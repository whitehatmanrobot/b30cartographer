          if (!CopyFile( (LPCTSTR) pInstance->QueryGroupListFile(),
                           (LPCTSTR) pOptions->szGroupListTmp,
                           FALSE ))
            {
                //
                // CopyFile failed, log an error, but don't delete group.lst.tmp
                //
                DWORD err = GetLastError();
                DebugTrace(0, "Instance %d: CopyFile() on group.lst.tmp failed %d", pInstance->QueryInstanceId(), err);
                pOptions->ReportPrint("Failed to copy %s to %s\n", pInstance->QueryGroupListFile(), pOptions->szGroupListTmp );
                
                PCHAR   args[2];
                args[0] = pInstance->QueryGroupListFile();
                args[1] = pOptions->szGroupListTmp,

                NntpLogEventEx( NNTP_COPY_FILE_FAILED,
                                2,
                                (const CHAR**)args,
                                err,
                                pInstance->QueryInstanceId() );

                goto exit;
            }
            else
            {
                DeleteFile( (LPCTSTR) pInstance->QueryGroupListFile() );
            }

            //
	        //	Start the instance only when there is no errors during rebuild
	        //
	        pInstance->m_BootOptions->IsReady = TRUE ;
	        if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) )
	        {
		        DebugTrace(0,"Starting instance %d after rebuild", pInstance->QueryInstanceId());
		        if(	!mb.SetDword( "", MD_SERVER_COMMAND, IIS_MD_UT_SERVER, MD_SERVER_COMMAND_START) )
		        {
			        //
			        //	failed to set server state to started
			        //
			        _ASSERT( FALSE );
                    mb.Close();
                    goto exit;
		        }
		        mb.Close();
	        }
            else
                goto exit;

	        //
	        //	wait for instance to start (timeout default is 2 min - reg config)
	        //

	        while( pInstance->QueryServerState() != MD_SERVER_STATE_STARTED ) {
		        Sleep( 1000 );
		        if( (((cSecs++)*1000) > dwStartupLatency ) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) goto exit;
	        }
        }
        else
        {
            ErrorTrace(0,"Error during Standard rebuild %d",pInstance->m_dwLastRebuildError);
            goto exit;
        }
    }
    else
    {

        //
        //	if clean rebuild, then erase all files
        //

        if ( DoClean ) {
		    if( !DeleteServerFiles( pInstance, pOptions, mb ) ) {
			    //
			    // handle error
			    //
			    fError = TRUE ;
			    ErrorTrace(0,"Error deleting server files");
			    goto exit ;
		    }
	    }

	    //
	    //	Start the instance for the rebuild
	    //	It should start since, we have cleaned out stuff !
	    //
	    pInstance->m_BootOptions->IsReady = TRUE ;
	    if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) )
	    {
		    DebugTrace(0,"Starting instance %d before rebuild", pInstance->QueryInstanceId());
		    if(	!mb.SetDword( "", MD_SERVER_COMMAND, IIS_MD_UT_SERVER, MD_SERVER_COMMAND_START) )
		    {
			    //
			    //	failed to set server state to started
			    //
			    _ASSERT( FALSE );
		    }
		    mb.Close();
	    }

	    //
	    //	wait for instance to start (timeout default is 2 min - reg config)
	    //

	    while( pInstance->QueryServerState() != MD_SERVER_STATE_STARTED ) {
		    Sleep( 1000 );
		    if( (((cSecs++)*1000) > dwStartupLatency ) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) goto exit;
	    }

	    //
	    //	now we have a clean server up, we will start the rebuild
	    //

	    _ASSERT( pInstance->QueryServerState() == MD_SERVER_STATE_STARTED );
	    pTree = pInstance->GetTree() ;
	    _ASSERT( pTree );
	    _ASSERT( lpstrGroupFile );

	    //
	    //	Rebuild the newstree
	    //

	    if( pTree->BuildTree( lpstrGroupFile ) )	{

    	    //
	        //	Do the rebuild
	        //

            pOptions->ReportPrint("Rebuilding Article and XOver map table...\n");

	        pOptions->m_hShutdownEvent = QueryShutdownEvent();
    	    pOptions->m_dwTotalFiles = dwTotalFiles;

            if ( RebuildArtMapAndXover( pInstance ) ) 
    	    {
                pOptions->ReportPrint("Done.\n");
            } else {
	    	    fError = TRUE;
                pOptions->ReportPrint("Failed.\n");
            }
	
	    } else {
		    fError = TRUE;
		    pOptions->ReportPrint( "NNTPBLD aborting due to error building news tree\n" ) ;

            //
            //  rebuild cancelled internally !
            //
        
		    pOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING ;
        }

	    //
	    //	If we aborted due to a cancel, delete all server files
	    //
        if ( (pOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING) /*&& DoClean*/ ) {

    	    //
    	    //	stop this instance
    	    //
    	
		    pInstance->m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL ;
		    if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) )
		    {
			    DebugTrace(0,"Stopping instance %d: Rebuild cancelled", pInstance->QueryInstanceId());
			    if(	!mb.SetDword( "", MD_SERVER_COMMAND, IIS_MD_UT_SERVER, MD_SERVER_COMMAND_STOP) )
			    {
				    //
				    //	failed to set server state to stopped
				    //
				    _ASSERT( FALSE );
			    }
			    mb.Close();

    	        //
	            //	wait for instance to stop (timeout default is 2 min - reg config)
	            //

                cSecs = 0;
			    while( pInstance->QueryServerState() != MD_SERVER_STATE_STOPPED ) {
				    Sleep( 1000 );
				    if( (((cSecs++)*1000) > dwStartupLatency) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) goto exit;
			    }

                if ( DoClean ) {
                    _ASSERT( pInstance->QueryServerState() == MD_SERVER_STATE_STOPPED );
			        if( !DeleteServerFiles( pInstance, pOptions, mb ) ) {
				        //
    				    // handle error
	    			    //
		    		    fError = TRUE ;
			    	    ErrorTrace(0,"Error deleting server files");
				        goto exit ;
			        }
			    }
			    pOptions->ReportPrint("Deleted server files\n");
		    }
		    goto exit ;
	    }

	}
    
    //
	//	rebuild done - re-enable posting
	//
	
	_ASSERT( pInstance->QueryServerState() == MD_SERVER_STATE_STARTED );
	if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
    	pInstance->SetPostingModes( mb, TRUE, TRUE, TRUE );
    	mb.Close();
   	}

exit:

    //
    //  Set last rebuild error
    //

    if (!pInstance->m_dwLastRebuildError)
        pInstance->m_dwLastRebuildError = GetLastError();
    
	//
	//	Use rebuild RPC crit sect to protect m_BootOptions
	//
	EnterCriticalSection( &pInstance->m_critRebuildRpc ) ;

	// NOTE: this is created on a rebuild RPC !
	if( pInstance->m_BootOptions ) {
		if( pInstance->m_BootOptions->m_hOutputFile ) {
			_VERIFY( CloseHandle( pInstance->m_BootOptions->m_hOutputFile ) );
		}
		XDELETE pInstance->m_BootOptions;
		pInstance->m_BootOptions = NULL;
	}

	LeaveCriticalSection( &pInstance->m_critRebuildRpc ) ;

	//
	//  The rebuild thread is done with this instance - deref it
	//  (This ref count was bumped up in the rebuild RPC)
	//
	pInstance->Dereference();
	
    return ;
#endif
}

#if 0
BOOL
VerifyTable(
    PHTABLE			ourTable,
	CBootOptions*	pOptions
    )
{
    pOptions->ReportPrint("\nProcessing %s table(%s)\n",
        ourTable->Description, ourTable->FileName);

#if 0 
    checklink( ourTable, pOptions );
    diagnose( ourTable, pOptions );
#endif
    return(TRUE);

} // VerifyTable

BOOL
RenameHashFile(
    PHTABLE			HTable,
	CBootOptions*	pOptions
    )
{
	char	szNewFileName[MAX_PATH*2] ;

	lstrcpy( szNewFileName, HTable->FileName ) ;
	char*	pchEnd = szNewFileName + lstrlen( szNewFileName ) ;
	while( *pchEnd != '.' && *pchEnd != '\\' ) 
		pchEnd -- ;

	if( *pchEnd == '.' ) {
		lstrcpy( pchEnd+1, "bad" ) ;
	}	else	{
		lstrcat( pchEnd, ".bad" ) ;
	}

    if (!MoveFileEx(
            HTable->FileName,
            szNewFileName,
            MOVEFILE_REPLACE_EXISTING
            ) ) {

        if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            pOptions->ReportPrint("Error %d in rename\n",GetLastError());
            return(FALSE);
        }

    } else {
        pOptions->ReportPrint("Renaming from %s to %s\n",HTable->FileName, HTable->NewFileName);
    }

    return(TRUE);

} // RenameHashFile
#endif

#if 0
BOOL
BuildCandidateFile(
			PNNTP_SERVER_INSTANCE 	pInstance,
			IIS_VROOT_TABLE*	 	pTable,	
			LPSTR				 	szFile,
			BOOL					fRejectEmpties,
			DWORD					ReuseIndexFiles,
			LPDWORD 				pdwTotalFiles,
			LPDWORD 				pdwCancelState,
			LPSTR   				szErrString
			) {
/*++

Routine Description : 

	This function scans the registry and builds a list of virtual roots which
	we will then recursively scan for candidate directories which we may want to 
	be newsgroups.

	This function calls the instance method - TsEnumVirtualRoots - which
	does the vroot recursive scan from the metabase.

	NOTE: The TsEnum code is stolen from infocomm - would be nice if base IIS
	class exposed this.

Arguments : 

	szFile -	Name of the file in which we will save candidates
	fRejectEmpties - If TRUE don't put empty interior directories into the list
		of candidates (empty leaf directories still placed in candidate file)

Return Value : 

	TRUE if successfull
	FALSE	otherwise.

--*/

	BOOL	fRet = TRUE;
	char	szCurDir[MAX_PATH*2] ;
	NNTPBLD_PARAMS NntpbldParams ;

	TraceFunctEnter("BuildCandidateFile");
	
	GetCurrentDirectory( sizeof( szCurDir ), szCurDir ) ;

	HANDLE	hOutputFile = 
		CreateFile( szFile, 
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ, 	
					NULL, 
					CREATE_ALWAYS, 
					FILE_FLAG_SEQUENTIAL_SCAN,
					NULL 
				) ;

	if( hOutputFile == INVALID_HANDLE_VALUE )	{
        ErrorTrace( 0, "Unable to create File %s due to Error %d.\n", szFile, GetLastError() ) ;
		return	FALSE ; 
	}

	//
	//	Build the nntpbld params blob
	//	This is made available to ScanRoot() by TsEnumVirtualRoots()
	//
	
	NntpbldParams.pTable = pTable;
	NntpbldParams.szFile = szFile;
	NntpbldParams.hOutputFile = hOutputFile;
	NntpbldParams.fRejectEmpties = fRejectEmpties;
	NntpbldParams.ReuseIndexFiles = ReuseIndexFiles;
	NntpbldParams.pdwTotalFiles = pdwTotalFiles;
	NntpbldParams.pdwCancelState = pdwCancelState;
	NntpbldParams.szErrString = szErrString;
	
	fRet = pInstance->TsEnumVirtualRoots( ScanRoot, (LPVOID)&NntpbldParams	);
	
	_VERIFY( CloseHandle( hOutputFile ) );
	SetCurrentDirectory( szCurDir ) ;

	TraceFunctLeave();
	return	fRet ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\chkhash.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    chkhash_H.h

Abstract:

    This module is the main include file for the chkhash

Author:

    Johnson Apacible (JohnsonA)     18-Dec-1995

Revision History:

--*/

#ifndef _CHKHASH_H_
#define _CHKHASH_H_


//
// table stats
//

typedef struct _HTABLE_TYPE {

    //
    // Description of the hash table
    //

    LPCSTR Description;

    //
    // file name the hash table uses
    //

    LPCSTR FileName;

    //
    // name of new table
    //

    LPCSTR NewFileName;


    //
    // hash table signature
    //

    DWORD  Signature;

    //
    // number of entries in the hash table
    //

    DWORD  Entries;

    //
    // total deletions and insertions
    //

    DWORD  TotDels;
    DWORD  TotIns;

    //
    // number of pages containing hash entries
    //

    DWORD  PagesUsed;

    //
    // current file size
    //

    DWORD  FileSize;

    //
    // depth of the directory
    //

    DWORD   DirDepth;

    //
    // list of problems discovered
    //

    DWORD  Flags;

} HTABLE, *PHTABLE;

//
// Flags
//

#define HASH_FLAG_BAD_LINK             0x00000001
#define HASH_FLAG_BAD_SIGN             0x00000002
#define HASH_FLAG_BAD_SIZE             0x00000004
#define HASH_FLAG_CORRUPT              0x00000008
#define HASH_FLAG_NOT_INIT             0x00000010
#define HASH_FLAG_BAD_HASH             0x00000020
#define HASH_FLAG_BAD_ENTRY_COUNT      0x00000040
#define HASH_FLAG_BAD_PAGE_COUNT       0x00000080
#define HASH_FLAG_BAD_DIR_DEPTH        0x00000100

#define HASH_FLAG_NO_FILE              0x00000200

//
// If this is set, then no rebuilding is to take place
// because of a fatal error.
//

#define HASH_FLAG_ABORT_SCAN           0x80000000

//
// These flags indicate that the file is corrupt and should
// be rebuilt
//

#define HASH_FLAGS_CORRUPT             (HASH_FLAG_BAD_LINK | \
                                        HASH_FLAG_BAD_SIGN | \
                                        HASH_FLAG_BAD_SIZE | \
                                        HASH_FLAG_CORRUPT |  \
                                        HASH_FLAG_NOT_INIT | \
                                        HASH_FLAG_BAD_HASH | \
                                        HASH_FLAG_BAD_ENTRY_COUNT)

//
// hash types
//

enum filetype {
        artmap = 0,
        histmap = 1,
        xovermap = 2
        };


//
// function prototypes
//

BOOL
RebuildArtMapAndXover(
	PNNTP_SERVER_INSTANCE pInstance
    );

BOOL
RebuildGroupList(
	PNNTP_SERVER_INSTANCE pInstance
    );

#if 0
BOOL
checklink(
    PHTABLE HTable,
	class	CBootOptions*
    );


BOOL
RebuildArtMapFromXOver(
	PNNTP_SERVER_INSTANCE pInstance,
    class	CBootOptions*,
	LPSTR   lpXoverFilename
    );

BOOL
diagnose(
    PHTABLE HTable,
	class	CBootOptions*
    );

BOOL
RenameAllArticles(
	CNewsTree* pTree,
	CBootOptions*	pOptions
	) ;

#endif

#endif // _CHKHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\cio.cpp ===
/*++

Module Name :

	cio.cpp

Abstract :

	
	This module contains all of the non-inline code for all CIO
	derived classes.  Each CIO derived class represents an abstract
	IO operation such as - read a line of text and parse it,
	read an article, write an article etc...
	All of those classes derived from CIOPassThru are used in conjunction
	with CIODriverSource objects to handle encryption issues.

Author :

	Neil Kaethler

Revision History :


--*/


#include	"tigris.hxx"

#ifdef	CIO_DEBUG
#include	<stdlib.h>		// For Rand() function
#endif

CPool	CCIOAllocator::IOPool(CIO_SIGNATURE) ;
CCIOAllocator	gCIOAllocator ;
CCIOAllocator*	CCIOCache::gpCIOAllocator = &gCIOAllocator ;

DWORD	CIO::cbSmallRequest = 400 ;
DWORD	CIO::cbMediumRequest = 4000 ;
DWORD	CIO::cbLargeRequest = 32000 ;


const	unsigned	cbMAX_IO_SIZE = MAX_IO_SIZE ;

CCIOAllocator::CCIOAllocator()	{
}

#ifdef	DEBUG
void
CCIOAllocator::Erase(
					void*	lpv
					)	{

	FillMemory( (BYTE*)lpv, cbMAX_IO_SIZE, 0xCC ) ;

}

BOOL
CCIOAllocator::EraseCheck(
					void*	lpv
					)	{

	DWORD	cb = cbMAX_IO_SIZE ;
	
	for( DWORD	j=sizeof(CPool*); j < cb; j++ ) {
		if(	((BYTE*)lpv)[j] != 0xCC )
			return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CCIOAllocator::RangeCheck(
					void*	lpv
					)	{

	return	TRUE ;

}

BOOL	
CCIOAllocator::SizeCheck(	DWORD	cb )	{

	return	cb <= cbMAX_IO_SIZE ;

}
#endif

BOOL
CIO::InitClass(	)		{
/*++

Routine Description :

	Initialize the CPool object used to allocate CIO objects.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	cbSmallRequest = CBufferAllocator::rgPoolSizes[0] - 50 ;
	cbMediumRequest = CBufferAllocator::rgPoolSizes[1] - 50 ;
	cbLargeRequest = CBufferAllocator::rgPoolSizes[2] - 50 ;

	return	CCIOAllocator::InitClass() ;
}

BOOL
CIO::TermClass()	{
/*++

Routine Description :

	Release all memory associated with the CPool object used
	to allocate CIO OBJECTs.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	return	CCIOAllocator::TermClass() ;
}

CIO::~CIO()	{
/*++

Routine Description :

	Class Destructor
	
Arguments :

	None.

Return Value :

	None.

--*/


	TraceFunctEnter( "CIO::~CIO" ) ;
	DebugTrace( (DWORD_PTR)this, "Destroy CIO" ) ;


	//
	//	Make sure there are no references left when we are destroyed.
	//	CIO objects are manipulated through a combination of smart pointers
	//	and regular pointers, so we need to be carefull that there are no bugs
	//	where the object is destroyed through a regular pointer while a smart pointer
	//	has a reference.
	//

	_ASSERT( m_refs == -1 ) ;

}

int
CIO::Complete(	CSessionSocket*	pSocket,
				CReadPacket*	pRead,	
				CIO*	&pio	)		{
/*++

Routine Description :

	For derived classes this function will do whatever processing
	is required when a Read Completes.  The CReadPacket will contain
	pointers to the data which was read.   If a CReadPacket is issued
	by a CIO object this function must be overridden.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	This function must be overridden by derived classes if they issue CReadPacket's
	//
	DebugBreak() ;
	return	0 ;
}


int
CIO::Complete(	CSessionSocket*	pSocket,
				CWritePacket*	pRead,	
				CIO*	&pio	)		{
/*++

Routine Description :

	For derived classes this function will do whatever processing
	is required when a Write Completes.  The CWritePacket will contain
	pointers to the data which was written.   If a CWritePacket is issued
	by a CIO object this function must be overridden.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet in which the written data resided.
			  This data may no longer be usable.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	//
	//	This function must be overridden by derived classes if they issue CWritePackets
	//
	DebugBreak() ;
	return	0 ;
}


void
CIO::Complete(	CSessionSocket*	pSocket,	
				CTransmitPacket*	pTransmit,	
				CIO*	&pio )	{
/*++

Routine Description :

	For derived classes this function will do whatever processing
	is required when a TransmitFile Completes.  The CTransmitPacket will contain
	the file handle etc. of whatever file was transmitted..

Arguments :
	
	pSocket - The socket against which the IO was issued
	pTransmit-The packet which describes the TransmitFile operation
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	None.

--*/


	//	
	//	This function must be overridden by derived classes if they issue CTransmitPackets
	//	(NOTE : can't partially complete a CTransmitPacket, that's why the return type is
	//	void).
	//
	DebugBreak() ;
}



void
CIO::Complete(	CSessionSocket*	pSocket,	
				CExecutePacket*	pExecute,	
				CIO*	&pio )	{
/*++

Routine Description :

	For derived classes which have deferred execution of something !

Arguments :
	
	pSocket - The socket against which the IO was issued
	pExecute- The packet which describes the Deferred operation
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	None.

--*/


	//	
	//	This function must be overridden by derived classes if they issue CExecutePackets
	//	(NOTE : can't partially complete a CExecutePackets, that's why the return type is
	//	void).
	//
	DebugBreak() ;
}





void
CIO::Shutdown(	CSessionSocket*	pSocket,	
				CIODriver&	pdriver,	
				SHUTDOWN_CAUSE	cause,
				DWORD	dwErrorCode	 ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	This will give derived classes a chance to close or destroy
	any objects they may be using.

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	DebugBreak() ;
}		

void
CIO::DoShutdown(	CSessionSocket*	pSocket,	
					CIODriver&		driver,	
					SHUTDOWN_CAUSE	cause,
					DWORD	dwErrorCode	 ) {
/*++

Routine Description :

	This function is called by CIODriver's to signal termination of a session.
	We will call the derived classes Shutdown() function after we have given
	the current state a chance to process the Shutdown as well.

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	//	Now call the controlling state's shutdown method !
	if( m_pState != 0 ) {
		m_pState->Shutdown( driver, pSocket, cause, dwErrorCode ) ;
	}

	Shutdown( pSocket, driver, cause, dwErrorCode ) ;
}		


BOOL
CIOShutdown::Start( CIODriver& driver,
					CSessionSocket*	pSocket,
					unsigned cAhead ) {
/*++

Routine Description :

	This function is called to start a CIO object.
	The CIO object should create and Issue whatever packets
	it needs to accomplish its function.
	In the case of CIOShutdown, we exist solely to ease CIODriver
	termination, and do not issue any Packets.

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.


return Value :

	TRUE if successfull, FALSE otherwise

--*/

	//
	//	Shutdown State - so do nothing but keep things apparently moving !
	//
	TraceFunctEnter( "CIOShutdown::Start" ) ;
	DebugTrace( (DWORD_PTR)this, "Start shutdown on driver %x pSocket %x", &driver, pSocket ) ;
	return	TRUE ;
}


BOOL	
CIOShutdown::InitRequest(
			class	CIODriverSource&	driver,	
			CSessionSocket*	pSocket,	
			CReadPacket*	pPacket,	
			BOOL&	fAcceptRequests
			)	{
/*++

Routine Description :

	Somebody is still trying to issue IO's even though
	we are closing things down.  Fail the request and
	keep things moving.

Arguments :

	driver - driver controlling IO completions
	pSocket - Socket IO is associated with
	pPacket - the request packet
	fAcceptRequests - OUT parameter indicating whether
		we will Init more requests - return TRUE here

Return Value :

	Always FALSE, the IO Request was failed.

--*/

	fAcceptRequests = TRUE ;
	return	FALSE ;

}

BOOL	
CIOShutdown::InitRequest(
			class	CIODriverSource&	driver,	
			CSessionSocket*	pSocket,	
			CWritePacket*	pWritePacket,	
			BOOL&	fAcceptRequests
			)	{
/*++

Routine Description :

	Somebody is still trying to issue IO's even though
	we are closing things down.  Fail the request and
	keep things moving.

Arguments :

	driver - driver controlling IO completions
	pSocket - Socket IO is associated with
	pPacket - the request packet
	fAcceptRequests - OUT parameter indicating whether
		we will Init more requests - return TRUE here

Return Value :

	Always FALSE, the IO Request was failed.

--*/

	fAcceptRequests = TRUE ;
	return	FALSE ;

}


BOOL	
CIOShutdown::InitRequest(
			class	CIODriverSource&	driver,	
			CSessionSocket*	pSocket,	
			CTransmitPacket*	pTransmitPacket,	
			BOOL&	fAcceptRequests	
			)	{
/*++

Routine Description :

	Somebody is still trying to issue IO's even though
	we are closing things down.  Fail the request and
	keep things moving.

Arguments :

	driver - driver controlling IO completions
	pSocket - Socket IO is associated with
	pPacket - the request packet
	fAcceptRequests - OUT parameter indicating whether
		we will Init more requests - return TRUE here

Return Value :

	Always FALSE, the IO Request was failed.

--*/

	fAcceptRequests = TRUE ;
	return	FALSE ;
}




int		
CIOShutdown::Complete(	IN CSessionSocket* pSocket,
						IN	CReadPacket*	pPacket,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest ) {
/*++

Routine Description :

	Swallow the packets !! We only help to make sure all packets are
	consumed during CIODriver termination.
	This function is for use with CIODriverSource objects.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The packet containing the completed packet.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.
	pRequest -The request packet which start us off.
	fCompleteRequest - an Out parameter - set to TRUE to indicate
			  the request should be completed !

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	Consume the packet !
	//
	
	fCompleteRequest = TRUE ;
	//
	//	Zero bytes transferred - the operation failed !!
	//
	pRequest->m_cbBytes = 0 ;

	TraceFunctEnter( "CIOShutdown::Complete - CReadPacket" ) ;
	DebugTrace( (DWORD_PTR)this, "read complete shutdown on pSocket %x pPacket %x driver %x", pSocket, pPacket, &(*pPacket->m_pOwner) ) ;
	return	pPacket->m_cbBytes ;
}

int		
CIOShutdown::Complete(	IN CSessionSocket* pSocket,
						IN	CReadPacket*	pPacket,	
						OUT	CIO*	&pio ) {
/*++

Routine Description :

	Swallow the packet - consume all the bytes

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The completed packet
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	Consume the packet
	//
	TraceFunctEnter( "CIOShutdown::Complete - CreadPacket" ) ;
	DebugTrace( (DWORD_PTR)this, "read complete on pSock %x pPacket %x m_pOwner %x", pSocket, pPacket, &(*pPacket->m_pOwner) ) ;
	return	pPacket->m_cbBytes ;
}

int		
CIOShutdown::Complete(	IN CSessionSocket*	pSocket,
						IN	CWritePacket*	pPacket,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest )	{
/*++

Routine Description :

	Swallow the packets !! We only help to make sure all packets are
	consumed during CIODriver termination.
	This function is for use with CIODriverSource objects.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The packet containing the completed packet.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.
	pRequest -The request packet which start us off.
	fCompleteRequest - an Out parameter - set to TRUE to indicate
			  the request should be completed !

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	Consume the packet always !
	//	
	pRequest->m_cbBytes = 0 ;
	fCompleteRequest = TRUE ;

	TraceFunctEnter( "CIOShutdown::Complete - CWritePacket" ) ;
	DebugTrace( (DWORD_PTR)this, "Write Complete on pSock %x pPacket %x m_pOwner %x", pSocket, pPacket, &(*pPacket->m_pOwner) ) ;
	return	pPacket->m_cbBytes ;
}

int		
CIOShutdown::Complete(	IN CSessionSocket*	pSocket,
						IN	CWritePacket*	pPacket,	
						OUT	CIO*	&pio )	{
/*++

Routine Description :

	Swallow the packet - consume all the bytes

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The completed packet
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	Consume the packet always !
	//
	TraceFunctEnter( "CIOShutdown::Complete - CWritePacket" ) ;
	DebugTrace( (DWORD_PTR)this, "Write Complete on pSock %x pPacket %x m_pOwner %x", pSocket, pPacket, &(*pPacket->m_pOwner) ) ;
	return	pPacket->m_cbBytes ;
}

void	CIOShutdown::Complete(	IN CSessionSocket*,
								IN	CTransmitPacket*	pPacket,	
								CPacket*	pRequest,	
								BOOL&	fCompleteRequest ) {
/*++

Routine Description :

	Swallow the packets !! We only help to make sure all packets are
	consumed during CIODriver termination.
	This function is for use with CIODriverSource objects.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The packet containing the completed packet.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.
	pRequest -The request packet which start us off.
	fCompleteRequest - an Out parameter - set to TRUE to indicate
			  the request should be completed !

return Value :

	None. (always assumed to be consumed by caller !)

--*/

	//
	//	Consume the packet - pretty easy to do !
	//
	fCompleteRequest = TRUE ;
	pRequest->m_cbBytes = 0 ;


}

void	CIOShutdown::Complete(	IN CSessionSocket*,
								IN	CTransmitPacket*	pPacket,	
								OUT	CIO*	&pio ) {
/*++

Routine Description :

	Swallow the packet - consume all the bytes

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The completed packet
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	None. (always assumed to be consumed by caller !)

--*/

	//
	//	Consume the packet !
	//
}

void	CIOShutdown::Complete(	IN CSessionSocket*,
								IN	CExecutePacket*	pPacket,	
								OUT	CIO*	&pio ) {
/*++

Routine Description :

	Swallow the packet - consume all the bytes

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The completed packet
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	None. (always assumed to be consumed by caller !)

--*/

	//
	//	Consume the packet !
	//
	_ASSERT( pPacket != 0 ) ;
	if( pPacket->m_pWrite != 0 ) 	{
		pPacket->m_pOwner->DestroyPacket( pPacket->m_pWrite ) ;
		pPacket->m_pWrite = 0 ;
	}
	pPacket->m_pOwner->DestroyPacket( pPacket ) ;
}



//
//	Maximum number of pending reads while reading an article
//
unsigned	CIOGetArticle::maxReadAhead = 3 ;
//
//	Number of bytes to accumulate before writing to a file !
//
unsigned	CIOGetArticle::cbTooSmallWrite = 4000 ;
//
//	The pattern which marks the end of an article
//
char		CIOGetArticle::szTailState[] = "\r\n.\r\n" ;
//
//	The pattern which marks the end of the head of an article
//	
char		CIOGetArticle::szHeadState[] = "\r\n\r\n" ;

CIOGetArticle::CIOGetArticle(
						CSessionState*	pstate,
						CSessionSocket*	pSocket,	
						CDRIVERPTR&	pDriver,
						LPSTR			lpstrTempDir,
						char			(&szTempName)[MAX_PATH],
						DWORD			cbLimit,
						BOOL			fSaveHead,
						BOOL			fPartial )	:
/*++

Routine Description :

	Class Constructor

Arguments :
	
	pstate - The State which is issuing us and who's completion function
			we should later call
	pSocket -	The socket on which we will be issued
	pDriver -	The CIODriver object handling all of the socket's IO
	pFileChannel -	The File Channel into which we should save all data
	fSaveHead - TRUE if we want the HEAD of the article placed in a buffer !
	fPartial	- If TRUE then we should assume that a CRLF has already
				been sent and '.\r\n' alone can terminate the article.

Return Value :
	
	None

--*/

	//
	//	Get a CIOGetArticle object half way set up - user still needs
	//	to call Init() but we will do much here !
	//
	CIORead( pstate ),
	m_lpstrTempDir( lpstrTempDir ),
	m_szTempName( szTempName ),
	m_pFileChannel( 0 ),	
	m_pFileDriver( 0 ),
	m_pSocketSink( pDriver ),
	m_fDriverInit( FALSE ),
	m_cwrites( 0 ),
	m_cwritesCompleted( 0 ),
	m_cFlowControlled( LONG_MIN ),
	m_fFlowControlled( FALSE ),
	m_cReads( 0 ),
	m_pWrite( 0 ),
	m_cbLimit( cbLimit ),
	m_pchHeadState( 0 ),
	m_ibStartHead( 0 ),
	m_ibStartHeadData( 0 ),
	m_ibEndHead( 0 ),
	m_ibEndHeadData( 0 ),
	m_ibEndArticle( 0 ),
	m_cbHeadBytes( 0 ),
	m_cbGap( 0 )
#ifdef	CIO_DEBUG
	,m_fSuccessfullInit( FALSE ),
	m_fTerminated( FALSE )
#endif
{

	_ASSERT( m_lpstrTempDir != 0 ) ;
	m_szTempName[0] = '\0' ;

	ASSIGNI(m_HardLimit, 0);

	if( fPartial )
		m_pchTailState = &szTailState[2] ;
	else	
		m_pchTailState = &szTailState[0] ;


	if( fSaveHead ) {
		m_fAcceptNonHeaderBytes = TRUE ;
		m_pchHeadState = &szHeadState[0] ;
	}

	TraceFunctEnter( "CIOGetArticle::CIOGetArticle" ) ;

	_ASSERT( m_pFileDriver == 0 ) ;
	_ASSERT( pstate != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pDriver != 0 ) ;

}

CIOGetArticle::~CIOGetArticle( )	{
/*++

Routine Description :

	Class Destructor

Arguments :
	
	None

Return Value :
	
	None

--*/

	//
	//	Destroy a CIOGetArticle - always close our m_pFileDriver if possible
	//	in case we are terminated due to some socket error.
	//
	TraceFunctEnter( "CIOGetArticle::~CIOGetArticle" ) ;

#ifdef	CIO_DEBUG
	//
	//	Our destructor should only be called if we weren't successfully init
	//	or after Term() has been called.
	//
	_ASSERT( !m_fSuccessfullInit || m_fTerminated ) ;
#endif

	DebugTrace( (DWORD_PTR)this, "m_pFileDriver %x m_fDriverInit %x", m_pFileDriver, m_fDriverInit ) ;

	if( m_pFileDriver != 0 ) {
		if( m_fDriverInit )		{
			m_pFileDriver->UnsafeClose( (CSessionSocket*)this, CAUSE_NORMAL_CIO_TERMINATION, 0, FALSE ) ;
		}
	}
	if( m_pWrite != 0 ) {
		CPacket::DestroyAndDelete( m_pWrite ) ;
		m_pWrite = 0 ;
	}
}

void
CIOGetArticle::Term(	CSessionSocket*	pSocket,
						BOOL			fAbort,
						BOOL			fStarted	)	{
/*++

Routine Description :

	Start destroying a successfully initialize CIOGetArticle object

Arguments :
	
	fAbort - If TRUE then destroy the socket which we were using
			If FALSE then only close down our File Channel's

Return Value :

	None

--*/
#ifdef	CIO_DEBUG
	m_fTerminated = TRUE ;
#endif
	//
	//	Start us on our way to destruction !!
	//	If we have been successfully Initialized, then this will
	//	lead to our destruction when our m_pFileDriver eventually shutsdown.
	//	(Since we were succesfully Init() our m_pFileDriver has a reference to us,
	//	so we must allow it to shutdown and destroy us to avoid problems with
	//	circular references and multiple frees !)
	//

	if( m_pFileDriver != 0 ) {
		m_pFileDriver->UnsafeClose( pSocket,
				fAbort ? CAUSE_USERTERM : CAUSE_NORMAL_CIO_TERMINATION, 0, fAbort ) ;
	}
}


void
CIOGetArticle::Shutdown(	CSessionSocket*	pSocket,	
							CIODriver&		driver,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dwOptional )	{
/*++

Routine Description :

	Do whatever work is necessary when one of the two CIODriver's we are
	using is terminated.

Arguments :

	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	TraceFunctEnter( "CIOGetArticle::Shutdown" ) ;
	DebugTrace( (DWORD_PTR)this, "SHutdown args - pSocket %x driver %x cause %x dw %x",
			pSocket, &driver, cause, dwOptional ) ;

	//
	//	This function is called when the CIODriver's we are refenced by our closing down.
	//	Since we are referenced by two of them (one for the socket and one for the file)
	//	we only want to be deleted by the CIODriver for the file.
	//
	if( &driver == m_pFileDriver )	{
		// Out file is closing - what can we do about it !
		//_ASSERT( 1==0 ) ;
#ifdef	CIO_DEBUG
		m_fTerminated = TRUE ;
#endif

		//
		//	We set this to 0 here as we know we will be called here by
		//	the same thread that is completing writes to the file - so
		//	since that's the only thread referencing this member variable -
		//	there are no thread safety issues accessing that member.
		//

		m_pSocketSink = 0 ;

		if ( m_fFlowControlled )
		{
			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );
		}

	}	else	{
		// Close down the rest of our stuff as well !!
		Term( pSocket, cause != CAUSE_NORMAL_CIO_TERMINATION ) ;
	}
}

void
CIOGetArticle::ShutdownFunc(	void *pv,	
								SHUTDOWN_CAUSE	cause,	
								DWORD dw ) {
/*++

Routine Description :

	Notification function which is called when a CIODriver used by
	a CIOGetArticle if finally destroyed.  This function is provided
	to the CIODriver we use for File IO's during out Init().

Arguments :

	pv	-	Pointer to dead CIOGetArticle - this has been destroyed dont use !
	cause -	The reason for termination
	dw		Optional extra information regarding termination

Return Value :

	None

--*/

	TraceFunctEnter( "CIOGetArticle::ShutdownFunc" ) ;
	//
	//	This function gets notified when a CIOFileDriver used by CIOGetArticle
	//	is terminated.  Not much for us to worry about.
	//	(CIODriver's require these functions)
	//

	//_ASSERT( 1==0 ) ;
	return ;
}

BOOL
CIOGetArticle::Start(	CIODriver&	driver,	
						CSessionSocket	*pSocket,	
						unsigned cReadAhead )	{
/*++

Routine Description :

	This function is called to start transferring data from the socket
	into the file.

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/


	_ASSERT( pSocket != 0 ) ;

	m_cReads = -((long)maxReadAhead) + cReadAhead ;

	while( cReadAhead < maxReadAhead )	{
		//
		//	Start reading data from the socket
		//
		CReadPacket*	pRead = driver.CreateDefaultRead( cbMediumRequest ) ;
		if( 0!=pRead )	{
			BOOL	eof ;
			pRead->m_dwExtra1 = 0 ;
			driver.IssuePacket( pRead, pSocket, eof ) ;
			cReadAhead++ ;
			InterlockedIncrement( &m_cReads ) ;
		}	else	{
			//
			// This is a fatal problem only if we couldn't issue ANY reads at all !
			//
			if( cReadAhead == 0 )
				return FALSE  ;
		}
	}	
	return	TRUE ;
}

const	unsigned	MAX_OUTSTANDING_FILE_WRITES	= 8 ;	
const	unsigned	RESTORE_FLOW = 2 ;

void
CIOGetArticle::DoFlowControl( PNNTP_SERVER_INSTANCE pInstance )	{
/*++

Routine Description :

	Check whether it is necessary to set flow control due to
	too many outstanding writes.
	If necessary, then the first time we do put ourselves into Flow Control,
	try to flush our pending writes.
	We should be called only immediately before issuing an Async Write to the file
	to ensure that a CWritePacket completion will actually execute the necessary
	code to restart a flow controlled session.
	(Otherwisse, we could potentially decide to Flow control the session
	and before setting m_fFlowControlled to TRUE all the pending writes complete
	and then we'd be left in a boat where there are no pending reads or
	writes and no way to get out of the flow control state.)

Arguments :

	None.

Return Value :

	None.


--*/

	//
	//	Important - do all tests of m_fFlowControlled before setting
	//	m_cFlowControlled - as other thread will touch m_cFlowControlled
	//	before touching m_fFlowControlled !!
	//	(Will only touch m_fFlowControlled if m_fFlowControlled is TRUE ) !
	//	Thus we know that if m_fFlowControlled is FALSE there is nobody
	//	messing with m_cFlowControlled,
	//
	//

	if( m_cwrites - m_cwritesCompleted > MAX_OUTSTANDING_FILE_WRITES ) {
		
		if( m_fFlowControlled ) {
			// All ready have flow control turned on
			;
		}	else	{
			m_cFlowControlled = -1 ;
			m_fFlowControlled = TRUE ;
			m_pFileChannel->FlushFileBuffers() ;

			IncrementStat( pInstance, SessionsFlowControlled );
		}
	}	else	{
		if( !m_fFlowControlled ) {
			m_cFlowControlled = LONG_MIN ;	// Keep resetting !
		}
	}
}

inline	DWORD
CIOGetArticle::HeaderSpaceAvailable()	{
/*++

Routine Description :

	Compute the amount of space available in the buffer we are using
	to hold the article header !

Arguments :

	None.

Return Value :

	number of bytes available, 0 if we aren't collecting article headers !

--*/

	if( m_pArticleHead != 0 ) {

		return	m_ibEndHead - m_ibEndHeadData ;

	}
	return	0 ;
}

inline	void
CIOGetArticle::FillHeaderSpace(
						char*	pchStart,
						DWORD	cbBytes
						) {
/*++

Routine Description :

	Copy bytes into the header storage area !!
	Caller should ensure that this will fit !!
	
Arguments :

	pchStart - Start of bytes to be copied !
	cbBytes -	Number of bytes to copy !

Return Value :

	None.

--*/

	_ASSERT( m_pArticleHead != 0 ) ;
	_ASSERT( cbBytes + m_ibEndHeadData < m_ibEndHead ) ;

	CopyMemory( m_pArticleHead->m_rgBuff + m_ibEndHeadData,
				pchStart,
				cbBytes
				) ;

	m_ibEndHeadData += cbBytes ;
}

inline	void
CIOGetArticle::InitializeHeaderSpace(
						CReadPacket*	pRead,
						DWORD			cbArticleBytes
						) {
/*++

Routine Description  :

	Given a read packet which contains our first completed read,
	set up all our buffer start for holding header information !
	
Arguments :

	CReadPackets*	pRead - the completed read !
	cbArticleBytes - Number of bytes in the completed read making up the article !

Return Value :

	None.
	
--*/


	_ASSERT( m_pArticleHead == 0 ) ;
	_ASSERT( m_ibStartHead == 0 ) ;
	_ASSERT( m_ibEndHead == 0 ) ;
	_ASSERT( m_ibStartHeadData == 0 ) ;
	_ASSERT( m_ibEndHeadData == 0 ) ;
	_ASSERT( m_cbHeadBytes == 0 ) ;
	_ASSERT( cbArticleBytes <= (pRead->m_ibEndData - pRead->m_ibStartData)) ;

	m_pArticleHead = pRead->m_pbuffer ;

	m_ibStartHead = pRead->m_ibStart ;
	m_ibStartHeadData = pRead->m_ibStartData ;
	m_ibEndHeadData = pRead->m_ibStartData + cbArticleBytes ;

	if( m_ibEndHeadData < pRead->m_ibEndData )
		m_ibEndHead = m_ibEndHeadData ;
	else
		m_ibEndHead = pRead->m_ibEnd ;

}

inline	BOOL
CIOGetArticle::GetBiggerHeaderBuffer(
							CIODriver&	driver,
							DWORD		cbRequired
							) {
/*++

Routine Description :

	We have too much data to fit into the buffer we are using to hold
	header information.  So try to get a bigger buffer and move
	our old data into that buffer !

Arguments :

	driver - A CIODriverSink we can use to allocate buffers !

Return Value :

	TRUE if successfull,
	FALSE otherwise.
	If we fail we leave member variables untouched.

--*/

	_ASSERT( m_pArticleHead != 0 ) ;

	CBuffer*	pTemp = 0 ;

	DWORD	cbRequest = cbMediumRequest ;

	if( (m_pArticleHead->m_cbTotal + cbRequired)  > cbMediumRequest )	{
		cbRequest = cbLargeRequest ;
	}

	if( cbRequest < (cbRequired + (m_ibEndHeadData - m_ibStartHeadData)) ) {
		return	FALSE ;
	}

	pTemp = driver.AllocateBuffer( cbRequest ) ;

	if( pTemp != 0 ) {

		DWORD	cbToCopy = m_ibEndHeadData - m_ibStartHeadData ;
		CopyMemory( pTemp->m_rgBuff,
					&m_pArticleHead->m_rgBuff[ m_ibStartHeadData ],
					cbToCopy
					) ;

		m_ibStartHead = 0 ;
		m_ibStartHeadData = 0 ;
		m_ibEndHead = pTemp->m_cbTotal ;
		m_ibEndHeadData = cbToCopy ;
		m_pArticleHead = pTemp ;

		return	TRUE ;
	}

	return	FALSE ;
}

inline	BOOL
CIOGetArticle::ResetHeaderState(
						CIODriver&	driver
						)	{
/*++

Routine Description :

	This function is called when for some reason an error occurred
	and we wont be able to save the header info for the article.
	We will set all the member variables so that we will continue
	to read the article, however when we finally call the state's completion
	procedure we will tell them an error occurred, and the article
	transfer will fail.

Arguments :

	driver - CIODriverSink that can be used to allocate packets etc !

Return Value :

	None.

--*/

	//
	//	Should only be called before we have started issuing file IO's,
	//	after we start issuing file IO's we should have all the header
	//	data and should not hit errors that would result in our being
	//	called !!!
	//
	_ASSERT( m_pFileDriver == 0 ) ;

	if( m_pArticleHead ) {
		//
		//	If we have an existing buffer - turn it into a write packet
		//	that can be written to the hard disk
		//

		m_pWrite = driver.CreateDefaultWrite(
								m_pArticleHead,
								m_ibStartHead,
								m_ibEndHead,
								m_ibStartHeadData,
								m_ibEndHeadData
								) ;

		if( m_pWrite ) {

			m_pArticleHead = 0 ;
			m_ibStartHead = 0 ;	
			m_ibEndHead = 0 ;
			m_ibStartHeadData = 0;
			m_ibEndHeadData = 0 ;
			m_pchHeadState = 0 ;
			return	TRUE ;

		}	else	{

			return	FALSE ;

		}

	}	else	{
		//
		//	Should already be in a good state !
		//

		_ASSERT( m_pArticleHead == 0 ) ;
		_ASSERT( m_ibStartHead == 0 ) ;
		_ASSERT( m_ibStartHeadData == 0 ) ;
		_ASSERT( m_ibEndHead == 0 ) ;
		_ASSERT( m_ibEndHeadData == 0 ) ;

		m_pchHeadState = 0 ;

	}

	return	TRUE ;
}

void
CIOGetArticle::DoCompletion(
					CSessionSocket*	pSocket,
					HANDLE	hFile,
					DWORD	cbFullBuffer,
					DWORD	cbTotalTransfer,
					DWORD	cbAvailableBuffer,
					DWORD	cbGap
					) {
/*++

Routine Description :

	Call the State's completion function with all the correct
	arguments.

Arguments :
	
	hFile - Handle to the file we used, if we used one !!
		(This will be INVALID_HANDLE_VALUE if no file required !)

Return Value :

	None.

--*/

	//
	//	Figure out error codes if the article looks bad !
	//

	NRC		nrc	= nrcOK ;

	char*	pchHead = 0 ;
	DWORD	cbHeader = 0 ;
	DWORD	cbArticle = 0 ;
	DWORD	cbTotal = 0 ;

	if( m_pArticleHead == 0 ) {
		nrc = nrcHeaderTooLarge ;
	}	else	{

		if( m_pchHeadState != 0 ) {
			nrc = nrcArticleIncompleteHeader ;
		}

		pchHead = &m_pArticleHead->m_rgBuff[m_ibStartHeadData] ;
		cbHeader = m_cbHeadBytes ;
		if( cbAvailableBuffer == 0 )
			cbAvailableBuffer = m_pArticleHead->m_cbTotal - m_ibStartHeadData ;

		//
		//	If there's no file handle, we should have the entire
		//	article in our buffer !!
		//
		if( hFile == INVALID_HANDLE_VALUE ) {

			cbArticle = cbFullBuffer ;

			_ASSERT( cbArticle >= cbHeader ) ;

		}

	}

	//
	//	Call the state's completion function !!
	//

	m_pState->Complete(
						this,
						pSocket,
						nrc,
						pchHead,
						cbHeader,
						cbArticle,
						cbAvailableBuffer,
						hFile,
						cbGap,
						cbTotalTransfer
						) ;
}

BOOL
CIOGetArticle::InitializeForFileIO(
							CSessionSocket*	pSocket,
							CIODriver&		readDriver,
							DWORD			cbHeaderBytes
							)	{
/*++

Routine Description :

	We've been reading data into Ram buffers, and we have gotten so
	much that we've decided not to try to hold it all in RAM.
	So now we must start doing writes to a file somewhere.
	This code will create the file, and set up the necessary
	data structures for processing completed file IO.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	_ASSERT( m_lpstrTempDir != 0 ) ;

	if( !NNTPCreateTempFile( m_lpstrTempDir, m_szTempName ) ) {
		return	FALSE ;
	}

#if 0
	HANDLE	hFile = CreateFile( m_szTempName,
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								0,
								CREATE_ALWAYS,
								FILE_FLAG_OVERLAPPED,
								INVALID_HANDLE_VALUE
								) ;

	if( hFile != INVALID_HANDLE_VALUE ) {

		DWORD	cbGap = m_cbGap ;

		m_pFileChannel = new	CFileChannel() ;
		if( m_pFileChannel->Init(	hFile,
									pSocket,
									cbGap,
									FALSE
									) ) {

			//
			//	Try to create the CIODriver we are going to use to	
			//	complete our async writes !!!
			//

			m_pFileDriver = new CIODriverSink(
										readDriver.GetMediumCache()
										) ;



			if( m_pFileDriver->Init(	m_pFileChannel,
										pSocket,
										ShutdownFunc,
										(void*)this
										) ) {
				m_fDriverInit = TRUE ;

				if( m_pSocketSink != 0 ) {
					//
					//	Now we have to send ourselves into the CIODriverSink() !
					//
					if( m_pFileDriver->SendWriteIO( pSocket, *this, FALSE ) ) {
						return	TRUE ;
					}
				}
			}
		}
	}
#endif

	//
	//	All clean up in error cases is handled by our destructor !
	//
	return	FALSE ;
}



int
CIOGetArticle::Complete(	CSessionSocket*	pSocket,	
							CReadPacket	*pRead,	
							CIO*&	pio	)	{
/*++

Routine Description :

	Called whenever a CReadPacket we have issued completes.
	We only issue read packets against the socket.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	//
	//	This function determines whether we've read an entire article and if so
	//	starts wrapping things up.
	//	All article data we get is either accumulated or issued as a write
	//	to our file.
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	pRead != 0 ) ;
	_ASSERT( pio == this ) ;

	//
	//	Bump the count of writes because we KNOW that IF this is the last read
	//	we may issue a write, CONSEQUENTLY we don't want to confuse the Write Completion
	//	function as to when we are finished.
	//	(It is important to increment before we set the COMPLETE state so that the
	//	thread where writes are completing doesn't get confused and terminate early.)
	//
	//	NOW there is a chance that we won't write this out immediately - in which case we
	//	need to have a matching decrement.	
	//
	m_cwrites ++ ;

	//
	//	Check whether the posting is too big !
	//
	ASSIGNI(m_HardLimit, m_cbLimit);
	if(!EQUALSI(m_HardLimit, 0)) {
		if( GREATER( pRead->m_iStream, m_HardLimit) ) {
			pRead->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_ARTICLE_LIMIT_EXCEEDED,
											0,
											TRUE ) ;
			return	pRead->m_cbBytes ;
		}
	}


	long sign = InterlockedDecrement( &m_cReads ) ;
	long signShutdowns = -1 ;

	//
	//	pch - this will be our current position in the input data
	//
	char	*pch = pRead->StartData();

	//
	//	pchStart and pchEnd - the bounds of the data in the completed
	//	read - after initialization nobody should modify these,
	//	as all the following code uses these instead of StartData(), EndData()
	//	all the time.
	//
	char	*pchStart = pch ;
	char	*pchEnd = pRead->EndData() ;

	//
	//	For those occasions where we get a read which contains both
	//	header and body bytes, but we can't get all the data into a buffer
	//	keep track of where the body bytes start in case we should
	//	do a partial write out of the buffer !
	//
	char	*pchStartBody = pch ;


	//
	//	Pointer to the end of the Header (if we find it !)
	//
	char	*pchEndHead = 0 ;

	//
	//	Number of bytes in the header we found when this read completed !
	//
	DWORD	cbHeadBytes = 0 ;

	//
	//	Number of bytes in the completed read which are part of the article -
	//	this includes any bytes in the header, so cbArticleBytes should always
	//	be greater or equal to cbHeadBytes !
	//
	DWORD	cbArticleBytes = 0 ;

	//
	//	Try to determine if we have found the end of the article ;
	//
	if( m_pchHeadState ) {
		//
		//	We are simultaneously scanning for the end of the
		//	article headers !
		//
		while( pch < pchEnd ) {

			//
			//	We will break out of the loop when we find the end of the
			//	header !
			//
			if( *pch == *m_pchHeadState ) {
				m_pchHeadState ++ ;
				if( *m_pchHeadState == '\0' ) {	
					pchEndHead = pch + 1 ;
					//
					//	break here - we have found the end of the article's header
					//	but not the end of the article, so the following loop
					//	will keep looking for that !
					//
					break ;
				}
			}	else	{
				if( *pch == szHeadState[0] ) {
					m_pchHeadState = &szHeadState[1] ;
				}	else	{
					m_pchHeadState = &szHeadState[0] ;
				}
			}

			//
			//	Test to see if we have come to the end of the article !!
			//
			if( *pch == *m_pchTailState ) {
				m_pchTailState ++ ;
				if( *m_pchTailState == '\0' ) {
					//
					//	Have got the entire terminating sequence - break !
					//
					pch++ ;
					break ;
				}
			}	else	{
				if( *pch == szTailState[0] ) {
					m_pchTailState = &szTailState[1] ;
				}	else	{
					m_pchTailState = &szTailState[0] ;
				}
			}

			pch++ ;
		}
		if( pchEndHead )
			cbHeadBytes = (DWORD)(pchEndHead - pchStart) ;
		else
			cbHeadBytes = (DWORD)(pch - pchStart) ;
	}	
	//
	//	We are not scanning for the end of the article headers !
	//	so keep the loop simpler !
	//
	if( *m_pchTailState != '\0' ) {
		while( pch < pchEnd ) {

			if( *pch == *m_pchTailState ) {
				m_pchTailState ++ ;
				if( *m_pchTailState == '\0' ) {
					//
					//	Have got the entire terminating sequence - break !
					//
					pch++ ;
					break ;
				}
			}	else	{
				if( *pch == szTailState[0] ) {
					m_pchTailState = &szTailState[1] ;
				}	else	{
					m_pchTailState = &szTailState[0] ;
				}
			}
			pch++ ;
		}
	}
	cbArticleBytes = (DWORD)(pch-pchStart) ;

	//
	//	We can do some validation here !
	//	dont go past the end of the buffer !
	//
	_ASSERT( pch <= pchEnd ) ;	
	//
	//	either find the end of the article or examine all the bytes in buffer !
	//
	_ASSERT( *m_pchTailState == '\0' || pch == pchEnd ) ;	
	//
	//	If we have not found the end of the header, then cbHeadBytes
	//	should be the same as cbArticleBytes !!!!
	//
	_ASSERT(	m_pchHeadState == 0 ||
				*m_pchHeadState == '\0' ||
				cbHeadBytes == cbArticleBytes ) ;
	//
	//	Regardless of state - always more bytes in the article than in the
	//	the header !!
	//
	_ASSERT(	cbHeadBytes <= cbArticleBytes ) ;
	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	//
	//	Check to see whether we need to remove CIOGetArticle from
	//	its flow control state !
	//
	if( pRead->m_dwExtra1 != 0 ) {
		//
		//	This Read was issued by the thread that completes writes to
		//	a file, and was marked to indicate we should leave our flow
		//	control state !
		//
		m_fFlowControlled = FALSE ;
		m_cFlowControlled = LONG_MIN ;
	}

	//
	//	Issue a new read if Necessary !!
	//
	BOOL	eof ;
	if( *m_pchTailState != '\0' )	{
		if( InterlockedIncrement( &m_cFlowControlled ) < 0 ) {
			if( sign < 0 ) {
				do	{
					CReadPacket*	pNewRead=pRead->m_pOwner->CreateDefaultRead( cbMediumRequest ) ;
					if( pNewRead )	{
						pNewRead->m_dwExtra1 = 0 ;
						pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;
					}	else	{
						// bugbug ... Need better Error handling !!
						_ASSERT( 1==0 ) ;
					}
				}	while( InterlockedIncrement( &m_cReads ) < 0 ) ;
			}
		}
	}	else	{
		pio = 0 ;
	}


	//
	//	Boolean indicating whether we have examined and used all the bytes
	//	in the completed read.  Start out assuming that we haven't.
	//	
	BOOL	fConsumed = FALSE ;


	//
	//	Are we still trying to accumulate all the bytes in the header of
	//	the article ? If so save the bytes away,
	//	Or if we have a bunch of room in the header buffer, then put
	//	whatever article bytes we have in there as well !
	//
	DWORD	cbAvailable = HeaderSpaceAvailable() ;
	if( m_pchHeadState != 0 ||
		(m_fAcceptNonHeaderBytes &&
		((cbAvailable  > cbArticleBytes) ||
			(m_pArticleHead->m_cbTotal < cbMediumRequest))) ) {
		
		//
		//	If we are still accumulating bytes into our buffer,
		//	then we better not have started doing any file IO !!!!
		//
		_ASSERT( m_pFileDriver == 0 ) ;
		//
		//	Whether we're placing header bytes or the bytes immediately
		//	following the header into our buffer this had better be TRUE !
		//
		_ASSERT( m_fAcceptNonHeaderBytes ) ;

		//
		//	we're still trying to accumulate the header of the article !
		//
		if( m_pArticleHead != 0 ) {

			if( cbAvailable > cbArticleBytes ) {

				fConsumed = TRUE ;
				FillHeaderSpace( pchStart, cbArticleBytes ) ;	

			}	else	{

				//
				//	Need a bigger buffer to hold all the data in the header !
				//	If we already have a resonably sized buffer that will hold
				//	the header than just copy the header text
				//

				if( cbAvailable > cbHeadBytes &&
					m_pArticleHead->m_cbTotal >= cbMediumRequest ) {

					//
					//	If we can't fit all the article bytes but we can
					//	fit all the header bytes than we MUST have the entire
					//	header, and we must have just gotten it !!
					//
					_ASSERT( m_pchHeadState != 0 ) ;
					_ASSERT( *m_pchHeadState == '\0' ) ;
			
					FillHeaderSpace( pchStart, cbHeadBytes ) ;
					pchStartBody += cbHeadBytes ;
	
				}	else	if( !GetBiggerHeaderBuffer( *pRead->m_pOwner, cbArticleBytes ) ) {

					//
					//	Oh-oh ! failed to get a larger header buffer -
					//	lets see if we can fit just the header bytes in the buffer
					//

					if( cbAvailable > cbHeadBytes ) {

						//	Must have entire header if this is the case !
						_ASSERT( m_pchHeadState != 0 ) ;
						_ASSERT( *m_pchHeadState == '\0' ) ;

						FillHeaderSpace( pchStart, cbHeadBytes ) ;
						pchStartBody += cbHeadBytes ;

					}	else	{

						//
						//	Blow off whatever buffers we have - when we call
						//	the m_pState's completion function we will indicate
						//	that we had an error !
						//
						if( !ResetHeaderState( *pRead->m_pOwner ) ) {

							//
							//	A fatal error !!! Can't open a file to hold the article !!!
							//

							pRead->m_pOwner->UnsafeClose(	pSocket,
															CAUSE_OOM,
															GetLastError(),
															TRUE
															) ;
							pio = 0 ;
							return	cbArticleBytes ;
						}

					}
	
				}	else	{

					fConsumed = TRUE ;
					FillHeaderSpace( pchStart, cbArticleBytes ) ;

				}
			}
		
		}	else	{

			//
			//	First time we've completed a read - set up to hold the
			//	header information !
			//		
			fConsumed = TRUE ;	
			InitializeHeaderSpace( pRead, cbArticleBytes ) ;			

		}

		if( m_pchHeadState ) {
			//
			//	Still accumulating header bytes - count them up !
			//
			m_cbHeadBytes += cbHeadBytes ;
			if(	*m_pchHeadState == '\0' ) {

				//
				//	we have received the entire header of the article !
				//
				m_pchHeadState = 0 ;
			}
		}	
	}	

	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	//
	//	Check if all the bytes in the incoming packet were
	//	stored by the above code, which tried to store the bytes
	//	away into a buffer
	//

	if( fConsumed ) {

		if( *m_pchTailState == '\0' ) {

			//
			//	Best of all worlds - we have a complete article, and we have
			//	managed to save it all in a buffer without any file IO !!
			//	Now figure out if we completed it in just one read, cause if we
			//	we have we want to be carefull about how much space we can use
			//	in that read !
			//

			DWORD	cbAvailable = 0 ;
			if( m_pArticleHead == pRead->m_pbuffer ) {

				//
				//	Just one read got everything !!! well the available
				//	bytes will be the entire packet if there was no extra data
				//	otherwise, it will need some adjustment !!
				//
				_ASSERT( pch == pRead->StartData() + cbArticleBytes ) ;

				if( cbArticleBytes != pRead->m_cbBytes ) {
					//
					//	This must mean that we got more bytes then just the article -
					//	shuffle bytes around to get the most usable room in this IO buffer !
					//
					DWORD	cbTemp = pRead->m_ibEnd - pRead->m_ibEndData ;
					if( cbTemp == 0 ) {
						//
						//	There's not going to be any space available -
						//
						cbAvailable = cbArticleBytes ;
					}	else	{

						MoveMemory( pch+cbTemp, pch, pchEnd - pch ) ;
						pRead->m_ibStartData += cbTemp ;
						pRead->m_ibEndData = pRead->m_ibEnd ;
						cbAvailable = cbArticleBytes + cbTemp ;

					}
				}
			}


			DoCompletion(	pSocket,
							INVALID_HANDLE_VALUE,
							m_ibEndHeadData - m_ibStartHeadData,	
							m_ibEndHeadData - m_ibStartHeadData,
							cbAvailable
							) ;

			//
			//	No Next state !
			//
			pio = 0 ;

		}

		//
		//	reset to zero as we are swallowing all the data into a buffer and not issuing writes
		//	to a file !
		//
		m_cwrites = 0 ;

		return	cbArticleBytes ;
	}


	//
	//	If we EVER reach this point, then we have completed a Read which
	//	we did not copy into our header buffer.  That means, we should not
	//	ever place any other reads into our header buffer, as then we would
	//	not have a correct image of the article !!!!
	//
	m_fAcceptNonHeaderBytes = FALSE ;


	//
	//	If we reach this point then we are no longer able to save bytes
	//	in the buffer we has set aside for saving header bytes.
	//	We have to write these bytes to a file now !!!
	//


	if( m_pFileDriver == 0 ) {

		//
		//	This is the first time we have reached this point - so we
		//	need to create a file and everything right now !!!
		//

		if( !InitializeForFileIO(
								pSocket,
								*pRead->m_pOwner,
								m_cbHeadBytes
								)	) {

			//
			//	A fatal error !!! Can't open a file to hold the article !!!
			//

			pRead->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_OOM,
											GetLastError(),
											TRUE
											) ;
			pio = 0 ;
			return	cbArticleBytes ;

		}	else	{

	
			//
			//	In some error cases we will create a WritePacket before we have
			//	created all the CIODriver's to handle the IO, so if we have
			//	one make sure the owner is set correctly !
			//
			if( m_pWrite ) {

				m_pWrite->m_pOwner = m_pFileDriver ;

			}

			//
			//	If we have accumulated some data we need to write it into the file !
			//
			
			if( m_pArticleHead != 0 ) {
				//
				//	Bump the number of writes, as we're going to write the header
				//	to disk now !!!!
				//
				m_cwrites ++ ;
				
				//
				//	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
				//  our destructor if an error has occurred !!
				//
				CWritePacket*	pTempWrite =
					m_pFileDriver->CreateDefaultWrite(
											m_pArticleHead,
											m_ibStartHead,
											m_ibEndHead,
											m_ibStartHeadData,
											m_ibEndHeadData
											) ;

				DoFlowControl( INST(pSocket) ) ;
				m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
			}

		}

	}

	//
	//	Issue a write, unless the user is sending small packets,
	//	in which case we will accumulate the data !!
	//

	//
	//	Note - use pchStartBody in all calculations here, as we may have
	//	taken a fraction of the bytes into our header buffer !!
	//

	if( *m_pchTailState != '\0' )	{
		unsigned	cbSmall = (unsigned)(pchEnd - pchStartBody) ;
		if( cbSmall < cbTooSmallWrite )	{
			if( m_pWrite == 0 )	{
				m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
				m_pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart) ;
			}	else	{
				if( (m_pWrite->m_ibEnd - m_pWrite->m_ibEndData) > cbSmall )		{
					CopyMemory( m_pWrite->EndData(), pchStartBody, cbSmall ) ;
					m_pWrite->m_ibEndData += cbSmall ;
					m_cwrites -- ;		// There will never be a corresponding write for this completiong
										// as we copied the data into another buffer. SO decrement the count.
				}	else	{
					//
					//	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
					//  our destructor if an error has occurred !!
					//
					CWritePacket*	pTempWrite = m_pWrite ;
					m_pWrite = 0 ;
					DoFlowControl( INST(pSocket) ) ;
					m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
					m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
				}
			}
		// If we came through here we should have consumed all bytes in the packet!
		_ASSERT( pch == pchEnd ) ;
		_ASSERT( unsigned(pch - pchStart) == pRead->m_cbBytes ) ;
		return	(int)(pch - pchStart) ;
		}
	}

	if( m_pWrite )	{
		CWritePacket*	pTempWrite = m_pWrite ;
		m_pWrite = 0 ;

		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
	}
	

	CWritePacket*	pWrite = 0 ;
	if( pch == pchEnd )		{
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead ) ;
	}	else	{
		unsigned	ibEnd = pRead->m_ibStartData + (unsigned)(pch - pchStart) ;
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead->m_pbuffer,
						pRead->m_ibStartData, ibEnd,
						pRead->m_ibStartData, ibEnd ) ;
	}

	if( pWrite )	{

	    //
    	//	It is possible that long before we reached here we took a portion
	    //	of this packet and placed it into our header buffer - so adjust for that
    	//	if it occurred !!
	    //
    	pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart) ;

	    _ASSERT( pWrite->m_ibStartData < pWrite->m_ibEndData ) ;

		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pWrite, pSocket, eof ) ;

	}	else	{

		pRead->m_pOwner->UnsafeClose(	pSocket,
										CAUSE_OOM,
										GetLastError(),
										TRUE
										) ;

	}
	_ASSERT( eof == FALSE ) ;

	if( *m_pchTailState == '\0' )	{
		m_pFileChannel->FlushFileBuffers() ;
	}

	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	return	(int)(pch - pchStart) ;
}

int	
CIOGetArticle::Complete(	CSessionSocket*	pSocket,	
							CWritePacket *pWrite,	
							CIO*&	pioOut ) {
/*++

Routine Description :

	Called whenever a write to a file completes.
	We must determine whether we have completed all the writes
	we are going to do and if so call the state's completion function.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet that was writtne to the file.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	TraceFunctEnter( "CIOGetArticle::Complete" ) ;

	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pWrite != 0 ) ;
	_ASSERT( pioOut == this ) ;

	m_cwritesCompleted++ ;

	long	cFlowControlled = 0 ;

	//
	//	Process the completion of a write to a file.
	//	determine whether we need to signal the entire transfer
	//	as completed.
	//

	if( *m_pchTailState == '\0' && m_cwritesCompleted == m_cwrites )	{

		// BUGBUG: loss of 64-bit precision
		DWORD	cbTransfer = DWORD( LOW(pWrite->m_iStream) + pWrite->m_cbBytes ) /*- m_pFileChannel-> */ ;
		DWORD	cbGap = m_pFileChannel->InitialOffset() ;

		HANDLE	hFile = m_pFileChannel->ReleaseSource() ;

		_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;

		DoCompletion(	pSocket,
						hFile,
						0,
						cbTransfer,
						0,			// Let DoCompletion compute available buffer size !
						cbGap
						) ;



		//
		//	NOT ALLOWED TO RETURIN A NEW IO OPERATION !!! Because this function is
		//	operating in a Channel which is temporary !!!
		//

		//	We do not set pioOut to zero, as we want the CIODriver to
		//	call out Shutdown function during its termination processing !


		//
		//	Now we must destroy our channels !!!
		//

		DebugTrace( (DWORD_PTR)this, "Closing File Driver %x ", m_pFileDriver ) ;
		
		//m_pFileDriver->Close( pSocket,	CAUSE_LEGIT_CLOSE, 0, FALSE ) ;
		Term( pSocket, FALSE ) ;

		DebugTrace( (DWORD_PTR)this, "deleting self" ) ;

	}	else	if( ( m_fFlowControlled ) ) {

		if( m_cwrites - m_cwritesCompleted <= RESTORE_FLOW && m_pSocketSink != 0 )	{
			//
			//	ALWAYS issue at least 1 read when coming out of a flow control state !!
			//

			CReadPacket*	pRead = 0 ;

			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );

			cFlowControlled = m_cFlowControlled + 1 ;
			while( cFlowControlled >= 1  ) {
				if( m_pSocketSink == 0 )
					break ;
				pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
				if( 0!=pRead )	{
					BOOL	eof ;
					InterlockedIncrement( &m_cReads ) ;
					pRead->m_dwExtra1 = 0 ;
					pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
				}	
				cFlowControlled -- ;
			}	

			//
			//	The following read is special - we set the m_dwExtra1 field so that
			//	the read completion code can determine that it is time to leave
			//	the flow control state !
			//
			pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
			if( 0!=pRead )	{
				BOOL	eof ;
				pRead->m_dwExtra1 = 1 ;
				InterlockedIncrement( &m_cReads ) ;
				pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
			}	else	{

				//
				//	Fatal error - drop the session !
				//
				m_pSocketSink->UnsafeClose(	pSocket,
											CAUSE_OOM,
											GetLastError(),
											TRUE
											) ;
				return	pWrite->m_cbBytes ;

			}
			cFlowControlled -- ;

			InterlockedExchange( &m_cFlowControlled, LONG_MIN ) ;
			// Set to FALSE after InterlockedExchange !!
			m_fFlowControlled = FALSE ;

		}
	}

	return	pWrite->m_cbBytes ;
}


//CIOGetArticleEx


//
//	Maximum number of pending reads while reading an article
//
unsigned	CIOGetArticleEx::maxReadAhead = 3 ;
//
//	Number of bytes to accumulate before writing to a file !
//
unsigned	CIOGetArticleEx::cbTooSmallWrite = cbLargeRequest - 512;

BOOL
CIOGetArticleEx::FValid()	{

	_ASSERT( !m_pchMatch || strlen( m_pchMatch ) != 0 ) ;
	_ASSERT( m_pchTailState == 0 ||
			m_pchTailState >= m_pchMatch &&
			(m_pchTailState <= m_pchMatch + strlen(m_pchMatch)) ) ;

	_ASSERT( (m_pFileDriver == 0 && m_pFileChannel == 0) ||
			 (m_pFileDriver != 0 && m_pFileChannel != 0) ) ;

	_ASSERT( m_cbLimit != 0 ) ;

	_ASSERT( m_pState != 0 ) ;
	//_ASSERT( m_pSocketSink != 0 ) ;	This can happen during destruction !

	_ASSERT( m_pWrite == 0 ||
			m_pFileDriver != 0 ) ;
	return	TRUE ;
}

CIOGetArticleEx::CIOGetArticleEx(
						CSessionState*	pstate,
						CSessionSocket*	pSocket,	
						CDRIVERPTR&	pDriver,
						DWORD	cbLimit,
						LPSTR	szMatch,
						LPSTR	pchInitial,
						LPSTR	szErrorMatch,
						LPSTR	pchInitialError
						) :
/*++

Routine Description :

	Class Constructor

Arguments :
	
	pstate - The State which is issuing us and who's completion function
			we should later call
	pSocket -	The socket on which we will be issued
	pDriver -	The CIODriver object handling all of the socket's IO
	pFileChannel -	The File Channel into which we should save all data
	fSaveHead - TRUE if we want the HEAD of the article placed in a buffer !
	fPartial	- If TRUE then we should assume that a CRLF has already
				been sent and '.\r\n' alone can terminate the article.

Return Value :
	
	None

--*/

	//
	//	Get a CIOGetArticleEx object half way set up - user still needs
	//	to call Init() but we will do much here !
	//
	CIORead( pstate ),
	m_pchMatch( szMatch ),
	m_pchTailState( pchInitial ),
	m_pchErrorMatch( szErrorMatch ),
	m_pchErrorState( pchInitialError ),
	m_pFileChannel( 0 ),	
	m_pFileDriver( 0 ),
	m_pSocketSink( pDriver ),
	m_fDriverInit( FALSE ),
	m_fSwallow( FALSE ),
	m_cwrites( 0 ),
	m_cwritesCompleted( 0 ),
	m_cFlowControlled( LONG_MIN ),
	m_fFlowControlled( FALSE ),
	m_cReads( 0 ),
	m_pWrite( 0 ),
	m_cbLimit( cbLimit ),
	m_ibStartHead( 0 ),
	m_ibStartHeadData( 0 ),
	m_ibEndHead( 0 ),
	m_ibEndHeadData( 0 )
#ifdef	CIO_DEBUG
	,m_fSuccessfullInit( FALSE ),
	m_fTerminated( FALSE )
#endif
{

	ASSIGNI(m_HardLimit, 0);
	TraceFunctEnter( "CIOGetArticleEx::CIOGetArticleEx" ) ;


	_ASSERT( m_pchTailState != 0 ) ;
	_ASSERT( m_pchMatch != 0 ) ;
	_ASSERT(	(m_pchErrorMatch == 0 && m_pchErrorState == 0) ||
				(m_pchErrorMatch != 0 && m_pchErrorState != 0) ) ;
	_ASSERT( FValid() ) ;
}

CIOGetArticleEx::~CIOGetArticleEx( )	{
/*++

Routine Description :

	Class Destructor

Arguments :
	
	None

Return Value :
	
	None

--*/

	_ASSERT( FValid() ) ;
	//
	//	Destroy a CIOGetArticleEx - always close our m_pFileDriver if possible
	//	in case we are terminated due to some socket error.
	//
	TraceFunctEnter( "CIOGetArticleEx::~CIOGetArticleEx" ) ;

#ifdef	CIO_DEBUG
	//
	//	Our destructor should only be called if we weren't successfully init
	//	or after Term() has been called.
	//
	_ASSERT( !m_fSuccessfullInit || m_fTerminated ) ;
#endif

	DebugTrace( (DWORD_PTR)this, "m_pFileDriver %x m_fDriverInit %x", m_pFileDriver, m_fDriverInit ) ;

	if( m_pFileDriver != 0 ) {
		if( m_fDriverInit )		{
			m_pFileDriver->UnsafeClose( (CSessionSocket*)this, CAUSE_NORMAL_CIO_TERMINATION, 0, FALSE ) ;
		}
	}
	if( m_pWrite != 0 ) {
		CPacket::DestroyAndDelete( m_pWrite ) ;
		m_pWrite = 0 ;
	}
}

void
CIOGetArticleEx::Term(	CSessionSocket*	pSocket,
						BOOL			fAbort,
						BOOL			fStarted	)	{
/*++

Routine Description :

	Start destroying a successfully initialize CIOGetArticleEx object

Arguments :
	
	fAbort - If TRUE then destroy the socket which we were using
			If FALSE then only close down our File Channel's

Return Value :

	None

--*/
#ifdef	CIO_DEBUG
	m_fTerminated = TRUE ;
#endif
	//
	//	Start us on our way to destruction !!
	//	If we have been successfully Initialized, then this will
	//	lead to our destruction when our m_pFileDriver eventually shutsdown.
	//	(Since we were succesfully Init() our m_pFileDriver has a reference to us,
	//	so we must allow it to shutdown and destroy us to avoid problems with
	//	circular references and multiple frees !)
	//

	if( m_pFileDriver != 0 ) {
		m_pFileDriver->UnsafeClose( pSocket,
				fAbort ? CAUSE_USERTERM : CAUSE_NORMAL_CIO_TERMINATION, 0, fAbort ) ;
	}
}


void
CIOGetArticleEx::Shutdown(	CSessionSocket*	pSocket,	
							CIODriver&		driver,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dwOptional )	{
/*++

Routine Description :

	Do whatever work is necessary when one of the two CIODriver's we are
	using is terminated.

Arguments :

	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	TraceFunctEnter( "CIOGetArticleEx::Shutdown" ) ;
	DebugTrace( (DWORD_PTR)this, "SHutdown args - pSocket %x driver %x cause %x dw %x",
			pSocket, &driver, cause, dwOptional ) ;

	//
	//	This function is called when the CIODriver's we are refenced by our closing down.
	//	Since we are referenced by two of them (one for the socket and one for the file)
	//	we only want to be deleted by the CIODriver for the file.
	//
	if( &driver == m_pFileDriver )	{
		// Out file is closing - what can we do about it !
		//_ASSERT( 1==0 ) ;
#ifdef	CIO_DEBUG
		m_fTerminated = TRUE ;
#endif

		//
		//	We set this to 0 here as we know we will be called here by
		//	the same thread that is completing writes to the file - so
		//	since that's the only thread referencing this member variable -
		//	there are no thread safety issues accessing that member.
		//

		m_pSocketSink = 0 ;

		if ( m_fFlowControlled )
		{
			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );
		}

	}	else	{
		// Close down the rest of our stuff as well !!
		Term( pSocket, cause != CAUSE_NORMAL_CIO_TERMINATION ) ;
	}
}

void
CIOGetArticleEx::ShutdownFunc(	void *pv,	
								SHUTDOWN_CAUSE	cause,	
								DWORD dw ) {
/*++

Routine Description :

	Notification function which is called when a CIODriver used by
	a CIOGetArticleEx if finally destroyed.  This function is provided
	to the CIODriver we use for File IO's during out Init().

Arguments :

	pv	-	Pointer to dead CIOGetArticleEx - this has been destroyed dont use !
	cause -	The reason for termination
	dw		Optional extra information regarding termination

Return Value :

	None

--*/

	TraceFunctEnter( "CIOGetArticleEx::ShutdownFunc" ) ;
	//
	//	This function gets notified when a CIOFileDriver used by CIOGetArticleEx
	//	is terminated.  Not much for us to worry about.
	//	(CIODriver's require these functions)
	//

	//_ASSERT( 1==0 ) ;
	return ;
}

BOOL
CIOGetArticleEx::Start(	CIODriver&	driver,	
						CSessionSocket	*pSocket,	
						unsigned cReadAhead )	{
/*++

Routine Description :

	This function is called to start transferring data from the socket
	into the file.

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/


	_ASSERT( pSocket != 0 ) ;

	m_cReads = -((long)maxReadAhead) + cReadAhead ;

	while( cReadAhead < maxReadAhead )	{
		//
		//	Start reading data from the socket
		//
		CReadPacket*	pRead = driver.CreateDefaultRead( cbLargeRequest ) ;
		if( 0!=pRead )	{
			BOOL	eof ;
			pRead->m_dwExtra1 = 0 ;
			driver.IssuePacket( pRead, pSocket, eof ) ;
			cReadAhead++ ;
			InterlockedIncrement( &m_cReads ) ;
		}	else	{
			//
			// This is a fatal problem only if we couldn't issue ANY reads at all !
			//
			if( cReadAhead == 0 )
				return FALSE  ;
		}
	}	
	return	TRUE ;
}

void
CIOGetArticleEx::DoFlowControl( PNNTP_SERVER_INSTANCE pInstance )	{
/*++

Routine Description :

	Check whether it is necessary to set flow control due to
	too many outstanding writes.
	If necessary, then the first time we do put ourselves into Flow Control,
	try to flush our pending writes.
	We should be called only immediately before issuing an Async Write to the file
	to ensure that a CWritePacket completion will actually execute the necessary
	code to restart a flow controlled session.
	(Otherwisse, we could potentially decide to Flow control the session
	and before setting m_fFlowControlled to TRUE all the pending writes complete
	and then we'd be left in a boat where there are no pending reads or
	writes and no way to get out of the flow control state.)

Arguments :

	None.

Return Value :

	None.


--*/

	//
	//	Important - do all tests of m_fFlowControlled before setting
	//	m_cFlowControlled - as other thread will touch m_cFlowControlled
	//	before touching m_fFlowControlled !!
	//	(Will only touch m_fFlowControlled if m_fFlowControlled is TRUE ) !
	//	Thus we know that if m_fFlowControlled is FALSE there is nobody
	//	messing with m_cFlowControlled,
	//
	//

	if( m_cwrites - m_cwritesCompleted > MAX_OUTSTANDING_FILE_WRITES ) {
		
		if( m_fFlowControlled ) {
			// All ready have flow control turned on
			;
		}	else	{
			m_cFlowControlled = -1 ;
			m_fFlowControlled = TRUE ;
			m_pFileChannel->FlushFileBuffers() ;

			IncrementStat( pInstance, SessionsFlowControlled );
		}
	}	else	{
		if( !m_fFlowControlled ) {
			m_cFlowControlled = LONG_MIN ;	// Keep resetting !
		}
	}
}

inline	DWORD
CIOGetArticleEx::HeaderSpaceAvailable()	{
/*++

Routine Description :

	Compute the amount of space available in the buffer we are using
	to hold the article header !

Arguments :

	None.

Return Value :

	number of bytes available, 0 if we aren't collecting article headers !

--*/

	if( m_pArticleHead != 0 ) {

		return	m_ibEndHead - m_ibEndHeadData ;

	}
	return	0 ;
}

inline	void
CIOGetArticleEx::FillHeaderSpace(
						char*	pchStart,
						DWORD	cbBytes
						) {
/*++

Routine Description :

	Copy bytes into the header storage area !!
	Caller should ensure that this will fit !!
	
Arguments :

	pchStart - Start of bytes to be copied !
	cbBytes -	Number of bytes to copy !

Return Value :

	None.

--*/

	_ASSERT( m_pArticleHead != 0 ) ;
	_ASSERT( cbBytes + m_ibEndHeadData < m_ibEndHead ) ;

	CopyMemory( m_pArticleHead->m_rgBuff + m_ibEndHeadData,
				pchStart,
				cbBytes
				) ;

	m_ibEndHeadData += cbBytes ;
}


inline	void
CIOGetArticleEx::InitializeHeaderSpace(
						CReadPacket*	pRead,
						DWORD			cbArticleBytes
						) {
/*++

Routine Description  :

	Given a read packet which contains our first completed read,
	set up all our buffer start for holding header information !
	
Arguments :

	CReadPackets*	pRead - the completed read !
	cbArticleBytes - Number of bytes in the completed read making up the article !

Return Value :

	None.
	
--*/


	_ASSERT( m_pArticleHead == 0 ) ;
	_ASSERT( m_ibStartHead == 0 ) ;
	_ASSERT( m_ibEndHead == 0 ) ;
	_ASSERT( m_ibStartHeadData == 0 ) ;
	_ASSERT( m_ibEndHeadData == 0 ) ;
	_ASSERT( cbArticleBytes <= (pRead->m_ibEndData - pRead->m_ibStartData)) ;

	m_pArticleHead = pRead->m_pbuffer ;

	m_ibStartHead = pRead->m_ibStart ;
	m_ibStartHeadData = pRead->m_ibStartData ;
	m_ibEndHeadData = pRead->m_ibStartData + cbArticleBytes ;

	if( m_ibEndHeadData < pRead->m_ibEndData )
		m_ibEndHead = m_ibEndHeadData ;
	else
		m_ibEndHead = pRead->m_ibEnd ;

}

inline	BOOL
CIOGetArticleEx::GetBiggerHeaderBuffer(
							CIODriver&	driver,
							DWORD		cbRequired
							) {
/*++

Routine Description :

	We have too much data to fit into the buffer we are using to hold
	header information.  So try to get a bigger buffer and move
	our old data into that buffer !

Arguments :

	driver - A CIODriverSink we can use to allocate buffers !

Return Value :

	TRUE if successfull,
	FALSE otherwise.
	If we fail we leave member variables untouched.

--*/

	_ASSERT( m_pArticleHead != 0 ) ;

	CBuffer*	pTemp = 0 ;

	DWORD	cbRequest = cbMediumRequest ;

	if( (m_pArticleHead->m_cbTotal + cbRequired)  > cbMediumRequest )	{
		cbRequest = cbLargeRequest ;
	}

	if( cbRequest < (cbRequired + (m_ibEndHeadData - m_ibStartHeadData)) ) {
		return	FALSE ;
	}

	pTemp = driver.AllocateBuffer( cbRequest ) ;

	if( pTemp != 0 ) {

		DWORD	cbToCopy = m_ibEndHeadData - m_ibStartHeadData ;
		CopyMemory( pTemp->m_rgBuff,
					&m_pArticleHead->m_rgBuff[ m_ibStartHeadData ],
					cbToCopy
					) ;

		m_ibStartHead = 0 ;
		m_ibStartHeadData = 0 ;
		m_ibEndHead = pTemp->m_cbTotal ;
		m_ibEndHeadData = cbToCopy ;
		m_pArticleHead = pTemp ;

		return	TRUE ;
	}

	return	FALSE ;
}

#if 0
inline	BOOL
CIOGetArticleEx::ResetHeaderState(
						CIODriver&	driver
						)	{
/*++

Routine Description :

	This function is called when for some reason an error occurred
	and we wont be able to save the header info for the article.
	We will set all the member variables so that we will continue
	to read the article, however when we finally call the state's completion
	procedure we will tell them an error occurred, and the article
	transfer will fail.

Arguments :

	driver - CIODriverSink that can be used to allocate packets etc !

Return Value :

	None.

--*/

	//
	//	Should only be called before we have started issuing file IO's,
	//	after we start issuing file IO's we should have all the header
	//	data and should not hit errors that would result in our being
	//	called !!!
	//
	_ASSERT( m_pFileDriver == 0 ) ;

	if( m_pArticleHead ) {
		//
		//	If we have an existing buffer - turn it into a write packet
		//	that can be written to the hard disk
		//

		m_pWrite = driver.CreateDefaultWrite(
								m_pArticleHead,
								m_ibStartHead,
								m_ibEndHead,
								m_ibStartHeadData,
								m_ibEndHeadData
								) ;

		if( m_pWrite ) {

			m_pArticleHead = 0 ;
			m_ibStartHead = 0 ;	
			m_ibEndHead = 0 ;
			m_ibStartHeadData = 0;
			m_ibEndHeadData = 0 ;
			m_pchHeadState = 0 ;
			return	TRUE ;

		}	else	{

			return	FALSE ;

		}

	}	else	{
		//
		//	Should already be in a good state !
		//

		_ASSERT( m_pArticleHead == 0 ) ;
		_ASSERT( m_ibStartHead == 0 ) ;
		_ASSERT( m_ibStartHeadData == 0 ) ;
		_ASSERT( m_ibEndHead == 0 ) ;
		_ASSERT( m_ibEndHeadData == 0 ) ;

		m_pchHeadState = 0 ;

	}

	return	TRUE ;
}
void
CIOGetArticleEx::DoCompletion(
					CSessionSocket*	pSocket,
					HANDLE	hFile,
					DWORD	cbFullBuffer,
					DWORD	cbTotalTransfer,
					DWORD	cbAvailableBuffer,
					DWORD	cbGap
					) {
/*++

Routine Description :

	Call the State's completion function with all the correct
	arguments.

Arguments :
	
	hFile - Handle to the file we used, if we used one !!
		(This will be INVALID_HANDLE_VALUE if no file required !)

Return Value :

	None.

--*/

	//
	//	Figure out error codes if the article looks bad !
	//

	NRC		nrc	= nrcOK ;

	char*	pchHead = 0 ;
	DWORD	cbHeader = 0 ;
	DWORD	cbArticle = 0 ;
	DWORD	cbTotal = 0 ;

	if( m_pArticleHead == 0 ) {
		nrc = nrcHeaderTooLarge ;
	}	else	{

		if( m_pchHeadState != 0 ) {
			nrc = nrcArticleIncompleteHeader ;
		}

		pchHead = &m_pArticleHead->m_rgBuff[m_ibStartHeadData] ;
		cbHeader = m_cbHeadBytes ;
		if( cbAvailableBuffer == 0 )
			cbAvailableBuffer = m_pArticleHead->m_cbTotal - m_ibStartHeadData ;

		//
		//	If there's no file handle, we should have the entire
		//	article in our buffer !!
		//
		if( hFile == INVALID_HANDLE_VALUE ) {

			cbArticle = cbFullBuffer ;

			_ASSERT( cbArticle >= cbHeader ) ;

		}

	}

	//
	//	Call the state's completion function !!
	//

	m_pState->Complete(
						this,
						pSocket,
						nrc,
						pchHead,
						cbHeader,
						cbArticle,
						cbAvailableBuffer,
						hFile,
						cbGap,
						cbTotalTransfer
						) ;
}
#endif



BOOL
CIOGetArticleEx::InitializeForFileIO(
							FIO_CONTEXT*	pFIOContext,
							CSessionSocket*	pSocket,
							CIODriver&		readDriver,
							DWORD			cbHeaderBytes
							)	{
/*++

Routine Description :

	We've been reading data into Ram buffers, and we have gotten so
	much that we've decided not to try to hold it all in RAM.
	So now we must start doing writes to a file somewhere.
	This code will create the file, and set up the necessary
	data structures for processing completed file IO.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/
	_ASSERT( FValid() ) ;

	_ASSERT( m_pFileChannel == 0 ) ;
	_ASSERT( m_pFileDriver == 0 ) ;

	if( pFIOContext != 0 ) {

		_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;

		m_pFileChannel = new	CFileChannel() ;
		if( m_pFileChannel && m_pFileChannel->Init(	pFIOContext,
									pSocket,
									0,
									FALSE
									) ) {

			//
			//	Try to create the CIODriver we are going to use to	
			//	complete our async writes !!!
			//

			m_pFileDriver = new CIODriverSink(
										readDriver.GetMediumCache()
										) ;



			if( m_pFileDriver && m_pFileDriver->Init(	m_pFileChannel,
										                pSocket,
                										ShutdownFunc,
				                						(void*)this
										) ) {
				m_fDriverInit = TRUE ;

				if( m_pSocketSink != 0 ) {
					//
					//	Now we have to send ourselves into the CIODriverSink() !
					//
					if( m_pFileDriver->SendWriteIO( pSocket, *this, FALSE ) ) {
						return	TRUE ;
					}
				}
			}
		}
	}

	//
	//	All clean up in error cases is handled by our destructor !
	//
	return	FALSE ;
}


BOOL
CIOGetArticleEx::StartFileIO(
							CSessionSocket*	pSocket,
							FIO_CONTEXT*	pFIOContext,
							CBUFPTR&		pBuffer,
							DWORD			ibStartBuffer,
							DWORD			ibEndBuffer,
							LPSTR			szMatch,
							LPSTR			pchInitial
							)	{
/*++

Routine Description :

	We've been reading data into Ram buffers, and we have gotten so
	much that we've decided not to try to hold it all in RAM.
	So now we must start doing writes to a file somewhere.
	This code will create the file, and set up the necessary
	data structures for processing completed file IO.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	_ASSERT( szMatch != 0 ) ;
	_ASSERT( pchInitial != 0 ) ;
	_ASSERT( FValid() ) ;

	_ASSERT( m_pFileChannel == 0 ) ;
	_ASSERT( m_pFileDriver == 0 ) ;

	m_pchMatch = szMatch ;
	m_pchTailState = pchInitial ;
	m_pchErrorMatch = 0 ;
	m_pchErrorState = 0 ;

	if( pFIOContext == 0 ) 	{
		_ASSERT( pBuffer == 0 ) ;
		//
		//	We just want to consume all of the bytes that we get and throw them away !
		//
		m_fSwallow = TRUE ;
		return	TRUE ;
	}	else	if( InitializeForFileIO(	pFIOContext,
								pSocket,
								*m_pSocketSink,
								0	) )	{

		//
		//	Well the file is set up - we need to
		//	write the first batch of bytes into the file !
		//
		//
		//	Bump the number of writes, as we're going to write the header
		//	to disk now !!!!
		//
		m_cwrites ++ ;
		//
		//	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
		//  our destructor if an error has occurred !!
		//

		m_pWrite =
			m_pFileDriver->CreateDefaultWrite(
									pBuffer,
									0,
									pBuffer->m_cbTotal,
									ibStartBuffer,
									ibEndBuffer
									) ;

		if( m_pWrite )	{
			_ASSERT( FValid() ) ;
			return	TRUE ;
		}	
	}

	//m_pchMatch = 0 ;
	//m_pchTailState = 0 ;

	//
	//	Shutdown the socket !
	//
	m_pSocketSink->UnsafeClose(	pSocket,
								CAUSE_OOM,
								__LINE__,
								TRUE
								) ;
	//
	//	All clean up in error cases is handled by our destructor !
	//
	return	FALSE ;
}




int
CIOGetArticleEx::Complete(	CSessionSocket*	pSocket,	
							CReadPacket	*pRead,	
							CIO*&	pio	
							)	{
/*++

Routine Description :

	Called whenever a CReadPacket we have issued completes.
	We only issue read packets against the socket.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	//
	//	This function determines whether we've read an entire article and if so
	//	starts wrapping things up.
	//	All article data we get is either accumulated or issued as a write
	//	to our file.
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	pRead != 0 ) ;
	_ASSERT( pio == this ) ;
	_ASSERT( FValid() ) ;

	//
	//	Bump the count of writes because we KNOW that IF this is the last read
	//	we may issue a write, CONSEQUENTLY we don't want to confuse the Write Completion
	//	function as to when we are finished.
	//	(It is important to increment before we set the COMPLETE state so that the
	//	thread where writes are completing doesn't get confused and terminate early.)
	//
	//	NOW there is a chance that we won't write this out immediately - in which case we
	//	need to have a matching decrement.	
	//
	m_cwrites ++ ;

	//
	//	Check whether the posting is too big !
	//
	ASSIGNI(m_HardLimit, m_cbLimit);
	if(!EQUALSI(m_HardLimit, 0)) {
		if( GREATER( pRead->m_iStream, m_HardLimit) ) {
			pRead->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_ARTICLE_LIMIT_EXCEEDED,
											0,
											TRUE ) ;
			return	pRead->m_cbBytes ;
		}
	}


	long sign = InterlockedDecrement( &m_cReads ) ;
	long signShutdowns = -1 ;

	//
	//	pch - this will be our current position in the input data
	//
	char	*pch = pRead->StartData();

	//
	//	pchStart and pchEnd - the bounds of the data in the completed
	//	read - after initialization nobody should modify these,
	//	as all the following code uses these instead of StartData(), EndData()
	//	all the time.
	//
	char	*pchStart = pch ;
	char	*pchEnd = pRead->EndData() ;

	//
	//	For those occasions where we get a read which contains both
	//	header and body bytes, but we can't get all the data into a buffer
	//	keep track of where the body bytes start in case we should
	//	do a partial write out of the buffer !
	//
	char	*pchStartBody = pch ;


	//
	//	Pointer to the end of the Header (if we find it !)
	//
	char	*pchEndHead = 0 ;

	//
	//	Number of bytes in the completed read which are part of the article -
	//	this includes any bytes in the header, so cbArticleBytes should always
	//	be greater or equal to cbHeadBytes !
	//
	DWORD	cbArticleBytes = 0 ;

	//
	//	Are we finished receiving the article !
	//
	BOOL	fFinished = FALSE ;

	//
	//	Try to determine if we have found the end of the article ;
	//
	//
	//	We are not scanning for the end of the article headers !
	//	so keep the loop simpler !
	//
	if( m_pchErrorMatch )	{
		//
		//	We are simultaneously scanning for the end of the
		//	article headers !
		//
		while( pch < pchEnd ) {

			//
			//	We will break out of the loop when we find the end of the
			//	header !
			//
			if( *pch == *m_pchErrorState ) {
				m_pchErrorState ++ ;
				if( *m_pchErrorState == '\0' ) {	
					fFinished = TRUE ;
					pch++ ;
					//
					//	break here - we have found the end of the article's header
					//	but not the end of the article, so the following loop
					//	will keep looking for that !
					//
					break ;
				}
			}	else	{
				if( *pch == m_pchErrorMatch[0] ) {
					m_pchErrorState = &m_pchErrorMatch[1] ;
				}	else	{
					m_pchErrorState = &m_pchErrorMatch[0] ;
				}
			}
			//
			//	Test to see if we have come to the end of the article !!
			//
			if( *pch == *m_pchTailState ) {
				m_pchTailState ++ ;
				if( *m_pchTailState == '\0' ) {
					fFinished = TRUE ;
					//
					//	Have got the entire terminating sequence - break !
					//
					pch++ ;
					break ;
				}
			}	else	{
				if( *pch == m_pchMatch[0] ) {
					m_pchTailState = &m_pchMatch[1] ;
				}	else	{
					m_pchTailState = &m_pchMatch[0] ;
				}
			}
			pch++ ;
		}
	}	else	{
		while( pch < pchEnd ) {
			if( *pch == *m_pchTailState ) {
				m_pchTailState ++ ;
				if( *m_pchTailState == '\0' ) {
					fFinished = TRUE ;
					//
					//	Have got the entire terminating sequence - break !
					//
					pch++ ;
					break ;
				}
			}	else	{
				if( *pch == m_pchMatch[0] ) {
					m_pchTailState = &m_pchMatch[1] ;
				}	else	{
					m_pchTailState = &m_pchMatch[0] ;
				}
			}
			pch++ ;
		}
	}

	cbArticleBytes = (DWORD)(pch-pchStart) ;

	//
	//	Check to see whether we need to remove CIOGetArticleEx from
	//	its flow control state !
	//
	if( pRead->m_dwExtra1 != 0 ) {
		//
		//	This Read was issued by the thread that completes writes to
		//	a file, and was marked to indicate we should leave our flow
		//	control state !
		//
		m_fFlowControlled = FALSE ;
		m_cFlowControlled = LONG_MIN ;
	}
	//
	//	Issue a new read if Necessary !!
	//
	BOOL	eof ;
	if( !fFinished )	{
		if( InterlockedIncrement( &m_cFlowControlled ) < 0 ) {
			if( sign < 0 ) {
				do	{
					CReadPacket*	pNewRead=pRead->m_pOwner->CreateDefaultRead( cbLargeRequest ) ;
					if( pNewRead )	{
						pNewRead->m_dwExtra1 = 0 ;
						pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;
					}	else	{
						// bugbug ... Need better Error handling !!
						_ASSERT( 1==0 ) ;
					}
				}	while( InterlockedIncrement( &m_cReads ) < 0 ) ;
			}
		}
	}

	//
	//	We can do some validation here !
	//	dont go past the end of the buffer !
	//
	_ASSERT( pch <= pchEnd ) ;	
	//
	//	either find the end of the article or examine all the bytes in buffer !
	//
	_ASSERT( *m_pchTailState == '\0'
				|| pch == pchEnd
				|| (m_pchErrorMatch != 0 && m_pchErrorState != 0 && *m_pchErrorState == '\0' ) ) ;	
	_ASSERT( fFinished || pch == pchEnd ) ;
	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	//
	//	Boolean indicating whether we have examined and used all the bytes
	//	in the completed read.  Start out assuming that we haven't.
	//	
	BOOL	fConsumed = FALSE ;

	//
	//	Are we still trying to accumulate all the bytes in the header of
	//	the article ? If so save the bytes away,
	//	Or if we have a bunch of room in the header buffer, then put
	//	whatever article bytes we have in there as well !
	//
	DWORD	cbAvailable = HeaderSpaceAvailable() ;
	if( !m_pFileDriver && !m_fSwallow ) 	{
		m_cwrites = 0 ;
		if( m_pArticleHead != 0 ) {

			if( cbAvailable > cbArticleBytes ||
				GetBiggerHeaderBuffer( *pRead->m_pOwner, cbArticleBytes ) ) {
				fConsumed = TRUE ;
				FillHeaderSpace( pchStart, cbArticleBytes ) ;	
				pchStartBody += cbArticleBytes ;
	
			}	else	{
	
				//
				//	Blow off whatever buffers we have - when we call
				//	the m_pState's completion function we will indicate
				//	that we had an error !
				//
//				if( !ResetHeaderState( *pRead->m_pOwner ) ) {
					//
					//	A fatal error !!! Can't open a file to hold the article !!!
					//
					pRead->m_pOwner->UnsafeClose(	pSocket,
														CAUSE_OOM,
													GetLastError(),
													TRUE
													) ;
						pio = 0 ;
					return	cbArticleBytes ;
//				}
			}
		}	else	{
			//
			//	First time we've completed a read - set up to hold the
			//	header information !
			//		
			fConsumed = TRUE ;	
			InitializeHeaderSpace( pRead, cbArticleBytes ) ;			
		}
		if( fFinished ) {
			//
			//	Must terminate for one of these reasons !
			//
			_ASSERT( *m_pchTailState == '\0' ||
						(m_pchErrorState != 0 && *m_pchErrorState == '\0') ) ;
			BOOL	fGoodMatch = *m_pchTailState == '\0' ;
			//
			//	Received the entire article into a buffer -
			//	lets call the state and let him know !
			//
			//	First however - we will check to see whether we
			//	need to get our client a separate buffer
			//	so that they have play room !
			//
			CBUFPTR	pTemp = m_pArticleHead ;
			if( pTemp == pRead->m_pbuffer ) {
				//
				//	Oh-oh - we're using the IO buffer directly -
				//	we should make sure we get to use the whole
				//	thing - if not make a copy !!
				//
				if( pch != pchEnd ) {
					//
					//	Need to make a copy of the data !
					//
					if( GetBiggerHeaderBuffer( *pRead->m_pOwner, 0 ) ) {
						pTemp = m_pArticleHead ;
					}	else	{
						//
						//	OUT of Memory ! this is a FATAL error !
						//
						pRead->m_pOwner->UnsafeClose(	pSocket,
													CAUSE_OOM,
													__LINE__,
													TRUE
													) ;
					}
				}
			}
			DWORD	ibStart = m_ibStartHeadData ;
			DWORD	cb = m_ibEndHeadData - ibStart ;
			//
			//	Reset all our member variables -
			//	we may be re-used by the calling state
			//	but we want to start our clean !
			//
			m_pchTailState = 0 ;
			m_pchMatch = 0 ;
			m_pArticleHead = 0 ;
			m_ibStartHead = 0 ;
			m_ibEndHead = 0 ;
			m_ibStartHeadData = 0 ;
			m_ibEndHeadData = 0 ;
			_ASSERT( m_cwrites == 0 ) ;
			_ASSERT( !m_fFlowControlled ) ;
			_ASSERT( m_pWrite == 0 ) ;
			_ASSERT( FValid() ) ;

			//
			//	Errors could have caused us to not have a usable buffer
			//	so double check before completing !
			//
			if( pTemp ) 	{
				pio = m_pState->Complete(	this,
										pSocket,
										fGoodMatch,
										pTemp,
										ibStart,
										cb
										) ;
			}


			_ASSERT( FValid() ) ;

		}	
		//
		//	This is the number of bytes we've consumed
		//	from the current packet !
		//
		return	cbArticleBytes ;
	}	else	if( m_fSwallow ) 	{
		//
		//	If we are swallowing all the bytes, all we need to do
		//	is see if we're terminated !
		//
		if( fFinished ) 	{
			_ASSERT( *m_pchTailState == '\0' ||
						(m_pchErrorState != 0 && *m_pchErrorState == '\0') ) ;
			pio = m_pState->Complete(	this,
										pSocket	
										) ;

		}
		return	cbArticleBytes ;
	}

	//
	//	If we enter this portion of CIOGetArticleEx than
	//	we are not picking up errors !
	//
	_ASSERT( m_pchErrorState == 0 ) ;
	_ASSERT( m_pchErrorMatch == 0 ) ;

	//
	//	Issue a write, unless the user is sending small packets,
	//	in which case we will accumulate the data !!
	//
	//
	//	Note - use pchStartBody in all calculations here, as we may have
	//	taken a fraction of the bytes into our header buffer !!
	//
	if (fFinished) {
        pio = 0;
	    unsigned	cbSmall = (unsigned)(pch - pchStart) ;

	    //
	    // Grab the write packet for later use
	    //
	    CWritePacket* pWrite = m_pWrite;
	    m_pWrite = 0;
	    
        //
        // If we have a buffer and the data will fit in it, copy it in.
        //
        if (pWrite != 0 && ((pWrite->m_ibEnd - pWrite->m_ibEndData) > cbSmall)) {
		    CopyMemory( pWrite->EndData(), pchStart, cbSmall ) ;
		    pWrite->m_ibEndData += cbSmall ;
            m_cwrites -- ;		// There will never be a corresponding write for this completiong
    	    				    // as we copied the data into another buffer. SO decrement the count.
        } else {
            //
            // If we're here, then we don't have a buffer, or it's not big
            // enough for the data.
            //
            if (pWrite != 0) {
                // Flush the old buffer since we had one.
                DoFlowControl(INST(pSocket));
                m_pFileDriver->IssuePacket(pWrite, pSocket, eof);
            }

            // Allocate a new buffer

            unsigned ibEnd = pRead->m_ibStartData + cbSmall;
            pWrite = m_pFileDriver->CreateDefaultWrite(
                pRead->m_pbuffer,
                pRead->m_ibStartData, ibEnd,
                pRead->m_ibStartData, ibEnd);

            if (pWrite) {
                pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart);
                _ASSERT(pWrite->m_ibStartData < pWrite->m_ibEndData);
            } else {
                pRead->m_pOwner->UnsafeClose(pSocket, CAUSE_OOM, GetLastError(), TRUE);
            }
        }

        //
        // Buffers have been set up as needed.  Flush them to disk
        //
        // Hack so that we call FIOWriteFileEx correctly within
        // CFileChannel::Write
        //
        if (pWrite) {
            pWrite->m_dwExtra2 = 1;
            DoFlowControl(INST(pSocket));
            m_pFileDriver->IssuePacket(pWrite, pSocket, eof);
        }


        _ASSERT(eof == FALSE);
        _ASSERT(*m_pchTailState == '\0');
        _ASSERT(pchStart == pRead->StartData());
        _ASSERT(pchEnd == pRead->EndData());

        m_pFileChannel->FlushFileBuffers();
        return (int)(pch - pchStart);
    } else {

	    unsigned	cbSmall = (unsigned)(pchEnd - pchStartBody) ;
	    if( cbSmall < cbTooSmallWrite )	{
		    if( m_pWrite == 0 )	{
			    m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
			    if (m_pWrite == NULL) {
            		pRead->m_pOwner->UnsafeClose(pSocket,
						CAUSE_OOM,
						GetLastError(),
						TRUE
						) ;
			        return 0;
			    }
			    m_pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart) ;
		    }	else	{
			    if( (m_pWrite->m_ibEnd - m_pWrite->m_ibEndData) > cbSmall )		{
				    CopyMemory( m_pWrite->EndData(), pchStartBody, cbSmall ) ;
				    m_pWrite->m_ibEndData += cbSmall ;
                    m_cwrites -- ;		// There will never be a corresponding write for this completiong
				    				    // as we copied the data into another buffer. SO decrement the count.
			    }	else	{
				    //
				    //	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
				    //  our destructor if an error has occurred !!
				    //
	                // BUGBUG: Here is where I want to check size and alloc 32k
				    CWritePacket*	pTempWrite = m_pWrite ;
				    m_pWrite = 0 ;
				    DoFlowControl( INST(pSocket) ) ;
				    m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
				    m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
			    }
		    }
		    // If we came through here we should have consumed all bytes in the packet!
		    _ASSERT( pch == pchEnd ) ;
		    _ASSERT( unsigned(pch - pchStart) == pRead->m_cbBytes ) ;
            return	(int)(pch - pchStart) ;
	    }
    }

	if( m_pWrite )	{
		CWritePacket*	pTempWrite = m_pWrite ;
		m_pWrite = 0 ;

		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
	}
	

	CWritePacket*	pWrite = 0 ;
	if( pch == pchEnd )		{
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead ) ;
	}	else	{
		unsigned	ibEnd = pRead->m_ibStartData + (unsigned)(pch - pchStart) ;
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead->m_pbuffer,
						pRead->m_ibStartData, ibEnd,
						pRead->m_ibStartData, ibEnd ) ;
	}

	if( pWrite )	{

		//
	    //	It is possible that long before we reached here we took a portion
    	//	of this packet and placed it into our header buffer - so adjust for that
	    //	if it occurred !!
    	//
	    pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart) ;

    	_ASSERT( pWrite->m_ibStartData < pWrite->m_ibEndData ) ;

		DoFlowControl( INST(pSocket) ) ;
		//
		//	Hack so that we call FIOWriteFileEx correctly within 
		//	CFileChannel::Write !
		//
		if( fFinished ) 	{
			pWrite->m_dwExtra2 = 1 ;
		}
		m_pFileDriver->IssuePacket( pWrite, pSocket, eof ) ;

	}	else	{

		pRead->m_pOwner->UnsafeClose(	pSocket,
										CAUSE_OOM,
										GetLastError(),
										TRUE
										) ;

	}
	_ASSERT( eof == FALSE ) ;

	if( fFinished )	{
		_ASSERT( *m_pchTailState == '\0' ) ;
		m_pFileChannel->FlushFileBuffers() ;
	}

	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	return	(int)(pch - pchStart) ;
}

int	
CIOGetArticleEx::Complete(	CSessionSocket*	pSocket,	
							CWritePacket *pWrite,	
							CIO*&	pioOut ) {
/*++

Routine Description :

	Called whenever a write to a file completes.
	We must determine whether we have completed all the writes
	we are going to do and if so call the state's completion function.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet that was writtne to the file.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	TraceFunctEnter( "CIOGetArticleEx::Complete" ) ;

	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pWrite != 0 ) ;
	_ASSERT( pioOut == this ) ;

	m_cwritesCompleted++ ;

	long	cFlowControlled = 0 ;

	//
	//	Process the completion of a write to a file.
	//	determine whether we need to signal the entire transfer
	//	as completed.
	//

	if( *m_pchTailState == '\0' && m_cwritesCompleted == m_cwrites )	{

		// BUGBUG: loss of 64-bit precision
		DWORD	cbTransfer = DWORD( LOW(pWrite->m_iStream) + pWrite->m_cbBytes ) /*- m_pFileChannel-> */ ;
		FIO_CONTEXT*	pFIOContext= m_pFileChannel->ReleaseSource() ;
		_ASSERT( pFIOContext != 0 ) ;
		_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;

		m_pState->Complete(	this,
							pSocket,
							pFIOContext,
							cbTransfer
							) ;


		//
		//	NOT ALLOWED TO RETURIN A NEW IO OPERATION !!! Because this function is
		//	operating in a Channel which is temporary !!!
		//
		//	We do not set pioOut to zero, as we want the CIODriver to
		//	call out Shutdown function during its termination processing !
		//
		//	Now we must destroy our channels !!!
		//
		DebugTrace( (DWORD_PTR)this, "Closing File Driver %x ", m_pFileDriver ) ;
		Term( pSocket, FALSE ) ;
		DebugTrace( (DWORD_PTR)this, "deleting self" ) ;

	}	else	if( ( m_fFlowControlled ) ) {

		if( m_cwrites - m_cwritesCompleted <= RESTORE_FLOW && m_pSocketSink != 0 )	{
			//
			//	ALWAYS issue at least 1 read when coming out of a flow control state !!
			//

			CReadPacket*	pRead = 0 ;

			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );

			cFlowControlled = m_cFlowControlled + 1 ;
			while( cFlowControlled >= 1  ) {
				if( m_pSocketSink == 0 )
					break ;
				pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
				if( 0!=pRead )	{
					BOOL	eof ;
					InterlockedIncrement( &m_cReads ) ;
					pRead->m_dwExtra1 = 0 ;
					pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
				}	
				cFlowControlled -- ;
			}	

			//
			//	The following read is special - we set the m_dwExtra1 field so that
			//	the read completion code can determine that it is time to leave
			//	the flow control state !
			//
			pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
			if( 0!=pRead )	{
				BOOL	eof ;
				pRead->m_dwExtra1 = 1 ;
				InterlockedIncrement( &m_cReads ) ;
				pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
			}	else	{

				//
				//	Fatal error - drop the session !
				//
				m_pSocketSink->UnsafeClose(	pSocket,
											CAUSE_OOM,
											GetLastError(),
											TRUE
											) ;
				return	pWrite->m_cbBytes ;

			}
			cFlowControlled -- ;

			InterlockedExchange( &m_cFlowControlled, LONG_MIN ) ;
			// Set to FALSE after InterlockedExchange !!
			m_fFlowControlled = FALSE ;

		}
	}

	return	pWrite->m_cbBytes ;
}






//
//	Maximum number of pending reads while reading an article
//
unsigned	CIOReadArticle::maxReadAhead = 3 ;
//
//	Number of bytes to accumulate before writing to a file !
//
unsigned	CIOReadArticle::cbTooSmallWrite = 1024 ;


CIOReadArticle::CIOReadArticle( CSessionState*	pstate,
								CSessionSocket*	pSocket,	
								CDRIVERPTR&	pDriver,
								CFileChannel*	pFileChannel,
								DWORD			cbLimit,
								BOOL fPartial )	:
/*++

Routine Description :

	Class Constructor

Arguments :
	
	pstate - The State which is issuing us and who's completion function
			we should later call
	pSocket -	The socket on which we will be issued
	pDriver -	The CIODriver object handling all of the socket's IO
	pFileChannel -	The File Channel into which we should save all data
	fPartial	- If TRUE then we should assume that a CRLF has already
				been sent and '.\r\n' alone can terminate the article.

Return Value :
	
	None

--*/

	//
	//	Get a CIOReadArticle object half way set up - user still needs
	//	to call Init() but we will do much here !
	//
	CIORead( pstate ),
	m_pFileChannel( pFileChannel ),	
	m_pFileDriver( new CIODriverSink( pDriver->GetMediumCache() ) ),
	m_pSocketSink( pDriver ),
	m_fDriverInit( FALSE ),
	m_cwrites( 0 ),
	m_cwritesCompleted( 0 ),
	m_cFlowControlled( LONG_MIN ),
	m_fFlowControlled( FALSE ),
	m_cReads( 0 ),
	m_pWrite( 0 ),
	m_cbLimit( cbLimit )
#ifdef	CIO_DEBUG
	,m_fSuccessfullInit( FALSE ),
	m_fTerminated( FALSE )
#endif
{

	ASSIGNI( m_HardLimit, 0 );

	if( fPartial )
		m_artstate = BEGINLINE ;
	else	
		m_artstate = NONE ;

	TraceFunctEnter( "CIOReadArticle::CIOReadArticle" ) ;

	ErrorTrace( (DWORD_PTR)this, "CIOReadArticle - created file driver %x using channel %x", ((CIODriverSink*)m_pFileDriver), ((CFileChannel*)pFileChannel) ) ;

	_ASSERT( m_pFileDriver != 0 ) ;
	_ASSERT( pFileChannel != 0 ) ;
	_ASSERT( pstate != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pDriver != 0 ) ;
	_ASSERT(	!m_pFileChannel->FReadChannel() ) ;
}

CIOReadArticle::~CIOReadArticle( )	{
/*++

Routine Description :

	Class Destructor

Arguments :
	
	None

Return Value :
	
	None

--*/

	//
	//	Destroy a CIOReadArticle - always close our m_pFileDriver if possible
	//	in case we are terminated due to some socket error.
	//
	TraceFunctEnter( "CIOReadArticle::~CIOReadArticle" ) ;

#ifdef	CIO_DEBUG
	//
	//	Our destructor should only be called if we weren't successfully init
	//	or after Term() has been called.
	//
	_ASSERT( !m_fSuccessfullInit || m_fTerminated ) ;
#endif

	DebugTrace( (DWORD_PTR)this, "m_pFileDriver %x m_fDriverInit %x", m_pFileDriver, m_fDriverInit ) ;

	if( m_pFileDriver != 0 ) {
		if( m_fDriverInit )		{
			m_pFileDriver->UnsafeClose( (CSessionSocket*)this, CAUSE_NORMAL_CIO_TERMINATION, 0, FALSE ) ;
		}
	}
	if( m_pWrite != 0 ) {
		CPacket::DestroyAndDelete( m_pWrite ) ;
		m_pWrite = 0 ;
	}
}

BOOL
CIOReadArticle::Init(	CSessionSocket* pSocket,
						unsigned cbOffset )	{
/*++

Routine Description :

	Initialize object.

Arguments :

	pSocket - The socket we are reading the article from,
	cbOffset -  Unused

Return Value :

	TRUE if succesfull initialized - must be destroyed with a call to Term()
	FALSE if not successfully initialized - do not call Term()


--*/
	//
	//	Prepare to copy from the specified socket into the specified file
	//
	BOOL	fRtn = FALSE ;
	if( m_pFileDriver!= 0 )	{
		if( m_pFileDriver->Init( m_pFileChannel, pSocket, ShutdownFunc, (void*)this ) )	{
			m_fDriverInit = TRUE ;
			if( !m_pFileDriver->SendWriteIO( pSocket, *this, FALSE ) )	{
				fRtn = FALSE ;
			}	else	{
				fRtn = TRUE ;
#ifdef	CIO_DEBUG
				m_fSuccessfullInit = TRUE ;
#endif				
			}
		}	
	}	
	return	fRtn ;
}

void
CIOReadArticle::Term(	CSessionSocket*	pSocket,
						BOOL			fAbort,
						BOOL			fStarted	)	{
/*++

Routine Description :

	Start destroying a successfully initialize CIOReadArticle object

Arguments :
	
	fAbort - If TRUE then destroy the socket which we were using
			If FALSE then only close down our File Channel's

Return Value :

	None

--*/
#ifdef	CIO_DEBUG
	m_fTerminated = TRUE ;
#endif
	//
	//	Start us on our way to destruction !!
	//	If we have been successfully Initialized, then this will
	//	lead to our destruction when our m_pFileDriver eventually shutsdown.
	//	(Since we were succesfully Init() our m_pFileDriver has a reference to us,
	//	so we must allow it to shutdown and destroy us to avoid problems with
	//	circular references and multiple frees !)
	//

	if( m_pFileDriver != 0 ) {
		m_pFileDriver->UnsafeClose( pSocket,
				fAbort ? CAUSE_USERTERM : CAUSE_NORMAL_CIO_TERMINATION, 0, FALSE ) ;
	}
}


void
CIOReadArticle::Shutdown(	CSessionSocket*	pSocket,	
							CIODriver&		driver,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dwOptional )	{
/*++

Routine Description :

	Do whatever work is necessary when one of the two CIODriver's we are
	using is terminated.

Arguments :

	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	TraceFunctEnter( "CIOreadArticle::Shutdown" ) ;
	DebugTrace( (DWORD_PTR)this, "SHutdown args - pSocket %x driver %x cause %x dw %x",
			pSocket, &driver, cause, dwOptional ) ;

	//
	//	This function is called when the CIODriver's we are refenced by our closing down.
	//	Since we are referenced by two of them (one for the socket and one for the file)
	//	we only want to be deleted by the CIODriver for the file.
	//
	if( &driver == m_pFileDriver )	{
		// Out file is closing - what can we do about it !
		//_ASSERT( 1==0 ) ;
#ifdef	CIO_DEBUG
		m_fTerminated = TRUE ;
#endif

		//
		//	We set this to 0 here as we know we will be called here by
		//	the same thread that is completing writes to the file - so
		//	since that's the only thread referencing this member variable -
		//	there are no thread safety issues accessing that member.
		//

		m_pSocketSink = 0 ;

		if ( m_fFlowControlled )
		{
			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );
		}

		//return	TRUE ;

	}	else	{
		// Close down the rest of our stuff as well !!
		Term( pSocket, cause != CAUSE_NORMAL_CIO_TERMINATION ) ;
	}
}

void
CIOReadArticle::ShutdownFunc(	void *pv,	
								SHUTDOWN_CAUSE	cause,	
								DWORD dw ) {
/*++

Routine Description :

	Notification function which is called when a CIODriver used by
	a CIOReadArticle if finally destroyed.  This function is provided
	to the CIODriver we use for File IO's during out Init().

Arguments :

	pv	-	Pointer to dead CIOReadArticle - this has been destroyed dont use !
	cause -	The reason for termination
	dw		Optional extra information regarding termination

Return Value :

	None

--*/

	TraceFunctEnter( "CIOreadArticle::ShutdownFunc" ) ;
	//
	//	This function gets notified when a CIOFileDriver used by CIOReadArticle
	//	is terminated.  Not much for us to worry about.
	//	(CIODriver's require these functions)
	//

	//_ASSERT( 1==0 ) ;
	return ;
}

BOOL
CIOReadArticle::Start(	CIODriver&	driver,	
						CSessionSocket	*pSocket,	
						unsigned cReadAhead )	{
/*++

Routine Description :

	This function is called to start transferring data from the socket
	into the file.

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/


	_ASSERT( pSocket != 0 ) ;

	m_cReads = -((long)maxReadAhead) + cReadAhead ;

	while( cReadAhead < maxReadAhead )	{
		//
		//	Start reading data from the socket
		//
		CReadPacket*	pRead = driver.CreateDefaultRead( cbMediumRequest ) ;
		if( 0!=pRead )	{
			BOOL	eof ;
			pRead->m_dwExtra1 = 0 ;
			driver.IssuePacket( pRead, pSocket, eof ) ;
			cReadAhead++ ;
			InterlockedIncrement( &m_cReads ) ;
		}	else	{
			//
			// This is a fatal problem only if we couldn't issue ANY reads at all !
			//
			if( cReadAhead == 0 )
				return FALSE  ;
		}
	}	
	return	TRUE ;
}


void
CIOReadArticle::DoFlowControl(PNNTP_SERVER_INSTANCE pInstance)	{
/*++

Routine Description :

	Check whether it is necessary to set flow control due to
	too many outstanding writes.
	If necessary, then the first time we do put ourselves into Flow Control,
	try to flush our pending writes.
	We should be called only immediately before issuing an Async Write to the file
	to ensure that a CWritePacket completion will actually execute the necessary
	code to restart a flow controlled session.
	(Otherwisse, we could potentially decide to Flow control the session
	and before setting m_fFlowControlled to TRUE all the pending writes complete
	and then we'd be left in a boat where there are no pending reads or
	writes and no way to get out of the flow control state.)

Arguments :

	None.

Return Value :

	None.


--*/

	//
	//	Important - do all tests of m_fFlowControlled before setting
	//	m_cFlowControlled - as other thread will touch m_cFlowControlled
	//	before touching m_fFlowControlled !!
	//	(Will only touch m_fFlowControlled if m_fFlowControlled is TRUE ) !
	//	Thus we know that if m_fFlowControlled is FALSE there is nobody
	//	messing with m_cFlowControlled,
	//
	//

	if( m_cwrites - m_cwritesCompleted > MAX_OUTSTANDING_FILE_WRITES ) {
		
		if( m_fFlowControlled ) {
			// All ready have flow control turned on
			;
		}	else	{
			m_cFlowControlled = -1 ;
			m_fFlowControlled = TRUE ;
			m_pFileChannel->FlushFileBuffers() ;

			IncrementStat( pInstance, SessionsFlowControlled );
		}
	}	else	{
		if( !m_fFlowControlled ) {
			m_cFlowControlled = LONG_MIN ;	// Keep resetting !
		}
	}
}

int
CIOReadArticle::Complete(	CSessionSocket*	pSocket,	
							CReadPacket	*pRead,	
							CIO*&	pio	)	{
/*++

Routine Description :

	Called whenever a CReadPacket we have issued completes.
	We only issue packets against the socket.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	//
	//	This function determines whether we've read an entire article and if so
	//	starts wrapping things up.
	//	All article data we get is either accumulated or issued as a write
	//	to our file.
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	pRead != 0 ) ;
	_ASSERT( pio == this ) ;

	ASSIGNI(m_HardLimit, m_cbLimit);
	if(!EQUALSI(m_HardLimit, 0)) {
		if( GREATER( pRead->m_iStream, m_HardLimit ) ) {
			pRead->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_ARTICLE_LIMIT_EXCEEDED,
											0,
											TRUE ) ;
			return	pRead->m_cbBytes ;
		}
	}


	//
	//	Bump the count of writes because we KNOW that IF this is the last read
	//	we will issue a write, CONSEQUENTLY we don't want to confuse the Write Completion
	//	function as to when we are finished.
	//	(It is important to increment before we set the COMPLETE state so that the
	//	thread where writes are completing doesn't get confused and terminate early.)
	//
	//	NOW there is a chance that we won't write this out immediately - in which case we
	//	need to have a matching decrement.	
	//
	long sign = InterlockedDecrement( &m_cReads ) ;
	long signShutdowns = -1 ;
	m_cwrites ++ ;
	_ASSERT( m_cwrites > 0 ) ;

	char	*pch = pRead->StartData();
	char	*pchStart = pch ;
	char	*pchEnd = pRead->EndData() ;
	while(	pch < pchEnd )	{
		if( *pch =='.' && m_artstate == BEGINLINE )	{
			m_artstate = PERIOD ;
		}	else	if( *pch == '\r' )	{
			if( m_artstate == PERIOD )
				m_artstate = COMPLETENEWLINE ;
			else
				m_artstate = NEWLINE ;
		}	else	if( *pch == '\n' )	{
			if( m_artstate == COMPLETENEWLINE ) {
				m_artstate = COMPLETE ;
				pch++ ;		// so that pch points one past end of article !
				break ;
			}	else	if(	m_artstate == NEWLINE )	{
				m_artstate = BEGINLINE ;
			}	else	{
				m_artstate = NONE ;
			}
		}	else	{
			m_artstate = NONE ;
		}
		pch ++ ;
	}
	_ASSERT( pch <= pchEnd ) ;
	_ASSERT( m_artstate == COMPLETE || pch == pchEnd ) ;	// If the article ain't complete
														// then ALL bytes better be consumed !

	//
	//	Check to see whether we need to remove CIOReadArticle from
	//	its flow control state !
	//
	if( pRead->m_dwExtra1 != 0 ) {
		//
		//	This Read was issued by the thread that completes writes to
		//	a file, and was marked to indicate we should leave our flow
		//	control state !
		//
		m_fFlowControlled = FALSE ;
		m_cFlowControlled = LONG_MIN ;
	}
		

	//
	//	Issue a new read if Necessary !!
	//
	BOOL	eof ;
	if( m_artstate != COMPLETE )	{
		if( InterlockedIncrement( &m_cFlowControlled ) < 0 ) {
			if( sign < 0 ) {
				do	{
					CReadPacket*	pNewRead=pRead->m_pOwner->CreateDefaultRead( cbMediumRequest ) ;
					if( pNewRead )	{
						pNewRead->m_dwExtra1 = 0 ;
						pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;
					}	else	{
						// bugbug ... Need better Error handling !!
						_ASSERT( 1==0 ) ;
					}
				}	while( InterlockedIncrement( &m_cReads ) < 0 ) ;
			}
		}
	}	else	{
		pio = 0 ;
		//m_pFileChannel->FlushFileBuffers() ;
	}


	//
	//	Issue a write, unless the user is sending small packets,
	//	in which case we will accumulate the data !!
	//
	if( m_artstate != COMPLETE )	{
		unsigned	cbSmall = (unsigned)(pchEnd - pchStart) ;
		if( cbSmall < cbTooSmallWrite )	{
			if( m_pWrite == 0 )	{
				m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
			}	else	{
				if( (m_pWrite->m_ibEnd - m_pWrite->m_ibEndData) > cbSmall )		{
					CopyMemory( m_pWrite->EndData(), pchStart, cbSmall ) ;
					m_pWrite->m_ibEndData += cbSmall ;
					m_cwrites -- ;		// There will never be a corresponding write for this completiong
										// as we copied the data into another buffer. SO decrement the count.
				}	else	{
					//
					//	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
					//  our destructor if an error has occurred !!
					//
					CWritePacket*	pTempWrite = m_pWrite ;
					m_pWrite = 0 ;
					DoFlowControl( INST(pSocket) ) ;
					m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
					m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
				}
			}
		// If we came through here we should have consumed all bytes in the packet!
		_ASSERT( pch == pchEnd ) ;
		_ASSERT( unsigned(pch - pchStart) == pRead->m_cbBytes ) ;
		return	(int)(pch - pchStart) ;
		}
		
	}

	if( m_pWrite )	{
		CWritePacket*	pTempWrite = m_pWrite ;
		m_pWrite = 0 ;

		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
	}
	

	CWritePacket*	pWrite = 0 ;
	if( pch == pchEnd ) 		
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead ) ;
	else	{
		unsigned	ibEnd = pRead->m_ibStartData + (unsigned)(pch - pchStart) ;
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead->m_pbuffer,
						pRead->m_ibStartData, ibEnd,
						pRead->m_ibStartData, ibEnd ) ;
	}
	if( pWrite )	{
		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pWrite, pSocket, eof ) ;

	}	else	{
		// Bug bug .... Error Handling Required
		_ASSERT( 1==0 ) ;
	}
	_ASSERT( eof == FALSE ) ;

	if( m_artstate == COMPLETE )	{
		m_pFileChannel->FlushFileBuffers() ;
	}

	return	(int)(pch - pchStart) ;
}

int	
CIOReadArticle::Complete(	CSessionSocket*	pSocket,	
							CWritePacket *pWrite,	
							CIO*&	pioOut ) {
/*++

Routine Description :

	Called whenever a write to a file completes.
	We must determine whether we have completed all the writes
	we are going to do and if so call the state's completion function.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet that was writtne to the file.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	TraceFunctEnter( "CIOReadArticle::Complete" ) ;

	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pWrite != 0 ) ;
	_ASSERT( pioOut == this ) ;

	m_cwritesCompleted++ ;

	long	cFlowControlled = 0 ;

	//
	//	Process the completion of a write to a file.
	//	determine whether we need to signal the entire transfer
	//	as completed.
	//

	if( m_artstate == COMPLETE && m_cwritesCompleted == m_cwrites )	{

		// BUGBUG: loss of precision in 64-bit arithmetic !!
		DWORD	cbTransfer = DWORD( LOW(pWrite->m_iStream) + pWrite->m_cbBytes ) ;

		m_pState->Complete( this, pSocket, pWrite->m_pOwner, *m_pFileChannel, cbTransfer ) ;
		//
		//	NOT ALLOWED TO RETURIN A NEW IO OPERATION !!! Because this function is
		//	operating in a Channel which is temporary !!!
		//

		//	We do not set pioOut to zero, as we want the CIODriver to
		//	call out Shutdown function during its termination processing !


		//
		//	Now we must destroy our channels !!!
		//

		DebugTrace( (DWORD_PTR)this, "Closing File Driver %x ", m_pFileDriver ) ;
		
		//m_pFileDriver->Close( pSocket,	CAUSE_LEGIT_CLOSE, 0, FALSE ) ;
		Term( pSocket, FALSE ) ;

		DebugTrace( (DWORD_PTR)this, "deleting self" ) ;

	}	else	if( ( m_fFlowControlled ) ) {

		if( m_cwrites - m_cwritesCompleted <= RESTORE_FLOW && m_pSocketSink != 0 )	{
			//
			//	ALWAYS issue at least 1 read when coming out of a flow control state !!
			//
			CReadPacket*	pRead = 0 ;

			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );

			cFlowControlled = m_cFlowControlled + 1 ;
			while( cFlowControlled >= 1  ) {
				if( m_pSocketSink == 0 )
					break ;
				pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
				if( 0!=pRead )	{
					BOOL	eof ;
					InterlockedIncrement( &m_cReads ) ;
					pRead->m_dwExtra1 = 0 ;
					pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
				}	
				cFlowControlled -- ;
			}	
			//
			//	The following read is special - we set the m_dwExtra1 field so that
			//	the read completion code can determine that it is time to leave
			//	the flow control state !
			//
			pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
			if( 0!=pRead )	{
				BOOL	eof ;
				pRead->m_dwExtra1 = 1 ;
				InterlockedIncrement( &m_cReads ) ;
				pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
			}	else	{

				//
				//	Fatal error - drop the session !
				//
				m_pSocketSink->UnsafeClose(	pSocket,
											CAUSE_OOM,
											GetLastError(),
											TRUE
											) ;
				return	pWrite->m_cbBytes ;

			}
			cFlowControlled -- ;

			//
			InterlockedExchange( &m_cFlowControlled, LONG_MIN ) ;
			// Set to FALSE after InterlockedExchange !!
			m_fFlowControlled = FALSE ;

		}
	}

	return	pWrite->m_cbBytes ;
}


char	CIOReadLine::szLineState[] = "\r\n" ;

CIOReadLine::CIOReadLine(
					CSessionState*	pstate,
					BOOL	fWatchEOF
					) :
	//
	//	Initialize a CIOReadLine object -
	//	set member variables to neutral values.
	//
	CIORead( pstate ),
	m_fWatchEOF( fWatchEOF ),
	m_pbuffer( 0 ),
	m_pchStart( 0 ),
	m_pchStartData( 0 ),
	m_pchEndData( 0 ),	
	m_pchEnd( 0 ),
	m_pchLineState( &szLineState[0] )	{


	TraceFunctEnter( "CIOReadLine::CIOReadLine" ) ;

	DebugTrace( (DWORD_PTR)this, "New CIOREadline on state %x", pstate ) ;
}

BOOL
CIOReadLine::Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead ) {
/*++

Routine Description :

	This function is called to start reading data from the socket

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/


	//
	//	Start issuing reads !
	//	only do so if there isn't any completed data waiting for us !
	//
	TraceFunctEnter( "CIOReadLine::Start" ) ;

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	m_pbuffer == 0 ) ;
	_ASSERT(	m_pchStart == 0 ) ;
	_ASSERT(	m_pchStartData == 0 ) ;
	_ASSERT(	m_pchEndData == 0 ) ;
	_ASSERT(	m_pchEnd == 0 ) ;

	DebugTrace( (DWORD_PTR)this, "cReadAhead %d driver& %x pSocket %x", cReadAhead, &driver, pSocket ) ;

	if( cReadAhead < 2 )	{

		unsigned	cLimit = 2 ;
		if( m_fWatchEOF ) {
			cLimit = 1 ;
		}

		while( cReadAhead < cLimit )	{
			//
			//	Start reading data from the socket
			//
			CReadPacket*	pRead = driver.CreateDefaultRead( cbSmallRequest ) ;
			if( 0!=pRead )	{
				BOOL	eof ;
				driver.IssuePacket( pRead, pSocket, eof ) ;
				cReadAhead++ ;
			}	else	{
				//
				// This is a fatal problem only if we couldn't issue ANY reads at all !
				//
				if( cReadAhead == 0 )
					return FALSE  ;
			}
		}	

	}	else	{

		driver.ResumeTimeouts() ;
	
	}
	return	TRUE ;
}

void
CIOReadLine::Shutdown(	CSessionSocket*	pSocket,	
						CIODriver&		driver,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We have nothing to worry about here - as long as our destuctor
	is called everything will be cleaned up.

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Alwasy TRUE - we want to be destroyed.

--*/

	//
	//	WE get notified here when the CIODriver is shutting down.
	//	there's not much to do but to tell the driver to destroy us
	//	when done.
	//
	TraceFunctEnter( "CIOReadLine::Shutdown" ) ;
}



int	CIOReadLine::Complete(	IN CSessionSocket*	pSocket,	
							IN CReadPacket*	pRead,	
							OUT	CIO*	&pioOut ) 	{
/*++

Routine Description :

	Called whenever a CReadPacket we have issued completes.
	We only issue packets against the socket.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pioOut	- The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	TraceFunctEnter( "CIOReadLine::Complete" ) ;

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	pRead != 0 ) ;
	_ASSERT( pioOut != 0 ) ;

	char*	pchCurrent = pRead->StartData() ;
	char*	pchStart = pchCurrent ;
	char*	pchEnd = pRead->EndData() ;

	_ASSERT( pchStart != 0 ) ;
	_ASSERT(	pchEnd != 0 ) ;
	_ASSERT(	pchStart <= pchEnd ) ;
	_ASSERT( pchEnd == &pRead->m_pbuffer->m_rgBuff[ pRead->m_ibEndData ] ) ;

	//
	//	We just read some data on a socket - see if we have a complete line.
	//	If we don't, accumulate the data and make sure we have a buffer
	//	large enough to hold our max accumulation size.
	//
	//	NOTE : m_pbuffer is a reference counting smart pointer, so
	//	assigning to it will keep the buffers we are passed in CReadPackets
	//	from being destroyed and preserve them for our use !
	//

	DebugTrace( (DWORD_PTR)this, "pchCurrent %x pchStart %x pchEnd %x", pchCurrent, pchStart, pchEnd ) ;

Top :

	while( pchCurrent < pchEnd ) {

		if( *pchCurrent == *m_pchLineState ) {
			m_pchLineState ++ ;
			if( *m_pchLineState == '\0' ) {
				//
				//	Have got the entire terminating sequence - break !
				//
				pchCurrent++ ;
				break ;
			}
		}	else	{
			if( *pchCurrent == szLineState[0] ) {
				m_pchLineState = &szLineState[1] ;
			}	else	{
				m_pchLineState = &szLineState[0] ;
			}
		}
		pchCurrent++ ;
	}

	_ASSERT( pchCurrent <= pchEnd ) ;

	if( *m_pchLineState == '\0' )	{
				
		if( m_pbuffer != 0 )	{


			//
			//	If we have a buffer these must all be non-null !
			//
			_ASSERT( m_pchStartData && m_pchEndData && m_pchStart && m_pchEnd ) ;

			unsigned cb = (unsigned)(pchCurrent - pchStart)  ;
			if( cb  < (unsigned)(m_pchEnd - m_pchEndData) )	{

				CopyMemory( m_pchEndData, pchStart, cb )	;
				m_pchEndData += cb ;

			}	else	{
				
				//
				// ERROR COMPLETION !!! The line was TOOOO long
				//
				DWORD	ibZap = min( 50, (DWORD)(m_pchEnd - m_pchStartData) ) ;
				m_pchStartData[ibZap] = '\0' ;
	
				//
				//	just move the enddata pointer to be equal to the end - so that if
				//	we get called again we will always fail the completion !
				//

				pSocket->TransactionLog(	"Line too long",	m_pchStartData, NULL ) ;

				//
				//	Now kill the session ! - this will result in our desctructor getting
				//	called and everything getting cleaned up !
				//

				pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_CIOREADLINE_OVERFLOW, 0 ) ;

				//
				//	We will consume all the bytes, since we're dropping the session anyways !
				//
				return	pRead->m_cbBytes ;
			}
		}	else	{
	
			//
			//	Since we don't have a buffer these must all be Non-Null !
			//
			_ASSERT( !m_pchStartData && !m_pchEndData && !m_pchStart && !m_pchEnd ) ;

			//
			//	Did we get a CRLF alone on a line ?? if so ignore it !
			//

			if( (pchCurrent - pchStart) == (sizeof( CIOReadLine::szLineState ) - 1) )		{
				m_pchLineState = &szLineState[0] ;
				goto	Top ;
			}

			//
			//	Set up these members to point at the current line !
			//
			m_pbuffer = pRead->m_pbuffer ;
			m_pchStart = pRead->Start() ;
			m_pchStartData = pchStart ;
			m_pchEndData = pchCurrent ;
			m_pchEnd = pchCurrent ;
		}

		//
		//	Now have a complete line of text - strip white space and make
		//	array of string pointers !
		//
		_ASSERT(	m_pbuffer && m_pchStart && m_pchStartData &&
					m_pchEndData && m_pchEnd ) ;
		_ASSERT( m_pchEndData <= m_pchEnd ) ;

		char	*rgsz[ MAX_STRINGS ] ;

		ZeroMemory( rgsz, sizeof( rgsz ) ) ;
		int		isz = 0 ;

		for(	char	*pchT = m_pchStartData;
						pchT < m_pchEndData;
						pchT ++ ) {

			if( isspace( (UCHAR)*pchT ) || *pchT == '\0' )	{
				*pchT = '\0' ;
				if( rgsz[isz] != 0 ) {

					_ASSERT( strpbrk( rgsz[isz], "\r\n\t " ) == 0  ) ;

					if( (isz+1) < MAX_STRINGS )
						isz ++ ;
				}
			}	else	{
				if( rgsz[isz] == 0 ) {
					rgsz[isz] = pchT ;
				}	else if( (isz+1) == MAX_STRINGS &&
								pchT[-1] == '\0' ) {
					rgsz[isz] = pchT ;
				}
			}
		}

		DebugTrace( (DWORD_PTR)this, "call state %x with 1st arg %s", m_pState, rgsz[0] ? rgsz[0] : "(NULL)") ;

		CIO	*pio = this ;
		if( isz != 0 )	{
			pio = m_pState->Complete( this, pSocket, pRead->m_pOwner, isz, rgsz, m_pchStart ) ;

			//
			//	Reset our state entirely regardless of return value.
			//
			m_pbuffer = 0 ;
			m_pchStartData = 0 ;
			m_pchEndData = 0 ;
			m_pchEnd = 0 ;
			m_pchStart = 0 ;
		}

		//
		//	At this point we should always be preparing to examine a new line of text !
		//	If the user spews CRLF's at us we want to keep resetting our state.  Meantime
		//	all those CRLF's will fill our buffer, and if they send to many we will drop
		//	the connection !!
		//
		m_pchLineState = &szLineState[0] ;

		unsigned	cbReturn = (unsigned)(pchCurrent - pchStart) ;

		_ASSERT( cbReturn <= pRead->m_ibEndData - pRead->m_ibStartData ) ;

		pioOut = pio ;
		if( pioOut != this ) {
			DebugTrace( (DWORD_PTR)this, "New pio is %x - delete self", pioOut ) ;
		}	else	{
			if( cbReturn == pRead->m_cbBytes )	{
				//
				//	Have exactly exhausted the current buffer - need to issue another
				//	read.
				//
				_ASSERT( pchCurrent == pchEnd ) ;
				CReadPacket*	pNewRead	= pRead->m_pOwner->CreateDefaultRead( cbSmallRequest ) ;
				if( pNewRead )	{
					BOOL	eof ;
					pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;			
				}	else	{
					pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
				}
			}
		}
		return	cbReturn ;
	}	else	{

		DebugTrace( (DWORD_PTR)this, "No Newline in line m_pbuffer %x m_pchEndData %x m_pchStart %x",
			m_pbuffer, m_pchStartData, m_pchEndData ) ;

		_ASSERT( pchCurrent >= pchStart ) ;
		_ASSERT( pchCurrent <= pchEnd ) ;
		_ASSERT( pchEnd == &pRead->m_pbuffer->m_rgBuff[ pRead->m_ibEndData ] ) ;

		if( m_pbuffer != 0 )		{
			DWORD	cbToCopy = (DWORD)(pchEnd - pchStart) ;
			if( cbToCopy + m_pchEndData >= m_pchEnd ) {
				//
				//	The command line is to long to be processed - blow off the session !
				//			

				//
				//	Null terminate whats in our buffer and log it - just give the log the
				//	first 50 bytes of whatever was coming across !
				//
				DWORD	ibZap = min( 50, (DWORD)(m_pchEnd - m_pchStartData) ) ;
				m_pchStartData[ibZap] = '\0' ;
				//	just move the enddata pointer to be equal to the end - so that if
				//	we get called again we will always fail the completion !
				m_pchEndData = m_pchEnd ;
				pSocket->TransactionLog(	"Line too long",	m_pchStartData, NULL ) ;

				//
				//	Now kill the session ! - this will result in our desctructor getting
				//	called and everything getting cleaned up !
				//
				
				pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_CIOREADLINE_OVERFLOW, 0 ) ;
				return	pRead->m_cbBytes ;
			}
			
			CopyMemory( m_pchEndData, pchStart, pchEnd - pchStart ) ;
			m_pchEndData += (pchEnd - pchStart) ;
		}	else	{
			if( ((pRead->m_ibEnd - pRead->m_ibEndData) < MAX_BYTES) )	{

				_ASSERT(MAX_BYTES < REQUEST_BYTES); // to ensure the buffer we allocate later is enough for a line.
				if ((pchEnd - pchStart)>MAX_BYTES)
				{
					// Line too long, fail it.
					// Bug 195489 -
					// We will allocate a buffer with size REQUEST_BYTES (currently 4000)
					// However, (pchStart, pchEnd) may contain a very large data in a single line (all 0's), greater than 4000
					// copying it in the following CopyMemory line corrupts memory.

					ErrorTrace((DWORD_PTR)this, "CIOReadLine: Line too long - %d bytes", pchEnd - pchStart);
					pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_CIOREADLINE_OVERFLOW, 0 ) ;
					return	pRead->m_cbBytes ;		// consume everything
				}
				DWORD	cbOut = 0 ;

				DWORD	cbFront = 0 ;
				DWORD	cbTail = 0 ;
				pRead->m_pOwner->GetReadReserved( cbFront, cbTail ) ;

				m_pbuffer = new( REQUEST_BYTES+cbFront, cbOut )	CBuffer( cbOut ) ;

				if( m_pbuffer != 0 )		{
					m_pchEnd = &m_pbuffer->m_rgBuff[ m_pbuffer->m_cbTotal ] ;
					m_pchStart = &m_pbuffer->m_rgBuff[0] ;
					m_pchStartData = m_pchStart + cbFront ;
					CopyMemory( m_pchStartData,	pchStart, pchEnd - pchStart ) ;
					m_pchEndData =  m_pchStartData + (pchEnd - pchStart) ;
				}	else	{

					// ERROR COMPLETION !!!!
					_ASSERT( 1==0 ) ;
					pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
					return	pRead->m_cbBytes ;
				}
			}	else	{
				m_pbuffer = pRead->m_pbuffer ;
				m_pchStart = pRead->Start() ;
				m_pchStartData = pchStart ;
				m_pchEndData = pRead->EndData() ;
				m_pchEnd = pRead->End() ;
			}
		}
		_ASSERT( m_pchEndData <= m_pchEnd ) ;
		_ASSERT( m_pchStartData <= m_pchEndData ) ;
		_ASSERT( m_pchStartData >= m_pchStart ) ;
		_ASSERT(	m_pchEndData >= m_pchStartData ) ;
		_ASSERT( m_pchStart && m_pchStartData && m_pchEnd && m_pchEndData ) ;

		_ASSERT( unsigned(pchEnd - pchStart) == pRead->m_cbBytes ) ;

		CReadPacket*	pNewRead	= pRead->m_pOwner->CreateDefaultRead( cbSmallRequest ) ;
		DebugTrace( (DWORD_PTR)this, "Issued New Read Packet %d", pNewRead ) ;
		if( pNewRead )	{
			BOOL	eof ;
			pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;			
		}	else	{
			_ASSERT( 1==0 ) ;
			pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
		}

		return	pRead->m_cbBytes ;	// Consumed everything !!
	}
	return	0 ;
}

unsigned	CIOWriteLine::cbJunk ;

CIOWriteLine::CIOWriteLine( CSessionState*	pstate ) :
	//
	//	Initialize to an illegal state - we require a call to InitBuffers()
	//
	CIOWrite( pstate ),
	m_pWritePacket( 0 ),
	m_pchStart( 0 ),
	m_pchEnd( 0 )	{

	TraceFunctEnter( "CIOWriteLine::CIOWriteLine" ) ;
	DebugTrace( (DWORD_PTR)this, "New CIOWriteLine" ) ;

}

CIOWriteLine::~CIOWriteLine( )	{
	//
	//	get rid of anything we're holding !
	//

	if( m_pWritePacket != 0 )	{
		//delete	m_pWritePacket ;
		CPacket::DestroyAndDelete( m_pWritePacket ) ;
	}
}

BOOL
CIOWriteLine::InitBuffers(	CDRIVERPTR&	pdriver,	
							unsigned	cbLimit )	{
/*++

Routine Description :

	This function is called to make the CIOWriteLine initialize all
	the buffers etc... it needs to hold the line we want to output.

Arguments :

	pdriver -	The driver against which we will be issued
	cbLimit	-	Maximum number of byte we will have to hold

Return Value :

	TRUE if successfull, FALSE otherwise

--*/
	_ASSERT( m_pWritePacket == 0 ) ;
	if( m_pWritePacket != 0 )	{
		return	FALSE ;
	}	else	{
		unsigned	cbOut = 0 ;
		//
		//	Get buffer big enough to hold cbLimit bytes of text !
		//

		m_pWritePacket = pdriver->CreateDefaultWrite( cbLimit ) ;
		if( m_pWritePacket != 0 )	{
			_ASSERT( m_pWritePacket->m_pbuffer != 0 ) ;
			m_pchStart = m_pWritePacket->StartData() ;
			m_pchEnd = m_pWritePacket->End() ;
			return	TRUE ;
		}
	}
	return	FALSE ;
}

BOOL
CIOWriteLine::InitBuffers(	CDRIVERPTR&	pdriver,
							CIOReadLine* pReadLine )	{
/*++

Routine Description :

	This function is called to give us a chance to allocate buffers etc... -
	We will be writing exactly what is in the CIOReadLine's buffers !!

Arguments :

	pdriver -	The driver against which we will be issued
	cbLimit	-	Maximum number of byte we will have to hold

Return Value :

	TRUE if successfull, FALSE otherwise

--*/
	_ASSERT(	pdriver != 0 ) ;
	_ASSERT( pReadLine != 0 ) ;
	_ASSERT( pReadLine->m_pbuffer != 0 ) ;
	_ASSERT(	pReadLine->m_pchStart != 0 ) ;
	_ASSERT(	pReadLine->m_pchEnd != 0 ) ;
	_ASSERT(	pReadLine->m_pchStart < pReadLine->m_pchEnd ) ;
	_ASSERT(	pReadLine->m_pchStart >= &pReadLine->m_pbuffer->m_rgBuff[0] ) ;
	_ASSERT(	pReadLine->m_pchStartData >= pReadLine->m_pchStart ) ;
	_ASSERT(	pReadLine->m_pchEnd <= &pReadLine->m_pbuffer->m_rgBuff[pReadLine->m_pbuffer->m_cbTotal] ) ;
	
	//
	//	We're going to write what we just read in a CIOreadLine object -
	//	so build a CWritePacket which uses the same buffer !
	//

	m_pWritePacket = pdriver->CreateDefaultWrite(	pReadLine->m_pbuffer,
						(unsigned)(pReadLine->m_pchStart - &pReadLine->m_pbuffer->m_rgBuff[0]),
						(unsigned)(pReadLine->m_pchEnd - &pReadLine->m_pbuffer->m_rgBuff[0]),
						(unsigned)(pReadLine->m_pchStartData - &pReadLine->m_pbuffer->m_rgBuff[0]),
						(unsigned)(pReadLine->m_pchEndData - &pReadLine->m_pbuffer->m_rgBuff[0])
						) ;

	if( m_pWritePacket )	{
		m_pchStart = pReadLine->m_pchStart ;
		m_pchEnd = pReadLine->m_pchEnd ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL	CIOWriteLine::Start(	CIODriver&	driver,	
								CSessionSocket*	pSocket,	
								unsigned	cbReadAhead ) {
/*++

Routine Description :

	This function is called to let us issue our writepacket to the socket

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/

	//
	//	Write the data to the network !
	//

	_ASSERT( m_pWritePacket != 0 ) ;
	_ASSERT( m_pchStart <= m_pchEnd ) ;
	_ASSERT( m_pchStart >= m_pWritePacket->Start() ) ;
	_ASSERT( m_pchStart <= m_pWritePacket->End() ) ;
	BOOL	fRtn = FALSE ;
	if( m_pchStart <= m_pchEnd )	{
		fRtn = TRUE ;
		m_pWritePacket->m_ibEndData = (unsigned)(m_pchStart - &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_ibStart]);

		//
		//	Any failure at this point will result in our Shutdown function
		//	being called, and our Destructor in short order.
		//	This can happen recursively !!!  Once IssuePacket is called
		//	we are not responsible for freeing the packet !!!! So, set our
		//	PacketPointer to 0 before we call IssuePacket !
		//

		CWritePacket*	pTemp = m_pWritePacket ;
		m_pWritePacket = 0 ;

		BOOL	eof ;		
		driver.IssuePacket( pTemp, pSocket, eof ) ;
		//
		//	Reset to Initial State !! - regardless of errors !!
		//	
		m_pchStart = 0 ;
		m_pchEnd = 0 ;
	}
	return	fRtn ;
}

void
CIOWriteLine::Shutdown( CSessionSocket*	pSocket,	
						CIODriver&		driver,
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

}	

int	CIOWriteLine::Complete(	IN CSessionSocket*	pSocket,	
							IN	CWritePacket* pWritePacket,	
							OUT	CIO*&	pioOut ) {
/*++

Routine Description :

	The one and only packet we can issue has completed !

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet in which the written data resided.
			  This data may no longer be usable.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	TraceFunctEnter( "CIOWriteLine::Complete" ) ;

	//
	//	Nobody cares too much about how we complete - just let the state know !
	//

	pioOut = m_pState->Complete( this, pSocket, pWritePacket->m_pOwner ) ;
	DebugTrace( (DWORD_PTR)this, "Complete - returned %x packet bytes %d", pioOut, pWritePacket->m_cbBytes ) ;
	if( pioOut != this ) {
		DebugTrace( (DWORD_PTR)this, "CIOWriteLine::Complete - completed writing line - delete self" ) ;
	}
	return	pWritePacket->m_cbBytes ;

}

const	unsigned	MAX_CMD_WRITES = 3 ;

CIOWriteCMD::CIOWriteCMD(	CSessionState*	pstate,	
							CExecute*	pCmd,
							ClientContext&	context,
							BOOL		fIsLargeResponse,
							CLogCollector	*pCollector ) :
	CIOWrite( pstate ),
	m_pCmd( pCmd ),
	m_context( context ),
	m_cWrites( 0 ),
	m_cWritesCompleted( 0 ),
	m_fComplete( FALSE ),
	m_cbBufferSize( cbSmallRequest ),
	m_pCollector( pCollector ) {

	if( fIsLargeResponse )
		m_cbBufferSize = cbMediumRequest ;

	_ASSERT( pCmd != 0 ) ;
}

CIOWriteCMD::~CIOWriteCMD( ) {
	if( m_pCmd != 0 ) {
		delete	m_pCmd ;
	}
}


void
CIOWriteCMD::Shutdown( CSessionSocket*	pSocket,	
						CIODriver&		driver,
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

}	



BOOL
CIOWriteCMD::Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead ) {


	BOOL	fJunk ;
	CWritePacket*	pWrite = driver.CreateDefaultWrite( m_cbBufferSize ) ;
	if( pWrite != 0 ) {
		unsigned	cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
		//
		//	Use this temporary fComplete variable instead of the m_fComplete Member variable.
		//	This keeps us safe from the situation where a write completes before we
		//	have incremented m_cWrites and m_fComplete is set to a TRUE.
		//
		BOOL		fComplete = FALSE ;
		unsigned	cbOut = m_pCmd->FirstBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
		if( m_pCollector != 0 ) {
			ADDI( m_pCollector->m_cbBytesSent, cbOut );
		}

		pWrite->m_ibEndData = pWrite->m_ibStartData + cbOut ;
		driver.IssuePacket( pWrite, pSocket, fJunk ) ;
		m_cWrites ++ ;

		while( !fComplete && m_cWrites < MAX_CMD_WRITES ) {
			pWrite = driver.CreateDefaultWrite( cbMediumRequest ) ;
			if( pWrite == 0 )
				break ;
			cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
			cbOut = m_pCmd->NextBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
			if( m_pCollector != 0 )	{
				ADDI( m_pCollector->m_cbBytesSent, cbOut );
			}

			if( cbOut == 0 ) {
				driver.DestroyPacket( pWrite ) ;
				pWrite = driver.CreateDefaultWrite( cbLargeRequest ) ;
				if( pWrite == 0 )
					break ;
				cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
				cbOut = m_pCmd->NextBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
				if( m_pCollector != 0 )	{
					ADDI( m_pCollector->m_cbBytesSent, cbOut );
				}
				if( cbOut == 0 ) {
					driver.DestroyPacket( pWrite ) ;
					driver.UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
					break ;
				}
			}


			_ASSERT( cb != 0 ) ;
			_ASSERT( cbOut != 0 ) ;

			pWrite->m_ibEndData = pWrite->m_ibStartData + cbOut ;
			driver.IssuePacket( pWrite, pSocket, fJunk ) ;
			m_cWrites ++ ;
		}
		m_fComplete = fComplete ;
		return	TRUE ;
	}
	return	FALSE ;
}

int
CIOWriteCMD::Complete(	CSessionSocket*	pSocket,
						CWritePacket*	pWritePacket,
						CIO*&			pioOut ) {

	m_cWritesCompleted ++ ;
	if( m_fComplete )	{
		if( m_cWritesCompleted == m_cWrites ) {
			pioOut = m_pState->Complete( this, pSocket, pWritePacket->m_pOwner, m_pCmd, m_pCollector ) ;
			m_pCmd = 0 ;	// We are not responsible for destroying this if
							//	we manage to call the completion function !!
							//	So 0 the pointer so our destructor doesn't blow it off.
			_ASSERT( pioOut != this ) ;
		}
	}	else	{
		unsigned	cb = 0 ;
		unsigned	cbOut = 0 ;
		BOOL	fJunk ;
		BOOL	fComplete = m_fComplete ;
		while( !fComplete && (m_cWrites - m_cWritesCompleted) < MAX_CMD_WRITES ) {

			CWritePacket*	pWrite = pWritePacket->m_pOwner->CreateDefaultWrite( cbMediumRequest ) ;
			if( pWrite == 0 )	{
				pWritePacket->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
				break ;
			}
			cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
			cbOut = m_pCmd->NextBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
			if( m_pCollector != 0 ) {
				ADDI( m_pCollector->m_cbBytesSent, cbOut );
			}

			if( cbOut == 0 ) {
				pWritePacket->m_pOwner->DestroyPacket( pWrite ) ;
				pWrite = pWritePacket->m_pOwner->CreateDefaultWrite( cbLargeRequest ) ;
				if( pWrite == 0 )	{
					pWritePacket->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
					break ;
				}
				cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
				cbOut = m_pCmd->NextBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
				if( m_pCollector != 0 )	{
					ADDI( m_pCollector->m_cbBytesSent, cbOut );
				}
				if( cbOut == 0 ) {
					pWritePacket->m_pOwner->DestroyPacket( pWrite ) ;
					pWritePacket->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
					break ;
				}
			}

			_ASSERT( cb != 0 ) ;
			_ASSERT( cbOut != 0 ) ;

			pWrite->m_ibEndData = pWrite->m_ibStartData + cbOut ;
			pWrite->m_pOwner->IssuePacket( pWrite, pSocket, fJunk ) ;
			m_cWrites ++ ;
		}
		m_fComplete = fComplete ;
	}

	return	pWritePacket->m_cbBytes ;
}

void
CIOWriteAsyncComplete::Complete(	BOOL	fReset	)	{
/*++

Routine Description :

	This function is called by the derived classes when
	the operation has completed !

Arguments :

	fReset - if TRUE we should reset ourselves for another
		operation !

Return Value :

	None.

--*/
	//
	//	Were we pending - do we have something to finish !
	//
	_ASSERT( m_pSocket!= 0 ) ;
	_ASSERT( m_pExecute != 0 ) ;
	//
	//	If no bytes moved, the command can't have completed !
	//
	_ASSERT( m_cbTransfer != 0 || (m_cbTransfer == 0 && !m_fComplete) ) ;
	//
	//	If we're supposed to get a larger buffer, then
	//	no bytes should have moved !
	//
	_ASSERT( !m_fLargerBuffer || (m_fLargerBuffer && m_cbTransfer != 0) ) ;
	//
	//	Copy the member variables into stack variables and set them to NULL.
	//	We must do this because after calling ProcessPacket() we can't touch
	//	any members as we may re-enter this class on this thread !
	//
	CSessionSocket*	pSocket = m_pSocket ;
	CExecutePacket*	pExecute = m_pExecute ;
	m_pExecute = 0;
	m_pSocket = 0 ;
	_ASSERT( pSocket != 0 ) ;

	_ASSERT( pExecute->m_pWrite != 0 ) ;
	pExecute->m_cbTransfer = m_cbTransfer ;
	pExecute->m_fComplete = m_fComplete ;
	pExecute->m_fLargerBuffer = m_fLargerBuffer ;
	CDRIVERPTR	pDriver = pExecute->m_pOwner ;

	//
	//	We've copied all the usefull parts of our state into
	//	the CExecutePacket to send off - now NULL out the reset of
	//	our state so that nobody mistakenly uses it !
	//
	m_cbTransfer = 0 ;
	m_fLargerBuffer = FALSE ;
	m_fComplete = FALSE ;
	if( fReset )
		Reset() ;

	//
	//	NOW ! - release the reference we have to the CIOWriteAsyncCMD -
	//	the session may have dropped and this could lead to our destruction !
	//
	m_pWriteAsyncCMD = 0 ;

	//
	//	Okay - process the completion synchronized with
	//	writes on the socket - we may re-enter this object
	//	on another method because of re-use - so we must
	//	not modify anything after this call !
	//
	pExecute->m_pOwner->ProcessExecute(	pExecute,
										pSocket
										) ;
}


void
CIOWriteAsyncComplete::Reset()	{
/*++

Routine Description :

	This function will reset our state so that we could handle a second Async operation !
	Basically we set our state to be the same as immediately after construction !

Arguments :

	None.

Return Value :

	None.

--*/

	//
	//	Most of our state should have been reset on the call to Complete() !
	//
	_ASSERT( m_pSocket == 0 ) ;
	_ASSERT( m_pExecute == 0 ) ;
	_ASSERT( m_cbTransfer == 0 ) ;
	_ASSERT( m_fLargerBuffer == FALSE ) ;
	_ASSERT( m_fComplete == FALSE ) ;

	//
	//	Reset our base class - and add a refence so we're just like new !
	//
	CNntpComplete::Reset() ;
	AddRef() ;
}


CIOWriteAsyncComplete::~CIOWriteAsyncComplete()	{
/*++

Routine Description :

	Clean up an CIOWriteAsyncComplete object.
	There is not much to do - we just _ASSERT that Complete() has
	been called.

Arguments :

	None.

Return Value :

	None.


--*/
	_ASSERT( m_pExecute == 0 ) ;
	_ASSERT( m_pSocket == 0 ) ;
}

void
CIOWriteAsyncComplete::FPendAsync(	
			CSessionSocket*		pSocket,
			CExecutePacket*		pExecute,
			CIOWriteAsyncCMD*	pWriteAsync
			) 	{
/*++

Routine Description :

	This function is called by the the CIOWriteAsyncCMD when it is ready to
	deal with the completion of the CAsyncExecute object we are dealing with.
	Because our constructor adds a reference, we know that the operation
	can't complete before this guys is called.

Arguments :

	pSocket - the socket we are doing the operation for
	pExecute - the CExecutePacket that will manage the synchronization of the
		drivers completion with our IO's
	pWriteAsync - the guy we add a reference to.
		Ensures that if the session goes down while we are pending we don't get
		destroyed !

Return Value :

	None.

--*/
	_ASSERT( pExecute != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	m_pExecute = pExecute ;
	m_pSocket = pSocket ;
	m_pWriteAsyncCMD = pWriteAsync ;
	Release() ;
}



CIOWriteAsyncCMD::CIOWriteAsyncCMD(	CSessionState*	pstate,	
							CAsyncExecute*	pCmd,
							ClientContext&	context,
							BOOL		fIsLargeResponse,
							CLogCollector	*pCollector
							) :
	CIOWrite( pstate ),
	m_pCmd( pCmd ),
	m_context( context ),
	m_cWrites( 0 ),
	m_cWritesCompleted( 0 ),
	m_fComplete( FALSE ),
	m_cbBufferSize( cbSmallRequest ),
	m_pCollector( pCollector ),
	m_pDeferred( 0 )	{

	m_pfnCurBuffer = &(CAsyncExecute::FirstBuffer) ;

	if( fIsLargeResponse )
		m_cbBufferSize = cbMediumRequest ;

	_ASSERT( pCmd != 0 ) ;
}

CIOWriteAsyncCMD::~CIOWriteAsyncCMD( ) {
	if( m_pCmd != 0 ) {
		delete	m_pCmd ;
	}
}

BOOL
CIOWriteAsyncCMD::Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead
					) {
/*++

Routine Description :

	Start the execution of async commands !

Arguments :
	driver - The CIODriver managing the session
	pSocket - The Socket we're working on
	cReadAhead - Nothing we care about !

Return Value :

	TRUE if we're successfully setup !

--*/

	CExecutePacket*	pExecute = driver.CreateExecutePacket() ;
	if( pExecute )	{
		if(	!Execute(	
					pExecute,
					driver,
					pSocket,
					m_cbBufferSize
					) 	)	{
			//
			//	We own destruction of the CExecutePacket we've created is this fails
			//
			pExecute->m_pOwner->DestroyPacket( pExecute ) ;
			return	FALSE ;
		}
		return	TRUE ;
	}
	return	FALSE ;
}

void
CIOWriteAsyncCMD::Shutdown(
						CSessionSocket*	pSocket,	
						CIODriver&		driver,
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

	//
	//	If we have a deferred completion packet - kill it !
	//
	if( m_pDeferred ) {
		driver.DestroyPacket( m_pDeferred ) ;
		m_pDeferred = 0 ;
	}
}	


BOOL
CIOWriteAsyncCMD::Execute(
						CExecutePacket*	pExecute,
						CIODriver&	driver,
						CSessionSocket*	pSocket,
						DWORD		cbInitialSize
						)	{
/*++

Routine Description :

	This is a helper function for the CIOWriteAsyncCMD class -
	we will build the necessary write packets etc... to issue
	Async Commands against storage drivers.
	(We don't directly deal with Storage drivers - we have a pointer
	to an Async Command object that will issue the operation !)

Arguments :

	pExecute - the CExecutePacket that will carry notification of the
		completion of this async operation back to us !
	driver - the CIODriver managing the session !
	pSocket - the Socket of the session
	cbInitialSize - how big a buffer we think the command could use !

Return Value :

	TRUE if successfull
	FALSE if a fatal error occurs - Caller must destroy
		his CExecutePacket object !

--*/
	//
	//	Basic assumptions about arguments !
	//
	_ASSERT( pExecute != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	//
	//	Shouldn't be issuing more op's if we think we're done !
	//
	_ASSERT( !m_fComplete ) ;
	//
	//	Better arrive in here without a Write Packet !
	//
	_ASSERT( pExecute->m_pWrite == 0 ) ;
	//
	//	Allocate memory to hold results !
	//
	pExecute->m_pWrite = driver.CreateDefaultWrite( cbInitialSize ) ;
	if( pExecute->m_pWrite == 0 ) {
		//
		//	Fatal error !
		//
		driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
		return	FALSE ;
	}	else	{
		//
		//	Give to the AsyncCommand who will execute against storage
		//	driver !
		//
		unsigned	cb = pExecute->m_pWrite->m_ibEnd - pExecute->m_pWrite->m_ibStartData ;
		CIOWriteAsyncComplete*	pComplete =
			(m_pCmd->*m_pfnCurBuffer)(	(BYTE*)pExecute->m_pWrite->StartData(),
										cb,
										m_context,
										m_pCollector
										) ;
		//
		//	Operation must have been successfully issued against
		//	Storage driver !
		//
		if( pComplete ) {
			pComplete->FPendAsync(	pSocket,
									pExecute,
									this
									) ;
			return	TRUE ;
		}
	}
	driver.UnsafeClose( pSocket, CAUSE_ASYNCCMD_FAILURE, __LINE__ ) ;
	return	FALSE ;
}

void
CIOWriteAsyncCMD::Complete(
						CSessionSocket*	pSocket,
						CExecutePacket*	pExecute,
						CIO*&			pioOut
						)	{
/*++

Routine Description :

	This function deals with the completion of our Async Command.
	Now that the command has completed somewhat - we need to
	take the results of the completion and take the appropriate action.
	Generally if no errors occurred, we will write the data out
	to the socket, if the buffer we gave the command was too small
	we should re-issue against AsyncCommand.

Arguments :

	pSocket - the socket we're doing work for
	pExecute - the packet containing the completion state of
		the AsyncCommand that we're executing
	pioOut - Containing CIODriver's reference to us !

Return Value :

	None.

--*/

	//
	//	Capture IssuePacket noise !
	//
	BOOL	fJunk ;

	//
	//	Basic assumptions about arguments !
	//
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pExecute != 0 ) ;
	_ASSERT( pExecute->m_pWrite != 0 ) ;
	_ASSERT( pExecute->m_pWrite->m_pbuffer != 0 ) ;
	_ASSERT( pioOut == this ) ;

	m_fComplete = pExecute->m_fComplete ;
	//
	//	If this packet completed things, then it better have
	//	succeeded in giving us some bytes to send !
	//
	_ASSERT( !m_fComplete ||
		(m_fComplete && pExecute->m_cbTransfer != 0 &&
			!pExecute->m_fLargerBuffer) ) ;

	//
	//	Default size for buffers holding outgoing data !
	//
	DWORD	cbSize = m_cbBufferSize ;

	//
	//	If it failed - find out why !
	//
	if (pExecute->m_cbTransfer == (DWORD) -1) {
		//
		// The number of bytes was less than zero.  Simply reset the value to zero, destroy the
		// write packet and let it fall down and call Execute() again.  This is used by xover
		// to cause it to call NextBuffer
		//
		pExecute->m_cbTransfer = 0;
		pExecute->m_pOwner->DestroyPacket( pExecute->m_pWrite ) ;
		pExecute->m_pWrite = 0 ;
	} else if( pExecute->m_cbTransfer > 0 ) {
		//
		//	Issue the write to the socket !
		//
		m_pfnCurBuffer = &(CAsyncExecute::NextBuffer) ;
		m_cWrites ++ ;
		pExecute->m_pWrite->m_ibEndData = pExecute->m_pWrite->m_ibStartData + pExecute->m_cbTransfer ;
		pExecute->m_pOwner->IssuePacket(	pExecute->m_pWrite,
											pSocket,
											fJunk
											) ;
	}	else	{
		//
		//	Can't be finished if it failed !
		//
		_ASSERT( !m_fComplete ) ;
		//
		//	Preserve the number of bytes we had provided to the client !
		//
		DWORD	cbWrite = pExecute->m_pWrite->m_pbuffer->m_cbTotal ;
		//
		//	Destroy the CWritePacket no matter what went wrong !
		//
		pExecute->m_pOwner->DestroyPacket( pExecute->m_pWrite ) ;
		pExecute->m_pWrite = 0 ;
		//
		//	Did we need to try again with a larger buffer ?
		//
		if( !pExecute->m_fLargerBuffer ||
			(pExecute->m_fLargerBuffer &&
				cbWrite > cbLargeRequest ) ) {
			//
			//	This is a fatal error - tear down the session !
			//
			pExecute->m_pOwner->UnsafeClose( pSocket, CAUSE_ASYNCCMD_FAILURE, __LINE__ ) ;
			pExecute->m_pOwner->DestroyPacket( pExecute ) ;
			return ;
		}	

		//
		//	We only fall through to here if we need to try again
		//	with a large buffer - try the biggest we have !
		//
		cbSize = cbLargeRequest ;
		//
		//	We're going to re-issue the operation - it must not
		//	be the case that we would flow control, otherwise we
		//	never should have issued the operation we're completing now !
		//
		_ASSERT( (m_cWrites - m_cWritesCompleted) <= MAX_CMD_WRITES ) ;
	}	
	//
	//	We should have consumed this Write Packet by this point
	//	so NULL it out of the ExecutePacket !
	//
	pExecute->m_pWrite = 0 ;

	//
	//	Ok - lets keep executing the command !
	//
	if(	m_fComplete )	{
		//
		//	If we've completed the operation we don't need the
		//	Execute packet anymore !
		//
		pExecute->m_pOwner->DestroyPacket( pExecute ) ;
	}	else	{
		if( (m_cWrites - m_cWritesCompleted) > MAX_CMD_WRITES )	{
			//
			//	Save this for later - when the Write Completions catch up !
			//
			m_pDeferred = pExecute ;
		}	else	{
			//
			//	Do more async work against the AsyncExecute object !
			//
			if( !Execute(	pExecute,
							*pExecute->m_pOwner,
							pSocket,
							cbSize
							)	)	{
				//
				//	Fatal error - blow off our CExecutePacket !
				//	NOTE : Execute() will call UnsafeShutdown()
				//	for us in case of failures !
				//
				pExecute->m_pOwner->DestroyPacket( pExecute ) ;
				return ;
			}
		}
	}
}
	

int
CIOWriteAsyncCMD::Complete(	
						CSessionSocket*	pSocket,
						CWritePacket*	pWritePacket,
						CIO*&			pioOut
						) {
/*++

Routine Description :

	We've completed sending some stuff to a client.
	If we're done finishing things, notify our containing
	state - otherwise make sure we keep doing work !

Arguments :

	pSocket - the socket we're doing work for
	pWritePacket - represents the bytes we sent to the client !
	pioOut - a reference to us in the containing CIODriver !

Return Value :
	
	bytes consumed !

--*/

	//
	//	Keep track of how many writes have completed !
	//
	m_cWritesCompleted ++ ;
	if( m_fComplete )	{

		//
		//	If we've completed all Executions of the command,
		//	then we better not have a deferred CExecutePacket
		//	lying around - should have destroyed in on the
		//	Complete path for CExecutePacket's !
		//
		_ASSERT( m_pDeferred == 0 ) ;

		//
		//	We're only really done when the number of
		//	WritePacket Completions catches up with the number
		//	of write packets we issued !
		//
		if( m_cWritesCompleted == m_cWrites ) {
			pioOut = m_pState->Complete( 	this,
											pSocket,
											pWritePacket->m_pOwner,
											m_pCmd,
											m_pCollector
											) ;
			m_pCmd = 0 ;	// We are not responsible for destroying this if
							//	we manage to call the completion function !!
							//	So 0 the pointer so our destructor doesn't blow it off.
			_ASSERT( pioOut != this ) ;
		}
	}	else	{
		//
		//	Check to see if we have any deferred work to do !
		//
		if( m_pDeferred ) 	{
			//	
			//	Okay - issue off one of these commands against our
			//	storage drivers !
			//
			if( !Execute(	m_pDeferred,
							*m_pDeferred->m_pOwner,
							pSocket,
							m_cbBufferSize
							)	)	{
				//
				//	Fatal error - blow off the session !
				//
				m_pDeferred->m_pOwner->DestroyPacket( m_pDeferred ) ;
				_ASSERT( FALSE ) ;
				return	pWritePacket->m_cbBytes ;
			}
			m_pDeferred = 0 ;
		}
	}
	return	pWritePacket->m_cbBytes ;
}


#if 0

void
CIOWriteAsyncCMD::CommandComplete(
						BOOL	fLargerBuffer,
						BOOL	fComplete,
						DWORD	cbTransfer,
						CSessionSocket*	pSocket,
						)	{
/*++

Routine Description :

	This function is called if the operation pending against the
	storage driver completes asynchronously !

Arguments :
	fLargerBuffer - If this is TRUE cbTransfer must be 0, and it indicates
		that we should execute the operation again with a larger buffer !
	cbTransfer - If non zero than its the number of bytes that were copied
		into pPacket - ZERO indicates a fatal error if fLargeBuffer is FALSE !
	pSocket - The socket for thes session
	pPacket - The packet the client was to fill for us !

Return :

	Nothing !

--*/
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pPacket != 0 ) ;
	_ASSERT( m_pWrite != 0 ) ;
	_ASSERT( m_pExecute != 0 ) ;

	CIODRIVERPTR	pDriver = m_pExecute->m_pOwner ;
	_ASSERT( pDriver != 0 ) ;
	pDriver->ProcessExecute(	

	//
	//	If we arrive here we must have an operation pending
	//

	BOOL	fDefer = (m_cWrites - m_cWritesCompleted) > MAX_CMD_WRITES ;
	CIODRIVERPTR	pdriver = pPacket->m_pOwner ;
	DWORD	cbBufferSize = m_cbBufferSize ;

	if( cbTransfer != 0 )	{
		//
		//	Send off the packet !
		//
		pPacket->m_ibEndData = pPacket->m_ibStartData + cbTransfer ;
		m_cWrites ++ ;
		m_fComplete = fComplete ;
		fDefer &= !m_fComplete ;
		m_fDeferred = fDefer ;

		pdriver->IssuePacket( pPacket, pSocket, fJunk ) ;
			//
		//	Now the question is - should we issue another
		//	operation against AsyncExecute object !
		//
	}	else	if( !fLargerBuffer ) 	{
		//
		//	Fatal error - drop the session !
		//
		driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
		return ;
	}	else	if( fLargerBuffer ) 	{
		cbBufferSize = cbLargeBuffer ;
	}
	//
	//	Fall through to here only if we're considering pending more
	//	operations !
	//
	if( !fDefer ) 	{
		Execute(	
					driver,
					pSocket,
					cbBufferSize
					) ;
	}
}



BOOL
CIOWriteAsyncCMD::Execute(
						CIODriver&	driver,
						CSessionSocket*	pSocket,
						DWORD		cbInitialSize
						)	{


	_ASSERT( !m_fComplete ) ;
	_ASSERT( !m_fTerminated ) ;

	//
	//	Capture the don't care OUT parm of IssuePacket() !
	//
	BOOL	fJunk ;

	//
	//
	//
	_ASSERT( m_pExecute != 0 ) ;

	CWritePacket*	pWrite = driver.CreateDefaultWrite( cbInitialSize ) ;
	if( pWrite != 0 ) {
		unsigned	cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
		//
		//	Use this temporary fComplete variable instead of the m_fComplete Member variable.
		//	This keeps us safe from the situation where a write completes before we
		//	have incremented m_cWrites and m_fComplete is set to a TRUE.
		//
		BOOL		fComplete = FALSE ;
		CIOWriteAsyncComplete*	pComplete =
			m_pCmd->GetBuffer(	(BYTE*)pWrite->StartData(),
										cb,
										m_context,
										m_pCollector
										) ;
		if( !pComplete ) {
			driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
			return	FALSE ;
		}
		//
		//	Now we have the Async Completion object -
		//	it may have completed already so we will have to handle
		//	that case when we setup for async completion !
		//
		DWORD	cbTransfer ;
		BOOL	fLarger ;
		BOOL	fJunk ;

		if( !pComplete->FPendAsync(	cbTransfer,
									fLarger,
									fComplete,
									pWrite,
									pSocket,
									this
									)	)	{
			_ASSERT( !fLarger ) ;
			_ASSERT( cbTransfer == 0 ) ;
			return	FALSE ;
		}	else	{
			if(	cbTransfer == 0 &&
				fLarger &&
				cbInitialSize != cbLargeRequest	) {
				driver.DestroyPacket( pWrite ) ;
				pWrite = driver.CreateDefaultWrite( cbLargeRequest ) ;
				pComplete =
					m_pCmd->GetBuffer(	
											(BYTE*)pWrite->StartData(),
											cb,
											m_context,
											m_pCollector
											) ;
				m_fComplete = (!!fComplete) ;
				if( !pComplete ) {
					driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
					return	FALSE ;
				}
				if( !pComplete->FPendAsync(	cbTransfer,
											fLarger,
											fComplete,
											pWrite,
											pSocket,
											this
											)	)	{
					_ASSERT( !fLarger ) ;
					_ASSERT( cbTransfer == 0 ) ;
					return	FALSE ;
				}	
				if( cbTransfer == 0 ) 	{
					//
					//	This is a fatal error - tear down !
					//
					driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
					return	FALSE ;
				}
			}
			//
			//	If we get here this must be FALSE as the operation
			//	was successfully issued !
			//
			_ASSERT( !fLarger ) ;
			//
			//	This guy is ready to go - so mark up the
			//	WritePacket and send it off !
			//
			pWrite->m_ibEndData = pWrite->m_ibStartData + cbTransfer ;
			//
			//	Increment this before we issue the IO - and before
			//	we set m_fComplete to fComplete
			//	This way we avoid mistakes regarding our termination
			//	in our completion function !
			//
			m_cWrites ++ ;
			//
			//	We will repeat the loop IF and only If we are not behind
			//	1) The Command hasn't completed
			//	2) The number of
			//
			m_fComplete = fComplete ;
			//
			//	All our state is adjusted before we issue the IO so
			//	that we don't miss taking the correct action when the
			//	IO completes !
			//

			l = InterlockedExchangeAdd( &m_cPending, PACKETS ) + PACKETS ;
			_ASSERT( (l&0XFFFF) >= 1 ) ;

			driver.IssuePacket( pWrite, pSocket, fJunk ) ;
			return	TRUE ;
		}
	}
	driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
	return	FALSE ;
}
#endif



MultiLine::MultiLine() :
	m_pBuffer( 0 ),
	m_cEntries( 0 )	{

	ZeroMemory( &m_ibOffsets[0], sizeof( m_ibOffsets ) ) ;

}

CIOMLWrite::CIOMLWrite(	
	CSessionState*	pstate,
	MultiLine*		pml,
	BOOL			fCoalesce,
	CLogCollector*	pCollector
	) :
	CIOWrite( pstate ),
	m_pml( pml ),
	m_fCoalesceWrites( fCoalesce ),
	m_pCollector( pCollector ),
	m_iCurrent( 0 )	{

	_ASSERT( m_pml != 0 ) ;
	_ASSERT( m_pml->m_cEntries <= 16 ) ;

}

BOOL
CIOMLWrite::Start(
		CIODriver&		driver,
		CSessionSocket*	pSocket,
		unsigned		cAhead
		) {

	DWORD	c = 0 ;
	DWORD	iNext = 0;

	while( m_iCurrent != (m_pml->m_cEntries) && c<3 ) {

		if( m_fCoalesceWrites ) {

			iNext = m_pml->m_cEntries ;

		}	else	{

			iNext = m_iCurrent+1 ;

		}

		CWritePacket*	pWrite = driver.CreateDefaultWrite(
									m_pml->m_pBuffer,
									m_pml->m_ibOffsets[m_iCurrent],
									m_pml->m_ibOffsets[iNext],
									m_pml->m_ibOffsets[m_iCurrent],
									m_pml->m_ibOffsets[iNext]
									) ;

		if( pWrite ) {

			BOOL	fJunk ;
			driver.IssuePacket( pWrite, pSocket, fJunk ) ;

		}	else	{
			
			return	FALSE ;

		}
		m_iCurrent = iNext ;
		c++ ;
	}
	return	TRUE ;
}


int
CIOMLWrite::Complete(	CSessionSocket*	pSocket,
						CWritePacket*	pPacket,
						CIO*&			pio
						) {

	if( m_fCoalesceWrites ||
		m_iCurrent == (m_pml->m_cEntries)	) {

		_ASSERT( m_iCurrent == m_pml->m_cEntries ) ;

		pio	= m_pState->Complete(
								this,
								pSocket,
								pPacket->m_pOwner
								) ;

	}	else	{

	
		CWritePacket*	pWrite = pPacket->m_pOwner->CreateDefaultWrite(
									m_pml->m_pBuffer,
									m_pml->m_ibOffsets[m_iCurrent],
									m_pml->m_ibOffsets[m_iCurrent+1],
									m_pml->m_ibOffsets[m_iCurrent],
									m_pml->m_ibOffsets[m_iCurrent+1]
									) ;

		if( pWrite ) {

			BOOL	fJunk ;
			pPacket->m_pOwner->IssuePacket( pWrite, pSocket, fJunk ) ;
			m_iCurrent++ ;

		}	else	{

			pPacket->m_pOwner->UnsafeClose( pSocket,
											CAUSE_OOM,
											0
											) ;			

		}
	}
	return	pPacket->m_cbBytes ;
}


void
CIOMLWrite::Shutdown( CSessionSocket*	pSocket,	
						CIODriver&		driver,
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

}	




CIOTransmit::CIOTransmit(	CSessionState*	pstate ) :
	//
	//	Initialize to an illegal state !
	//
	CIOWrite( pstate ),
	m_pTransmitPacket( 0 ),
	m_pExtraText( 0 ),
	m_pchStartLead( 0 ),
	m_cbLead( 0 ),
	m_cbTail( 0 ),
	m_pchStartTail( 0 ) {

	TraceFunctEnter( "CIOTransmit::CIOTransmit" ) ;
	DebugTrace( (DWORD_PTR)this, "NEW CIOTransmit" ) ;

}

CIOTransmit::~CIOTransmit() {

	if( m_pTransmitPacket != 0 )	{
		//delete	m_pTransmitPacket ;
		CPacket::DestroyAndDelete( m_pTransmitPacket ) ;
	}

}

unsigned	CIOTransmit::cbJunk = 0 ;

BOOL
CIOTransmit::Init(	CDRIVERPTR&	pdriver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,	
					DWORD	cbExtra ) {
	//
	//	Build a transmit packet with appropriate values and get a buffer
	//	for any text we send on the side !
	//

	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( m_pTransmitPacket == 0 ) ;
	_ASSERT( m_pExtraText == 0 ) ;
	_ASSERT( m_pchStartLead == 0 ) ;
	_ASSERT( m_cbLead == 0 ) ;

	
	if( cbExtra != 0 )	{
		DWORD	cbAllocated ;
		m_pExtraText = new( (int)cbExtra, cbAllocated )	CBuffer( cbAllocated ) ;

		if( m_pExtraText == 0 )
			return	FALSE ;
		m_pchStartLead = &m_pExtraText->m_rgBuff[0] ;
	}

	m_pTransmitPacket = pdriver->CreateDefaultTransmit( pFIOContext, ibOffset, cbLength ) ;

	if( m_pTransmitPacket == 0 ) {
		if( m_pExtraText != 0 ) {
			delete	m_pExtraText ;
			m_pExtraText = 0 ;
			m_pchStartLead = 0 ;
		}
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CIOTransmit::Init(	CDRIVERPTR&	pdriver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,	
					CBUFPTR&	m_pbuffer,
					DWORD	ibStart,
					DWORD	ibEnd ) {
	//
	//	Build a transmit packet with appropriate values and get a buffer
	//	for any text we send on the side !
	//

	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( m_pTransmitPacket == 0 ) ;
	_ASSERT( m_pExtraText == 0 ) ;
	_ASSERT( m_pchStartLead == 0 ) ;
	_ASSERT( m_cbLead == 0 ) ;

	m_pTransmitPacket = pdriver->CreateDefaultTransmit( pFIOContext, ibOffset, cbLength ) ;

	if( m_pTransmitPacket != 0 ) {

		m_pExtraText = m_pbuffer ;
		m_cbLead = ibEnd - ibStart ;
		m_pTransmitPacket->m_buffers.Head = &m_pExtraText->m_rgBuff[ibStart] ;
		m_pTransmitPacket->m_buffers.HeadLength = m_cbLead ;

	}	else	{	
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CIOTransmit::InitWithTail(	CDRIVERPTR&	pdriver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,	
					CBUFPTR&	m_pbuffer,
					DWORD	ibStart,
					DWORD	ibEnd ) {
	//
	//	Build a transmit packet with appropriate values and get a buffer
	//	for any text we send on the side !
	//

	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( m_pTransmitPacket == 0 ) ;
	_ASSERT( m_pExtraText == 0 ) ;
	_ASSERT( m_pchStartLead == 0 ) ;
	_ASSERT( m_cbLead == 0 ) ;

	m_pTransmitPacket = pdriver->CreateDefaultTransmit( pFIOContext, ibOffset, cbLength ) ;

	if( m_pTransmitPacket != 0 ) {

		m_pExtraText = m_pbuffer ;
		m_cbLead = ibEnd - ibStart ;
		m_pTransmitPacket->m_buffers.Tail = &m_pExtraText->m_rgBuff[ibStart] ;
		m_pTransmitPacket->m_buffers.TailLength = m_cbLead ;

	}	else	{	
		return	FALSE ;
	}
	return	TRUE ;
}


char*
CIOTransmit::GetBuff( unsigned	&cbRemaining ) {

	//
	//	How many bytes left in that buffer we reserved during Init() ??
	//
	_ASSERT( m_pExtraText != 0 ) ;
	
	if( m_pExtraText != 0 ) {
		cbRemaining = m_pExtraText->m_cbTotal - m_cbLead ;
		return	m_pchStartLead ;
	}
	return	0 ;
}

void
CIOTransmit::AddLeadText( unsigned cb ) {
	//
	//	Text we want to send BEFORE the file
	//

	_ASSERT( cb <= m_pExtraText->m_cbTotal - m_cbLead ) ;

	m_cbLead += cb ;
	m_pchStartLead += cb ;

	m_pTransmitPacket->m_buffers.Head = &m_pExtraText->m_rgBuff[0] ;
	m_pTransmitPacket->m_buffers.HeadLength = m_cbLead ;
}

void
CIOTransmit::AddTailText(	unsigned	cb ) {
	//
	//	For Text we want sent AFTER the file !
	//

	m_cbTail += cb ;
	m_pchStartTail = m_pchStartLead + m_cbLead ;

	m_pTransmitPacket->m_buffers.Tail = &m_pExtraText->m_rgBuff[m_cbLead] ;
	m_pTransmitPacket->m_buffers.TailLength = m_cbTail ;

}

void
CIOTransmit::AddTailText(	char*	pch,	unsigned	cb ) {

	m_pTransmitPacket->m_buffers.Tail = pch ;
	m_pTransmitPacket->m_buffers.TailLength = cb ;
}

LPSTR
CIOTransmit::GetLeadText(	unsigned&	cb )		{

	cb = 0 ;
	LPSTR	lpstrReturn = 0 ;

	if( m_pTransmitPacket ) {
		lpstrReturn = (LPSTR)m_pTransmitPacket->m_buffers.Tail ;
		cb = m_pTransmitPacket->m_buffers.TailLength ;
	}
	return	lpstrReturn ;
}

LPSTR
CIOTransmit::GetTailText(	unsigned&	cb )		{

	cb = 0 ;
	LPSTR	lpstrReturn = 0 ;

	if( m_pTransmitPacket ) {
		lpstrReturn = (LPSTR)m_pTransmitPacket->m_buffers.Head ;
		cb = m_pTransmitPacket->m_buffers.HeadLength ;
	}
	return	lpstrReturn ;
}


void
CIOTransmit::Shutdown(	CSessionSocket*	pSocket,	
						CIODriver&		driver,	
						SHUTDOWN_CAUSE	cause,
						DWORD	dwError ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

}

void
CIOTransmit::Complete(	CSessionSocket*	pSocket,	
						CTransmitPacket*	pPacket,
						CIO*&	pio ) {

	//
	//	Let the state know the operation has completed !
	//
	pio = m_pState->Complete( this, pSocket, pPacket->m_pOwner, &pPacket->m_buffers, pPacket->m_cbBytes ) ;	

	_ASSERT( pio != this ) ;	// Can't reuse CIOTransmit's like you can CIOReadLine's !
}

BOOL
CIOTransmit::Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cAhead ) {
/*++

Routine Description :

	This function is called to give us a chance to issue our CTransmitPacket

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/

	TraceFunctEnter( "CIOTransmit::Start" ) ;

	BOOL	eof ;
	//
	//	Start the Transfer ! - Socket errors could cause our
	//	destructor to be called, and we are not responsible for
	//	freeing the packet after IssuePacket is called so
	//	ZERO out the m_pTransmitPacket member before calling !
	//
	CTransmitPacket*	pTempTransmit = m_pTransmitPacket ;
	m_pTransmitPacket = 0 ;
	driver.IssuePacket( pTempTransmit, pSocket, eof ) ;
	return	TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\cio.h ===
/*++

	cio.h

	This file contains the definitions of the classes defining abstract IO operations.
	
	All such classes are derived from class CIO which defines the basic interface to such operations.
	A 'CIO' operation represents a more abstract IO operation such as :

		Read A Line and Parse into arguments (CIOReadLine)
		Read An Article from one stream into a file until a terminating period is found.
		Write A Line
		Write A File to a stream with text before and after
		
	Most of these operations map more or less directly to NT Calls : TransmitFile, ReadFile and WriteFile

	Each CIO object will create 'Packets' (objects derived from CPacket which are
	passed to the channel to execute through the appropriate NT Call.
	The underlying Channel will process either 'send' the 'packets' directly through a
	call to NT (ie. ReadFile, WriteFile or TransmitFile) or will send the packet to
	a 'CIODriverSource' object which will munge the packets if the session is encrypted.
	(Likewise, CReadPacket's will be munged by the CIODriverSource object before a CIO object
	gets to see the 'completed read'.)

	NOTE : Packets basically wrap OVERLAP structures with extra information about buffers,
	sequence numbers etc....

	There are a special set of CIO objects derived from CIOPassThru which are used by
	CIODriverSource objects to handle SSPI sessions.  (ie. CIOSealMessage and CIOUnsealMessage).
	Together with CIOServerSSL, these objects do the actual encrypt/decrypt and authentication of
	SSPI sessions.   CIOPassThru derives from CIO, however it provides a new and slightly different
	interface which is used by the CIODriverSource to provide the extra info needed to encrypt
	and decrypt.

	The basics of the CIO Interface are as follows :

	Start() -  Issue the first set of packets which start the IO operation

	Complete() - There is a complete function for each of the 3 packets that may be issued.
				When the async IO operation is completed the CIO objects Complete function
				will be called with the now completed 'Packet'.
	
	And in the case of CIOPassThru derived objects there are additionally :

	InitRequest() - There is an InitRequest function for each of the 3 packets that mahy be
				issued.  This gives the CIOPassThru object a chance to massage the Data before
				it is handed off to NT.	

--*/



#ifndef	_CIO_H_
#define	_CIO_H_

#ifdef	DEBUG
#ifndef	CIO_DEBUG
#define	CIO_DEBUG
#endif
#endif

//
// CPool Signature
//

#define CIO_SIGNATURE (DWORD)'1516'





// Forward definition !

#ifndef	_NO_TEMPLATES_

typedef	CRefPtr< CSessionState >	CSTATEPTR ;

#else

typedef	class	INVOKE_SMARTPTR( CSessionState )	CSTATEPTR ;

#endif


//
//	This is the base class defining the virtual interface for all IO operations.
//
//	InitClass() must be called before any objects are created to setup
//	the Pool allocator for the class.
//
class	CIO		{
protected :

	//
	//	Reference Count !
	//
	long	m_refs ;

	//
	//	Smart pointer to the state which gets completion notifications from the
	//	CIO object.
	//
	CSTATEPTR		m_pState ;

	//
	//	The following are initialized after we initialize our buffer management system
	//	Use these to size buffers for generic reads and writes.
	//
	static	DWORD	cbSmallRequest ;
	static	DWORD	cbMediumRequest ;
	static	DWORD	cbLargeRequest ;
	

	//
	//	Protected constructors - only derived classes may exist !
	//
	inline	CIO( ) ;
	inline	CIO( CSessionState*	pState ) ;		// protected so only derived class can construct !

	//
	//	Any kind of IO error will result in Shutdown being called !
	//
	virtual	void	Shutdown(	
							CSessionSocket*	pSocket,	
							CIODriver&	pdriver,	
							enum	SHUTDOWN_CAUSE	cause,	
							DWORD	dwError
							) ;

	inline	void	operator	delete( void *pv ) ;	

	//
	//	Destructor is protected as we only want derived classes to hit it
	//
	virtual	~CIO() ;

public :

	//
	//
	//	Call InitClass() before allocating any objects, TermClass() when all are freed.
	//		We override new and delete for CIO and all derived object.
	//
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;
	
	//
	//	Allocate and release to CPool
	//
	inline	void*	operator	new(	size_t	size, CIODriver& sink ) ;
	inline	static	void	Destroy( CIO*	pio, CIODriver& sink ) ;
	inline	void	DestroySelf() ;
	inline	long	AddRef() ;
	inline	long	RemoveRef() ;
	
	//
	//	IO Interface -
	//	Use these functions to initiate and complete IO operations.
	//
	//	This function MUST be overriden by a derived class.
	//
	virtual	BOOL	Start(	
						CIODriver&	driver,	
						CSessionSocket*	pSocket,
						unsigned cAhead = 0
						) = 0 ;

	//
	//	These are not pure virtual functions as some derived CIO operations do
	//	not ever issue particular kinds of packets, and hence never Complete certain Packet Types either.
	//
	//	However, all of these will DebugBreak() if called !
	//

	//
	//	Process a completed read
	//
	virtual	int
	Complete(	IN CSessionSocket*,
				IN	CReadPacket*,	
				OUT	CIO*	&pio
				) ;

	//
	//	Process a completed write
	//
	virtual	int	
	Complete(	IN CSessionSocket*,
				IN	CWritePacket*,	
				OUT	CIO*	&pio
				) ;

	//
	//	Process a completed TransmitFile
	//
	virtual	void	
	Complete(	IN CSessionSocket*,
				IN	CTransmitPacket*,	
				OUT	CIO*	&pio
				) ;

	//
	//	Process a deferred completion !
	//
	virtual	void
	Complete(	IN	CSessionSocket*,
				IN	CExecutePacket*,
				OUT	CIO*	&pio
				) ;

	//
	//	Indicate whether this CIO operation 'Reads' data -
	//	basically usefull for ASSERT checking
	//
	virtual	BOOL	IsRead()	{	return	FALSE ;	}

	//		Termination interface - when an unexpected error occurs
	//	the CIODriver object will call DoShutdown.  DoShutdown insures that
	//	the current state's Notification functions are called and then it
	//	calls the derived CIO object's shutdown function.
	//	Since more than one CIODriver may reference a CIO object, Shutdown() and DoShutdown()
	//	must figure out whether the object should be deleted.  If the object should be deleted,
	//	return	TRUE, otherwise return FALSE.
	//
	void	DoShutdown(	
						CSessionSocket*	pSocket,	
						CIODriver&	driver,	enum	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwError ) ;

} ;

#ifdef _NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CIO )

#endif

//
//	Some IO operations are clearly 'Reads' and hence are derived from here.
//	This class has no functionality, only exists to make sure 'Reads' and 'Writes' dont get
//	confused.
//
class	CIORead : public	CIO	{
protected :
	inline	CIORead(	CSessionState*	pState ) ;
	BOOL	IsRead()	{	return	TRUE ;	}
#ifdef	DEBUG
	~CIORead() {}
#endif
} ;

//
//	Some IO operations are clearly 'Writes' and hence are derived from here.
//	This class has no functionality, only exists to make sure 'Reads' and 'Writes' dont get
//	confused.
//
class	CIOWrite : public	CIO	{
protected :
	inline	CIOWrite(	CSessionState*	pState ) ;
#ifdef	DEBUG
	~CIOWrite()	{}
#endif

} ;

#ifdef _NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CIORead )
DECLARE_SMARTPTRFUNC( CIOWrite )

#endif


class	CIOPassThru	: public CIO	{
//
//	All CIO objects which wish to operate with a CIODriverSource object must derive
//	from this class and support its interface.
//	
//	CIOPassThru on its own will move all data through without touching -
//	not usefull except for debugging CIODriverSource objects.
//
//

public :
	CIOPassThru() ;

	//
	//	Take a ReadPacket prepared by somebody else, and do whatever we want to adjust
	//	it before sending it on
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CReadPacket*	pPacket,	
						BOOL&	fAcceptRequests
						) ;

	//
	//	Take a Write Packet that has been issued and do whatever munging is necessary -
	//	ie. encrypt the data.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CWritePacket*	pWritePacket,	
						BOOL&	fAcceptRequests
						) ;

	//
	//	Take a TransmitPacket and do what ever filtering is necessary - ie encrypt
	//	the data.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CTransmitPacket*	pTransmitPacket,	
						BOOL&	fAcceptRequests	
						) ;

	//
	//	Start a CIO operation
	//
	BOOL	Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	//
	//	Start a CIOPassThru operation
	//
	virtual	BOOL	Start(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,
						BOOL	&fAcceptRequests,	
						BOOL	&fRequireRequests,	
						unsigned cAhead = 0
						) ;

	//
	//	Do the necessary filtering on a completed read before passing
	//	to the higher protocol layers - this will mean decrypting data etc...
	//
	virtual	int Complete(	
						IN CSessionSocket*,
						IN	CReadPacket*,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest
						) ;

	//
	//	Do the necessary filtering of a completed write before passing
	//	on to the higher layers
	//
	virtual	int	Complete(	
						IN CSessionSocket*,
						IN	CWritePacket*,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest
						) ;

	//
	//	Do the necessary filtering of a completed TransmitFile
	//
	virtual	void	Complete(	
						IN CSessionSocket*,
						IN	CTransmitPacket*,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest
						) ;

} ;


#ifdef _NO_TEMPLATES_
DECLARE_SMARTPTRFUNC( CIOPassThru )
#endif


class	CIOSealMessages : public	CIOPassThru	{
//
//	Only exists to perform SSPI Seals on outbound packets.
//
//	NOTE : CTransmitPacket's will probably require another CIOPassThru derived class !
//	This class will only process individual CWritePacket's
//
private:
	//	
	//	Encryption Context which has our SSL keys, SSPI interface etc...
	//
	CEncryptCtx&	m_encrypt ;

protected:

#ifdef	DEBUG
	~CIOSealMessages()	{}
#endif

public :
	
	//
	//	Must build with an Encryption Context ready to go
	//
	CIOSealMessages( CEncryptCtx&	encrypt ) ;

	
	//
	//	The InitRequest will Seal the message and then issue it to
	//	the socket.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CWritePacket*	pWritePacket,	
						BOOL&	fAcceptRequests
						) ;

	//
	//
	//
	virtual	BOOL	Start(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,
						BOOL	&fAcceptRequests,	
						BOOL	&fRequireRequests,	
						unsigned cAhead = 0
						) ;

	//
	//	Completion of Seal'd messages is easy - just mark the pRequest
	//	packet as transferring all of its bytes and indicate that it
	//	should be returned to its originator
	//
	virtual	int	Complete(	IN CSessionSocket*,
							IN	CWritePacket*,	
							CPacket*	pRequest,	
							BOOL&	fCompleteRequest ) ;

	//
	//	We don't have any shutdown processing to do - this will just
	//	return
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	pdriver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

protected :
	//
	//	Util function for Sealing a packet - for internal use only
	//
	BOOL	SealMessage(	
					IN	class	CRWPacket*	pPacket
					)
	{
		SECURITY_STATUS	ss = ERROR_NOT_SUPPORTED ;
		DWORD			cbNew;
		BOOL			fRet = FALSE ;

		fRet = m_encrypt.SealMessage(
						(LPBYTE)pPacket->StartData(),
						pPacket->m_ibEndData - pPacket->m_ibStartData,
						(LPBYTE)pPacket->StartData() - m_encrypt.GetSealHeaderSize(),
						&cbNew );

   		if( fRet )
		{
   			pPacket->m_ibStartData -= m_encrypt.GetSealHeaderSize();
   			pPacket->m_ibEndData += m_encrypt.GetSealTrailerSize();

			_ASSERT( pPacket->m_ibEndData - pPacket->m_ibStartData == cbNew );
   		}

		return	ss;
	}
}  ;

class	CIOUnsealMessages : public	CIOPassThru	{
//
//	Only exists to process inbound read packets and Unseal them.
//
private:
	//
	//	Encryption Context we use to unseal the message
	//
	CEncryptCtx&	m_encrypt ;

	//
	//	A buffer containing partially read data for incomplete Unseal's
	//
	CBUFPTR			m_pbuffer ;
	
	//
	//	Number of bytes we need to build a complete Unseal'able message
	//	in our buffer.  This can be 0 in cases where we can't figure out
	//	how many bytes we need !!!
	//
	DWORD			m_cbRequired ;

	//
	//	Starting point of the usable portion of the buffer
	//
	DWORD			m_ibStart ;

	//
	//	Start of the encrypted data within the buffer
	//
	DWORD			m_ibStartData ;

	//
	//	End of the usable range of bytes within the buffer
	//
	DWORD			m_ibEnd ;

	//
	//	Last byte of received data within the buffer
	//
	DWORD			m_ibEndData ;

protected:

#ifdef	DEBUG
	~CIOUnsealMessages()	{}
#endif

public :

	//
	//	Build a CIOUnsealMessages block - always require an encryption context
	//
	CIOUnsealMessages(
					CEncryptCtx&	encrypt
					) ;

	//
	//	Very little to do when a Read request is issued - just
	//	turn the request around and issue a read against the socket.
	//
	BOOL	InitRequest(
					class	CIODriverSource&	driver,	
					CSessionSocket*	pSocket,	
					CReadPacket*	pReadPacket,	
					BOOL&	fAcceptRequests
					) ;

	//
	//
	//
	BOOL	Start(	CIODriverSource&	driver,	
					CSessionSocket*	pSocket,
					BOOL	&fAcceptRequests,	
					BOOL	&fRequireRequests,	
					unsigned cAhead = 0
					) ;

	//
	//	On completed reads we will copy data out of the buffer
	//	in order to build complete Unseal'able blocks of data.
	//
	int	Complete(	IN CSessionSocket*,
					IN	CReadPacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	//
	//	Very little shutdown work we need to do
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	pdriver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

protected :

	//
	//	Utility function which wraps up our calls to the CEncryptCtx
	//
	BOOL	UnsealMessage(	
					CBuffer&		buffer,
					DWORD&			cbConsumed,
					DWORD&			cbRequired,
					DWORD&			ibStartData,
					DWORD&			ibEndData,
					BOOL&			fComplete
		            )
	{
		SECURITY_STATUS	ss = ERROR_NOT_SUPPORTED ;
		LPBYTE			pbDecrypt;
		DWORD			cbDecrypted;
		DWORD			cbExpected;
		DWORD			ibSaveStartData = ibStartData;
		BOOL			fSuccess = FALSE ;
		fComplete = FALSE ;

		fSuccess = m_encrypt.UnsealMessage(
						(LPBYTE)buffer.m_rgBuff + ibStartData,
						ibEndData - ibStartData,
						&pbDecrypt,
						&cbDecrypted,
						&cbExpected );

		ss = GetLastError() ;

        if ( fSuccess )
		{
			ibStartData = (DWORD)(pbDecrypt - (LPBYTE)buffer.m_rgBuff);
			ibEndData = ibStartData + cbDecrypted;
			cbConsumed = ibEndData - ibSaveStartData;
			fComplete = TRUE ;

			_ASSERT( cbConsumed == m_encrypt.GetSealHeaderSize() + cbDecrypted );
        }
		else if( ss == SEC_E_INCOMPLETE_MESSAGE )
		{
			cbRequired = cbExpected;
			cbConsumed = ibEndData - ibStartData;
			fSuccess = TRUE ;
        }
		else
		{
			//	
			//	Some kind of unanticipated error occurred - return FALSE
			//	and let caller blow the session off.
			//
			cbConsumed = 0;
			cbRequired = 0;
			ibStartData = 0;
			ibEndData = 0;
		}

		return	fSuccess;
	}

	BOOL	DecryptInputBuffer(	
						IN	LPBYTE	pBuffer,
						IN	DWORD	cbInBuffer,
						OUT	DWORD&	cbLead,
						OUT	DWORD&	cbConsumed,
						OUT	DWORD&	cbData,
						OUT	DWORD&	cbRequired,
						OUT	BOOL&	fComplete
						) ;

}  ;

class	CIOTransmitSSL : public	CIOPassThru	{
private :

	//
	//	Encryption context to use to encrypt the file data
	//	this actually lives in a CSessionSocket::m_context object,
	//	and we just keep a reference here to speed things up.
	//
	CEncryptCtx&	m_encryptCtx ;
	
	//
	//	The CIODriverSource which will process completions
	//
	CDRIVERPTR		m_pSocketSink ;

	//
	//	The CIODriverSink which originated the TransmitFile request
	//
	CDRIVERPTR		m_pDriverSource ;
	
	//
	//	The CChannel from which we are reading the data
	//
	CFILEPTR		m_pFileChannel ;

	//
	//	The File Driver from which will handle completion of file IO's
	//
	CSINKPTR		m_pFileDriver ;

	//
	//	The TransmitFileBuffers which will be sent in the message
	//
	TRANSMIT_FILE_BUFFERS	*m_pbuffers ;

	//
	//	This is initialized to a negative number, the absolute value of
	//	which tells us how many reads we want to always have pending.
	//	Each time we issue a read we will InterlockedIncrement this,
	//	and when we reach zero we know that we are so many reads ahead.
	//
	long			m_cReads ;

	//
	//	Number of Writes that have been issued
	//
	DWORD			m_cWrites ;

	//
	//	Number of writes that have beeen completed
	//
	DWORD			m_cWritesCompleted ;

	//
	//	Current position within the file.
	//
	DWORD			m_ibCurrent ;

	//
	//	Final position within the file.
	//
	DWORD			m_ibEnd ;

	//
	//	Number of bytes of trailer text sent
	//
	DWORD			m_cbTailConsumed ;

	//
	//	Are we finished yet ?
	//
	BOOL			m_fCompleted ;

	//
	//	Number of Reads that have been flow controlled
	//
	long			m_cFlowControlled ;

	//	
	//
	//	
	BOOL			m_fFlowControlled ;

	//
	//	Setup the next read
	//
	void	ComputeNextRead(
					CReadPacket*	pRead
					) ;


	//
	//	Given a read and a write packet, adjust the write packet
	//	for any extra data we had prepended to the read, and figure
	//	out if this is the last read necessary from the file.
	//
	BOOL	CompleteRead(
					CReadPacket*	pRead,
					CWritePacket*	pWrite
					) ;

	//
	//	Release all of our stuff, and get ready for a new call
	//	to InitRequest()
	//
	void	Reset() ;


	BOOL	SealMessage(	
					IN	class	CRWPacket*	pPacket
					)
	{
		SECURITY_STATUS	ss = ERROR_NOT_SUPPORTED ;
		DWORD			cbNew;
		BOOL			fRet = FALSE ;

		fRet = m_encryptCtx.SealMessage(
						(LPBYTE)pPacket->StartData(),
						pPacket->m_ibEndData - pPacket->m_ibStartData,
						(LPBYTE)pPacket->StartData() - m_encryptCtx.GetSealHeaderSize(),
						&cbNew );

   		if( fRet )
		{
   			pPacket->m_ibStartData -= m_encryptCtx.GetSealHeaderSize();
   			pPacket->m_ibEndData += m_encryptCtx.GetSealTrailerSize();

			_ASSERT( pPacket->m_ibEndData - pPacket->m_ibStartData == cbNew );
   		}

		return	ss;
	}

protected :
#ifdef	DEBUG
	~CIOTransmitSSL()	{}
#endif

public :

	//
	//	Globals which control flow control !
	//
	static	DWORD	MAX_OUTSTANDING_WRITES ;
	static	DWORD	RESTORE_FLOW ;


	CIOTransmitSSL(
					CEncryptCtx&	encrypt,
					CIODriver&		sink
					) ;

	//
	//	Called to start transferring a file when
	//	we have gotten an initial TransmitFile request
	//
	BOOL	InitRequest(
					class	CIODriverSource&	driver,	
					CSessionSocket*		pSocket,	
					CTransmitPacket*	pTransmitPacket,	
					BOOL&				fAcceptRequests
					) ;

	//
	//	This is called when we are ready to start issuing reads
	//	to a file
	//
	BOOL	Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	//
	//	Called when file reads complete.
	//
	int Complete(	IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	BOOL	Start(	CIODriverSource&	driver,	
					CSessionSocket*	pSocket,
					BOOL	&fAcceptRequests,	
					BOOL	&fRequireRequests,	
					unsigned cAhead = 0
					) ;

	//
	//	Called when a write to a socket completes.
	//
	int	Complete(	IN CSessionSocket*,
					IN	CWritePacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	//
	//	Tear down stuff, if cause == CAUSE_NORMAL_CIO_TERMINATION
	//	then everything has been succesfull, and we only need tear down
	//	our file stuff.
	//	Otherwise, we need to tear down the socket drivers as well.
	//
	void	Term(	
					CSessionSocket*	pSocket,
					enum	SHUTDOWN_CAUSE	cause,
					DWORD	dwError
					) ;					

	//
	//	Our notification function which is called when we terminate
	//	CIODrivers.  This will be called in regular operation as we
	//	finish async IO to different file handles.
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	pdriver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

	static	void	ShutdownFunc(
						void*	pv,
						SHUTDOWN_CAUSE	cause,
						DWORD			dwOptionalError
						) ;

} ;



class	CIOServerSSL	:	public	CIO	{
//
//	Server Side SSL logons.  This CIO object can be
//	issued onto a CIODriverSink at startup, and will do
//	all of the necessary SSL negogtiation to get a session
//	key etc... Once this is established, we'll insert an
//	underlying CIODriverSource mechanism to filter
//	(encrypt/decrypt) all packets on the fly.
//
private :
	
	//
	//	Context we are using for encryption - hold SSPI stuff
	//
	CEncryptCtx		&m_encrypt ;

	//
	//	The write packet we are going to put our data in when
	//	we successfully call m_encrypt.Converse().
	//
	CWritePacket*	m_pWrite ;

	//
	//	Keep track of whether we have successfully authenticated yet.
	//
	BOOL			m_fAuthenticated ;

	//
	//	Number of IO's pending
	//
	long			m_cPending ;

	//
	//	Keep track of CIODriver sequence numbers so that we can
	//	insert a CIODriverSource into the stream later
	//
	SEQUENCENO		m_sequencenoNextRead ;
	SEQUENCENO		m_sequencenoNextWrite ;

	//
	//	Our start function will get called twice - make sure
	//	we don't get messed up because of this.
	//
	BOOL			m_fStarted ;

	//
	//	A buffer containing partially read data for incomplete Unseal's
	//
	CBUFPTR			m_pbuffer ;

	//
	//	Starting offset of data within the buffer
	//
	DWORD			m_ibStartData ;

	//
	//	Number of bytes of data we already have in the buffer !!
	//
	DWORD			m_ibEndData ;

	//
	//	Last byte we can use in the buffer !!
	//
	DWORD			m_ibEnd ;

protected :
	//
	//	Destructor ensures that m_pWrite is released !!
	//
	~CIOServerSSL( ) ;

public :
	//
	//	Create a CIOServerSSL object
	//
	CIOServerSSL(
			CSessionState	*pstate,
			CEncryptCtx& encrypt
			) ;
	
	//
	//	Create a CIODriverSource and initialize it to handle
	//	encryption/decryption
	//
	BOOL	SetupSource(
					CIODriver&	driver,
					CSessionSocket*	pSocket
					) ;

	//
	//	Start stuff going - issue initial reads and the like
	//
	BOOL	Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	//
	//	Next packet in the negogtiation - let SSPI examine it
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	Process completions of our negogtiated packets
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	void	Complete(	
					IN CSessionSocket*,
					IN	CTransmitPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	An error has occurred and the ssession is being blown off.
	//	Very little shutdown work we need to do
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	pdriver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;


} ;

class	CIOShutdown : public CIOPassThru	{
//
//	This CIO object exists solely to help shutdown processing.
//	IO's that are outstanding when a CIODriver is shutdown need to
//	have some minimum processing done during termination, we do that.
//
public :

	//
	//	Build a CIOShutdown object - only one is every built, its
	//	a global.  We put the reference count to an artificially
	//	high number so we never mistakenly think we have to delete it.
	//
	CIOShutdown()	{	m_refs = 0x40000000 ; }

	//
	//	Desctructor -
	//
	~CIOShutdown()	{
#ifdef	_ENABLE_ASSERTS
		m_refs = -1 ;
#endif
	}	


	//
	//	swallow this call - we're dying and if somebody is still trying to do
	//	IO, to bad for them.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CReadPacket*	pPacket,	
						BOOL&	fAcceptRequests
						) ;

	//
	//	swallow this call - we're dying and if somebody is still trying to do
	//	IO, to bad for them.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CWritePacket*	pWritePacket,	
						BOOL&	fAcceptRequests
						) ;


	//
	//	swallow this call - we're dying and if somebody is still trying to do
	//	IO, to bad for them.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CTransmitPacket*	pTransmitPacket,	
						BOOL&	fAcceptRequests	
						) ;


	//
	//	We don't need this function except to fill our vtbl.
	//
	BOOL	Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	void	Complete(	
					IN CSessionSocket*,
					IN	CTransmitPacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	void	Complete(	
					IN CSessionSocket*,
					IN	CTransmitPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	Process a deferred completion ! - just swallow it !
	//
	void	Complete(	
					IN	CSessionSocket*,
					IN	CExecutePacket*,
					OUT	CIO*	&pio
					) ;

} ;

class	CIOGetArticle : public	CIORead	{
//
//	Do all the IO's necessary to transfer a complete posting
//	from a socket to a file.
//
protected :

	//
	//	Variable to hold onto the tail pattern we're looking for.
	//
	static	char	szTailState[] ;

	//
	//	Varitable to hold onto the head separator patter we're looking for.
	//
	static	char	szHeadState[] ;

	//
	//	The directory to hold the temporary file, if necessary !
	//
	LPSTR			m_lpstrTempDir ;

	//
	//	The prefix for the temporary file, if necessary !
	//
	char			(&m_szTempName)[MAX_PATH];

	//
	//	The CIODriver where we are getting our socket read completions
	//
	CDRIVERPTR		m_pSocketSink ;
	
	//
	//	The CChannel which is handling our File Writes
	//
	CFILEPTR		m_pFileChannel ;

	//
	//	The CIODriver which processes completions of our File Writes
	//
	CSINKPTR		m_pFileDriver ;

	//
	//	Keep track of our Initialization state, in case we are
	//	destroyed before entirely started
	//
	BOOL			m_fDriverInit ;	// TRUE if m_pFileDriver->Init() was called !

	//
	//	Number of empty bytes the caller wants the file to start with !
	//
	DWORD			m_cbGap ;
	
	//
	//	Hard Limit - drop session if this is exceeded.
	//
	DWORD			m_cbLimit ;

	//
	//	The STRMPOSITION which will exceed our hard limit
	//
	STRMPOSITION	m_HardLimit ;

	//
	//	A pointer into szTailState[] indicating what portion of the
	//	trail pattern we've recognized
	//
	LPSTR			m_pchTailState ;

	//
	//	A pointer into szHeadState[] which determines helps us
	//	determine whether we've found the complete head of the article
	//
	LPSTR			m_pchHeadState ;

	//
	//	A smart pointer to a buffer which holds the head of the article
	//
	CBUFPTR			m_pArticleHead ;
	//
	//	The start of the head of the article within the buffer
	//
	DWORD			m_ibStartHead ;
	//
	//	The end of the head of the article within the buffer
	//
	DWORD			m_ibEndHead ;
	//
	//	The starting offset of header bytes within the buffer
	//
	DWORD			m_ibStartHeadData ;
	//
	//	The ending offset of all data within the header buffer
	//
	DWORD			m_ibEndHeadData ;
	//
	//	Number of bytes in the header
	//
	DWORD			m_cbHeadBytes ;
	//
	//	Boolean indicating whether we can stuff non-header bytes into
	//	m_pArticleHead
	//
	BOOL			m_fAcceptNonHeaderBytes ;

	//	The end of the article within the buffer if m_fWholeArticle is TRUE !
	//
	DWORD			m_ibEndArticle ;

	//
	//	Maximum number of Reads that we should be ahead of Writes
	//
	static	unsigned	maxReadAhead ;

	//
	//	Number of bytes which is too small to issue as one file write
	//	accumulate more bytes before doing file IO.
	//
	static	unsigned	cbTooSmallWrite ;

	//
	//	Number of writes issued
	//
	unsigned		m_cwrites ;	//	Count of Writes that were issued

	//
	//	Number of writes that have completed
	//
	unsigned		m_cwritesCompleted ;	// Count of Writes that were completed
	long			m_cFlowControlled ;	// Number of times we should have issued reads
									// but didn't due to flow control to the disk!
	
	long			m_cReads ;			// Number of reads

	//	
	//	Are we in our flow control state
	//
	BOOL			m_fFlowControlled ;

	//
	//	A write packet we are using to accumulate bytes for FILE IO
	//
	CWritePacket*	m_pWrite ;
	
#ifdef	CIO_DEBUG
	//
	//	Debug variables used to ensure that callers properly use Init() Term() interface !
	//
	BOOL			m_fSuccessfullInit ;
	BOOL			m_fTerminated ;
#endif

	//
	//	How many bytes are available in the header storage area ?
	//
	inline	DWORD	HeaderSpaceAvailable() ;

	//
	//	Copy bytes into our header buffer and adjust all the members
	//	to reflect the number of bytes used within the header !
	//
	inline	void	FillHeaderSpace(	
							char*	pchData,
							DWORD	cbData
							) ;

	//
	//	Try to get a larger buffer to hold header information -
	//
	inline	BOOL	GetBiggerHeaderBuffer(
							CIODriver&	driver,
							DWORD		cbRequired
							) ;

	//
	//	Initialize the buffer we're using to hold header information -
	//	grab the buffer right out of the incoming read !!
	//
	inline	void	InitializeHeaderSpace(
							CReadPacket*	pRead,
							DWORD			cbArticleBytes
							) ;

	//
	//	When errors occur call this guy to set us into a state
	//	where we continue to read but end up telling m_pState
	//	that the article transfer failed !!
	//
	inline	BOOL	ResetHeaderState(
							CIODriver&	driver
							) ;

	//
	//	Function for calling m_pStates completion function when
	//	we have completed all the necessary IO's
	//
	void	DoCompletion(	CSessionSocket*	pSocket,
							HANDLE	hFile,
							DWORD	cbFullBuffer,
							DWORD	cbTotalTransfer,
							DWORD	cbAvailableBuffer,
							DWORD	cbGap = 0
							) ;


	//
	//	This function sets things up so that we can start doing
	//	async file IO !
	//
	BOOL	InitializeForFileIO(
								CSessionSocket*	pSocket,
								CIODriver&		readDriver,
								DWORD			cbHeaderBytes
								) ;

	//
	//	Destructor is protected to force clients to use
	//	the correct destruction method !
	//
	~CIOGetArticle( ) ;

public :
	CIOGetArticle(	CSessionState*	pstate,
					CSessionSocket*	pSocket,	
					CDRIVERPTR&	pDriver,
					LPSTR	lpstrTempDir,	
					char	(&lpstrTempName)[MAX_PATH],
					DWORD	cbLimit,	
					BOOL	fSaveHead = FALSE,
					BOOL	fPartial = FALSE )	;

	//
	//	Initialization and termination functions
	//	
	//	After we've been successfully initialized the user must not delete us,
	//	instead they must call our Term function
	//
	BOOL	Init(	CSessionSocket*	pSocket,	
					unsigned cbOffset = 0
					) ;

	//
	//	Termination function - tear down at least the CIODriver for the file
	//	IO, and maybe tear down the Socket's CIODriver (and session as well)
	//
	void	Term(	CSessionSocket*	pSocket,	
					BOOL	fAbort = TRUE,	
					BOOL	fStarted = TRUE
					) ;

	//
	//	Do everything we need to do regarding flow control
	//
	void	DoFlowControl(PNNTP_SERVER_INSTANCE pInstance) ;

	//
	//	Issue our first IO's
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket	*pSocket,	
					unsigned cAhead = 0	
					) ;

	//
	//	A Read from the socket has completed
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	A Write to the file has completed
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	One of the 2 CIODriver's we use is being torn down,
	//	figure out if the other one needs to be torn down as well.
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	driver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

	static	void	ShutdownFunc(	
						void	*pv,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptionalError
						) ;		
} ;

class	CIOGetArticleEx : public	CIORead	{
//
//	Do all the IO's necessary to transfer a complete posting
//	from a socket to a file.
//
protected :

	//
	//	The CIODriver where we are getting our socket read completions
	//
	CDRIVERPTR		m_pSocketSink ;
	//
	//	The CChannel which is handling our File Writes
	//
	CFILEPTR		m_pFileChannel ;
	//
	//	The CIODriver which processes completions of our File Writes
	//
	CSINKPTR		m_pFileDriver ;
	//
	//	Keep track of our Initialization state, in case we are
	//	destroyed before entirely started
	//
	BOOL			m_fDriverInit ;	// TRUE if m_pFileDriver->Init() was called !
	//
	//	Do we want to swallow all of the incoming bytes ?
	//	
	BOOL			m_fSwallow ;
	//
	//	Hard Limit - drop session if this is exceeded.
	//
	DWORD			m_cbLimit ;
	//
	//	The STRMPOSITION which will exceed our hard limit
	//
	STRMPOSITION	m_HardLimit ;
	//
	//	The string we are to match to find the end of this section !
	//
	LPSTR			m_pchMatch ;
	//
	//	A pointer into szTailState[] indicating what portion of the
	//	trail pattern we've recognized
	//
	LPSTR			m_pchTailState ;
	//
	//	The string that if we match indicates some kind of early error
	//	completion !
	//
	LPSTR			m_pchErrorMatch ;
	//
	//	The state of matching the error string !
	//
	LPSTR			m_pchErrorState ;
	//
	//	A smart pointer to a buffer which holds the head of the article
	//
	CBUFPTR			m_pArticleHead ;
	//
	//	The start of the head of the article within the buffer
	//
	DWORD			m_ibStartHead ;
	//
	//	The end of the head of the article within the buffer
	//
	DWORD			m_ibEndHead ;
		//
	//	The starting offset of header bytes within the buffer
	//
	DWORD			m_ibStartHeadData ;
	//
	//	The ending offset of all data within the header buffer
	//
	DWORD			m_ibEndHeadData ;
	//
	//	Maximum number of Reads that we should be ahead of Writes
	//
	static	unsigned	maxReadAhead ;

	//
	//	Number of bytes which is too small to issue as one file write
	//	accumulate more bytes before doing file IO.
	//
	static	unsigned	cbTooSmallWrite ;

	//
	//	Number of writes issued
	//
	unsigned		m_cwrites ;	//	Count of Writes that were issued

	//
	//	Number of writes that have completed
	//
	unsigned		m_cwritesCompleted ;	// Count of Writes that were completed
	long			m_cFlowControlled ;	// Number of times we should have issued reads
									// but didn't due to flow control to the disk!
	
	long			m_cReads ;			// Number of reads

	//	
	//	Are we in our flow control state
	//
	BOOL			m_fFlowControlled ;

	//
	//	A write packet we are using to accumulate bytes for FILE IO
	//
	CWritePacket*	m_pWrite ;
	
#ifdef	CIO_DEBUG
	//
	//	Debug variables used to ensure that callers properly use Init() Term() interface !
	//
	BOOL			m_fSuccessfullInit ;
	BOOL			m_fTerminated ;
#endif


	//
	//	How many bytes are available in the header storage area ?
	//
	inline	DWORD	HeaderSpaceAvailable() ;

	//
	//	Copy bytes into our header buffer and adjust all the members
	//	to reflect the number of bytes used within the header !
	//
	inline	void	FillHeaderSpace(	
							char*	pchData,
							DWORD	cbData
							) ;

	//
	//	Try to get a larger buffer to hold header information -
	//
	inline	BOOL	GetBiggerHeaderBuffer(
							CIODriver&	driver,
							DWORD		cbRequired
							) ;

	//
	//	Initialize the buffer we're using to hold header information -
	//	grab the buffer right out of the incoming read !!
	//
	inline	void	InitializeHeaderSpace(
							CReadPacket*	pRead,
							DWORD			cbArticleBytes
							) ;

	//
	//	This function sets things up so that we can start doing
	//	async file IO !
	//
	BOOL	InitializeForFileIO(
								FIO_CONTEXT*	pFIOContext,
								CSessionSocket*	pSocket,
								CIODriver&		readDriver,
								DWORD			cbHeaderBytes
								) ;

	//
	//	Destructor is protected to force clients to use
	//	the correct destruction method !
	//
	~CIOGetArticleEx( ) ;

	//
	//	Are we a legal object !
	//
	BOOL
	FValid() ;

public :
	CIOGetArticleEx(	
					CSessionState*	pstate,
					CSessionSocket*	pSocket,	
					CDRIVERPTR&	pDriver,
					DWORD	cbLimit,
					LPSTR	szMatch,
					LPSTR	pchInitial,
					LPSTR	szErrorMatch,
					LPSTR	pchInitialError
					)	;

	//
	//	Initialization and termination functions
	//	
	//	After we've been successfully initialized the user must not delete us,
	//	instead they must call our Term function
	//
	BOOL	Init(	CSessionSocket*	pSocket,	
					unsigned cbOffset = 0
					) ;

	//
	//	Termination function - tear down at least the CIODriver for the file
	//	IO, and maybe tear down the Socket's CIODriver (and session as well)
	//
	void	Term(	CSessionSocket*	pSocket,	
					BOOL	fAbort = TRUE,	
					BOOL	fStarted = TRUE
					) ;

	//
	//	Do everything we need to do regarding flow control
	//
	void	DoFlowControl(PNNTP_SERVER_INSTANCE pInstance) ;

	//
	//	Issue our first IO's
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket	*pSocket,	
					unsigned cAhead = 0	
					) ;

	//
	//	Start doing writes to the file !
	//
	BOOL	StartFileIO(
					CSessionSocket*	pSocket,
					FIO_CONTEXT*	pFIOContext,
					CBUFPTR&	pBuffer,
					DWORD		ibStartBuffer,
					DWORD		ibEndBuffer,
					LPSTR		szMatch,
					LPSTR		pchInitial
					) ;

	//
	//	A Read from the socket has completed
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	A Write to the file has completed
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	One of the 2 CIODriver's we use is being torn down,
	//	figure out if the other one needs to be torn down as well.
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	driver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

	static	void	ShutdownFunc(	
						void	*pv,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptionalError
						) ;		
} ;




class	CIOReadArticle : public	CIORead	{
//
//	Do all the IO's necessary to transfer a complete posting
//	from a socket to a file.
//
protected :

	//
	//	The CIODriver where we are getting our socket read completions
	//
	CDRIVERPTR			m_pSocketSink ;
	
	//
	//	The CChannel which is handling our File Writes
	//
	CFILEPTR			m_pFileChannel ;

	//
	//	The CIODriver which processes completions of our File Writes
	//
	CSINKPTR			m_pFileDriver ;

	//
	//	Keep track of our Initialization state, in case we are
	//	destroyed before entirely started
	//
	BOOL				m_fDriverInit ;	// TRUE if m_pFileDriver->Init() was called !
	
	//
	//	Hard Limit - drop session if this is exceeded.
	//
	DWORD				m_cbLimit ;

	//
	//	The STRMPOSITION which will exceed our hard limit
	//
	STRMPOSITION		m_HardLimit ;

	//
	//	State information regarding how much of the terminating CRLF.CRLF we've
	//	seend
	//	
	enum	ArtState	{
		NONE	= 0,
		NEWLINE	= 1,
		BEGINLINE	= 2,
		PERIOD = 3,
		COMPLETENEWLINE = 4,
		COMPLETE = 5,
	} ;
	
	//
	//	Current state of CRLF.CRLF	
	//
	ArtState	m_artstate ;

	//
	//	Maximum number of Reads that we should be ahead of Writes
	//
	static	unsigned	maxReadAhead ;

	//
	//	Number of bytes which is too small to issue as one file write
	//	accumulate more bytes before doing file IO.
	//
	static	unsigned	cbTooSmallWrite ;

	//
	//	Number of writes issued
	//
	unsigned	m_cwrites ;	//	Count of Writes that were issued

	//
	//	Number of writes that have completed
	//
	unsigned	m_cwritesCompleted ;	// Count of Writes that were completed
	long		m_cFlowControlled ;	// Number of times we should have issued reads
									// but didn't due to flow control to the disk!
	
	long		m_cReads ;			// Number of reads

	//	
	//	Are we in our flow control state
	//
	BOOL		m_fFlowControlled ;

	//
	//	A write packet we are using to accumulate bytes for FILE IO
	//
	CWritePacket*	m_pWrite ;

#ifdef	CIO_DEBUG
	//
	//	Debug variables used to ensure that callers properly use Init() Term() interface !
	//
	BOOL		m_fSuccessfullInit ;
	BOOL		m_fTerminated ;
#endif

	//
	//	Destructor is protected to force clients through
	//	correct destruction method
	//
	~CIOReadArticle( ) ;

public :
	CIOReadArticle(	CSessionState*	pstate,
					CSessionSocket*	pSocket,	
					CDRIVERPTR&	pDriver,	
					CFileChannel*	pFileChannel,
					DWORD	cbLimit,	
					BOOL	fPartial = FALSE )	;

	//
	//	Initialization and termination functions
	//	
	//	After we've been successfully initialized the user must not delete us,
	//	instead they must call our Term function
	//
	BOOL	Init(	CSessionSocket*	pSocket,	
					unsigned cbOffset = 0
					) ;

	//
	//	Termination function - tear down at least the CIODriver for the file
	//	IO, and maybe tear down the Socket's CIODriver (and session as well)
	//
	void	Term(	CSessionSocket*	pSocket,	
					BOOL	fAbort = TRUE,	
					BOOL	fStarted = TRUE
					) ;

	//
	//	Do everything we need to do regarding flow control
	//
	void	DoFlowControl(PNNTP_SERVER_INSTANCE pInstance) ;

	//
	//	Issue our first IO's
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket	*pSocket,	
					unsigned cAhead = 0	
					) ;

	//
	//	A Read from the socket has completed
	//
	int Complete(	IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	A Write to the file has completed
	//
	int	Complete(	IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	One of the 2 CIODriver's we use is being torn down,
	//	figure out if the other one needs to be torn down as well.
	//
	void	Shutdown(	CSessionSocket*	pSocket,	
						CIODriver&	driver,	
						enum	SHUTDOWN_CAUSE	cause,	
						DWORD	dwError
						) ;

	static	void	ShutdownFunc(	
						void	*pv,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptionalError
						) ;		
} ;



class   CIOReadLine ;

//-------------------------------------------------
class	CIOWriteLine :	public	CIOWrite	{
/*++

	Write an arbitrary line to a stream.

--*/
private :
	CWritePacket*	m_pWritePacket ;

	char*	m_pchStart ;
	char*	m_pchEnd ;
	static	unsigned	cbJunk ;
	enum	CONSTANTS	{
		WL_MAX_BYTES	= 768,
	} ;
protected :

	//
	//	Protected destructor to force clients through
	//	correct destruction method !
	//
	~CIOWriteLine( ) ;

public :
	CIOWriteLine( CSessionState*	pstate ) ;
	
	BOOL	InitBuffers( CDRIVERPTR&	pdriver,	CIOReadLine*	pReadLine ) ;
	BOOL	InitBuffers( CDRIVERPTR&	pdriver,	unsigned	cbLimit = WL_MAX_BYTES ) ;
	inline	char*	GetBuff(	unsigned	&cbRemaining = cbJunk ) ;
	inline	char*	GetTail( ) ;
	inline	void	SetLimits(	char*	pchStartData,	char*	pchEndData ) ;	
	inline	void	AddText(	unsigned	cb ) ;
	inline	void	Reset() ;
	
	BOOL	Start(	CIODriver&,	CSessionSocket*	pSocket,	unsigned	cReadAhead = 0 ) ;
	int	Complete(	IN	CSessionSocket*,	IN	CWritePacket*,	OUT CIO*	&pio ) ;
	void	Shutdown(	CSessionSocket*	pSocket,	CIODriver&	driver,	enum	SHUTDOWN_CAUSE	cause,	DWORD	dwError ) ;
} ;

//
//	This class exists to process CExecute derived objects - we will call
//	their Start and PartialExecute functions until they have sent all their data.
//
//
class	CIOWriteCMD :	public	CIOWrite	{
	//
	//	The CExecute derived object which is generating text to send
	//
	class	CExecute*	m_pCmd ;

	//
	//	The m_context - needed by *m_pCmd to get at the sessions state
	//
	struct	ClientContext&	m_context ;

	//
	//	A void pointer meaningless to us, but provided to m_pCmd on each
	//	call so the CExecute object can maintain some state accross calls
	//
	LPVOID		m_pv ;

	//
	//	The number of writes we've issued
	//
	unsigned	m_cWrites ;

	///
	//	The number of writes we've completed.
	//
	unsigned	m_cWritesCompleted ;

	//
	//	The size of the buffers we are using !
	//
	unsigned	m_cbBufferSize ;

	//
	//	Set to TRUE when we've issued the last write we're going to issue
	//
	BOOL		m_fComplete ;
	
	//
	//	Object which wants to collect log information !
	//
	class	CLogCollector*	m_pCollector ;

	//
	//	Destructor is protected to force clients through
	//	correct destruction mechanism !
	//
	~CIOWriteCMD( ) ;

public :

	//
	//	Create a CWriteCmd object which will execute
	//	the specified CExecute object.
	//
	CIOWriteCMD(	
			CSessionState*	pstate,	
			class	CExecute*	pCmd,	
			struct	ClientContext&	context,	
			BOOL	fIsLargeResponse,
			class CLogCollector*	pCollector=0
			) ;

	//
	//	Start calling the CExecute object and issuing
	//	write packets !
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead = 0
					) ;

	//
	//	Called as each write we issue completes !
	//
	int		Complete(	
					CSessionSocket*,	
					CWritePacket*,	
					CIO*&	
					) ;

	//
	//	Called when the session drops and we're still alive !!
	//
	void	Shutdown(	
					CSessionSocket*,	
					CIODriver&,	
					enum SHUTDOWN_CAUSE	cause,	
					DWORD	dw
					) ;
} ;


//
//	This class exists to process CExecute derived objects - we will call
//	their Start and PartialExecute functions until they have sent all their data.
//
//
class	CIOWriteAsyncCMD :	public	CIOWrite	{
	//
	//	The CExecute derived object which is generating text to send
	//
	class	CAsyncExecute*	m_pCmd ;

	//
	//	The m_context - needed by *m_pCmd to get at the sessions state
	//
	struct	ClientContext&	m_context ;

	//
	//	This is the function pointer into the Async Command that we use
	//	get our data !
	//
	typedef	CIOWriteAsyncComplete*	(CAsyncExecute::*PFNBUFFER)(
						BYTE*	pbStart,
						int		cb,
						struct	ClientContext&	context,
						class	CLogCollector*	pCollector
						) ;
	PFNBUFFER	m_pfnCurBuffer ;
	//
	//	The number of writes we've issued
	//
	unsigned	m_cWrites ;

	///
	//	The number of writes we've completed.
	//
	unsigned	m_cWritesCompleted ;

	//
	//	The size of the buffers we are using !
	//
	unsigned	m_cbBufferSize ;
	//
	//	Set to TRUE when we've issued the last write we're going to issue
	//
	BOOL	m_fComplete ;
	//
	//	Hold the packet we use for AsyncCommand completions if we need
	//	to do some flow control against the Command completions !
	//
	CExecutePacket*	m_pDeferred ;
	//
	//	Object which wants to collect log information !
	//
	class	CLogCollector*	m_pCollector ;
	//
	//	A void pointer meaningless to us, but provided to m_pCmd on each
	//	call so the CExecute object can maintain some state accross calls
	//
	LPVOID		m_pv ;
	//
	//	Destructor is protected to force clients through
	//	correct destruction mechanism !
	//
	~CIOWriteAsyncCMD( ) ;

	BOOL
	Execute(
			CExecutePacket*	pExecute,
			CIODriver&		driver,
			CSessionSocket*	pSocket,
			DWORD			cbInitialSize
			) ;

public :

	//
	//	Create a CWriteCmd object which will execute
	//	the specified CExecute object.
	//
	CIOWriteAsyncCMD(	
			CSessionState*	pstate,	
			class	CAsyncExecute*	pCmd,	
			struct	ClientContext&	context,	
			BOOL	fIsLargeResponse,
			class CLogCollector*	pCollector=0
			) ;


	//
	//	Completion function called by the Command object when its
	//	finished filling the buffer !
	//
	void
	CommandComplete(	BOOL	fLargerBuffer,
						BOOL	fComplete,
						DWORD	cbTransferred,
						CSessionSocket*	pSocket
						) ;
						

	//
	//	Start calling the CExecute object and issuing
	//	write packets !
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead = 0
					) ;

	//
	//	Process a deferred completion !
	//
	virtual	void
	Complete(	IN	CSessionSocket*,
				IN	CExecutePacket*,
				OUT	CIO*	&pio
				) ;

	//
	//	Called as each write we issue completes !
	//
	int		Complete(	
					CSessionSocket*,	
					CWritePacket*,	
					CIO*&	
					) ;

	//
	//	Called when the session drops and we're still alive !!
	//
	void	Shutdown(	
					CSessionSocket*,	
					CIODriver&,	
					enum SHUTDOWN_CAUSE	cause,	
					DWORD	dw
					) ;
} ;


typedef	CSmartPtr< CIOWriteAsyncCMD >	CIOWRITEASYNCCMDPTR ;
//
//	This class defines the base class for Store Driver Completion
//	objects that operate with CIOWriteAsyncCMD !
//
class	CIOWriteAsyncComplete : 	public	CNntpComplete	{
private :
	//
	//	CIOWriteAsyncCMD	is a friend of ours so that it
	//	can access this portion of our interface !
	//	
	friend	class	CIOWriteAsyncCMD ;
	//
	//	Hold this stuff for when we complete !
	//
	CSessionSocket*	m_pSocket ;
	//
	//	This is the packet we use to synchronize completion from
	//	the AsyncExecute object with Write Completions on the Completion
	//	port !
	//
	CExecutePacket*	m_pExecute ;
	//
	//	This is a ref counting pointer that we use to maintain a
	//	reference on the CIOWriteAsyncCMD that issued the operation.
	//	This should only be NON NULL if m_pExecute is NON NULL !
	//
	CIOWRITEASYNCCMDPTR	m_pWriteAsyncCMD ;
	//
	//	This function marks the completion object with all the state
	//	it needs to remain as a pending async completion !
	//	If we return FALSE then the operation has already completed
	//	and this object should NOT be touched again !
	//
	void
	FPendAsync(	CSessionSocket*		pSocket,
				CExecutePacket*		pExecute,
				class	CIOWriteAsyncCMD*	pWriteAsync
				) ;
				
protected :
	//
	//	This member must be FALSE if m_cbTransfer is not zero !
	//	This member can be set if m_cbTransfer != 0, which indicates
	//	that we must allocate a larger buffer for the IO operation !
	//
	unsigned	int	m_fLargerBuffer:1 ;
	unsigned	int	m_fComplete:1 ;
	//
	//	This member variable MUST BE SET by the derived class
	//	to contain the number of bytes transferred in the request -
	//	0 is regarded as a fatal error that should tear down the session !
	//
	DWORD	m_cbTransfer ;
	//
	//	This member function is called when the operation is completed !
	//	We are passed fReset which tells us whether we should reset for
	//	another operation !
	//
	void
	Complete(	BOOL	fReset	) ;
	
public :
	//
	//	Add a reference to ourselves when we're constructed !
	//
	CIOWriteAsyncComplete() :
		m_pSocket( 0 ),
		m_pExecute( 0 ),
		m_cbTransfer( 0 ),
		m_fLargerBuffer( FALSE ),
		m_fComplete( FALSE )	{
		AddRef() ;
	}
	//
	//	The destructor is called when the completion object is destroyed -
	//	By the time our destructor gets called, Complete() must be called
	//	for the finished Async operation !
	//
	~CIOWriteAsyncComplete() ;

	//
	//	This function is called only after Complete() has been called -
	//	it will reset our state so that we can be re-used for another
	//	async operation.
	//	NOTE : we will call CNntpComplete::Reset(), so that our base
	//	class is also ready for re-use !
	//
	void
	Reset() ;
}	;




//
//	The multi line structure is used when we wish to be able to
//	issue a CIOWriteMultiline.
//	m_pBuffer must be laid out with
//
//
struct	MultiLine	{
	//
	//	Reference counting to the buffer containing the data
	//
	CBUFPTR		m_pBuffer ;

	//
	//	Number of entries actually present - MAX is 16 !
	//
	DWORD		m_cEntries ;

	//
	//	Offsets to the data -
	//	Note that m_ibOffsets[17] is the offset to the end of the
	//	16th block of data - NOT an offset to the beginning of the
	//	17th piece.  Data is assumed to be contiguous so that
	//	m_ibOffsets[1] - m_ibOffsets[0] is the length of data
	//	starting at m_ibOffsets[0].
	//
	DWORD		m_ibOffsets[17] ;

	MultiLine() ;

	//
	//
	//
	BYTE*		Entry( DWORD i ) {
		_ASSERT( i < 17 ) ;
		return	(BYTE*)&m_pBuffer->m_rgBuff[ m_ibOffsets[i] ] ;
	}
} ;

class	CIOMLWrite :	public	CIOWrite	{
private :

	//
	//	Pointer to the MultiLine object describing the data !
	//
	MultiLine*	m_pml ;

	//
	//	The current chunk we are writing
	//	(only applicable if m_fCoalesceWrites == FALSE)
	//
	DWORD		m_iCurrent ;

	//
	//	if TRUE then the remote server can handling
	//	getting multiple lines all in one chunk !
	//
	BOOL		m_fCoalesceWrites ;

	//
	//	Do we want to log what we are sending !?
	//
	class		CLogCollector*	m_pCollector ;

public :

	//
	//	Create a CWriteCmd object which will execute
	//	the specified CExecute object.
	//
	CIOMLWrite(	
			CSessionState*	pstate,	
			MultiLine*		pml,
			BOOL	fCoalesce = FALSE,
			class CLogCollector*	pCollector=0
			) ;

	//
	//	Start calling the CExecute object and issuing
	//	write packets !
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead = 0
					) ;

	//
	//	Called as each write we issue completes !
	//
	int		Complete(	
					CSessionSocket*,	
					CWritePacket*,	
					CIO*&	
					) ;

	//
	//	Called when the session drops and we're still alive !!
	//
	void	Shutdown(	
					CSessionSocket*,	
					CIODriver&,	
					enum SHUTDOWN_CAUSE	cause,	
					DWORD	dw
					) ;
} ;



//
//	This class exists to wrap TransmitFile operations.
//
class	CIOTransmit : public	CIOWrite	{
private :
	
	//
	//	The packet representing the transmit file operation !
	//
	CTransmitPacket*	m_pTransmitPacket ;

	//
	//	Buffer holding any extra text we send
	//
	CBUFPTR				m_pExtraText ;

	//
	//	String to send before the file
	//
	char*				m_pchStartLead ;

	//
	//	Length of string to send before the file
	//
	int					m_cbLead ;

	//
	//	String to send following the file
	//
	char*				m_pchStartTail ;

	//
	//	Length of string following the file
	//
	int					m_cbTail ;

	//
	//	Catches unwanted return values
	//
	static	unsigned	cbJunk ;

protected :

	//	
	//	Destructor is protected to force clients through correct
	//	destruction method !
	//
	~CIOTransmit() ;

public :
	//
	//	Constructor stores a reference to the state issuing the IO.
	//
	CIOTransmit( CSessionState*	pstate ) ;

	//
	//	Get ready to transmit just a file with no extra text
	//
	BOOL	Init(	CDRIVERPTR&	pdriver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,	
					DWORD	cbExtra = 0
					) ;

	//
	//	Get ready to transmit a file and some preceeding text !
	//
	BOOL	Init(	CDRIVERPTR&	driver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,
					CBUFPTR&	pbuffer,
					DWORD	ibStart,	
					DWORD	ibEnd
					) ;

	//
	//	Get ready to transmit a file and some following text !
	//
	BOOL	InitWithTail(	
					CDRIVERPTR&	driver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,
					CBUFPTR&	pbuffer,
					DWORD	ibStart,	
					DWORD	ibEnd
					) ;

	//
	//	Sometimes we don't know what text we send during the Init call -
	//	so use GetBuff() to find a buffer we've stored away and to
	//	stick strings into it.
	//
	char*	GetBuff( unsigned	&cbRemaining = cbJunk ) ;

	//
	//	The first cb bytes of the buffer referenced by GetBuff contain
	//	leading text.
	//
	void	AddLeadText( unsigned	cb ) ;

	//
	//	The next cb bytes of the buffer referenced by GetBuff contain trailer text.
	//
	void	AddTailText( unsigned	cb ) ;
	
	//
	//
	//
	void	AddTailText( char*	pch,	unsigned	cb ) ;

	//
	//	Let me see the lead text that is set to go
	//
	LPSTR	GetLeadText(	unsigned	&cb ) ;
	LPSTR	GetTailText(	unsigned	&cb ) ;

	//
	//	Called when everything is setup and its time to do the transmit
	//
	BOOL	Start(	CIODriver&,	CSessionSocket*,	
					unsigned	cAhead
					) ;

	//
	//	Called when the TransmitFile completes !
	//
	void	Complete(	IN CSessionSocket*,
						IN	CTransmitPacket*,	
						OUT	CIO*	&pio
						) ;

	//
	//	Called if the socket drops while Transmit is in progress !
	//
	void	Shutdown(	CSessionSocket*	pSocket,	
						CIODriver&	driver,	
						enum	SHUTDOWN_CAUSE	cause,	
						DWORD	dwError
						) ;
} ;
	

//------------------------------------
class	CIOReadLine : public CIORead {
//
// This class will reissue reads to a socket until a complete line is read (terminated by NewLine)
// or the provided buffer is filled.
//
private :
	friend	class   CIOWriteLine ;
	enum	CONSTANTS	{
		MAX_STRINGS	= 20,		// Maximum number of strings
		MAX_BYTES = 768,		//	At most 1K of data on an individual line
		REQUEST_BYTES = 4000,
	} ;

	//	
	//	This variable holds the pattern we are looking for
	//	to terminate the line
	//
	static	char	szLineState[] ;

	//
	//	This variable is used to determine when we have hit
	//	the end of the line.
	//
	LPSTR	m_pchLineState ;

	//
	// If this is true than we are probably reading from a file
	// and need to be carefull.
	//
	BOOL	m_fWatchEOF ;		

	//
	// The buffer in which the string is held
	//
	CBUFPTR	m_pbuffer ;			

	//
	// Starting point of the usable portion of the buffer
	//
	char*	m_pchStart ;		

	//
	// Start of data within the buffer
	//
	char*	m_pchStartData ;	

	//
	// End of the data within the buffer
	//
	char*	m_pchEndData ;		

	//
	// End of the usable portion of the buffer
	//
	char*	m_pchEnd ;			

#ifdef	DEBUG
protected :
	~CIOReadLine()	{}
#endif

public :

	//
	//	Our constructor - we get passed the state that we are
	//	to report completions to.  We will bump the state's reference count.
	//	Also, fWatchEOF specifies whether we need to take care for
	//	EOF situations when reading from files.
	//
	CIOReadLine(	
					CSessionState*	pstate,
					BOOL fWatchEOF = FALSE
					) ;

	//
	//	Start reading the line - Read from the socket or file.
	//
	BOOL	Start(	
					CIODriver&,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	//
	//	One of our reads (socket or file) has completed - see if we have
	//	a complete line of text terminated with CRLF and if so call our states
	//	completion function.
	//
	int		Complete(	
					IN	CSessionSocket*,
					IN CReadPacket*,
					OUT CIO*	&pio
					) ;

	//	
	//	Our shutdown function is called when the session is dropped - we don't
	//	have to do anything !
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	driver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

	inline	CBUFPTR	GetBuffer() ;
	inline  DWORD   GetBufferLen() ;
} ;

#ifndef	_NO_TEMPLATES_

typedef	CSmartPtr< CIOReadLine >	CIOREADLINEPTR ;
typedef	CSmartPtr< CIOReadArticle >	CIOREADARTICLEPTR ;
typedef	CSmartPtr< CIOGetArticle >	CIOGETARTICLEPTR ;
typedef	CSmartPtr< CIOWriteLine >	CIOWRITELINEPTR ;
typedef	CSmartPtr< CIOWriteCMD >	CIOWRITECMDPTR ;
typedef	CSmartPtr< CIOTransmit >	CIOTRANSMITPTR ;

#endif


#define	MAX_IO_SIZE		max(	sizeof( CIO ),	\
								max( max( sizeof( CIOReadArticle ), sizeof( CIOGetArticle)),	\
									max( sizeof( CIOWriteLine ),	\
										max( sizeof( CIOTransmit ) ,	\
											max( sizeof( CIOPassThru ),		\
												max( sizeof( CIOServerSSL ), sizeof( CIOReadLine ) ) ) ) ) ) )


#endif	//	_CIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\commands.h ===
/*++

	commands.h

	This file defines the various command related structures and classes.
	A command starts as a string a client sends us and which we will parse
	and create a CCmd derived object to represent.

--*/

#ifndef	_COMMANDS_H_
#define	_COMMANDS_H_

#include "isquery.h"
#include "tflist.h"

// Forward Definitions
class	CCmd ;

//
//	Constants representing the different commands -
//
typedef enum    ENMCMDIDS   {
    eAuthinfo	=0x1,
    eArticle	=0x2,
    eBody		=0x4,
    eDate		=0x8,
    eGroup		=0x10,
    eHead		=0x20,
    eHelp		=0x40,
    eIHave		=0x80,
    eLast		=0x100,
    eList		=0x200,
    eMode		=0x800,
    eNewsgroup	=0x1000,
    eNewnews	=0x2000,
    eNext		=0x4000,
    ePost		=0x8000,
	eQuit		=0x10000,
    eSlave		=0x20000,
    eStat		=0x40000,
	eXHdr		=0x80000, 
    eXOver		=0x100000,
	eXReplic	=0x200000,
	eListgroup  =0x400000,
	eSearch     =0x800000,
	eXPat		=0x1000000,
	eErrorsOnly	=0x20000000,	// Do we log errors only?  This bit controls
								// that.
	eOutPush	=0x40000000,	// Do we log outgoing push feeds ?  
								// This bit controls that !
    eUnimp		=0x80000000
}   ECMD ;

typedef	class	CIOExecute*	PIOEXECUTE ;
typedef	PIOEXECUTE	(*MAKEFUNC)(	int	argc, 
									char** argv, 
									class CExecutableCommand*&,
									struct	ClientContext&, 
									class	CIODriver&
									) ;

//
//	A table of SCmdLookup structures is used to find 
//	the write function to parse each command.
//
struct	SCmdLookup	{
	//
	//	lowercase command string
	//
	LPSTR	lpstrCmd ;

	//
	//	Function to call on match
	//
	MAKEFUNC	make;

	//
	//	Command ID - used for selective Transaction logging
	//
    ECMD    eCmd ;

	//
	//	Logon Required - must the user have a logon context
	//	before they can execute this command.
	//
	BOOL	LogonRequired ;

	//
	//	Size hint - does the command generate a lot of text 
	//	in response.  This will be used to determine how 
	//	big a buffer to allocate for the commands response.
	//	TRUE implies the command will have a large amount of 
	//	data to send.
	//
	BOOL	SizeHint ;
} ;

//
//	Utility functiosn
//
LPSTR	ConditionArgs(	int	cArgs, char **argv, BOOL fZapCommas = FALSE ) ;



//
//	The base class for all commands
//
class	CCmd	{

public : 
	//
	//	Build a CCmd derived object to handle the client request
	//
	//	NOTE: A CIOExecute*& (reference to pointer) doesn't compile on all platforms.

	friend	CIOExecute*	make( 
							int cArgs, 
							char **argv, 
							ECMD& rCmd, 
							class CExecutableCommand*& pexecute, 
							struct ClientContext& context, 
							BOOL&	fIsLargeResponse, 
							CIODriver&	driver, 
							LPSTR&	lpstrOperation 
							) ;

public :
	static	SCmdLookup	table[] ;

public :

	//
	//	Place holder functions - may be used in future with security stuff
	//
    virtual BOOL    IsValid() ;
    
} ;


class	CExecutableCommand	: public	CCmd	{
/*++

Class Description : 

	This class defines the interface that the CAcceptNNRPD 
	state machine can use to issue these commands.
	The assumption is that this command can be handled entirely
	by either a CWriteCMD or a CWriteAsyncCMD to manage the IO's

--*/

private : 
	//
	//	Nobody should be allocating memory for these !
	//
	void*	operator	new( size_t	size ) ;	// nobody is allowed to use this operator !!

public : 
	//
	//	We're destroyed through pointers - so make them virtual !
	//
	virtual	~CExecutableCommand()	{}
	//
	//	Custom allocator uses space right in ClientContext structure
	//
	inline	void	*
	operator	new(	size_t	size,	
						struct	ClientContext&	context 
						) ;
	//
	//	Do nothing delete
	//
	inline	void	
	operator	delete(	void *pv, 
						size_t size 
						) ;
	//
	//	Build the necessary CIO objects to execute the Command !
	//	If this returns FALSE we've failed, and need to drop the session !
	//
	virtual	BOOL
	StartCommand(	class	CAcceptNNRPD*	pState,
					BOOL					fIsLarge,
					class	CLogCollector*	pCollector,
					class	CSessionSocket*	pSocket, 
					class	CIODriver&		driver
					) = 0 ;
	//
	//	If there is anything the command needs to do when all of the text is sent
	//	do so when this function is called !
	//
	virtual	BOOL	
	CompleteCommand(	CSessionSocket*	pSocket,
						struct	ClientContext& 
						) ;
} ;




//
//	The base class for all commands which only send text to the client
//
class   CExecute : public CExecutableCommand	{
private :

	//
	//	Hold a temp pointer for any Child classes which may need it in their
	//	PartialExecute's.
	//
	void*	m_pv ;
public :
	//
	//	Get the first block of text to send to the client.
	//
	unsigned	FirstBuffer( BYTE*	pStart, int	cb, struct	ClientContext&	context,	BOOL	&fComplete, class CLogCollector*	pCollector ) ;

	//
	//	Get the subsequent block of text to send to the client !
	//
	unsigned	NextBuffer( BYTE*	pStart, int	cb, struct	ClientContext&	context,	BOOL	&fComplete, class CLogCollector*	pCollector ) ;

protected :
	CExecute() ;

	//
	//	Start execution - usually prints command response code
	//
    virtual int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&,	class	CLogCollector*	pCollector ) ;

	//
	//	Print body of response - derived classes should try to fill this buffer !
	//
    virtual int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context,	class	CLogCollector*	pCollector ) ;
public :

	//
	//	destructor must be virtual as derived classes
	//	are destroyed through a pointer
	//
	virtual	~CExecute()	{}
	//
	//	Issue the CIOWriteCMD that will handle our executiong !
	//
	BOOL
	StartCommand(	class	CAcceptNNRPD*	pState,
					BOOL					fIsLarge,
					class	CLogCollector*	pCollector,
					class	CSessionSocket*	pSocket, 
					class	CIODriver&		driver
					) ;
} ;


class	CAsyncExecute	: 	public	CExecutableCommand	{
/*++

Class Description : 

	This class manages commands which pend async operations to our 
	drivers !

--*/
private : 

	//
	//	friend functions that can can get to our privates !
	//
	friend	class	CIOWriteAsyncCMD ;
public : 

	CAsyncExecute() ;

	//
	//	Get the first block of text to send to the client.
	//
	virtual	class	CIOWriteAsyncComplete*		
	FirstBuffer(	BYTE*	pStart, 
					int		cb, 
					struct	ClientContext&	context,
					class CLogCollector*	pCollector 
					) = 0 ;

	//
	//	Get the subsequent block of text to send to the client !
	//
	virtual	class	CIOWriteAsyncComplete*	
	NextBuffer( 	BYTE*	pStart, 
					int		cb, 
					struct	ClientContext&	context,	
					class CLogCollector*	pCollector 
					) = 0 ;

	//
	//	Issue the CIOWriteAsyncCMD that will handle our executiong !
	//
	BOOL
	StartCommand(	class	CAcceptNNRPD*	pState,
					BOOL					fIsLarge,
					class	CLogCollector*	pCollector,
					class	CSessionSocket*	pSocket, 
					class	CIODriver&		driver
					) ;


} ;




//
//	The base class for all commands which need to issue complex IO operations !
//	(ie. CIOReadArticle)
//
class	CIOExecute : public CSessionState	{
protected :
	CIOExecute() ;
	~CIOExecute() ;

	//
	//	The Next CIOReadLine object to issue once this command completes
	//
	CIOPTR			m_pNextRead ;

	//
	//	Should we do a TransactionLog of the results ?
	//
	CLogCollector*	m_pCollector ;

public :

	//
	//	Used by CAcceptNNRPD to indicate that the object should do a TransactionLog when
	//	completed !
	//
	inline	void	DoTransactionLog(	class	CLogCollector *pCollector )	{	m_pCollector = pCollector ;	}
	
	//
	//	Used by CAcceptNNRPD to save the CIOReadLine which starts the next state
	//
	void		SaveNextIO( CIORead*	pRead ) ;

	//
	//	Used by Derived classes to get the IO should issue when complete !
	//
	CIOREADPTR	GetNextIO( ) ;

	//
	//	In error situations where we have called the Start() function 
	//
	virtual	void	TerminateIOs(	CSessionSocket*	pSocket,	CIORead*	pRead,	CIOWrite*	pWrite ) ;

	//
	//	CIOExecute states have a special way of starting up, as they may need to 
	//	pend async operations against their drivers etc...
	//
	virtual	BOOL
	StartExecute( 
				CSessionSocket* pSocket,
				CDRIVERPTR& pdriver,
				CIORead*&   pRead,
				CIOWrite*&  pWrite 
				) ;


	
} ;

#define MAX_AUTHINFO_BLOB   512

//
//	Print an error message to the client
//
class	CErrorCmd :	public	CExecute	{
private :
	//
	//	A reference to the NNTPReturn Code we should send to client !
	//
	CNntpReturn&	m_return ;
public :
	CErrorCmd(	CNntpReturn&	nntpReturn ) ;
	int	StartExecute(BYTE*	lpb,	int	cb,	BOOL	&fComplete,	void *&pv, struct	ClientContext&, class CLogCollector * ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
	BOOL	CompleteCommand(	CSessionSocket*	pSocket,	struct	ClientContext&	context ) ;
} ;

//
//	Process a Check Command !
//
class	CCheckCmd : public	CExecute	{
private : 

	//
	//	Pointer to the Message-ID we are to examine !
	//
	LPSTR	m_lpstrMessageID ;

public : 
	
	CCheckCmd(	LPSTR	lpstrMessageID ) ;
	
	static	CIOExecute*	make(	int		cArgs, 
								char	**argv, 
								class	CExecutableCommand*&,
								struct	ClientContext&,
								class	CIODriver&
								) ;

	int	StartExecute(	BYTE*	lpb,
						int		cb,
						BOOL&	fComplete, 
						void*&	pv, 
						struct	ClientContext&, 
						class CLogCollector * 
						) ;				

	int	PartialExecute(	BYTE*	lpb,
						int		cb,
						BOOL&	fComplete, 
						void*&	pv, 
						struct	ClientContext&, 
						class CLogCollector * 
						) ;				


} ;


//
//	Process an Authinfo request
//
class	CAuthinfoCmd : public	CExecute {
private :
    CAuthinfoCmd();
    AUTH_COMMAND m_authCommand;
	LPSTR	m_lpstrBlob ;

public :
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector * ) ;
    static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
} ;

//
//	Process a 'article' command
//
class	CArticleCmd :	public	CIOExecute {
protected :

	static	char	szArticleLog[] ;
	static	char	szBodyLog[]	;
	static	char	szHeadLog[] ;
	

	//
	//	The Article ID of the requested article !
	//
	ARTICLEID	m_artid ;

	//
	//	The Transmit IO operation used to send the article to the client!
	//
	CIOTransmit*	m_pTransmit ;

	//
	//	Ptr to virtual server instance - needed so we can close tsunami
	//	cache file handles.
	//
	PNNTP_SERVER_INSTANCE m_pInstance ;

	//
	//	A pointer to the newsgroup in which we found the article - only
	//	held onto so we can log later !
	//
	CGRPPTR	m_pGroup ;

	//
	//	A pointer to the command line - also used for logging !
	//
	LPSTR	m_lpstr ;

	//
	//	Length of the file 
	//
	DWORD	m_cbArticleLength ;
	
	//
	//	The FIO_CONTEXT for the handle we got from the driver !
	//
	FIO_CONTEXT*	m_pFIOContext ;

	//
	//	File offsets etc...
	//
	//	Where does the header start !
	//
	WORD		m_HeaderOffset ;

	//
	//	How long is the header ?
	//
	WORD		m_HeaderLength ;

	//
	//
	//
	CBUFPTR	m_pbuffer ;

	DWORD	m_cbOut ;	// Number of bytes in buffer to send !


	//
	//	This is the class we use for completing driver operations !
	//
	class	CArticleCmdDriverCompletion	:	public	CNntpComplete	{
	private : 
		//
		//	We hold this with a smart pointer to add a reference
		//	until the operation completes.  otherwise, the socket
		//	could shut down while we're waiting for the driver - causing problems !
		//
		CDRIVERPTR	m_pDriver ;
		//
		//	We need this socket for when the operation completes !
		//
		CSessionSocket*	m_pSocket ;
	public : 
		//
		//	The Article Id we should update the current context to if the operation succeeds !
		//
		ARTICLEID	m_ArticleIdUpdate ;
		//
		//	Standard COM - we don't do it - all of this is handled by our base class
		//
		//	AddRef()
		//	Release()
		//	QueryInterface()
		//	SetResult() 
		//

		//
		//	Initialize with two references initially - one that 
		//	we give to the driver and one for ourselves !
		//
		CArticleCmdDriverCompletion( 	CIODriver&	driver,
										CSessionSocket*	pSocket
										)	: 	m_pDriver( &driver ),
										m_pSocket( pSocket ),
										m_ArticleIdUpdate( INVALID_ARTICLEID )	{
			long	l = AddRef() ;	// Add a reference - we remove
									// this manually ourselves !
			_ASSERT( l == 2 ) ;
		}

		//
		//	Okay the last reference was dropped - do the completion work 
		//	and then die !
		//
		void
		Destroy() ;

		//
		//	This version of release doesn't call Destroy - it lets the
		//	caller do the work !
		//
		ULONG	__stdcall	SpecialRelease() ;
	} ;

	//
	//	This is the object we give to the driver to tell us when 
	//	they have barfed up a file handle for us !
	//
	CArticleCmdDriverCompletion	m_DriverCompletion ;
	friend	class	CArticleCmdDriverCompletion ;

	//
	//	The FIO_CONTEXT that the driver returns to us with the embedded handle !
	//
	FIO_CONTEXT*	m_pFileContext ;

	CArticleCmd(	PNNTP_SERVER_INSTANCE pInstance, 
					CIODriver&	driver,
					CSessionSocket*	pSocket,
					LPSTR lpstr = szArticleLog
					) : 
			m_DriverCompletion( driver, pSocket ),
			m_pTransmit( 0 ), 
			m_pInstance( pInstance ),
			m_pbuffer( 0 ), 
			m_cbOut( 0 ), 
			m_lpstr( lpstr ),
			m_pFIOContext( 0 ),
			m_HeaderOffset( 0 ),
			m_HeaderLength( 0 ),
			m_cbArticleLength( 0 )
			{}

	~CArticleCmd() ;
	
	//
	//	Figure out what CArticle we want to send to the client
	//
	BOOL	BuildTransmit( 
					LPSTR	lpstrArg,	
					char	rgchSuccess[4],	
					LPSTR	lpstrOpt, 
					DWORD	cbOpt,	
					ClientContext&	context,
					class	CIODriver&	driver 
					) ;


	static	CARTPTR	GetArticleInfo(	char*	szArg, 
									struct	ClientContext&	context, 
									ARTICLEID	&artid  
									) ;

	static	BOOL	
	GetArticleInfo(	char*		szArg, 
					CGRPPTR&	pGroup,	
					struct		ClientContext&	context, 
					char*		szBuff,	
					DWORD&		cbBuff, 
					char*		szOpt, 
					DWORD		cbOpt,
					OUT	FIO_CONTEXT*	&pContext,
					IN	CNntpComplete*	pComplete,
					OUT	WORD	&HeaderOffset,
					OUT	WORD	&HeaderLength,
					OUT	ARTICLEID	&ArticleIdUpdate
					) ;

	virtual	BOOL	GetTransferParms(	
									FIO_CONTEXT*	&pFIOContext,
									DWORD&	ibStart,
									DWORD&	cbTransfer 
									) ;

	//
	//	Start sending the article to the client
	//
	virtual	BOOL	StartTransfer(	FIO_CONTEXT*	pFIOContext,
									DWORD	ibStart,
									DWORD	cb,
									CSessionSocket*	pSocket,
									CDRIVERPTR&	pdriver,
									CIORead*&,
									CIOWrite*& 
									) ;

	//
	//	CStatCmd uses our GetArticleInfo function !
	//
	friend	class	CStatCmd ;

public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver&) ;

	//
	//	Function required for CSessionState derived objects - start issuing IO's
	//
	BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*& ) ;

	//
	//	This is the function called by CAcceptNNRPD State.
	//	We use this because we want to take care about how our 
	//	driver operation completes !
	//
	virtual	BOOL
	StartExecute( 
				CSessionSocket* pSocket,
				CDRIVERPTR& pdriver,
				CIORead*&   pRead,
				CIOWrite*&  pWrite 
				) ;


	//
	//	Regardless of whether we complete a CIOTransmit of a Write Line
	//	this will do the correct logging etc.... !
	//
	void
	InternalComplete(
				CSessionSocket*	pSocket,
				CDRIVERPTR&		pdriver,
				TRANSMIT_FILE_BUFFERS*	ptrans, 
				unsigned cbBytes 

				) ;
	//
	//	Completes the sending of an error response to the client
	//	if the store driver fails to barf up a FILE handle for us.
	//
	CIO*	
	Complete(	CIOWriteLine*,	
				CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;


	//
	//	TransmitFile Completion
	//
	CIO*	
	Complete(	CIOTransmit*	ptransmit,
				CSessionSocket*	pSocket,
				CDRIVERPTR&	pdriver, 
				TRANSMIT_FILE_BUFFERS*	ptrans, 
				unsigned cbBytes 
				) ;

						

    BOOL    IsValid( ) ;
} ;

//
//	Send the Body of an article - most work done by base class CArticleCmd
//	
class	CBodyCmd : public	CArticleCmd	{
protected : 
//	CBodyCmd(	CARTPTR&	pArticle, ARTICLEID	artid ) :
//			CArticleCmd( pArticle, artid ){}
	CBodyCmd(	PNNTP_SERVER_INSTANCE pInstance,
				CIODriver&	driver,
				CSessionSocket*	pSocket
				) : CArticleCmd( pInstance, driver, pSocket, szBodyLog ) {}

	BOOL	GetTransferParms(	FIO_CONTEXT*	&pFIOContext,	DWORD&	ibStart,	DWORD&	cbTransfer ) ;
public :
#ifdef	RETIRED
	BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*&	pWrite ) ;
#endif
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&, struct ClientContext&, class CIODriver& ) ;
} ;

//
//	Send the Head of an article - most work done by base class CArticleCmd
//
class	CHeadCmd : public CArticleCmd	{
protected : 
//	CHeadCmd(	CARTPTR&	pArticle, ARTICLEID	artid ) : 
//		CArticleCmd( pArticle, artid ) {}
	CHeadCmd(	PNNTP_SERVER_INSTANCE pInstance,
				CIODriver&	driver,
				CSessionSocket*	pSocket
				) : CArticleCmd( pInstance, driver, pSocket, szHeadLog ) {} 
	BOOL	GetTransferParms(	FIO_CONTEXT*	&pFIOContext,	DWORD&	ibStart,	DWORD&	cbTransfer ) ;
	BOOL	StartTransfer(	FIO_CONTEXT*	pFIOContext,	DWORD	ibStart,	DWORD	cb,
						CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver,	CIORead*&,	CIOWrite*& ) ;
public :

#ifdef	RETIRED
	BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*&	pWrite ) ;
#endif
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
} ;

//
//	Send Statistics regarding the article
//
class	CStatCmd : public	CExecute	{
private :
	LPSTR		m_lpstrArg ;
//	CARTPTR		m_pArticle ;
//	ARTICLEID	m_artid ;
public :
	CStatCmd(	LPSTR	lpstrArg ) ;
//	CStatCmd( CARTPTR&	pArticle,	ARTICLEID	artid ) ;
	static	CIOExecute*	make(	int	cArgs, char **argv, class CExecutableCommand*& pexecute, struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;	
} ;


//
//	Report the current date !
//	
class	CDateCmd : public CExecute {
private :
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&, struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
} ;
	
//
//	Select a group ('group' command)
//
class	CGroupCmd : public CExecute {
private :
	//
	//	The group the client wants made current
	//
    CGRPPTR    m_pGroup ;

    CGroupCmd( CGRPPTR ) ;
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver&) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;
	
//
//	Send help text to client
//	
class	CHelpCmd : public CExecute {
private :
	int	m_cbTotal ;
	static	char	szHelp[] ;
public :
	CHelpCmd() ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Select a group and return all the article-id's within the group.
//
class	CListgroupCmd : public CExecute {
private :
	//
	//	The group the client wants made current
	//
    CGRPPTR    m_pGroup ;

    //
    //  The last article id we reported to the client
    //
    ARTICLEID   m_curArticle ;

   	///
	//	Xover handle - will improve performance sometimes
	//
	HXOVER		m_hXover ;

    CListgroupCmd( CGRPPTR ) ;
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver&) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	This will adjust CClientContext to move back one article !
//	
class	CLastCmd : public CExecute {
private :
	ARTICLEID	m_artidMin ;
	CLastCmd(	ARTICLEID	artid ) : m_artidMin( artid ) {}
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Send a list of newsgroups to the client
//	
class	CListCmd : public CExecute {
protected :
	//
	//	We use the CGroupIterator to enumerate through all the appropriate newsgroups !
	//
    CGroupIterator* m_pIterator ;

    CListCmd() ;
    CListCmd( CGroupIterator*   p ) ;
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    ~CListCmd( ) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplte, void *&pv, ClientContext& context, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* ) ;
	void	GetLogStrings(	LPSTR	&lpstrTarget,	LPSTR&	lpstrParameters ) ;
} ;

class	CListNewsgroupsCmd : public	CListCmd	{
public :
	CListNewsgroupsCmd( CGroupIterator*	p ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplte, void *&pv, ClientContext& context, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* ) ;
} ;

class	CListPrettynamesCmd : public CListCmd	{
public :
	CListPrettynamesCmd( CGroupIterator*	p ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplte, void *&pv, ClientContext& context, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* ) ;
} ;

class	CListSearchableCmd : public CListCmd {
public :
    CListSearchableCmd( CGroupIterator*	p ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
};

class	CListExtensionsCmd : public CExecute {
private :
	int	m_cbTotal ;
	static char szExtensions[] ;
public :
	CListExtensionsCmd() ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Send a string to client telling them everythings fine, but do nothing otherwise
//	
class	CModeCmd : public CExecute {
private :
public :
	CModeCmd( ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;

} ;

//
//	Handle the 'slave' command
//
class	CSlaveCmd : public CErrorCmd {
private :
public :
	CSlaveCmd(	CNntpReturn&	nntpReturn ) ;
	static	CIOExecute*	make( int cArgs, char **arg, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
} ;
	
//
//	Determine which newsgroups are new !
//	
class	CNewgroupsCmd : public CExecute {
private :
	//
	//	Time specified by client
	//
	FILETIME	m_time ;

	//
	//	Iterator which will enumerate all newsgroups !
	//
	CGroupIterator*	m_pIterator ;
	CNewgroupsCmd() ;
public :
	CNewgroupsCmd( FILETIME&	time, CGroupIterator*	pIter ) ;
	~CNewgroupsCmd( ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Respond to the newnews command
//
class	CNewnewsCmd : public CExecute	{
private :
	//
	//	Time specified by client
	//
	FILETIME	m_time ;

	//
	//	Clients wildcard string
	//
	LPSTR		m_lpstrPattern ;

	//
	//	Iterator which hits only those newsgroups matching wildcard string !
	//
	CGroupIterator*	m_pIterator ;

	//
	//	Current ArticleId being processed
	//
	ARTICLEID	m_artidCurrent ;

	//
	//	Number of articles in current newsgroup which did not meet the time
	//	requirement !
	//
	DWORD		m_cMisses ;
	CNewnewsCmd() ;
public :
	CNewnewsCmd(	FILETIME&	time,	CGroupIterator*	pIter, LPSTR lpstrPattern ) ;
	~CNewnewsCmd( ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Respond to the next command - adjust current article pointer in CClientContext
//	
class	CNextCmd : public CExecute {
private :
	ARTICLEID	m_artidMax ;
	CNextCmd(	ARTICLEID artid ) : m_artidMax( artid ) {}
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* pCollector ) ;
} ;


class	CReceiveComplete : 	public	CNntpComplete	{
private : 
	class	CReceiveArticle*	GetContainer() ;
	class	CSessionSocket*	m_pSocket ;
public : 
	CReceiveComplete() : m_pSocket( 0 )	{}
	//
	//	This function is called when we start our work !
	//
	void
	StartPost(	CSessionSocket*	pSocket ) ;
	//
	//	This function gets called when the post completes !
	//
	void
	Destroy() ;
} ;


//
//	Base class for any command which sends an article to the server !
//
class	CReceiveArticle :	public	CIOExecute	{
private :
	//
	//	Our completion object is our friend !
	//
	friend	class	CReceiveComplete ;
	CReceiveArticle() ;					// Cannot use this constructor !!! - must provide string !!!
protected :
	//
	//	This tells us whether CIOReadArticle::Init has been called - in
	//	which case we must be very carefull referencing m_pFileChannel
	//	as CIOReadArticle is responsible for destroying it !
	//
	BOOL			m_fReadArticleInit ;

	//
	//	CIOWriteLine for initial response to command !
	//
	CIOWriteLine*	m_pWriteResponse ;

	//
	//	pointer to socket session driver !
	//
	CDRIVERPTR		m_pDriver ;

	//
	//	The session who owns this post command
	//
	ClientContext*	m_pContext ;

	//
	//	Number of CIO operations completed !
	//
	long			m_cCompleted ;

	//
	//	Used to determine whether our first send to 
	//	the client completed, and whether it is now o.k. to send
	//	the final response code.
	//
	long			m_cFirstSend ;

	//
	//	MULTI_SZ string which was our command line !
	//
	LPMULTISZ		m_lpstrCommand ;	// optional arguments to pSocket->m_context.m_pInFeed->fPost() ; !!

	//
	//	Flag that decides how stringent we are when we get empty articles
	//	For POSTs, we will reject the article only after receiving .CRLF.CRLF
	//	For IHave's and XReplic's, we will reject as soon as we receive a .CRLF
	//
	BOOL			m_fPartial;

	//
	//	For the InFeed to keep track of stuff !
	//
	LPVOID			m_lpvFeedContext ;

	//
	//	This is the completion object we use with the async post stuff !
	//
	CReceiveComplete	m_PostComplete ;

	//
	//	Function which gets first string we send to the client !
	//
	virtual	char*	GetPostOkString() = 0 ;

	//
	//	Return the code which we should we used when failing an illegally formatted article.
	//
	virtual	NRC		BadArticleCode()	{	return	nrcTransferFailedGiveUp ; }	

	//
	//	Function which builds the command string that is logged
	//
	virtual	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) = 0 ;

	//
	//	Function which processes command line if post exceeds soft limit !
	//
	virtual	NRC		ExceedsSoftLimit( PNNTP_SERVER_INSTANCE pInst )	{	return	nrcTransferFailedGiveUp	;	}

	//
	//	Function which indicates whether we should try to patch an article that we
	//	don't find a header in.
	//
	virtual	BOOL	FEnableNetscapeHack()	{	return	FALSE ;	}


	//
	//	Called to send the posting results to the client !
	//
	BOOL	SendResponse(	CSessionSocket*	pSocket,
							class	CIODriver&	driver, 
							CNntpReturn	&nntpReturn 
							) ;

	BOOL
	NetscapeHackPost(	CSessionSocket*	pSocket,
						CBUFPTR&	pBuffer, 
						HANDLE		hToken,
						DWORD		ibStart, 
						DWORD		cbTransfer
						) ;
	
public :
	CReceiveArticle(	LPMULTISZ	lpstrArgs, BOOL fPartial = TRUE ) ;
	~CReceiveArticle() ;

	//
	//	Called to initialize our state and create the initial CIO objects we use to 
	//	start a posting transaction with the client !
	//
	BOOL	Init(	ClientContext&, 
					class CIODriver& driver  
					) ;

	//
	//	Called when a fatal error occurs before our initial CIO objects can be 
	//	issued !
	//
	void	TerminateIOs(	
					CSessionSocket*	pSocket,	
					CIORead*	pRead,	
					CIOWrite*	pWrite 
					) ;

	//
	//	Called by the CAcceptNNRPD state after we've been
	//	constructed and wants to execute us !
	//
	BOOL
	StartExecute( 
				CSessionSocket* pSocket,
                CDRIVERPTR& pdriver,
                CIORead*&   pRead,
                CIOWrite*&  pWrite 
				) ;
	//
	//	Called by the CIODriver mechanism when we are ready to go !
	//
	BOOL	Start(	CSessionSocket*	pSocket, 
					CDRIVERPTR& pdriver, 
					CIORead*&, 
					CIOWrite*& 
					) ;

	//
	//	Called when we have completed writing a line in response to a client !
	//
	CIO*	Complete(	CIOWriteLine*,	
						class	CSessionSocket*,	
						CDRIVERPTR& 
						) ;


	//
	//	This is the signature for a read that completes
	//	entirely in memory !
	//
	CIO*
	Complete(
				class	CIOGetArticleEx*,
				class	CSessionSocket*,
				BOOL	fGoodMatch,
				CBUFPTR&	pBuffer,
				DWORD		ibStart, 
				DWORD		cb
				) ;

	//
	//	This is the completion that is called when we've 
	//	completed transferring an article to a file !
	//
	void
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) ;

	//
	//	This is the completion that is called when we've 
	//	swallowed an article that we didn't want to have !
	//
	CIO*
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*
				) ;

	//
	//	This is the completion that is called when the post
	//	to the driver finishes !
	//
	void
	Complete(	class	CSessionSocket*	pSocket,
				BOOL	fSuccess 
				) ;

	//
	//	Called when the session dies when we are receiving a posting !
	//
	void	Shutdown(	CIODriver&	driver,	
						CSessionSocket*	pSocket,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwError 
						) ;

} ;


class	CAcceptComplete : 	public	CNntpComplete	{
private : 
	class	CAcceptArticle*	GetContainer() ;
	class	CSessionSocket*	m_pSocket ;
public : 
	CAcceptComplete() : m_pSocket( 0 )	{}
	//
	//	This function is called when we start our work !
	//
	void
	StartPost(	CSessionSocket*	pSocket ) ;
	//
	//	This function gets called when the post completes !
	//
	void
	Destroy() ;
} ;


class	CAcceptArticle :	public	CIOExecute	{
private : 

	friend	class	CAcceptComplete ;
	
	CAcceptArticle() ;

protected : 
	//
	//	Command line arguments 
	//
	LPMULTISZ		m_lpstrCommand ;

	//
	//	Is this a partial receive ??
	//
	BOOL		m_fPartial ;
	//
	//	pointer to socket session driver !
	//
	CDRIVERPTR		m_pDriver ;
	//
	//	The session who owns this post command
	//
	ClientContext*	m_pContext ;
	//
	//	For the InFeed to keep track of stuff !
	//
	LPVOID			m_lpvFeedContext ;
	//
	//	The object we use to figure out when our async post completes !
	//
	CAcceptComplete	m_PostCompletion ;

	BOOL
	SendResponse(	CSessionSocket*	pSocket, 
					CIODriver&		driver, 
					CNntpReturn&	nntpReturn,
					LPCSTR			lpstrMessageId
					) ;

	virtual	BOOL	FAllowTransfer(	struct	ClientContext&	) = 0 ;

	//
	//	Return the code which we should we used when failing an illegally formatted article.
	//
	virtual	NRC		BadArticleCode()	{	return	nrcTransferFailedGiveUp ; }	

	//
	//	Function which builds the command string that is logged
	//
	virtual	DWORD	FillLogString(	BYTE*	pbCommandLog, 
									DWORD cbCommandLog 
									) = 0 ;

	//
	//	Function which processes command line if post exceeds soft limit !
	//
	virtual	NRC		ExceedsSoftLimit( PNNTP_SERVER_INSTANCE pInst )	{	return	nrcTransferFailedGiveUp	;	}

public  : 
	CAcceptArticle(	LPMULTISZ	lpstrArgs, 
					ClientContext*	pContext,
					BOOL fPartial = TRUE ) ;
	~CAcceptArticle() ;

	//
	//	Called to initialize our state and create the initial CIO objects we use to 
	//	start a posting transaction with the client !
	//
	BOOL	Init(	ClientContext&, 
					class CIODriver& driver  
					) ;

	//
	//	Called when a fatal error occurs before our initial CIO objects can be 
	//	issued !
	//
	void	TerminateIOs(	
					CSessionSocket*	pSocket,	
					CIORead*	pRead,	
					CIOWrite*	pWrite 
					) ;

	//
	//	Called by the CAcceptNNRPD state after we've been
	//	constructed and wants to execute us !
	//
	BOOL
	StartExecute( 
				CSessionSocket* pSocket,
                CDRIVERPTR& pdriver,
                CIORead*&   pRead,
                CIOWrite*&  pWrite 
				) ;
	//
	//	Called by the CIODriver mechanism when we are ready to go !
	//
	BOOL	Start(	CSessionSocket*	pSocket, 
					CDRIVERPTR& pdriver, 
					CIORead*&, 
					CIOWrite*& 
					) ;

	//
	//	Called when we have completed writing a line in response to a client !
	//
	CIO*	Complete(	CIOWriteLine*,	
						class	CSessionSocket*,	
						CDRIVERPTR& 
						) ;

	//
	//	This is the signature for a read that completes
	//	entirely in memory !
	//
	CIO*
	Complete(
				class	CIOGetArticleEx*,
				class	CSessionSocket*,
				BOOL	fGoodMatch,
				CBUFPTR&	pBuffer,
				DWORD		ibStart, 
				DWORD		cb
				) ;

	//
	//	This is the completion that is called when we've 
	//	completed transferring an article to a file !
	//
	void
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) ;

	//
	//	This is the completion that is called when we've 
	//	swallowed an article that we didn't want to have !
	//
	CIO*
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*
				) ;

	//
	//	This is the completion that is called when the post
	//	to the driver finishes !
	//
	void
	Complete(	class	CSessionSocket*	pSocket,
				BOOL	fSuccess 
				) ;

	//
	//	Called when the session dies when we are receiving a posting !
	//
	void	Shutdown(	CIODriver&	driver,	
						CSessionSocket*	pSocket,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwError 
						) ;

} ;

class	CTakethisCmd  :		public	CAcceptArticle	{
protected : 

	//
	//	Returns TRUE if we would take the posting !
	//
	BOOL	FAllowTransfer(	
					struct	ClientContext&	
					) ;

	///
	//	Error code if the article is malformed !
	//
	NRC	
	BadArticleCode()	{	
		return	nrcSArticleRejected ;	
	}

	//
	//	Error code if the article size exceeds the soft posting limit !
	//
	NRC	
	ExceedsSoftLimit()	{	
		return	nrcSArticleRejected ;	
	}

	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) ;

public : 

	//
	//	Construct a Takethis object !
	//
	CTakethisCmd(	LPMULTISZ	lpstrArgs,
					ClientContext*	pContext
					) ;

	static	CIOExecute*	make(	int		cArgs, 
								char**	argv, 
								class	CExecutableCommand*&, 
								struct	ClientContext&, 
								class	CIODriver&
								) ;
} ;


//
//	Handle Post Command
//	
class	CPostCmd : public CReceiveArticle	{
private :
protected :
	//
	//	Get String we send to clients who issue 'Post'
	//
	char*	GetPostOkString() ;
	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) ;
	NRC		ExceedsSoftLimit( )	{	return	nrcPostFailed ;	}
	BOOL	FEnableNetscapeHack()	{	return	TRUE ;	}
public :
	CPostCmd(	LPMULTISZ	lpstrArgs ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
	//BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*& ) ;

	//
	//	Return the code which we should we used when failing an illegally formatted article.
	//
	virtual	NRC		BadArticleCode()	{	return	nrcPostFailed ; }	

} ;

//
//	Handle IHAVE Command
//	bugbug ... not all implemented yet !
//
class	CIHaveCmd :	public	CReceiveArticle	{
private :
protected :
	char*	GetPostOkString() ;
	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) ;
	NRC		ExceedsSoftLimit( PNNTP_SERVER_INSTANCE pInstance ) ;
public :
	CIHaveCmd(	LPMULTISZ	lpstrCmd ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
} ;

//
//	Handle XREPLIC Command
//
class	CXReplicCmd : public	CReceiveArticle	{
private :

protected :
	char*	GetPostOkString() ;
	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) ;
	NRC		ExceedsSoftLimit( )	{	return	nrcTransferFailedGiveUp ;	}
public :
	CXReplicCmd( LPMULTISZ	lpstr ) ;
	static	CIOExecute*	make(	int	cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
	//BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*& ) ;
} ;

//
//	Handle QUIT Command
//
class	CQuitCmd : public	CExecute	{
private :
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* pCollector ) ;

	//
	//	Disconnect the socket when the write completes !
	//
	BOOL	CompleteCommand(	CSessionSocket*	pSocket,	ClientContext&	context ) ;
} ;

class   CXHdrAsyncComplete : public CIOWriteAsyncComplete {
/*++

Class Description:

    This class implements the completion object passed to drivers for XHDR
    operations !
--*/
private:

    //
    // The last article that the driver stuck into our XHDR results!
    //
    ARTICLEID   m_currentArticle;

    //
    // The requested range of articles
    //
    ARTICLEID   m_loArticle;
    ARTICLEID   m_hiArticle;

    //
    // The buffer we've asked the results be put in !
    //
    BYTE*       m_lpb;

    //
    // The size of the buffer
    //
    DWORD       m_cb;

    //
    // Keep track of how many bytes we prefix onto the response
    //
    DWORD       m_cbPrefix;

    //
    // Header key word
    //
    LPSTR       m_szHeader;

    //
    // This guy can examine and manipulate out guts
    //
    friend void
    CNewsGroup::FillBuffer(
        CSecurityCtx *,
        CEncryptCtx *,
        CXHdrAsyncComplete&
    );

    friend class CXHdrCmd;

    //
    // Can only be constructed by our friends
    //
    CXHdrAsyncComplete();

public:

    //
    // This function is called when the last reference is released !
    //
    void
    Destroy();
};

class CXHdrCmd : public CAsyncExecute {
/*++

    This class manages async XHDR operations, executed on behalf of
    clients against our async store driver interface !

--*/
private:

    //
    // These operations are not allowed
    //
    CXHdrCmd();
    CXHdrCmd( CXHdrCmd& );
    CXHdrCmd& operator=(CXHdrCmd& );

    //
    // This is the completion argument that we give to drivers
    //
    CXHdrAsyncComplete  m_Completion;

    //
    // Constructor is private, only Make can produce these guys
    //
    CXHdrCmd( CGRPPTR&  pGroup );

    //
    // The newsgroup from which we are getting the Xhdr data
    //
    CGRPPTR m_pGroup;

public:

    static CIOExecute*  make( int, char**, CExecutableCommand*&, ClientContext&, CIODriver& );
    ~CXHdrCmd();

    //
    // Get the first blob of text to send to the client
    //
    CIOWriteAsyncComplete*
    FirstBuffer(    BYTE*   pStart,
                    int     cb,
                    ClientContext&      context,
                    CLogCollector*      pCollector
                );

    //
    // Get the subsequent block of text to send to the client
    //
    CIOWriteAsyncComplete*
    NextBuffer( BYTE*   pStart,
                int     cb,
                ClientContext&  context,
                CLogCollector*  pCollector
               );
};

class	CXOverCacheWork :	public	CXoverCacheCompletion	{
private : 
	//
	//	This is embedded in an CXOverAsyncComplete object - get it !
	//
	class	CXOverAsyncComplete*	
	GetContainer() ;
	//
	//	Get the newsgroup in which this XOVER operation is being issued !
	//
	CGRPPTR&	
	GetGroup() ;
public : 

	void
	DoXover(	ARTICLEID	articleIdLow,
				ARTICLEID	articleIdHigh,
				ARTICLEID*	particleIdNext, 
				LPBYTE		lpb, 
				DWORD		cb,
				DWORD*		pcbTransfer, 
				class	CNntpComplete*	pComplete
				) ;

	//
	//	this function is called when the operation completes !
	//
	void
	Complete(	BOOL		fSuccess, 
				DWORD		cbTransferred, 
				ARTICLEID	articleIdNext
				) ;

	//
	//	Get the arguments for this XOVER operation !
	//
	void
	GetArguments(	OUT	ARTICLEID&	articleIdLow, 
					OUT	ARTICLEID&	articleIdHigh,
					OUT	ARTICLEID&	articleIdGroupHigh,
					OUT	LPBYTE&		lpbBuffer, 
					OUT	DWORD&		cbBuffer
					) ;	

	//
	//	Get only the range of articles requested for this XOVER op !
	//
	void
	GetRange(	OUT	GROUPID&	groupId,
				OUT	ARTICLEID&	articleIdLow,
				OUT	ARTICLEID&	articleIdHigh,
				OUT	ARTICLEID&	articleIdGroupHigh
				) ;
} ;

class	CXOverAsyncComplete :	public	CIOWriteAsyncComplete	{
/*++

Class	Description : 

	This class implements the completion object passed to 
	drivers for XOVER operations !

--*/
private : 

	class	CXOverCmd*	
	GetContainer() ;

	friend	class	CXOverCacheWork ;

	//
	//	The last article that the driver stuck into our XOVER results !
	//
	ARTICLEID	m_currentArticle ;

	//
	//	The requested range of articles 
	//
	ARTICLEID	m_loArticle ;
	ARTICLEID	m_hiArticle ;
	ARTICLEID	m_groupHighArticle ;

	//
	//	The buffer we've asked the results be put in !
	//
	BYTE*		m_lpb ;
	//
	//	The size of the buffer !
	//
	DWORD		m_cb ;
	//
	//	a handle to help the cache !
	//
	HXOVER		m_hXover ;
	//
	//	Keep track of how many bytes we prefix onto the response !
	//
	DWORD		m_cbPrefix ;
	//
	//	This is the item we give to the XOVER cache if we need to do 
	//	work with it !
	//
	CXOverCacheWork	m_CacheWork ;

	//
	//	This guy can examine and manipulate our guts !
	//
	friend	void	
	CNewsGroup::FillBuffer(
		class	CSecurityCtx*,
		class	CEncryptCtx*,
		class	CXOverAsyncComplete&
		) ;
		
	friend	class	CXOverCmd ;

	//
	//	Can only be constructed by our friends !
	//	
	CXOverAsyncComplete() ;
public : 
	//
	//	Get the newsgroup in which this XOVER operation is being issued !
	//
	CGRPPTR&	
	GetGroup() ;
	//
	//	This function is called when the last reference is released !
	//
	void
	Destroy() ;

} ;

class	CXOverCmd : public CAsyncExecute {
/*++

Class Description : 

	This class manages Async XOVER operations, executed
	on behalf of clients against our ASYNC Store driver 
	interface !
	
--*/
private :

	friend	class	CXOverAsyncComplete ;
	friend	class	CXOverCacheWork;

	//
	//	These operations are not allowed !
	//
	CXOverCmd() ;
	CXOverCmd( CXOverCmd& ) ;
	CXOverCmd&	operator=( CXOverCmd& ) ;

	//
	//	This is the completion argument that we give
	//	to drivers !
	//
	CXOverAsyncComplete	m_Completion ;

	//
	//	Constructor is private - only make() can produce these guys !
	//
    CXOverCmd(	CGRPPTR&	pGroup ) ;

	//
	//	The newsgroup from which we are getting the Xover data
	//
	CGRPPTR		m_pGroup ;

	//
	// A pointer to the ClientContext so the XoverCache code can
	// restart a FillBuffer
	//
	ClientContext *m_pContext;

public :
    static CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    ~CXOverCmd( ) ;

	//
	//	Get the first block of text to send to the client.
	//
	CIOWriteAsyncComplete*		
	FirstBuffer(	BYTE*	pStart, 
					int		cb, 
					struct	ClientContext&	context,
					class CLogCollector*	pCollector 
					) ;

	//
	//	Get the subsequent block of text to send to the client !
	//
	CIOWriteAsyncComplete*	
	NextBuffer( 	BYTE*	pStart, 
					int		cb, 
					struct	ClientContext&	context,	
					class CLogCollector*	pCollector 
					) ;
};

class	COverviewFmtCmd : public CExecute {
private :
    COverviewFmtCmd();

public :
    static CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    ~COverviewFmtCmd( ) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
};

 
#define MAX_SEARCH_RESULTS 9


class CSearchAsyncComplete {
private:
	ARTICLEID m_currentArticle;	// Article we're interested in
	BYTE *m_lpb;				// Pointer to the buffer
	DWORD m_cb;					// Size of the buffer
	HXOVER m_hXover;			// a handle to help the cache
	DWORD m_cbTransfer;			// Number of bytes placed in buffer
	CNntpSyncComplete *m_pComplete;
	//	
	//	This guy can examine and manipulate our guts !
	//
	friend	void	
	CNewsGroup::FillBuffer(
		class	CSecurityCtx*,
		class	CEncryptCtx*,
		class	CSearchAsyncComplete&
		) ;
		
	friend	class	CSearchCmd ;

	//
	//	Can only be constructed by our friends !
	//	
	CSearchAsyncComplete() ;
} ;


class	CSearchCmd : public CExecute {
private :
	// Not permitted:
    CSearchCmd();
    CSearchCmd(const CSearchCmd&);
    CSearchCmd& operator= (const CSearchCmd&);


	CGRPPTR m_pGroup;
	CHAR *m_pszSearchString;
	INntpDriverSearch *m_pSearch;
	INntpSearchResults *m_pSearchResults;

	int m_cResults;			// Number of results in m_pvResults
	int m_iResults;			// Next result to send.  ==cResults means get more

	WCHAR *m_pwszGroupName[MAX_SEARCH_RESULTS];
	DWORD m_pdwArticleID[MAX_SEARCH_RESULTS];

	BOOL m_fMore;
	DWORD m_cMaxSearchResults;

	struct CSearchVRootEntry {
		CSearchVRootEntry *m_pPrev;
		CSearchVRootEntry *m_pNext;
		CNNTPVRoot *m_pVRoot;
		CSearchVRootEntry(CNNTPVRoot *pVRoot) :
			m_pPrev(NULL), m_pNext(NULL),
			m_pVRoot(pVRoot) {}
	};

	
	TFList<CSearchVRootEntry> m_VRootList;
	TFList<CSearchVRootEntry>::Iterator m_VRootListIter;

	static void
	VRootCallback(void *pContext, CVRoot *pVroot);

	HRESULT GetNextSearchInterface(HANDLE hImpersonate, BOOL fAnonymous);

public :
	CSearchCmd(const CGRPPTR& pGroup, CHAR* pszSearchString);

    static CIOExecute*	
    make(
    	int cArgs,
    	char **argv,
    	class CExecutableCommand*&,
    	struct ClientContext&,
    	class CIODriver&
    	);

    ~CSearchCmd( ) ;

	int
	StartExecute(
		BYTE *lpb,
		int cb,
		BOOL &fComplete,
		void *&pv,
		ClientContext& context,
		CLogCollector*  pCollector);

	int
	PartialExecute(
		BYTE *lpb,
		int cb,
		BOOL &fComplete,
		void *&pv,
		ClientContext& context,
		CLogCollector*  pCollector);

};



class	CSearchFieldsCmd : public CExecute {
private :
    CSearchFieldsCmd();

	//
	// the current field name that we are looking at
	//
	DWORD m_iSearchField;

public :
    static CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    ~CSearchFieldsCmd( ) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
};


class CXpatAsyncComplete {
private:
	ARTICLEID m_currentArticle;	// Article we're interested in
	BYTE *m_lpb;				// Pointer to the buffer
	DWORD m_cb;					// Size of the buffer
	HXOVER m_hXover;			// a handle to help the cache
	DWORD m_cbTransfer;			// Number of bytes placed in buffer
	CNntpSyncComplete *m_pComplete;
	LPSTR m_szHeader;
	//	
	//	This guy can examine and manipulate our guts !
	//
	friend	void	
	CNewsGroup::FillBuffer(
		class	CSecurityCtx*,
		class	CEncryptCtx*,
		class	CXpatAsyncComplete&
		) ;
		
	friend class CXPatCmd;

	//
	//	Can only be constructed by our friends !
	//	
	CXpatAsyncComplete() ;
};

class CXPatCmd : public CExecute {
private:
    CXPatCmd();

	CGRPPTR m_pGroup;
	INntpDriverSearch *m_pSearch;
	INntpSearchResults *m_pSearchResults;

	int m_cResults;			// Number of results in m_pvResults
	int m_iResults;			// Next result to send.  ==cResults means get more

	BOOL m_fMore;

	WCHAR *m_pwszGroupName[MAX_SEARCH_RESULTS];
	DWORD m_pdwArticleID[MAX_SEARCH_RESULTS];

	char *m_szHeader;		// The header we are searching for
	char *m_szMessageID;	// MsgId we're searching for or NULL if ArtIDs
	DWORD m_dwLowArticleID, m_dwHighArticleID;

	int GetArticleHeader(CGRPPTR pGroup,
		DWORD iArticleID,
		char *szHeader,
		ClientContext& context,
		BYTE *lpb,
		int cb);


public:
	CXPatCmd(INntpDriverSearch *pDriverSearch, 
		INntpSearchResults *pSearchResults);

    static CIOExecute*
    make(
		int cArgs,
 		char **argv,
		class CExecutableCommand*&,
		struct ClientContext&,
		class CIODriver&);

	~CXPatCmd( ) ;

	int
	StartExecute(
		BYTE *lpb,
		int cb,
		BOOL &fComplete,
		void *&pv,
		ClientContext& context,
		class CLogCollector* pCollector);

	int
	PartialExecute(
		BYTE *lpb,
		int cb,
		BOOL &fComplete,
		void *&pv,
		ClientContext& context,
		class CLogCollector* pCollector);
};

/*
class	CXHdrCmd : public	CExecute	{
private : 

	CGRPPTR		m_pGroup ;
	ARTICLEID	m_currentArticle ;
	ARTICLEID	m_loArticle ;
	ARTICLEID	m_hiArticle ;
	LPSTR		m_szHeader ;


	CXHdrCmd( LPSTR	m_szHeader,	CGRPPTR	pGroup,	ARTICLEID	artidlow, ARTICLEID	artidhi	) ;

public : 
	static	CIOExecute*	make(	int	cArgs,	char **argv, class CExecutableCommand*&, struct ClientContext&, class CIODriver& ) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplte, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
} ;
*/
	
class	CUnimpCmd : public CExecute {
private :
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;

	int	StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct ClientContext&, class CLogCollector* pCollector ) ;
} ;



//
//	Remove all white space from constants, as some compilers
//	have problems !
//


#if 0 
#define	MAX_CEXECUTE_SIZE max(sizeof(CErrorCmd),\
max(sizeof(CAuthinfoCmd),\
max(sizeof(CListCmd),\
max(sizeof(CModeCmd),\
max(sizeof(CNewgroupsCmd),\
max(sizeof(CNextCmd),\
max(sizeof(CXOverCmd),\
sizeof( CUnimpCmd )))))))))
#else
#define	MAX_CEXECUTE_SIZE max(max(max(sizeof(CErrorCmd),\
max(sizeof(CSlaveCmd),sizeof(CAuthinfoCmd))),\
max(max(sizeof(CStatCmd),max(sizeof(CDateCmd),sizeof(CListCmd))),\
max(max(max(sizeof(CModeCmd),sizeof(CXPatCmd)),\
max(max(sizeof(CGroupCmd),sizeof(CLastCmd)),sizeof(CNewgroupsCmd))),\
max(max(sizeof(CNextCmd),sizeof(CNewnewsCmd)),\
max(max(sizeof(CHelpCmd),sizeof(CXHdrCmd)),sizeof(CXOverCmd)))))),\
max(max(sizeof(CQuitCmd),sizeof(CSearchCmd)),sizeof( CUnimpCmd )))
#endif

extern	const	unsigned	cbMAX_CEXECUTE_SIZE ;

#define	MAX_CIOEXECUTE_SIZE	max(sizeof(	CIOExecute),\
max(sizeof(CArticleCmd),max(\
max(sizeof(CBodyCmd),\
sizeof(CHeadCmd)),max(\
max(sizeof(CReceiveArticle),\
sizeof(CPostCmd)),\
max(sizeof(CIHaveCmd),\
sizeof(CXReplicCmd))))))

extern	const	unsigned	cbMAX_CIOEXECUTE_SIZE ;

extern LPMULTISZ BuildMultiszFromCommas(LPSTR lpstr);

#include    "commands.inl"
	
#endif	// _COMMANDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\cio.inl ===
inline	void*	
CIO::operator	new( size_t	size, CIODriver&	sink ) {
	Assert( size <= cbMAX_IO_SIZE ) ;

	return	sink.m_CIOCache.Alloc( size ) ;
}

inline	void
CIO::operator	delete(	void*	pv ) {
}

inline	void
CIO::Destroy( CIO*	pio, CIODriver& sink ) {
	
	_ASSERT( pio->m_refs == -1 ) ;

	delete	pio ;
	sink.m_CIOCache.Free( pio ) ;
}

inline	void
CIO::DestroySelf(	)	{
	delete	this ;
	gCIOAllocator.Release( (LPVOID)this ) ;
}

inline	long
CIO::AddRef()	{
	return	InterlockedIncrement( &m_refs ) ;
}

inline	long
CIO::RemoveRef()	{
	return	InterlockedDecrement( &m_refs ) ;
}

inline	
CIO::CIO() :
	m_refs( -1 ),
	m_pState( 0 )	{
}

inline
CIO::CIO(	CSessionState	*pState ) :
		m_refs( -1 ),
		m_pState( pState )	{
}

inline
CIORead::CIORead(	CSessionState*	pState ) :
	CIO( pState )	{
}

inline
CIOWrite::CIOWrite(	CSessionState*	pState ) :	
	CIO( pState )	{
}



inline
CBUFPTR	CIOReadLine::GetBuffer()	{
	return	m_pbuffer ;
}

inline  DWORD   CIOReadLine::GetBufferLen() {
	return (DWORD)(m_pchEndData - m_pchStartData) ;
}

inline
char*	CIOWriteLine::GetBuff( unsigned&	cbRemaining )	{

	Assert( m_pWritePacket != 0 ) ;
	Assert( m_pchStart != 0 ) ;
	Assert( m_pchEnd != 0 ) ;
	Assert( m_pchEnd >= m_pchStart ) ;
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;
	
	cbRemaining = (unsigned)(m_pchEnd - m_pchStart) ;
	return	m_pchStart ;
}

inline
void	CIOWriteLine::AddText(	unsigned	cb )	{

	Assert( cb != 0 ) ;
	Assert( m_pchStart != 0 ) ;
	Assert( m_pchEnd != 0 ) ;
	Assert(	m_pchStart <= m_pchEnd ) ;
	Assert( m_pWritePacket != 0 ) ;	
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;
	
	m_pchStart +=cb ;
	Assert( m_pchStart <= m_pchEnd ) ;
}

inline	
char*	CIOWriteLine::GetTail()	{

	Assert( m_pWritePacket != 0 ) ;
	Assert( m_pchStart != 0 ) ;
	Assert( m_pchEnd != 0 ) ;
	Assert( m_pchEnd >= m_pchStart ) ;
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;

	return	m_pchEnd ;
}

inline
void	CIOWriteLine::SetLimits(	char*	pchStart,	char*	pchEnd )	{

	Assert( pchStart != 0 ) ;
	Assert( pchEnd != 0 ) ;
	Assert( pchStart != pchEnd ) ;
	Assert(	m_pWritePacket != 0 ) ;
	Assert(	m_pchStart != 0 ) ;
	Assert(	m_pchEnd != 0 ) ;
	Assert(	m_pchEnd >= m_pchStart ) ;
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;
	Assert(	pchStart <= pchEnd ) ;
	Assert(	pchStart >= m_pchStart ) ;
	Assert(	pchEnd <= m_pchEnd );

	m_pWritePacket->m_ibStartData = (unsigned)(pchStart - &m_pWritePacket->m_pbuffer->m_rgBuff[0]) ;
	Assert( m_pWritePacket->m_ibStartData >= m_pWritePacket->m_ibStart ) ;

	m_pchStart = pchEnd ;
	m_pchEnd = m_pWritePacket->EndData() ;

}

inline
void	CIOWriteLine::Reset( )	{

	Assert( m_pWritePacket != 0 ) ;
	Assert( m_pchStart!= 0 ) ;
	Assert(	m_pchEnd != 0 ) ;
	Assert(	m_pchEnd >= m_pchStart ) ;
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;

	m_pchStart = m_pWritePacket->StartData() ;
	m_pchEnd = m_pWritePacket->End() ;
	m_pWritePacket->m_ibEndData = m_pWritePacket->m_ibStartData ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\commands.cpp ===
/*++

    commands.cpp

    This file contains the code that interprets and implements NNTP commands.

    There are two distinct categories of commands :
    Those derived from CExecute and those derived from CIOExecute.

    All that Commands derived from CExecute do are manipulate the ClientContext structure
    and send text back to the client.

    Commands derived from CIOExecute on the other hand perform more complicate operations
    such as sending or receiving files.  In fact, CIOExecute is also derived from CSessionState
    so such commands are full blown states in the session state machine.
    (Albeit, special states that will return the session to the command processing state - CAcceptNNRPD)

--*/


#include    <stdlib.h>

#define INCL_INETSRV_INCS
#include    "tigris.hxx"

#include "parse.h"

#if 0
CIOExecute* build2( int cArgs, char **argv, class CExecutableCommand*& pexecute, struct ClientContext& context) {
    return   0 ;
}
#endif

//
//  Server FAULT string - when hash tables inexplicably fail, send this
//
char    szServerFault[] = "503 Server Fault\r\n" ;

//
//	Strings that terminate NNTP postings and indicate possible error states
//	etc !
//
//	The end of the header of a message !
//
char	szBodySeparator[] = "\r\n\r\n" ;
//
//	The end of an article !
//
char	szEndArticle[] = "\r\n.\r\n" ;
//
//	Generally we may start matching in the middle
//	of szEndArticle !
//
char	*szInitial = szEndArticle + 2 ;

//
//  This table must be in alhabetical order.
//  We use this table to parse the first argument in each line the client sends us,
//  after recognizing the command, we call a 'make' function which creates the
//  appropriate command object.
//
//  In general, the make commands should do significant amounts of validation, and
//  if there are problems, return a CErrorCmd object. (which prints the right return code.)
//
SCmdLookup  CCmd::table[] = {
    {   "authinfo", (MAKEFUNC)  (CAuthinfoCmd::make),   eAuthinfo,  FALSE,  TRUE    },
    {   "article",  (MAKEFUNC)  CArticleCmd::make,      eArticle,   TRUE,   TRUE    },
    {   "body",     (MAKEFUNC)  CBodyCmd::make,         eBody,      TRUE,   TRUE    },
    {   "check",    (MAKEFUNC)  CCheckCmd::make,        eUnimp,     FALSE,  FALSE   },
    {   "date",     (MAKEFUNC)  CDateCmd::make,         eDate,      TRUE,   FALSE   },
    {   "group",    (MAKEFUNC)  CGroupCmd::make,        eGroup,     TRUE,   FALSE   },
    {   "head",     (MAKEFUNC)  CHeadCmd::make,         eHead,      TRUE,   TRUE    },
    {   "help",     (MAKEFUNC)  CHelpCmd::make,         eHelp,      FALSE,  TRUE    },
    {   "ihave",    (MAKEFUNC)  CIHaveCmd::make,        eIHave,     FALSE,  TRUE    },
    {   "last",     (MAKEFUNC)  CLastCmd::make,         eLast,      TRUE,   FALSE   },
    {   "list",     (MAKEFUNC)  CListCmd::make,         eList,      TRUE,   TRUE    },
    {   "listgroup", (MAKEFUNC) CListgroupCmd::make,    eListgroup, TRUE,   TRUE    },
    {   "mode",     (MAKEFUNC)  CModeCmd::make,         eMode,      FALSE,  FALSE   },
    {   "newgroups",(MAKEFUNC)  CNewgroupsCmd::make,    eNewsgroup, TRUE,   TRUE    },
    {   "newnews",  (MAKEFUNC)  CNewnewsCmd::make,      eNewnews,   TRUE,   TRUE    },
    {   "next",     (MAKEFUNC)  CNextCmd::make,         eNext,      TRUE,   FALSE   },
    {   "over",     (MAKEFUNC)  CXOverCmd::make,        eXOver,     TRUE,   TRUE    },
    {   "pat",      (MAKEFUNC)  CXPatCmd::make,         eXPat,      TRUE,   TRUE    },
    {   "post",     (MAKEFUNC)  CPostCmd::make,         ePost,      TRUE,   TRUE    },
    {   "quit",     (MAKEFUNC)  CQuitCmd::make,         eQuit,      FALSE,  FALSE   },
    {   "search",   (MAKEFUNC)  CSearchCmd::make,       eSearch,    TRUE,   TRUE    },
//    {   "slave",    (MAKEFUNC)  CSlaveCmd::make,        eSlave,     TRUE,   FALSE   },
    {   "stat",     (MAKEFUNC)  CStatCmd::make,         eStat,      FALSE,  FALSE   },
    {   "takethis", (MAKEFUNC)  CTakethisCmd::make,     eIHave,     FALSE,  TRUE    },
    {   "xhdr",     (MAKEFUNC)  CXHdrCmd::make,         eXHdr,      TRUE,   TRUE    },
    {   "xover",    (MAKEFUNC)  CXOverCmd::make,        eXOver,     TRUE,   TRUE    },
    {   "xpat",     (MAKEFUNC)  CXPatCmd::make,         eXPat,      TRUE,   TRUE    },
    {   "xreplic",  (MAKEFUNC)  CXReplicCmd::make,      eXReplic,   FALSE,  TRUE    },
    // must be the last entry, catches all unrecognized strings
    {   NULL,       (MAKEFUNC)  CUnimpCmd::make,        eUnimp,     FALSE,  FALSE   },
} ;

#if 0					// BUGBUG: Be sure to renumber these before reenabling them.
SCmdLookup*	rgCommandTable[26] =	{
	&CCmd::table[0],	// a
	&CCmd::table[2],	// b
	&CCmd::table[3],	// c
	&CCmd::table[4],	// d
	&CCmd::table[5],	// e
	&CCmd::table[5],	// f
	&CCmd::table[5],	// g
	&CCmd::table[6],	// h
	&CCmd::table[8],	// i
	&CCmd::table[9],	// j
	&CCmd::table[9],	// k
	&CCmd::table[9],	// l
	&CCmd::table[12],	// m
	&CCmd::table[13],	// n
	&CCmd::table[16],	// o
	&CCmd::table[17],	// p
	&CCmd::table[18],	// q
	&CCmd::table[19],	// r
	&CCmd::table[19],	// s
	&CCmd::table[22],	// t
	&CCmd::table[23],	// u
	&CCmd::table[23],	// v
	&CCmd::table[23],	// w
	&CCmd::table[23],	// x
	&CCmd::table[27],	// y
	&CCmd::table[27]	// z
} ;
#else
SCmdLookup*	rgCommandTable[26] =	{
	&CCmd::table[0],	// a
	&CCmd::table[0],	// b
	&CCmd::table[0],	// c
	&CCmd::table[0],	// d
	&CCmd::table[0],	// e
	&CCmd::table[0],	// f
	&CCmd::table[0],	// g
	&CCmd::table[0],	// h
	&CCmd::table[0],	// i
	&CCmd::table[0],	// j
	&CCmd::table[0],	// k
	&CCmd::table[0],	// l
	&CCmd::table[0],	// m
	&CCmd::table[0],	// n
	&CCmd::table[0],	// o
	&CCmd::table[0],	// p
	&CCmd::table[0],	// q
	&CCmd::table[0],	// r
	&CCmd::table[0],	// s
	&CCmd::table[0],	// t
	&CCmd::table[0],	// u
	&CCmd::table[0],	// v
	&CCmd::table[0],	// w
	&CCmd::table[0],	// x
	&CCmd::table[0],	// y
	&CCmd::table[0]		// z
} ;
#endif



BOOL
GetCommandRange(
    INT argc,
    char **argv,
    PDWORD loRange,
    PDWORD hiRange,
	NRC&	code
    );

BOOL CheckMessageID(char *szMessageID,              // in
                    struct ClientContext &context,  // in
                    GROUPID *pGroupID,              // out
                    ARTICLEID *pArticleID,          // out
                    CGRPPTR *pGroup);               // out

class   CIOExecute*
make(   int cArgs,
            char **argv,
            ECMD&   rCmd,
            CExecutableCommand*& pexecute,
            ClientContext& context,
            BOOL&   fIsLargeResponse,
            CIODriver&  driver,
            LPSTR&  lpstrOperation
            ) {
/*++

Routine Description :

    Create an appropriate command object for the command we are processing.
    To do so, we use a table of strings (CCmd::table) to recognize the first
    word of the command.  Once we've identified the command, we call another
    function to parse the rest of the line and build the appropriate objects.
    Note that the ClientContext is passed around, as the CCmd object is actually
    constructed in place in the ClientContext in most cases.  The ClientContext
    also provides us all the info on what article is currently seleceted etc...

Arguments :

    cArgs - Number of arguments on the command line
    argv -  Array of pointers to NULL terminated command line parms
    rCmd -  A parameter through which we return the command which was recognized.
    NOTE : This parameters should be retired as it is largely unused.
    pexecute - A pointer reference through which we return a pointer to a CExecute
            object if one is constructed.
    psend - A reference through which we return a CIOExecute derived object if
            one is constructed.
    fIsLargeResponse - An OUT parameter - we return a Hint to the caller of whether
            the command will generate a lot or little text to send to the client.
            This can be used when allocating buffers to get a better size.
    NOTE:   Only one of pexecute and psend will be Non Null when we return.

Return Value :

    A Pointer to a CCmd derived object.   Note that we will also return a pointer
    to either a CIOExecute or CExecute derived object through the references.
    We do this so that the caller knows what type of CCmd it is dealing with.

--*/

    //
    //  The base CCmd make function searches the CCmd::table to find the
    //  appropriate function for creating the command object !
    //

	_strlwr( argv[0] ) ;

    _ASSERT( context.m_return.fIsClear() ) ;    // No errors should be set already
    pexecute = 0 ;

	DWORD	dw= *argv[0] - 'a' ;
	if( dw > DWORD('z'-'a') ) {
		dw = DWORD('z'-'a') ;
	}
    for( SCmdLookup *pMake = rgCommandTable[dw];
            pMake->lpstrCmd != NULL;
            pMake++ ) {
        if( strcmp( pMake->lpstrCmd, argv[0] ) == 0 ) {
            break ;
        }
    }
    lpstrOperation = pMake->lpstrCmd ;
    rCmd = pMake->eCmd ;
    fIsLargeResponse = pMake->SizeHint ;

#ifndef DEVELOPER_DEBUG
    if( pMake->LogonRequired &&
        !context.m_securityCtx.IsAuthenticated() &&
        !context.m_encryptCtx.IsAuthenticated() ) {

        context.m_return.fSet( nrcLogonRequired ) ;
        pexecute = new( context )   CErrorCmd( context.m_return ) ;
        fIsLargeResponse = FALSE ;
        return  0 ;
    }
#endif
    return  pMake->make( cArgs, argv, pexecute, context, driver ) ;
}


void
SetDriverError(		CNntpReturn&	nntpret,
					ENMCMDIDS		operation,
					HRESULT			hResDriver
					)	{
/*++

Routine Description :

	This function exists to convert an NNTP Store Driver's
	failure code into meaningfull data to return to a client.

Arguments :

	nntpret - The object holding the response for the client
	operation - The Command that failed
	hResDriver - The drivers failure code

Return Value :

	None.

--*/

	switch( operation ) 	{
		case	eArticle :
		case	eBody :
		case	eHead :
			//
			//	Did the driver fail to find the article !
			//
			if( hResDriver == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) ||
				hResDriver == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) )	{
				nntpret.fSet( nrcNoSuchArticle ) ;
				break ;
			}	else	if( hResDriver == E_ACCESSDENIED ) {
				nntpret.fSet( nrcNoAccess ) ;
				break ;
			}
			//
			//	fall through into default case !
			//	

		default :
			nntpret.fSet( nrcServerFault ) ;
			break ;
	}
	//
	//	We must set some error before we exit !
	//
	_ASSERT( !nntpret.fIsClear() ) ;
}

				





#if 0
BOOL
FValidateMessageId( LPSTR   lpstrMessageId ) {
/*++

Routine Description :

    Check that the string is a legal looking message id.
    Should contain 1 @ sign and at least one none '>' character
    after that '@' sign.

Arguments :

    lpstrMessageId - Message ID to be validated.

Returns

    TRUE if it appears to be legal
    FALSE   otherwise

--*/

    int cb = lstrlen( lpstrMessageId );

    if( lpstrMessageId[0] != '<' || lpstrMessageId[cb-1] != '>' ) {
        return  FALSE ;
    }

    if( lpstrMessageId[1] == '@' )
        return  FALSE ;

    int cAtSigns = 0 ;
    for( int i=1; i<cb-2; i++ ) {
        if( lpstrMessageId[i] == '@' ) {
            cAtSigns++ ;
        }   else if( lpstrMessageId[i] == '<' || lpstrMessageId[i] == '>' ) {
            return  FALSE ;
        }   else if( isspace( (UCHAR)lpstrMessageId[i] ) ) {
            return  FALSE ;
        }
    }
    if( lpstrMessageId[i] == '<' || lpstrMessageId[i] == '>' || cAtSigns != 1 ) {
        return  FALSE ;
    }
    return  TRUE ;
}
#endif


BOOL
 CCmd::IsValid( ) {
    return  TRUE ;
}

CExecute::CExecute() : m_pv( 0 ) {
}


unsigned
CExecute::FirstBuffer(  BYTE*   pb,
                    int     cb,
                    ClientContext&  context,
                    BOOL    &fComplete,
                    CLogCollector*  pCollector )    {
/*++

Routine Description :

    Calls the derived class's StartExecute and PartialExecute functions to let them
    fill the buffer that we will send to the client.

Arguments:

    pb - The buffer to be filled
    cb - The number of bytes available in the buffer
    context - The client's context - to be passed to the derived class PartialExecute !
    fComplete - An Out parameter used to indicate whether the command has been completed !

Return Value :

    TRUE if successfull FALSE otherwise (actually, we can't fail!)

--*/

    //
    //  This function builds the first block of text we will send to the client.
    //  We will call out StartExecute() and PartialExecute() functions untill either
    //  the command is complete or our buffer is reasonably full !
    //

    _ASSERT( fComplete == FALSE ) ;

    unsigned    cbRtn = 0 ;

    _ASSERT( cb > 0 ) ;
    _ASSERT( pb != 0 ) ;

    unsigned cbOut = StartExecute( pb, cb, fComplete, m_pv, context, pCollector ) ;
    _ASSERT( cbOut <= (unsigned)cb ) ;
    while( (cb-cbOut) > 50 && !fComplete ) {
        cbOut += cbRtn = PartialExecute( pb+cbOut, cb-cbOut, fComplete, m_pv, context, pCollector ) ;
        if( cbRtn == 0 )
            break ;
        _ASSERT( cbOut <= (unsigned)cb ) ;
    }
    _ASSERT( cbOut != 0 ) ;

    return  cbOut ;
}

unsigned
CExecute::NextBuffer(   BYTE*   pb,
                    int     cb,
                    ClientContext&  context,
                    BOOL    &fComplete,
                    CLogCollector*  pCollector )    {
/*++

Routine Description :

    Calls the derived class's PartialExecute functions to let them
    fill the buffer that we will send to the client.

Arguments:

    pb - The buffer to be filled
    cb - The number of bytes available in the buffer
    context - The client's context - to be passed to the derived class PartialExecute !
    fComplete - An Out parameter used to indicate whether the command has been completed !

Return Value :

    TRUE if successfull FALSE otherwise (actually, we can't fail!)

--*/

    //
    //  This function builds the first block of text we will send to the client.
    //  We will call out StartExecute() and PartialExecute() functions untill either
    //  the command is complete or our buffer is reasonably full !
    //

    _ASSERT( fComplete == FALSE ) ;

    unsigned    cbRtn = 0 ;

    _ASSERT( cb > 0 ) ;
    _ASSERT( pb != 0 ) ;

    unsigned cbOut = PartialExecute( pb, cb, fComplete, m_pv, context, pCollector ) ;
    if( cbOut != 0 ) {
        _ASSERT( cbOut <= (unsigned)cb ) ;
        while( (cb-cbOut) > 50 && !fComplete ) {
            cbOut += cbRtn = PartialExecute( pb+cbOut, cb-cbOut, fComplete, m_pv, context, pCollector ) ;
            if( cbRtn == 0 )
                break ;
            _ASSERT( cbOut <= (unsigned)cb ) ;
        }
        _ASSERT( cbOut != 0 ) ;
    }

    return  cbOut ;
}


//
//  NOTE : The following CExecute functions are not Pure Virtual as
//  a command can get by without implementing them, as it can
//  mark the command as completed etc... before these are called.
//  All of these DebugBreak() however, so derived commands must
//  guarantee that if these are called they are overridden !!
//
int
CExecute::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL &fComplete,
                        void *&pv,
                        ClientContext& context,
                        CLogCollector*  pCollector ) {
    DebugBreak() ;
    return  0 ;
}

int
CExecute::PartialExecute( BYTE* lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext &context,
                            CLogCollector*  pCollector ) {
    DebugBreak() ;
    return  0 ;
}

BOOL
CExecutableCommand::CompleteCommand(  CSessionSocket* pSocket,
                            ClientContext&  context )   {
    _ASSERT( pSocket != 0 ) ;
    return TRUE ;
}

BOOL
CExecute::StartCommand(	class	CAcceptNNRPD*	pState,
						BOOL					fIsLarge,
						class	CLogCollector*	pCollector,
						class	CSessionSocket*	pSocket,
						class	CIODriver&		driver
						)	{
/*++

Routine Description :

	This function does the necessary work to start a command
	going.  Note that if the command requires async work, we have to
	specially handle it.

Arguments :

	pSocket - the current session
	driver - the CIODriver managing socket IO

Return Value :

	Pointer to a CIOReadLine object if appropriate !
--*/

	_ASSERT( pState != 0 ) ;
	_ASSERT( pSocket != 0 ) ;

	CIOWriteCMD*	pioWrite = new( driver )
								CIOWriteCMD(	pState,
												this,
												pSocket->m_context,
												fIsLarge,
												pCollector
												) ;
	if( pioWrite != 0 ) {
		if( !driver.SendWriteIO( pSocket, *pioWrite, TRUE ) ) {
			driver.UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
			CIO::Destroy( pioWrite, driver ) ;
			return	FALSE ;
		}
	}
	return	TRUE ;
}

CAsyncExecute::CAsyncExecute() {
/*++

Routine Description :

	Initialize for invocation by our clients.
	We setup our function pointer to point at the
	FirstBuffer() function

Args :

	None.

Return Value :

	None.

--*/
}

BOOL
CAsyncExecute::StartCommand(	
						class	CAcceptNNRPD*	pState,
						BOOL					fIsLarge,
						class	CLogCollector*	pCollector,
						class	CSessionSocket*	pSocket,
						class	CIODriver&		driver
						)	{
/*++

Routine Description :

	This function does the necessary work to start a command
	going.  Note that if the command requires async work, we have to
	specially handle it.

Arguments :

	pSocket - the current session
	driver - the CIODriver managing socket IO

Return Value :

	Pointer to a CIOReadLine object if appropriate !
--*/

	_ASSERT( pState != 0 ) ;
	_ASSERT( pSocket != 0 ) ;

	CIOWriteAsyncCMD*	pioWrite = new( driver )
								CIOWriteAsyncCMD(	
												pState,
												this,
												pSocket->m_context,
												fIsLarge,
												pCollector
												) ;
	if( pioWrite != 0 ) {
		if( !driver.SendWriteIO( pSocket, *pioWrite, TRUE ) ) {
			driver.UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
			CIO::Destroy( pioWrite, driver ) ;
			return	FALSE ;
		}
	}
	return	TRUE ;
}





CIOExecute::CIOExecute() : m_pNextRead( 0 ), m_pCollector( 0 ) {
/*++

Routine Description :

    Initializes the base CIOExecute class.

Arguments :

    None.

Return Value :

    None.

--*/
    //
    //  Constructor does nothing but make sure m_pNextRead is illegal
    //

}

CIOExecute::~CIOExecute() {
/*++

Routine Description :

    Destroy a base CIOExecute object
    We must insure that we don't leave a dangling m_pNextRead.

Arguments :

    None.

Return Value :

    None.

--*/
    //
    //  If the next read wasnt used, destroy it !
    //

//  if( m_pNextRead != 0 ) {
//      delete  m_pNextRead ;
//      m_pNextRead = 0 ;
//  }
    //  Destructor will automatically get rid of m_pNextRead

}

void
CIOExecute::SaveNextIO( CIORead*    pRead )     {
/*++

Routine Description :

    Save away a CIORead pointer for future use.

Arguemtns :

    pRead - pointer to the CIORead object that will be issued when the CIOExecute
        command completes all of its IO's.

Return Value :

    None .

--*/
    TraceFunctEnter( "CIOExecute::SaveNextIO" ) ;

    //
    //  This function saves the next IO operation to be issued when this
    //  command completes.  That will always be a CIOReadLine as we will
    //  always be returning to the CAcceptNNRPD state which will want to
    //  get the client's next command !
    //


    _ASSERT( m_pNextRead == 0 ) ;
    _ASSERT( pRead != 0 ) ;

    m_pNextRead = pRead ;

    DebugTrace( (DWORD_PTR)this, "m_pNextRead set to %x", m_pNextRead ) ;
}

CIOREADPTR
CIOExecute::GetNextIO( )    {
    /*++

Routine Description :

    Return a saved CIORead pointer.  We will only return the value once !!!
    So don't call us twice !

Arguemtns :

    None.

Return Value :

    A pointer to a CIORead derived object saved previously with SaveNextIO.

--*/

    TraceFunctEnter( "CIOExecute::GetNextIO" ) ;

    //
    //  Return the previously saved CIO object !
    //  (This function pairs with SaveNextIO())
    //

    _ASSERT( m_pNextRead != 0 ) ;
    CIOREADPTR  pRead = (CIORead*)((CIO*)m_pNextRead) ;
    m_pNextRead = 0 ;

    DebugTrace( (DWORD_PTR)this, "GetNextIO retuning %x m_pNextRead %x", pRead, m_pNextRead ) ;

    return  pRead ;
}

void
CIOExecute::TerminateIOs(   CSessionSocket* pSocket,
                            CIORead*    pRead,
                            CIOWrite*   pWrite )    {
/*++

Routine Description :

    This function is called when we have called the Start() function of
    the derived class, but an error occurs before we can issue the IO's.
    So this function is called so that the appropriate destruction or shutdown
    can be performed.

Arguments :

    pRead - The same CIO pointer returned on the call to Start().
    pWrite - The same CIO pointer returned on the call to Start().

Return Value :

    None.

--*/

    // By default - do nothing

    if( pRead != 0 )
        pRead->DestroySelf() ;

    if( pWrite != 0 )
        pWrite->DestroySelf() ;

}


BOOL
CIOExecute::StartExecute( CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite ) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //

	_ASSERT( 1==0 ) ;
	return	FALSE ;

}





CErrorCmd::CErrorCmd( CNntpReturn&  nntpReturn ) :
    m_return( nntpReturn ) {
/*++

Routine Description :

    Initializes a CErrorCmd object.

Arguemtns :

    nntpReturn - A reference to the CNntpReturn object which we are
                    returning to the client as an error.

Return Value :

    None.

--*/
    //
    //  CErrorCmd objects just send an error message to the client.
    //  We assert that the context's error field is set !!
    //

    _ASSERT( !m_return.fIsClear() ) ;

}

CIOExecute*
CErrorCmd::make(    int cArgs,
                    char **argv,
                    CExecutableCommand*&  pexecute,
                    ClientContext&  context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CErrorCmd object based on the error currently in the Client's context struct.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CErrorCmd object.

--*/
    //
    //  Build a CErrorCmd object using the ClientContext's current error !
    //

    _ASSERT( !context.m_return.fIsClear() ) ;
    CErrorCmd*  pTemp = new( context )  CErrorCmd( context.m_return ) ;
    pexecute = pTemp ;
    return  0 ;
}

int
CErrorCmd::StartExecute(    BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void*&  pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print an error message into a buffer to be sent to a client.
    We assume that we don't have to deal with getting a buffer to small to hold
    the string. (Since we are generally provided 4K buffers that better be true!)

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Attempt to print the error message into the provided buffer
    //

    _ASSERT( m_return.m_nrc != nrcNotSet ) ;
    int cbOut = _snprintf( (char*)lpb, cb, "%03d %s\r\n", m_return.m_nrc, m_return.szReturn() ) ;
    fComplete = TRUE ;

    /*
    if( pCollector != 0 ) {
        pCollector->FillLogData( LOG_TARGET, lpb, cbOut-2 ) ;
    }
    */

    context.m_nrcLast = m_return.m_nrc ;

    if( cbOut > 0 )
        return  cbOut ;
    else
        return   0 ;
}

BOOL
CErrorCmd::CompleteCommand( CSessionSocket  *pSocket,
                            ClientContext&  context ) {
/*++

Routine Description :

    Do whatever processing is necessary once we have completed all sends to a
    client related to this command. In our case, all we do is clear the current
    error code that we have a reference to.

Arguments :

    pSocket -   The socket on which we were sending.
    context -   The user's current state info.

Return Value :

    Always return TRUE.

--*/
    //
    //  When the command completes reset the ClientContext's error value
    //
    context.m_return.fSetClear() ;
    return  TRUE ;
}

CModeCmd::CModeCmd( )
    {
/*++

Routine Description :

    Initialize a CModeCmd object - we just derive from CErrorCmd and let it do
    all of the work !!


Arguments :

    nntpReturn - A nntpReturn object which will hold our response to the Mode cmd.

Return Value :

    None.

--*/
    //
    //  Mode commands do nothing but print a message, so derive from CErrorCmd !
    //
}

CCheckCmd::CCheckCmd(   LPSTR   lpstrMessageID ) :
    m_lpstrMessageID( lpstrMessageID ) {
}

CIOExecute*
CCheckCmd::make(    int cArgs,
                    char** argv,
                    CExecutableCommand*&  pexecute,
                    ClientContext&  context,
                    CIODriver&  driver
                    ) {

    InterlockedIncrementStat( (context.m_pInstance), CheckCommands );

    if( cArgs != 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
    }   else if( !context.m_pInFeed->fIsIHaveLegal() ) {
        context.m_return.fSet( nrcNoAccess ) ;
    }   else if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) ) {
        context.m_return.fSet( nrcSNotAccepting ) ;
    }   else if( !FValidateMessageId( argv[1] ) ) {
        context.m_return.fSet( nrcSAlreadyHaveIt, argv[1] ) ;
    }   else    {
        pexecute = new( context )   CCheckCmd( argv[1] ) ;
        return  0 ;
    }
    pexecute =  new( context )  CErrorCmd( context.m_return ) ;
    return   0 ;
}

int
CCheckCmd::StartExecute(    BYTE *lpb,
                            int cbLimit,
                            BOOL    &fComplete,
                            void*&pv,
                            ClientContext&  context,
                            CLogCollector*  pLogCollector
                            )   {

    static  char    szWantIt[] = "238 " ;
    static  char    szDontWantIt[] = "438 " ;

    int cbOut = sizeof( szWantIt ) - 1 ;

    pv = 0 ;

    WORD    HeaderOffset, HeaderLength ;
    ARTICLEID   ArticleId ;
    GROUPID     GroupId ;

    BOOL    fFoundArticle = FALSE ;
	BOOL	fFoundHistory = FALSE ;

	CStoreId storeid;

    if( !(fFoundArticle =
            (context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                    m_lpstrMessageID,
                                                    HeaderOffset,
                                                    HeaderLength,
                                                    ArticleId,
                                                    GroupId,
													storeid)) &&
        GetLastError() == ERROR_FILE_NOT_FOUND &&
        !(fFoundHistory = (context.m_pInstance)->HistoryTable()->SearchMapEntry( m_lpstrMessageID )) ) {

        CopyMemory( lpb, szWantIt, sizeof( szWantIt ) ) ;
        context.m_nrcLast = nrcSWantArticle ;

    }   else    {

        CopyMemory( lpb, szDontWantIt, sizeof( szDontWantIt ) ) ;
        context.m_nrcLast = nrcSAlreadyHaveIt ;

		//
		//	set dwLast so transaction logs pickup extra code !!
		//

		if( fFoundArticle ) {
			context.m_dwLast = nrcMsgIDInArticle ;
		}	else	{
			context.m_dwLast = nrcMsgIDInHistory ;
		}
    }

    int		cbMessageID = lstrlen( m_lpstrMessageID ) ;
    int		cbToCopy = min( cbLimit - cbOut - 2, cbMessageID ) ;
    CopyMemory( lpb + cbOut, m_lpstrMessageID, cbToCopy ) ;
    cbOut += cbToCopy ;
    pv = (void*)(m_lpstrMessageID + cbToCopy) ;

    if( cbToCopy == cbMessageID &&
        cbOut+2 < cbLimit ) {
        lpb[cbOut++] = '\r' ;
        lpb[cbOut++] = '\n' ;
        fComplete = TRUE ;
    }
    return  cbOut ;
}

int
CCheckCmd::PartialExecute(  BYTE    *lpb,
                            int     cbLimit,
                            BOOL&   fComplete,
                            void*&  pv,
                            ClientContext&  context,
                            CLogCollector*  pLogCollector
                            ) {

    char*   szMessageID = (char*)pv ;
    int     cbOut = 0 ;

    int		cbMessageID = lstrlen( szMessageID ) ;
    int		cbToCopy = min( cbLimit - cbOut - 2, cbMessageID ) ;
    CopyMemory( lpb + cbOut, szMessageID, cbToCopy ) ;
    cbOut += cbToCopy ;
    pv = (void*)(szMessageID + cbToCopy) ;

    if( cbToCopy == cbMessageID &&
        cbOut+2 < cbLimit ) {
        lpb[cbOut++] = '\r' ;
        lpb[cbOut++] = '\n' ;
        fComplete = TRUE ;
    }
    return  cbOut ;
}



CIOExecute*
CModeCmd::make( int cArgs,
                char** argv,
                CExecutableCommand*&  pexecute,
                ClientContext&  context,
                CIODriver&  driver ) {
/*++

Routine Description :

    Create a CModeCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CModeCmd object.

--*/


    //
    //  To create a Mode Command - set the context's error code and
    //  create a CErrorCmd() derived object !
    //

    _ASSERT( context.m_return.fIsClear() ) ;

    InterlockedIncrementStat( (context.m_pInstance), ModeCommands );

    if( cArgs == 2 ) {

        if( lstrcmpi( argv[1], "reader" ) == 0 ) {

            CModeCmd*   pTemp = new( context ) CModeCmd( ) ;
            pexecute = pTemp ;
            return  0 ;

        }   else    if( lstrcmpi( argv[1], "stream" ) == 0 ) {

            if( !context.m_pInFeed->fIsIHaveLegal() ) {
                context.m_return.fSet( nrcNotRecognized ) ;
            }   else    {
                context.m_return.fSet( nrcModeStreamSupported ) ;
            }
            pexecute = new( context )   CErrorCmd( context.m_return ) ;
            return  0 ;
        }
    }

    context.m_return.fSet( nrcNotRecognized ) ;
    pexecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

int
CModeCmd::StartExecute( BYTE *lpb,
                        int cbLimit,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pLogCollector ) {
/*++

Routine Description :

    Send the help text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cbLimit != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT(    pv == 0 ) ;

    static  char    szConnectString[] = "200 Posting Allowed\r\n" ;
    DWORD   cb = 0 ;
    char*   szConnect = 0;

    context.m_nrcLast = nrcServerReady ;


    //
    //  Figure out whether we are accepting posts right now.
    //

    if( context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) ) {

        szConnect = (context.m_pInstance)->GetPostsAllowed( cb ) ;

        //
        //  switch this context's feed object type
        //

        if( !context.m_pInFeed->fIsPostLegal() ) {

		    CompleteFeedRequest(
			    context.m_pInstance,
			    (context.m_pInFeed)->feedCompletionContext(),
			    (context.m_pInFeed)->GetSubmittedFileTime(),
                TRUE,   // CAUSE_USERTERM
			    FALSE
			    );

            delete context.m_pInFeed ;
            context.m_pInFeed = NULL ;

            context.m_pInFeed = (context.m_pInstance)->NewClientFeed();
		    if( context.m_pInFeed != 0 ) {
			    (context.m_pInFeed)->fInit(
                                        (PVOID)(context.m_pInstance)->m_pFeedblockClientPostings,
				        			    (context.m_pInstance)->m_PeerTempDirectory,
						        	    0,
							            0,
							            0,
							            TRUE,	/* Do security checks on clients */
							            TRUE,	/* allow control messages from clients */
							            (context.m_pInstance)->m_pFeedblockClientPostings->FeedId
							            );
            } else {
                _ASSERT( FALSE );
            }
        }

    }   else    {

        context.m_nrcLast = nrcServerReadyNoPosts ;
        szConnect = (context.m_pInstance)->GetPostsNotAllowed( cb ) ;

    }

    if( !szConnect )    {
        szConnect = szConnectString ;
        cb = sizeof( szConnectString ) - 1 ;
    }


    CopyMemory( lpb, szConnect, cb ) ;
    fComplete = TRUE ;

    /*
    if( pLogCollector ) {
        pLogCollector->FillLogData( LOG_TARGET, (BYTE*)szConnect, 4 ) ;
    }
    */

    return  cb ;
}


int
CModeCmd::PartialExecute(   BYTE *lpb,
                        int cbLimit,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pLogCollector ) {
/*++

Routine Description :

    Send the help text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cbLimit != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT(    pv == 0 ) ;

    //
    //  We expect StartExecute to suffice always !
    //
    _ASSERT( 1==0 ) ;


    return  0 ;
}


CSlaveCmd::CSlaveCmd(   CNntpReturn&    nntpReturn ) :
    CErrorCmd(  nntpReturn ) {
    //
    //  Slave command does nothing but send a string !
    //
}

CIOExecute*
CSlaveCmd::make(    int cArgs,
                    char**  argv,
                    CExecutableCommand*&  pexecute,
                    ClientContext&  context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CSlaveCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CSlaveCmd object.

--*/


    //
    //  Create a SLAVE command response
    //

    context.m_return.fSet( nrcSlaveStatusNoted ) ;
    pexecute = new( context ) CSlaveCmd( context.m_return ) ;
    return  0 ;
}

inline
CStatCmd::CStatCmd( LPSTR   lpstrArg ) :
    m_lpstrArg( lpstrArg )  {
}

CIOExecute*
CStatCmd::make( int cArgs,
                char** argv,
                CExecutableCommand*&  pexecute,
                ClientContext&  context,
                CIODriver&  driver ) {
/*++

Routine Description :

    Create a CStatCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CStatCmd if possible, otherwise a CErrorCmd object
    set to print the appropriate error.

--*/

    InterlockedIncrementStat( (context.m_pInstance), StatCommands );

    //
    //  Create a CStatCmd object if possible,   We use GetArticleInfo
    //  to parse most of the command line, the exact same function used
    //  by article, head, and body commands.
    //

    _ASSERT( lstrcmpi( argv[0], "stat" ) == 0 ) ;

    if( cArgs > 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
        pexecute = new( context )   CErrorCmd( context.m_return ) ;
        return  0 ;
    }
    if( cArgs == 1 ) {
        if( context.m_pCurrentGroup == 0 ) {
            context.m_return.fSet( nrcNoGroupSelected ) ;
        }   else    if( context.m_idCurrentArticle == INVALID_ARTICLEID )   {
            context.m_return.fSet( nrcNoCurArticle ) ;
        }   else    {
            pexecute = new( context )   CStatCmd( 0 ) ;
            return  0 ;
        }
    }   else    {
        if( argv[1][0] == '<' && argv[1][ lstrlen( argv[1] ) -1 ] == '>' ) {
            pexecute = new( context )   CStatCmd( argv[1] ) ;
            return  0 ;
        }   else    {
            if( context.m_pCurrentGroup == 0 ) {
                context.m_return.fSet( nrcNoGroupSelected ) ;
            }   else    {
                for( char *pchValid = argv[1]; *pchValid!=0; pchValid++ ) {
                    if( !isdigit( (UCHAR)*pchValid ) ) {
                        break ;
                    }
                }
                if( *pchValid == '\0' ) {
                    pexecute = new( context )   CStatCmd( argv[1] ) ;
                    return  0 ;
                }
            }

        }
    }
    if( context.m_return.fIsClear() ) {
        context.m_return.fSet( nrcSyntaxError ) ;
    }
    pexecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}


int
CStatCmd::StartExecute( BYTE*   lpb,
                        int cb,
                        BOOL&   fComplete,
                        void*&  pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the stat command response into the provided buffer.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Very simple StartExecute - just print a line of text.
    //

    static  char    szNotFound[] = "430 No Such Article found" ;
    static  char    szNotFoundArticleId[] = "423 no such article number in group" ;
    static  char    szStatString[] = "223 " ;

    WORD    HeaderOffset ;
    WORD    HeaderLength ;

    fComplete = TRUE ;
    int cbOut = 4 ;

    CopyMemory( lpb, szStatString, sizeof( szStatString ) ) ;

    if( m_lpstrArg != 0 && *m_lpstrArg == '<' ) {

        /*
        if( pCollector ) {
            pCollector->ReferenceLogData( LOG_TARGET, (BYTE*)m_lpstrArg ) ;
        }
        */

        ARTICLEID   articleid ;
        GROUPID groupid ;
		CStoreId storeid;

		
        if( (context.m_pInstance)->ArticleTable()->GetEntryArticleId( m_lpstrArg,
                                                        HeaderOffset,
                                                        HeaderLength,
                                                        articleid,
                                                        groupid,
														storeid) &&
            articleid != INVALID_ARTICLEID && groupid != INVALID_ARTICLEID ) {

            lstrcat( (char*)lpb, "0 " ) ;
            lstrcat( (char*)lpb, m_lpstrArg ) ;
            cbOut = lstrlen( (char*)lpb ) ;

            context.m_nrcLast = nrcHeadFollowsRequestBody ;

        }   else if( GetLastError() == ERROR_FILE_NOT_FOUND ||
                     articleid == INVALID_ARTICLEID || groupid == INVALID_ARTICLEID )   {

            context.m_nrcLast = nrcNoSuchArticle ;

            CopyMemory( lpb, szNotFound, sizeof( szNotFound ) - 1 ) ;
            cbOut = sizeof( szNotFound ) - 1 ;
        }   else    {

            context.m_nrcLast = nrcServerFault ;
            context.m_dwLast = GetLastError() ;

            CopyMemory( lpb, szServerFault, sizeof( szServerFault ) - 1 - 2 ) ;
            cbOut = sizeof( szServerFault ) - 1 - 2 ;
        }
    }   else    {
        ARTICLEID   artid = context.m_idCurrentArticle ;
        if( m_lpstrArg == 0 ) {

            _itoa( context.m_idCurrentArticle, (char*)lpb+sizeof( szStatString ) - 1, 10 ) ;

        }   else    {
            artid = atoi( m_lpstrArg ) ;
            _itoa( artid, (char*)lpb+sizeof( szStatString ) - 1, 10 ) ;

        }
        lstrcat( (char*)lpb+sizeof( szStatString ), " " ) ;

        DWORD   cbConsumed = lstrlen( (char*)lpb ) ;
        DWORD   cbUsed = cb - cbConsumed ;
        BOOL        fPrimary ;
        FILETIME    filetime ;
		DWORD		cStoreId = 0;
        if( (context.m_pInstance)->XoverTable()->ExtractNovEntryInfo(
                        context.m_pCurrentGroup->GetGroupId(),
                        artid,
                        fPrimary,
                        HeaderOffset,
                        HeaderLength,
                        &filetime,
                        cbUsed,
                        (char*)lpb+cbConsumed,
						cStoreId,
						NULL,
						NULL) ) {

            cbOut = (int)   (cbUsed + cbConsumed) ;
            context.m_idCurrentArticle = artid ;

            /*
            if( pCollector ) {
                pCollector->FillLogData(    LOG_TARGET, lpb+cbConsumed, cbUsed ) ;
            }
            */

            context.m_nrcLast = nrcHeadFollowsRequestBody ;

        }   else if( GetLastError() == ERROR_FILE_NOT_FOUND )   {

            context.m_nrcLast = nrcNoArticleNumber ;

            CopyMemory( lpb, szNotFoundArticleId, sizeof( szNotFoundArticleId ) - 1 ) ;
            cbOut = sizeof( szNotFoundArticleId ) - 1 ;

        }   else    {

            context.m_nrcLast = nrcServerFault ;
            context.m_dwLast = GetLastError() ;

            CopyMemory( lpb, szServerFault, sizeof( szServerFault ) - 1 ) ;
            cbOut = sizeof( szServerFault ) - 1 ;

        }
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData(    LOG_PARAMETERS, lpb, 4 ) ;
    }
    */

    lpb[cbOut++] = '\r' ;
    lpb[cbOut++] = '\n' ;
    return  cbOut ;
}


char    CArticleCmd::szArticleLog[] = "article" ;
char    CArticleCmd::szBodyLog[] = "body";
char    CArticleCmd::szHeadLog[] = "head" ;


BOOL
CArticleCmd::GetTransferParms(
                        FIO_CONTEXT*	&pFIOContext,
                        DWORD&  ibStart,
                        DWORD&  cbLength ) {


    if( m_pFIOContext != 0 ) {
        pFIOContext = m_pFIOContext ;
        ibStart = m_HeaderOffset ;
        cbLength = m_cbArticleLength ;

        return  TRUE ;
    }
    return  FALSE ;
}


BOOL
CArticleCmd::StartTransfer( FIO_CONTEXT*	pFIOContext,          // File to transmit from
                            DWORD   ibStart,        // Starting offset within file
                            DWORD   cbLength,       // Number of bytes from file to send
                            CSessionSocket* pSocket,// Socket on which to send
                            CDRIVERPTR& pdriver,    // CIODriver object used by socket
                            CIORead*&   pRead,      // Next CIO derived read object
                            CIOWrite*&  pWrite ) {  // Next CIO derived write object to issue
    //
    //  This function is used to start sending an article requested by a client to
    //  the client.  We may be called from derived command objects for the Head and
    //  Body commands - so we have arguments for selecting the portion of the file
    //  to be transmitted.
    //
    if( m_pTransmit->Init(  pdriver, pFIOContext, ibStart, cbLength, m_pbuffer, 0, m_cbOut ) ) {
        pWrite = m_pTransmit ;
        return  TRUE ;
    }
    return  FALSE ;
}

BOOL
CArticleCmd::Start( CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite ) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //

	FIO_CONTEXT*	pFIOContext = 0 ;
    DWORD   ibStart ;
    DWORD   cbLength ;

    if( GetTransferParms( pFIOContext, ibStart, cbLength ) ) {
		_ASSERT( pFIOContext != 0 ) ;
		_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
        return  StartTransfer( pFIOContext, ibStart, cbLength, pSocket, pdriver, pRead, pWrite ) ;
    }
    return  FALSE ;
}

BOOL
CArticleCmd::StartExecute( CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite ) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //
	m_DriverCompletion.Release() ;
	return	TRUE ;
}



void
CArticleCmd::CArticleCmdDriverCompletion::Destroy()	{
/*++

Routine Description :

	This is called when the last reference to the Article Command Completion
	object is released - meaning that we can now issue an IO !

Arguments :

	None.

Return Value :

	None.

--*/

	CIORead*	pRead = 0 ;

	//
	//	Okay do our work !
	//
	CArticleCmd*	pCmd = (CArticleCmd*)(((BYTE*)this) - ((BYTE*)&(((CArticleCmd*)0)->m_DriverCompletion))) ;
	if(		SUCCEEDED(GetResult()) &&
			pCmd->m_pFIOContext != 0 &&
			pCmd->m_pFIOContext->m_hFile != INVALID_HANDLE_VALUE 	) {

		//
		//	Everything should have worked, so update the Current Article Pointer for the session !
		//
		if( m_ArticleIdUpdate != INVALID_ARTICLEID )
			m_pSocket->m_context.m_idCurrentArticle = m_ArticleIdUpdate ;

		DWORD	cbHigh = 0 ;
		pCmd->m_cbArticleLength = GetFileSizeFromContext( pCmd->m_pFIOContext, &cbHigh ) ;
		if (pCmd->m_HeaderLength == 0) {
		    pCmd->m_HeaderLength = (WORD)pCmd->m_pFIOContext->m_dwHeaderLength;
		    _ASSERT(pCmd->m_HeaderLength != 0);
		}
		_ASSERT( cbHigh == 0 ) ;

		CIOWrite*	pWrite = 0 ;
		//
		//	Start things up !
		//
		if( pCmd->Start(	m_pSocket,
							m_pDriver,
							pRead,
							pWrite
							) )	{
			_ASSERT( pRead == 0 ) ;
			if( m_pDriver->SendWriteIO( m_pSocket, *pWrite, TRUE ) )	{
				//
				//	Everything worked out with gravy - this is our best result !
				//	
				return ;
			}	else	{
				//
				//	KILL the session !
				//
				m_pDriver->UnsafeClose(	m_pSocket, CAUSE_UNKNOWN, 0 ) ;
				pCmd->TerminateIOs( m_pSocket, pRead, pWrite ) ;
				pRead = 0 ;
				return ;
			}
		}	else	{

			//
			//	This is a failure that should tear down the session - everything
			//	looked like it was going to be perfect, we must have run out
			//	of memory or something ugly!
			//	pCmd->Start() should clean up any CIO objects !
			//
			_ASSERT( 	pRead == 0 ) ;
			_ASSERT(	pWrite == 0 ) ;
			//
			//	Fall through to error case !
			//
		}

	}	else	{
		//
		//	Need to send a failure of some sort  - the Store DRIVER failed us,
		//	so we need to send a reasonable error to the client !
		//	We also need to clean up the objects we made with the hope of
		//	being able to send the article to the client !
		//

		//
		//	Setup the context's CNntpReturn structure with our failure code !
		//
		SetDriverError( m_pSocket->m_context.m_return, eArticle, GetResult() ) ;
		m_pSocket->m_context.m_dwLast = GetResult() ;

		//
		//	This buffer was allocated to hold some transmit file stuff - instead
		//	it gets our error code !
		//
		_ASSERT( pCmd->m_pbuffer != 0 ) ;
		pCmd->m_pbuffer = 0 ;
		m_pSocket->m_context.m_nrcLast = m_pSocket->m_context.m_return.m_nrc;

		//
		//	Well now build a CIOWriteLine to send to the client !
		//
		CIOWriteLine*	pWriteLine = new( *m_pDriver ) CIOWriteLine( pCmd ) ;

		//
		//	Now evaluate pWriteLine !
		//
		if( pWriteLine ) {
			CDRIVERPTR	pDriver = m_pDriver ;

			if( pWriteLine->InitBuffers( pDriver, 400 ) ) {

				unsigned	cbLimit =  0;
				char*	pch = pWriteLine->GetBuff( cbLimit ) ;
				int	cbOut = _snprintf(	pch,
										cbLimit,
										"%03d %s\r\n",
										m_pSocket->m_context.m_return.m_nrc,
										m_pSocket->m_context.m_return.szReturn()
										) ;


				//
				//	We should be using strings that fit in our smallest buffers !
				//
				_ASSERT( cbOut < 400 ) ;

				pWriteLine->AddText(	cbOut ) ;

				if( m_pDriver->SendWriteIO( m_pSocket, *pWriteLine, TRUE ) )	{
					//
					//	Well there were problems, but we sent something to the client !
					//	
					//
					//	Now destroy this stuff - we do it here so that if the m_pTransmit holds
					//	our last reference we don't get blown up before we can send an error message
					//	(if we successfully send an error message our last ref goes away!)
					//
					_ASSERT( pCmd->m_pTransmit != 0 ) ;
					CIO::Destroy( pCmd->m_pTransmit, *m_pDriver ) ;	//bugbug this line should move !
					return ;
				}	else	{
					//
					//	KILL the session !
					//
					m_pDriver->UnsafeClose(	m_pSocket, CAUSE_UNKNOWN, 0 ) ;
					pCmd->TerminateIOs( m_pSocket, pRead, pWriteLine ) ;
					pRead = 0 ;
					return ;
				}
			}
		}
	}


	//
	//	Now destroy this stuff - we do it here so that if the m_pTransmit holds
	//	our last reference we don't get blown up before we can send an error message
	//	(if we successfully send an error message our last ref goes away!)
	//
	_ASSERT( pCmd->m_pTransmit != 0 ) ;
	CIO::Destroy( pCmd->m_pTransmit, *m_pDriver ) ;
	
	//
	//	KILL the session !
	//
	m_pDriver->UnsafeClose(	m_pSocket, CAUSE_UNKNOWN, 0 ) ;

	m_pSocket = 0 ;


}


void
CArticleCmd::InternalComplete(
                        CSessionSocket* pSocket,
                        CDRIVERPTR& pdriver,
                        TRANSMIT_FILE_BUFFERS*  pbuffers,
                        unsigned cbBytes
						) {
/*++

Routine description :

	Handle the completion and error logging of either a TransmitFile
	or Write to the client !

Arguments :

	pSocket - our socket
	pdriver - the driver handling our IO's

Return's :

	Nothing

--*/

    //
    //  Issue the next Read IO - should return us to CAcceptNNRPD state.
    //

    TraceFunctEnter( "CArticleCmd::InternalComplete" ) ;

    _ASSERT( m_pGroup != 0 ) ;
    _ASSERT( m_lpstr != 0 ) ;


    if( m_pCollector != 0 ) {

        /*
        m_pCollector->ReferenceLogData( LOG_OPERATION, (BYTE*)m_lpstr ) ;
        */

		if(	pbuffers ) {

	        unsigned    cb = 0 ;

	        _ASSERT(pbuffers->Head != 0 ) ;

	   	    LPSTR   lpstr = (LPSTR)pbuffers->Head ;
	        lpstr[ pbuffers->HeadLength - 2 ] = '\0' ;
	        m_pCollector->ReferenceLogData( LOG_TARGET, (BYTE*)lpstr+4 ) ;

	        ASSIGNI( m_pCollector->m_cbBytesSent, cbBytes );
		}	
   	    pSocket->TransactionLog( m_pCollector, pSocket->m_context.m_nrcLast, pSocket->m_context.m_dwLast ) ;
    }


    CIOREADPTR  pio = GetNextIO() ;
    _ASSERT( pio != 0 ) ;
	pSocket->m_context.m_return.fSetClear() ;
    pdriver->SendReadIO( pSocket, *pio,    TRUE ) ;
}


CIO*
CArticleCmd::Complete(	CIOWriteLine*	pioWriteLine,	
						CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver
						) {

	InternalComplete( pSocket, pdriver, 0, 0 ) ;
	return	0 ;
}


CIO*
CArticleCmd::Complete(  CIOTransmit*    ptransmit,
                        CSessionSocket* pSocket,
                        CDRIVERPTR& pdriver,
                        TRANSMIT_FILE_BUFFERS*  pbuffers,
                        unsigned cbBytes
						) {

    //
    //  Issue the next Read IO - should return us to CAcceptNNRPD state.
    //

    TraceFunctEnter( "CArticleCmd::Complete CIOTransmit" ) ;

    _ASSERT( m_pGroup != 0 ) ;
    _ASSERT( m_lpstr != 0 ) ;

	InternalComplete( pSocket, pdriver, pbuffers, cbBytes ) ;

    return   0 ;
}

BOOL
CArticleCmd::GetArticleInfo(    char    	*szArg,
                                CGRPPTR&    pGroup,
                                struct  ClientContext&  context,
                                char    	*szBuff,
                                DWORD   	&cbBuff,
                                char    	*szOpt,
                                DWORD   	cbOpt,
                                OUT FIO_CONTEXT*	&pContext,
								IN	CNntpComplete*	pComplete,
                                OUT WORD    &HeaderOffset,
                                OUT WORD    &HeaderLength,
								OUT	ARTICLEID	&ArticleIdUpdate
                                ) {
/*++

Routine Description :

    This function gets all the information we need to respond to an
    article, head or body command.  We generate the response strings,
    as well as get the necessary file handles etc...

Arguments :


Return  Value :

    TRUE if successfull, FALSE otherwise !
    If we fail the m_return object within the ClientContext will be set
    to an appropriate error message !

--*/
    //
    //  This function attempts to parse a command line sent by a client
    //  and determine what article they wish to retrieve.
    //  If we can get the article we will return a pointer to it,
    //  otherwise we will set the context's error code to something
    //  sensible.
    //

    TraceQuietEnter("CArticleCmd::GetArticleInfo");

    ARTICLEID   artid ;
    GROUPID     groupid ;
    DWORD       cbOut = 0 ;

	ArticleIdUpdate = INVALID_ARTICLEID ;

    if( szArg == 0 ) {
        pGroup = context.m_pCurrentGroup ;
        artid = context.m_idCurrentArticle ;
    }   else    {
        if( szArg[0] == '<' && szArg[ lstrlen( szArg ) -1 ] == '>' ) {

			CStoreId storeid;

            if( (context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                            szArg,
                                                            HeaderOffset,
                                                            HeaderLength,
                                                            artid,
                                                            groupid,
															storeid
															) &&
                artid != INVALID_ARTICLEID && groupid != INVALID_ARTICLEID ) {
                _ASSERT( artid != INVALID_ARTICLEID ) ;
                pGroup = (context.m_pInstance)->GetTree()->GetGroupById(
                                                            groupid
                                                            ) ;

                if(pGroup == 0) {
                    // this article belongs to a deleted group
                    context.m_return.fSet( nrcNoSuchArticle ) ;
                    return 0 ;
                }

                if( !pGroup->IsGroupAccessible( context.m_securityCtx,
                								context.m_encryptCtx,
                                                context.m_IsSecureConnection,
                                                FALSE,
                                                TRUE ) )   {
                    context.m_return.fSet( nrcNoAccess ) ;
                    return 0 ;
                }

                //cbOut = _snprintf( szBuff, cbBuff, "%s\r\n", szArg ) ;
                if( ((cbOut = lstrlen( szArg )) + 2)+cbOpt > (DWORD)cbBuff )        {
                    context.m_return.fSet( nrcServerFault ) ;
                    return 0 ;
                }

                CopyMemory( szBuff, szOpt, cbOpt ) ;
                CopyMemory( szBuff+cbOpt, szArg, cbOut ) ;
                szBuff[cbOpt+cbOut++] = '\r' ;
                szBuff[cbOpt+cbOut++] = '\n' ;

                //
                //  Note - do not cache articles we get for SSL connections
                //  as our async IO code can't reuse the file handles !
                //

				pGroup->GetArticle(	
									artid,
									0,
									INVALID_ARTICLEID,
									storeid,
									&context.m_securityCtx,
									&context.m_encryptCtx,
									TRUE,
									pContext,
									pComplete
									) ;

                cbBuff = cbOut + cbOpt ;
                return  TRUE ;
            }   else if( GetLastError() == ERROR_FILE_NOT_FOUND ||
                         artid == INVALID_ARTICLEID || groupid == INVALID_ARTICLEID )   {
                ErrorTrace(0,"Not in article table5");
                context.m_return.fSet( nrcNoSuchArticle ) ;
                return   FALSE ;
            }   else    {
                ErrorTrace(0,"Hash Table failure %x", GetLastError() );
                context.m_return.fSet( nrcServerFault ) ;
                return   FALSE ;
            }
        }   else    {

			artid = 0 ;
            for( char *pchValid = szArg; *pchValid != 0; pchValid ++ )  {
                if( !isdigit( (UCHAR)*pchValid ) ) {
                    context.m_return.fSet( nrcSyntaxError ) ;
                    return  FALSE ;
                }	else	{
					artid = 10 * artid + (*pchValid - '0') ;
				}
            }

            if( context.m_pCurrentGroup == 0 ) {
                context.m_return.fSet( nrcNoGroupSelected ) ;
                return  FALSE ;
            }

            pGroup = context.m_pCurrentGroup ;
            //artid = atoi( szArg ) ;
        }

    }
    if( pGroup != 0 ) {
        //
        //  Check that the artid is in a valid range for this newsgroup !
        //
        if( artid >= context.m_pCurrentGroup->GetFirstArticle() &&
            artid <= context.m_pCurrentGroup->GetLastArticle() ) {

            _itoa( artid, szBuff, 10 ) ;
            DWORD   cbOut = lstrlen( szBuff ) ;
            szBuff[ cbOut++ ] = ' ' ;
            DWORD   cbConsumed = cbBuff - cbOut - 1 ; // Reserve Room for NULL Terminator !

            GROUPID groupIdCurrent = context.m_pCurrentGroup->GetGroupId() ;
            GROUPID groupIdPrimary ;
            ARTICLEID   artidPrimary ;
			CStoreId storeid;

            if( (context.m_pInstance)->XoverTable()->GetPrimaryArticle(
                                            groupIdCurrent,
                                            artid,
                                            groupIdPrimary,
                                            artidPrimary,
                                            cbConsumed,
                                            szBuff + cbOut,
                                            cbConsumed,
                                            HeaderOffset,
                                            HeaderLength,
											storeid
                                            ) ) {

                if( groupIdCurrent != groupIdPrimary ) {

                    pGroup = context.m_pInstance->GetTree()->GetGroupById( groupIdPrimary ) ;

                }

                cbOut += cbConsumed ;
                szBuff[ cbOut ++ ] = '\r' ;
                szBuff[ cbOut ++ ] = '\n' ;
                cbBuff = cbOut ;

                //
                //  Let's try to get the actual CArticle object !! -
                //  Note don't cache articles for SSL sessions as our
                //  IO code can't re-use file handles
                //
                if( pGroup != 0 ) {

					//                    context.m_idCurrentArticle = artid ;	// this should only be done on a successfull completion !
					ArticleIdUpdate = artid ;
					pGroup->GetArticle(	
									artidPrimary,
									context.m_pCurrentGroup,
									artid,
									storeid,
									&context.m_securityCtx,
									&context.m_encryptCtx,
									TRUE,
									pContext,
									pComplete
									) ;

                }   else    {
                    ErrorTrace(0,"Not in article table6");
                    context.m_return.fSet( nrcNoArticleNumber ) ;
                    return  FALSE ;
                }
                return  TRUE ;
            }   else if( GetLastError() == ERROR_FILE_NOT_FOUND )   {

                ErrorTrace(0,"Not in article table7");
                context.m_return.fSet( nrcNoArticleNumber ) ;

            }   else    {

                ErrorTrace(0, "Hash table failure %x", GetLastError() ) ;
                context.m_return.fSet( nrcServerFault ) ;

            }
        }   else    {
			if (artid == INVALID_ARTICLEID) {
				context.m_return.fSet(nrcNoCurArticle);
			} else {
				context.m_return.fSet( nrcNoArticleNumber ) ;
			}
        }
    }   else    {
        context.m_return.fSet( nrcNoGroupSelected ) ;
    }
    if( context.m_return.fIsClear() )
        context.m_return.fSet( nrcServerFault ) ;
    return  FALSE ;
}

CIOExecute*
CArticleCmd::make(  int cArgs,
                    char **argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    CIODriver&  driver
					) {
/*++

Routine Description :

    Create a CArticleCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CArticleCmd if possible, otherwise a CErrorCmd object
    set to print the appropriate error.

--*/


    //
    //  Create a CArticleCmd object - GetArticleInfo does most of the work
    //

    _ASSERT( lstrcmpi( argv[0], "article" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    static  char    szOpt[] = "0 article " ;


	//
	//	Hack to get the CSessionSocket object
	//
	CSessionSocket*	pSocket = 	(CSessionSocket*)(((BYTE*)(&context)) - ((BYTE*)&((CSessionSocket*)0)->m_context)) ;

    CArticleCmd* pArtCmd = new  CArticleCmd(context.m_pInstance, driver, pSocket) ;

    InterlockedIncrementStat( (context.m_pInstance), ArticleCommands );

    if( pArtCmd != 0 ) {

		static	char	szCode[4] = { '2', '2', '0', ' ' } ;

        if( !pArtCmd->BuildTransmit(    argv[1], "220 ", szOpt, sizeof( szOpt ) - 1, context, driver ) ) {
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0 ;
        }

        context.m_nrcLast = nrcArticleFollows ;

        return  pArtCmd ;
    }

    context.m_return.fSet( nrcServerFault ) ;
    pExecute =  new( context )  CErrorCmd( context.m_return ) ;
    return  0 ;
}

CArticleCmd::~CArticleCmd() {

    //
    //  the virtual server instance is obtained in the constructor !
    //
    //m_pInstance->NNTPCloseHandle(   m_hArticleFile, m_pArticleFileInfo ) ;

	if( m_pFIOContext ) {
		ReleaseContext( m_pFIOContext ) ;
	}

}

BOOL
CArticleCmd::BuildTransmit( LPSTR   lpstrArg,
                            char	rgchSuccess[4],
                            LPSTR   lpstrOpt,
                            DWORD   cbOpt,
                            ClientContext&  context,
                            class   CIODriver&  driver ) {

    _ASSERT( m_pTransmit == 0 ) ;

    m_pTransmit = new( driver ) CIOTransmit( this ) ;

    if( m_pTransmit != 0 ) {

        m_pbuffer = driver.AllocateBuffer( 4000 ) ;
        DWORD   cbTotal = m_pbuffer->m_cbTotal ;

        if( m_pbuffer != 0 )    {

            //lstrcpy( &m_pbuffer->m_rgBuff[0], lpstrSuccess ) ;
            //m_cbOut = lstrlen( lpstrSuccess ) ;
                        CopyMemory( &m_pbuffer->m_rgBuff[0], rgchSuccess, 4 ) ;
                        m_cbOut = 4 ;
            cbTotal -= m_cbOut ;

            _ASSERT( m_pbuffer->m_rgBuff[m_cbOut -1] == ' ' ) ;

            if( GetArticleInfo( lpstrArg,
                                m_pGroup,
                                context,
                                m_pbuffer->m_rgBuff + 4,
                                cbTotal,
                                lpstrOpt,
                                cbOpt,
                                //m_hArticleFile,
                                //m_pArticleFileInfo,
								m_pFIOContext,
								&m_DriverCompletion,
                                m_HeaderOffset,
                                m_HeaderLength,
								m_DriverCompletion.m_ArticleIdUpdate
                                ) ) {
                m_cbOut += cbTotal ;
                return  TRUE ;
            }
        }
    }
    if( context.m_return.fIsClear() ) {
        context.m_return.fSet( nrcServerFault ) ;
    }
    if( m_pTransmit )
        CIO::Destroy( m_pTransmit, driver ) ;
                                // CIOTransmit has reference to us and will
                                // destroy us when destroyed - no need for clean up
                                // by caller !
    return  FALSE ;
}

CIOExecute*
CHeadCmd::make( int cArgs,
                    char **argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CHeadCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CHeadCmd if possible, otherwise a CErrorCmd object
    set to print the appropriate error.

--*/


    //
    //  Create a CArticleCmd object - GetArticleInfo does most of the work
    //

    _ASSERT( lstrcmpi( argv[0], "head" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    static  char    szOpt[] = "0 head " ;
	//
	//	Hack to get the CSessionSocket object
	//
	CSessionSocket*	pSocket = 	(CSessionSocket*)(((BYTE*)(&context)) - ((BYTE*)&((CSessionSocket*)0)->m_context)) ;

    CHeadCmd* pHeadCmd = new    CHeadCmd(context.m_pInstance, driver, pSocket) ;

    if( pHeadCmd != 0 ) {

		static	char	szCode[4] = { '2', '2', '1' , ' ' } ;

        if( !pHeadCmd->BuildTransmit(   argv[1], "221 ", szOpt, sizeof( szOpt ) - 1, context, driver ) ) {
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0 ;
        }

        context.m_nrcLast = nrcHeadFollows ;

        return  pHeadCmd ;
    }

    context.m_return.fSet( nrcServerFault ) ;
    pExecute =  new( context )  CErrorCmd( context.m_return ) ;
    return  0 ;
}

BOOL
CHeadCmd::StartTransfer(    FIO_CONTEXT*	pFIOContext,          // File to transmit from
                            DWORD   ibStart,        // Starting offset within file
                            DWORD   cbLength,       // Number of bytes from file to send
                            CSessionSocket* pSocket,// Socket on which to send
                            CDRIVERPTR& pdriver,    // CIODriver object used by socket
                            CIORead*&   pRead,      // Next CIO derived read object
                            CIOWrite*&  pWrite ) {  // Next CIO derived write object to issue
    //
    //  This function is used to start sending an article requested by a client to
    //  the client.  We may be called from derived command objects for the Head and
    //  Body commands - so we have arguments for selecting the portion of the file
    //  to be transmitted.
    //
    if( m_pTransmit->Init(  pdriver, pFIOContext, ibStart, cbLength, m_pbuffer, 0, m_cbOut ) ) {

        static  char    szTail[] = ".\r\n" ;
        CopyMemory( &m_pbuffer->m_rgBuff[m_cbOut], szTail, sizeof( szTail ) -1 ) ;
        m_pTransmit->AddTailText( sizeof( szTail ) - 1 ) ;
        pWrite = m_pTransmit ;
        return  TRUE ;
    }
    return  FALSE ;
}

BOOL
CHeadCmd::GetTransferParms(
                        FIO_CONTEXT*	&pFIOContext,
                        DWORD&      ibOffset,
                        DWORD&      cbLength ) {

	if( m_pFIOContext != 0 ) {

        pFIOContext = m_pFIOContext ;
        ibOffset = m_HeaderOffset ;
        cbLength = m_HeaderLength ;

        return  TRUE ;

    }
    return  FALSE ;
}


CIOExecute*
CBodyCmd::make( int cArgs,
                    char **argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CStatCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CBodyCmd if possible, otherwise a CErrorCmd object
    set to print the appropriate error.

--*/


    //
    //  Create a CArticleCmd object - GetArticleInfo does most of the work
    //

    _ASSERT( lstrcmpi( argv[0], "body" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    static  char    szOpt[] = "0 body " ;
	//
	//	Hack to get the CSessionSocket object
	//
	CSessionSocket*	pSocket = 	(CSessionSocket*)(((BYTE*)(&context)) - ((BYTE*)&((CSessionSocket*)0)->m_context)) ;

    CBodyCmd* pBodyCmd = new    CBodyCmd(context.m_pInstance, driver, pSocket) ;

    if( pBodyCmd != 0 ) {

		static	char	szCode[4] = { '2', '2', '2', ' ' } ;

        if( !pBodyCmd->BuildTransmit(   argv[1], "222 ", szOpt, sizeof( szOpt ) - 1, context, driver ) ) {
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0 ;
        }

        context.m_nrcLast = nrcBodyFollows ;

        return  pBodyCmd;
    }

    context.m_return.fSet( nrcServerFault ) ;
    pExecute =  new( context )  CErrorCmd( context.m_return ) ;
    return  0 ;
}

BOOL
CBodyCmd::GetTransferParms(
                        FIO_CONTEXT*	&pFIOContext,
                        DWORD&      ibOffset,
                        DWORD&      cbLength ) {

	if( m_pFIOContext ) {

        pFIOContext = m_pFIOContext ;
        ibOffset = m_HeaderOffset + m_HeaderLength ;
        cbLength = m_cbArticleLength - m_HeaderLength ;

        return  TRUE ;
    }
    return  FALSE ;
}

BOOL
CArticleCmd::IsValid( ) {

    return  TRUE ;
}

CIOExecute*
CUnimpCmd::make(    int cArgs,
                    char **argv,
                    CExecutableCommand*&  pexecute,
                    struct ClientContext&   context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CUnimpCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CErrorCmd object which will print the necessary message !

--*/


    //
    //  Create a CUnimpCmd object - which just reports error 503 !
    //

    context.m_return.fSet( nrcNotRecognized ) ;

    pexecute = new( context ) CErrorCmd( context.m_return ) ;
    return  0 ;
}

int
CUnimpCmd::StartExecute(    BYTE *lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext&,
                            CLogCollector*  pCollector ) {

    static  char    szUnimp[] = "503 - Command Not Recognized\r\n" ;

    CopyMemory( lpb, szUnimp, sizeof( szUnimp ) ) ;
    fComplete = TRUE ;

    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, 4 ) ;
    }

    return  sizeof( szUnimp )  - 1 ;
}


CIOExecute*
CDateCmd::make( int cArgs,
                char    **argv,
                CExecutableCommand*&  pexecute,
                struct ClientContext&   context,
                class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CDateCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CDateCmd object which will print the necessary message !

--*/



    //
    //  Create a CDateCmd object - there's not much to do !
    //

    _ASSERT( lstrcmpi( argv[0], "date" ) == 0 ) ;

    CDateCmd    *pCmd = new( context ) CDateCmd() ;
    pexecute = pCmd ;
    return  0 ;
}

int
CDateCmd::StartExecute( BYTE*   lpb,
                        int     cb,
                        BOOL&   fComplete,
                        void*&  pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the Date response string into the buffer to be sent to the client.
    Assume its short so mark fComplete TRUE after this call.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  This function implements the date command - assume the caller always
    //  provides a large enough buffer.
    //
    //  Just send the current time !
    //

    SYSTEMTIME  systime ;

    GetSystemTime( &systime ) ;

    int cbOut = _snprintf( (char*)lpb, cb, "111 %04d%02d%02d%02d%02d%02d\r\n",
            systime.wYear, systime.wMonth, systime.wDay, systime.wHour, systime.wMinute, systime.wSecond ) ;
    _ASSERT( cbOut > 0 ) ;
    fComplete = TRUE ;

    context.m_nrcLast = nrcDateFollows ;

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, cbOut-2 ) ;
    }
    */

    return  cbOut ;
}



BOOL
GetTimeDateAndDistributions(    int cArgs,
                                char **argv,
                                FILETIME&   filetimeOut,
                                ClientContext&  context ) {

    TraceFunctEnter( "GetTimeDateAndDistributions" ) ;

    //
    //  This function is used by the newnews and newgroups command to parse much of their
    //  command lines.  we basically want to return a FILETIME structure containing a time
    //  corresponding to the request - or set the ClientContext's error code to an appropriate
    //  value !
    //

    FILETIME    filetime ;

    if( cArgs > 4 || cArgs < 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
        return  FALSE ;
    }   else    {

        if( lstrlen( argv[0] ) != 6 || lstrlen( argv[1] ) != 6 ) {
            context.m_return.fSet( nrcSyntaxError ) ;
            return  FALSE ;
        }

        SYSTEMTIME  systime ;
        int cScanned = sscanf( argv[0], "%2hd%2hd%2hd", &systime.wYear,
                                    &systime.wMonth, &systime.wDay) ;

        //systime.wMonth = min( systime.wMonth, 12 ) ;
        //systime.wDay = min( systime.wDay, 32 ) ;
        if( systime.wYear < 50 )
            systime.wYear += 2000 ;
        else
            systime.wYear += 1900 ;

        cScanned += sscanf( argv[1], "%2hd%2hd%2hd", &systime.wHour,
                                    &systime.wMinute, &systime.wSecond) ;
        systime.wDayOfWeek = 0 ;
        //systime.wHour = min( systime.wHour, 23 ) ;
        //systime.wMinute = min( systime.wMinute, 59 ) ;
        //systime.wSecond = min( systime.wSecond, 59 ) ;
        systime.wMilliseconds = 0 ;

        if( cScanned != 6 ) {
            context.m_return.fSet( nrcSyntaxError ) ;
            return  FALSE ;
        }

        FILETIME    localtime ;
        if( !SystemTimeToFileTime( &systime, &localtime) )  {
            context.m_return.fSet( nrcSyntaxError ) ;
            return  FALSE ;
        }
        filetime = localtime ;

        //
        //  We have UTC times both on the files and in the hash tables !
        //  Therefore when the user specified GMT no conversion is needed because
        //  we will be comparing to UTC times, but when they don't specify
        //  GMT we need to take the time they passed us and convert to UTC for
        //  comparison purposes !!!
        //


        if( cArgs == 2 )    {

            //
            //  GMT NOT specified ! - convert our localtime to UTC !!
            //

            if( !LocalFileTimeToFileTime( &localtime, &filetime ) ) {
                    DWORD   dw = GetLastError() ;
                    _ASSERT( 1==0 ) ;
            }

        }   else    {

            //
            //  There's between 2 and 4 arguments - so must be more than 2 !
            //
            _ASSERT( cArgs > 2 ) ;

            //
            //  Did they specify GMT ??
            //
            if( lstrcmp( argv[2], "GMT" ) == 0 ) {
                //
                //  GMT Is specified ! - don't need to convert our localtime to UTC !!
                //

                if( cArgs == 4  ) {
                    // Check for distributions line
                    //context.m_return.fSet( nrcSyntaxError ) ;
                    //return    FALSE ;
                }
            }   else    {
                //
                //  GMT NOT specified ! - convert our localtime to UTC !!
                //

                if( !LocalFileTimeToFileTime( &localtime, &filetime ) ) {
                        DWORD   dw = GetLastError() ;
                        _ASSERT( 1==0 ) ;
                }

                //
                //  Eventually there needs to be logic to deal with distributions here !
                //  but for now ignore the problem !
                //

                if( cArgs == 4 ) {
                    context.m_return.fSet( nrcSyntaxError ) ;
                    return  FALSE ;
                }
            }
        }
#ifdef  DEBUG

    FILETIME    DebugLocalTime ;
    SYSTEMTIME  DebugLocalSystemTime ;
    SYSTEMTIME  DebugUTCTime ;

    FileTimeToLocalFileTime( &filetime, &DebugLocalTime ) ;
    FileTimeToSystemTime( &DebugLocalTime, &DebugLocalSystemTime ) ;
    FileTimeToSystemTime( &filetime, &DebugUTCTime ) ;

    DebugTrace( 0, "Debug Local Time YYMMDD %d %d %d HHMMSS %d %d %d",
            DebugLocalSystemTime.wYear, DebugLocalSystemTime.wMonth, DebugLocalSystemTime.wDay,
            DebugLocalSystemTime.wHour, DebugLocalSystemTime.wMinute, DebugLocalSystemTime.wSecond ) ;

    DebugTrace( 0, "Debug UTC Time YYMMDD %d %d %d HHMMSS %d %d %d",
            DebugUTCTime.wYear, DebugUTCTime.wMonth, DebugUTCTime.wDay,
            DebugUTCTime.wHour, DebugUTCTime.wMinute, DebugUTCTime.wSecond ) ;

#endif
    }
    filetimeOut = filetime ;
    return  TRUE ;
}

CIOExecute*
CNewgroupsCmd::make(    int cArgs,
                        char **argv,
                        class CExecutableCommand*&    pExecute,
                        struct ClientContext&   context,
                        CIODriver&  driver ) {
/*++

Routine Description :

    Create a CNewgroupsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNewgroupsCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Use GetTimeDateAndDistributions to parse the command line, and if that succeeds
    //  create a CNewgroups object !
    //

    _ASSERT( lstrcmpi( argv[0], "newgroups" ) == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), NewgroupsCommands );

    FILETIME    localtime ;

    if( !GetTimeDateAndDistributions( cArgs-1, &argv[1], localtime, context ) ) {
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {
        CGroupIterator* pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                            context.m_IsSecureConnection,   // include secure ?
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        if( pIterator != 0 ) {
            pExecute = new( context ) CNewgroupsCmd( localtime, pIterator ) ;
            if( pExecute == 0 )
                delete  pIterator ;
            else
                return  0 ;
        }
    }
    context.m_return.fSet( nrcServerFault ) ;
    pExecute = new( context ) CErrorCmd( context.m_return ) ;
    return  0 ;
}


CNewgroupsCmd::CNewgroupsCmd(   FILETIME&   time,
                                CGroupIterator* pIter ) :
    m_time( time ), m_pIterator( pIter ) {
    //
    //  This constructor must be provided valid arguments !
    //
}

CNewgroupsCmd::~CNewgroupsCmd() {

    if( m_pIterator != 0 ) {
        delete  m_pIterator ;
    }
}

int
CNewgroupsCmd::StartExecute(    BYTE    *lpb,
                                int cb,
                                BOOL&   fComplete,
                                void*&  pv,
                                ClientContext&  context,
                                CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CNewsgroupsCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Print our initial response line into the buffer !
    //

    static  char    szNewgroups[] = "231 New newsgroups follow.\r\n" ;
    _ASSERT( cb > sizeof( szNewgroups ) ) ;

    context.m_nrcLast = nrcNewgroupsFollow ;

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szNewgroups, 4 ) ;
    }
    */

    CopyMemory( lpb, szNewgroups, sizeof( szNewgroups ) ) ;
    return  sizeof( szNewgroups ) - 1 ;
}

int
CNewgroupsCmd::PartialExecute(  BYTE    *lpb,
                                int     cb,
                                BOOL&   fComplete,
                                void*&  pv,
                                ClientContext&,
                                CLogCollector*  pCollector ) {
/*++

Routine Description :

    Examine each newsgroup in the newsgroup tree and determine whether we should
    send info on it to the client.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Check each newsgroup's Time to the time the client specified, and if necessary send
    //  print the newsgroup info into the supplied buffer !
    //


    fComplete = FALSE ;
    int cbRtn = 0 ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;
		_ASSERT(p != NULL);

		if (p != NULL) {
        	FILETIME    grouptime = p->GetGroupTime() ;
        	SYSTEMTIME  systime ;
        	FileTimeToSystemTime( &grouptime, &systime ) ;
        	if( CompareFileTime( &grouptime, &m_time ) > 0 ) {
        	    if( cb - cbRtn > 10 ) {
        	        int cbTemp = _snprintf( (char*)lpb+cbRtn, cb-cbRtn, "%s %d %d %c\r\n",
        	                p->GetNativeName(), p->GetLastArticle(), p->GetFirstArticle(), 'y' ) ;
        	        if( cbTemp < 0 ) {
        	            return  cbRtn ;
        	        }   else    {
        	            cbRtn += cbTemp ;
        	        }
        	    }   else    {
        	        return  cbRtn ;
        	    }
        	}
		}
        m_pIterator->Next() ;
    }
    _ASSERT( cbRtn <= cb ) ;
    if( cb - cbRtn > 3 ) {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    _ASSERT( cbRtn <= cb ) ;
    return  cbRtn ;
}


LPMULTISZ
BuildMultiszFromCommas( LPSTR   lpstr )     {

    char*   pchComma = lpstr ;

    while( (pchComma = strchr( pchComma, ',' )) != 0 ) {
        *pchComma++ = '\0' ;
        char*   pchCommaBegin = pchComma ;
        while( *pchComma == ',' )
            pchComma++ ;

        if( pchComma != pchCommaBegin ) {
            MoveMemory( pchCommaBegin, pchComma, lstrlen( pchComma )+2 ) ;
        }

    }
    return  lpstr ;
}

CIOExecute*
CNewnewsCmd::make(  int cArgs,
                    char **argv,
                    class CExecutableCommand*&    pExecute,
                    struct ClientContext&   context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CNewnewsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNewnewsCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Use GetTimeDataAndDistributions to parse the clients command line
    //  If that succeeds build an iterator which will enumerate all of the
    //  requested newsgroups.  Then create a CNewnewsCmd object.
    //

    _ASSERT( lstrcmpi( argv[0], "newnews" ) == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), NewnewsCommands );

    FILETIME    localtime ;

    if( !(context.m_pInstance)->FAllowNewnews() ) {
        context.m_return.fSet( nrcNoAccess ) ;
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }

    if( !GetTimeDateAndDistributions( cArgs-2, &argv[2], localtime, context ) ) {
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {
        CGroupIterator* pIterator = 0 ;

        //
        //  We need to provide a DOUBLE NULL terminated list to GetIterator() -
        //  we know there must be at least 4 args, so since we're done with the third
        //  arg, zap it to make sure we pass a DOUBLE NULL terminated string !
        //
        *argv[2] = '\0' ;
        if( *argv[1] == '*' && argv[1][1] == '\0' ) {
            pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                    context.m_IsSecureConnection,   // include secure ?
                                                    &context.m_securityCtx,         // client security ctx
                                                    context.m_IsSecureConnection,   // is client conx secure ?
                                                    &context.m_encryptCtx           // client ssl ctx
                                                    ) ;
        } else  {
            LPMULTISZ lpmulti = BuildMultiszFromCommas( argv[1] ) ;
            pIterator = (context.m_pInstance)->GetTree()->GetIterator(  lpmulti,
                                                            context.m_IsSecureConnection,
                                                            FALSE,
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        }

        if( pIterator != 0 ) {
            pExecute = new( context ) CNewnewsCmd( localtime, pIterator, argv[1] ) ;
            if( pExecute == 0 )
                delete  pIterator ;
            else
                return  0 ;
        }
    }
    context.m_return.fSet( nrcServerFault ) ;
    pExecute = new( context ) CErrorCmd( context.m_return ) ;
    return  0 ;
}

CNewnewsCmd::CNewnewsCmd(   FILETIME&   time,
                            CGroupIterator* pIter,
                            LPSTR       lpstrPattern ) :
    m_time( time ),
    m_pIterator( pIter ),
    m_artidCurrent( INVALID_ARTICLEID ),
    m_cMisses( 0 ),
    m_lpstrPattern( lpstrPattern ) {
    //
    //  All constructor args must be valid
    //
}

CNewnewsCmd::~CNewnewsCmd( )    {

    if( m_pIterator != 0 )
        delete  m_pIterator ;

}

CNewnewsCmd::StartExecute(  BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void*&  pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CNewsnewsCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Copy the initial response string into the buffer
    //

    static  char    szNewnews[] = "230 list of new articles by message-id follows.\r\n" ;
    _ASSERT( cb > sizeof( szNewnews) ) ;

    context.m_nrcLast = nrcNewnewsFollows ;

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szNewnews, 4 ) ;
    }
    */

    CopyMemory( lpb, szNewnews, sizeof( szNewnews)-1 ) ;
    return  sizeof( szNewnews ) - 1 ;
}


class   CExtract :  public  IExtractObject  {
public :

    CNewsTree*  m_pTree ;
    LPSTR       m_lpstrGroupName ;
    LPMULTISZ   m_lpmultiGroupPattern ;

    CExtract(   CNewsTree*  pTree,
                LPSTR   lpstrGroup,
                LPMULTISZ   lpmulti ) :
        m_pTree( pTree ),
        m_lpstrGroupName( lpstrGroup ),
        m_lpmultiGroupPattern( lpmulti ) {}

    BOOL
    DoExtract(  GROUPID PrimaryGroup,
                ARTICLEID   PrimaryArticle,
                PGROUP_ENTRY    pGroups,
                DWORD           cGroups ) ;


} ;

BOOL
CExtract::DoExtract(
                GROUPID     PrimaryGroup ,
                ARTICLEID   PrimaryArticle,
                PGROUP_ENTRY    pGroups,
                DWORD       nXPost ) {


    GROUPID xgroup;

    CGRPPTR pGroup;

    _ASSERT(m_lpmultiGroupPattern != NULL);
    _ASSERT(m_lpstrGroupName != NULL ) ;

    //
    // start with the primary group
    //

    xgroup = PrimaryGroup;

    //
    // ok, do the xposted groups
    //

    BOOL fGroupIsPrimary = TRUE;

    do
        {
        pGroup = m_pTree->GetGroupById(xgroup);

        if(pGroup != 0) {
            if ( MatchGroup( m_lpmultiGroupPattern, pGroup->GetName() ) ) {
                if ( lstrcmpi( m_lpstrGroupName, pGroup->GetName() ) == 0 ) {
                     return  TRUE ;
                } else {
                     return  FALSE ;
                }
            }
        } else if( fGroupIsPrimary ) {
            // bail only if group is primary, else skip to next group
            return  FALSE ;
        }

        if ( nXPost > 0 ) {
            xgroup = pGroups->GroupId;
            pGroups++;
            fGroupIsPrimary = FALSE;
        }

    } while ( nXPost-- > 0 );
    return  FALSE ;
}

int
CNewnewsCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )   {
/*++

Routine Description :

    Examine each newsgroup in the newsgroup tree and within that newsgroup
    examine the articles to determine whether they meet the date requirements
    and the article's message id should be sent to the client.
    We use the XOVER table extensively instead of opening individual article files.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The clients state.

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/
    int cbRtn = 0 ;
    fComplete = FALSE ;
    FILETIME    filetime ;
    ARTICLEID   artidFirst ;

    TraceFunctEnter( "CNewnewsCmd::PartialExecute" ) ;

    //
    //  Variables to hold file offsets in articles - we don't need these
    //
    WORD    HeaderOffsetJunk ;
    WORD    HeaderLengthJunk ;


    //
    //  Iterate through all of the requested newsgroups, in each newsgroup use the
    //  XOVER hash table to search all of the article id's to find any articles matching
    //  the time/date requirements.  If they are found print the Message-Id's into the
    //  supplied buffer.
    //  Note : We start looking for matching time/date requirements from the last article id
    //  and work backwards. We will stop looking when 5 articles have not met the requirement.
    //  (as ARTICLEID's will be assigned in almost chronological order.)
    //


    //
    // reserve space for \r\n
    //

    DWORD entrySize = cb - cbRtn - 2;

    //
    // Get the xover information from the database
    //

    while( !m_pIterator->IsEnd() && !(context.m_pInstance)->GetTree()->m_bStoppingTree ) {

        //
        //  Note - iterator only returns those groups matching the pattern
        //  string it was created with when CNewnewsCmd::make was called !
        //
        CGRPPTR p = m_pIterator->Current() ;

        _ASSERT( p!=0 ) ;
        if( m_artidCurrent == INVALID_ARTICLEID ) {
            m_artidCurrent = p->GetLastArticle() ;
            m_cMisses = 0 ;
        }   else    {


        }
        artidFirst = p->GetFirstArticle() ;
        _ASSERT( artidFirst > 0 );

        while( m_artidCurrent >= artidFirst && m_cMisses < 5 && !(context.m_pInstance)->GetTree()->m_bStoppingTree ) {

            BOOL    fPrimary;   // We won't use this - we don't care whether Primary or not !
            CExtract    extractor(  (context.m_pInstance)->GetTree(),
                                    p->GetName(),
                                    m_lpstrPattern
                                    ) ;

			DWORD cStoreIds = 0;
            if( (context.m_pInstance)->XoverTable()->ExtractNovEntryInfo(
                                            p->GetGroupId(),
                                            m_artidCurrent,
                                            fPrimary,
                                            HeaderOffsetJunk,
                                            HeaderLengthJunk,
                                            &filetime,
                                            entrySize,
                                            (PCHAR)(lpb+cbRtn),
											cStoreIds,
											NULL,
											NULL,
                                            &extractor
                                            )   )   {

                if( entrySize != 0  ) {


#ifdef  DEBUG

                    FILETIME    DebugLocalTime ;
                    SYSTEMTIME  DebugLocalSystemTime ;
                    SYSTEMTIME  DebugUTCTime ;

                    FileTimeToLocalFileTime( &filetime, &DebugLocalTime ) ;
                    FileTimeToSystemTime( &DebugLocalTime, &DebugLocalSystemTime ) ;
                    FileTimeToSystemTime( &filetime, &DebugUTCTime ) ;

                    DebugTrace( 0, "Debug Local Time YYMMDD %d %d %d HHMMSS %d %d %d",
                            DebugLocalSystemTime.wYear, DebugLocalSystemTime.wMonth, DebugLocalSystemTime.wDay,
                            DebugLocalSystemTime.wHour, DebugLocalSystemTime.wMinute, DebugLocalSystemTime.wSecond ) ;

                    DebugTrace( 0, "XOVER - Debug UTC Time YYMMDD %d %d %d HHMMSS %d %d %d",
                            DebugUTCTime.wYear, DebugUTCTime.wMonth, DebugUTCTime.wDay,
                            DebugUTCTime.wHour, DebugUTCTime.wMinute, DebugUTCTime.wSecond ) ;

                    FileTimeToSystemTime( &m_time, &DebugUTCTime ) ;

                    DebugTrace( 0, "TARGET - Debug UTC Time YYMMDD %d %d %d HHMMSS %d %d %d",
                            DebugUTCTime.wYear, DebugUTCTime.wMonth, DebugUTCTime.wDay,
                            DebugUTCTime.wHour, DebugUTCTime.wMinute, DebugUTCTime.wSecond ) ;

#endif

                    if( CompareFileTime( &filetime, &m_time ) < 0 ) {
                        m_cMisses++ ;
                    }   else    {

                        //
                        // send the msg id
                        //

                        cbRtn += entrySize;
                        CopyMemory(  lpb+cbRtn, "\r\n", 2 );
                        cbRtn += 2;
                        if( cb-2 <= cbRtn ) {

                            _ASSERT( cbRtn != 0 ) ;

                            return  cbRtn ;
                        }
                    }
                }
            }   else    if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

                _ASSERT( cbRtn != 0 || cb < 100 ) ;

                return  cbRtn ;
            }

            _ASSERT( (cb-2) > cbRtn ) ;
            _ASSERT( cbRtn <= cb ) ;
            _ASSERT( m_artidCurrent != 0 );
            if ( m_artidCurrent == 0 ) break;
            m_artidCurrent-- ;
            entrySize = cb - cbRtn - 2 ;
        }
        _ASSERT( cbRtn <= cb ) ;
        m_pIterator->Next() ;
        m_artidCurrent = INVALID_ARTICLEID ;
    }
    _ASSERT( cbRtn <= cb || (context.m_pInstance)->GetTree()->m_bStoppingTree ) ;
    _ASSERT( m_cMisses <= 5 || (context.m_pInstance)->GetTree()->m_bStoppingTree ) ;
    _ASSERT( m_artidCurrent >= artidFirst || (context.m_pInstance)->GetTree()->m_bStoppingTree ) ;
    //
    // all done ?
    //
    if ( m_pIterator->IsEnd() || (context.m_pInstance)->GetTree()->m_bStoppingTree ) {
        //
        // add the terminating . if done
        //
        if( cb - cbRtn > 3 )    {
            CopyMemory( lpb+cbRtn, StrTermLine, 3 );
            cbRtn += 3 ;
            fComplete = TRUE;
        }
    }

    _ASSERT( cbRtn != 0 ) ;

    return  cbRtn ;
}



CIOExecute*
CGroupCmd::make(    int    cArgs,
                    char **argv,
                    CExecutableCommand*&  pexecute,
                    struct ClientContext&   context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CGroupCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CGroupCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Create a CGroupCmd object if we can find the specified newsgroup.
    //  otherwise return an error to the client.
    //
    _ASSERT( lstrcmpi( argv[0], "group" ) == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), GroupCommands );

    CGroupCmd*  pCmd = 0 ;
    if( cArgs == 2 ) {
        CGRPPTR p = (context.m_pInstance)->GetTree()->GetGroup( argv[1], lstrlen( argv[1] )+1 ) ;
        if( p!= 0 ) {

            if( p->IsGroupAccessible(   context.m_securityCtx,
           								context.m_encryptCtx,
                                        context.m_IsSecureConnection,
                                        FALSE,
                                        TRUE	) ) {
                pCmd =  new( context )  CGroupCmd( p ) ;
                pexecute = pCmd ;
                return  0 ;
            }   else    {

                if( context.m_securityCtx.IsAnonymous() ) {

                    context.m_return.fSet( nrcLogonRequired ) ;

                }   else    {

                    context.m_return.fSet( nrcNoAccess ) ;

                }

            }
        }   else    {
            context.m_return.fSet( nrcNoSuchGroup) ;
        }
    }   else    {
        context.m_return.fSet( nrcSyntaxError ) ;
    }
    _ASSERT( !context.m_return.fIsClear() ) ;
    pexecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

CGroupCmd::CGroupCmd( CGRPPTR   p ) : m_pGroup( p ) { }

DWORD
NNTPIToA(
	DWORD	dw,
	char*	pchBuf
	)	{

	char	*pchBegin = pchBuf ;
	DWORD	digval;

	do	{
		digval = dw % 10 ;
		dw /= 10 ;
		*pchBuf++	= (char)(digval + '0') ;	
	}	while( dw > 0 ) ;

	DWORD	dwReturn = (DWORD)(pchBuf-pchBegin) ;
	char	*pchLast = pchBuf-1 ;

	do	{
		char	temp = *pchLast ;
		*pchLast = *pchBegin ;
		*pchBegin = temp ;
		--pchLast ;
		pchBegin++ ;
	}	while( pchBegin < pchLast ) ;

	return	dwReturn ;
}

int
CGroupCmd::StartExecute(    BYTE *lpb,
                            int cbSize,
                            BOOL    &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Change the clients context so that they are now operating in a different group.
    We will also print the necessary response string !
    We assume that we will be provided a large enough buffer for whatever we want to print.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Print a string into the supplied buffer and adjust the ClientContext.
    //

    // _ASSERT( IsValid() ) ;
    int cbRtn = 0 ;

    context.m_nrcLast = nrcGroupSelected ;

    if( m_pGroup != 0  )    {
		CopyMemory( lpb, "211 ", 4 ) ;
		cbRtn = 4 ;

		char	szNumBuff[30] ;
		DWORD	cb = NNTPIToA( m_pGroup->GetArticleEstimate(), szNumBuff ) ;
		CopyMemory( lpb+cbRtn, szNumBuff, cb ) ;
		cbRtn += cb ;
		lpb[cbRtn++] = ' ' ;

		cb = NNTPIToA( m_pGroup->GetFirstArticle(), szNumBuff ) ;
		CopyMemory( lpb+cbRtn, szNumBuff, cb ) ;
		cbRtn += cb ;
		lpb[cbRtn++] = ' ' ;

		cb = NNTPIToA( m_pGroup->GetLastArticle(), szNumBuff ) ;
		CopyMemory( lpb+cbRtn, szNumBuff, cb ) ;
		cbRtn += cb ;
		lpb[cbRtn++] = ' ' ;

		cb = m_pGroup->FillNativeName( (char*)lpb+cbRtn, cbSize - cbRtn ) ;
		cbRtn += cb ;

		lpb[cbRtn++] = '\r' ;
		lpb[cbRtn++] = '\n' ;

        if( cbRtn < 0 ) {
            _ASSERT( 1==0 ) ;
            // Not large enough buffer to send the string !!
            return  0 ;
        }
        context.m_pCurrentGroup = m_pGroup ;
        if( m_pGroup->GetArticleEstimate() > 0 )
            context.m_idCurrentArticle = m_pGroup->GetFirstArticle() ;
        else
            context.m_idCurrentArticle = INVALID_ARTICLEID ;
    }   else    {
        _ASSERT( 1==0 ) ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, cbRtn-2 ) ;
    }
    */

    fComplete = TRUE ;
    return  cbRtn ;
}

int
CGroupCmd::PartialExecute(  BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void *&pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {

    //
    //  We assume StartExecute will always succeed since we send such a small string and
    //  the caller always provides large buffers.
    //
    //

    _ASSERT( 1==0 ) ;
    return 0 ;
}


CIOExecute*
CListgroupCmd::make(    int    cArgs,
                    char **argv,
                    CExecutableCommand*&  pexecute,
                    struct ClientContext&   context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CGroupCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CGroupCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Create a CGroupCmd object if we can find the specified newsgroup.
    //  otherwise return an error to the client.
    //
    _ASSERT( lstrcmpi( argv[0], "listgroup" ) == 0 ) ;

    CListgroupCmd*  pCmd = 0 ;
    if( cArgs == 2 ) {
        CGRPPTR p = (context.m_pInstance)->GetTree()->GetGroup( argv[1], lstrlen( argv[1] )+1 ) ;
        if( p!= 0 ) {

            if( p->IsGroupAccessible(   context.m_securityCtx,
           								context.m_encryptCtx,
                                        context.m_IsSecureConnection,
                                        FALSE,
                                        TRUE	) ) {
                pCmd =  new( context )  CListgroupCmd( p ) ;
                pexecute = pCmd ;
                return  0 ;
            }   else    {

                if( context.m_securityCtx.IsAnonymous() ) {

                    context.m_return.fSet( nrcLogonRequired ) ;

                }   else    {

                    context.m_return.fSet( nrcNoAccess ) ;

                }

            }
        }   else    {
            context.m_return.fSet( nrcNoSuchGroup ) ;
        }
    }   else    if( cArgs == 1 ) {

        if( context.m_pCurrentGroup != 0 ) {

            pCmd = new( context )   CListgroupCmd( context.m_pCurrentGroup ) ;
            pexecute = pCmd ;
            return  0 ;

        }

        context.m_return.fSet( nrcNoListgroupSelected ) ;

    }   else    {
        context.m_return.fSet( nrcSyntaxError ) ;
    }
    _ASSERT( !context.m_return.fIsClear() ) ;
    pexecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

CListgroupCmd::CListgroupCmd( CGRPPTR   p ) : m_pGroup( p ) { }

int
CListgroupCmd::StartExecute(    BYTE *lpb,
                            int cb,
                            BOOL    &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Change the clients context so that they are now operating in a different group.
    We will also print the necessary response string !
    We assume that we will be provided a large enough buffer for whatever we want to print.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Print a string into the supplied buffer and adjust the ClientContext.
    //

    // _ASSERT( IsValid() ) ;
    int cbRtn = 0 ;
    static  char    szListGroupResponse[] = "211\r\n" ;

    context.m_nrcLast = nrcGroupSelected ;

    if( m_pGroup != 0  )    {

        m_curArticle = m_pGroup->GetFirstArticle() ;

        CopyMemory( lpb, szListGroupResponse, sizeof( szListGroupResponse ) ) ;
        cbRtn  += sizeof( szListGroupResponse ) - 1 ;
        context.m_pCurrentGroup = m_pGroup ;
        if( m_pGroup->GetArticleEstimate() > 0 )
            context.m_idCurrentArticle = m_curArticle ;
        else
            context.m_idCurrentArticle = INVALID_ARTICLEID ;
    }   else    {
        _ASSERT( 1==0 ) ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, cbRtn-2 ) ;
    }
    */

    return  cbRtn ;
}

int
CListgroupCmd::PartialExecute(  BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void *&pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {

    //
    //  We assume StartExecute will always succeed since we send such a small string and
    //  the caller always provides large buffers.
    //
    //

    DWORD   cbRtn = 0 ;
    ARTICLEID   artidMax = m_pGroup->GetLastArticle() ;
    DWORD cbRemaining = cb;
    ARTICLEID artidTemp = m_curArticle;

    fComplete = FALSE;

    while( artidTemp <= artidMax  && cbRemaining > 20 ) {

        if( context.m_pInstance->XoverTable()->SearchNovEntry( context.m_pCurrentGroup->GetGroupId(),
                                        artidTemp,
                                        0,
                                        0 ) ) {

            //
            //  Change the current Article position.
            //  Send the Command succeeded response.
            //

            _itoa( artidTemp, (char*)lpb + cbRtn, 10 ) ;
            cbRtn += lstrlen( (char*)lpb + cbRtn) ;

            _ASSERT( int(cbRtn + 2) <= cb ) ;
            lpb[cbRtn++] = '\r' ;
            lpb[cbRtn++] = '\n' ;
            cbRemaining = cb - cbRtn ;

        }   else    {
            _ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ;
        }
        artidTemp++ ;
    }
    if( artidTemp >= artidMax ) {
        static  char    szTerm[] = ".\r\n" ;
        if( cbRemaining >= sizeof( szTerm ) - 1 ) {
            CopyMemory( lpb + cbRtn, szTerm, sizeof( szTerm ) - 1 ) ;
            cbRtn += sizeof( szTerm ) -1 ;
            fComplete = TRUE ;
        }
    }
    m_curArticle = artidTemp ;
    return  cbRtn ;

}


CIOExecute*
CListCmd::make( int argc,
                char **argv,
                CExecutableCommand*&	pExecute,
                struct ClientContext& context,
                class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CNewnewsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNewnewsCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/

    TraceFunctEnter( "CListCmd::make" ) ;

    InterlockedIncrementStat( (context.m_pInstance), ListCommands );

    //
    // check to see if they've done a LIST SRCHFIELDS
    //
    // if so they aren't listing groups, so we need to use the
    // CSearchFields object
    //
    if (argc >= 2 && lstrcmpi(argv[1], "srchfields") == 0) {
        return CSearchFieldsCmd::make(argc, argv, pExecute, context, driver);
    }

	//
	// check to see if they've done a LIST OVERVIEW.FMT
	//
	// if so they aren't listing groups, so we need to use the COverviewFmtCmd
	// objects
	//
	if (argc >= 2 && lstrcmpi(argv[1], "overview.fmt") == 0) {
        return COverviewFmtCmd::make(argc, argv, pExecute, context, driver);
	}

	//
	// LIST EXTENSIONS
	//
	if (argc >= 2 && lstrcmpi(argv[1], "extensions") == 0) {
        return CListExtensionsCmd::make(argc, argv, pExecute, context, driver);
	}

	//
    //  create a CListCmd object.
    //  If the user specified 'list active' they may also specify a
    //  3rd argument which should be a wildmat compatible string.
    //  We will pass this 3rd arg to GetIterator() if it exists,
    //  otherwise we will list all active groups.
    //

    CGroupIterator* pIterator = 0 ;
    CListCmd    *p = 0 ;
    if( argc == 1 || lstrcmpi( argv[1], "active" ) == 0 ) {
        if( argc <= 2 ) {
            pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                    context.m_IsSecureConnection,   // include secure ?
                                                    &context.m_securityCtx,         // client security ctx
                                                    context.m_IsSecureConnection,   // is client conx secure ?
                                                    &context.m_encryptCtx           // client ssl ctx
                                                    ) ;
        }   else if( argc == 3 )    {
            LPMULTISZ   multisz = BuildMultiszFromCommas( argv[2] ) ;
            pIterator = (context.m_pInstance)->GetTree()->GetIterator(  multisz,
                                                            context.m_IsSecureConnection,
                                                            FALSE,
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        }   else    {
            context.m_return.fSet( nrcSyntaxError ) ;
            pExecute = new( context )   CErrorCmd( context.m_return ) ;
            return  0 ;
        }
        if( pIterator != 0 ) {
            p = new( context )  CListCmd( pIterator ) ;
            pExecute = p ;
            return  0 ;
        }
    }   else    if( argc >= 2 && lstrcmpi( argv[1], "newsgroups" ) == 0 )     {

        if( argc == 3 ) {
            LPMULTISZ   multisz = BuildMultiszFromCommas( argv[2] ) ;
            pIterator = (context.m_pInstance)->GetTree()->GetIterator(  multisz,
                                                            context.m_IsSecureConnection,
                                                            FALSE,
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        }   else    {
            pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                        context.m_IsSecureConnection,   // include secure ?
                                                        &context.m_securityCtx,         // client security ctx
                                                        context.m_IsSecureConnection,   // is client conx secure ?
                                                        &context.m_encryptCtx           // client ssl ctx
                                                        ) ;
        }
        if( pIterator != 0 ) {
            pExecute = new( context )   CListNewsgroupsCmd( pIterator ) ;
            return 0 ;
        }
    }   else    if( argc >= 2 && lstrcmpi( argv[1], "prettynames" ) == 0 )     {

        if( argc == 3 ) {
            LPMULTISZ   multisz = BuildMultiszFromCommas( argv[2] ) ;
            pIterator = (context.m_pInstance)->GetTree()->GetIterator(  multisz,
                                                            context.m_IsSecureConnection,
                                                            FALSE,
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        }   else    {
            pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                        context.m_IsSecureConnection,   // include secure ?
                                                        &context.m_securityCtx,         // client security ctx
                                                        context.m_IsSecureConnection,   // is client conx secure ?
                                                        &context.m_encryptCtx           // client ssl ctx
                                                        ) ;
        }
        if( pIterator != 0 ) {
            pExecute = new( context )   CListPrettynamesCmd( pIterator ) ;
            return 0 ;
        }
    }   else    if( argc == 2 && lstrcmpi( argv[1], "distributions" ) == 0 )    {
        context.m_return.fSet( nrcServerFault ) ;
        pExecute = new( context )   CErrorCmd( context.m_return ) ;
        return 0 ;
	} else	if (argc >= 2 && lstrcmpi(argv[1], "searchable") == 0) {
		pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                        context.m_IsSecureConnection,   // include secure ?
                                                        &context.m_securityCtx,         // client security ctx
                                                        context.m_IsSecureConnection,   // is client conx secure ?
                                                        &context.m_encryptCtx           // client ssl ctx
                                                        ) ;
        if( pIterator != 0 ) {
            pExecute = new( context )   CListSearchableCmd( pIterator ) ;
            return 0 ;
        }
    }   else    {
        // NYI Implented
        context.m_return.fSet( nrcSyntaxError ) ;
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }
    context.m_return.fSet( nrcServerFault ) ;
    pExecute = new( context ) CErrorCmd( context.m_return ) ;
    return 0 ;
}

CListCmd::CListCmd( CGroupIterator *p ) :
    m_pIterator( p ) {
}

CListNewsgroupsCmd::CListNewsgroupsCmd( CGroupIterator  *p ) :
    CListCmd( p ) {
}

CListPrettynamesCmd::CListPrettynamesCmd( CGroupIterator  *p ) :
    CListCmd( p ) {
}

CListSearchableCmd::CListSearchableCmd( CGroupIterator  *p ) :
    CListCmd( p ) {
}

CListCmd::~CListCmd( ) {
    delete  m_pIterator ;
}

int
CListCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL &fComplete,
                        void *&pv,
                        ClientContext& context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CListCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  Just print the initial 'more data follows' message and then move on.
    //

    static  char    szStart[] = "215 list of newsgroups follow\r\n"  ;

    context.m_nrcLast = nrcListGroupsFollows ;

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;

    if( cb < sizeof( szStart ) ) {
        // _ASSERT( 1==0 ) ;
        return  0 ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szStart, 4 ) ;
    }
    */

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    return  sizeof( szStart ) - 1 ;
}


int
CListCmd::PartialExecute(   BYTE *lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector )  {
/*++

Routine Description :

    For each newsgroup the iterator provides us print a string describing the newsgroup.
    Note that CListCmd::make will provide the iterator with any pattern matching strings
    required.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   Client's current context (we don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  For each newsgroup the iterator provides print some information into the
    //  supplied buffer until it is full.
    //


    int cbRtn = 0 ;

    fComplete = FALSE ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;
		_ASSERT(p != NULL);

		if (p != NULL) {
        	if( cb - cbRtn > 5 ) {
        	    //  bugbug ... When security work is completed the last chacater should be
        	    //  something reasonable instead of always 'y'.
        	    int cbTemp = _snprintf( (char*) lpb + cbRtn, cb-cbRtn, "%s %d %d %c\r\n",
        	            p->GetNativeName(),
        	            p->GetLastArticle(),
        	            p->GetFirstArticle(),
        	            p->GetListCharacter() ) ;
        	    if( cbTemp < 0 ) {
        	        return  cbRtn ;
        	    }   else    {
        	        cbRtn += cbTemp ;
        	    }
        	} else  {
        	    return  cbRtn ;
        	}
		}
        m_pIterator->Next() ;
    }
    if( cb - cbRtn > 3 )    {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    return  cbRtn ;
}

int
CListNewsgroupsCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL &fComplete,
                        void *&pv,
                        ClientContext& context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CListCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  Just print the initial 'more data follows' message and then move on.
    //

    static  char    szStart[] = "215 descriptions follow\r\n"  ;

    context.m_nrcLast = nrcListGroupsFollows ;

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;

    if( cb < sizeof( szStart ) ) {
        // _ASSERT( 1==0 ) ;
        return  0 ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szStart, 4 ) ;
    }
    */

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    return  sizeof( szStart ) - 1 ;
}


int
CListNewsgroupsCmd::PartialExecute(   BYTE *lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector )  {
/*++

Routine Description :

    For each newsgroup the iterator provides us print a string describing the newsgroup.
    Note that CListCmd::make will provide the iterator with any pattern matching strings
    required.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   Client's current context (we don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  For each newsgroup the iterator provides print some information into the
    //  supplied buffer until it is full.
    //


    int cbRtn = 0 ;

    fComplete = FALSE ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;

		_ASSERT(p != NULL);
		if (p != NULL) {
        	if( cb - cbRtn > 5 ) {
	
	            LPCSTR   lpstrName = p->GetNativeName() ;
	            int     cbTemp = lstrlen( lpstrName ) ;
	            int     cbTemp2 = 0 ;
	            if( cbTemp+2 < (cb-cbRtn) ) {
	                CopyMemory( lpb+cbRtn, lpstrName, cbTemp ) ;
	                lpb[cbRtn+cbTemp] = ' ' ;
	
	                cbTemp2 = p->CopyHelpText( (char*)lpb+cbRtn+cbTemp+1, cb - (cbRtn + cbTemp+2) ) ;
	                if( cbTemp2 == 0 ) {
	                    return  cbRtn ;
	                }
	            }   else    {
	                return  cbRtn ;
	            }

	            cbRtn += cbTemp + cbTemp2 + 1  ;
	        } else  {
	            return  cbRtn ;
	        }
		}
        m_pIterator->Next() ;
    }
    if( cb - cbRtn > 3 )    {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    return  cbRtn ;
}

int
CListPrettynamesCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL &fComplete,
                        void *&pv,
                        ClientContext& context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CListCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  Just print the initial 'more data follows' message and then move on.
    //

    static  char    szStart[] = "215 prettynames for newsgroups\r\n"  ;

    context.m_nrcLast = nrcListGroupsFollows ;

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;

    if( cb < sizeof( szStart ) ) {
        // _ASSERT( 1==0 ) ;
        return  0 ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szStart, 4 ) ;
    }
    */

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    return  sizeof( szStart ) - 1 ;
}

int
CListPrettynamesCmd::PartialExecute(   BYTE *lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector )  {
/*++

Routine Description :

    For each newsgroup the iterator provides us, print the newsgroup prettyname (an addon).
    Note that CListCmd::make will provide the iterator with any pattern matching strings
    required.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   Client's current context (we don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  For each newsgroup the iterator provides print some information into the
    //  supplied buffer until it is full.
    //


    int cbRtn = 0 ;

    fComplete = FALSE ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;

		_ASSERT(p != NULL);
		if (p != NULL) {
        	if( cb - cbRtn > 5 ) {
	
	            LPCSTR   lpstrName = p->GetNativeName() ;
	            int     cbTemp = lstrlen( lpstrName ) ;
	            int     cbTemp2 = 0 ;
	            if( cbTemp+2 < (cb-cbRtn) ) {
	                CopyMemory( lpb+cbRtn, lpstrName, cbTemp ) ;
	                lpb[cbRtn+cbTemp] = '\t' ;	// TAB delim
	
	                cbTemp2 = p->CopyPrettyname( (char*)lpb+cbRtn+cbTemp+1, cb - (cbRtn + cbTemp+2) ) ;
	                if( cbTemp2 == 0 ) {
	                	return cbRtn ;
	                }
	            }   else    {
	                return  cbRtn ;
	            }
	
	            cbRtn += cbTemp + cbTemp2 + 1  ;
	        } else  {
	            return  cbRtn ;
	        }
		}
        m_pIterator->Next() ;
    }
    if( cb - cbRtn > 3 )    {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    return  cbRtn ;
}

int CListSearchableCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{
    TraceFunctEnter("CListSearchableCmd::StartExecute");

    DWORD cbOut;
    char szList[] = "224 Data Follows\r\n"; //* US-ASCII\r\n.\r\n";

    context.m_nrcLast = nrcXoverFollows ;

    _ASSERT(lpb != 0);
    _ASSERT(cb != 0);
    _ASSERT(fComplete == FALSE);

    _ASSERT(cb > sizeof(szList));
    CopyMemory( (char*)lpb, szList, sizeof(szList)-1);
    cbOut = sizeof(szList) - 1;

    fComplete = FALSE;

    return cbOut;
}

int
CListSearchableCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("CListSearchableCmd::PartialExecute");

    //
    //  For each newsgroup the iterator provides print some information into the
    //  supplied buffer until it is full.
    //


    int cbRtn = 0 ;

    fComplete = FALSE ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;

		_ASSERT(p != NULL);

		if (p != NULL) {
			//
			//	LIST SEARCHABLE returns all newsgroups whose content is indexed
			//	- this is derived from the MD_IS_CONTENT_INDEXED vroot property.
			//
			if( p->IsContentIndexed() ) {
	        	if( cb - cbRtn > 5 ) {
	            	int cbTemp = _snprintf( (char*) lpb + cbRtn, cb-cbRtn, "%s\r\n",
	                	    p->GetNativeName() ) ;
		            if( cbTemp < 0 ) {
	    	            return  cbRtn ;
	        	    }   else    {
	            	    cbRtn += cbTemp ;
		            }
	    	    } else  {
	        	    return  cbRtn ;
		        }
	        }
		}
	    m_pIterator->Next() ;
    }
    if( cb - cbRtn > 3 )    {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    return  cbRtn ;
}

CIOExecute*
CListExtensionsCmd::make( int argc,
                char**  argv,
                CExecutableCommand*&  pExecute,
                ClientContext&  context,
                class   CIODriver&  driver  )   {
/*++

Routine Description :

    Create a CListExtensionsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CListExtensionsCmd object.

--*/


    //
    //  Create a CListExtensionsCmd object
    //

    _ASSERT( pExecute == 0 ) ;

    CListExtensionsCmd *pReturn = new( context ) CListExtensionsCmd() ;
    pExecute = pReturn ;
    return  0 ;
}

char CListExtensionsCmd::szExtensions[] =    
	"202 Extensions supported:\r\n"
	" OVER\r\n"
	" SRCH\r\n"
	" PAT\r\n"
//	" PATTEXT\r\n"	
//	" LISTGROUP\r\n"	
//	" AUTHINFO\r\n"	
//	" AUTHINFO-GENERIC\r\n"	
	".\r\n" ;


CListExtensionsCmd::CListExtensionsCmd() : m_cbTotal( sizeof( szExtensions )-1 ) {
}


int
CListExtensionsCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pLogCollector ) {
/*++

Routine Description :

    Send the list extensions text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT(    pv == 0 ) ;
    _ASSERT( m_cbTotal != 0 ) ;
    _ASSERT( m_cbTotal == sizeof( szExtensions )-1 ) ;

    //
    //  Send the extension list text to the client.
    //  Because there may be a lot of text, we will use the provided void*& pv argument
    //  to save our position in case PartialExecute needs to be called.
    //

	context.m_nrcLast =	nrcExtensionsFollow;

	pv = szExtensions;

    DWORD   cbToCopy = min( cb, m_cbTotal ) ;
    CopyMemory( lpb, pv, cbToCopy ) ;
    pv = ((BYTE*)pv + cbToCopy ) ;
    if( cbToCopy != (DWORD)m_cbTotal ) {
        fComplete = FALSE ;
    }   else    {
        fComplete = TRUE ;
    }
    m_cbTotal -= cbToCopy ;

    /*
    if( pLogCollector ) {
        pLogCollector->FillLogData( LOG_TARGET, (BYTE*)szExtensions, 4 ) ;
    }
    */

    return  cbToCopy ;
}


int
CListExtensionsCmd::PartialExecute(   BYTE    *lpb,
                            int cb,
                            BOOL    &fComplete,
                            void    *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Send the rest of the list extensions text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/


    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT( pv != 0 ) ;
    _ASSERT( m_cbTotal != 0 ) ;

    //
    //  Copy extension list text into buffer untill the buffer is full!
    //

    DWORD   cbToCopy = min( cb, m_cbTotal ) ;
    CopyMemory( lpb, pv, cbToCopy ) ;
    pv = ((BYTE*)pv + cbToCopy ) ;
    if( cbToCopy != (DWORD)m_cbTotal ) {
        fComplete = FALSE ;
    }   else    {
        fComplete = TRUE ;
    }
    m_cbTotal -= cbToCopy ;
    return  cbToCopy ;
}

CIOExecute*
CHelpCmd::make( int argc,
                char**  argv,
                CExecutableCommand*&  pExecute,
                ClientContext&  context,
                class   CIODriver&  driver  )   {
/*++

Routine Description :

    Create a CHelpCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CHelpCmd object.

--*/


    //
    //  Create a CHelpCmd object
    //

    _ASSERT( lstrcmpi( argv[0], "help" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), HelpCommands );

    CHelpCmd*   pReturn = new( context )    CHelpCmd() ;
    pExecute = pReturn ;
    return  0 ;
}

char    CHelpCmd::szHelp[] =    "100 Legal commands are : \r\n"
                                "article [MessageID|Number] \r\n"
                                "authinfo [user|pass|generic|transact] <data> \r\n"
                                "body [MessageID|Number]\r\n"
                                "check <message-id>\r\n"
                                "date\r\n"
                                "group newsgroup\r\n"
                                "head [MessageID|Number]\r\n"
                                "help \r\n"
                                "ihave <message-id>\r\n"
                                "last\r\n"
                                "list [active|newsgroups[wildmat]|srchfields|searchable|prettynames[wildmat]]\r\n"
                                "listgroup [newsgroup]\r\n"
                                "mode stream|reader\r\n"
                                "newgroups yymmdd hhmmss [\"GMT\"] [<distributions>]\r\n"
                                "newnews wildmat yymmdd hhmmss [\"GMT\"] [<distributions>]\r\n"
                                "next\r\n"
                                "post\r\n"
                                "quit\r\n"
                                "search\r\n"
//                                "slave\r\n"
                                "stat [MessageID|number]\r\n"
                                "xhdr header [range|MessageID]\r\n"
                                "xover [range]\r\n"
                                "xpat header range|MessageID pat [morepat ...]\r\n"
                                "xreplic newsgroup/message-number[,newsgroup/message-number...]\r\n"
                                "takethis <message-id>\r\n"
                                ".\r\n" ;


CHelpCmd::CHelpCmd() : m_cbTotal( sizeof( szHelp )-1 ) {
}


int
CHelpCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pLogCollector ) {
/*++

Routine Description :

    Send the help text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT(    pv == 0 ) ;
    _ASSERT( m_cbTotal != 0 ) ;
    _ASSERT( m_cbTotal == sizeof( szHelp )-1 ) ;

    //
    //  Send the Help Text to the client.
    //  Because there may be a lot of text, we will use the provided void*& pv argument
    //  to save our position in case PartialExecute needs to be called.
    //

    context.m_nrcLast = nrcHelpFollows ;

    pv = szHelp ;

    DWORD   cbToCopy = min( cb, m_cbTotal ) ;
    CopyMemory( lpb, pv, cbToCopy ) ;
    pv = ((BYTE*)pv + cbToCopy ) ;
    if( cbToCopy != (DWORD)m_cbTotal ) {
        fComplete = FALSE ;
    }   else    {
        fComplete = TRUE ;
    }
    m_cbTotal -= cbToCopy ;

    /*
    if( pLogCollector ) {
        pLogCollector->FillLogData( LOG_TARGET, (BYTE*)szHelp, 4 ) ;
    }
    */

    return  cbToCopy ;
}


int
CHelpCmd::PartialExecute(   BYTE    *lpb,
                            int cb,
                            BOOL    &fComplete,
                            void    *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Send the rest of the help text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/


    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT( pv != 0 ) ;
    _ASSERT( m_cbTotal != 0 ) ;

    //
    //  Copy HelpText into buffer untill the buffer is full!
    //

    DWORD   cbToCopy = min( cb, m_cbTotal ) ;
    CopyMemory( lpb, pv, cbToCopy ) ;
    pv = ((BYTE*)pv + cbToCopy ) ;
    if( cbToCopy != (DWORD)m_cbTotal ) {
        fComplete = FALSE ;
    }   else    {
        fComplete = TRUE ;
    }
    m_cbTotal -= cbToCopy ;
    return  cbToCopy ;
}

CIOExecute*
CNextCmd::make( int argc,
                char**  argv,
                CExecutableCommand*&  pExecute,
                struct ClientContext&   context,
                class   CIODriver&  driver  )   {
/*++

Routine Description :

    Create a CNextCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNextCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/

    //
    //  Build a next command object.
    //  First make sure that this command is legal given the current ClientContext state.
    //

    _ASSERT( lstrcmpi( argv[0], "next" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), NextCommands );

    ARTICLEID   artidMax = INVALID_ARTICLEID ;

    if( context.m_pCurrentGroup == 0 )  {
        context.m_return.fSet( nrcNoGroupSelected ) ;
    }   else    if( context.m_idCurrentArticle == INVALID_ARTICLEID )   {
        context.m_return.fSet( nrcNoCurArticle ) ;
    }   else    if( context.m_idCurrentArticle >=
                (artidMax = context.m_pCurrentGroup->GetLastArticle()) ) {
        context.m_return.fSet( nrcNoNextArticle ) ;
    }   else    {
        _ASSERT( artidMax != INVALID_ARTICLEID ) ;
        pExecute = new( context ) CNextCmd( artidMax ) ;
        return  0 ;
    }

    pExecute = new( context )   CErrorCmd( context.m_return );
    return  0 ;
}

int
CNextCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector )    {
/*++

Routine Description :

    Search the XOVER table going forward from the client's current position untill
    we find an article.  Once thats done, send the article's info to the client
    and adjust the context.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state (selected group etc...)

Return Value :

    Number of bytes placed in buffer.

--*/
    int cbRtn = 0 ;

    _ASSERT( context.m_pCurrentGroup != 0 ) ;
    _ASSERT( context.m_idCurrentArticle != INVALID_ARTICLEID ) ;
    _ASSERT( context.m_idCurrentArticle <= context.m_pCurrentGroup->GetLastArticle() ) ;

    context.m_nrcLast = nrcHeadFollowsRequestBody ;

    BOOL    fPrimary ;  // Don't care !!
    FILETIME    filetime ;  // Don't care
    DWORD   cbRemaining = 0 ;
    DWORD   cbConsumed = 0 ;
    WORD    HeaderOffsetJunk ;
    WORD    HeaderLengthJunk ;

    ARTICLEID   artidTemp = context.m_idCurrentArticle ;

    if( artidTemp < context.m_pCurrentGroup->GetFirstArticle() ) {
        artidTemp = context.m_pCurrentGroup->GetFirstArticle()-1 ;
    }

    fComplete = TRUE ;

    static  char    szNextText[] = "223 " ;
    CopyMemory( lpb, szNextText, sizeof( szNextText )-1 ) ;

    do  {
        artidTemp++ ;

        _itoa( artidTemp, (char*)lpb + sizeof( szNextText ) - 1, 10 ) ;
        cbConsumed = lstrlen( (char*)lpb ) ;
        lpb[cbConsumed ++ ] = ' ' ;
        cbRemaining = cb - cbConsumed ;

		DWORD cStoreIds = 0;
        if( (context.m_pInstance)->XoverTable()->ExtractNovEntryInfo(
                                            context.m_pCurrentGroup->GetGroupId(),
                                            artidTemp,
                                            fPrimary,
                                            HeaderOffsetJunk,
                                            HeaderLengthJunk,
                                            &filetime,
                                            cbRemaining,
                                            (char*)lpb + cbConsumed,
											cStoreIds,
											NULL,
											NULL) ) {
            //
            //  Change the current Article position.
            //  Send the Command succeeded response.
            //

            context.m_idCurrentArticle = artidTemp ;
            cbRtn = cbConsumed + cbRemaining ;
            _ASSERT( cbRtn + 2 <= cb ) ;
            lpb[cbRtn++] = '\r' ;
            lpb[cbRtn++] = '\n' ;

            /*
            if( pCollector )    {
                pCollector->FillLogData( LOG_TARGET, lpb, cbRtn - 2 ) ;
            }
            */
            return  cbRtn ;

        }   else    {
            _ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ;
        }
    }   while( artidTemp <= m_artidMax ) ;

    static  char    szNoNext[] = "421 No next to retrieve\r\n" ;

    context.m_nrcLast = nrcNoNextArticle ;

    cbRtn = sizeof( szNoNext ) - 1 ;
    CopyMemory( lpb, szNoNext, cbRtn ) ;

    /*
    if( pCollector )    {
        pCollector->FillLogData( LOG_TARGET, lpb, cbRtn - 2 ) ;
    }
    */

    return  cbRtn ;
}

int
CNextCmd::PartialExecute(   BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void *&pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {
    //
    //  StartExecute should always be sufficient !!
    //
    _ASSERT( 1==0 ) ;
    return 0 ;
}

CIOExecute*
CLastCmd::make( int argc,
                char**  argv,
                CExecutableCommand*&  pExecute,
                ClientContext&  context,
                class   CIODriver&  driver  )   {
/*++

Routine Description :

    Create a CNewnewsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNewnewsCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Determine whether the client can legally execute the last command and if so
    //  create a CLastCmd object.
    //
    //

    _ASSERT( lstrcmpi( argv[0], "last" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    ARTICLEID   artidMin = INVALID_ARTICLEID ;

    InterlockedIncrementStat( (context.m_pInstance), LastCommands );

    if( context.m_pCurrentGroup == 0 )  {
        context.m_return.fSet( nrcNoGroupSelected ) ;
    }   else    if( context.m_idCurrentArticle == INVALID_ARTICLEID )   {
        context.m_return.fSet( nrcNoCurArticle ) ;
    }   else    if( context.m_idCurrentArticle <=
                (artidMin = context.m_pCurrentGroup->GetFirstArticle()) ) {
        context.m_return.fSet( nrcNoPrevArticle ) ;
    }   else    {
        _ASSERT( artidMin != INVALID_ARTICLEID ) ;
        pExecute = new( context )   CLastCmd( artidMin ) ;
        return  0 ;
    }
    _ASSERT( !context.m_return.fIsClear() ) ;
    pExecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

int
CLastCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector )    {
/*++

Routine Description :

    Search the XOVER table going Backwards from the client's current position untill
    we find an article.  Once thats done, send the article's info to the client
    and adjust the context.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state (selected group etc...)

Return Value :

    Number of bytes placed in buffer.

--*/


    int cbRtn = 0 ;

    _ASSERT( context.m_pCurrentGroup != 0 ) ;
    _ASSERT( context.m_idCurrentArticle != INVALID_ARTICLEID ) ;
    _ASSERT( context.m_idCurrentArticle >= m_artidMin ) ;

    ARTICLEID   artidTemp = context.m_idCurrentArticle ;

    BOOL    fPrimary ;  // Don't care !!
    FILETIME    filetime ;  // Don't care
    DWORD   cbRemaining = 0 ;
    DWORD   cbConsumed = 0 ;
    WORD    HeaderOffsetJunk ;
    WORD    HeaderLengthJunk ;

    fComplete = TRUE ;

    context.m_nrcLast = nrcHeadFollowsRequestBody ;

    static  char    szLastText[] = "223 " ;
    CopyMemory( lpb, szLastText, sizeof( szLastText ) ) ;

    do  {
        artidTemp -- ;

        _itoa( artidTemp, (char*)lpb + sizeof( szLastText ) - 1, 10 ) ;
        cbConsumed = lstrlen( (char*)lpb ) ;
        lpb[cbConsumed ++ ] = ' ' ;
        cbRemaining = cb - cbConsumed ;

		DWORD cStoreIds = 0;
        if( (context.m_pInstance)->XoverTable()->ExtractNovEntryInfo(
                                                context.m_pCurrentGroup->GetGroupId(),
                                                artidTemp,
                                                fPrimary,
                                                HeaderOffsetJunk,
                                                HeaderLengthJunk,
                                                &filetime,
                                                cbRemaining,
                                                (char*)lpb + cbConsumed,
												cStoreIds,
												NULL,
												NULL) ) {

            //
            //  Change the current article pointer and then send the success response !
            //

            context.m_idCurrentArticle = artidTemp ;

            cbRtn = cbConsumed + cbRemaining ;
            _ASSERT( cbRtn + 2 <= cb ) ;
            lpb[cbRtn++] = '\r' ;
            lpb[cbRtn++] = '\n' ;

            /*
            if( pCollector )    {
                pCollector->FillLogData( LOG_TARGET, lpb, cbRtn - 2 ) ;
            }
            */
            return  cbRtn ;

        }   else    {
            _ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ;
        }
    }   while( artidTemp >= m_artidMin ) ;

    context.m_nrcLast = nrcNoPrevArticle ;

    static  char    szNoNext[] = "422 No previous article to retrieve\r\n" ;
    cbRtn = sizeof( szNoNext ) - 1 ;
    CopyMemory( lpb, szNoNext, cbRtn ) ;

    /*
    if( pCollector )    {
        pCollector->FillLogData( LOG_TARGET, lpb, cbRtn - 2 ) ;
    }
    */

    return  cbRtn ;

}

int
CLastCmd::PartialExecute(   BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void *&pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {
    _ASSERT( 1==0 ) ;
    return 0 ;
}

LPMULTISZ
ConditionArgs(  int cArgs,
                char**  argv,
                BOOL    fZapCommas ) {
/*++

Routine Description :

    Convert argc, argv arguments into a MULTI_SZ
    The cnversion is done in place.   All argv pointers must be in a contiguous buffer.

Arguemtns :

    cArgs - Number of arguments
    argv -  Argument array
    fZapCommas - convert commas to NULLS

Return Value :

    Pointer to MULTI_SZ

--*/

    //
    //  This function takes an argc,argv set of arguments and converts them
    //  to a MULTI_SZ with a single NULL between strings and 2 NULLs at the end.
    //
    //

    char*   pchComma = 0 ;
    char*   pchEnd = argv[cArgs-1] + lstrlen( argv[cArgs-1] ) + 1 ;
    int     c = 0 ;
    for( char*  pch = argv[0], *pchDest = pch; pch < pchEnd; pch ++, pchDest++ ) {
        if( fZapCommas && *pch == ',' ) {
            for( pchComma = pch; *pchComma == ','; pchComma ++ )
                *pchComma = '\0' ;
        }
        if( (*pchDest = *pch) == '\0' ) {
#if 0
            if( ++c == cArgs ) {
                break ;
            }   else    {
                while( pch[1] == '\0' ) pch++ ;
            }
#endif
            while( pch[1] == '\0' && pch < pchEnd )     pch++ ;
        }
    }
    *pchDest++ = '\0' ;
//  *pchDest++ = '\0' ;

    //
    //  Verify that it is double NULL terminated !
    //
    _ASSERT( pchDest[-3] != '\0' ) ;
    _ASSERT( pchDest[-2] == '\0' ) ;
    _ASSERT( pchDest[-1] == '\0' ) ;

    return  argv[0] ;
}

BOOL
FValidateXreplicArgs(   PNNTP_SERVER_INSTANCE pInstance, LPMULTISZ   multisz )   {

    LPSTR   lpstr = multisz ;
    CNewsTree* pTree = pInstance->GetTree();
    while( *lpstr ) {

        //
        //  appears from RFC's that ':' may separate arguments as well as '/''s.
        //
        char*   pchColon = strchr( lpstr, '/' ) ;
        if( pchColon == 0 )
            pchColon = strchr( lpstr, ':' ) ;

        if( pchColon == 0 )
            return  FALSE ;
        else    {
            int i=1 ;
            while( pchColon[i] != '\0' ) {
                if( !isdigit( (UCHAR)pchColon[i] ) ) {
                    return  FALSE ;
                }
                i++ ;
            }
            if( i==1 )
                return  FALSE ;
        }

        *pchColon = '\0' ;
        if( !fTestComponents( lpstr ) ) {
            *pchColon = ':' ;
            return  FALSE ;
        } else {
            //
            //  CreateGroup will create this group if it does not exist
            //
            //  BUGBUG: KangYan: don't know what this function is used for,
            //  Whether we should pass NULL / FALSE to give system access rights
            //  or extract htoken / fAnonymous from pInstance
    		if( pTree->CreateGroup( lpstr, FALSE, NULL, FALSE ) )	{
#ifdef DEBUG	
				CGRPPTR p = pTree->GetGroupPreserveBuffer(lpstr, lstrlen(lpstr) + 1);
				_ASSERT(p != NULL);
#endif
		    }
        }
        *pchColon = ':' ;

        lpstr += lstrlen( lpstr ) + 1 ;
    }
    return  TRUE ;
}

CIOExecute*
CXReplicCmd::make(  int cArgs,
                    char**  argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CXReplicCmd object.    CXReplicCmd derives from CReceiveArticle
    which does most of the work.

Arguments :

    Same as CCmd::make.

Return Value :

    A CXReplicCmd if possible, otherwise an appropriate CErrorCmd object.

--*/

    InterlockedIncrementStat( (context.m_pInstance), XReplicCommands );

    //
    //  This function will build a CXReplic command object.
    //  We will use ConditionArgs() to convert the user provided arguments
    //  into something a feed object can take.
    //

    if( cArgs == 1 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
    }   else    if( !context.m_pInFeed->fIsXReplicLegal() )     {
        context.m_return.fSet( nrcNoAccess ) ;
		context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) )  {
        context.m_return.fSet( nrcPostingNotAllowed ) ;
		context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {
        LPMULTISZ   lpstrArgs = ::ConditionArgs( cArgs-1, &argv[1], TRUE ) ;
        if( lpstrArgs == 0 ) {
            context.m_return.fSet( nrcServerFault ) ;
        }

        if( !FValidateXreplicArgs( context.m_pInstance, lpstrArgs ) ) {
            context.m_return.fSet( nrcTransferFailedGiveUp, nrcSyntaxError, "Illegal Xreplic Line" ) ;
        }   else    {
            CXReplicCmd*    pXReplic = new CXReplicCmd( lpstrArgs ) ;

            //
            //  NOTE : if the Init call fails it will delete the CXReplicCmd object
            //  itself !
            //

            if( pXReplic && pXReplic->Init( context, driver ) ) {
                return  pXReplic ;
            }   else    {
                context.m_return.fSet( nrcServerFault ) ;
            }
        }
    }
	context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
    pExecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

CXReplicCmd::CXReplicCmd( LPMULTISZ lpstrArgs ) : CReceiveArticle( lpstrArgs) {
}

char*
CXReplicCmd::GetPostOkString()  {
    //
    //  Return the 'command succeeded send more data' string appropriate to the XREPLIC cmd.
    //
    return  "335 - XReplic accepted - terminate article with period\r\n" ;
}

DWORD
CXReplicCmd::FillLogString( BYTE*   pbCommandLog,   DWORD   cbCommandLog )  {

    _ASSERT( pbCommandLog != 0 ) ;
    _ASSERT( cbCommandLog > 0 ) ;

    static  char    szXreplic[] = "xreplic" ;
    DWORD   cbToCopy = (DWORD)min( cbCommandLog, sizeof( szXreplic )-1 ) ;
    CopyMemory( pbCommandLog, szXreplic, cbToCopy ) ;
    return  cbToCopy ;
}


CIOExecute*
CIHaveCmd::make(    int cArgs,
                    char**  argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CXReplicCmd object.    CXReplicCmd derives from CReceiveArticle
    which does most of the work.

Arguments :

    Same as CCmd::make.

Return Value :

    A CXReplicCmd if possible, otherwise an appropriate CErrorCmd object.

--*/

    //
    //  This function will build a CXReplic command object.
    //  We will use ConditionArgs() to convert the user provided arguments
    //  into something a feed object can take.
    //

    BOOL    fFoundArticle = FALSE ;
	BOOL	fFoundHistory = FALSE ;

    InterlockedIncrementStat( (context.m_pInstance), IHaveCommands );

    if( cArgs != 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
    }   else    if( !context.m_pInFeed->fIsIHaveLegal() )   {
        context.m_return.fSet( nrcNoAccess ) ;
		context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) )  {
        context.m_return.fSet( nrcPostingNotAllowed ) ;
		context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {

        //if( *argv[1] != '<' || argv[1][ lstrlen( argv[1] ) - 1 ] != '>' ) {
        if( !FValidateMessageId( argv[1] ) ) {

            context.m_return.fSet( nrcNotWanted ) ;

        }   else    {
            ARTICLEID   artid ;
            GROUPID     groupid ;
            WORD        HeaderOffset ;
            WORD        HeaderLength ;
			CStoreId storeid;

            if( !(fFoundArticle =
                    (context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                            argv[1],
                                                            HeaderOffset,
                                                            HeaderLength,
                                                            artid,
                                                            groupid,
															storeid)) &&
                GetLastError() == ERROR_FILE_NOT_FOUND &&
                !(fFoundHistory = (context.m_pInstance)->HistoryTable()->SearchMapEntry( argv[1] )) ) {

                LPMULTISZ   lpstrArgs = ::ConditionArgs( cArgs-1, &argv[1] ) ;
                if( lpstrArgs == 0 ) {
                    context.m_return.fSet( nrcServerFault ) ;
                }

                CIHaveCmd*  pIHave = new CIHaveCmd( lpstrArgs ) ;

                //
                //  Note : if the Init() call fails the object will delete itself !
                //

                if( pIHave && pIHave->Init( context, driver ) ) {
                    return  pIHave ;
                }   else    {
                    context.m_return.fSet( nrcServerFault ) ;
                }
            }   else if( fFoundArticle || fFoundHistory )   {

				//
				//	set dwLast so transaction logs pickup extra code !!
				//

				if( fFoundArticle ) {
					context.m_dwLast = nrcMsgIDInArticle ;
				}	else	{
					context.m_dwLast = nrcMsgIDInHistory ;
				}

                context.m_return.fSet( nrcNotWanted ) ;

            }   else    {

                context.m_return.fSet( nrcServerFault ) ;

            }
        }
    }
	context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
    pExecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

CIHaveCmd::CIHaveCmd( LPMULTISZ lpstrArgs ) : CReceiveArticle( lpstrArgs) {
}

char*
CIHaveCmd::GetPostOkString()    {
    //
    //  Return the 'command succeeded send more data' string appropriate to the XREPLIC cmd.
    //
    return  "335 - Ihave accepted - terminate article with period\r\n" ;
}

DWORD
CIHaveCmd::FillLogString( BYTE* pbCommandLog,   DWORD   cbCommandLog )  {

    _ASSERT( pbCommandLog != 0 ) ;
    _ASSERT( cbCommandLog > 0 ) ;

    static  char    szIhave[] = "ihave" ;
    DWORD   cbToCopy = (DWORD)min( cbCommandLog, sizeof( szIhave )-1 ) ;
    CopyMemory( pbCommandLog, szIhave, cbToCopy ) ;
    return  cbToCopy ;
}

NRC
CIHaveCmd::ExceedsSoftLimit( PNNTP_SERVER_INSTANCE pInstance )  {

    if( m_lpstrCommand ) {
        FILETIME    FileTime ;
        GetSystemTimeAsFileTime( &FileTime ) ;
        pInstance->HistoryTable()->InsertMapEntry(m_lpstrCommand, &FileTime) ;
    }
    return  nrcTransferFailedGiveUp ;
}




CIOExecute*
CPostCmd::make( int cArgs,
                char**  argv,
                CExecutableCommand*&  pExecute,
                ClientContext&  context,
                class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CPostCmd object.   CPostCmd derives from CReceiveArticle which does most
    of the work.

Arguments :

    Same as CCmd::make.

Return Value :

    A CPostCmd  object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/

    InterlockedIncrementStat( (context.m_pInstance), PostCommands );

    //
    //  Build a CPostCmd object.
    //

    if( cArgs > 1 ) {
        pExecute = new( context ) CUnimpCmd() ;
		context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), nrcPostFailed);
        return  0 ;
    }   else    if( !context.m_pInFeed->fIsPostLegal() )    {
        context.m_return.fSet( nrcNoAccess ) ;
		context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) )  {
        context.m_return.fSet( nrcPostingNotAllowed ) ;
		context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {

        CPostCmd*   pPost = new CPostCmd( 0 ) ;

        if( pPost && pPost->Init(   context, driver ) )     {
            return  pPost ;
        }   else    {

            // CPostCmd destroys iteself if Init() fails ... so just send error!

            context.m_return.fSet( nrcServerFault ) ;
			context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0 ;
        }
    }
	// we shouldn't reach this... all cases are handled above
	_ASSERT(FALSE);
    return  0 ;
}

char*
CPostCmd::GetPostOkString() {
    return  "340 Continue posting - terminate with period \r\n" ;
}

DWORD
CPostCmd::FillLogString( BYTE*  pbCommandLog,   DWORD   cbCommandLog )  {

    _ASSERT( pbCommandLog != 0 ) ;
    _ASSERT( cbCommandLog > 0 ) ;

    static  char    szPost[] = "post" ;
    DWORD   cbToCopy = (DWORD)min( cbCommandLog, sizeof( szPost )-1 ) ;
    CopyMemory( pbCommandLog, szPost, cbToCopy ) ;
    return  cbToCopy ;
}



CReceiveArticle::CReceiveArticle( LPMULTISZ lpstrArgs, BOOL fPartial ) :
    m_fReadArticleInit( FALSE ),
    m_pWriteResponse( 0 ),
    m_cCompleted( -3 ),     // We issue 3 CIO operations - this value is interlocked incremented
                            // and when the final CIO completes (InterlockedIncrement returns 0)
                            // we can move onto the next state !
    m_cFirstSend( -2 ),
    m_pDriver( 0 ),
    m_fPartial( fPartial ),
    m_lpstrCommand( lpstrArgs ),
	m_lpvFeedContext( 0 ),
	m_pContext( 0 )	{

    TraceFunctEnter( "CReceiveArticle::CReceiveArticle" ) ;

    //
    //  This constructor sets all fields to illegal values except m_lpstrCommand and m_fPartial
    //  All other fields should be set up by a call to Init().
    //
}

void
CReceiveArticle::Shutdown(  CIODriver&  driver,
                            CSessionSocket* pSocket,
                            SHUTDOWN_CAUSE  cause,
                            DWORD           dwError ) {

    TraceFunctEnter( "CReceiveArticle::Shutdown" ) ;

    DebugTrace( (DWORD_PTR)this, "Shutdown cause %d pSocket %x driver %x",
        cause, pSocket, &driver ) ;

    if( cause != CAUSE_NORMAL_CIO_TERMINATION && !m_fReadArticleInit )  {

    }
    if( cause != CAUSE_NORMAL_CIO_TERMINATION && pSocket != 0 )
        pSocket->Disconnect( cause, dwError ) ;
}

CReceiveArticle::~CReceiveArticle() {
/*++

Routine Description :

	If we're shutting down and m_lpvFeedContext isn't NULL then
	some kind of fatal error occurred.  Anyways, we need to make
	sure this thing cleans up after itself !


Arguments :

	None.

Return Value :

	None.

--*/

	if( m_lpvFeedContext != 0 ) {
		_ASSERT( m_pContext != 0 ) ;
		DWORD	dwReturn ;
		CNntpReturn	nntpReturn ;
		m_pContext->m_pInFeed->PostCancel(	
					m_lpvFeedContext,
					dwReturn,
					nntpReturn
					) ;
	}
}

BOOL
CReceiveArticle::Init(  ClientContext&  context,
                        class   CIODriver&  driver ) {

    //
    //  Create necessary files etc... to place article into as it arrives !
    //

    TraceFunctEnter( "CReceiveArticle::Init" ) ;

    _ASSERT (m_pWriteResponse == NULL);

	m_pContext = &context ;
    m_pWriteResponse = new( driver ) CIOWriteLine( this ) ;

    if( m_pWriteResponse != 0 ) {
        return  TRUE ;
    }
    DebugTrace( (DWORD_PTR)this, "cleanup after error - m_pWriteResponse %x", m_pWriteResponse ) ;
    if( m_pWriteResponse != 0 ) {
        CIO::Destroy( m_pWriteResponse, driver ) ;
    }   else    {
        delete  this ;
    }
    return  FALSE ;
}

void
CReceiveArticle::TerminateIOs(  CSessionSocket* pSocket,
                            CIORead*    pRead,
                            CIOWrite*   pWrite )    {

    if( pWrite != 0 )
        pWrite->DestroySelf() ;

    CIOGetArticle*  pGetArticle = (CIOGetArticle*)pRead ;

    pGetArticle->DestroySelf() ;

}


BOOL
CReceiveArticle::StartExecute(
					CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite
					) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //

	if( Start( pSocket, pdriver, pRead, pWrite ) )	{
		if( pWrite ) {
			if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
				return	TRUE ;
			}	else	{
				TerminateIOs( pSocket, pRead, pWrite ) ;
				pRead = 0 ;
			}
		}
	}
	return	FALSE ;
}


BOOL
CReceiveArticle::Start( CSessionSocket* pSocket,
                        CDRIVERPTR& pdriver,
                        CIORead*&   pRead,
                        CIOWrite*&  pWrite ) {

    //
    //  This function is required for all CSessionState derived objects -
    //  we provide the initial CIO's which are issued when this state is started.
    //
    //  In our case we will issue a CIOWriteLine containing our 'command ok send more data' string
    //  and a CIOReadArticle operation to get the anticipated article into a file.
    //

    TraceFunctEnter( "CReceiveArticle::Start" ) ;


    CIOGetArticleEx*  pReadArticle = NULL;
    if( m_pWriteResponse->InitBuffers( pdriver, 200 ) ) {

        char    *szPostOk = GetPostOkString() ;
        DWORD   cbPostOk  = lstrlen( szPostOk ) ;

        char*   lpb = m_pWriteResponse->GetBuff() ;
        CopyMemory( lpb, szPostOk, cbPostOk ) ;
        m_pWriteResponse->AddText( cbPostOk ) ;

        DebugTrace( (DWORD_PTR)this, "About to Init FileChannel - start CIOReadArticle !" ) ;

        PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
        pReadArticle = new( *pdriver ) CIOGetArticleEx( this,
                                            pSocket,
                                            pdriver,
                                            pSocket->m_context.m_pInFeed->cbHardLimit( pInst->GetInstanceWrapper() ),
											szBodySeparator,
											szBodySeparator,
											szEndArticle,
											(m_fPartial) ? szInitial : szEndArticle
											) ;
        if( pReadArticle != 0 ) {
            m_fReadArticleInit = TRUE ;
            pWrite = m_pWriteResponse ;
            pRead = pReadArticle ;
            m_pDriver = pdriver ;
            if( m_pCollector ) {
                ADDI( m_pCollector->m_cbBytesSent, cbPostOk );
            }
            return  TRUE ;
        }
    }
    DebugTrace( (DWORD_PTR)this, "Error starting state - clean up ! m_pWriteResponse %x"
                            " pReadArticle %x",
                m_pWriteResponse, pReadArticle ) ;
    if( m_pWriteResponse )  {
        CIO::Destroy( m_pWriteResponse, *pdriver ) ;
        m_pWriteResponse = 0 ;
    }
    if( pReadArticle ) {
        _ASSERT( !m_fReadArticleInit ) ;
        CIO::Destroy( pReadArticle, *pdriver ) ;
    }
    return  FALSE ;
}


BOOL
CReceiveArticle::SendResponse(  CSessionSocket* pSocket,
                                CIODriver&  driver,
                                CNntpReturn&    nntpReturn
                                )   {
/*++

Routine Description :

    This function exists to check whether it is a good time to send
    the result code of the post to the client.  Our main concern is to make
    sure that our initial 'Ok' response to the command has completed
    before we try do another send.

Arguments :

    pSocket - The socket on which we will send
    nntpReturn - The result of the post operation

Return Value :
    TRUE if we sent the response - caller should clear the nntpReturn object.


--*/

    TraceFunctEnter( "CReceiveArticle::SendResponse" ) ;

    long sign = InterlockedIncrement( &m_cFirstSend ) ;

    if( sign == 0 ) {

        CIOWriteLine    *pWrite = new( driver ) CIOWriteLine(this);
        if (pWrite == NULL) {
			m_pDriver->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
			return FALSE;
        }

        if( !pWrite->InitBuffers( m_pDriver, 200 )  )   {
			m_pDriver->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
			CIO::Destroy(pWrite, driver);
			return FALSE;
        }   else    {

            unsigned    cb ;
            char    *lpb = pWrite->GetBuff( cb ) ;

            int cbOut = _snprintf( lpb, cb, "%03d %s\r\n", nntpReturn.m_nrc,
                            nntpReturn.fIsOK() ? "" : nntpReturn.szReturn() ) ;
            if( cbOut > 0 ) {

                if( m_pCollector ) {
                    ADDI( m_pCollector->m_cbBytesSent, cbOut );
                    pSocket->TransactionLog( m_pCollector,
                                            pSocket->m_context.m_nrcLast,
                                            pSocket->m_context.m_dwLast
                                            ) ;
                }

                pWrite->AddText( cbOut ) ;
                if( !m_pDriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
                    ErrorTrace( (DWORD_PTR)(this), "Failure sending pWrite %x", pWrite ) ;
                    CIO::Destroy( pWrite, driver ) ;
                }

            }   else    {
			    m_pDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
			    CIO::Destroy(pWrite, driver);
			    return FALSE;
            }
        }
    }
    return  sign == 0 ;
}


CIO*
CReceiveArticle::Complete(  CIOWriteLine*,
                            CSessionSocket* pSocket,
                            CDRIVERPTR& pdriver
							) {

    //
    //  One of two CIOWriteLine's issued in this state completed -
    //  Interlock Increment and see whether its time to move onto a new state (CAcceptNNRPD)
    //


    TraceFunctEnter( "CReceiveArticle::Complete CIOWriteLine" ) ;

    if( SendResponse( pSocket, *pdriver, pSocket->m_context.m_return ) )
        pSocket->m_context.m_return.fSetClear() ;

    long    l = InterlockedIncrement( &m_cCompleted ) ;
    _ASSERT( l <= 0 ) ;
    if( l==0 ) {
        _ASSERT( pdriver == m_pDriver ) ;
        CIOREADPTR  pio = GetNextIO() ;

        if( !pdriver->SendReadIO( pSocket, *pio, TRUE ) ) {
            /*delete    pio */;
        }
    }
    return  0 ;
}

extern  DWORD
NetscapeHackFunction(
        LPBYTE      lpbBuffer,
        DWORD       cbBuffer,
        DWORD       cbBufferMax,
        DWORD&      cbNewHeader,
        LPBYTE      szHackString,
        BYTE        szRepairString[2]
        ) ;


BOOL
CReceiveArticle::NetscapeHackPost(	
					CSessionSocket*	pSocket,
					CBUFPTR&	pBuffer,
					HANDLE		hToken,
					DWORD		ibStart,
					DWORD		cb	
					)	{
/*++

Routine Description :

	This function deals with postings that apparently don't have
	a body separator.  It may be that they come from badly behaved
	clients that insert LFLF to separate the body instead of
	CRLFCRLF (Netscape does this in one version, with small
	cancel articles).

Arguments :

	pBuffer - the buffer containing the message !
	ibStart - offset into buffer where data starts !
	cb		-	Number of bytes in the article

Return Value :

	NNTP return code !

--*/
	//
	//	The article terminated abruptly with a CRLF.CRLF
	//	This will probably be a failed post, HOWEVER - it
        //      could be that it is a cancel message
	//	from a netscape client.
	//
	NRC		nrcResult = nrcOK ;
	BOOL	fSuccess = FALSE ;
	BOOL	fRtn = FALSE ;
	LPSTR	pchHeader = &pBuffer->m_rgBuff[ibStart] ;
	DWORD	cbTotalBuffer = pBuffer->m_cbTotal - ibStart ;
	DWORD   cbNewHeader = 0 ;
	DWORD	cbNetscape =
		NetscapeHackFunction(
						(LPBYTE)pchHeader,
						cb,
						cbTotalBuffer,
						cbNewHeader,
						(LPBYTE)"\n\n",
						(LPBYTE)"\r\n"
						) ;
	if( cbNetscape != 0 ) {
		//
		//	Attempt to deal with the article - the only thing is
		//	in memory buffers, and we should so if we can process it !
		//
		DWORD	cbArticle = cb ;
		DWORD	cbBody = cbNetscape - cbNewHeader ;
		DWORD	cbAllocated = 0 ;
		LPVOID	lpvPostContext = 0 ;
		CBUFPTR	pBody = new( (int)cbBody, cbAllocated )	CBuffer( cbAllocated ) ;
		if( pBody ) 	{
			//
			//	If we get to this point, we've succeeded - we've totally handled the
			//	post and managed the nntp return codes !
			//
			fRtn = TRUE ;
			//
			//	Copy the body into this buffer !
			//
			CopyMemory(	pBody->m_rgBuff,
						&pBuffer->m_rgBuff[ibStart+cbNewHeader],
						cbBody
						) ;

        	//
        	// Allocate room in the log buffer for the list of newsgroups
        	// (Max is 256 characters -- we'll grab 200 of them if we can)
        	// If we fail, we just pass NULL to PostEarly
        	//

        	DWORD cbNewsgroups;
        	BYTE* pszNewsgroups;
        	for (cbNewsgroups=200; cbNewsgroups>0; cbNewsgroups--) {
	            pszNewsgroups = pSocket->m_Collector.AllocateLogSpace(cbNewsgroups);
        	    if (pszNewsgroups) {
	                break;
        	    }
        	}

			//
			//	Now post the article !
			//

			PNNTP_SERVER_INSTANCE pInstance = pSocket->m_context.m_pInstance;
			ClientContext*  pContext = &pSocket->m_context ;
			BOOL	fAnon = pSocket->m_context.m_pInFeed->fDoSecurityChecks() ;
			DWORD	ibOut = 0 ;
			DWORD	cbOut = 0 ;
			FIO_CONTEXT*	pFIOContext = 0 ;
			fSuccess = pSocket->m_context.m_pInFeed->PostEarly(
							pInstance->GetInstanceWrapper(),
							&pContext->m_securityCtx,
							&pContext->m_encryptCtx,
							pContext->m_securityCtx.IsAnonymous(),
							m_lpstrCommand,
							pBuffer,
							ibStart,
							cbNewHeader,
							&ibOut,
							&cbOut,
							&pFIOContext,
							&lpvPostContext,
							pSocket->m_context.m_dwLast,
							pSocket->GetClientIP(),
							pSocket->m_context.m_return,
							(char*)pszNewsgroups,
							cbNewsgroups
							) ;

            //
            // Add the list of newsgroups to the log structure
            //

            if (pszNewsgroups) {
                pSocket->m_Collector.ReferenceLogData(LOG_TARGET, pszNewsgroups);
            }

			pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
			_ASSERT( (lpvPostContext == 0 && !fSuccess ) || (fSuccess && lpvPostContext != 0) ) ;
			//
			//	Looks like we can post the article - if so
			//	lets try to write it to disk !
			//
			if( fSuccess ) 	{
				//
				//	Successfully posted the article - we can now write the bytes !
				//
				HANDLE	hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ) ;
				if( pFIOContext && hEvent ) 	{
					OVERLAPPED	ovl ;
					ZeroMemory( &ovl, sizeof( ovl ) ) ;
					ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x00000001);
					DWORD	cbWritten = 0 ;
					BOOL fWrite = WriteFile(	
								pFIOContext->m_hFile,
								pBuffer->m_rgBuff + ibOut,
								cbOut,
								&cbWritten,
								&ovl
								) ;
					if( !fWrite && GetLastError() == ERROR_IO_PENDING ) 	{
						fWrite = GetOverlappedResult(	pFIOContext->m_hFile,
														&ovl,
														&cbWritten,
														FALSE
														) ;
					}
					if(	fWrite ) 	{
						_ASSERT( cbWritten == cbOut ) ;
						ZeroMemory( &ovl, sizeof( ovl ) ) ;
						ovl.Offset = cbWritten ;
						ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x00000001);
						fWrite = WriteFile(	pFIOContext->m_hFile,
											pBody->m_rgBuff,
											cbBody,
											&cbWritten,
											&ovl
											) ;
						if( !fWrite && GetLastError() == ERROR_IO_PENDING ) 	{
							fWrite = GetOverlappedResult(	pFIOContext->m_hFile,
															&ovl,
															&cbWritten,
															FALSE
															) ;
						}
					}
					//
					//	Well we tried to write the posting to disk - complete
                                        //      the posting path for this one
					//
					if( fWrite )	{
						fSuccess = pSocket->m_context.m_pInFeed->PostCommit(
						                pSocket->m_context.m_pInstance->GetInstanceWrapper(),
										lpvPostContext,
										hToken,
										pSocket->m_context.m_dwLast,
										pSocket->m_context.m_return,
										pSocket->m_context.m_securityCtx.IsAnonymous()
										) ;
						pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
						lpvPostContext = 0 ;
					}	
				}
				//
				//	Cleanup stuff we don't need anymore !
				//
				if( hEvent )
					CloseHandle( hEvent ) ;

			}
			//
			//	Fall through to here - if an error occurs cancel the posting
			//	a successfull run through the above code would set
			//	lpvPostContext back to NULL !
			//
			if( lpvPostContext != 0 ) 	{
				fSuccess = pSocket->m_context.m_pInFeed->PostCancel(	
										lpvPostContext,
										pSocket->m_context.m_dwLast,
										pSocket->m_context.m_return
										) ;
				pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
			}
		}	
		nrcResult = nrcOK ;
	}
	return	fRtn;
}



CIO*
CReceiveArticle::Complete(  CIOGetArticleEx*  pReadArticle,
                            CSessionSocket* pSocket,
							BOOL	fGoodMatch,
							CBUFPTR&		pBuffer,
							DWORD			ibStart,
							DWORD			cb
							)	{
    //
    //  We have completed reading the file sent by the client.
    //  Pass it to the feed object for processing and then send the necessary response.
    //  Finally, check whether its time to move onto a new state.
    //
    //


	_ASSERT( m_pContext != 0 ) ;
	_ASSERT( m_pContext == &pSocket->m_context ) ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOReadArticle" ) ;

    DWORD   cbGroups = 0 ;
    BYTE*   pchGroups = 0 ;
    DWORD   cbMessageId = 0 ;
    BYTE*   pchMessageId = 0 ;

    BOOL    fSuccess= FALSE ;
	DWORD	ibOut = 0 ;
	DWORD	cbOut = 0 ;
	HANDLE	hFile = INVALID_HANDLE_VALUE ;
	HANDLE	hToken = 0 ;

	NRC	nrcResult = nrcOK ;

	if( !fGoodMatch ) 	{
		nrcResult = nrcArticleIncompleteHeader ;
		pSocket->m_context.m_dwLast = nrcResult ;
		BOOL	fDoBadArticle = TRUE ;
		if( FEnableNetscapeHack() )	{
			if ( pSocket->m_context.m_encryptCtx.QueryCertificateToken() ) {
			    hToken = pSocket->m_context.m_encryptCtx.QueryCertificateToken();
			} else {
			    hToken = pSocket->m_context.m_securityCtx.QueryImpersonationToken();
			}
			fDoBadArticle =	!NetscapeHackPost(	pSocket,
											pBuffer,
											hToken,
											ibStart,
											cb
											) ;
		}	
		if( fDoBadArticle )	{
			NRC nrc = BadArticleCode() ;
			pSocket->m_context.m_return.fSet(   nrc,
												nrcResult,
												"Bad Article"
												) ;
			pSocket->m_context.m_nrcLast = nrc ;
			pSocket->m_context.m_dwLast = nrcResult ;
		}
		//
		//	Everything is done at this point - so
		//	send off error codes etc... to client !
		//
		if( SendResponse(   pSocket, *m_pDriver, pSocket->m_context.m_return ) )
			pSocket->m_context.m_return.fSetClear() ;
		// After we finish processing the article - issue the next IO operation !
		long    l = InterlockedIncrement( &m_cCompleted ) ;
		_ASSERT( l <= 0 ) ;
		if( l==0 ) {
			//
			// The ReadArticle has completed - we can start the next state
			//
			CIOREADPTR  pio = GetNextIO() ;
			DebugTrace( (DWORD_PTR)this, "won InterlockedIncrement - pio %x", pio ) ;
			return	pio.Release() ;
		}
		return	0 ;
	}	

   	//
    // Allocate room in the log buffer for the list of newsgroups
   	// (Max is 256 characters -- we'll grab 200 of them if we can)
  	// If we fail, we just pass NULL to PostEarly
   	//

   	DWORD cbNewsgroups;
   	BYTE* pszNewsgroups;
   	for (cbNewsgroups=200; cbNewsgroups>0; cbNewsgroups--) {
        pszNewsgroups = pSocket->m_Collector.AllocateLogSpace(cbNewsgroups);
   	    if (pszNewsgroups) {
            break;
   	    }
   	}

    PNNTP_SERVER_INSTANCE pInstance = pSocket->m_context.m_pInstance;

    ClientContext*  pContext = &pSocket->m_context ;
    BOOL	fAnon = pSocket->m_context.m_pInFeed->fDoSecurityChecks() ;
	FIO_CONTEXT*	pFIOContext;

    fSuccess = pSocket->m_context.m_pInFeed->PostEarly(
                            pInstance->GetInstanceWrapper(),
                            &pContext->m_securityCtx,
                            &pContext->m_encryptCtx,
							pContext->m_securityCtx.IsAnonymous(),
                            m_lpstrCommand,
							pBuffer,
							ibStart,
							cb,
							&ibOut,
							&cbOut,
							&pFIOContext,
							&m_lpvFeedContext,
                            pSocket->m_context.m_dwLast,
                            pSocket->GetClientIP(),
                            pSocket->m_context.m_return,
                            (char*)pszNewsgroups,
                            cbNewsgroups
							) ;
    //
    // Add the list of newsgroups to the log structure
    //

    if (pszNewsgroups) {
        pSocket->m_Collector.ReferenceLogData(LOG_TARGET, pszNewsgroups);
    }

	pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;

    //
    //  The CIOReadArticle call usis responsible for deleting the m_pFileChannel,
    //  (because it was successfully init.)
    //  Get rid of our reference as soon as we're done, because after we
    //  return from this function, the CFileChannel could disappear at any second,
    //  and we may yet be called through our Shutdown() function etc....
    //
    DebugTrace( (DWORD_PTR)this, "Result of post is %x", fSuccess ) ;
	_ASSERT(!fSuccess || pFIOContext != NULL);

	pReadArticle->StartFileIO(
						pSocket,
						pFIOContext,
						pBuffer,
						ibOut,
						cbOut+ibOut,
						szEndArticle,
						szInitial
						) ;
	return	pReadArticle ;
}


CReceiveArticle*
CReceiveComplete::GetContainer()	{
	return	CONTAINING_RECORD( this, CReceiveArticle, m_PostComplete ) ;
}

void
CReceiveComplete::StartPost(	CSessionSocket*	pSocket	)	{
	m_pSocket = pSocket ;
	CReceiveArticle*	pContainer = GetContainer() ;
	pContainer->AddRef() ;
}

void
CReceiveComplete::Destroy()	{
	CReceiveArticle*	pContainer = GetContainer() ;
	pContainer->Complete( m_pSocket, SUCCEEDED( GetResult() ) ) ;
	if( pContainer->RemoveRef() < 0 ) 	{
		delete	pContainer ;
	}
}

void
CReceiveArticle::Complete(  CIOGetArticleEx*	pReadArticle,
                            CSessionSocket*		pSocket,
							FIO_CONTEXT*		pFIOContext,
							DWORD				cbTransfer
							)	{
    //
    //  We have completed reading the file sent by the client.
    //  Pass it to the feed object for processing and then send the necessary response.
    //  Finally, check whether its time to move onto a new state.
    //
    //

	_ASSERT( pReadArticle != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( m_lpvFeedContext != 0 ) ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOReadArticle" ) ;

	void*	pvContext = 0 ;
	ClientContext*  pContext = &pSocket->m_context ;
	HANDLE  hToken;

	// Due to some header file problems, I can only pass in
	// a hToken handle here.  Since the post component doens't have
	// type information for client context stuff.
	if ( pContext->m_encryptCtx.QueryCertificateToken() ) {
	    hToken = pContext->m_encryptCtx.QueryCertificateToken();
	} else {
	    hToken = pContext->m_securityCtx.QueryImpersonationToken();
	}
	
	m_PostComplete.StartPost( pSocket ) ;

    PNNTP_SERVER_INSTANCE pInstance = ((pSocket->m_context).m_pInstance);
    if ( cbTransfer < pSocket->m_context.m_pInFeed->cbSoftLimit( pInstance->GetInstanceWrapper() ) ||
            pSocket->m_context.m_pInFeed->cbSoftLimit( pInstance->GetInstanceWrapper() ) == 0 ) {
        BOOL	fSuccess = pSocket->m_context.m_pInFeed->PostCommit(
                                pSocket->m_context.m_pInstance->GetInstanceWrapper(),
			    				m_lpvFeedContext,
				    			hToken,
                                pSocket->m_context.m_dwLast,
                                pSocket->m_context.m_return,
                                pSocket->m_context.m_securityCtx.IsAnonymous(),
							    &m_PostComplete
							    ) ;

	    if( !fSuccess ) 	{
		    m_PostComplete.Release() ;
	    }
	} else {

	    //
	    // Cancel the post and set corresponding errors
	    //
	    pSocket->m_context.m_pInFeed->PostCancel(	
										m_lpvFeedContext,
										pSocket->m_context.m_dwLast,
										pSocket->m_context.m_return
										) ;
	    NRC nrc = ExceedsSoftLimit( pInstance );
	    pSocket->m_context.m_return.fSet(   nrc,
	                                        nrcArticleTooLarge,
	                                        "The Article is too large" );
	    pSocket->m_context.m_dwLast = nrcArticleTooLarge;
	    m_PostComplete.Release();
	}
}

void
CReceiveArticle::Complete(	CSessionSocket*	pSocket,
							BOOL			fSuccess
							)	{

	TraceFunctEnter( "CReceiveArticle::Complete" ) ;

	pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
	m_lpvFeedContext = 0 ;

	//ReleaseContext( pFIOContext ) ;
    //
    //  The CIOReadArticle call usis responsible for deleting the m_pFileChannel,
    //  (because it was successfully init.)
    //  Get rid of our reference as soon as we're done, because after we
    //  return from this function, the CFileChannel could disappear at any second,
    //  and we may yet be called through our Shutdown() function etc....
    //
    DebugTrace( (DWORD_PTR)this, "Result of post is %x", fSuccess ) ;

    if( SendResponse(   pSocket, *m_pDriver, pSocket->m_context.m_return ) )
        pSocket->m_context.m_return.fSetClear() ;

    // After we finish processing the article - issue the next IO operation !
    long    l = InterlockedIncrement( &m_cCompleted ) ;
    _ASSERT( l <= 0 ) ;
    if( l==0 ) {
        //
        // The ReadArticle has completed - we can start the next state
        //
        CIOREADPTR  pio = GetNextIO() ;

        DebugTrace( (DWORD_PTR)this, "won InterlockedIncrement - pio %x", pio ) ;

        if( !m_pDriver->SendReadIO( pSocket, *pio, TRUE ) ) {
            /*delete    pio */;
        }
    }


}



CIO*
CReceiveArticle::Complete(  CIOGetArticleEx*	pReadArticle,
                            CSessionSocket*		pSocket
							)	{
/*++

Routine Description :

	This function is called when we complete receiving an article
	which has failed to post.
	We just need to send the error code.

Arguments :

	pReadArticle - the CIO used to receive the article
	pSocket - the socket we're working for !

Return Value :

	NULL

--*/

	_ASSERT( pReadArticle != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( m_lpvFeedContext == 0 ) ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOGetArticleEx - no article" ) ;

    if( SendResponse(   pSocket, *m_pDriver, pSocket->m_context.m_return ) )
        pSocket->m_context.m_return.fSetClear() ;

	CIOREADPTR	pio = 0 ;
    // After we finish processing the article - issue the next IO operation !
    long    l = InterlockedIncrement( &m_cCompleted ) ;
    _ASSERT( l <= 0 ) ;
    if( l==0 ) {
        //
        // The ReadArticle has completed - we can start the next state
        //
        pio = GetNextIO() ;
        DebugTrace( (DWORD_PTR)this, "won InterlockedIncrement - pio %x", pio ) ;
    }
	return	pio.Release() ;
}

CPostCmd::CPostCmd( LPMULTISZ   lpstrArg    ) : CReceiveArticle( lpstrArg, FALSE )  {
}

CAcceptArticle::CAcceptArticle( LPMULTISZ   lpstrArgs,
								ClientContext*	pContext,
                                BOOL        fPartial ) :
    m_lpstrCommand( lpstrArgs ),
    m_fPartial( fPartial ),
	m_pContext( pContext ),
	m_lpvFeedContext( 0 )	 {

	_ASSERT( pContext != 0 ) ;

}

CAcceptArticle*
CAcceptComplete::GetContainer()	{
	return	CONTAINING_RECORD( this, CAcceptArticle, m_PostCompletion ) ;
}

void
CAcceptComplete::StartPost(	CSessionSocket*	pSocket	)	{
	m_pSocket = pSocket ;
	CAcceptArticle*	pContainer = GetContainer() ;
	pContainer->AddRef() ;
}

void
CAcceptComplete::Destroy()	{
	CAcceptArticle*	pContainer = GetContainer() ;
	pContainer->Complete( m_pSocket, SUCCEEDED( GetResult() ) ) ;
	if( pContainer->RemoveRef() < 0 ) 	{
		delete	pContainer ;
	}
}






CAcceptArticle::~CAcceptArticle() {
	if( m_lpvFeedContext != 0 ) {
		_ASSERT( m_pContext != 0 ) ;
		DWORD	dwReturn ;
		CNntpReturn	nntpReturn ;
		m_pContext->m_pInFeed->PostCancel(	
					m_lpvFeedContext,
					dwReturn,
					nntpReturn
					) ;
	}
}



BOOL
CAcceptArticle::StartExecute(
					CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite
					) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //

	if( Start( pSocket, pdriver, pRead, pWrite ) )	{
		if( pWrite ) {
			if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
				TerminateIOs( pSocket, pRead, pWrite ) ;
				pRead = 0 ;
				return	FALSE ;
			}
		}
		return	TRUE ;
	}
	return	FALSE ;
}


BOOL
CAcceptArticle::Start(  CSessionSocket* pSocket,
                        CDRIVERPTR&     pdriver,
                        CIORead*&       pRead,
                        CIOWrite*&      pWrite
                        ) {

	static	char	szBodySeparator[] = "\r\n\r\n" ;

	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( m_pContext != 0 ) ;

    _ASSERT( pRead == 0 ) ;
    _ASSERT( pWrite == 0 ) ;

    m_pDriver = pdriver ;

	//
	//	bugbug - need to handle partial articles and the like here !
	//

    PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
    pRead = new( *pdriver ) CIOGetArticleEx(
										this,
                                        pSocket,
                                        pdriver,
                                        pSocket->m_context.m_pInFeed->cbHardLimit( pInst->GetInstanceWrapper() ),
										szBodySeparator,
										szBodySeparator,
										szEndArticle,
										(m_fPartial) ? szInitial : szEndArticle
                                        ) ;

    return  pRead != 0 ;
}


CIO*
CAcceptArticle::Complete(   CIOWriteLine*,
                            CSessionSocket* pSocket,
                            CDRIVERPTR& pdriver
							) {

    TraceFunctEnter( "CAcceptArticles::Complete CIOWriteLine" ) ;

    //
    //  Clear any return code we may have had !
    //
    pSocket->m_context.m_return.fSetClear() ;

    CIOREADPTR  pio = GetNextIO() ;
    if( !pdriver->SendReadIO( pSocket, *pio, TRUE ) ) {
        /*delete    pio */;
    }
    return  0 ;
}




CIO*
CAcceptArticle::Complete(	CIOGetArticleEx*  pReadArticle,
							CSessionSocket* pSocket,
							BOOL	fGoodMatch,
							CBUFPTR&		pBuffer,
							DWORD			ibStart,
							DWORD			cb
							)	{
    //
    //  We have completed reading the file sent by the client.
    //  Pass it to the feed object for processing and then send the necessary response.
    //  Finally, check whether its time to move onto a new state.
    //
    //

	static	char	szEndArticle[] = "\r\n.\r\n" ;
	static	char	*szInitial = szEndArticle + 2 ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOReadArticle" ) ;

    DWORD   cbGroups = 0 ;
    BYTE*   pchGroups = 0 ;
    DWORD   cbMessageId = 0 ;
    BYTE*   pchMessageId = 0 ;

	if( !fGoodMatch ) 	{
		NRC	nrcResult = nrcArticleIncompleteHeader ;
		NRC nrc = BadArticleCode() ;
		pSocket->m_context.m_return.fSet(   nrc,
											nrcResult,
											"Bad Article"
											) ;
		pSocket->m_context.m_nrcLast = nrc ;
		pSocket->m_context.m_dwLast = nrcResult ;
		//
		//	Everything is done at this point - so
		//	send off error codes etc... to client !
		//

		if( !SendResponse(  pSocket,
							*m_pDriver,
							pSocket->m_context.m_return,
							((pchMessageId && *pchMessageId != '\0') ?
							(LPCSTR)pchMessageId :
								(m_lpstrCommand ? m_lpstrCommand : "NULL" ))
							) ) {

			pSocket->m_context.m_return.fSetClear() ;
			m_pDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, pSocket->m_context.m_return.m_nrc ) ;
		}
		return	0 ;
	}

	//
	// Allocate room in the log buffer for the list of newsgroups
	// (Max is 256 characters -- we'll grab 200 of them if we can)
	// If we fail, we just pass NULL to PostEarly
	//

    DWORD cbNewsgroups;
    BYTE* pszNewsgroups;
    for (cbNewsgroups=200; cbNewsgroups>0; cbNewsgroups--) {
        pszNewsgroups = pSocket->m_Collector.AllocateLogSpace(cbNewsgroups);
        if (pszNewsgroups) {
            break;
        }
   	}

    BOOL    fSuccess= FALSE ;
	DWORD	ibOut = 0 ;
	DWORD	cbOut = 0 ;
	PFIO_CONTEXT pFIOContext = 0 ;

    BOOL    fTransfer = FAllowTransfer( pSocket->m_context ) ;
	if( fTransfer ) 	{
		PNNTP_SERVER_INSTANCE pInstance = pSocket->m_context.m_pInstance;
		ClientContext*  pContext = &pSocket->m_context ;
		BOOL	fAnon = pSocket->m_context.m_pInFeed->fDoSecurityChecks() ;
		fSuccess = pSocket->m_context.m_pInFeed->PostEarly(
							pInstance->GetInstanceWrapper(),
							&pContext->m_securityCtx,
							&pContext->m_encryptCtx,
							pContext->m_securityCtx.IsAnonymous(),
							m_lpstrCommand,
							pBuffer,
							ibStart,
							cb,
							&ibOut,
							&cbOut,
							&pFIOContext,
							&m_lpvFeedContext,
							pSocket->m_context.m_dwLast,
							pSocket->GetClientIP(),
							pSocket->m_context.m_return,
							(char*)pszNewsgroups,
							cbNewsgroups,
							FALSE
							) ;
        //
        // Add the list of newsgroups to the log structure
        //
        if (pszNewsgroups) {
            pSocket->m_Collector.ReferenceLogData(LOG_TARGET, pszNewsgroups);
        }
		pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
	}	else	{
		pBuffer = 0 ;
	}

    //
    //  The CIOReadArticle call usis responsible for deleting the m_pFileChannel,
    //  (because it was successfully init.)
    //  Get rid of our reference as soon as we're done, because after we
    //  return from this function, the CFileChannel could disappear at any second,
    //  and we may yet be called through our Shutdown() function etc....
    //
    DebugTrace( (DWORD_PTR)this, "Result of post is %x", fSuccess ) ;

	pReadArticle->StartFileIO(
						pSocket,
						pFIOContext,
						pBuffer,
						ibOut,
						cbOut+ibOut,
						szEndArticle,
						szInitial
						) ;
	return	pReadArticle ;
}

void
CAcceptArticle::Complete(	CIOGetArticleEx*	pReadArticle,
							CSessionSocket*		pSocket,
							FIO_CONTEXT*		pFIOContext,
							DWORD				cbTransfer
							)	{
    //
    //  We have completed reading the file sent by the client.
    //  Pass it to the feed object for processing and then send the necessary response.
    //  Finally, check whether its time to move onto a new state.
    //
    //

	_ASSERT( pReadArticle != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( m_lpvFeedContext != 0 ) ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOReadArticle" ) ;

	void*	pvContext = 0 ;
	ClientContext*  pContext = &pSocket->m_context ;
	HANDLE  hToken;

	// Due to some header file problems, I can only pass in
	// a hToken handle here.  Since the post component doens't have
	// type information for client context stuff.
	if ( pContext->m_encryptCtx.QueryCertificateToken() ) {
	    hToken = pContext->m_encryptCtx.QueryCertificateToken();
	} else {
	    hToken = pContext->m_securityCtx.QueryImpersonationToken();
	}
	
	m_PostCompletion.StartPost( pSocket ) ;

    BOOL	fSuccess = pSocket->m_context.m_pInFeed->PostCommit(
                            pSocket->m_context.m_pInstance->GetInstanceWrapper(),
							m_lpvFeedContext,
							hToken,
                            pSocket->m_context.m_dwLast,
                            pSocket->m_context.m_return,
                            pSocket->m_context.m_securityCtx.IsAnonymous(),
							&m_PostCompletion
							) ;
	if( !fSuccess ) 	{
		//
		//	call this guy so that we send the response for the post !
		//
		m_PostCompletion.Release() ;
	}
}

void
CAcceptArticle::Complete(	CSessionSocket*	pSocket, 
							BOOL	fPostSuccessfull	
							)	{
	TraceFunctEnter( "CAcceptArticle::Complete - pSocket, fPost" ) ;
	m_lpvFeedContext = 0 ;
	pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;

    //
    //  The CIOReadArticle call usis responsible for deleting the m_pFileChannel,
    //  (because it was successfully init.)
    //  Get rid of our reference as soon as we're done, because after we
    //  return from this function, the CFileChannel could disappear at any second,
    //  and we may yet be called through our Shutdown() function etc....
    //
    DebugTrace( (DWORD_PTR)this, "Result of post is %x", fPostSuccessfull ) ;

	LPSTR	pchMessageId = 0 ;

    if( !SendResponse(  pSocket,
                        *m_pDriver,
                        pSocket->m_context.m_return,
						(m_lpstrCommand ? m_lpstrCommand : "NULL" )
                        ) ) {

        pSocket->m_context.m_return.fSetClear() ;
        m_pDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, pSocket->m_context.m_return.m_nrc ) ;
		return	;
    }
}

CIO*
CAcceptArticle::Complete(	CIOGetArticleEx*	pReadArticle,
							CSessionSocket*		pSocket
							)	{
/*++

Routine Description :

	This function is called when we complete receiving an article
	which has failed to post.
	We just need to send the error code.

Arguments :

	pReadArticle - the CIO used to receive the article
	pSocket - the socket we're working for !

Return Value :

	NULL

--*/
    TraceFunctEnter( "CReceiveArticle::Complete CIOGetArticleEx - no article" ) ;


	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pReadArticle != 0 ) ;
	_ASSERT( m_lpvFeedContext == 0 ) ;

	LPSTR	pchMessageId = 0 ;
	pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;

    if( !SendResponse(  pSocket,
                        *m_pDriver,
                        pSocket->m_context.m_return,
						((pchMessageId && *pchMessageId != '\0') ?
							(LPCSTR)pchMessageId :
								(m_lpstrCommand ? m_lpstrCommand : "NULL" ))
                        ) ) {

        pSocket->m_context.m_return.fSetClear() ;
        m_pDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, pSocket->m_context.m_return.m_nrc ) ;
    }
	return	0 ;
}

BOOL
CAcceptArticle::SendResponse(   CSessionSocket* pSocket,
                                CIODriver&  driver,
                                CNntpReturn&    nntpReturn,
								LPCSTR		szMessageId
                                )   {
/*++

Routine Description :

    This function exists to check whether it is a good time to send
    the result code of the post to the client.  Our main concern is to make
    sure that our initial 'Ok' response to the command has completed
    before we try do another send.

Arguments :

    pSocket - The socket on which we will send
    nntpReturn - The result of the post operation

Return Value :
    TRUE if we sent the response - caller should clear the nntpReturn object.


--*/

    TraceFunctEnter( "CAcceptArticles::SendResponse" ) ;

    _ASSERT( m_pDriver ) ;

    CIOWriteLine    *pWrite = new( driver ) CIOWriteLine(this);

    if (pWrite == NULL) {
        m_pDriver->UnsafeClose(pSocket, CAUSE_OOM, 0);
        return FALSE;
    }

    if( !pWrite->InitBuffers( m_pDriver, 200 )  )   {
        m_pDriver->UnsafeClose(pSocket, CAUSE_OOM, 0);
        CIO::Destroy(pWrite, driver);
        return FALSE;
    }   else    {

        unsigned    cb ;
        char    *lpb = pWrite->GetBuff( cb ) ;

        int cbOut = _snprintf( lpb, cb, "%03d %s %s\r\n", nntpReturn.m_nrc, szMessageId,
                        nntpReturn.fIsOK() ? "" : nntpReturn.szReturn() ) ;
        if( cbOut > 0 ) {

            if( m_pCollector ) {
                ADDI( m_pCollector->m_cbBytesSent, cbOut );
                pSocket->TransactionLog( m_pCollector,
                                        pSocket->m_context.m_nrcLast,
                                        pSocket->m_context.m_dwLast
                                        ) ;
            }


            pWrite->AddText( cbOut ) ;
            if( !m_pDriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
                ErrorTrace( (DWORD_PTR)(this), "Failure sending pWrite %x", pWrite ) ;
                CIO::Destroy( pWrite, driver ) ;
            }   else    {
                return  TRUE ;
            }

        }   else    {
            m_pDriver->UnsafeClose(pSocket, CAUSE_UNKNOWN, 0);
            CIO::Destroy(pWrite, driver);
            return FALSE;
        }
    }
    return  FALSE ;
}

void
CAcceptArticle::TerminateIOs(   CSessionSocket* pSocket,
                            CIORead*    pRead,
                            CIOWrite*   pWrite )    {

    if( pWrite != 0 )
        pWrite->DestroySelf() ;

    CIOGetArticle*  pGetArticle = (CIOGetArticle*)pRead ;
    pGetArticle->DestroySelf() ;
}


void
CAcceptArticle::Shutdown(   CIODriver&  driver,
                            CSessionSocket* pSocket,
                            SHUTDOWN_CAUSE  cause,
                            DWORD           dwError ) {

    TraceFunctEnter( "CReceiveArticle::Shutdown" ) ;

    DebugTrace( (DWORD_PTR)this, "Shutdown cause %d pSocket %x driver %x",
        cause, pSocket, &driver ) ;

    if( cause != CAUSE_NORMAL_CIO_TERMINATION && pSocket != 0 )
        pSocket->Disconnect( cause, dwError ) ;
}




CTakethisCmd::CTakethisCmd( LPMULTISZ   lpstrArgs,
							ClientContext*	pContext
							) :
    CAcceptArticle( lpstrArgs, pContext, TRUE ) {
}

CIOExecute*
CTakethisCmd::make(
                int     cArgs,
                char**  argv,
                CExecutableCommand*&  pExecute,
                struct  ClientContext&  context,
                class   CIODriver&      driver
                ) {

    //
    //  If somebody sends a takethis command it doesn't matter what follows -
    //  we will swallow it whole !!
    //

    InterlockedIncrementStat( (context.m_pInstance), TakethisCommands );

    LPMULTISZ   lpstrArgs = 0 ;
    if( cArgs > 1 )
        lpstrArgs = ::ConditionArgs( cArgs-1, &argv[1] ) ;

    CTakethisCmd*   pTakethis =
        new CTakethisCmd( lpstrArgs, &context ) ;

    if( pTakethis ) {
        return  pTakethis ;
    }
    context.m_return.fSet( nrcServerFault ) ;
    pExecute = new( context )   CErrorCmd( context.m_return ) ;
    return   0 ;
}

DWORD
CTakethisCmd::FillLogString(    BYTE*   pbCommandLog,
                                DWORD   cbCommandLog
                                )   {

    return  0 ;
}

BOOL
CTakethisCmd::FAllowTransfer(   ClientContext&  context )   {

    if( !context.m_pInFeed->fIsIHaveLegal() ) {
        context.m_return.fSet( nrcSArticleRejected, nrcNoAccess, "Access Denied" ) ;
        return  FALSE ;
    }

    if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) )   {
        context.m_return.fSet( nrcSNotAccepting ) ;
        return  FALSE ;
    }
    return  TRUE ;
}


CIOExecute*
CQuitCmd::make( int cArgs,
                char**  argv,
                CExecutableCommand*&  pExecute,
                struct ClientContext&   context,
                class   CIODriver&  driver  ) {
/*++

Routine Description :

    Create a CQuitCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CQuitCmd object.

--*/


    //  build a quit command object

    _ASSERT( cArgs >= 1 ) ;
    _ASSERT( lstrcmpi( argv[0], "quit" ) == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), QuitCommands );

    CQuitCmd    *pTmp = new( context ) CQuitCmd() ;
    pExecute = pTmp ;
    return  0 ;
}

int
CQuitCmd::StartExecute( BYTE    *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void    *&pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector ) {

    //
    //  Send the response to the command -
    //  we will blow off the session later.
    //

    char    szQuit[] = "205 closing connection - goodbye!\r\n" ;

    context.m_nrcLast = nrcGoodBye ;

    _ASSERT( cb > sizeof( szQuit ) ) ;
    int cbRtn = sizeof( szQuit ) - 1 ;
    CopyMemory( lpb, szQuit, cbRtn ) ;
    fComplete = TRUE ;

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szQuit, 4 ) ;
    }
    */

    return  cbRtn ;
}

BOOL
CQuitCmd::CompleteCommand(  CSessionSocket* pSocket,
                            ClientContext&  ) {
    //
    //  Kill the session - this is called when we know our write had completed.
    //
    pSocket->Disconnect() ;
    return  FALSE ;
}



//
// local structures for processing AUTHINFO commands
//

typedef struct _AUTH_TABLE {

    //
    // type of command
    //

    AUTH_COMMAND Command;

    //
    // actual command string
    //

    LPSTR CommandString;

    //
    // number of params expected
    //

    DWORD nParams;

} AUTH_TABLE, *PAUTH_TABLE;


//
// Authinfo commands
//

AUTH_TABLE AuthCommandTable[] = {
    { AuthCommandUser, "USER", 3 },
    { AuthCommandPassword, "PASS", 3 },
    { AuthCommandReverse, "REVERSE", 2 },
    { AuthCommandTransact, "GENERIC", 3 },
    { AuthCommandTransact, "TRANSACT", 3 },
    { AuthCommandInvalid, NULL, 0 }
    };

//
// Reply strings
//

typedef struct _AUTH_REPLY {
    LPSTR Reply;
    DWORD Len;
    NRC   nrc;
} AUTH_REPLY, *PAUTH_REPLY;


AUTH_REPLY SecReplies[] = {
    { "281 Authentication ok\r\n", 0, nrcLoggedOn },
    { "281 Authentication ok.  Logged on as Guest.\r\n", 0, nrcLoggedOn },
    { "381 Protocol supported, proceed\r\n", 0, nrcPassRequired },
    { "381 Waiting for password\r\n", 0, nrcPassRequired },
    { "500 Bad Command\r\n", 0, nrcNotRecognized },
    { "501 Syntax Error\r\n", 0, nrcSyntaxError },
    { "502 Permission denied\r\n", 0, nrcNoAccess },
    { "503 Give username first\r\n", 0, nrcServerFault },
    { "451 System Problem\r\n", 0, nrcLogonFailure  },
    { "480 Authorization required\r\n", 0, nrcLogonRequired },
    { "485 MSN NTLM BASIC\r\n", 0, nrcSupportedProtocols },
    { NULL, 0, nrcServerFault }
    };



CAuthinfoCmd::CAuthinfoCmd() {
    m_authCommand = AuthCommandInvalid;
}

CIOExecute*
CAuthinfoCmd::make(
        int cArgs,
        char **argv,
        CExecutableCommand*& pExecute,
        ClientContext&  context,
        class   CIODriver&  driver
        )
{
    DWORD i;
    CAuthinfoCmd *pTmp = new( context ) CAuthinfoCmd() ;
    ENTER("AuthInfoCmd Make")

    //
    // Has to have at least 1 param
    //

    if ( cArgs < 2 ) {

        ErrorTrace(0,"No params in authinfo");
        context.m_return.fSet( nrcSyntaxError ) ;
        goto cleanup;
    }

    DebugTrace(0,"auth info command is %s",argv[1]);

    //
    // Check command
    //

    if ( pTmp != NULL ) {

        for (i=0; AuthCommandTable[i].CommandString != NULL ;i++) {
            if( lstrcmpi( AuthCommandTable[i].CommandString, argv[1] ) == 0 ) {
                if ( cArgs < (INT)AuthCommandTable[i].nParams ) {

                    //
                    //  Handle 'Authinfo Transact' in a special manner
                    //
                    if( AuthCommandTable[i].Command == AuthCommandTransact &&
                        cArgs == 2 ) {

                        char    szPackageBuffer[256] ;
                        ZeroMemory( szPackageBuffer, sizeof( szPackageBuffer ) ) ;
                        DWORD   nbytes = sizeof( szPackageBuffer )-1 ;

						(context.m_pInstance)->LockConfigRead();
                        if( (context.m_securityCtx).GetInstanceAuthPackageNames( (BYTE*)szPackageBuffer, &nbytes, PkgFmtCrLf ) ) {

                            context.m_return.fSet( nrcLoggedOn, szPackageBuffer ) ;

                        }   else    {

                            context.m_return.fSet( nrcServerFault ) ;

                        }
						(context.m_pInstance)->UnLockConfigRead();

                        goto    cleanup ;
                    }

                    ErrorTrace(0,"Insufficient params (%d) in authinfo %s",
                        cArgs,argv[1]);

                    context.m_return.fSet( nrcSyntaxError ) ;
                    goto cleanup;
                }

                pTmp->m_authCommand = AuthCommandTable[i].Command;

                break;
            }
        }

        //
        // if command illegal, clean up
        //

        if ( pTmp->m_authCommand == AuthCommandInvalid ) {
            ErrorTrace(0,"Invalid authinfo command %s",argv[1]);
            context.m_return.fSet( nrcSyntaxError ) ;
            if ( pTmp != NULL ) {
                goto    cleanup ;
            }
        } else {

            //
            // Get the blob
            //

            pTmp->m_lpstrBlob = argv[2] ;

        }
    }

    pExecute = pTmp ;
    return  0 ;

cleanup:
    delete  pTmp ;
    pExecute = new( context ) CErrorCmd( context.m_return ) ;
    return  0 ;
}

int
CAuthinfoCmd::StartExecute(
        BYTE *lpb,
        int cb,
        BOOL &fComplete,
        void *&pv,
        ClientContext&  context,
        CLogCollector*  pCollector
        )
{
    DWORD nbytes;
    DWORD cbPrefix = 0;
    REPLY_LIST  replyId;
    BOOL        f;

    // Handle default domain case.
    CHAR	szTmp[MAX_USER_NAME_LEN + MAX_DOMAIN_NAME + 2];
    LPSTR	lpTmp = NULL;
    int iRet = 0;


    CSecurityCtx *sec = &context.m_securityCtx;
    ENTER("AuthInfoCmd::StartExecute")

    _ASSERT(m_authCommand != AuthCommandInvalid);

    // if no logon domain is present in user name, and default
    // logon domain is set, then prepend default logon domain to username
    if (m_authCommand == AuthCommandUser)
    {
        if (m_lpstrBlob && m_lpstrBlob[0] != '\0' 
            && !strchr(m_lpstrBlob, '/') && !strchr(m_lpstrBlob, '\\') 
            && (context.m_pInstance->QueryAuthentInfo())->strDefaultLogonDomain.QueryCCH() > 0)
        {
            LPSTR lpstr = (context.m_pInstance->QueryAuthentInfo())->strDefaultLogonDomain.QueryStr();

            lpTmp = (LPSTR) szTmp;
            

            if (lpstr[0] == '\\' && lpstr[1] == '\0')
            {
                // all trusted domains
                iRet = _snprintf(lpTmp, sizeof(szTmp), "/%s", m_lpstrBlob);
                lpTmp[sizeof(szTmp)-1] = '\0';
            }
            else
            {
                iRet = _snprintf(lpTmp, sizeof(szTmp), "%s/%s", lpstr, m_lpstrBlob);
                lpTmp[sizeof(szTmp)-1] = '\0';
            }
        }
        else
            lpTmp = m_lpstrBlob;
    }
    else
        lpTmp = m_lpstrBlob;	

    //
    // Pass this off to our processor
    //
    SetLastError( NO_ERROR ) ;
        
    // if iRet < 0, the authinfo user string is too long. return with error immediately
    if (iRet < 0)
    {
        if ( sec->IsAuthenticated() )
        {
            context.DecrementUserStats();
        }
        sec->Reset();    
        lstrcpy( (LPSTR)lpb, SecReplies[SecSyntaxErr].Reply );
        nbytes = lstrlen( (LPSTR)lpb );
        context.m_nrcLast = SecReplies[SecSyntaxErr].nrc ;
        context.m_dwLast = ERROR_BUFFER_OVERFLOW;

        fComplete = TRUE ;
        return(nbytes);
    }
    //
    // if we're already logged in as some user dec the stats
    // ProcessAuthInfo will reset the session on the first call
    //
    if ( sec->IsAuthenticated() )
    {
        context.DecrementUserStats();
    }

    nbytes = cb;
    (context.m_pInstance)->LockConfigRead();
    f = sec->ProcessAuthInfo(
                            context.m_pInstance,
                            m_authCommand,
                            lpTmp,
                            lpb + sizeof("381 ") - 1,
                            &nbytes,
                            &replyId
                            );
    (context.m_pInstance)->UnLockConfigRead();

    //
    // if replyID == SecNull we're conversing for challenge/response logon
    //
    if ( replyId == SecNull )
    {
        _ASSERT( nbytes != 0 );
        _ASSERT( nbytes < cb - sizeof("381 \r\n") );

        context.m_nrcLast = nrcPassRequired ;

        //
        // prepend the protocol specific header
        //
        CopyMemory( lpb, "381 ", sizeof("381 ") - 1 );

        //
        // append the CRLF
        //
        lstrcpy( (LPSTR)lpb + sizeof("381 ") - 1 + nbytes, "\r\n" );
        nbytes += sizeof("381 \r\n") - 1;
    }
    //
    // if replyID == SecProtNS respond with supported protocols.
    //
    else if ( replyId == SecProtNS )
    {

        context.m_nrcLast = nrcSupportedProtocols ;

        CopyMemory( lpb, "485 ", sizeof("485 ") - 1 );

        nbytes = cb - sizeof("485 \r\n");
 		(context.m_pInstance)->LockConfigRead();
       	(context.m_securityCtx).GetAuthPackageNames( lpb + sizeof("485 ") - 1, &nbytes );
		(context.m_pInstance)->UnLockConfigRead();

        lstrcpy( (char*)lpb + sizeof("485 ") - 1 + nbytes, "\r\n" );
        nbytes += sizeof("485 \r\n") - 1;
    }

    else
    {
        _ASSERT( replyId < NUM_SEC_REPLIES );

        lstrcpy( (LPSTR)lpb, SecReplies[replyId].Reply );
        nbytes = lstrlen( (LPSTR)lpb );
        context.m_nrcLast = SecReplies[replyId].nrc ;
        context.m_dwLast = GetLastError() ;

        //
        // inc the perf counters if SecPermissionDenied or proceed prompts
        //
        switch( replyId )
        {
        case SecPermissionDenied:
            IncrementStat( (context.m_pInstance), LogonFailures );
            break;

        case SecProtOk:
        case SecNeedPwd:
            IncrementStat( (context.m_pInstance), LogonAttempts );
            break;
        }
    }

    _ASSERT( nbytes <= (DWORD)cb );

    if ( f == FALSE )
    {
        //
        // if we fail for any reason reset the state to accept user/auth/apop
        //
        sec->Reset();
    }


    //
    // if we're logged in as some user inc the stats
    // ProcessAuthInfo will not set the flag till we're logged on
    //
    if ( sec->IsAuthenticated() )
    {
        context.IncrementUserStats();
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, nbytes-2 ) ;
    }
    */

    fComplete = TRUE ;
    return(nbytes);
}

CIOExecute*
CXOverCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&	pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    CXOverCmd   *pXover;
    CGRPPTR     pGroup;
    //ARTICLEID   artid;
    DWORD       loRange;
    DWORD       hiRange;

    //
    // Has a group been chosen?
    //

    ENTER("XOverCmd::Make")

    InterlockedIncrementStat( (context.m_pInstance), XOverCommands );

    pGroup = context.m_pCurrentGroup ;

    if ( pGroup == 0 ) {

        ErrorTrace(0,"No current group selected");
        context.m_return.fSet( nrcNoGroupSelected );
        pExecute = new( context ) CErrorCmd( context.m_return );
        return 0;
    }

    //
    // Get article range
    //

    loRange = pGroup->GetFirstArticle( );
    hiRange = pGroup->GetLastArticle( );

    //
    // See if we have any articles
    //

    if ( pGroup->GetArticleEstimate() == 0 || loRange > hiRange ) {

        ErrorTrace(0,"No articles in group");
        context.m_return.fSet( nrcNoCurArticle );
        pExecute = new( context ) CErrorCmd( context.m_return );
        return 0;
    }

    _ASSERT( loRange <= hiRange );

    //
    // Get the article number
    //

    if ( argc == 1 ) {

        //
        // Use current article
        //

        if( context.m_idCurrentArticle != INVALID_ARTICLEID ) {

            if( context.m_idCurrentArticle < loRange ||
                context.m_idCurrentArticle > hiRange ) {
                context.m_return.fSet( nrcNoSuchArticle ) ;
                pExecute = new( context )   CErrorCmd( context.m_return ) ;
                return  0 ;
            }

            pXover = new( context ) CXOverCmd( pGroup ) ;
            if ( pXover == 0 ) {
                ErrorTrace(0,"Cannot allocate XOverCmd");
                goto exit;
            }

            pXover->m_Completion.m_currentArticle =
            pXover->m_Completion.m_loArticle =
            pXover->m_Completion.m_hiArticle = context.m_idCurrentArticle;

            pXover->m_pContext = &context;

        }   else    {

            context.m_return.fSet( nrcNoCurArticle ) ;
            pExecute = new( context )   CErrorCmd( context.m_return ) ;
            return  0 ;
        }

        _ASSERT( context.m_idCurrentArticle <= hiRange );
        _ASSERT( context.m_idCurrentArticle >= loRange );

    } else if ( argc == 2 ) {

        //
        // Range is specified, get it
        //
		NRC	code ;

        if ( !GetCommandRange( argc, argv, &loRange, &hiRange, code ) ) {

            //
            // something wrong with the range specified
            //

            ErrorTrace(0,"Range Error %s",argv[1]);
			context.m_return.fSet( code == nrcNotSet ? nrcNoArticleNumber : code );
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0;
        }

        pXover = new( context ) CXOverCmd( pGroup ) ;
        if ( pXover == 0 ) {
            ErrorTrace(0,"Cannot allocate XOverCmd");
            goto exit;
        }

        pXover->m_Completion.m_currentArticle =
        pXover->m_Completion.m_loArticle = loRange;
        pXover->m_Completion.m_hiArticle = hiRange;

        pXover->m_pContext = &context;

    } else {

        ErrorTrace(0,"Syntax Error");
        context.m_return.fSet( nrcSyntaxError ) ;
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }

exit:
    pExecute = (CExecute*)pXover;
    return 0;
}

CXOverAsyncComplete::CXOverAsyncComplete()	:
	m_currentArticle( INVALID_ARTICLEID ),
	m_loArticle( INVALID_ARTICLEID ),
	m_hiArticle( INVALID_ARTICLEID ),
	m_groupHighArticle( INVALID_ARTICLEID ),
	m_lpb( 0 ),
	m_cb( 0 ),
	m_cbPrefix( 0 ) {
}

CXOverCmd*
CXOverAsyncComplete::GetContainer()	{
	return	CONTAINING_RECORD( this, CXOverCmd, m_Completion ) ;
}

void
CXOverAsyncComplete::Destroy()	{
/*++

Routine Description :

	This is called when our last reference goes away.
	We don't destruct ourselves at that point - instead
	we get ready for another round !

	NOTE : We cannot touch any members after calling the
		base classes Complete() function - as we can
		be re-entered for another operation !

Arguments :

	None.


Return Value :

	None

--*/
	
	if(	SUCCEEDED(GetResult()) ) {

		if(	m_currentArticle > m_hiArticle ) {
			m_fComplete = TRUE ;
            CopyMemory( m_lpb+m_cbTransfer, StrTermLine, 3 );
            m_cbTransfer += 3 ;
		}
	    m_cbTransfer += m_cbPrefix ;
	}

	//
	//	When we reset our state we keep our Article Number
	//	and group info - but this buffer stuff is useless now
	//
	m_lpb = 0 ;
	m_cb = 0 ;
	//
	//	Call our base classes completion function ! -
	//	Note if we're note complete we pass TRUE so that
	//	the base class resets for another operation !
	//
	Complete( !m_fComplete ) ;
}

inline	CGRPPTR&
CXOverAsyncComplete::GetGroup()	{
	return		GetContainer()->m_pGroup;
}

CXOverAsyncComplete*
CXOverCacheWork::GetContainer()	{
	return		CONTAINING_RECORD(	this, CXOverAsyncComplete, m_CacheWork ) ;
}

inline	CGRPPTR&
CXOverCacheWork::GetGroup()	{
	CXOverAsyncComplete*	p = GetContainer() ;
	return		p->GetGroup() ;
}

void
CXOverCacheWork::DoXover(	
				ARTICLEID	articleIdLow,
				ARTICLEID	articleIdHigh,
				ARTICLEID*	particleIdNext, 
				LPBYTE		lpb, 
				DWORD		cb,
				DWORD*		pcbTransfer, 
				class	CNntpComplete*	pComplete
				)	{

	_ASSERT( particleIdNext != 0 ) ;
	_ASSERT(	lpb != 0 ) ;
	_ASSERT(	pcbTransfer != 0 ) ;
	_ASSERT(	pComplete != 0 ) ;
	//
	//	Okay - issue the Xover command against the real driver !
	//
	CGRPPTR&	pGroup = GetGroup() ;
	_ASSERT(	pGroup != 0 ) ;
	pGroup->FillBufferInternal(	articleIdLow, 
								articleIdHigh, 
								particleIdNext, 
								lpb, 
								cb, 
								pcbTransfer, 
								pComplete
								) ;
}

//
//	this function is called when the operation completes !
//
void
CXOverCacheWork::Complete(	
			BOOL		fSuccess, 
			DWORD		cbTransferred, 
			ARTICLEID	articleIdNext
			)	{

    //
    // If we had a successful completion and there were bytes returned, then
    // we go ahead and complete by calling pContainer->Release().  We also do
    // this in the failure case as well.
    //
    // If it was successful, but there weren't any bytes returned, then we set
    // the number of bytes transferred to -1 to signal the IO code that it needs
    // to issue a NextBuffer command
    //

    TraceQuietEnter("CXOverCacheWork::Complete");

	CXOverAsyncComplete*	pContainer = GetContainer() ;
	pContainer->m_cbTransfer = cbTransferred ;
	pContainer->m_currentArticle = articleIdNext ;

	if(!fSuccess) {
		pContainer->SetResult(E_FAIL);
    	pContainer->Release();
    	return;
	}

	pContainer->SetResult( S_OK ) ;

	CXOverCmd *pCmd = pContainer->GetContainer();

    if ((cbTransferred + pCmd->m_Completion.m_cbPrefix) != 0 || 
            articleIdNext > pContainer->m_hiArticle) {
	   	pContainer->Release() ;
        return;
	}

	pContainer->m_cbTransfer = (DWORD)-1;
	pContainer->Release() ;

}

	//
	//	Get the arguments for this XOVER operation !
	//
void
CXOverCacheWork::GetArguments(	
				OUT	ARTICLEID&	articleIdLow, 
				OUT	ARTICLEID&	articleIdHigh,
				OUT	ARTICLEID&	articleIdGroupHigh,
				OUT	LPBYTE&		lpbBuffer, 
				OUT	DWORD&		cbBuffer
				) 	{

	CXOverAsyncComplete*	pContainer = GetContainer() ;
	articleIdLow = pContainer->m_currentArticle ;
	articleIdHigh = pContainer->m_hiArticle ;
	articleIdGroupHigh = pContainer->m_groupHighArticle ;
	lpbBuffer = pContainer->m_lpb ;
	cbBuffer = pContainer->m_cb ;
}

	//
	//	Get only the range of articles requested for this XOVER op !
	//
void
CXOverCacheWork::GetRange(	
			OUT	GROUPID&	groupId,
			OUT	ARTICLEID&	articleIdLow,
			OUT	ARTICLEID&	articleIdHigh,
			OUT	ARTICLEID&	articleIdGroupHigh
			) 	{
	CXOverAsyncComplete*	pContainer = GetContainer() ;
	articleIdLow = pContainer->m_currentArticle ;
	articleIdHigh = pContainer->m_hiArticle ;
	articleIdGroupHigh = pContainer->m_groupHighArticle ;
	CGRPPTR&	pGroup = GetGroup() ;
	groupId = pGroup->GetGroupId() ;
}


CXOverCmd::CXOverCmd( CGRPPTR&  pGroup ) :
    m_pGroup( pGroup ),
    m_pContext (NULL) {
}

CXOverCmd::~CXOverCmd( ) {
}

CIOWriteAsyncComplete*
CXOverCmd::FirstBuffer(
            BYTE *lpb,
            int cb,
            ClientContext& context,
            CLogCollector*  pCollector
            )
{

	TraceFunctEnter("CXOverCmd::FirstBuffer");

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
	_ASSERT( m_Completion.m_lpb == 0 ) ;
	_ASSERT( m_Completion.m_cb == 0 ) ;
    _ASSERT (m_pContext != NULL);

    static  char    szStart[] = "224 Overview information follows\r\n"  ;

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    context.m_nrcLast = nrcXoverFollows ;
	m_Completion.m_cbPrefix = sizeof( szStart ) - 1 ;
	cb -= m_Completion.m_cbPrefix ;
	lpb += m_Completion.m_cbPrefix ;

	m_Completion.m_lpb = lpb ;
	m_Completion.m_cb = cb - 3 ;

	m_pGroup->FillBuffer(
					&context.m_securityCtx,
					&context.m_encryptCtx,
					m_Completion
					) ;

	return	&m_Completion ;

#if 0
    if( cb < sizeof( szStart ) ) {
        return  0 ;
    }
#endif

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, 4 ) ;
    }
    */

}

CIOWriteAsyncComplete*
CXOverCmd::NextBuffer(
    BYTE *lpb,
    int cb,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    ENTER("CXOverCmd::NextBuffer")

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
	_ASSERT( m_Completion.m_lpb == 0 ) ;
	_ASSERT( m_Completion.m_cb == 0 ) ;
    _ASSERT (m_pContext != NULL);

    //
    // reserve space for \r\n
    //
    _ASSERT( cb > 2 ) ;

    m_Completion.m_lpb = lpb ;
    m_Completion.m_cb = cb - 3 ;
    m_Completion.m_cbPrefix = 0 ;

    m_pGroup->FillBuffer(
				&context.m_securityCtx,
				&context.m_encryptCtx,
				m_Completion
				);

	return	&m_Completion ;

}

CIOExecute*
CSearchFieldsCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&	pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter("CSearchFieldsCmd::make");

    CSearchFieldsCmd   *pSearchFieldsCmd;

    // make sure the command syntax is proper
    if (argc != 2) {
        DebugTrace(0, "wrong number of arguments passed into LIST SRCHFIELDS");
        context.m_return.fSet(nrcSyntaxError);
        pExecute = new (context) CErrorCmd(context.m_return);
        return 0;
    }

    pSearchFieldsCmd = new(context) CSearchFieldsCmd();
    if (pSearchFieldsCmd == 0) {
        ErrorTrace(0, "Cannot allocate CSearchFieldsCmd");
        context.m_return.fSet(nrcServerFault);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    pSearchFieldsCmd->m_iSearchField = 0;

    pExecute = (CExecute*)pSearchFieldsCmd;
    return 0;
}

CSearchFieldsCmd::CSearchFieldsCmd() {
}

CSearchFieldsCmd::~CSearchFieldsCmd() {
}

int CSearchFieldsCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{
    TraceFunctEnter("CSearchFieldsCmd::Execute");

    DWORD cbOut;
    char szStart[] = "224 Data Follows\r\n";

    context.m_nrcLast = nrcXoverFollows ;

    _ASSERT(lpb != 0);
    _ASSERT(cb != 0);
    _ASSERT(fComplete == FALSE);

    _ASSERT(cb > sizeof(szStart));
    memcpy(lpb, szStart, sizeof(szStart));
    cbOut = sizeof(szStart) - 1;

    return cbOut;
}

int
CSearchFieldsCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("CSearchFieldsCmd::PartialExecute");

    char szEnd[] = ".";
    DWORD cbOut = 0;

    while (!fComplete) {
        char *szFieldName = GetSearchHeader(m_iSearchField);

        // if we get back a NULL then we've listed then all, put the .
        if (szFieldName == NULL) {
            szFieldName = szEnd;
            fComplete = TRUE;
        }

        // make sure there is enough space to write the current fieldname
        DWORD cFieldName = strlen(szFieldName);
        if (cFieldName + 2 > (cb - cbOut)) {
            fComplete = FALSE;
            return cbOut;
        }

        m_iSearchField++;

        memcpy(lpb + cbOut, szFieldName, cFieldName);
        lpb[cbOut + cFieldName] = '\r';
        lpb[cbOut + cFieldName + 1] = '\n';
        cbOut += cFieldName + 2;
    }

    return cbOut;
}

CIOExecute*
COverviewFmtCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&	pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter("COverviewFmtCmd::make");

    COverviewFmtCmd   *pOverviewFmtCmd;

    // make sure the command syntax is proper
    if (argc != 2) {
        DebugTrace(0, "wrong number of arguments passed into LIST OVERVIEW.FMT");
        context.m_return.fSet(nrcSyntaxError);
        pExecute = new (context) CErrorCmd(context.m_return);
        return 0;
    }

    pOverviewFmtCmd = new(context) COverviewFmtCmd();
    if (pOverviewFmtCmd == 0) {
        ErrorTrace(0, "Cannot allocate COverviewFmtCmd");
        context.m_return.fSet(nrcServerFault);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    pExecute = (CExecute*)pOverviewFmtCmd;
    return 0;
}

COverviewFmtCmd::COverviewFmtCmd() {
}

COverviewFmtCmd::~COverviewFmtCmd() {
}

int COverviewFmtCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{
    TraceFunctEnter("COverviewFmtCmd::Execute");

    DWORD cbOut;
    char szOverviewFmt[] = "215 Order of fields in overview database.\r\n"
						   "Subject:\r\n"
						   "From:\r\n"
						   "Date:\r\n"
						   "Message-ID:\r\n"
						   "References:\r\n"
						   "Bytes:\r\n"
						   "Lines:\r\n"
						   "Xref:full\r\n"
						   ".\r\n";

    context.m_nrcLast = nrcListGroupsFollows;

    _ASSERT(lpb != 0);
    _ASSERT(cb != 0);
    _ASSERT(fComplete == FALSE);

    _ASSERT(cb > sizeof(szOverviewFmt));
    memcpy(lpb, szOverviewFmt, sizeof(szOverviewFmt));
    cbOut = sizeof(szOverviewFmt) - 1;

	fComplete = TRUE;

    return cbOut;
}

int
COverviewFmtCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("COverviewFmtCmd::PartialExecute");

	// everything is in StartExecute
	_ASSERT(FALSE);

    return 0;
}

LPMULTISZ
ConditionArgsForSearch(
                int cArgs,
                char**  argv,
                BOOL    fZapCommas ) {
/*++

Routine Description :

    Convert argc, argv arguments into a MULTI_SZ
    The cnversion is done in place.   All argv pointers must be in a contiguous buffer.

Arguemtns :

    cArgs - Number of arguments
    argv -  Argument array
    fZapCommas - convert commas to NULLS

Return Value :

    Pointer to MULTI_SZ

--*/

    //
    //  This function takes an argc,argv set of arguments and converts them
    //  to a MULTI_SZ with a single NULL between strings and 2 NULLs at the end.
    //
    //

    char*   pchComma = 0 ;
    char*   pchEnd = argv[cArgs-1] + lstrlen( argv[cArgs-1] ) + 1 ;
    int     c = 0 ;
    for( char*  pch = argv[0], *pchDest = pch; pch < pchEnd; pch ++, pchDest++ ) {
        if( fZapCommas && *pch == ',' ) {
            for( pchComma = pch; *pchComma == ','; pchComma ++ )
                *pchComma = '\0' ;
        }
        if( (*pchDest = *pch) == '\0' ) {
            while( pch[1] == '\0' && pch < pchEnd )     pch++ ;
        }
    }
    *pchDest++ = '\0' ;
    *pchDest++ = '\0' ;

    //
    //  Rebuild the argc argv structure - !
    //
    for( int i=1; i<cArgs; i++ ) {
        argv[i] = argv[i-1]+lstrlen(argv[i-1])+1 ;
    }
    return  argv[0] ;
}

CSearchAsyncComplete::CSearchAsyncComplete() {
}

CSearchCmd::CSearchCmd(const CGRPPTR& pGroup, CHAR* pszSearchString) :
	m_pGroup(pGroup),
	m_pszSearchString(pszSearchString),
	m_VRootList(&CSearchVRootEntry::m_pPrev, &CSearchVRootEntry::m_pNext),
	m_VRootListIter(&m_VRootList),
	m_pSearch(NULL),
	m_pSearchResults(NULL) {
}

CSearchCmd::~CSearchCmd() {
	if (m_pszSearchString)
		XDELETE m_pszSearchString;
	if (m_pSearch)
		m_pSearch->Release();
	if (m_pSearchResults)
		m_pSearchResults->Release();

	TFList<CSearchVRootEntry>::Iterator it(&m_VRootList);
	while (!it.AtEnd()) {
		CSearchVRootEntry *pEntry = it.Current();
		CNNTPVRoot *pRoot = pEntry->m_pVRoot;
		it.RemoveItem();
		pRoot->Release();
		delete pEntry;
	}

}

CIOExecute*
CSearchCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&	pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter("CSearchCmd::make");

    CSearchCmd   *pSearchCmd;
    int i;
    BOOL fInPresent;
    HRESULT hr;

    InterlockedIncrementStat( (context.m_pInstance), SearchCommands );

    //
    // make sure they passed the correct number of args
    //
    if (argc < 2) {
        DebugTrace(0, "SEARCH command received with no args");
        context.m_return.fSet(nrcSyntaxError);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

	//
    // See if the "IN" clause has been specified.  If it hasn't, then
    // we have to point to a newsgroup. (Per the spec, IN must be the
    // first word following SEARCH)
    //

    fInPresent = (_stricmp("IN", argv[1]) == 0);

    if (!fInPresent && context.m_pCurrentGroup == 0) {
    	ErrorTrace(0, "No current group selected");
    	context.m_return.fSet(nrcNoGroupSelected);
    	pExecute = new(context) CErrorCmd(context.m_return);
    	return 0;
    }

    //
    // See if there are any available atq threads.  If we don't
    // have a couple laying around, then fail as we might deadlock waiting
    // for a completion.
    //

    if (AtqGetInfo(AtqAvailableThreads) < 1) {
		ErrorTrace(0, "Server too busy");
		context.m_return.fSet(nrcErrorPerformingSearch);
    	pExecute = new(context) CErrorCmd(context.m_return);
    	return 0;
    }

    ConditionArgsForSearch(argc, argv, FALSE);

    //
    // change argv[1] to have the entire query string by converting 0s into
    // ' 's
    //
    for (i = 1; i < argc - 1; i++)
    	*((argv[i + 1]) - 1) = ' ';

	CHAR *pszSearchString =  XNEW CHAR[strlen(argv[1]) + 1];
	if (pszSearchString == NULL) {
		ErrorTrace(0, "Could not allocate search string");
		context.m_return.fSet(nrcServerFault);
    	pExecute = new(context) CErrorCmd(context.m_return);
    	return 0;
    }

	lstrcpy (pszSearchString, argv[1]);

    pSearchCmd = new(context) CSearchCmd(context.m_pCurrentGroup, pszSearchString);
    if (pSearchCmd == 0) {
        ErrorTrace(0, "Cannot allocate CSearchCmd");
        XDELETE pszSearchString;
        context.m_return.fSet(nrcServerFault);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    // Save off the list of VRoots.  If fInPresent, then we have to
    // go through all of the VRoots.  Otherwise, only add the current
    // group's VRoot

	if (fInPresent) {
		// "IN" was specified, so all indexed groups should be searched.
		// Enumerate the list of VRoots and add them to the table.
		CNNTPVRootTable *pVRootTable = context.m_pInstance->GetVRTable();
		pVRootTable->EnumerateVRoots(pSearchCmd, VRootCallback);
	} else {
		// No "IN", so only search the current group.  Fake up the callback
		// to add it to the list
		CNNTPVRoot* pVRoot = context.m_pCurrentGroup->GetVRoot();
		VRootCallback(pSearchCmd, pVRoot);
		pVRoot->Release();
	}

    pExecute = (CExecute*)pSearchCmd;
	return 0;

}

void
CSearchCmd::VRootCallback(void *pContext, CVRoot *pVRoot) {

	TraceQuietEnter ("CSearchCmd::VRootCallback");

	HRESULT hr;

	CSearchCmd *pThis = (CSearchCmd *)pContext;
	CNNTPVRoot *pNNTPVRoot = (CNNTPVRoot *)pVRoot;

	// If the VRoot isn't indexed, no reason to do anything...
	if (!pNNTPVRoot->IsContentIndexed())
		return;

	// See if the driver for this VRoot implements the search interface
	// Note that pDriver isn't AddRef()ed, so we don't have to release it.
	INntpDriver *pDriver = pNNTPVRoot->GetDriver();
	if (!pDriver) {
		ErrorTrace((DWORD_PTR)pContext, "Could not locate driver for vroot");
		return;
	}

	INntpDriverSearch *pSearch=NULL;
	hr = pDriver->QueryInterface(IID_INntpDriverSearch, (VOID**)&pSearch);
	if (FAILED(hr)) {
		if (hr == E_NOINTERFACE) {
			DebugTrace((DWORD_PTR)pContext, "Driver does not implement search");
		} else {
			ErrorTrace((DWORD_PTR)pContext, "Could not QI for INntpDriverSearch, %x", hr);
		}
		return;
	}

	// Walk the list of VRoots to see if the driver thinks that
	// they are the same as one that's already been seen.

	TFList<CSearchVRootEntry>::Iterator it(&pThis->m_VRootList);
	BOOL fFound = FALSE;
	while (!it.AtEnd()) {
		CSearchVRootEntry *pTestEntry = it.Current();
		CNNTPVRoot *pTestVRoot = pTestEntry->m_pVRoot;
		_ASSERT(pTestVRoot);
		if (pTestVRoot == NULL)
			continue;
		INntpDriver *pTestDriver = pTestVRoot->GetDriver();
		_ASSERT (pTestDriver);
		if (!pTestDriver) {
			ErrorTrace((DWORD_PTR)pContext, "Could not locate driver for vroot");
			continue;
		}

		INntpDriverSearch *pTestSearch=NULL;
		hr = pDriver->QueryInterface(IID_INntpDriverSearch, (VOID**)&pTestSearch);
		_ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			continue;

		fFound = pTestSearch->UsesSameSearchDatabase(pSearch, NULL);
		pTestSearch->Release();
		if (fFound) {
			DebugTrace((DWORD_PTR)pContext, "Driver already on list");
			break;
		}

		it.Next();
	}


	if (!fFound) {
		CSearchVRootEntry *pVRootEntry = new CSearchVRootEntry(pNNTPVRoot);
		_ASSERT(pVRootEntry);
		if (pVRootEntry) {
			pNNTPVRoot->AddRef();
			pThis->m_VRootList.PushBack(pVRootEntry);
		} else {
			// All we can do is skip the entry and move on.
			ErrorTrace((DWORD_PTR)pContext, "Could not allocate vroot ptr");
		}
	}

	// That's all
	pSearch->Release();

}

int CSearchCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{

	HRESULT hr;

    TraceFunctEnter("CSearchCmd::StartExecute");

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT(fComplete == FALSE);
    _ASSERT(m_pSearch == NULL);

	//
	//	Prefer to use the SSL based hToken !
	//
	BOOL fAnonymous = FALSE;
	HANDLE hImpersonate = context.m_encryptCtx.QueryCertificateToken();
	if(hImpersonate == NULL) {
		hImpersonate = context.m_securityCtx.QueryImpersonationToken() ;
		fAnonymous = context.m_securityCtx.IsAnonymous();
	}

	m_cMaxSearchResults = context.m_pInstance->GetMaxSearchResults();

	m_VRootListIter.ResetHeader(&m_VRootList);

	GetNextSearchInterface (hImpersonate, fAnonymous);

    static const char szStart[] = "224 Overview information follows\r\n"  ;

	//	Put out the response code.
    context.m_nrcLast = nrcXoverFollows ;

    DWORD cbRtn = 0;

	// starting to send data
	CopyMemory((char*) lpb, szStart, sizeof(szStart) - 1);
	cbRtn += sizeof(szStart) - 1;

    return cbRtn;
}

int
CSearchCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("CSearchCmd::PartialExecute");

	//
	//	Prefer to use the SSL based hToken !
	//
	BOOL fAnonymous = FALSE;
	HANDLE hImpersonate = context.m_encryptCtx.QueryCertificateToken();
	if(hImpersonate == NULL) {
		hImpersonate = context.m_securityCtx.QueryImpersonationToken() ;
		fAnonymous = context.m_securityCtx.IsAnonymous();
	}

    int cbRtn = 0;                  // number of bytes we've added to lpb

    BOOL fBufferFull = FALSE;
    fComplete = FALSE;
    HRESULT hr;

	//
	// Since this is a Sync event, we'll increase the number of runnable
	// threads in the Atq pool.
	//
	AtqSetInfo(AtqIncMaxPoolThreads, NULL);

    while (!fComplete && !fBufferFull) {
        _ASSERT(m_iResults <= m_cResults);

        //
        // get some data from Search if we don't have anything to send
        //
        if (m_iResults == m_cResults && m_fMore) {
            HRESULT hr;

            // otherwise there is more to get, go get it
            m_iResults = 0;
            DWORD cResults = MAX_SEARCH_RESULTS;

			CNntpSyncComplete scComplete;

            m_pSearchResults->GetResults(
            	&cResults,
            	&m_fMore,
            	m_pwszGroupName,	//array of names,
            	m_pdwArticleID,		//array of ids,
            	&scComplete,			// Completion object
            	hImpersonate,		// hToken
            	fAnonymous,			// fAnonymous
            	NULL);				// Context

			_ASSERT(scComplete.IsGood());
			hr = scComplete.WaitForCompletion();

            m_cResults = cResults;
            m_cMaxSearchResults -= cResults;

            // check for Search failure
            if (FAILED(hr)) {
                // if we fail here then the best we can do is truncate the
                // list we return
                hr = GetNextSearchInterface(hImpersonate, fAnonymous);
                if (hr != S_OK) {
                	if (cb - cbRtn > 3) {
						CopyMemory(lpb + cbRtn, StrTermLine, 3);
						cbRtn += 3;
						fComplete = TRUE;
					} else {
						fBufferFull = TRUE;
					}
                }
                continue;
            }
        }

        // check to see if we are out of results
        if (!m_fMore && m_iResults == m_cResults) {
        	hr = GetNextSearchInterface(hImpersonate, fAnonymous);
            if (hr != S_OK) {
            	if (cb - cbRtn > 3) {
                	CopyMemory(lpb + cbRtn, StrTermLine, 3);
                	cbRtn += 3;
                	fComplete = TRUE;
            	} else {
					fBufferFull = TRUE;
             	}
            }
            continue;
        }

        // convert Unicode group name to ASCII (errr, make that UTF8)
        char *szNewsgroup = (char *) lpb + cbRtn;
        // Note, first arg was changed from CP_ACP to CP_UTF8
        // (code page ascii->utf8)
        int cNewsgroup = WideCharToMultiByte(CP_UTF8, 0,
        	m_pwszGroupName[m_iResults], -1,
            szNewsgroup, cb - cbRtn, NULL, NULL) - 1;
        // check to see if it could fit
        if (cNewsgroup <= 0) {
            _ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);
            fBufferFull = TRUE;
            continue;
        }
        // we also need to fit the : and still leave room for .\r\n
        if (cb <= (cbRtn + cNewsgroup + 1 + 3)) {
            fBufferFull = TRUE;
            continue;
        }

        // this is a \0 now, it will be converted into a colon in a few lines
        char *szColon = szNewsgroup + cNewsgroup;
        cbRtn += cNewsgroup + 1; // name of newsgroup + colon

        DWORD dwArticleID = m_pdwArticleID[m_iResults];

        // get the group object for this newsgroup
        CGRPPTR pGroup = (context.m_pInstance)->GetTree()->GetGroup(szNewsgroup, cNewsgroup+1);

		if (pGroup != NULL &&
            dwArticleID >= pGroup->GetFirstArticle() &&
            dwArticleID <= pGroup->GetLastArticle())
        {
			// we set fDoTest to FALSE, since Tripoli already does the ACL
			// tests for us, and it would be wasteful to do them again.
			// BUGBUG - this means that we might miss tests with the
			// hCertToken
			if (!pGroup->IsGroupAccessible(context.m_securityCtx,
       							  		   context.m_encryptCtx,
                                  		   context.m_IsSecureConnection,
								  		   FALSE,
								  		   FALSE))
			{
				// if this group requires SSL and this client doesn't have
				// SSL then don't show them this article information
            	cbRtn -= cNewsgroup + 1;
			} else {
            	// convert \0 to a colon
            	*szColon = ':';

	            // get XOVER data...

				CSearchAsyncComplete scComplete;
				CNntpSyncComplete asyncComplete;

				scComplete.m_currentArticle = dwArticleID;
				scComplete.m_lpb = lpb + cbRtn;
				scComplete.m_cb = cb - cbRtn - 3;		// Room for the ".\r\n"
				_ASSERT(cb - cbRtn - 3 > 0);
				scComplete.m_cbTransfer = 0;
				scComplete.m_pComplete = &asyncComplete;

				//
				// Set vroot to the completion object
				//
				CNNTPVRoot *pVRoot = pGroup->GetVRoot();
				asyncComplete.SetVRoot( pVRoot );

				pGroup->FillBuffer (
					&context.m_securityCtx,
					&context.m_encryptCtx,
					scComplete);

				// wait for it to complete
				_ASSERT( asyncComplete.IsGood() );
				hr = asyncComplete.WaitForCompletion();

				pVRoot->Release();

	            if (scComplete.m_cbTransfer == 0) {
					if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
		                // we ran out of buffer space...
		                cbRtn -= cNewsgroup + 1;
		                fBufferFull = TRUE;
		                continue;
					} else {
						// this doesn't have an entry, so don't return it to the
						// user
	            		cbRtn -= cNewsgroup + 1;
					}
	            } else {
	                cbRtn += scComplete.m_cbTransfer;
	            }
			}
        } else {
            // the newsgroup object doesn't exist.  this could happen if a
            // newsgroup was deleted, but the index still reflects articles
            // in it.
            // our solution: don't send any index information to the client
            // for this message
            cbRtn -= cNewsgroup + 1;
        }


        // say that we saw this article
        m_iResults++;
    }


	// Return the number of Atq threads back to what it was before we started
	AtqSetInfo(AtqDecMaxPoolThreads, NULL);

    return  cbRtn;
}

HRESULT
CSearchCmd::GetNextSearchInterface(HANDLE hImpersonate, BOOL fAnonymous) {

    TraceFunctEnter("CSearchCmd::GetNextSearchInterface");

    HRESULT hr = S_FALSE;				// Default to no interfaces left

    m_iResults = 0;
    m_cResults = 0;
    m_fMore = FALSE;

	// MakeSearchQuery trashes the search string, so we need to make a copy of it.
    char *pszSearchString = XNEW char[strlen(m_pszSearchString)+1];
    if (pszSearchString == NULL) {
    	ErrorTrace((DWORD_PTR)this, "Could not allocate search string");
		TraceFunctLeave();
    	return E_OUTOFMEMORY;
    }

	while (!m_VRootListIter.AtEnd()) {
		CSearchVRootEntry *pVRootEntry = m_VRootListIter.Current();
		CNNTPVRoot *pNNTPVRoot = pVRootEntry->m_pVRoot;
		m_VRootListIter.Next();
		INntpDriver *pDriver = pNNTPVRoot->GetDriver();
		if (pDriver == NULL)
			continue;

		WCHAR wszColumns[] = L"newsgroup,newsarticleid";

		// If we are holding pointers to the old search interfaces, release them.
		if (m_pSearch) {
			m_pSearch->Release();
			m_pSearch = NULL;
		}
		if (m_pSearchResults) {
			m_pSearchResults->Release();
			m_pSearchResults = NULL;
		}

		hr = pDriver->QueryInterface(IID_INntpDriverSearch, (VOID**)&m_pSearch);

		if (FAILED(hr)) {
			if (hr == E_NOINTERFACE)
				DebugTrace((DWORD_PTR)this, "This driver doesn't support search");
			else
				ErrorTrace((DWORD_PTR)this, "Could not QI INntpDriverSearch, %x", hr);
			continue;
		}

		CNntpSyncComplete scComplete;

		lstrcpy (pszSearchString, m_pszSearchString);

	    INNTPPropertyBag *pPropBag = NULL;

    	if (m_pGroup) {
    		// Note: The property bag is released by the driver
    		pPropBag = m_pGroup->GetPropertyBag();
    		scComplete.BumpGroupCounter();
		    if ( NULL == pPropBag ) {
    		    ErrorTrace( 0, "Get group property bag failed" );
				m_pSearch->Release();
				m_pSearch = NULL;
      		  	continue;
    		}
    	}

	    //
	    // Since this is a Sync event, we'll increase the number of runnable
	    // threads in the Atq pool.
	    //
	    AtqSetInfo(AtqIncMaxPoolThreads, NULL);

		m_pSearch->MakeSearchQuery (
			pszSearchString,
			pPropBag,
			TRUE,					// Deep Query
			wszColumns,				// Columns to return
			wszColumns,				// Sort order
			GetSystemDefaultLCID(),	// Locale
			m_cMaxSearchResults,	// max rows
			hImpersonate,			// hToken
			fAnonymous,				// fAnonymous
			&scComplete,			// INntpComplete *pICompletion
			&m_pSearchResults,		// INntpSearch *pINntpSearch
			NULL					// LPVOID lpvContext
			);

		_ASSERT(scComplete.IsGood());
		hr = scComplete.WaitForCompletion();

	    // Reset the number of threads
	    AtqSetInfo(AtqDecMaxPoolThreads, NULL);

		if (FAILED(hr)) {
			ErrorTrace((DWORD_PTR)this, "Error calling MakeSearchQuery, %x", hr);
			m_pSearch->Release();
			m_pSearch = NULL;
			continue;
		}

		m_fMore = TRUE;
		break;

    }

	XDELETE pszSearchString;
    TraceFunctLeave();
	return hr;
}

CXpatAsyncComplete::CXpatAsyncComplete() {

}

CIOExecute* CXPatCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&	pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter("CXPatCmd::make");

    CXPatCmd   *pXPatCmd;
    int i;

    InterlockedIncrementStat( (context.m_pInstance), XPatCommands );

    //
    // make sure they have selected a newsgroup
    //
    if (context.m_pCurrentGroup == NULL) {
        DebugTrace(0, "XPAT command received with no current group");
        context.m_return.fSet(nrcNoGroupSelected);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    //
    // make sure they passed enough arguments
    //
    if (argc < 4) {
        DebugTrace(0, "not enough arguments passed into XPAT");
        context.m_return.fSet(nrcSyntaxError);
        pExecute = new (context) CErrorCmd(context.m_return);
        return 0;
    }

    ConditionArgsForSearch(argc, argv, FALSE);

    //
    // change argv[1] to have the entire query string by converting 0s into
    // ' 's
    //
    for (i = 1; i < argc - 1; i++)
    	*((argv[i + 1]) - 1) = ' ';


	CHAR *pszSearchString =  XNEW CHAR[strlen(argv[1]) + 1];
	if (pszSearchString == NULL) {
		ErrorTrace(0, "Could not allocate search string");
		context.m_return.fSet(nrcServerFault);
    	pExecute = new(context) CErrorCmd(context.m_return);
    	return 0;
    }

	lstrcpy (pszSearchString, argv[1]);

	//
	// get a 0 after argv[1] and argv[2]
	//
	*(argv[2] - 1) = 0;
	*(argv[3] - 1) = 0;
	char *szMessageIDArg = argv[2];
	if (*szMessageIDArg == '<') {
	    GROUPID GroupID;
	    ARTICLEID ArticleID;
	    CGRPPTR pGroup;
	    // make sure the message ID exists...if not we need to
	    // report an error
	    if (!CheckMessageID(szMessageIDArg, context, &GroupID,
	                       &ArticleID, &pGroup))
	    {
	        DebugTrace(0, "unknown message ID passed into XPAT");
	        XDELETE pszSearchString;
	        context.m_return.fSet(nrcNoSuchArticle);
	        pExecute = new (context) CErrorCmd(context.m_return);
	        return 0;
	    }
	} else {
	    szMessageIDArg = NULL;
	}

    HRESULT hr;
	CNNTPVRoot *pNNTPVRoot = NULL;
	INntpDriver *pDriver = NULL;
	INntpDriverSearch *pDriverSearch = NULL;
	INntpSearchResults *pSearchResults = NULL;
	DWORD dwLowArticleID, dwHighArticleID;

	//
	//	Prefer to use the SSL based hToken !
	//
	BOOL fAnonymous = FALSE;
	HANDLE hImpersonate = context.m_encryptCtx.QueryCertificateToken();
	if(hImpersonate == NULL) {
		hImpersonate = context.m_securityCtx.QueryImpersonationToken() ;
		fAnonymous = context.m_securityCtx.IsAnonymous();
	}

	//
	// Grab the vroot for the group and perform the query
	//

	pNNTPVRoot = context.m_pCurrentGroup->GetVRoot();
	pDriver = pNNTPVRoot->GetDriver();
	_ASSERT(pDriver);
	if (pDriver == NULL) {
		DebugTrace(0, "Could not locate driver for vroot");
		pNNTPVRoot->Release();
		XDELETE pszSearchString;
		context.m_return.fSet(nrcServerFault);
		pExecute = new (context) CErrorCmd(context.m_return);
		return 0;
	}

	pNNTPVRoot->Release();

	hr = pDriver->QueryInterface(IID_INntpDriverSearch, (VOID**)&pDriverSearch);
	if (FAILED(hr)) {
		if (hr == E_NOINTERFACE) {
			DebugTrace(0, "This driver doesn't support xpat");
		} else {
			ErrorTrace(0, "Could not QI INntpDriverSearch, %x", hr);
		}

		XDELETE pszSearchString;
		context.m_return.fSet(nrcServerFault);
		pExecute = new (context) CErrorCmd(context.m_return);
		return 0;

	}

	CNntpSyncComplete scComplete;
	WCHAR wszColumns[] = L"newsgroup,newsarticleid";

	// Note:  The property bag is released by the driver
    INNTPPropertyBag *pPropBag = context.m_pCurrentGroup->GetPropertyBag();
    scComplete.BumpGroupCounter();

	//
	// Since this is a Sync event, we'll increase the number of runnable
	// threads in the Atq pool.
	//
	AtqSetInfo(AtqIncMaxPoolThreads, NULL);

	pDriverSearch->MakeXpatQuery(
		pszSearchString,
		pPropBag,
		TRUE,					// Deep Query
		wszColumns,				// Columns to return
		wszColumns,				// Sort order
		GetSystemDefaultLCID(),	// Locale
		context.m_pInstance->GetMaxSearchResults(),	// max rows
		hImpersonate,			// hToken
		fAnonymous,				// fAnonymous
		&scComplete,			// INntpComplete *pICompletion
		&pSearchResults,		// INntpSearch *pINntpSearch,
		&dwLowArticleID,		// Low article ID
		&dwHighArticleID,		// High article ID
		NULL					// Context
		);

	_ASSERT(scComplete.IsGood());
	hr = scComplete.WaitForCompletion();

	// Restore number of threads
    AtqSetInfo(AtqDecMaxPoolThreads, NULL);

	XDELETE pszSearchString;

	if (FAILED(hr)) {
		// Make the Low higher than High to force StartExecute to
		// output an empty results set
		dwLowArticleID = 9;
		dwHighArticleID = 0;
	}

	//
	// allocate the CXPatCmd object
	//
	pXPatCmd = new(context) CXPatCmd(pDriverSearch, pSearchResults);
	if (pXPatCmd == 0) {
		ErrorTrace(0, "Cannot allocate CXPatCmd");
		pDriverSearch->Release();
		pSearchResults->Release();
		context.m_return.fSet(nrcServerFault);
		pExecute = new(context) CErrorCmd(context.m_return);
		return 0;
	}

    //
    // the header to search is the first supplied argument
    // (assumes cmd buffer hangs around)
    pXPatCmd->m_szHeader = argv[1];
    pXPatCmd->m_szMessageID = szMessageIDArg;

	pXPatCmd->m_dwLowArticleID = dwLowArticleID;
	pXPatCmd->m_dwHighArticleID = dwHighArticleID;

	pExecute = (CExecute*)pXPatCmd;

	return(0);
}

CXPatCmd::CXPatCmd(INntpDriverSearch *pDriverSearch, 
	INntpSearchResults *pSearchResults) :
	m_pSearch(pDriverSearch),
	m_pSearchResults(pSearchResults),
	m_iResults(0),
	m_cResults(0),
	m_fMore(TRUE),
	m_szHeader(NULL),
	m_szMessageID(NULL)	{
	}


CXPatCmd::~CXPatCmd() {
	if (m_pSearch)
		m_pSearch->Release();
	if (m_pSearchResults)
		m_pSearchResults->Release();
}

int CXPatCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{
    TraceFunctEnter("CXPatCmd::Execute");

	static const char szStart[] = "221 Headers follow\r\n";
	static const char szNoResults[] = "221 Headers follow\r\n.\r\n";

    _ASSERT(lpb != 0);
    _ASSERT(cb != 0);
    _ASSERT(fComplete == FALSE);

	//	Put out the response code.
	context.m_nrcLast = nrcHeadFollows ;

	DWORD cbRtn = 0;

	// starting to send data
	if (m_dwLowArticleID <= m_dwHighArticleID) {
	    _ASSERT(m_pSearch != NULL);
    	_ASSERT(m_pSearchResults != NULL);
		CopyMemory((char*) lpb, szStart, sizeof(szStart) - 1);
		cbRtn += sizeof(szStart) - 1;
	} else {
		CopyMemory((char*) lpb, szNoResults, sizeof(szNoResults) - 1);
		cbRtn += sizeof(szNoResults) - 1;
		fComplete = TRUE;
	}

	return cbRtn;

}

//
// this is shared for XPAT and XHDR.  Given a group, article ID, and
// desired header, it prints the article ID and header to lpb.  returns
// the number of bytes written.  If the message ID is given it prints
// the message ID and selected header (it still uses group and article ID
// to find the data).
//
// returns 0 if there isn't enough buffer space for the article, -1
// if the article doesn't exist.
//

int CXPatCmd::GetArticleHeader(CGRPPTR pGroup,
                     DWORD dwArticleID,
                     char *szHeader,
                     ClientContext& context,
                     BYTE *lpb,
                     int cb)
{

	TraceQuietEnter("CXPatCmd::GetArticleHeader");
	
	int cbOut = 0;
	HRESULT hr;

	// :Text is a special case
	if (_stricmp(szHeader, ":Text") == 0) {
		if (cb > 20) {
			_itoa(dwArticleID, (char *) lpb, 10);
			cbOut = lstrlen((char *) lpb);
			CopyMemory(lpb + cbOut, " TEXT\r\n", 7);
			cbOut += 7;
		} else {
            SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
            return 0;
		}

		return cbOut;

	}

	// Not :Text, so we call the xhdr code to move the fetch the data.

	CXpatAsyncComplete scComplete;
	CNntpSyncComplete asyncComplete;

	scComplete.m_currentArticle = dwArticleID;
	scComplete.m_lpb = lpb;
	scComplete.m_cb = cb - 3;		// Room for the ".\r\n"
	scComplete.m_cbTransfer = 0;
	scComplete.m_pComplete = &asyncComplete;
	scComplete.m_szHeader = szHeader;

	//
	// Set vroot to the completion object
	//
	CNNTPVRoot *pVRoot = pGroup->GetVRoot();
	asyncComplete.SetVRoot( pVRoot );

	pGroup->FillBuffer (
		&context.m_securityCtx,
		&context.m_encryptCtx,
		scComplete);

	// wait for it to complete
	_ASSERT( asyncComplete.IsGood() );
	hr = asyncComplete.WaitForCompletion();
	pVRoot->Release();

	// check out status and return it
	if (FAILED(hr)) SetLastError(hr);

	if (scComplete.m_cbTransfer > 0)
		return scComplete.m_cbTransfer;

	// we ran out of buffer space...
	if (GetLastError() == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
		return 0;

	return -1;

}

int
CXPatCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("CXPatCmd::PartialExecute");

	//
	//	Prefer to use the SSL based hToken !
	//
	BOOL fAnonymous = FALSE;
	HANDLE hImpersonate = context.m_encryptCtx.QueryCertificateToken();
	if(hImpersonate == NULL) {
		hImpersonate = context.m_securityCtx.QueryImpersonationToken() ;
		fAnonymous = context.m_securityCtx.IsAnonymous();
	}

    int cbRtn = 0;                  // number of bytes we've added to lpb

    // these point to the article id and group of the primary group, which
    // might not be our current newsgroup
    DWORD dwPriArticleID;           // article ID for the current row
    char szPriNewsgroup[MAX_PATH];  // newsgroup for the current row
    DWORD dwArticleID;              // article ID in this group
    BOOL fBufferFull = FALSE;

    fComplete = FALSE;

    _ASSERT(m_iResults <= m_cResults);

	//
	// Since this is a Sync event, we'll increase the number of runnable
	// threads in the Atq pool.
	//
	AtqSetInfo(AtqIncMaxPoolThreads, NULL);

    while (!fComplete && !fBufferFull) {
        //
        // get some data from Search if we don't have anything to send
        //
        if (m_iResults == m_cResults && m_fMore) {
            HRESULT hr;

            // otherwise there is more to get, go get it
            m_iResults = 0;
            DWORD cResults = MAX_SEARCH_RESULTS;

			CNntpSyncComplete scComplete;

			m_pSearchResults->GetResults(
				&cResults,
				&m_fMore,
				m_pwszGroupName,
				m_pdwArticleID,
				&scComplete,
				hImpersonate,
				fAnonymous,
				NULL
				);

			_ASSERT(scComplete.IsGood());
			hr = scComplete.WaitForCompletion();

			m_cResults = cResults;

            // check for Search failure
            if (FAILED(hr)) {
                // truncate the list
                m_cResults = 0;
                ErrorTrace(0, "GetResults failed, %x", hr);
                _ASSERT(FALSE);
                if (cb - cbRtn > 3) {
                    CopyMemory(lpb + cbRtn, StrTermLine, 3);
                    cbRtn += 3;
                    fComplete = TRUE;
                } else {
                    fBufferFull = TRUE;
                }
                continue;
            }
        }

        if (m_iResults == m_cResults && !m_fMore) {
            // there are no more results, put the .\r\n and return
            if (cb - cbRtn > 3) {
                CopyMemory(lpb + cbRtn, StrTermLine, 3);
                cbRtn += 3;
                fComplete = TRUE;
            } else {
                fBufferFull = TRUE;
            }
            continue;
        }

		// convert Unicode group name to UTF8
		if (WideCharToMultiByte(CP_UTF8, 0, m_pwszGroupName[m_iResults],
			-1, szPriNewsgroup, sizeof(szPriNewsgroup), NULL, NULL) <= 0)
        {
            _ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);
            m_iResults++;
            continue;
        }

        // convert the filename to an article id
        dwPriArticleID = m_pdwArticleID[m_iResults];

        // if the article's primary group is not this group then find the
        // article ID for this group
        if (lstrcmp(szPriNewsgroup, context.m_pCurrentGroup->GetName()) != 0) {
            // we need to get the list of other groups that this article
            // was crossposted to
            CGRPPTR pPriGroup = 0;

            // get a pointer to the primary group
            pPriGroup = (context.m_pInstance)->GetTree()->
                            GetGroup(szPriNewsgroup, lstrlen(szPriNewsgroup)+1);
            if (pPriGroup == 0) {
                // this could happen if the tripoli cache was out of date
                m_iResults++;
                continue;
            }

            // get the list of crossposts
            DWORD cGroups = 10;
            DWORD cbGroupList = cGroups * sizeof(GROUP_ENTRY);
            PGROUP_ENTRY pGroupBuffer = XNEW GROUP_ENTRY[cGroups];
            if (pGroupBuffer == NULL) {
                // this isn't ideal, it will cause this article to not be
                // returned.  but its hard to do the right thing when you run
                // out of memory.
                _ASSERT(FALSE);
                m_iResults++;
                continue;
            }
            if (!(context.m_pInstance)->XoverTable()->GetArticleXPosts(
                    pPriGroup->GetGroupId(),
                    dwPriArticleID,
                    FALSE,
                    pGroupBuffer,
                    cbGroupList,
                    cGroups))
            {
                XDELETE pGroupBuffer;
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    // reallocate the buffer and try again
                    // GetArticleXPosts() sets cbGroupList to be the number
                    // of bytes required
                    cGroups = (cbGroupList / sizeof(GROUP_ENTRY));
                    pGroupBuffer = XNEW GROUP_ENTRY[cGroups];
                    if (pGroupBuffer == NULL) {
                        ASSERT(FALSE);
                        m_iResults++;
                        continue;
                    }
                    if (!(context.m_pInstance)->XoverTable()->GetArticleXPosts(
                        pPriGroup->GetGroupId(),
                        dwPriArticleID,
                        FALSE,
                        pGroupBuffer,
                        cbGroupList,
                        cGroups))
                    {
                        XDELETE pGroupBuffer;
                        m_iResults++;
                        continue;
                    }
                } else {
                    m_iResults++;
                    continue;
                }
            }

            // at this point pGroupBuffer has the information we need
            // find the current group in the group buffer
            DWORD iGroup;
            for (iGroup = 0; iGroup < cGroups; iGroup++) {
                if (pGroupBuffer[iGroup].GroupId ==
                    context.m_pCurrentGroup->GetGroupId())
                {
                    break;
                }
            }
            if (iGroup == cGroups) {
                // couldn't find the group.  this shouldn't happen.
                // _ASSERT(FALSE);
                // this can occur if XPAT searchs are done in control groups,
                // because the control group won't be listed in the
                // pGroupBuffer
				XDELETE pGroupBuffer;
                m_iResults++;
                continue;
            }

            // get the article id for the current newsgroup
            dwArticleID = pGroupBuffer[iGroup].ArticleId;

			XDELETE pGroupBuffer;
        } else {
            dwArticleID = dwPriArticleID;
        }

        // check to see if we are interested in this article ID
        if (dwArticleID >= m_dwLowArticleID && dwArticleID <= m_dwHighArticleID) {
            int x;
            // get the group object for this newsgroup
            CGRPPTR pGroup = context.m_pCurrentGroup;
            _ASSERT(pGroup != NULL);

            // format the output
            x = GetArticleHeader(pGroup, dwArticleID, m_szHeader,
                context, lpb + cbRtn, cb - cbRtn);

            if( x > 0 ) {
                m_iResults++;
                cbRtn += x;
            } else if (x == 0) {
				fBufferFull = TRUE;
			} else {
				m_iResults ++;
			}
        } else {
            // we don't need to return this article to the user, its out of
            // their supplied range
            m_iResults++;
        }
    }

	// Restore number of threads
	AtqSetInfo(AtqDecMaxPoolThreads, NULL);

	return cbRtn;
}



CXHdrAsyncComplete::CXHdrAsyncComplete()  :
    m_currentArticle( INVALID_ARTICLEID ),
    m_loArticle( INVALID_ARTICLEID ),
    m_hiArticle( INVALID_ARTICLEID ),
    m_lpb( 0 ),
    m_cb( 0 ),
    m_cbPrefix( 0 ) {
}

void
CXHdrAsyncComplete::Destroy()  {
/*++

Routine Description :

    This is called when our last reference goes away.
    We don't destruct ourselves at that point - instead
    we get ready for another round !

    NOTE : We cannot touch any members after calling the
        base classes Complete() function - as we can
        be re-entered for another operation !

Arguments :

    None.


Return Value :

    None

--*/

    if( SUCCEEDED(GetResult()) ) {

        if( m_currentArticle > m_hiArticle ) {
            m_fComplete = TRUE ;
            CopyMemory( m_lpb+m_cbTransfer, StrTermLine, 3 );
            m_cbTransfer += 3 ;
        }
        m_cbTransfer += m_cbPrefix ;
    }

    //
    //  When we reset our state we keep our Article Number
    //  and group info - but this buffer stuff is useless now
    //
    m_lpb = 0 ;
    m_cb = 0 ;
    //
    //  Call our base classes completion function ! -
    //  Note if we're note complete we pass TRUE so that
    //  the base class resets for another operation !
    //
    Complete( !m_fComplete ) ;
}

/*
CXHdrCmd::CXHdrCmd( LPSTR       lpstrHeader,
                    CGRPPTR     pGroup,
                    ARTICLEID   artidLow,
                    ARTICLEID   artidHigh ) :
    m_szHeader( lpstrHeader ),
    m_pGroup( pGroup ),
    m_loArticle( artidLow ),
    m_currentArticle( artidLow ),
    m_hiArticle( artidHigh )    {
}
*/
CXHdrCmd::CXHdrCmd( CGRPPTR&  pGroup ) :
    m_pGroup( pGroup )  {
}

CXHdrCmd::~CXHdrCmd( ) {
}

CIOExecute*
CXHdrCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&	pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter( "CXHdrCmd::make" );
    InterlockedIncrementStat( (context.m_pInstance), XHdrCommands );
	NRC	code ;

    if( argc < 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return 0 ;
    }

    DWORD   loRange = 0;
    DWORD   hiRange = 0;

    if( context.m_pCurrentGroup != 0 ) {

        loRange = context.m_pCurrentGroup->GetFirstArticle() ;
        hiRange = context.m_pCurrentGroup->GetLastArticle() ;

        if( context.m_pCurrentGroup->GetArticleEstimate() == 0 ||
            loRange > hiRange ) {

            // If this is NOT a query by msg-id, return an error
            if( !( (argc == 3) && (argv[2][0] == '<') ) ) {
                context.m_return.fSet( nrcNoCurArticle ) ;
                pExecute = new( context ) CErrorCmd( context.m_return ) ;
                return 0 ;
            }
        }
    }

    CGRPPTR pGroup = context.m_pCurrentGroup ;

    if( pGroup && argc == 2 ) {

        if( context.m_idCurrentArticle != INVALID_ARTICLEID &&
            context.m_idCurrentArticle >= loRange ) {

            loRange = hiRange = context.m_idCurrentArticle ;

        }   else    {

            if( context.m_idCurrentArticle == INVALID_ARTICLEID )
                context.m_return.fSet( nrcNoCurArticle ) ;
            else
                context.m_return.fSet( nrcNoSuchArticle ) ;
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return 0 ;
        }

    }   else    if( argc == 3 ) {

        if( argv[2][0] == '<' ) {

            ARTICLEID   artidPrimary ;
            GROUPID     groupidPrimary ;
            WORD        HeaderOffsetJunk ;
            WORD        HeaderLengthJunk ;

			CStoreId storeid;

            if( (context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                    argv[2],
                                                    HeaderOffsetJunk,
                                                    HeaderLengthJunk,
                                                    artidPrimary,
                                                    groupidPrimary,
													storeid) ) {
                pGroup = (context.m_pInstance)->GetTree()->GetGroupById( groupidPrimary ) ;
                if( pGroup == 0 ) {
                    context.m_return.fSet( nrcServerFault ) ;
                    pExecute = new( context ) CErrorCmd( context.m_return ) ;
                    return 0 ;
                }

                // check client access (client could get xhdr info for ANY group)
                if( !pGroup->IsGroupAccessible(
                                    context.m_securityCtx,
       								context.m_encryptCtx,
                                    context.m_IsSecureConnection,
                                    FALSE,
                                    TRUE	) ) {

                    context.m_return.fSet( nrcNoAccess ) ;
                    pExecute = new( context ) CErrorCmd( context.m_return ) ;
                    return 0 ;
                }

                hiRange = loRange = artidPrimary ;

            }   else if( GetLastError() == ERROR_FILE_NOT_FOUND )   {

                context.m_return.fSet( nrcNoSuchArticle ) ;
                pExecute = new( context ) CErrorCmd( context.m_return ) ;
                return 0 ;

            }   else    {

                context.m_return.fSet( nrcServerFault ) ;
                pExecute = new( context ) CErrorCmd( context.m_return ) ;
                return 0 ;

            }

        }   else    if( !pGroup || !GetCommandRange(	argc-1,
														&argv[1],
														&loRange,
														&hiRange,
														code
														) ) {

            if( pGroup == 0 ) {
                context.m_return.fSet( nrcNoGroupSelected ) ;
            }
            else {
                context.m_return.fSet( nrcNoSuchArticle ) ;
            }

            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return 0 ;

        }

    }   else    {

        if( pGroup == 0 ) {
            context.m_return.fSet( nrcNoGroupSelected ) ;
        }
        else {
            context.m_return.fSet( nrcSyntaxError ) ;
        }

        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;

    }

    _ASSERT( pGroup );

    CXHdrCmd*   pXHdrCmd = new( context )   CXHdrCmd( pGroup ) ;
    if ( NULL == pXHdrCmd ) {
        ErrorTrace( 0, "Can not allocate CXHdrCmd" );
        goto exit;
    }

    pXHdrCmd->m_Completion.m_currentArticle =
    pXHdrCmd->m_Completion.m_loArticle = loRange;
    pXHdrCmd->m_Completion.m_hiArticle = hiRange;
    pXHdrCmd->m_Completion.m_szHeader = argv[1];

exit:
    pExecute = pXHdrCmd ;
    return 0 ;
}

CIOWriteAsyncComplete*
CXHdrCmd::FirstBuffer(
            BYTE *lpb,
            int cb,
            ClientContext& context,
            CLogCollector*  pCollector
            )
{

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( m_Completion.m_lpb == 0 ) ;
    _ASSERT( m_Completion.m_cb == 0 ) ;

    static  char    szStart[] = "221 Xhdr information follows\r\n"  ;

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    context.m_nrcLast = nrcHeadFollows ;
    m_Completion.m_cbPrefix = sizeof( szStart ) - 1 ;
    cb -= m_Completion.m_cbPrefix ;
    lpb += m_Completion.m_cbPrefix ;

    m_Completion.m_lpb = lpb ;
    m_Completion.m_cb = cb - 3 ;

    m_pGroup->FillBuffer(
                    &context.m_securityCtx,
                    &context.m_encryptCtx,
                    m_Completion
                    ) ;


    return  &m_Completion ;
}

CIOWriteAsyncComplete*
CXHdrCmd::NextBuffer(
    BYTE *lpb,
    int cb,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    ENTER("CXHdrCmd::NextBuffer")

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( m_Completion.m_lpb == 0 ) ;
    _ASSERT( m_Completion.m_cb == 0 ) ;

    //
    // reserve space for \r\n
    //
    _ASSERT( cb > 2 ) ;
    m_Completion.m_lpb = lpb ;
    m_Completion.m_cb = cb - 3 ;
    m_Completion.m_cbPrefix = 0 ;


    m_pGroup->FillBuffer(
                    &context.m_securityCtx,
                    &context.m_encryptCtx,
                    m_Completion
                    ) ;

    return  &m_Completion ;
}
    
BOOL
GetCommandRange(
    INT argc,
    char **argv,
    PDWORD loRange,
    PDWORD hiRange,
	NRC&	code
    )
{
    PCHAR p;
    DWORD lo, hi;

	code = nrcNotSet ;

    //
    // one number
    //

    if ((p = strchr(argv[1], '-')) == NULL) {
        lo = atol(argv[1]);

        //
        // make sure it's within range
        //

        if ( (lo < *loRange) || (lo > *hiRange) ) {
			code = nrcXoverFollows ;
            return(FALSE);
        }

        *loRange = *hiRange = lo;
        return TRUE;
    }

    //
    // Get the hi + lo part
    //

    *p++ = '\0';
    lo = atol(argv[1]);

    //
    // if lo is
    //

    if ( lo < *loRange ) {
        lo = *loRange;
    }

    //
    // lo number cannot be > than hi limit
    //

    if ( lo > *hiRange ) {
		code = nrcXoverFollows ;
        return(FALSE);
    }

    //
    // if hi is absent, assume hi is the hi limit
    // if hi < lo, return FALSE
    //

    if( *p == '\0' ) {
        hi = *hiRange;
    }
    else if( (hi = atol(p)) < lo ) {
        return(FALSE);
    }

    //
    // if hi > hi limit, assume hi is the hi limit
    //

    if (hi > *hiRange) {
        hi = *hiRange;
    }

    _ASSERT( (*loRange <= lo) && (lo <= hi) && (hi <= *hiRange) );

    *loRange = lo;
    *hiRange = hi;

    return TRUE;

} // GetCommandRange

//
// get GroupID/ArticleID by message ID.  Also checks client permissions...
//
BOOL CheckMessageID(char *szMessageID,              // in
                    struct ClientContext &context,  // in
                    GROUPID *pGroupID,              // out
                    ARTICLEID *pArticleID,          // out
                    CGRPPTR *pGroup)                // out
{
    WORD        HeaderOffsetJunk;
    WORD        HeaderLengthJunk;

	CStoreId storeid;
    if ((context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                    szMessageID,
                                                    HeaderOffsetJunk,
                                                    HeaderLengthJunk,
                                                    *pArticleID,
                                                    *pGroupID,
													storeid))
    {
        *pGroup = (context.m_pInstance)->GetTree()->GetGroupById(*pGroupID);
        if (*pGroup == 0) {
            return FALSE;
        }

        // check security
        if (!(*pGroup)->IsGroupAccessible(	context.m_securityCtx,
               								context.m_encryptCtx,
                                       		context.m_IsSecureConnection,
                                       		FALSE,
                                       		TRUE ) )
        {
            return FALSE;
        }

        return TRUE;
    } else {
        return FALSE;
    }
}

const   unsigned    cbMAX_CEXECUTE_SIZE = MAX_CEXECUTE_SIZE ;
const   unsigned    cbMAX_CIOEXECUTE_SIZE = MAX_CIOEXECUTE_SIZE ;


extern "C" int __cdecl	_purecall(void)
{
	DebugBreak() ;
	  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\connect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    connect.cxx

    This module contains the connection accept routine called by the connection
    thread.


    FILE HISTORY:
        VladimV     30-May-1995     Created

*/
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE   __szTraceSourceFile

#define INCL_INETSRV_INCS
#include "tigris.hxx"

//extern  class   NNTP_IIS_SERVICE*  g_pInetSvc ;


/*******************************************************************

    NAME:       TigrisOnConnect

    SYNOPSIS:   Handles the incoming connection indication from the
                connection thread


    ENTRY:      sNew - New client socket
                psockaddr - Address of new client socket

    HISTORY:

********************************************************************/

VOID NntpOnConnect(
    SOCKET        sNew,
    SOCKADDR_IN*  psockaddrRemote,
    PVOID         pEndpointContext,
    PVOID         pAtqEndpointObject
    )
{
    PIIS_ENDPOINT			pEndpoint    = (PIIS_ENDPOINT)pEndpointContext;
	PNNTP_SERVER_INSTANCE	pInstance    = NULL;
    INT						cbAddr       = sizeof( sockaddr );
	BOOL					fMaxConnectionsExceeded;
    SOCKADDR				sockaddrLocal;
	DWORD					LocalIpAddress;
	DWORD                   dwInstance = 0;

    ENTER("NntpOnConnect");

    if ( getsockname( sNew,
                      &sockaddrLocal,
                      &cbAddr ) != 0 )
    {
		goto sock_exit ;
    }

	//
	//	This is where we associate the connection with the virtual server instance
	//	NOTE: This is different from W3, where the association is done on the HTTP
	//	request. NNTP does not specify domain names in client requests, so a virtual
	//	server is uniquely identified by <IP addr, Port> on the local end.
	//

	LocalIpAddress = ((PSOCKADDR_IN)&sockaddrLocal)->sin_addr.s_addr ;
    pInstance = (PNNTP_SERVER_INSTANCE)pEndpoint->FindAndReferenceInstance(
										NULL,						// Need to pass domain name
										LocalIpAddress,				// Local IP
										&fMaxConnectionsExceeded
										);

	if( pInstance ) {
	    dwInstance = pInstance->QueryInstanceId();
    }

	if( !pInstance ) {
		//
		//	TODO: Check GetLastError() for reason and close socket !!
		//

		if( pInstance ) {
			pInstance->DecrementCurrentConnections();
			pInstance->Dereference();
		}

		BuzzOff( sNew, psockaddrRemote, dwInstance );
		goto sock_exit ;
	}

	//
	//	InitiateConnection will do a pInst->Deref() on failure.
	//

    if ( !pInstance->InitiateConnection(
								(HANDLE)sNew,
								(SOCKADDR_IN*)psockaddrRemote,
                                (SOCKADDR_IN*)&sockaddrLocal,
								NULL,
								pEndpoint->IsSecure()
								)) {

		BuzzOff( sNew, psockaddrRemote, dwInstance );
		goto sock_exit ;
    }
    LEAVE

	return ;

sock_exit:

    //
    //  We failed to use this socket.  Free it up.
    //
    if( !(shutdown( sNew, 2 ) ==0) ) {
        ErrorTrace( (long)sNew, "shutdown failed");
    }
    if( !(closesocket( sNew ) == 0 ) ) {
        ErrorTrace( (long)sNew, "closesocket failed");
    }

	return ;

} // NntpOnConnect

VOID
NntpOnConnectEx(
    VOID * pAtqContext,
    DWORD  cbWritten,
    DWORD  err,
    OVERLAPPED * lpo
    )
/*++
    Description:

        Callback function for new connections when using AcceptEx.
        This function verifies if this is a valid connection
         ( maybe using IP level authentication)
         and creates a new connection object

        The connection object is added to list of active connections.
        If the max number of connections permitted is exceeded,
          the client connection object is destroyed and
          connection is rejected.

    Arguments:

       patqContext:   pointer to ATQ context for the IO operation
       cbWritten:     count of bytes available from first read operation
       dwError:       error if any from initial operation
       lpo:           indicates if this function was called as a result
                       of IO completion or due to some error.

    Returns:

        None.

--*/
{
    BOOL       fAllowConnection    = FALSE;
	BOOL	   fMaxConnectionsExceeded = FALSE;
	DWORD      dwInstance = 0;
    PVOID      pvBuff = 0;
    SOCKADDR * psockaddrLocal = 0;
    SOCKADDR * psockaddrRemote = 0;
    SOCKET     sNew = INVALID_SOCKET;
    PIIS_ENDPOINT pEndpoint;
    PNNTP_SERVER_INSTANCE pInstance;
#ifdef DEBUG
    PCHAR tmpBuffer[1];
#endif

    ENTER("NntpOnConnectEx")

    if ( err || !lpo )
    {
        DebugTrace(0,"[NntpOnConnectEx] Completion failed with error %d, Atq context %lx\n",
                    err, pAtqContext );

		goto sock_exit ;
    }

	_ASSERT( pAtqContext );

    //
    // Get AcceptEx parameters
    //

    AtqGetAcceptExAddrs( (PATQ_CONTEXT) pAtqContext,
                         &sNew,
                         &pvBuff,
                         (PVOID*)&pEndpoint,
                         &psockaddrLocal,
                         &psockaddrRemote );

#ifdef DEBUG
	tmpBuffer[0] = inet_ntoa(((SOCKADDR_IN*)psockaddrRemote)->sin_addr);
	DebugTrace(0,"Remote is %s", tmpBuffer[0]);

	tmpBuffer[0] = inet_ntoa(((SOCKADDR_IN*)psockaddrLocal)->sin_addr);
	DebugTrace(0,"Local is %s", tmpBuffer[0]);
#endif

	_ASSERT( pEndpoint );
    DebugTrace(0,"[NntpOnConnectEx] New connection, AtqCont = %lx, buf = %lx, endp %x written = %d\n",
                    pAtqContext,
                    pvBuff,
                    pEndpoint,
                    cbWritten );

    if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {

        DebugTrace(0,"Connection attempt on inactive service\n");
		BuzzOff( sNew, (PSOCKADDR_IN)psockaddrRemote, dwInstance );

        goto sock_exit;
    }

	//
	//	This is where we associate the connection with the virtual server instance
	//	NOTE: This is different from W3, where the association is done on the HTTP
	//	request. NNTP does not specify domain names in client requests, so a virtual
	//	server is uniquely identified by <IP addr, Port> on the local end.
	//
	//	NOTE1: We need to check to see if MaxConnections is exceeded ! If we reject
	//	a connection, we need to explicitly decrement this count.
	//	NOTE2: The Dereference for this is in the CSessionSocket destructor
	//

    pInstance = (PNNTP_SERVER_INSTANCE)pEndpoint->FindAndReferenceInstance(
										(LPCSTR)NULL,					// domain name
										((PSOCKADDR_IN)psockaddrLocal)->sin_addr.s_addr,	// Local IP
										&fMaxConnectionsExceeded
										);

	if( pInstance ) {
	    dwInstance = pInstance->QueryInstanceId();
    }

	if( !pInstance || fMaxConnectionsExceeded ) {
		//
		//	send refused message and close socket !
		//	TODO: Use GetLastError() to send reason
		//

		ErrorTrace(0,"Unable to find instance [err %d]\n",GetLastError());
		BuzzOff( sNew, (PSOCKADDR_IN)psockaddrRemote, dwInstance );

		if( pInstance ) {
			pInstance->DecrementCurrentConnections();
			pInstance->Dereference();
		}

        goto sock_exit;
	}

	//
	//	Create a session socket and appropriate feed objects and start
	//	NNTP state machines. This also does the IP access check.
	//	InitiateConnection will do a pInst->Deref() on failure.
	//

    if ( !pInstance->InitiateConnection(
								(HANDLE)sNew,
								(SOCKADDR_IN*)psockaddrRemote,
                                (SOCKADDR_IN*)psockaddrLocal,
								pAtqContext,
								pEndpoint->IsSecure()
								)) {
		//
		//	Failed to accept this connection - free it up.
		//
		BuzzOff( sNew, (PSOCKADDR_IN)psockaddrRemote, dwInstance );
		goto sock_exit ;
    }
    LEAVE
	
	return ;

sock_exit:

	//
    //  We failed to use this context.  Free it up.
    //
    if ( !AtqCloseSocket( (PATQ_CONTEXT) pAtqContext, FALSE )) {
		FatalTrace( (DWORD_PTR)pAtqContext, "AtqCloseSocket() failed");
        //  Do not reuse atq context if close failed.
        AtqFreeContext( (PATQ_CONTEXT) pAtqContext, FALSE);
	} else {
		//  Reuse atq context if close succeded
        AtqFreeContext( (PATQ_CONTEXT) pAtqContext, TRUE);
	}

	return ;

} // NntpOnConnectEx

VOID
BuzzOff(
	SOCKET s,
	SOCKADDR_IN* psockaddr,
	DWORD dwInstance )
{
	TraceFunctEnter("BuzzOff");

	//
    // Illegal access!!!
    //

    PCHAR tmpBuffer[2];
    CHAR  szId [20];
    PCHAR  BuzzerMsg = "502 Connection refused\r\n";
    DWORD  cbBuzzerMsg = lstrlen(BuzzerMsg);

    //
    // Send it a nice message before disconnecting
    //

    (VOID)send(s,BuzzerMsg,cbBuzzerMsg,0);

    //
    // Log error in event log
    //

    _itoa( dwInstance, szId, 10 );
    tmpBuffer[0] = szId;
    tmpBuffer[1] = inet_ntoa(psockaddr->sin_addr);
    ErrorTrace(0,"Virtual server %d: Access not allowed for client %s\n",dwInstance,tmpBuffer[0]);

    NntpLogEvent( NNTP_EVENT_CONNECT_DENIED,
                  2,
                  (const CHAR **)tmpBuffer,
                  0 );

	//
    // bye bye
    //

	TraceFunctLeave();
}

BOOL
VerifyClientAccess(
			CSessionSocket*       pSocket,
            SOCKADDR_IN *         psockaddr
            )
/*++

Routine Description:

    This routine verifies that a client can access this server

Arguments:

    psockaddr - the SOCKADDR structure containing the client connect info

Return Value:

    TRUE, client has access
    FALSE, otherwise

--*/
{
	AC_RESULT       acIpAccess;
    BOOL            fNeedDnsCheck = FALSE;
	BOOL			fRet = TRUE;
	struct hostent* pH = NULL;

    ENTER("VerifyClientAccess")

    _ASSERT( pSocket );

	pSocket->QueryAccessCheck()->BindAddr( (PSOCKADDR)psockaddr );
	if ( pSocket->BindInstanceAccessCheck() )
	{
		acIpAccess = pSocket->QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck);
		if ( (acIpAccess == AC_IN_DENY_LIST) ||
				((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) )
		{
			fRet = FALSE;
		}
		else if (fNeedDnsCheck)
		{
			pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)psockaddr)->sin_addr), 4, PF_INET );
			if(pH != NULL)
			{
				acIpAccess = pSocket->QueryAccessCheck()->CheckName(pH->h_name);
			}
			else
			{
				acIpAccess = AC_IN_DENY_LIST;
			}
		}

		if ( (acIpAccess == AC_IN_DENY_LIST) ||
				(acIpAccess == AC_NOT_IN_GRANT_LIST))
		{
			fRet = FALSE;
		}

    	pSocket->UnbindInstanceAccessCheck();
    	
	} else {
	    _ASSERT( FALSE );
    }

	if(!fRet)
	{
		SetLastError(ERROR_ACCESS_DENIED);
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\commands.inl ===
inline
void*	CExecutableCommand::operator	new(	size_t	size,	struct	ClientContext&	context ) {
	static	size_t	MAX_SIZE = cbMAX_CEXECUTE_SIZE ;
	_ASSERT( size<=MAX_SIZE) ;
	_ASSERT(	cbMAX_CEXECUTE_SIZE <= sizeof( context.m_rgbCommandBuff ) ) ;
#ifdef	DEBUG
	//
	//	Put in a marker so we can check for overruns !
	//
	_ASSERT( size+sizeof(DWORD) <= sizeof( context.m_rgbCommandBuff ) ) ;
	DWORD UNALIGNED*	pdw = (DWORD UNALIGNED*)(&context.m_rgbCommandBuff[MAX_SIZE]) ;
	*pdw = 0xABCDDCBA ;
#endif
	return	context.m_rgbCommandBuff ;
}

inline	
void	CExecutableCommand::operator	delete(	void	*pv, size_t size ) {

#ifdef	DEBUG
	//
	//	Check for overruns !!
	//
	DWORD	UNALIGNED*	pdw = (DWORD UNALIGNED *)( &((BYTE*)pv)[cbMAX_CEXECUTE_SIZE]) ;
	_ASSERT( *pdw == 0xABCDDCBA ) ;
	FillMemory( pv, size, 0xCC ) ;
	*pdw = 0xCCCCCCCC ;
#endif
}

#if 0 
inline
void*	CIOExecute::operator	new(	size_t	size ) {
	Assert( size<= MAX_CIOEXECUTE_SIZE ) ;
	return	gIOExecutePool.Alloc() ;
}

inline
void	CIOExecute::operator	delete(	void*	pv ) {
	gIOExecutePool.Free( pv ) ;
}
#endif

inline	void*	
CSessionState::operator	new(	size_t	size )	{

	Assert( size <= max( cbMAX_STATE_SIZE, cbMAX_CIOEXECUTE_SIZE ) ) ;
	void	*pv = gStatePool.Alloc() ;

	return	pv ;
}

inline	void
CSessionState::operator	delete(	void*	pv )	{
	gStatePool.Free( pv ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll/obj is used.

   Author:

        Murali R. Krishnan    ( MuraliK )    21-Feb-1995

   Project:
        W3 Server DLL

   Revision History:
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb | DbgOutputLogFile )


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

#ifdef __cplusplus
 extern "C" {
#endif

 # include <nt.h>
 # include <ntrtl.h>
 # include <nturtl.h>

 # include <windows.h>

 #ifdef __cplusplus
 };
#endif // __cplusplus


# include <pudebug.h>

//
//  Define the debugging constants
//



# define DEBUG_CONNECTION              0x00001000L
# define DEBUG_SOCKETS                 0x00002000L
# define DEBUG_RPC                     0x00004000L

# define DEBUG_INSTANCE                0x00020000L
# define DEBUG_ENDPOINT                0x00040000L
# define DEBUG_METABASE                0x00080000L

# define DEBUG_CGI                     0x00100000L
# define DEBUG_BGI                     0x00200000L
# define DEBUG_SSI                     0x00400000L
# define DEBUG_SERVICE_CTRL            0x00800000L

# define DEBUG_PARSING                 0x01000000L
# define DEBUG_REQUEST                 0x02000000L

# define DEBUG_INIT                    (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP                 (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT                  0x10000000
# define DEBUG_IID                     0x20000000
# define DEBUG_MISC                    0x40000000


//
// Specific macros for W3 svcs module
//
# define  TCP_PRINT              DBGPRINTF
# define  TCP_REQUIRE( exp)      DBG_REQUIRE( exp)


//
// Following macros are useful for formatting and printing out GUIDs
//

# define GUID_FORMAT   "{%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"

# define GUID_EXPAND(pg) \
  (((GUID *) (pg))->Data1), (((GUID *) (pg))->Data2), (((GUID *) (pg))->Data3), \
  (((GUID *) (pg))->Data4[0]),   (((GUID *) (pg))->Data4[1]), \
  (((GUID *) (pg))->Data4[2]),   (((GUID *) (pg))->Data4[3]), \
  (((GUID *) (pg))->Data4[4]),   (((GUID *) (pg))->Data4[5]), \
  (((GUID *) (pg))->Data4[6]),   (((GUID *) (pg))->Data4[7])

    // Usage:  DBGPRINTF(( DBG_CONTEXT, " My Guid: " GUID_FORMAT " \n", 
    //                     GUID_EXPAND( pMyGuid)));

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\cservic.cpp ===
//#---------------------------------------------------------------
//  File:       CServic.cpp
//
//  Synopsis:   This file implements the CService class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

#define INCL_INETSRV_INCS
#include    "tigris.hxx"

#include    <stdlib.h>

#ifndef Assert
#define Assert  _ASSERT
#endif

#if 0
#ifdef  PROFILE
#include	"c:\icecap\icapexp.h"
#endif
#endif

//extern  class   NNTP_IIS_SERVICE*  g_pInetSvc ;

DWORD
CBootOptions::ReportPrint(
        LPSTR   lpstr,
        ...
        )   {
/*++

Routine Description :

    Output a printf style string to our report file.

Arguments :

    Standard wsprintf interface.

Return Value :

    Number of bytes output.

--*/

    long   cch = 0 ;
    if( m_hOutputFile != INVALID_HANDLE_VALUE ) {

        char    szOutput[1024] ;

        va_list arglist ;

        va_start( arglist, lpstr ) ;

        cch = _snprintf( szOutput, sizeof(szOutput)-1, lpstr, arglist ) ;
        szOutput[sizeof(szOutput)-1] = '\0';
        // if data exceed size of buffer, cch will be negative. update the cch to be 1023
        if (cch<0) cch=sizeof(szOutput)-1;

        DWORD   cbWritten = 0 ;

        WriteFile( m_hOutputFile, szOutput, cch, &cbWritten, 0 ) ;

    }
    return  cch ;
}



typedef struct  tagVERTAG {
    LPSTR   pszTag;
} VERTAG, *PVERTAG, FAR *LPVERTAG;



VERTAG  Tags[] = {
    { "FileDescription" },
//  { "OriginalFilename" },
//  { "ProductName" },
    { "ProductVersion" },
//  { "LegalCopyright" },
//  { "LegalCopyright" },
};

#define NUM_TAGS    (sizeof( Tags ) / sizeof( VERTAG ))

DWORD   SetVersionStrings( LPSTR lpszFile, LPSTR lpszTitle, LPSTR   lpstrOut,   DWORD   cbOut   )
{
static char sz[256], szFormat[256], sz2[256];
    int     i;
    UINT    uBytes;
    LPVOID  lpMem;
    DWORD   dw = 0, dwSize;
    HANDLE  hMem;
    LPVOID  lpsz;
    LPDWORD lpLang;
    DWORD   dwLang2;
    BOOL    bRC, bFileFound = FALSE;

    LPSTR   lpstrOrig = lpstrOut ;


    CharUpper( lpszTitle );

    if ( dwSize = GetFileVersionInfoSize( lpszFile, &dw ) ) {
        if ( hMem = GlobalAlloc( GMEM_MOVEABLE|GMEM_ZEROINIT, (UINT)dwSize ) ) {
            lpMem = GlobalLock(hMem);
            if (GetFileVersionInfo( lpszFile, 0, dwSize, lpMem ) &&
                VerQueryValue(  lpMem, "\\VarFileInfo\\Translation",
                                (LPVOID FAR *)&lpLang, &uBytes ) )
            {
                dwLang2 = MAKELONG( HIWORD(lpLang[0]), LOWORD(lpLang[0]) );

                for( i=0; i<NUM_TAGS; i++ ) {

                    lpsz = 0 ;
                    //
                    // need to do the reverse because most winnt files are wrong
                    //
                    wsprintf( sz, "\\StringFileInfo\\%08lx\\%s", lpLang[0], Tags[i].pszTag );
                    wsprintf( sz2, "\\StringFileInfo\\%08lx\\%s", dwLang2, Tags[i].pszTag );
                    bRC =   VerQueryValue( lpMem, sz, &lpsz, &uBytes ) ||
                            VerQueryValue( lpMem, sz2, &lpsz, &uBytes ) ;

                    if( lpsz != 0 )     {

                        if( uBytes+1 < cbOut ) {
                            uBytes = min( (UINT)lstrlen( (char*)lpsz ), uBytes ) ;
                            CopyMemory( lpstrOut, lpsz, uBytes ) ;
                            lpstrOut[uBytes++] = ' ' ;
                            lpstrOut += uBytes ;
                            cbOut -= uBytes ;
                        }   else    {
                            GlobalUnlock( hMem );
                            GlobalFree( hMem );
                            return  (DWORD)(lpstrOut - lpstrOrig) ;
                        }
                    }

                }
                // version info from fixed struct
                bRC = VerQueryValue(lpMem,
                                    "\\",
                                    &lpsz,
                                    &uBytes );

                #define lpvs    ((VS_FIXEDFILEINFO FAR *)lpsz)
                static  char    szVersion[] = "Version: %d.%d.%d.%d" ;

                if ( cbOut > (sizeof( szVersion )*2) ) {

                    CopyMemory( szFormat, szVersion, sizeof( szVersion ) ) ;
                    //LoadString( hInst, IDS_VERSION, szFormat, sizeof(szFormat) );

                    DWORD   cbPrint = wsprintf( lpstrOut, szFormat, HIWORD(lpvs->dwFileVersionMS),
                                LOWORD(lpvs->dwFileVersionMS),
                                HIWORD(lpvs->dwFileVersionLS),
                                LOWORD(lpvs->dwFileVersionLS) );
                    lpstrOut += cbPrint ;

                }
                bFileFound = TRUE;
            }   else    {

            }

            GlobalUnlock( hMem );
            GlobalFree( hMem );
        }       else    {

        }
    }   else    {

    }
    DWORD   dw2 = GetLastError() ;

    return  (DWORD)(lpstrOut - lpstrOrig) ;
}


BOOL
GetRegDword(
        HKEY hKey,
        LPSTR pszValue,
        LPDWORD pdw
        )
/*++

Routine Description :

    Helper function for getting DWORD's out of the registry !

Arguments :

    hKey - registry key to look under
    pszValue - The name of the value
    pdw - Pointer to DWORD to receive value

Return Value :

    TRUE if successfull, false otherwise.

--*/
{
    DWORD   cbData = sizeof( DWORD );
    DWORD   dwType = REG_DWORD;

    return  RegQueryValueEx(hKey,
                            pszValue,
                            NULL,
                            &dwType,
                            (LPBYTE)pdw,
                            &cbData ) == ERROR_SUCCESS && dwType == REG_DWORD;
}

void
StartHintFunction( void ) {
/*++

Routine Description :

    Function provided to hash tables to call during boot up.
    Advances start hints with SCM.

Arguments :

    None.

Return Value :

    None.

--*/

    TraceFunctEnter("StartHintFunction");

    if ( g_pInetSvc && g_pInetSvc->QueryCurrentServiceState() == SERVICE_START_PENDING )
    {
        g_pInetSvc->UpdateServiceStatus(
									SERVICE_START_PENDING,
                                    NO_ERROR,
                                    g_pNntpSvc->m_cStartHints,
                                    SERVICE_START_WAIT_HINT
									) ;

        g_pNntpSvc->m_cStartHints ++ ;
    }
}

void
StopHintFunction( void ) {
/*++

Routine Description :

    Function to call during shutdown
    Advances stop hints with SCM.

Arguments :

    None.

Return Value :

    None.

--*/

    TraceFunctEnter("StopHintFunction");

    if ( g_pInetSvc && g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING )
    {
        g_pInetSvc->UpdateServiceStatus(
									SERVICE_STOP_PENDING,
                                    NO_ERROR,
                                    g_pNntpSvc->m_cStopHints,
                                    SERVICE_STOP_WAIT_HINT
									) ;

        g_pNntpSvc->m_cStopHints ++ ;
    }
}

//+---------------------------------------------------------------
//
//  Function:   EnumUserShutdown
//
//  Synopsis:   Called to teardown active users
//
//  Arguments:  pUser: active CUser instance
//
//  Returns:    void
//
//  History:    gordm       Created         11 Jul 1995
//
//----------------------------------------------------------------
BOOL EnumSessionShutdown( CSessionSocket* pUser, DWORD lParam,  PVOID   lpv )
{
    TraceFunctEnter( "CService::EnumUserShutdown" );

    DebugTrace( (LPARAM)pUser,
                "Terminating CSessionSocket %x", pUser);

    pUser->Disconnect();
    return  TRUE;
}

/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/

APIERR
GetDefaultDomainName(
    STR * pstrDomainName
    )
{

    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    APIERR                      err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;

	TraceFunctEnter("GetDefaultDomainName");

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        DebugTrace(0,"cannot open lsa policy, error %08lX\n",NtStatus );
        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Query the domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&DomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {
        DebugTrace(0,"cannot query lsa policy info, error %08lX\n",NtStatus );
        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Compute the required length of the ANSI name.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // dwFlags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  NULL,                 // lpMultiByteStr
                                  0,                    // cchMultiByte
                                  NULL,                 // lpDefaultChar
                                  NULL                  // lpUsedDefaultChar
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Resize the output string as appropriate, including room for the
    //  terminating '\0'.
    //

    if( !pstrDomainName->Resize( (UINT)Result + 1 ) )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Convert the name from UNICODE to ANSI.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // flags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  pstrDomainName->QueryStr(),
                                  pstrDomainName->QuerySize() - 1,  // for '\0'
                                  NULL,
                                  NULL
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();

        DebugTrace(0,"cannot convert domain name to ANSI, error %d\n",err );
        goto Cleanup;
    }

    //
    //  Ensure the ANSI string is zero terminated.
    //

    _ASSERT( (DWORD)Result < pstrDomainName->QuerySize() );

    pstrDomainName->QueryStr()[Result] = '\0';
    pstrDomainName->SetLen(Result);

    //
    //  Success!
    //

    _ASSERT( err == 0 );

    DebugTrace(0,"GetDefaultDomainName: default domain = %s\n",pstrDomainName->QueryStr() );

Cleanup:

    if( DomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)DomainInfo );
    }

    if( LsaPolicyHandle != NULL )
    {
        LsaClose( LsaPolicyHandle );
    }

    return err;

}   // GetDefaultDomainName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\debug.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains debug stuff

Author:

    Johnson Apacible (JohnsonA)     11-Jan-1996

Revision History:

--*/

#ifndef _NNTPDEBUG_
#define _NNTPDEBUG_


//
// If this is set, then memory debugging is on
//

#define ALLOC_DEBUG     0

extern DWORD numField;
extern DWORD numArticle;
extern DWORD numPCParse;
extern DWORD numPCString;
extern DWORD numDateField;
extern DWORD numCmd;
extern DWORD numFromPeerArt;
extern DWORD numMapFile;

#endif // _NNTPDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\cservice.h ===
//
// CService.h
//
//  This file defines the service object that will be the main wrapper class
//  of the TIGRIS server.
//  This class has largely been stolen from shuttle as it is now.
//
//  Implementation Schedule for all classes defined by this file, and
//  related helper functions to interact with the Gibralter Service architecture.
//      1.5 week
//
//  Unit Test Schedule :
//      0.5 week
//
//      Unit testing will consist of starting and stopping the service
//      and accepting connections.
//



#ifndef _CSERVICE_H_
#define _CSERVICE_H_

//
//  Private constants.
//

#define NNTP_MODULE_NAME      "nntpsvc.dll"

//
//	Cancel states
//
#define NNTPBLD_CMD_NOCANCEL		0
#define NNTPBLD_CMD_CANCEL_PENDING	1
#define NNTPBLD_CMD_CANCEL			2

//
//	Forwards
//
class CSessionSocket ;
class CGroupIterator ;

//
//	Constants
//
//	- Used to decide whether to manipulate socket buffer sizes.
#define	BUFSIZEDONTSET	(-1)

BOOL GetRegDword( HKEY hKey, LPSTR pszValue, LPDWORD pdw );
void StartHintFunction( void ) ;
void StopHintFunction( void ) ;
BOOL EnumSessionShutdown( CSessionSocket* pUser, DWORD lParam,  PVOID   lpv ) ;
DWORD   SetVersionStrings( LPSTR lpszFile, LPSTR lpszTitle, LPSTR   lpstrOut,   DWORD   cbOut   ) ;
APIERR
GetDefaultDomainName(
    STR * pstrDomainName
    );

//
// Nntp Roles
//

typedef enum _NNTP_ROLE {

    RolePeer,
    RoleMaster,
    RoleSlave,
    RoleClient,
    RoleMax

} NNTP_ROLE;

struct  TIGRIS_STATISTICS_0   {

    DWORD   TimeStarted ;
    DWORD   LastClear ;
    DWORD   NumClients ;
    DWORD   NumServers ;
    DWORD   NumUsers ;
    DWORD   LogonAttempts ;
    DWORD   LogonFailures ;
    DWORD   LogonSuccess ;
} ;

typedef TIGRIS_STATISTICS_0*  PTIGRIS_STATISTICS_0 ;

struct  NNTPBLD_STATISTICS_0   {

	__int64	  NumberOfArticles ;
	__int64	  NumberOfXPosts ;
    __int64   ArticleHeaderBytes ;
    __int64   ArticleTotalBytesSI ;
	__int64	  ArticleTotalBytesMI ;
    __int64   ArticlePrimaryXOverBytes ;
    __int64   ArticleXPostXOverBytes ;
    __int64   ArticleMapBytes ;
    __int64   ArticlePrimaryIndexBytes ;
    __int64   ArticleXPostIndexBytes ;
} ;

typedef NNTPBLD_STATISTICS_0*  PNNTPBLD_STATISTICS_0 ;

class	CBootOptions	{
public : 

	//
	//	Specify whether to blow away all old data structures 
	//
	BOOL DoClean ;

	//
	//	If TRUE then don't delete the history file regardless of other settings.
	//
	BOOL NoHistoryDelete ;

	//
	//	Omit non leaf dirs while generating the group list file
	//
	BOOL OmitNonleafDirs ;

	//
	//	If TRUE, dont delete existing xix files
	//
	DWORD ReuseIndexFiles ;

	//
	//	Name of a file containing either an INN style 'Active' file or 
	//	a tool generate newsgroup list file.  Either way, we will pull
	//	newsgroups out of this file and use them to build a news tree.	
	//
	char	szGroupFile[MAX_PATH] ;
	
	//
	//	Name of a temparory group.lst file used by STANDARD rebuild
	//	to store temparory group.lst information.  Normally group.lst.tmp
	//
	char	szGroupListTmp[MAX_PATH] ;
	
	//
	//	If TRUE, rebuild will skip any corrupted groups found.
	//	Only apply to STANDARD rebuild.
	//
	BOOL SkipCorruptGroup ;

	//
	//  If TRUE, rebuild will skip any corrupted vroots, if FASLE
	//  rebuild will fail if any one vroot failed somewhere during
	//  rebuild
	//
	BOOL SkipCorruptVRoot;

	//
	//	Number of newsgroups being skipped by STANDARD rebuild.
	//	And total number of newsgroups being rebuilt.
	//
	DWORD m_cGroupSkipped ;
	DWORD m_cGroups ;

	//
	//
	//	If TRUE then szGroupFile specifies an INN style Active file,
	//	otherwise it specifies a tool generate human edit newsgroup list.
	//
	BOOL IsActiveFile ;	

	//
	//	This is set when the rebuild thread is ready. This is after we
	//	clean out the hash tables.
	//
	BOOL IsReady ;

	//
	//	Handle to the file where we want to save our output.
	//
	HANDLE	m_hOutputFile ;

	//
	//	Handle to check for shutdown
	//
	HANDLE	m_hShutdownEvent ;

	//
	//	Number of worker threads to spawn for the rebuild
	//
	DWORD	cNumThreads ;

	//
	//	Rebuild thread should check if init failed
	//
	BOOL    m_fInitFailed ;

	//
	//	Newsgroup iterator shared by multiple rebuild threads
	//
	CGroupIterator* m_pIterator ;

	//
	//	Lock to synch access to shared iterator
	//
	CRITICAL_SECTION m_csIterLock;

	//
	//	Total number of files to process
	//
	DWORD	m_dwTotalFiles ;

	//
	//	Current number of files processed
	//
	DWORD	m_dwCurrentFiles ;

	//
	//	Cancel state
	//
	DWORD	m_dwCancelState ;

	//
	//	Get stats during nntpbld
	//
	NNTPBLD_STATISTICS_0	NntpbldStats;

	//
	//	Verbose in report file
	//
	BOOL	fVerbose;

	DWORD
	ReportPrint(	
			LPSTR	szString,		
			...
			) ;

	CBootOptions()	{
		DoClean = FALSE ;
		NoHistoryDelete = FALSE ;
		OmitNonleafDirs = FALSE ;
		ReuseIndexFiles = 0  ;
		SkipCorruptGroup = FALSE  ;
		SkipCorruptVRoot = FALSE;
		m_cGroupSkipped = 0  ;
		m_cGroups = 0  ;
		m_hOutputFile = INVALID_HANDLE_VALUE ;
		m_hShutdownEvent = NULL ;
		cNumThreads = 0 ;
		m_fInitFailed = FALSE;
		m_pIterator = NULL;
		m_dwTotalFiles = 0 ;
		m_dwCurrentFiles = 0;
		IsActiveFile = FALSE ;
		IsReady = FALSE ;
		m_dwCancelState = NNTPBLD_CMD_NOCANCEL ;
		ZeroMemory( szGroupFile, sizeof( szGroupFile ) ) ;
		ZeroMemory( szGroupListTmp, sizeof( szGroupListTmp ) ) ;
		ZeroMemory( &NntpbldStats, sizeof( NntpbldStats ) );
	} ;
} ;

#endif  // _CSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\expire.cpp ===
#include "tigris.hxx"

// global ptr to shutdown hint function
SHUTDOWN_HINT_PFN	gpfnHint = NULL;

//
//  Implementation of simple multi-thread safe queue: used for storing rmgroups
//
CQueue::CQueue()
{
	m_pHead = NULL;
	m_pTail = NULL;
    m_cNumElems = 0;

	// Create crit sect to synchronize adds/dels
    InitializeCriticalSection(&m_csQueueLock);
}

CQueue::~CQueue()
{
	QueueElem *pElem;

    LockQ();

	while (m_pHead)
	{
		pElem = m_pHead;
		m_pHead = m_pHead->pNext;
		XDELETE pElem;
        pElem = NULL;
        m_cNumElems--;
	}

    UnlockQ();

    _ASSERT(m_cNumElems == 0);

    DeleteCriticalSection(&m_csQueueLock);
	m_pHead = m_pTail = NULL;
}

// remove an element from the queue
// TRUE if an element was removed successfully - in this case *ppGroup is the element
// FALSE if the queue is empty - in this case *ppGroup is set to NULL
BOOL
CQueue::Dequeue( CGRPPTR *ppGroup)
{
    QueueElem *pElem;

	_ASSERT(ppGroup);

	LockQ();

    if(IsEmpty())
    {
		*ppGroup = NULL;
		UnlockQ();
        return FALSE;
    }

	pElem = m_pHead;
    _ASSERT(pElem);

	*ppGroup = pElem->pGroup;
	m_pHead = m_pHead->pNext;

	// adjust tail if needed
	if(m_pTail == pElem)
		m_pTail = m_pHead;

	XDELETE pElem;
    pElem = NULL;
	m_cNumElems--;

	UnlockQ();

	return TRUE;
}

// TRUE if enqueue succeeds
// FALSE if enqueue fails - it will fail only if we run out of memory
BOOL
CQueue::Enqueue( CGRPPTR pGroup )
{
	LockQ();

	m_cNumElems++;

	if (m_pHead == NULL)
	{
		m_pHead = XNEW QueueElem;
        if(!m_pHead)
		{
			UnlockQ();
            return FALSE;
		}

		m_pTail = m_pHead;
	}
	else
	{
		QueueElem *pElem = m_pTail;
		m_pTail = XNEW QueueElem;
        if(!m_pTail)
		{
			UnlockQ();
            return FALSE;
		}

		pElem->pNext = m_pTail;
	}

	m_pTail->pNext = NULL;
	m_pTail->pGroup = pGroup;

	UnlockQ();

	return TRUE;
}

// TRUE if queue contains a pGroup with lpGroupName - the pGroup object is returned in *ppGroup
// FALSE otherwise - *ppGroup is NULL
BOOL
CQueue::Search(
	CGRPPTR *ppGroup,
	LPSTR lpGroupName
	)
{
	QueueElem  *pElem, *pPrev;

	_ASSERT(ppGroup);
	_ASSERT(lpGroupName);

	LockQ();

	if(IsEmpty())
	{
		*ppGroup = NULL;
		UnlockQ();
		return FALSE;
	}

	BOOL fFound = FALSE;

	pElem = m_pHead;
	pPrev = NULL;
	while (pElem)
	{
		if(!lstrcmp(lpGroupName, pElem->pGroup->GetName()))
		{
			*ppGroup = pElem->pGroup;

			if(pElem == m_pHead)
				m_pHead = m_pHead->pNext;		// first node
			else
				pPrev->pNext = pElem->pNext;	// intermediate or last node

			// adjust tail if needed
			if(pElem == m_pTail)
				m_pTail = pPrev;

			// delete the node
			XDELETE pElem;
			pElem = NULL;
			m_cNumElems--;

			// found this group
			fFound = TRUE;
			break;
		}

		// next node, remember previous one
		pPrev = pElem;
		pElem = pElem->pNext;
	}

	UnlockQ();

	return fFound;
}

//
//	Implementation of CExpire methods !
//

CExpire::CExpire( LPCSTR lpMBPath )
{
	m_ExpireHead = m_ExpireTail = 0 ;
	m_FExpireRunning  = FALSE;
	m_RmgroupQueue = NULL;
    m_cNumExpireBlocks = 0;

	lstrcpy( m_szMDExpirePath, lpMBPath );
	lstrcat( m_szMDExpirePath, "/Expires/" );
}

CExpire::~CExpire()
{
}

BOOL
CExpire::ExpireArticle(
				CNewsTree*		pTree,
				GROUPID			GroupId,
				ARTICLEID		ArticleId,
				STOREID         *pstoreid,
				CNntpReturn &	nntpReturn,
				HANDLE          hToken,
				BOOL            fMustDelete,
				BOOL            fAnonymous,
				BOOL            fFromCancel,
                BOOL            fExtractNovDone,
                LPSTR           lpMessageId
				)
/*++

Routine Description:

	Physically and Logically deletes an article from the news tree. All
    pointers to the article are removed. The MessageID is moved to the
    history table. The file the article resides in is removed immediately or
    moved to a directory where it will be deleted eventually.

Arguments:

	pTree - Newstree to expire article from
    GroupId - newsgroup id
    ArticleId - article id to expire
    storeid - Store id for this article
	nntpReturn - The return value for this function call
	fMustDelete - Should I expire the article even if I cannot delete physical article ?
    fExtractNovDone - ExtractNovEntry has been done, so dont repeat the call
    lpMessageId - MessageId found by calling ExtractNovEntry

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
    BOOL fRet = FALSE;

	TraceFunctEnter( "CExpire::ExpireArticle" );

	nntpReturn.fSetClear(); // clear the return object

    char  szMessageId[MAX_MSGID_LEN];
    DWORD cMessageId = sizeof( szMessageId ) ;
    FILETIME FileTime;
    DWORD   dwErr;

    if( !fExtractNovDone ) {

    	//DebugTrace( DWORD(0), "Expire 1. Get MessageId for (%d,%d)", GroupId, ArticleId ) ;
        // 1. Get MessageId
        //
        BOOL  fPrimary;
	    WORD	HeaderOffset ;
	    WORD	HeaderLength ;
		DWORD cStoreIds = 0;
        if ( !XOVER_TABLE(pTree)->ExtractNovEntryInfo(
                                GroupId,
                                ArticleId,
                                fPrimary,
							    HeaderOffset,
							    HeaderLength,
                                &FileTime,
                                cMessageId,
                                szMessageId,
								cStoreIds,
								NULL,
								NULL)
           )
        {
            // Without a MessageId, we can't remove the article pointers in the ArticleTable or
            // place a record of the article in the HistoryTable.
            //
            // If the data structure are intact, then the caller is deleting something that doesn't
            // exist. If the data structures are corrupt and the caller has a Messageid (perhaps by
            // opening the article file), then we might consider writing a delete function that takes
            // MessageId as an argument.
            //
            DebugTrace( DWORD(0), "Expire: SearchNovEntry Error %d on (%lu/%lu)", GetLastError(), GroupId, ArticleId );
            nntpReturn.fSet( nrcNoSuchArticle );
            return FALSE;
        }
        szMessageId[ min(cMessageId, sizeof(szMessageId)-1) ] = '\0';
        lpMessageId = szMessageId;
    }

    _ASSERT( lpMessageId );

	//DebugTrace( DWORD(0), "Expire 3. Get all the other news groups" ) ;
    // 3. Get all the other news groups
    //
    DWORD nGroups = INITIAL_NUM_GROUPS;
    DWORD BufferSize = nGroups * sizeof(GROUP_ENTRY);
    PGROUP_ENTRY pGroupBuffer = XNEW GROUP_ENTRY[nGroups];
    if ( NULL == pGroupBuffer ) {
        return FALSE;
    }
    PBYTE rgcStoreCrossposts = XNEW BYTE[nGroups];
    if ( NULL == rgcStoreCrossposts ) {
        XDELETE pGroupBuffer;
        return FALSE;
    }

    if ( !XOVER_TABLE(pTree)->GetArticleXPosts(
                            GroupId,
                            ArticleId,
                            FALSE,
                            pGroupBuffer,
                            BufferSize,
                            nGroups,
                            rgcStoreCrossposts
                            )
       )
    {
		DWORD err = GetLastError();
        XDELETE pGroupBuffer;
        XDELETE rgcStoreCrossposts;
        if ( ERROR_INSUFFICIENT_BUFFER == err )
        {
            // Reallocate buffer and try again.
            //
            nGroups = (BufferSize + sizeof(GROUP_ENTRY) - 1)/ sizeof(GROUP_ENTRY);
            BufferSize = nGroups * sizeof(GROUP_ENTRY);
            pGroupBuffer = XNEW GROUP_ENTRY[nGroups];
            if ( NULL == pGroupBuffer ) {
                return FALSE;
            }
            rgcStoreCrossposts = XNEW BYTE[nGroups];
            if ( NULL == rgcStoreCrossposts ) {
                XDELETE pGroupBuffer;
                return FALSE;
            }

            if ( !XOVER_TABLE(pTree)->GetArticleXPosts(
                                GroupId,
                                ArticleId,
                                FALSE,
                                pGroupBuffer,
                                BufferSize,
                                nGroups,
                                rgcStoreCrossposts
                                ) ) {

                XDELETE pGroupBuffer;
                XDELETE rgcStoreCrossposts;
                return FALSE;
            }

            // SUCCESS on second try.
            //
        }
        else
        {
            // Information is not available at this time.
            //
			ErrorTrace( DWORD(0), "Expire: GetArticleXPosts Error %d on (%lu/%lu)", GetLastError(), GroupId, ArticleId );
            nntpReturn.fSet( nrcNoSuchArticle );
            return FALSE;
        }
    }

    //
    // Now we should loop through all the store's and ask the store wide primary group
    // to delete the physical article.  If the server wide ( the first store wide )
    // primary article is physically deleted, then we'll go ahead and delete hash table entries
    // otherwise we'll stop expiring this article.  As long as the server wide primary
    // article is deleted, all group's will do DeleteLogicArticle to update their
    // watermarks.
    //
    int     iStore = 0;
    CGRPPTR pGroup;
    for ( DWORD i = 0; i < nGroups; i += rgcStoreCrossposts[iStore++] ) {

        //
        // We don't want to get groups if the tree has been stopped
        //
        pGroup = pTree->GetGroupById( pGroupBuffer[i].GroupId, FALSE );

        // pGroup could be 0, if this group has been deleted
        if(pGroup != 0)
        {
            // We should still check if the primary group is in exchange store, if it
            // is, we should not call its deletearticle method
            CNNTPVRoot *pVRoot = pGroup->GetVRoot();
            if ( fFromCancel || pVRoot && !pVRoot->HasOwnExpire() ) {

                // We don't have to save fixed properties for primary group at this time,
                // fixed properties will be saved back to group.lst when the whole group's
                // expiration is completed
                fRet = pGroup->DeletePhysicalArticle( hToken, fAnonymous, pGroupBuffer[i].ArticleId, pstoreid );
                dwErr = GetLastError();
            } else {

                //
                // If it's a exchange vroot, we should always logically delete it
                //
                fRet = TRUE;
            }

            if ( pVRoot ) pVRoot->Release();
        }

        //
        // We only bail if we failed deleting server wide primary article, in
        // this case, either the article has already been deleted or is being
        // used.  If it has already been deleted, somebody else has already
        // taken care of it.  If there is opening sharing violation, we'll leave
        // the next round expire to take care of it
        //
        if ( i == 0 && !fRet && !fMustDelete ) {
            ErrorTrace( 0, "Can not delete server wide article, bail expire %d",
                        GetLastError() );
            nntpReturn.fSet( nrcNoSuchArticle );
            XDELETE pGroupBuffer;
            XDELETE rgcStoreCrossposts;
            return FALSE;
        }
    }

    //
    // We only go ahead and expire the article logically when we
    // have physically deleted it, or when it's an exchange
    // vroot, or the failure didn't occur on a server wide primary article
    //
    //
    // Add history entry here so that if somebody else has already
    // expired this article, we are done
    //
	GetSystemTimeAsFileTime( &FileTime ) ;
    if ( FALSE == HISTORY_TABLE(pTree)->InsertMapEntry( lpMessageId, &FileTime ) )
    {
         //
	     // another thread has already expired this article - bail !
	     // in fact this is very unlikely to happen because if another thread
	     // has already inserted the history entry, he should have already
	     // deleted the primary article and we won't be able to come here.  But
	     // just to be safe ...
	     //
	     DWORD dwError = GetLastError();
	     _ASSERT( ERROR_ALREADY_EXISTS == dwError );

	     ErrorTrace( DWORD(0), "Expire: History.InsertMapEntry Error %d on (%lu/%lu)", dwError, GroupId, ArticleId );
         nntpReturn.fSet( nrcHashSetFailed, lpMessageId, "History", dwError );
         XDELETE pGroupBuffer;
         XDELETE rgcStoreCrossposts;
         return FALSE;
    }

    //DebugTrace( DWORD(0), "Expire 5/6. Delete XoverTable/ArticleTable pointers" ) ;
    // 5. Delete XoverTable pointers using group/article pair.
    // 6. Delete ArticleTable pointers using MessageId.
    //
    if( !XOVER_TABLE(pTree)->DeleteNovEntry( GroupId, ArticleId ) )
	{
		// someone else deleted this entry or hash table shutdown - bail !
		DWORD dwError = GetLastError();
		_ASSERT( ERROR_FILE_NOT_FOUND == dwError );

        DebugTrace( DWORD(0), "Expire: DeleteNovEntry Error %d on (%lu/%lu)", dwError, GroupId, ArticleId );
        nntpReturn.fSet( nrcNoSuchArticle );
		XDELETE pGroupBuffer;
		XDELETE rgcStoreCrossposts;
		return FALSE;
	}

	//
	// Delete logical article for this guy, we do want to get group even
	// if the tree has been stopped, since we already deleted its physical article
	//
	pGroup = pTree->GetGroupById( GroupId, TRUE );
	if ( pGroup ) pGroup->DeleteLogicalArticle( ArticleId );

	//
	// Delete the article table entry, we'll continue even if we failed on this
	//
	ARTICLE_TABLE(pTree)->DeleteMapEntry( lpMessageId );

    //
	//DebugTrace( DWORD(0), "Expire 8. Delete article logically from all the cross-posted newsgroups." ) ;
    // 8. Delete article logically from all the cross-posted newsgroups.
    //
    for ( i = 0; i < nGroups; i++ )
    {
        if ( GROUPID_INVALID != pGroupBuffer[i].GroupId && GroupId != pGroupBuffer[i].GroupId )
        {
			DebugTrace( DWORD(0), "Expire: Deleting (%lu/%lu) logically from cross-posted newsgroups.", pGroupBuffer[i].GroupId, pGroupBuffer[i].ArticleId ) ;

            pGroup = pTree->GetGroupById( pGroupBuffer[i].GroupId, TRUE );

            if ( pGroup != 0 ) {

			    // delete the xover entry for this logical article
		        if( !XOVER_TABLE(pTree)->DeleteNovEntry( pGroupBuffer[i].GroupId, pGroupBuffer[i].ArticleId ) ) {
				    ErrorTrace( DWORD(0), "Expire: DeleteNovEntry Error %d on (%lu/%lu)", GetLastError(), pGroupBuffer[i].GroupId, pGroupBuffer[i].ArticleId );
			    } else {
                    pGroup->DeleteLogicalArticle( pGroupBuffer[i].ArticleId );
                }

                // We have to ask secondary group to save fixed property every time
                // one article has been deleted out of it logically
                pGroup->SaveFixedProperties();
            }
        }
    }

    XDELETE pGroupBuffer;
    XDELETE rgcStoreCrossposts;
    nntpReturn.fSetOK();
    return fRet;
}

BOOL
CExpire::ProcessXixBuffer(
            CNewsTree*  pTree,
            BYTE*       lpb,
            int         cb,
            GROUPID     GroupId,
            ARTICLEID   artidLow,
            ARTICLEID   artidHigh,
            DWORD&      dwXixSize
            )
/*++

Routine Description:

    This function takes an article range and the XIX info for this range
    and expires all articles in this range.

Arguments:

    pTree     -  CNewsTree object
    lpb       -  xix buffer
    cb        -  size of data in xix buffer (including a terminating NULL)
    GroupId   -  group id for xix data
    artidLow  -  low range to expire
    artidHigh -  high range to expire
    dwXixSize -  sum of sizes of all articles expired in this xix file

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
    BOOL fRet = TRUE;
    return fRet;
}

FILETIME
gCalculateExpireFileTime( DWORD dwExpireHorizon )
{

    // Calulcate Expire Horizon
    //
    FILETIME ftCurrentTime;
    ULARGE_INTEGER liCurrentTime, liExpireHorizon;
    GetSystemTimeAsFileTime( &ftCurrentTime );
    LI_FROM_FILETIME( &liCurrentTime, &ftCurrentTime );
    liExpireHorizon.QuadPart  = 1000 * 1000 * 10; // to achieve units of seconds
    liExpireHorizon.QuadPart *= 60 * 60;          // to achieve units of hours
    liExpireHorizon.QuadPart *= dwExpireHorizon;
    liCurrentTime.QuadPart -= liExpireHorizon.QuadPart;
    FILETIME ftExpireHorizon;
    FILETIME_FROM_LI( &ftExpireHorizon, &liCurrentTime );
    return ftExpireHorizon;
}

BOOL
CExpire::DeletePhysicalArticle( CNewsTree* pTree, GROUPID GroupId, ARTICLEID ArticleId, STOREID *pStoreId, HANDLE hToken, BOOL fAnonymous )
{
    BOOL fRet = TRUE;

    CGRPPTR  pGroup = pTree->GetGroupById( GroupId );

    if(pGroup != 0)
        fRet = pGroup->DeletePhysicalArticle( hToken, fAnonymous, ArticleId, pStoreId );
    else
        fRet = FALSE;

    return fRet;
}

//
// Detailed Design
//
// FOR every wild match string in multi_sz registry key,
//    Size = 0
//    Heap = empty
//    FOR every news group in the wild match string
//       FOR every physical article in the news group
//           IF file date of physical article is too old
//               Expire Article
//           ELSE
//               IF Heap is full
//                   Remove youngest article from Heap
//               ENDIF
//               Size += Size of article
//               Insert Article into Heap in oldest to youngest order.
//           ENDIF
//       ENDFOR
//    ENDFOR
//    IF Size is too big
//        Sort Heap
//        WHILE Size is too big AND Heap isn't empty
//            Size -= Size of oldest article
//            Expire oldest article
//            Remove oldest article from Heap
//        ENDWHILE
//        IF Heap is empty
//            Reprocess current wild match string
//        ELSE
//            Process next wild match string
//        ENDIF
//    ELSE
//        Process next wild match string
//    ENDIF
// ENDFOR
//

void
CExpire::ExpireArticlesBySize( CNewsTree* pTree )
{
}

typedef enum _ITER_TURN
{
    itFront,
    itBack
} ITER_TURN;

BOOL
CExpire::MatchGroupExpire( CGRPPTR pGroup )
/*++
    Check if the vroot that the group belongs to does expiration
    itself.
--*/
{
    BOOL    bExpire;

    CNNTPVRoot *pVRoot = pGroup->GetVRoot();
    if ( pVRoot ) {
        bExpire = pVRoot->HasOwnExpire();
        pVRoot->Release();
    } else bExpire = FALSE;

    return !bExpire;
}

BOOL
CExpire::MatchGroupEx(	LPMULTISZ	multiszPatterns,	CGRPPTR pGroup ) {

	Assert( multiszPatterns != 0 ) ;
	LPSTR lpstrGroup = pGroup->GetName();

    if( multiszPatterns == 0 ) {
        return  MatchGroupExpire( pGroup ) ;
    }

	LPSTR	lpstrPattern = multiszPatterns ;

	while( *lpstrPattern != '\0' )	{
		if( *lpstrPattern == '!' ) {
			_strlwr( lpstrPattern+1 );
			if( HrMatchWildmat( lpstrGroup, lpstrPattern+1 ) == ERROR_SUCCESS ) {
				return	FALSE ;
			}
		}	else	{
			_strlwr( lpstrPattern );
			if( HrMatchWildmat( lpstrGroup, lpstrPattern ) == ERROR_SUCCESS ) {
				return	MatchGroupExpire( pGroup ) ;
			}
		}
		lpstrPattern += lstrlen( lpstrPattern ) + 1 ;
	}
	return	FALSE ;
};

//
// Detailed Design
//
//    Make a newsgroup iterator on *
//    FOR every newsgroup in this iterator
//       + Evaluate the group against the list of expire policies
//       and set the most aggressive time policy.
//       + Queue this group on the expire thrdpool
//    ENDFOR
//

void
CExpire::ExpireArticlesByTime( CNewsTree* pTree )
{
    TraceFunctEnter( "CExpire::ExpireArticlesByTime" );

    //
    // No work if number of expire policies == 0
    //
    LockBlockList();
    if( m_cNumExpireBlocks == 0 ) {
        UnlockBlockList();
        return;
    }
    UnlockBlockList();

    //
    // Prepare ftExpireHorizon (TIME) and dwExpireSpace (SIZE)
    // NOTE: This function will process only those policies with
    // dwExpireSpace == 0xFFFFFFFF
    //

    BOOL fDoFileScan = FALSE;
    DWORD cPreTotalArticles = ((pTree->GetVirtualServer())->ArticleTable())->GetEntryCount();
    DWORD cPreArticlesExpired = ((pTree->GetVirtualServer())->m_NntpStats).ArticlesExpired;
    pTree->BeginExpire( fDoFileScan );

    CGroupIterator* pIteratorFront = pTree->ActiveGroups(TRUE, NULL, FALSE, NULL);
    CGroupIterator* pIteratorBack  = pTree->ActiveGroups(TRUE, NULL, FALSE, NULL, TRUE);
    ITER_TURN itTurn = itFront;

    if (pIteratorFront && pIteratorBack) {
	    for ( ;!pIteratorFront->IsEnd() && !pIteratorBack->IsBegin()
            && !pTree->m_bStoppingTree; )
	    {
            CGRPPTR pGroup;
            if( itTurn == itFront ) {
                pGroup = pIteratorFront->Current();
            } else {
                pGroup = pIteratorBack->Current();
            }

            //
            //  Evaluate group against configured expire policies
            //

            BOOL fIsMatch = FALSE;
            FILETIME ftZero = {0};
            FILETIME minft = ftZero;
            LPEXPIRE_BLOCK	expireCurrent = NextExpireBlock( 0 )  ;
            while ( expireCurrent )
            {
                DWORD	cbNewsgroups = 0 ;
                PCHAR   multiszNewsgroups = 0;
                DWORD   dwExpireHorizon;
                DWORD   dwExpireSpace;
                BOOL    fIsRoadKill = FALSE ;
                FILETIME ft;

                if (GetExpireBlockProperties(	expireCurrent,
                                            multiszNewsgroups,
                                            cbNewsgroups,
                                            dwExpireHorizon,
                                            dwExpireSpace,
                                            FALSE,
                                            fIsRoadKill ))
                {
                    _ASSERT( multiszNewsgroups );
                    if (dwExpireSpace == 0xFFFFFFFF) {
	                    if( MatchGroupEx( multiszNewsgroups, pGroup ) ) {
	                        //
	                        //  SetExpireTime should set the most aggressive expire by time
	                        //
	                        ft = gCalculateExpireFileTime( dwExpireHorizon );

	                        //
	                        //  Always set the most aggressive expire horizon.
	                        //
	                        if( CompareFileTime( &ftZero, &minft ) == 0 ) {
	                            minft = ft;
	                        } else if( CompareFileTime( &ft, &minft ) > 0 ) {
	                            minft = ft;
	                        }

	                        fIsMatch = TRUE;
	                    }
                    }

                    FREE_HEAP( multiszNewsgroups ) ;
                    multiszNewsgroups = NULL ;
                }

                expireCurrent = NextExpireBlock( expireCurrent ) ;
            }

            if( fIsMatch && !pGroup->IsDeleted()
                && ( fDoFileScan || !(pGroup->GetFirstArticle() > pGroup->GetLastArticle()))  ) {
                //
                //  ok, now that the group has been evaluated against all the expire policies
                //  on the system, put it on the thrdpool.
                //  NOTE: queue the group id on the thrdpool so it handles groups being deleted
                //  while on the queue.
                //

                _ASSERT( CompareFileTime( &ftZero, &minft ) != 0 );
                pGroup->SetGroupExpireTime( minft );

                DebugTrace(0,"Adding group %s to expire thrdpool", pGroup->GetName());
                if( !g_pNntpSvc->m_pExpireThrdpool->PostWork( (PVOID)(SIZE_T)pGroup->GetGroupId() ) ) {
                    //
                    //  TODO: If PostWork() fails, call WaitForJob() so the queue can be drained
                    //
                    _ASSERT( FALSE );
                }
            }

            // terminating condition - both iterators point at the same group
            if( pIteratorFront->Meet( pIteratorBack ) ) {
                DebugTrace(0,"Front and back iterators converged: group is %s", pGroup->GetName());
                break;
            }

            // advance either the front or back iterator and reverse the turn
            if( itTurn == itFront ) {
                pIteratorFront->Next();
                itTurn = itBack;
            } else {
                pIteratorBack->Prev();
                itTurn = itFront;
            }
        }
    }

    XDELETE pIteratorFront;
    pIteratorFront = NULL;
    XDELETE pIteratorBack;
    pIteratorBack = NULL;

    //
    //  ok, now cool our heels till the expire thrdpool finishes this job !!
    //
    pTree->EndExpire();
    DWORD cPercent = 0;
    //DWORD cPostTotalArticles = ((pTree->GetVirtualServer())->ArticleTable())->GetEntryCount();
    DWORD cPostArticlesExpired = ((pTree->GetVirtualServer())->m_NntpStats).ArticlesExpired;

    //
    // if we expired less than 10% of the total articles in this expire run,
    // we will do file scan on the next expire run.
    // Set pTree->m_cNumExpireByTimes to gNewsTreeFileScanRate, so next time CheckExpire.
    // will set fFileScan to TRUE
    //
    //
    if ((cPreTotalArticles == 0) ||
        (cPercent = (DWORD)( ((float)(cPostArticlesExpired-cPreArticlesExpired) / (float)cPreTotalArticles) * 100 )) < 10 )
    {
        pTree->m_cNumExpireByTimes = gNewsTreeFileScanRate;
        pTree->m_cNumFFExpires++;

        //
        //  caveat to the above comment - every so often (gNewsTreeFileScanRate)
        //  we will ensure that the other scan gets a chance to run...
        //
        if( pTree->m_cNumFFExpires % gNewsTreeFileScanRate == 0 ) {
            pTree->m_cNumExpireByTimes--;
            pTree->m_cNumFFExpires = 1;
        }
    }

    if( cPercent > 0 ) {
	    PCHAR	args[3] ;
        CHAR    szId[12];
        CHAR    szPercent[12];

        _itoa( pTree->GetVirtualServer()->QueryInstanceId(), szId, 10 );
        args[0] = szId;
        args[1] = fDoFileScan ? "HardScan" : "SoftScan";
        _itoa( cPercent, szPercent, 10 );
        args[2] = szPercent;

	    NntpLogEvent(
		    	NNTP_EVENT_EXPIRE_BYTIME_LOG,
			    3,
			    (const char **)args,
			    0
			    ) ;
    }

    DebugTrace( DWORD(0), "Articles Expired by Time" );
}

//
//	Return FALSE on failure. If the failure is fatal, set fFatal to TRUE.
//

BOOL
CExpire::InitializeExpires( SHUTDOWN_HINT_PFN  pfnHint, BOOL& fFatal, DWORD dwInstanceId )
{
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	TraceFunctEnter( "CExpire::InitializeExpires" ) ;

	// set the shutdown hint function
	gpfnHint = pfnHint;

	InitializeCriticalSection( &m_CritExpireList ) ;
	EnterCriticalSection( &m_CritExpireList ) ;

	DWORD	i = 0 ;
	DWORD   error;
    CHAR	Newsgroups[1024];
	CHAR	keyName[METADATA_MAX_NAME_LEN+1];
    DWORD	NewsgroupsSize = sizeof( Newsgroups );
	CHAR	ExpirePolicy[1024];
	DWORD	ExpirePolicySize = sizeof( ExpirePolicy );
	BOOL	fSuccessfull = TRUE ;

    if ( !mb.Open( QueryMDExpirePath(),
			METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {
		error = GetLastError();
		NntpLogEventEx(NNTP_NTERROR_EXPIRE_MBOPEN,
			0,
			NULL,
			error,
			dwInstanceId
			);
		fSuccessfull = FALSE ;

    }	else	{
		while( 1 ) {

		    DWORD	dwExpireHorizon = DEFAULT_EXPIRE_HORIZON;
			DWORD	dwExpireSpace = DEFAULT_EXPIRE_SPACE;

			ZeroMemory( Newsgroups, sizeof( Newsgroups ) ) ;

			if( !mb.EnumObjects( "",
								 keyName,
								 i++ ) )
			{
				// done enumerating feed keys
				error = GetLastError();
				if (error != ERROR_NO_MORE_ITEMS) {
					ErrorTrace(0,"Error %d enumerating feeds\n",error);
					fSuccessfull = FALSE ;
				}

				break ;
			}

			DWORD Value;

			if ( !mb.GetDword(	keyName,
								MD_EXPIRE_SPACE,
								IIS_MD_UT_SERVER,
								&Value ) )
			{
				PCHAR	tmpBuf[2] ;
				tmpBuf[0] = StrExpireSpace ;
				tmpBuf[1] = keyName ;
				error = GetLastError();

				NntpLogEventEx(	NNTP_NTERROR_EXPIRE_VALUE,
								2,
								(const CHAR **)tmpBuf,
								error,
								dwInstanceId
								) ;
				fSuccessfull = FALSE ;

				//
				//	expire policy exists but value is missing
				//

				if( !mb.DeleteObject( keyName ) ) {
					ErrorTrace(0,"Error %d deleting %s", GetLastError(), keyName);
				}

				continue ;

			} else {
				dwExpireSpace = max( 1, Value );
			}

			if ( !mb.GetDword(	keyName,
								MD_EXPIRE_TIME,
								IIS_MD_UT_SERVER,
								&Value ) )
			{
				PCHAR	tmpBuf[2] ;
				tmpBuf[0] = StrExpireHorizon ;
				tmpBuf[1] = keyName ;
				error = GetLastError();

				NntpLogEventEx(	NNTP_NTERROR_EXPIRE_VALUE,
								2,
								(const CHAR **)tmpBuf,
								error,
								dwInstanceId) ;
				fSuccessfull = FALSE ;

				//
				//	expire policy exists but value is missing
				//

				if( !mb.DeleteObject( keyName ) ) {
					ErrorTrace(0,"Error %d deleting %s", GetLastError(), keyName);
				}

				continue ;

			} else {
				dwExpireHorizon = max( 1, Value );
			}

			//
			// Get Newsgroups
			//

			{
				NewsgroupsSize = sizeof( Newsgroups );
				MULTISZ msz( Newsgroups, NewsgroupsSize );
				if( !mb.GetMultisz(	keyName,
									MD_EXPIRE_NEWSGROUPS,
									IIS_MD_UT_SERVER,
									&msz  ) )
				{
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrExpireNewsgroups;
					tmpBuf[1] = keyName ;
					error = GetLastError();

					NntpLogEventEx(	NNTP_NTERROR_EXPIRE_VALUE,
									2,
									(const CHAR **)tmpBuf,
									error,
									dwInstanceId) ;
					fSuccessfull = FALSE ;

					//
					//	expire policy exists but value is missing
					//

					if( !mb.DeleteObject( keyName ) ) {
						ErrorTrace(0,"Error %d deleting %s", GetLastError(), keyName);
					}

					continue ;

				}

                NewsgroupsSize = msz.QueryCCH();
			}

			//
			// Get expire policy
			//

            ExpirePolicySize = sizeof( ExpirePolicy );
			if( !mb.GetString(	keyName,
								MD_EXPIRE_POLICY_NAME,
								IIS_MD_UT_SERVER,
								ExpirePolicy,
								&ExpirePolicySize  ) )
			{
				{
					// default !
					PCHAR	tmpBuf[2] ;

					tmpBuf[0] = StrExpirePolicy ;
					tmpBuf[1] = keyName ;
					error = GetLastError();

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
									2,
									(const CHAR **)tmpBuf,
									error,
									dwInstanceId) ;

					fSuccessfull = FALSE ;

					//
					//	expire policy exists but value is missing
					//

					if( !mb.DeleteObject( keyName ) ) {
						ErrorTrace(0,"Error %d deleting %s", GetLastError(), keyName);
					}

					continue ;
				}
			}

			LPEXPIRE_BLOCK	lpExpire = AllocateExpireBlock(
											keyName,
											dwExpireSpace,
											dwExpireHorizon,
											Newsgroups,
											NewsgroupsSize,
											(PCHAR)ExpirePolicy,
											FALSE ) ;

			if( lpExpire )
				InsertExpireBlock( lpExpire ) ;
			else	{
				fSuccessfull = FALSE ;
				fFatal = TRUE ;
				break ;
			}

		}	// end while(1)

		mb.Close();

	}	// end if

	LeaveCriticalSection( &m_CritExpireList ) ;

	// Expire object is ready for use
	if( fSuccessfull ) {
		m_FExpireRunning = TRUE ;
	}

    if(!InitializeRmgroups()) {
        fSuccessfull = FALSE;
		fFatal = FALSE;
	}

	return	fSuccessfull ;
}

BOOL
CExpire::TerminateExpires( CShareLockNH* pLockInstance )		{

	BOOL	fRtn = FALSE ;

	//
	//	if expire thread is partying on this instance, block
	//	till it finishes. since we have called StopTree() we
	//	should not have to wait for long..
	//

	pLockInstance->ExclusiveLock();
	m_FExpireRunning = FALSE ;
	pLockInstance->ExclusiveUnlock();

	EnterCriticalSection( &m_CritExpireList ) ;

	LPEXPIRE_BLOCK	expire = NextExpireBlock( 0 ) ;

	while( expire ) {

		LPEXPIRE_BLOCK	expireNext = NextExpireBlock( expire ) ;
		CloseExpireBlock( expire ) ;
		expire = expireNext ;
	}

	LeaveCriticalSection( &m_CritExpireList ) ;
	DeleteCriticalSection( &m_CritExpireList ) ;

	return	fRtn ;
}

BOOL
CExpire::CreateExpireMetabase(	LPEXPIRE_BLOCK	expire ) {

	_ASSERT( expire != 0 ) ;
	_ASSERT( expire->m_ExpireId == 0 ) ;

	TraceFunctEnter( "CExpire::CreateExpireMetabase" ) ;

	char	keyName[ EXPIRE_KEY_LENGTH ] ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
	static	int		i = 1 ;
	DWORD	expireId = 0 ;
	BOOL	fSuccessfull = TRUE ;

    _ASSERT(QueryMDExpirePath() != NULL);

	if( !mb.Open( QueryMDExpirePath(), METADATA_PERMISSION_WRITE ) ) {
		ErrorTrace(0,"Error %d opening %s\n",GetLastError(),QueryMDExpirePath());
		return FALSE ;
	}

	while( i > 0 ) {

		//
		// Find a name for this expire
		//

		expireId = i++;
		wsprintf(keyName,"expire%d", expireId);

		DebugTrace(0,"Opening %s\n", keyName);

		if( !mb.AddObject( keyName ) ) {

			if( GetLastError() == ERROR_ALREADY_EXISTS ) {
				continue;	// try the next number
			}

			ErrorTrace(0,"Error %d adding %s\n", GetLastError(), keyName);
			mb.Close();
			return FALSE ;
		} else {
			break ;	// success - added it !
		}
	}

	_VERIFY( mb.Close() );
//	_VERIFY( mb.Save()  );

	expire->m_ExpireId = expireId ;

	if( !SaveExpireMetabaseValues( NULL, expire ) ) {

        ErrorTrace(0,"Update metabase failed. Deleting %s\n",keyName);

#if 0
		if( !mb.DeleteObject( keyName ) ) {
			ErrorTrace(0,"Error %d deleting %s\n",GetLastError(),keyName);
		}
#endif

		fSuccessfull = FALSE ;
	}

	return	fSuccessfull ;
}

BOOL
CExpire::SaveExpireMetabaseValues(
							MB* pMB,
							LPEXPIRE_BLOCK	expire
							) {

	TraceFunctEnter( "CExpire::SaveExpireMetabaseValues" ) ;


	char	keyName[ EXPIRE_KEY_LENGTH ] ;
	LPSTR	regstr ;
	DWORD	error ;
	BOOL	fOpened = FALSE ;
	BOOL	fRet = TRUE ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() ) ;

	_ASSERT( expire->m_ExpireId != 0 ) ;
	wsprintf( keyName, "expire%d", expire->m_ExpireId ) ;

	if( pMB == NULL ) {

		if( !mb.Open( QueryMDExpirePath(), METADATA_PERMISSION_WRITE ) ) {
			error = GetLastError();
            ErrorTrace(0,"Error %d opening %s\n",error,keyName);
			return	FALSE ;
		}

		pMB = &mb;
		fOpened = TRUE;
	}
					
    if( !pMB->SetString(	keyName,
							MD_KEY_TYPE,
							IIS_MD_UT_SERVER,
							NNTP_ADSI_OBJECT_EXPIRE,
							METADATA_NO_ATTRIBUTES
    					) )
	{
		regstr = "KeyType" ;
		fRet = FALSE ;
		goto exit;
	}

	if ( !pMB->SetDword(	keyName,
							MD_EXPIRE_SPACE,
							IIS_MD_UT_SERVER,
							expire->m_ExpireSize ) )
	{
		regstr = StrExpireSpace ;
		fRet = FALSE ;
		goto exit;
	}

	if ( !pMB->SetDword(	keyName,
							MD_EXPIRE_TIME,
							IIS_MD_UT_SERVER,
							expire->m_ExpireHours ) )
	{
		regstr = StrExpireHorizon ;
		fRet = FALSE ;
		goto exit;
	}

	if ( !pMB->SetData(	keyName,
						MD_EXPIRE_NEWSGROUPS,
						IIS_MD_UT_SERVER,
						MULTISZ_METADATA,
						expire->m_Newsgroups[0],
						MultiListSize(expire->m_Newsgroups)
						) )
	{
		regstr = StrExpireNewsgroups ;
		fRet = FALSE ;
	}

	if ( !pMB->SetString(	keyName,
							MD_EXPIRE_POLICY_NAME,
							IIS_MD_UT_SERVER,
							expire->m_ExpirePolicy
							) )
	{
		regstr = StrExpirePolicy ;
		fRet = FALSE ;
	}

exit:

	if( fOpened ) {
		pMB->Close();
		pMB->Save();
	}

	return	fRet ;
}

void
CExpire::MarkForDeletion( LPEXPIRE_BLOCK	expire	) {

	TraceFunctEnter( "CExpire::MarkForDeletion" ) ;

	_ASSERT( expire != 0 ) ;
	char	keyName[ EXPIRE_KEY_LENGTH ] ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() ) ;
	_ASSERT( expire->m_ExpireId != 0 ) ;

	EnterCriticalSection( &m_CritExpireList ) ;

	if( expire->m_ExpireId != 0 ) {
		wsprintf( keyName, "expire%d", expire->m_ExpireId ) ;

		if( !mb.Open( QueryMDExpirePath(), METADATA_PERMISSION_WRITE ) ) {
			ErrorTrace(0,"Error %d opening %s\n",GetLastError(),QueryMDExpirePath());
			return;
		}

		if( !mb.DeleteObject( keyName ) ) {
			ErrorTrace(0,"Error %d deleting %s\n",GetLastError(),keyName);
		}

		_VERIFY( mb.Close() );
		_VERIFY( mb.Save()  );
	}

	expire->m_fMarkedForDeletion = TRUE ;

	LeaveCriticalSection( &m_CritExpireList ) ;
}


LPEXPIRE_BLOCK
CExpire::AllocateExpireBlock(
				IN	LPSTR	KeyName	OPTIONAL,
				IN	DWORD	ExpireSpace,
				IN	DWORD	ExpireHorizon,
				IN	PCHAR	Newsgroups,
				IN	DWORD	NewsgroupSize,
				IN  PCHAR   ExpirePolicy,
				IN	BOOL	IsUnicode ) {


	LPEXPIRE_BLOCK	expireBlock = 0 ;
	LPSTR ExpirePolicyAscii = NULL;

	if( IsUnicode ) {

		ExpirePolicyAscii =
			(LPSTR)ALLOCATE_HEAP( (wcslen( (LPWSTR)ExpirePolicy ) + 1) * sizeof(WCHAR) ) ;
		if( ExpirePolicyAscii != 0 ) {
			CopyUnicodeStringIntoAscii( ExpirePolicyAscii, (LPWSTR)ExpirePolicy ) ;
		}	else	{
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			return 0;
		}

	}	else	{

		ExpirePolicyAscii =
			(LPSTR)ALLOCATE_HEAP( lstrlen(ExpirePolicy) + 1 ) ;
		if( ExpirePolicyAscii != 0 ) {
			lstrcpy( ExpirePolicyAscii, ExpirePolicy ) ;
		}	else	{
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			return 0;
		}
	}

    LPSTR*	lpstrNewsgroups = AllocateMultiSzTable(
                                            Newsgroups,
                                            NewsgroupSize,
                                            IsUnicode
                                            );
	if( lpstrNewsgroups == 0 ) {
		if( ExpirePolicyAscii ) {
			FREE_HEAP( ExpirePolicyAscii );
		}
		return	0 ;
	}

#if 0
	LPSTR*	plpstrTemp = ReverseMultiSzTable( lpstrNewsgroups ) ;

	if( plpstrTemp != NULL )	{
		FREE_HEAP( lpstrNewsgroups ) ;
		lpstrNewsgroups = plpstrTemp ;
	}	else	{
		FREE_HEAP( lpstrNewsgroups ) ;
		return 0 ;
	}
#endif

	if( lpstrNewsgroups != 0 ) {

		expireBlock = (LPEXPIRE_BLOCK)ALLOCATE_HEAP( sizeof( EXPIRE_BLOCK ) ) ;
		if( expireBlock != NULL ) {

			ZeroMemory( expireBlock, sizeof( *expireBlock ) ) ;

			if( KeyName != 0 ) {
				if( sscanf( KeyName + sizeof("expire")-1, "%d", &expireBlock->m_ExpireId ) != 1 ||
					expireBlock->m_ExpireId == 0 ) {
					FREE_HEAP( expireBlock ) ;
					FREE_HEAP( lpstrNewsgroups ) ;
					FREE_HEAP( ExpirePolicyAscii ) ;
					return 0 ;
				}
			}

			expireBlock->m_ExpireSize = ExpireSpace ;
			expireBlock->m_ExpireHours = ExpireHorizon ;

			//
			// store newsgroup list
			//
			expireBlock->m_Newsgroups = lpstrNewsgroups ;
			expireBlock->m_fMarkedForDeletion = FALSE ;
			expireBlock->m_references = 0 ;
			expireBlock->m_ExpirePolicy = ExpirePolicyAscii ;
		}	else	{
			FREE_HEAP( lpstrNewsgroups ) ;
			FREE_HEAP( ExpirePolicyAscii ) ;
			return 0 ;
		}
	}
	return	expireBlock ;
}

void
CExpire::CloseExpireBlock( LPEXPIRE_BLOCK	expire ) {

	EnterCriticalSection( &m_CritExpireList ) ;

	expire->m_references -- ;

	if( expire->m_references == 0 && expire->m_fMarkedForDeletion ) {

		RemoveExpireBlock( expire ) ;

		if( expire->m_Newsgroups != 0 ) {
			FREE_HEAP( expire->m_Newsgroups ) ;
		}
		if( expire->m_ExpirePolicy != 0 ) {
			FREE_HEAP( expire->m_ExpirePolicy ) ;
		}
		FREE_HEAP( expire ) ;
	}

	LeaveCriticalSection( &m_CritExpireList ) ;
}

DWORD
CExpire::CalculateExpireBlockSize(	LPEXPIRE_BLOCK	expire )	{

	DWORD	cb = sizeof( NNTP_EXPIRE_INFO ) ;

	cb += MultiListSize( expire->m_Newsgroups ) * sizeof( WCHAR ) ;
	cb += (lstrlen( expire->m_ExpirePolicy )+1) * sizeof( WCHAR ) ;

	return	cb ;
}


void
CExpire::InsertExpireBlock(	LPEXPIRE_BLOCK	expire ) {

	_ASSERT( expire != 0 ) ;

	EnterCriticalSection( &m_CritExpireList ) ;

	_ASSERT(expire->m_pNext == 0 ) ;
	_ASSERT(expire->m_pPrev == 0 ) ;

	if( m_ExpireHead == 0 ) {
		_ASSERT( m_ExpireTail == 0 ) ;
		m_ExpireHead = m_ExpireTail = expire ;
	}	else	{
		expire->m_pNext = m_ExpireHead ;
		m_ExpireHead->m_pPrev = expire ;

		m_ExpireHead = expire ;
	}

    m_cNumExpireBlocks++;
	LeaveCriticalSection( &m_CritExpireList ) ;
}

void
CExpire::RemoveExpireBlock(	LPEXPIRE_BLOCK	expire ) {

	_ASSERT( expire != 0 ) ;

	EnterCriticalSection( &m_CritExpireList ) ;

	if( expire->m_pNext != 0 ) {
		expire->m_pNext->m_pPrev = expire->m_pPrev ;
	}

	if( expire->m_pPrev != 0 ) {
		expire->m_pPrev->m_pNext = expire->m_pNext ;
	}

	if( expire == m_ExpireHead ) {
		m_ExpireHead = expire->m_pNext ;
	}

	if( expire == m_ExpireTail ) {
		m_ExpireTail = expire->m_pPrev ;
	}

    m_cNumExpireBlocks--;
	LeaveCriticalSection( &m_CritExpireList ) ;
}

void
CExpire::LockBlockList()
{
    EnterCriticalSection( &m_CritExpireList ) ;
}

void
CExpire::UnlockBlockList()
{
    LeaveCriticalSection( &m_CritExpireList ) ;
}

LPEXPIRE_BLOCK
CExpire::NextExpireBlock(	LPEXPIRE_BLOCK	expire, BOOL fIsLocked ) {

    if( !fIsLocked ) {
	    EnterCriticalSection( &m_CritExpireList ) ;
    }

	LPEXPIRE_BLOCK	expireOut = 0 ;
	if( expire == 0 ) {
		expireOut = m_ExpireHead ;
	}	else	{
		expireOut = expire->m_pNext ;
	}

	if( expire ) {
		CloseExpireBlock( expire ) ;
	}

	if( expireOut ) {
		expireOut->m_references ++ ;
	}

    if( !fIsLocked ) {
	    LeaveCriticalSection( &m_CritExpireList ) ;
    }

	return	expireOut ;
}

LPEXPIRE_BLOCK
CExpire::SearchExpireBlock(	DWORD	ExpireId ) {

	EnterCriticalSection( &m_CritExpireList ) ;

	LPEXPIRE_BLOCK	expire = 0 ;

	expire = m_ExpireHead ;

	while( expire != 0 && expire->m_ExpireId != ExpireId ) {
		expire = expire->m_pNext ;
	}

	if( expire ) {
		expire->m_references ++ ;
	}

	LeaveCriticalSection( &m_CritExpireList ) ;
	return	expire ;
}


BOOL
CExpire::GetExpireBlockProperties(	IN	LPEXPIRE_BLOCK	lpExpireBlock,
							PCHAR&	Newsgroups,
							DWORD&	cbNewsgroups,
							DWORD&	dwHours,
							DWORD&	dwSize,
							BOOL	fWantUnicode,
                            BOOL&   fIsRoadKill )		{


	_ASSERT( lpExpireBlock != 0 ) ;

	BOOL fOK = FALSE;

	EnterCriticalSection( &m_CritExpireList ) ;

	dwHours = lpExpireBlock->m_ExpireHours ;

	dwSize = lpExpireBlock->m_ExpireSize ;

    fIsRoadKill = (strstr( lpExpireBlock->m_ExpirePolicy, "@EXPIRE:ROADKILL" ) != NULL) ;

	DWORD	length = MultiListSize( lpExpireBlock->m_Newsgroups ) ;

	if( fWantUnicode ) {

		length *= sizeof( WCHAR ) ;
		if( length == 0 ) {
			Newsgroups = (char*)ALLOCATE_HEAP( 2*sizeof( WCHAR ) ) ;
			if( Newsgroups ) {
				Newsgroups[0] = L'\0' ;
				Newsgroups[1] = L'\0' ;
				fOK = TRUE ;
			}
		}	else	{
			Newsgroups = (char*)ALLOCATE_HEAP( length ) ;
			if( Newsgroups != 0 ) {
				WCHAR*	dest = (WCHAR*)Newsgroups ;
				char*	src = lpExpireBlock->m_Newsgroups[0] ;
				for( DWORD	 i=0; i<length; i+=2 ) {
					*(dest)++ = (WCHAR) *((BYTE*)src++) ;
				}
				fOK = TRUE ;
			}
		}
	}	else	{

		if( length == 0 ) {
			Newsgroups = (char*)ALLOCATE_HEAP( 2*sizeof( char ) ) ;
			if( Newsgroups != 0 ) {
				Newsgroups[0] = '\0' ;
				Newsgroups[1] = '\0' ;
				fOK = TRUE ;
			}
		}	else	{
			Newsgroups = (char*)ALLOCATE_HEAP( length ) ;
			if( Newsgroups != 0 ) {
				CopyMemory( Newsgroups, lpExpireBlock->m_Newsgroups[0], length ) ;
				fOK = TRUE ;
			}
		}
	}

	if (fOK)
		cbNewsgroups = length ;
	LeaveCriticalSection( &m_CritExpireList ) ;
	return	fOK ;
}

// called by InitializeExpires
BOOL
CExpire::InitializeRmgroups()
{
	_ASSERT( gpfnHint );

    m_RmgroupQueue = XNEW CQueue;
    if(!m_RmgroupQueue)
        return FALSE;

    return TRUE;
}

// called in CService::Stop before pTree->TermTree()
BOOL
CExpire::TerminateRmgroups( CNewsTree* pTree )
{
	_ASSERT( gpfnHint );

    if(m_RmgroupQueue)
    {
		// If the queue containing deferred rmgroup objects is not empty, process it
		// This could happen if the service is stopped before the next expire cycle kicks in
		if(!m_RmgroupQueue->IsEmpty()) {
			ProcessRmgroupQueue( pTree );
		}

        XDELETE m_RmgroupQueue;
        m_RmgroupQueue = NULL;
    }

    return TRUE;
}

// Process the rmgroup queue
// Called by the expire thread and when the service is stopped
void
CExpire::ProcessRmgroupQueue( CNewsTree* pTree )
{
    BOOL	fElem;
	DWORD	dwStartTick = GetTickCount();

    _ASSERT(m_RmgroupQueue);
	_ASSERT( gpfnHint );

    TraceFunctEnter("CExpire::ProcessRmgroupQueue");

    //
    //  Process all elements in the queue
    //  For each element, call DeleteArticles() to delete all articles in this group
    while(!m_RmgroupQueue->IsEmpty())
    {
        DebugTrace((LPARAM)0, "Dequeueing a rmgroup item");

        CGRPPTR pGroup;
        CGRPPTR pTreeGroup;

        fElem = m_RmgroupQueue->Dequeue( &pGroup);

        if(!fElem)
            break;

        _ASSERT(pGroup);

        // Now, delete all articles in the group
        // This includes removing entries in the hash tables and handling cross-posted articles
        if(!pGroup->DeleteArticles( gpfnHint, dwStartTick ))
        {
            // handle error
            ErrorTrace( (LPARAM)0, "Error deleting articles from newsgroup %s", pGroup->GetName());
        }

        //
        // If the group has been re-created, we'll only delete the articles
        // within our range.  Otherwise we'll remove the whole group physically
        //
        if ( pTreeGroup = pTree->GetGroup( pGroup->GetGroupName(),
                                            pGroup->GetGroupNameLen() )) {
            DebugTrace( 0, "We shouldn't remove the physical group" );
        } else {
		    if ( !pTree->RemoveDriverGroup( pGroup ) ) {
			    ErrorTrace( (LPARAM)0, "Error deleting directory: newsgroup %s", pGroup->GetName());
			}
		}

        DebugTrace((LPARAM)0, "Deleted all articles in newsgroup %s", pGroup->GetName());
    }

    TraceFunctLeave();
}

#if 0

//
// Detailed Design
//
// FOR every wild match string in multi_sz registry key,
//    FOR every news group in the wild match string
//       FOR every article from 'low' to 'high' do
//           Get article filetime from xover.hsh
//           IF article is older than expire horizon
//              Expire Article
//           ELSE
//              Stop scanning articles in this group
//           ENDIF
//       ENDFOR
//    ENDFOR
//    Process next wild match string
// ENDFOR
//

void
CExpire::ExpireArticlesByTimeEx( CNewsTree* pTree )
{
    TraceFunctEnter( "CExpire::ExpireArticlesByTime" );

    //
    // Prepare ftExpireHorizon (TIME) and dwExpireSpace (SIZE)
    // NOTE: This function will process only those policies with
    // dwExpireSpace == 0xFFFFFFFF
    //
    DWORD    dwExpireHorizon;
    DWORD    dwExpireSpace;
    IteratorNode* rgIteratorList;
    DWORD    NumIterators = 0;

    //
    //  Lock the expire block list so we can create our iterator array
    //
    LockBlockList();

    if( m_cNumExpireBlocks == 0 ) {
        //  No work to be done !
        UnlockBlockList();
        return;
    }

    //  No need to clean up this array since its off the stack..
    rgIteratorList = (IteratorNode*)_alloca( m_cNumExpireBlocks * sizeof(IteratorNode) );
    ZeroMemory( (PVOID)rgIteratorList, m_cNumExpireBlocks * sizeof(IteratorNode) );

    LPEXPIRE_BLOCK	expireCurrent = NextExpireBlock( 0, TRUE )  ;
    while ( expireCurrent )
    {
        DWORD	cbNewsgroups = 0 ;
        CGroupIterator* pIterator = 0 ;
        BOOL fIsRoadKill = FALSE ;

        if ( (dwExpireSpace == 0xFFFFFFFF) &&
        	GetExpireBlockProperties(	expireCurrent,
                                        rgIteratorList [NumIterators].multiszNewsgroups,
                                        cbNewsgroups,
                                        dwExpireHorizon,
                                        dwExpireSpace,
                                        FALSE,
                                        fIsRoadKill ) )
        {
            pIterator = pTree->GetIterator( (LPMULTISZ)rgIteratorList [NumIterators].multiszNewsgroups, TRUE, TRUE );
            rgIteratorList [NumIterators].pIterator = pIterator;
            rgIteratorList [NumIterators].ftExpireHorizon = gCalculateExpireFileTime( dwExpireHorizon );

        } else if( rgIteratorList[NumIterators].multiszNewsgroups )  {
            _ASSERT( dwExpireSpace != 0xFFFFFFFF ); // policy has expire by size settings
            FREE_HEAP( rgIteratorList[NumIterators].multiszNewsgroups ) ;
            rgIteratorList[NumIterators].multiszNewsgroups = NULL;
        }

        NumIterators++;
        expireCurrent = NextExpireBlock( expireCurrent, TRUE ) ;
    }

    UnlockBlockList();

    //
    //  ok, now that we have the list of expire iterators, we will round-robin
    //  groups from this list into the expire thread pool. this ensures that
    //  admins who configure virtual roots across multiple drives get the max
    //  parallelism from their drives !!
    //
    g_pNntpSvc->m_pExpireThrdpool->BeginJob( (PVOID)pTree );

    BOOL fMoreGroups = FALSE;
    do {
        //
        //  Round-robin between the group iterators as long as any iterator
        //  has more groups to process..
        //
        fMoreGroups = FALSE;
        for( DWORD i=0; i<NumIterators; i++)
        {
            CGroupIterator* pIterator = rgIteratorList[i].pIterator;
            if( pIterator && !pIterator->IsEnd() )
            {
                //  Get the current group of this iterator and put it on the thrdpool
                CGRPPTR  pGroup = pIterator->Current();
                pGroup->SetGroupExpireTime( rgIteratorList[i].ftExpireHorizon );
                DebugTrace(0,"Adding group %s to expire thrdpool", pGroup->GetName());
                g_pNntpSvc->m_pExpireThrdpool->PostWork( (PVOID)pGroup->GetGroupId() );

                //  advance the iterator. ensure we make one more pass thro the iterators
                pIterator->Next();
                fMoreGroups = TRUE;

            } else if( pIterator ) {
                _ASSERT( pIterator->IsEnd() );
                if( rgIteratorList[i].multiszNewsgroups )  {
                    FREE_HEAP( rgIteratorList[i].multiszNewsgroups ) ;
                    rgIteratorList[i].multiszNewsgroups = NULL;
                }
                XDELETE pIterator;
                rgIteratorList[i].pIterator = NULL;
            }
        }

    } while( fMoreGroups && !pTree->m_bStoppingTree );

#ifdef DEBUG
    for( DWORD i=0; i<NumIterators; i++) {
        _ASSERT( rgIteratorList[i].pIterator == NULL );
        _ASSERT( rgIteratorList[i].multiszNewsgroups == NULL );
    }
#endif

    //
    //  ok, now cool our heels till the expire thrdpool finishes this job !!
    //
    DWORD dwWait = g_pNntpSvc->m_pExpireThrdpool->WaitForJob( INFINITE );
    if( WAIT_OBJECT_0 != dwWait ) {
        ErrorTrace(0,"Wait failed - error is %d", GetLastError() );
    }

    DebugTrace( DWORD(0), "Articles Expired" );
}

//
//  !!! Experimental code if we want to expire based on vroots
//

//
// Detailed Design
//
// FOR each virtual root do
//      FOR each newsgroup in virtual root do
//          Set group expire time by evaluating expire policies
//          (This is similar to check in fAddArticleToPushFeeds)
//          IF group has an expire by time setting
//              Add group to expire thrdpool
//          ENDIF
//      ENDFOR
//  ENDFOR
//

void
CExpire::ExpireArticlesByTime2( CNewsTree* pTree )
{
    TraceFunctEnter( "CExpire::ExpireArticlesByTime2" );

    PNNTP_SERVER_INSTANCE pInst = pTree->GetVirtualServer();
    pInst->Reference();
    BOOL fRet = pInst->TsEnumVirtualRoots( CExpire::ProcessVroot, (LPVOID)pInst );
    pInst->Dereference();
}

static
BOOL
CExpire::ProcessVroot(
                PVOID           pvContext,
                MB*             pMB,
                VIRTUAL_ROOT*   pvr
                )
/*++

Routine Description :

	This function is called by TsEnumVirtualRoots with a given vroot.

Arguments :

	pvContext	-	This is the NNTP virtual server instance
	pmb			-	ptr to metabase object
	pvr			-	current virtual root in the iteration

Return Value :

	TRUE if successfull
	FALSE	otherwise.

--*/
{
    PNNTP_SERVER_INSTANCE pInst = (PNNTP_SERVER_INSTANCE)pvContext;
    CNewsTree* pTree = pInst->GetTree();
    CExpire* pExp = pInst->GetExpireObject();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\feedq.cpp ===
//#ifdef	UNIT_TEST
//#include	<windows.h>
//#include	<limits.h>
//#include	<dbgtrace.h>
//#include	"feedq.h"
//#else
#include	"tigris.hxx"
//#endif

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif


inline	BOOL
ENTRY::operator==( ENTRY&	rhs )	{
/*++

Routine Description :

	Test to see whether two ENTRY's are the same

Arguments :

	The right hand side of the == expression

Return Value :

	TRUE if the two ENTRY's are identical

--*/

	return	memcmp( this, &rhs, sizeof( rhs ) ) == 0 ;

}

inline	BOOL
ENTRY::operator!=( ENTRY&	rhs )	{
/*++

Routine Description

	Test to see whether two ENTRY's are different

Arguments :

	The RHS of the != expression

Return Value :

	TRUE if not equal false otherwise.

--*/

	return	memcmp( this, &rhs, sizeof( rhs ) ) != 0 ;

}


inline
ENTRY::ENTRY(	GROUPID	groupid,	ARTICLEID	artid ) :
/*++

Routine Description :

	Initialize an ENTRY

Arguments :

	groupid and artid to initialize the entry too.

Return Value :

	none.

--*/
	m_groupid( groupid ),
	m_articleid( artid )	{
}

CFeedQ::CFeedQ() :
	m_hFile( INVALID_HANDLE_VALUE ),
	m_fShared( FALSE ),
	m_cDeadBlocks( 0 ),
	m_iRemoveBlock( 0 )	{
/*++

Routine Description :

	Initialize a CFeedQ object - set everything up to an empty state !

Arguments :

	None.

Return Value :

	None.

--*/

	m_header.m_iRemovalPoint = 0 ;
	m_header.m_iAppendPoint = 0 ;

	InitializeCriticalSection(	&m_critAppends ) ;
	InitializeCriticalSection(	&m_critRemoves ) ;

	FillMemory( &m_rgBlock[0][0], sizeof( m_rgBlock ), 0xFF ) ;
}


CFeedQ::~CFeedQ() {
/*++

Routine Description :

	Destroy a CFeedQ object - Close() should be called first if Init() has been called !

Arguments :

	None.

Return Value :

	None.

--*/

	_ASSERT( m_hFile = INVALID_HANDLE_VALUE ) ;

	DeleteCriticalSection( &m_critAppends ) ;
	DeleteCriticalSection( &m_critRemoves ) ;
}


CFeedQ::CQPortion::CQPortion() :
	m_pEntries( 0 ),
	m_iFirstValidEntry( 0xFFFFFFFF ),
	m_iLastValidEntry( 0xFFFFFFFF )	{
}

inline	DWORD
CFeedQ::ComputeBlockFileOffset(	DWORD	iEntry )	{

	DWORD	ibFileOffset = (iEntry) *  sizeof( ENTRY ) ;
	return	ibFileOffset - (ibFileOffset % sizeof( ENTRY )) ;
}

inline	DWORD
CFeedQ::ComputeBlockStart(	DWORD	iEntry )	{

	return	CFeedQ::ComputeBlockFileOffset(	iEntry - (iEntry % MAX_ENTRIES) ) ;
}

inline	DWORD
CFeedQ::ComputeFirstValid(	DWORD	iEntry )	{
	return	(iEntry) - (iEntry) % MAX_ENTRIES ;
}

BOOL
CFeedQ::CQPortion::LoadAbsoluteEntry(	HANDLE	hFile,
							ENTRY*	pEntry,
							DWORD	iFirstValid,
							DWORD	iLastValid ) {
/*++

Routine Description :

	Load a portion of the queue from the file into the specified buffer.
	The desired index starting position into the queue is also passed.

Arguments :

	hFile - File to read from
	pEntry-	Buffer to use to hold data
	iFirstValid -	Index into the Queue as a whole, we want the indexed item
		to end up somewhere in the buffer we read.

Return Value :
	TRUE if successfull.
	FALSE otherwise

--*/

	TraceFunctEnter( "LoadAbsoluteEntry" ) ;

	_ASSERT(	hFile	!= INVALID_HANDLE_VALUE ) ;
	_ASSERT(	pEntry  != 0 ) ;
	_ASSERT(	iLastValid >= iFirstValid ) ;

	DWORD	cbRead = 0 ;

	iFirstValid = ComputeFirstValid( iFirstValid ) ;

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;
	ovl.Offset = ComputeBlockFileOffset(	iFirstValid ) ;

	DebugTrace( (DWORD_PTR)this, "iFirstValid is %x Offset %x", iFirstValid, ovl.Offset ) ;

	if( ReadFile(	hFile,
					pEntry,
					sizeof( BLOCK ),
					&cbRead,
					&ovl ) )	{

		m_pEntries = &(pEntry[0]) ;
		m_iFirstValidEntry = ComputeFirstValid( iFirstValid ) ;
		m_iLastValidEntry = m_iFirstValidEntry + cbRead / sizeof( ENTRY ) ;

		DebugTrace( (DWORD_PTR)this, "m_iFirstValid %x m_iLastValid %x",
			m_iFirstValidEntry, m_iLastValidEntry ) ;

		//
		//	If first block first entry is unused (saved for header.)
		//
		return	TRUE ;
	}

	ErrorTrace( (DWORD_PTR)this, "Read failed - cbRead %x GLE %x", cbRead, GetLastError() ) ;

	return	FALSE ;
}

BOOL
CFeedQ::CQPortion::FlushQPortion(	HANDLE	hFile ) {
/*++

Routine Description :

	Save a portion of the Queue to the specified file.

Arguments :

	hFile	 -	File to save to

REturn Value :

	TRUE if successfull,
	FALSe	otherwise.

--*/

	TraceFunctEnter( "FlushQPortion" ) ;

	_ASSERT( m_pEntries != 0 ) ;
	_ASSERT( m_iLastValidEntry > m_iFirstValidEntry ) ;
	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;
	ovl.Offset = ComputeBlockFileOffset( m_iFirstValidEntry ) ;

	DWORD	cbToWrite = (m_iLastValidEntry - m_iFirstValidEntry) * sizeof( ENTRY ) ;
	DWORD	cbWrite = 0 ;

	if( WriteFile(	hFile,
					m_pEntries,
					cbToWrite,
					&cbWrite,
					&ovl ) )	{

		if( cbWrite != cbToWrite )
			return	FALSE ;
		else
			return	TRUE ;
	}

	ErrorTrace( (DWORD_PTR)this, "WriteFile failed cbWrite %x cbToWrite %x GLE %x",
		cbWrite, cbToWrite, GetLastError() ) ;

	return	FALSE ;
}

BOOL
CFeedQ::CQPortion::FIsValidOffset(	DWORD	i ) {
	return	(i>=m_iFirstValidEntry) && (i < m_iLastValidEntry) ;
}

ENTRY&
CFeedQ::CQPortion::operator[](	DWORD	i ) {

	_ASSERT( i >= m_iFirstValidEntry ) ;
	_ASSERT( i < m_iLastValidEntry ) ;

	return	m_pEntries[ i - m_iFirstValidEntry ] ;
}

void
CFeedQ::CQPortion::Reset(	void	)	{

	m_pEntries = 0 ;
	m_iFirstValidEntry = 0 ;
	m_iLastValidEntry = 0 ;

}

void
CFeedQ::CQPortion::SetEntry(	ENTRY*	pEntry,	DWORD	i )		{

	m_pEntries = pEntry ;
	m_iFirstValidEntry = i ;
	m_iLastValidEntry = i + MAX_ENTRIES ;
}

void
CFeedQ::CQPortion::SetLimits(	DWORD	i )		{

	m_iFirstValidEntry = ComputeFirstValid( i ) ;
	m_iLastValidEntry = m_iFirstValidEntry + MAX_ENTRIES ;
}


void
CFeedQ::CQPortion::Clone(	CFeedQ::CQPortion&	portion	)	{
	m_pEntries = portion.m_pEntries ;
	m_iFirstValidEntry = portion.m_iFirstValidEntry ;
	m_iLastValidEntry = portion.m_iLastValidEntry ;
}

BOOL
CFeedQ::Init(	LPSTR	lpstrFile )		{

	m_fShared = FALSE ;
	m_cDeadBlocks = 0 ;
	m_iRemoveBlock = 0 ;
	m_header.m_iRemovalPoint = 0 ;
	m_header.m_iAppendPoint = 0 ;

	BOOL fRtn = InternalInit( lpstrFile ) ;
	if( fRtn ) {
		return	fRtn ;
	}	else	if( GetLastError() == ERROR_FILE_CORRUPT ) {
		if(	DeleteFile(	lpstrFile ) )	{
			return	InternalInit( lpstrFile ) ;
		}
	}
	return	fRtn ;
}


BOOL
CFeedQ::InternalInit(	LPSTR	lpstrFile ) {
/*++

Routine Description :

	Create a queue based upon the specified file.
	If the file exists we will try to read it in as a queue,
	if it doesn't we will create a queue and use the file to
	save the queue contents when necessary.

Arguments :

	lpstrFile -	Name of the file to hold queue in

Return Value :

	TRUE	if successfull
	FALSE	otherwise

	if we fail and GetLastError() == ERROR_FILE_CORRUPT
	then the file name specified contains a unrecoverable or invalid queue object.

--*/

	BOOL	fRtn = FALSE ;

	lstrcpy( m_szFile, lpstrFile ) ;

	m_hFile = CreateFile( lpstrFile,
							GENERIC_READ | GENERIC_WRITE,
							FILE_SHARE_READ,
							0,	// No security
							OPEN_ALWAYS,
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
							INVALID_HANDLE_VALUE ) ;

	if( m_hFile != INVALID_HANDLE_VALUE ) {

		BY_HANDLE_FILE_INFORMATION	fileInfo ;
		if( !GetFileInformationByHandle( m_hFile, &fileInfo ) )	{
			_VERIFY( CloseHandle( m_hFile ) );
			return	FALSE ;
		}

		if( fileInfo.nFileSizeLow > 0 ) {
			DWORD	cb = 0 ;
			ENTRY	empty( 0xFFFFFFFF, 0xFFFFFFFF ) ;

			m_header.m_iRemovalPoint = 0 ;
			m_header.m_iAppendPoint = 0 ;
			m_iRemoveBlock = 0 ;

			if( m_Remove.LoadAbsoluteEntry(	m_hFile,
										&m_rgBlock[ m_iRemoveBlock ][0],
										m_header.m_iAppendPoint,
										LONG_MAX ) )	{


				while( m_Remove[ m_header.m_iRemovalPoint ] == empty ) {
					m_header.m_iRemovalPoint ++ ;
					if( !m_Remove.FIsValidOffset( m_header.m_iRemovalPoint ) )	{
						if( !m_Remove.LoadAbsoluteEntry(	m_hFile,
													&m_rgBlock[m_iRemoveBlock][0],
													m_header.m_iRemovalPoint,
													LONG_MAX ) )	{
							DWORD dw = GetLastError() ;
							if( dw == ERROR_HANDLE_EOF ) {
								// The Queue is empty !!

								m_header.m_iRemovalPoint = 0 ;
								m_header.m_iAppendPoint = 0 ;
								m_Remove.SetEntry( &m_rgBlock[m_iRemoveBlock][0], 0 ) ;
								m_Append.Clone( m_Remove ) ;
								m_fShared = TRUE ;
								fRtn = TRUE ;
								_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
								_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

								SetFilePointer( m_hFile, 0, 0, FILE_BEGIN ) ;
								SetEndOfFile( m_hFile ) ;
								return	TRUE ;

							}	else	{
								m_cDeadBlocks ++ ;
								_VERIFY( CloseHandle( m_hFile ) );
								m_hFile = INVALID_HANDLE_VALUE ;
								SetLastError( ERROR_FILE_CORRUPT ) ;
								return	FALSE ;
							}

						}	else	{
							m_cDeadBlocks++ ;
						}
					}
				}
			}	else	{
				_VERIFY( CloseHandle( m_hFile ) );
				m_hFile = INVALID_HANDLE_VALUE ;
				SetLastError( ERROR_FILE_CORRUPT ) ;
				return	FALSE ;
			}

			m_header.m_iAppendPoint = m_header.m_iRemovalPoint ;

			m_Append.Clone( m_Remove ) ;
			m_fShared = TRUE ;

			while(	m_Append[ m_header.m_iAppendPoint ] != empty	) {

				m_header.m_iAppendPoint ++ ;
				if( !m_Append.FIsValidOffset(	m_header.m_iAppendPoint ) )	{
					if( !m_Append.LoadAbsoluteEntry(	m_hFile,
												&m_rgBlock[ m_iRemoveBlock ^ 1 ][0],
												m_header.m_iAppendPoint,
												LONG_MAX ) )	{
						m_fShared = FALSE ;


						if( m_Remove.FIsValidOffset( m_header.m_iAppendPoint ) ) {
							m_Append.Clone( m_Remove ) ;
							m_fShared = TRUE ;
							fRtn = TRUE ;
							break ;
						}	else	{
							m_Append.SetEntry( &m_rgBlock[m_iRemoveBlock^1][0], m_header.m_iAppendPoint ) ;
							m_fShared = FALSE ;
							fRtn = TRUE ;
							_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
							_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;
						}
						break ;
					}	else	{
						m_fShared = FALSE ;
					}

				}
			}
			fRtn = CompactQueue() ;

			_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
			_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

		}	else	{
			m_Remove.SetEntry(	&m_rgBlock[m_iRemoveBlock][0], 0 ) ;
			m_Append.Clone( m_Remove ) ;
			m_fShared = TRUE ;
			fRtn = TRUE ;
			_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
			_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

		}
	}
	if( !fRtn )		{
		if( m_hFile != INVALID_HANDLE_VALUE ) {
			_VERIFY( CloseHandle( m_hFile ) );
			m_hFile = INVALID_HANDLE_VALUE ;
		}
		m_Append.Reset() ;
		m_Remove.Reset() ;
	}
	return	fRtn ;
}

BOOL
CFeedQ::FIsEmpty()	{

	BOOL	fRtn = FALSE ;

	EnterCriticalSection( &m_critRemoves ) ;
	EnterCriticalSection( &m_critAppends ) ;

	fRtn = m_header.m_iRemovalPoint == m_header.m_iAppendPoint ;

	LeaveCriticalSection( &m_critAppends ) ;
	LeaveCriticalSection( &m_critRemoves ) ;

	return	fRtn ;

}

BOOL
CFeedQ::Close( BOOL fDeleteFile )	{
/*++

Routine Description :

	This function saves all of the Queue contents and close all of our handles.

Arguments :

	fDeleteFile -   If TRUE, delete the fdq file

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	EnterCriticalSection( &m_critRemoves ) ;
	EnterCriticalSection( &m_critAppends ) ;

	_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
	_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

	BOOL	fRtn = TRUE ;


	if( !m_Append.FlushQPortion( m_hFile ) )	{
		fRtn = FALSE ;
	}	else	if(	m_fShared || m_Remove.FlushQPortion( m_hFile ) ) {

		fRtn &=	CompactQueue() ;

	}	else	{

		fRtn = FALSE ;

	}

	_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
	_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;


	if( m_hFile != INVALID_HANDLE_VALUE ) {
		fRtn &= CloseHandle( m_hFile ) ;
		m_hFile = INVALID_HANDLE_VALUE ;
		if( fDeleteFile ) {
            fRtn &= DeleteFile( m_szFile );
		}
	}

	LeaveCriticalSection( &m_critAppends ) ;
	LeaveCriticalSection( &m_critRemoves ) ;

	return	fRtn ;
}





BOOL
CFeedQ::Append(	GROUPID	groupid,
				ARTICLEID	artid )	{
/*++

Routine Description :

	This function will append a groupid,article id pair to the queue.

Arguments :

	groupid and artid - the pair to be appended

Return Value :

	TRUE if successfull -
	FALSE - A fatal error occurred manipulating the queue.


--*/

	ENTRY	entry ;
	entry.m_groupid = groupid ;
	entry.m_articleid = artid ;
	BOOL	fRtn = TRUE ;

#ifndef	UNIT_TEST
	_ASSERT( groupid != INVALID_ARTICLEID ) ;
	_ASSERT( artid != INVALID_ARTICLEID ) ;
#endif

	EnterCriticalSection( &m_critAppends ) ;

	if(	m_Append.FIsValidOffset( m_header.m_iAppendPoint ) )	{
		m_Append[ m_header.m_iAppendPoint ] = entry ;
		m_header.m_iAppendPoint ++ ;
	}	else	{

		if( !m_Append.FlushQPortion( m_hFile ) )	{
			fRtn = FALSE ;
		}	else	{
			ENTRY*	pEntries = & m_rgBlock[ m_iRemoveBlock ^ 1 ][0] ;
			FillMemory( pEntries, sizeof( m_rgBlock[0] ), 0xFF ) ;
			m_Append.SetEntry( pEntries, m_header.m_iAppendPoint ) ;
			m_Append[ m_header.m_iAppendPoint ] = entry ;
			m_header.m_iAppendPoint ++ ;
			m_fShared = FALSE ;

			_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
			_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

		}
	}
	LeaveCriticalSection( &m_critAppends ) ;
	return	fRtn ;
}


BOOL
CFeedQ::Remove(	GROUPID&	groupid,
				ARTICLEID&	artid )	{
/*++

Routine Description :

	Remove a groupid artid pair from the queue.  If the queue is empty return
	-1 for groupid and artid and return TRUE.


Arguments :

	groupid, artid - references which will hold the returned values

Return Value :

	TRUE if the queue is OK FALSE if a fatal file error occurred manipulating the queue.

--*/

	TraceFunctEnter( "CFeedQ::Remove" ) ;

	BOOL	fRtn = TRUE ;

	groupid = 0xFFFFFFFF ;
	artid = 0xFFFFFFFF ;

	EnterCriticalSection( &m_critRemoves ) ;

	DebugTrace( (DWORD_PTR)this, "m_iRemovalPoint %x m_iAppendPoint %x",
		m_header.m_iRemovalPoint, m_header.m_iAppendPoint ) ;

	if( m_header.m_iRemovalPoint < m_header.m_iAppendPoint )	{

		if( !m_Remove.FIsValidOffset( m_header.m_iRemovalPoint ) )	{

			m_cDeadBlocks ++ ;

			DebugTrace( (DWORD_PTR)this, "m_cDeadBlocks is now %d", m_cDeadBlocks ) ;

			EnterCriticalSection( &m_critAppends ) ;

			if( m_Append.FIsValidOffset( m_header.m_iRemovalPoint ) ) {

				DebugTrace( (DWORD_PTR)this, "m_iRemoveBlock %x m_fShared was %x", m_iRemoveBlock,
					m_fShared ) ;

				m_iRemoveBlock ^= 1 ;
				m_Remove.Clone( m_Append ) ;
				m_fShared = TRUE ;

			}	else	{
				fRtn = m_Remove.LoadAbsoluteEntry( m_hFile,
											&m_rgBlock[ m_iRemoveBlock ][0],
											m_header.m_iRemovalPoint,
											LONG_MAX ) ;
			}

			if( m_cDeadBlocks > MAX_DEAD_BLOCKS )	{

				CompactQueue() ;

			}

			_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
			_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

			LeaveCriticalSection( &m_critAppends ) ;
		}


		if( m_Remove.FIsValidOffset( m_header.m_iRemovalPoint ) ) {

			DebugTrace( (DWORD_PTR)this, "m_iRemovalPoint now %x", m_header.m_iRemovalPoint ) ;

			ENTRY	entry = m_Remove[ m_header.m_iRemovalPoint ] ;
			groupid = entry.m_groupid ;
			artid =	  entry.m_articleid ;

			_ASSERT( groupid != 0xFFFFFFFF ) ;
			_ASSERT( artid != 0xFFFFFFFF ) ;

			entry.m_groupid = 0xFFFFFFFF ;
			entry.m_articleid = 0XFFFFFFFF ;
			m_Remove[m_header.m_iRemovalPoint] = entry ;
			m_header.m_iRemovalPoint ++ ;
		}

	}
	LeaveCriticalSection( &m_critRemoves ) ;
	return	fRtn ;
}

BOOL
CFeedQ::StartFlush( )	{

	EnterCriticalSection( &m_critRemoves ) ;
	EnterCriticalSection( &m_critAppends ) ;

	return	CompactQueue() ;

}
void
CFeedQ::CompleteFlush()	{

	LeaveCriticalSection( &m_critAppends ) ;
	LeaveCriticalSection( &m_critRemoves ) ;

}


BOOL
CFeedQ::CompactQueue()	{
/*++

Routine Description :

	Remove unused space in the Queue's disk representation.

Arguments :

	None.

Return Value :

	TRUE if successfull
	FALSE if failed - if FALSE the queue is no longer usable.


--*/

	TraceFunctEnter( "CFeedQ::CompactQueue" ) ;

	DWORD	cbRead = 0,	cbWrite = 0 ;
	char	szTempFile[ MAX_PATH ] ;
	BOOL	fSuccess = FALSE ;

	lstrcpy( szTempFile, m_szFile ) ;

	char*	pchEnd = szTempFile + lstrlen( szTempFile ) ;
	while( *pchEnd != '.' && *pchEnd != '\\' && pchEnd > szTempFile ) {
		pchEnd -- ;
	}

	if( *pchEnd == '.' ) {
		lstrcpy( pchEnd +1, "bup" ) ;
	}	else	{
		lstrcat( szTempFile, ".bup" ) ;
	}

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;

	DebugTrace( (DWORD_PTR)this, " szTempFile =%s= m_szFile =%s=", szTempFile, m_szFile ) ;

	if( CopyFile( m_szFile, szTempFile, FALSE ) )	{

		DebugTrace( (DWORD_PTR)this, "m_iRemovalPoint %x m_iAppendPoint %x m_cDeadBlocks %x",
			m_header.m_iRemovalPoint, m_header.m_iAppendPoint, m_cDeadBlocks ) ;

		if( m_header.m_iRemovalPoint == m_header.m_iAppendPoint ) {

			fSuccess = TRUE ;
			fSuccess &= (0==SetFilePointer( m_hFile, 0, 0, FILE_BEGIN )) ;
			fSuccess &= SetEndOfFile( m_hFile ) ;

			DebugTrace( (DWORD_PTR)this, "fSuccess %x", fSuccess ) ;

			if( fSuccess && m_header.m_iRemovalPoint != 0 ) {
				m_header.m_iRemovalPoint = 0 ;
				m_header.m_iAppendPoint = 0 ;
				m_cDeadBlocks = 0 ;
				FillMemory( &m_rgBlock[0][0], sizeof( m_rgBlock ), 0xFF ) ;
				ovl.Offset = 0 ;
				fSuccess = WriteFile( m_hFile, &m_rgBlock[0][0], sizeof( m_rgBlock[0] ), &cbWrite, &ovl ) ;

				m_iRemoveBlock = 0 ;
				m_Append.SetEntry( &m_rgBlock[m_iRemoveBlock][0], 0 ) ;
				m_Remove.Clone( m_Append ) ;
				m_fShared = TRUE ;
			}

		}	else	{

			//
			//	Now we need to copy blocks arround.
			//

			if( m_cDeadBlocks == 0 )	{

				fSuccess = TRUE ;

			}	else	{

				ENTRY	*pEntries = &m_rgBlock[ m_iRemoveBlock ][0] ;

				HANDLE	hTempFile = CreateFile( szTempFile,
										GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ,
										0,	// No security
										OPEN_ALWAYS,
										FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
										m_hFile ) ;

				DebugTrace( (DWORD_PTR)this, " hTempFile %x ", hTempFile ) ;

				if( hTempFile != INVALID_HANDLE_VALUE )	{

					DWORD	ibFirst = ComputeBlockStart( m_header.m_iRemovalPoint ) ;
					DWORD	ibLast = ComputeBlockStart( m_header.m_iAppendPoint ) ;
					DWORD	ibStart = ibFirst ;

					_ASSERT( ibLast >= ibFirst ) ;

					if( SetFilePointer( m_hFile, 0, 0, FILE_BEGIN ) == 0 )	{

						do	{

							ZeroMemory( &ovl, sizeof( ovl ) ) ;
							if( ibStart != ibFirst )	{
								ovl.Offset = ibFirst ;
								fSuccess = ReadFile(	hTempFile,
											pEntries,
											sizeof( m_rgBlock[0] ),
											&cbRead,
											&ovl ) ;
							}	else	{
								//
								//	m_head already contains the starting block properly
								//	filled with 0xFFFFFFFF for consumed entries
								//
								cbRead = sizeof( m_rgBlock[0] ) ;
								fSuccess = TRUE ;
							}
							if( fSuccess ) {
								ZeroMemory( &ovl, sizeof( ovl ) ) ;
								fSuccess = WriteFile(	m_hFile,
														pEntries,
														cbRead,
														&cbWrite,
														0 ) ;
								ibFirst += sizeof( m_rgBlock[0] ) ;
							}

							DebugTrace( (DWORD_PTR)this, "fSuccess %x ibFirst %x ibLast %x",
								fSuccess, ibFirst, ibLast  ) ;

						}	while(	fSuccess && ibFirst < ibLast ) ;
						if( fSuccess && !m_fShared ) {

							fSuccess = WriteFile( m_hFile,
													&m_rgBlock[ m_iRemoveBlock ^ 1 ],
													sizeof( m_rgBlock[0] ),
													&cbWrite,
													0 ) ;
						}


						//
						//	Truncate the file !!
						//
						if( fSuccess )
							fSuccess &= SetEndOfFile( m_hFile ) ;

					}

					DebugTrace( (DWORD_PTR)this, "fSuccess %x", fSuccess ) ;

					if( fSuccess )	{
						m_fShared = FALSE ;
						m_header.m_iRemovalPoint -= m_cDeadBlocks * MAX_ENTRIES ;
						m_header.m_iAppendPoint -= m_cDeadBlocks * MAX_ENTRIES ;
						m_cDeadBlocks = 0 ;

						m_Append.SetLimits( m_header.m_iAppendPoint ) ;

						DebugTrace( (DWORD_PTR)this, "m_iRemovalPoint %x m_iAppendPoint %x m_cDeadBlocks %x",
							m_header.m_iRemovalPoint, m_header.m_iAppendPoint, m_cDeadBlocks ) ;

						if( m_Append.FIsValidOffset( m_header.m_iRemovalPoint ) ) {

							DebugTrace( (DWORD_PTR)this, "Cloning Append queue" ) ;

							m_Remove.Clone( m_Append ) ;
							m_fShared = TRUE ;
							if( m_Remove.m_pEntries == &m_rgBlock[0][0] )
								m_iRemoveBlock = 0 ;
							else
								m_iRemoveBlock = 1 ;
							fSuccess = TRUE ;

							_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
							_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

						}	else	{

							if( m_Append.m_pEntries == &m_rgBlock[m_iRemoveBlock][0] ) {
								m_iRemoveBlock ^= 1 ;
							}

							fSuccess = m_Remove.LoadAbsoluteEntry( m_hFile,
														&m_rgBlock[m_iRemoveBlock][0],
														m_header.m_iRemovalPoint,
														LONG_MAX ) ;

							_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
							_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

						}
					}

					_VERIFY( CloseHandle( hTempFile ) );
				}
			}
		}

		if( fSuccess ) {

		}

		// we do not need the temp file anymore - delete it !
		_VERIFY( DeleteFile( szTempFile ) );
	}

	DebugTrace( (DWORD_PTR)this, " fSuccess %x ", fSuccess ) ;

	return	fSuccess ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\feedmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    feedmgr.h

Abstract:

    This module contains definitions for the Feed Manager.

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

    Kangrong Yan ( KangYan )    28-Feb-1998
        Added prototypes for Feed Config functions.

--*/

#ifndef _FEEDMGR_
#define _FEEDMGR_

#include "infeed.h"

//
// Block states
//

typedef enum _FEED_BLOCK_STATE {

    FeedBlockStateActive,
    FeedBlockStateClosed,
	FeedBlockStateModified

} FEED_BLOCK_STATE;

//
// defines
//

#define FEED_BLOCK_SIGN         0xacbaedfe
#define MIN_FEED_INTERVAL       1   // in minutes
#define DEF_FEED_INTERVAL       5
#define MAX_DOMAIN_NAME         256

//
// client authent class for logging on feeds
//

class	CAuthenticator	{
public : 
	virtual	BOOL	StartAuthentication( BYTE*	lpb,	unsigned	cb,	unsigned	&cbOut ) = 0 ;
	virtual	BOOL	NextAuthentication(	LPSTR	lpResponse,	BYTE*	lpb,	unsigned	cb,	unsigned&	cbOut,	BOOL&	fComplete,	BOOL&	fSuccessfullLogon ) = 0 ;
	virtual	~CAuthenticator() {}
}	;

class	CClearTextAuthenticator : public	CAuthenticator	{
private : 
	LPSTR	m_lpstrAccount ;
	LPSTR	m_lpstrPassword ;
	BOOL	m_fAccountSent ;
	BOOL	m_fPasswordSent ;
public : 
	CClearTextAuthenticator(	LPSTR	lpstrAccount,	LPSTR	lpstrPassword ) ;
	~CClearTextAuthenticator() {}

	virtual	BOOL	StartAuthentication( BYTE*	lpb,	unsigned	cb,	unsigned	&cbOut ) ;
	virtual	BOOL	NextAuthentication(	LPSTR	lpResponse,	BYTE*	lpb,	unsigned	cb,	unsigned&	cbOut,	BOOL&	fComplete,	BOOL&	fSuccessfullLogon ) ;
} ;




//
// Max length of the feed key name
//

#define FEED_KEY_LENGTH         15

//
//
// Basic feed block
//

typedef struct _FEED_BLOCK {

    //
    // Signature of this block
    //

    DWORD Signature;

	/////////////////////////////////////////////////////////////////////
	// FeedManager Thread ONLY members - only the feed scheduler thread should
	//	touch these fields 

    //
    // Number of feeds done so far - this is set to 0 initially and is 
	// used to make sure the server starts the feed ASAP upon boot-up
    //
    DWORD NumberOfFeeds;

	//
	//	Number of failed connection attempts for Push feeds
	//
	DWORD	cFailedAttempts ;

    //
    // The last newsgroup spec Pulled;
    //
    DWORD LastNewsgroupPulled;

    //
    // Resolved IP address
    //
    DWORD IPAddress;

	////////////////////////////////////
	//
	// Fields usefull for any thread !

    //
    // Used to link feedblocks together
    //
    LIST_ENTRY ListEntry;

	//
	//	Used to determine whether a feed is in progress - 
	//	if no feed is in progress then the fields can safely be changed !
	//
	LONG	FeedsInProgress ;

    //
    // Count of references to this block
    //
    DWORD ReferenceCount;

    //
    // Current State of this block
    //
    FEED_BLOCK_STATE State;

	//
	//	Should we delete this block when the references reach 0 ?
	//
	BOOL		MarkedForDelete ;

	//
	//	Pointer to a FEED_BLOCK that we are replacing and we are waiting
	//	for death of !
	//
	struct	_FEED_BLOCK*		ReplacedBy ;	
	struct	_FEED_BLOCK*		Replaces ;

	////////////////////////////////////////////
	//	
	//	Fields constant accross lifetime of object !
	//

    //
    // Type of this feed (push/pull/passive)
    //
    FEED_TYPE FeedType;

    //
    // Name of reg key this feed info is stored under
    //
    CHAR KeyName[FEED_KEY_LENGTH+1];

	//
	//	The Queue used to record outgoing articles for this ACTIVE outgoing feed
	//
	class	CFeedQ*	pFeedQueue ;

    //
    // Unique id for this feed block
    //
    DWORD FeedId;


	////////////////////////////////////////////
	//
	//	The following are referenced by the feed scheduler thread
	//	as well as admin RPC threads !
	//

    //
    // Should we autocreate directories?
    //
    BOOL AutoCreate;

    //
    // Minutes between feeds
    //
    DWORD FeedIntervalMinutes;

    //
    // When to pull
    //
    FILETIME PullRequestTime;

    //
    // Times used for scheduling:
    //
    // If StartTime is 0, then use increment time
    // If StartTime is not 0 and inc is 0, then schedule once
    //      if inc is not 0, set during 1st run, then increment on
    //          subsequent runs
    //
    ULARGE_INTEGER StartTime;
    ULARGE_INTEGER NextActiveTime;

    //
    // Name of the feed server
    //
    LPSTR ServerName;

    //
    // Newsgroups to pull
    //
    LPSTR *Newsgroups;

    //
    // Distributions
    //
    LPSTR *Distribution;

	//
	//	For push and pull feeds - a flag indicating whether the 
	//	feed is currently 'enabled' - TRUE means we should initiate
	//	sessions, FALSE means dont start sessions.
	//
	//	For accepts feeds, FALSE means we treat incoming connections as
	//	regular client connections instead of a "feed". This effectively
	//	disables the passive feed.
	//
	BOOL	fEnabled ;

	//
	//	The name to be used in Path processing 
	//
	LPSTR*	UucpName ;


	//
	//	The directory where we are to store our temp files !
	//
	LPSTR	FeedTempDirectory ;

	//
	//	Maximum number of consecutive failed connect attempts before 
	//	we disable the feed.
	//	
	DWORD	MaxConnectAttempts ;

	//
	//	Number of sessions to create for outbound feeds
	//
	DWORD	ConcurrentSessions ;

	//
	//	Type of security to have
	//
	DWORD	SessionSecurityType ;

	//
	//	Authentication security
	//
	DWORD	AuthenticationSecurity ;

	//
	//	User Account/Password for clear text logons !
	//
	LPSTR	NntpAccount ;
	LPSTR	NntpPassword ;

	//
	//  Allow control messages on this feed ?
	//
	BOOL	fAllowControlMessages;

	//
	//	port to use for outgoing feeds
	//
	DWORD	OutgoingPort;

	//
	//	associated feed pair id
	//
	DWORD	FeedPairId;

	//
	//  counters used for periodic feed information
	//
	LONG	cSuccessfulArticles;
	LONG	cTryAgainLaterArticles;
	LONG	cSoftErrorArticles;
	LONG	cHardErrorArticles;
} FEED_BLOCK, *PFEED_BLOCK;


class	CFeedList	{
//
//	This class is used to keep lists of FEED_BLOCK's.
//	
//	This class will manage all syncrhronization of updates to FEED_BLOCKs.
//	We use a shared/Exclusive lock to protect the list.
//
public : 

	//
	//	Shared Exclusive Lock for the list.
	//
	RESOURCE_LOCK		m_ListLock ;

	//
	//	NT DOubly linked list structure.  Use NT macros 
	//
	LIST_ENTRY			m_ListHead ;


	//
	//	Constructor just creates empty object - call Init to 
	//	initialize resource's etc...
	//
	CFeedList() ;

	//
	//	Initialize RESOURCE_LOCK's
	//
	BOOL			Init() ;

	//
	//	Release RESOURCE_LOCK's.  Somebody should 
	//	walk the list before calling Term() and delete all the elements.
	//
	BOOL			Term() ;

	//
	//	For debug assert's - check that a FEED_BLOCK is in this list.
	//
	BOOL			FIsInList(	PFEED_BLOCK	block ) ;

	//
	//	The following functions just directly access 
	//	the resource_lock 
	//
	void			ShareLock() ;
	void			ShareUnlock() ;
	void			ExclusiveLock() ;
	void			ExclusiveUnlock() ;
	

	//
	//	This Enumerate interface will step through the list 
	//	keeping the lock held in shared mode until we have completely
	//	gone through the list.  While doing this enumeration,
	//	none of the Feed objects can be removed,deleted or changed
	//

	//
	//	Get the first FEED_BLOCK
	//
	PFEED_BLOCK		StartEnumerate() ;
	
	//
	//	Get The next FEED_BLOCK
	//
	PFEED_BLOCK		NextEnumerate(	PFEED_BLOCK	feedBlock ) ;

	//
	//	If caller wishes to finish enumerating without going through 
	//	the whole list call this function with the last FEED_BLOCK
	//	the caller got so that the locks can be properly released
	//
	void			FinishEnumerate(	PFEED_BLOCK	feedBlock ) ;
	
	//
	//	Used by the enum api's - Internal use only
	//
	PFEED_BLOCK		InternalNext( PFEED_BLOCK ) ;

	//
	//	Next grabs the list exclusively, bumps the FEED_BLOCK's
	//	reference count and then release the lock.
	//	This allows the caller to enumerate the FEED_BLOCKs certain
	//	that they won't be deleted while he is enumerating, but without
	//	having to have the lock held for the duration of the enumeration.
	//	This is necessary in the FeedManager thread to prevent dead locks with ATQ.
	//
	PFEED_BLOCK		Next( PNNTP_SERVER_INSTANCE pInstance, PFEED_BLOCK ) ;
	PFEED_BLOCK		Search(	DWORD	FeedId ) ;
	void			FinishWith( PNNTP_SERVER_INSTANCE pInstance, PFEED_BLOCK ) ;

	//
	//	Remove a FEED_BLOCK from the list
	//	Will grab the list exclusively
	//
	PFEED_BLOCK		Remove( PFEED_BLOCK	feed, BOOL	fMarkDead = FALSE ) ;

	//
	//	Insert a new FEED_BLOCK into the list
	//	will grab the list exclusively
	//
	PFEED_BLOCK		Insert( PFEED_BLOCK ) ;

	//
	//	This call will cause one feed block to be replaced with another.
	//	The replacement doesn't occur untill the feed being replaced 
	//	is not in progress (no active sessions using it.)
	//	If the Feed Blocks are enumerated while a feed is in progress
	//	and the feed has been 'updated' the enumeration will return 
	//	the Update FEED_BLOCK - the Original is effectively invisible.
	//
	void			ApplyUpdate( PFEED_BLOCK	Original,	PFEED_BLOCK	Update ) ;

	//
	//	Mark the FEED_BLOCK as in progress - so that ApplyUpdate calls
	//	pput the Update Block in the list and Original is not replaced
	//	until it is no longer in progress.
	//
	long			MarkInProgress( PFEED_BLOCK	block ) ;

	//
	//	Mark the feed as not in progress.
	//
	long			UnmarkInProgress( PNNTP_SERVER_INSTANCE pInstance, PFEED_BLOCK	block ) ;

	//
	//	Mark the feed as deleted - it should be destroyed when any 
	//	feeds that are in progress complete.
	//
	void			MarkForDelete(	PFEED_BLOCK	block ) ;

} ;
	

//
//
// Macros
//

//
// This computes the required size of the feed block
//

#if 0 
#define FEEDBLOCK_SIZE( _fb )                       \
            (sizeof(NNTP_FEED_INFO) +               \
            (lstrlen(feedBlock->ServerName) + 1 +    \
            MultiListSize(feedBlock->Newsgroups) +  \
            MultiListSize(feedBlock->Distribution)) * sizeof(WCHAR))	\
			(lstrlen(FeedTempDirectory) + 1)
#else

DWORD
MultiListSize(
    LPSTR *List
    ) ;

inline	DWORD
FEEDBLOCK_SIZE( PFEED_BLOCK	feedBlock ) {

	DWORD	cb = 
		sizeof( NNTP_FEED_INFO ) ;

	DWORD	cbUnicode = (lstrlen( feedBlock->ServerName ) + 1)  ;
	cbUnicode += MultiListSize(feedBlock->Newsgroups) ;
	cbUnicode += MultiListSize(feedBlock->Distribution) ;
	if( feedBlock->NntpAccount != 0 ) {
		cbUnicode += lstrlen( feedBlock->NntpAccount ) + 1 ;
	}
	if( feedBlock->NntpPassword != 0 ) {
		cbUnicode += lstrlen( feedBlock->NntpPassword ) + 1 ;
	}
	if( feedBlock->FeedTempDirectory != 0 )	{
		cbUnicode += lstrlen( feedBlock->FeedTempDirectory ) + 1 ;
	}
	if( feedBlock->UucpName != 0 ) {
#if 0 
		cbUnicode += lstrlen( feedBlock->UucpName ) + 1 ;
#endif
		cbUnicode += MultiListSize( feedBlock->UucpName ) ;
	}

	cb += cbUnicode * sizeof( WCHAR ) ;
	return	cb ;
}
#endif




//
// Macro to check whether given IP is a master
//

#define IsNntpMaster( _ip )         IsIPInList(NntpMasterIPList,(_ip))

//
// Macro to check whether given IP is a Peer
//

#define IsNntpPeer( _ip )           IsIPInList(NntpPeerIPList,(_ip))

//
//	Utility function - save feed information to registry !
//

BOOL
UpdateFeedMetabaseValues(
			IN PNNTP_SERVER_INSTANCE pInstance,
            IN PFEED_BLOCK FeedBlock,
            IN DWORD Mask
            );




//
// It creates a feed of the correct type based on a socket.
//

CInFeed * pfeedCreateInFeed(
		PNNTP_SERVER_INSTANCE pInstance,
		PSOCKADDR_IN sockaddr,
		BOOL        fRemoteEqualsLocal,
		CInFeed * & pInFeedFromClient,
		CInFeed * & pInFeedFromMaster,
		CInFeed * & pInFeedFromSlave,
		CInFeed * & pInFeedFromPeer
		);

//
// Prototypes for Feed config functions that replace RPCs
//
DWORD SetFeedInformationToFeedBlock( IN NNTP_HANDLE, IN DWORD, IN LPI_FEED_INFO, OUT PDWORD );
DWORD DeleteFeedFromFeedBlock( IN NNTP_HANDLE, IN DWORD, IN DWORD );
DWORD AddFeedToFeedBlock( IN NNTP_HANDLE, IN DWORD, IN LPI_FEED_INFO, IN LPSTR, OUT PDWORD, OUT LPDWORD );

//
// Utility function, increment the feed counters in a feed block based 
// on an NRC
//
void IncrementFeedCounter(struct _FEED_BLOCK *pFeedBlock, DWORD nrc);

#endif // _FEEDMGR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\feedmgr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    feedmgr.cpp

Abstract:

    This module contains code for the feed manager

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

    Kangrong Yan ( KangYan ) 24-Feb-1998:

        Feed config rpc goes away.  So the feed config in metabase could be bad.
        Service boot needs to check not to load bad feeds.  Also, make the orginal
        RPCs for feed config internal functions.

--*/

#include <buffer.hxx>
#include "tigris.hxx"
#include "feedmgr.h"

//
// forward prototypes
//

VOID
InsertFeedBlockIntoQueue(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    );

VOID
ComputeNextActiveTime(
		IN PNNTP_SERVER_INSTANCE pInstance,
		IN PFEED_BLOCK FeedBlock,
		IN FILETIME*	NextPullTime,
        IN BOOL SetNextPullTime
        );

VOID
ReferenceFeedBlock(
    PFEED_BLOCK FeedBlock
    );

BOOL
ProcessInstanceFeed(
				PNNTP_SERVER_INSTANCE	pInstance
				);

DWORD
WINAPI
FeedScheduler(
        LPVOID Context
        );

BOOL
InitializeFeedsFromMetabase(
    PNNTP_SERVER_INSTANCE pInstance,
	BOOL& fFatal
    );

BOOL
IsFeedTime(	
	PNNTP_SERVER_INSTANCE pInstance,
	PFEED_BLOCK	feedBlock,	
	ULARGE_INTEGER	liCurrentTime
	) ;

VOID
SetNextPullFeedTime(
	PNNTP_SERVER_INSTANCE pInstance,
	FILETIME*	pNextTime,
    PFEED_BLOCK FeedBlock
    );

BOOL
InitiateOutgoingFeed(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PFEED_BLOCK FeedBlock
    );

BOOL
ResumePeerFeed(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PFEED_BLOCK FeedBlock
    );

BOOL
BuildFeedQFileName(	
			char*	szFileOut,	
			DWORD	cbFileOut,	
			char*   szFileIn,
			char*	szPathIn
			);

void
BumpOutfeedCountersUp( PNNTP_SERVER_INSTANCE pInstance );

void
BumpOutfeedCountersDown( PNNTP_SERVER_INSTANCE pInstance );

void
LogFeedAdminEvent(
            DWORD       event,
            PFEED_BLOCK feedBlock,
            DWORD       dwInstanceId
            )   ;

CClearTextAuthenticator::CClearTextAuthenticator(	LPSTR	lpstrAccount,	LPSTR	lpstrPassword ) :
	m_lpstrAccount( lpstrAccount ),
	m_lpstrPassword( lpstrPassword ),
	m_fAccountSent( FALSE ),
	m_fPasswordSent( FALSE )	 {
/*++

Routine Description :

	Initialize a CClearTextAuthentication object -
	we will handle clear text authentication negogtiations.

Arguments :

	lpstrAccount - clear text account to issue in authinfo user command
	lpstrPassword - password to send in authinfo pass command

Return Value :

	None.

--*/
}

BOOL
CClearTextAuthenticator::StartAuthentication(	BYTE*		lpb,	
												unsigned	cb,	
												unsigned&	cbOut )	{	
/*++

Routine Description :

	Send the initial logon request for a clear text account/password logon !

Arguements :

	lpb -	Buffer in which to place send request
	cb	-	Number of bytes of space in buffer
	cbOut - Return the number of bytes used in the buffer
	fComplete - Is the logon Complete
	fComplete - Return whether the logon was successfull !

Return	Value :
	TRUE	if Successfull - FALSE otherwise !

--*/

	const	char	szCommand[] = "authinfo user " ;

	_ASSERT( !m_fAccountSent ) ;
	_ASSERT( !m_fPasswordSent ) ;

	int	cbAccount = lstrlen( m_lpstrAccount ) ;
	cbOut = 0 ;

	if( cb < sizeof( szCommand ) + cbAccount + 2 ) {
		return	FALSE ;
	}	else	{
		
		CopyMemory( lpb, szCommand, sizeof( szCommand ) - 1 ) ;
		cbOut =	sizeof( szCommand ) - 1 ;
		CopyMemory( lpb + cbOut, m_lpstrAccount, cbAccount ) ;
		cbOut += cbAccount ;
		lpb[cbOut++] = '\r' ;
		lpb[cbOut++] = '\n' ;

		m_fAccountSent = TRUE ;

		return	TRUE ;
	}
}

BOOL
CClearTextAuthenticator::NextAuthentication(	LPSTR		multisz,
												BYTE*		lpb,
												unsigned	cb,
												unsigned&	cbOut,
												BOOL&		fComplete,
												BOOL&		fLoggedOn ) {
/*++

Routine Description :

	Process the response of a authinfo user command and send the
	response.

Arguemnts :

	multisz -	The response from the remote server
	lpb -		Output Buffer
	cb	-		Size of output buffer
	cbOut -		OUT parm for number of bytes placed in output buffer
	fComplete -	OUT parm indicating whether the logon has completed
	fLoggedOn - OUT parm indicating whether we were successfully logged on

Return Value :
	TRUE if successfull - FALSE otherwise !

--*/


	const	char	szPassword[] = "authinfo pass " ;
	NRC	code ;

	fComplete = FALSE ;

	if( !m_fPasswordSent ) {

		if( !ResultCode( multisz, code ) ) {
			SetLastError( ERROR_BAD_ARGUMENTS ) ;
			return	FALSE ;
		}	else	{
			
			if( code == nrcPassRequired ) {
				int	cbPassword = lstrlen( m_lpstrPassword ) ;
				if( cb < sizeof( szPassword ) + cbPassword + 2 ) {
					SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
					return	FALSE ;
				}	else	{
					
					CopyMemory( lpb, szPassword, sizeof( szPassword ) - 1 ) ;
					cbOut =	sizeof( szPassword ) - 1 ;
					CopyMemory( lpb + cbOut, m_lpstrPassword, cbPassword ) ;
					cbOut += cbPassword  ;
					lpb[cbOut++] = '\r' ;
					lpb[cbOut++] = '\n' ;
					m_fPasswordSent = TRUE ;
				}
			}	else	{
				SetLastError( ERROR_BAD_ARGUMENTS ) ;
				return	FALSE ;
			}
		}
	}	else	{
		if( !ResultCode( multisz, code ) ) {
			SetLastError( ERROR_BAD_ARGUMENTS ) ;
			return	FALSE ;
		}	else	{		
			if( code == nrcLoggedOn ) {
				fLoggedOn = TRUE ;
			}	else	{
				fLoggedOn = FALSE ;
			}
			fComplete = TRUE ;
		}
	}
	return	TRUE ;
}





CFeedList::CFeedList() {
/*++

Routine Description :

	Set everything to a blank state.

Arguments :

	None.

Return Value :

	None

--*/
	ZeroMemory( &m_ListHead, sizeof( m_ListHead ) ) ;
	ZeroMemory( &m_ListLock, sizeof( m_ListLock ) ) ;
}

BOOL
CFeedList::Init()	{
/*++

Routine Description :

	Put the CFeedList into a usable state.

Arguments :

	None.

Return Value :

	None

--*/
	
	InitializeListHead( &m_ListHead ) ;

	return InitializeResource( &m_ListLock ) ;
}

BOOL
CFeedList::FIsInList(	PFEED_BLOCK	feedBlock ) {
/*++

Routine Description :

	Check whether a feedBlock already exists in the list.
	 ASSUME LOCKS ARE HELD !!

Arguments :

	feedBlock - check for this guy in the list

Return Value :

	TRUE if in list
	FALSE otherwise

--*/

	BOOL	fRtn = FALSE ;
//	AcquireResourceShared( &m_ListLock, TRUE ) ;

	PLIST_ENTRY	listEntry =	m_ListHead.Flink ;
	while( listEntry != &m_ListHead ) {

		PFEED_BLOCK	feedBlockList = CONTAINING_RECORD(	listEntry,
														FEED_BLOCK,
														ListEntry ) ;
		if( feedBlockList == feedBlock ) {
			fRtn = TRUE ;
			break ;
		}
		listEntry = listEntry->Flink ;
	}

//	ReleaseResource( &m_ListLock ) ;
	return	fRtn ;
}

void
CFeedList::ShareLock()	{
/*++

Routine Description :

	Grab the lock in shared mode
	Use this when we want to do several enumerations and
	ensure nothing is added/removed in btwn

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::ShareLock" ) ;

	AcquireResourceShared( &m_ListLock, TRUE ) ;

}

void
CFeedList::ShareUnlock()	{
/*++

Routine Description :

	Release the lock from shared mode
	Use this when we want to do several enumerations and
	ensure nothing is added/removed in btwn

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::ShareUnlock" ) ;
	
	ReleaseResource( &m_ListLock ) ;

}

void
CFeedList::ExclusiveLock()	{
/*++

Routine Description :

	Grab the lock in exclusive mode
	Use this when we want to do several enumerations and
	ensure nothing is added/removed in btwn

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::ExclusiveLock" ) ;

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

}

void
CFeedList::ExclusiveUnlock()	{
/*++

Routine Description :

	Release the lock in exclusive mode
	Use this when we want to do several enumerations and
	ensure nothing is added/removed in btwn

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::ExclusiveUnlock" ) ;
	
	ReleaseResource( &m_ListLock ) ;

}

PFEED_BLOCK
CFeedList::StartEnumerate(	)	{
/*++

Routine Description :

	Grab the lock in shared mode, and keep it
	untill we're finished enumerating.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::StateEnumerate" ) ;

	AcquireResourceShared( &m_ListLock, TRUE ) ;

	PFEED_BLOCK	feedOut = 0 ;	
	PLIST_ENTRY	listEntry = m_ListHead.Flink ;

	if( listEntry != &m_ListHead ) {

		feedOut = CONTAINING_RECORD(	listEntry,
										FEED_BLOCK,
										ListEntry ) ;

		if( feedOut->MarkedForDelete )
			feedOut = NextEnumerate( feedOut ) ;

	}	else	{

		ReleaseResource( &m_ListLock ) ;

	}

	if( feedOut != 0 ) {

		DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
				feedOut, feedOut->ReferenceCount, feedOut->State, feedOut->MarkedForDelete,
				feedOut->FeedsInProgress, feedOut->ReplacedBy, feedOut->Replaces ) ;
	}

	return	feedOut ;

}	//	CFeedList::StartEnumerate

PFEED_BLOCK
CFeedList::NextEnumerate(	
					PFEED_BLOCK	current
					) {
/*++

Routine Description :

	This function returns the next FEED_BLOCK in the list.
	StartEnumerate() grabbed the shared lock and returned the
	first element.  When we are about to return NULL, we know
	that the caller has gone through the entire list,
	so we release the lock.

Arguments :

	current - the current position in the enumeration

Return Value :

	The next feed block if there is one, NULL otherwise

--*/

	TraceFunctEnter( "CFeedList::NextEnumerate" ) ;

	_ASSERT( current != 0 ) ;

#ifdef	DEBUG
	_ASSERT( FIsInList( current ) ) ;
#endif

	PFEED_BLOCK	feedOut = 0 ;
	PLIST_ENTRY	listEntry = current->ListEntry.Flink ;
	while( listEntry && listEntry != &m_ListHead ) {

		feedOut = CONTAINING_RECORD(	listEntry,
										FEED_BLOCK,
										ListEntry ) ;

		if( !feedOut->MarkedForDelete ) {
			break ;
		}

		feedOut = 0 ;
		listEntry = listEntry->Flink ;
	}

	if( feedOut == 0 ) {
		
		DebugTrace( 0, "Released Lock" ) ;

		ReleaseResource( &m_ListLock ) ;
	}	else	{
		DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
				feedOut, feedOut->ReferenceCount, feedOut->State, feedOut->MarkedForDelete,
				feedOut->FeedsInProgress, feedOut->ReplacedBy, feedOut->Replaces ) ;
	}

	return	feedOut ;

}	//	CFeedList::NextEnumerate

void
CFeedList::FinishEnumerate(	
			PFEED_BLOCK	feed
			) {
/*++

Routine Description :

	This function is called when somebody has used StartEnumerate()
	to go through the list, however they decide they don't want to
	go to the end.
	This function will drop the shared resource lock, if the
	caller had not reached the end.

Arguments :

	feed - The last pointer the caller got from StartEnumerate()
		or NextEnumerate().  If they had gone through the whole
		list this will be NULL, and in that case there
		lock will have benn dropped.

Return Value :

	None.

--*/

	if( feed != 0 )
		ReleaseResource( &m_ListLock ) ;

}

PFEED_BLOCK
CFeedList::Next(	
			PNNTP_SERVER_INSTANCE pInstance,
			PFEED_BLOCK	feedBlockIn
			) {
/*++

Routine Description :

	This function will enumerate the list, however
	we will not hold any locks between calls to Next().
	This is quite different from NextEnumerate(), where
	because of the shared lock the caller is guaranteed
	that the list doesn't change underneath him
	We will bump the reference count of the returned element
	so that the caller is guaranteed that its memory wont
	be released while he examines it, however the caller
	should use MarkInProgress() to ensure that no other
	thread simultaneously changes memeber variables.
	On each call we will drop the refence count that we
	add from the previous position in the enumeration.
	Additionally as we go through each FEED_BLOCK
	we make sure we don't return to the caller blocks
	which have updates pending etc... (set by ApplyUpdate())

Aguments :

	feedBlockIn -
		The current position in the enumeration.	
		This should be NULL on the first call
		to get the first element in the list.

Return Value :

	The next block if there is one, NULL otherwise.

--*/

	TraceFunctEnter( "CFeedList::Next" ) ;

	PFEED_BLOCK	feedBlock = feedBlockIn ;
	PFEED_BLOCK	feedBlockOut = 0 ;
	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	feedBlockOut = InternalNext( feedBlock ) ;
	while( feedBlockOut &&
			(feedBlockOut->MarkedForDelete ||
			 feedBlockOut->Replaces != 0 ) ) {
		feedBlockOut = InternalNext( feedBlockOut ) ;
	}

	_ASSERT( feedBlockOut == 0 || feedBlockOut->ReplacedBy == 0 ) ;

	if( feedBlockOut != 0 ) {
		
		ReferenceFeedBlock( feedBlockOut ) ;

		DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
				feedBlockOut, feedBlockOut->ReferenceCount, feedBlockOut->State, feedBlockOut->MarkedForDelete,
				feedBlockOut->FeedsInProgress, feedBlockOut->ReplacedBy, feedBlockOut->Replaces ) ;

	}

	ReleaseResource( &m_ListLock ) ;

	//
	//	Try to do all Dereference's outside of locks !!
	//
	if( feedBlockIn != 0 ) {

		DereferenceFeedBlock( pInstance, feedBlockIn ) ;

	}

	return	feedBlockOut ;
}

PFEED_BLOCK
CFeedList::InternalNext(	
			PFEED_BLOCK	feedBlock
			)	{
/*++

Routine Description :

	This function is only for use by CFeedList::Next().
	It essentially advances by only one element.
	CFeedList::Next may advance by more than one if
	the blocks are marked for deletion/update/etc...

Arguments :

	feedBlock - current position

Return Value :

	Next entry in list if present
	NULL otherwise.

--*/

	PFEED_BLOCK	feedOut = 0 ;
	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	PLIST_ENTRY	listEntry ;
	if( feedBlock == 0 ) {
		
		listEntry = m_ListHead.Flink ;
	
	}	else	{

		listEntry = feedBlock->ListEntry.Flink ;

	}

	if( listEntry != 0 && listEntry != &m_ListHead ) {

		feedOut = CONTAINING_RECORD(	listEntry,
										FEED_BLOCK,
										ListEntry ) ;

	}

	ReleaseResource( &m_ListLock ) ;

	return	feedOut ;
}

PFEED_BLOCK
CFeedList::Search(	
			DWORD	FeedId
			) {
/*++

Routine Description :

	Given a feedId scan the list for a feed Block with a
	matching Id.
	We add a reference to the block we return, the caller
	should use FinishWith() to remove that reference.

Arguments :

	FeedId - the id we want to find.

Return Value :

	The feedblock if found, NULL otherwise.

--*/

	TraceFunctEnter( "CFeedList::Search" ) ;

	PFEED_BLOCK	feedBlock = 0 ;
	AcquireResourceShared( &m_ListLock, TRUE ) ;

	PLIST_ENTRY	listEntry =	m_ListHead.Flink ;
	while( listEntry != &m_ListHead ) {

		feedBlock = CONTAINING_RECORD(	listEntry,
										FEED_BLOCK,
										ListEntry ) ;
		if( feedBlock->FeedId == FeedId  && !feedBlock->MarkedForDelete ) {

			ReferenceFeedBlock( feedBlock ) ;

			DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
					feedBlock, feedBlock->ReferenceCount, feedBlock->State, feedBlock->MarkedForDelete,
					feedBlock->FeedsInProgress, feedBlock->ReplacedBy, feedBlock->Replaces ) ;

			break ;
		}
		listEntry = listEntry->Flink ;
		feedBlock = 0 ;
	}

	ReleaseResource( &m_ListLock ) ;

	return	feedBlock ;
}

void
CFeedList::FinishWith(
					PNNTP_SERVER_INSTANCE pInstance,
					PFEED_BLOCK	feedBlock ) {
/*++

Routine Description :

	Indicate that the caller has completed using a block returned from Search().
	When they are done we'll remove a reference Search() added.

Arguments :

	feedBlock - The block the caller completed using

Return Value :

	None.

--*/
	
	_ASSERT( feedBlock != 0 ) ;

	DereferenceFeedBlock( pInstance, feedBlock ) ;

}

PFEED_BLOCK
CFeedList::Insert(
			PFEED_BLOCK		feedBlock
			) {
/*++

Routine description :

	Insert a new feedblock into the head of the list.

Arguments :
	
	feedBlock - the element to insert into the head.

Return Value :
	
	pointer to the element that was inserted.

--*/

	TraceFunctEnter( "CFeedList::Insert" ) ;

	AcquireResourceExclusive(	&m_ListLock, TRUE ) ;

	InsertHeadList( &m_ListHead,
					&feedBlock->ListEntry ) ;

	DebugTrace( (DWORD_PTR)this, "Insert block %x", feedBlock ) ;
	
	ReleaseResource( &m_ListLock ) ;
	return	feedBlock ;
}

PFEED_BLOCK
CFeedList::Remove(	
				PFEED_BLOCK	feedBlock,
				BOOL		fMarkDead
				) {
/*++

Routine Description :

	Remove an element from the list.
	When removed from the list we mark the state as closed so
	that when the last reference is removed the
	destruction of the block is handled correctly.

Agruments :

	feedBlock - block to be removed
	fMarkDead - if TRUE mark the block's state as closed.

Return Value :

	Pointer to the block that was removed.

--*/

	TraceFunctEnter( "CFeedList::Remove" ) ;

#ifdef	DEBUG

	_ASSERT( feedBlock->ListEntry.Flink == 0 || FIsInList( feedBlock ) ) ;

#endif

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	if( feedBlock->ListEntry.Flink != 0 ) {
		RemoveEntryList( &feedBlock->ListEntry );
		feedBlock->ListEntry.Flink = 0 ;
		feedBlock->ListEntry.Blink = 0 ;
	}

	if( fMarkDead ) {
		feedBlock->State = FeedBlockStateClosed ;
	}

	DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
			feedBlock, feedBlock->ReferenceCount, feedBlock->State, feedBlock->MarkedForDelete,
			feedBlock->FeedsInProgress, feedBlock->ReplacedBy, feedBlock->Replaces ) ;

	ReleaseResource( &m_ListLock ) ;

	return	feedBlock ;
}

void
CFeedList::ApplyUpdate(	
				PFEED_BLOCK	Original,	
				PFEED_BLOCK	Updated
				) {
/*++

Routine Description :

	Given an Updated Feed Block make all the changes on the original feed Block.
	Because the Orginal may be 'in use' (which means there is an active
	TCP session for the feed which implies that completion port threads are
	accessing the member variables) we may not make the changes immediately.
	If the original is inuse we add the Updated version to the list, and mark
	the blocks so that when the session for the original completes the Updated
	entry replaces the original.
	In the meantime, the enumeration API's will take care to skip original's.

Arguments :
	Original - The original feed block which is in the list
	Updated - A feed block which copies most members of the Original
		but may vary in some members

Return Value :

	None.

--*/

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	_ASSERT( Original->Signature == Updated->Signature ) ;
	_ASSERT( Original->FeedType == Updated->FeedType ) ;
	_ASSERT( lstrcmp( Original->KeyName, Updated->KeyName ) == 0 ) ;
	_ASSERT( Original->pFeedQueue == Updated->pFeedQueue ) ;
	_ASSERT( Original->FeedId == Updated->FeedId ) ;

	
	Updated->NumberOfFeeds = 0 ;
	Updated->cFailedAttempts = 0 ;
	Updated->LastNewsgroupPulled = 0 ;
	Updated->FeedsInProgress = 0 ;

	if( Original->State == FeedBlockStateActive ) {

		if( Original->FeedsInProgress == 0 ) {
		
			//
			//	Just replace fields - one for one !
			//

			Original->AutoCreate = Updated->AutoCreate ;
			Original->fAllowControlMessages = Updated->fAllowControlMessages ;
			Original->OutgoingPort = Updated->OutgoingPort ;
			Original->FeedPairId = Updated->FeedPairId ;
			Original->FeedIntervalMinutes = Updated->FeedIntervalMinutes ;
			Original->PullRequestTime = Updated->PullRequestTime ;
			Original->StartTime = Updated->StartTime ;
			Original->NextActiveTime = Updated->NextActiveTime ;
			Original->cFailedAttempts = 0 ;
			Original->NumberOfFeeds = 0 ;
			
			if( Original->ServerName != Updated->ServerName ) {
				if( Original->ServerName )
					FREE_HEAP( Original->ServerName ) ;
				Original->ServerName = Updated->ServerName ;
			}
			Updated->ServerName = 0 ;

			if( Original->Newsgroups != Updated->Newsgroups ) {
				if( Original->Newsgroups )
					FREE_HEAP( Original->Newsgroups ) ;
				Original->Newsgroups = Updated->Newsgroups ;
			}
			Updated->Newsgroups = 0 ;

			if( Original->Distribution != Updated->Distribution ) {
				if( Original->Distribution )
					FREE_HEAP( Original->Distribution ) ;
				Original->Distribution = Updated->Distribution ;
			}
			Updated->Distribution = 0 ;

			Original->fEnabled = Updated->fEnabled ;

			if( Original->UucpName != Updated->UucpName ) {
				if( Original->UucpName )
					FREE_HEAP( Original->UucpName ) ;
				Original->UucpName = Updated->UucpName ;
			}

			if( Original->FeedTempDirectory != Updated->FeedTempDirectory ) {
				if( Original->FeedTempDirectory )
					FREE_HEAP( Original->FeedTempDirectory ) ;
				Original->FeedTempDirectory = Updated->FeedTempDirectory ;
			}
				
			Updated->FeedTempDirectory = 0 ;

			Original->MaxConnectAttempts = Updated->MaxConnectAttempts ;
			Original->ConcurrentSessions = Updated->ConcurrentSessions ;
			Original->SessionSecurityType = Updated->SessionSecurityType ;
			Original->AuthenticationSecurity = Updated->AuthenticationSecurity ;
		
			if( Original->NntpAccount != Updated->NntpAccount ) {
				if( Original->NntpAccount )
					FREE_HEAP( Original->NntpAccount ) ;
				Original->NntpAccount = Updated->NntpAccount ;
			}
			Updated->NntpAccount = 0 ;

			if( Original->NntpPassword != Updated->NntpPassword ) {
				if( Original->NntpPassword )
					FREE_HEAP(	Original->NntpPassword ) ;
				Original->NntpPassword = Updated->NntpPassword ;
			}
			Updated->NntpPassword = 0 ;

			FREE_HEAP( Updated ) ;
			
		}	else	{

			//
			//	A feed is in progress - so just remove the current Feed Block
			//	and replace with the new one !
			//

			_ASSERT( Original->ReplacedBy == 0 ) ;
			_ASSERT( Updated->Replaces == 0 ) ;

			Original->ReplacedBy = Updated ;
			Updated->Replaces = Original ;
		
			//
			//	Bump both ref counts so that they wont be
			//	destroyed untill the update is completed !
			//
			ReferenceFeedBlock( Updated ) ;
			//
			//	Bump the udpated guy twice - once for being referenced by Original
			//	and another for just being in the list !
			//
			ReferenceFeedBlock( Updated ) ;
			ReferenceFeedBlock( Original ) ;

			Original->MarkedForDelete = TRUE ;

			Insert( Updated ) ;

		}
	}
	ReleaseResource( &m_ListLock ) ;
}

long
CFeedList::MarkInProgress(	
				PFEED_BLOCK	feedBlock
				) {
/*++

Routine Description :

	Mark a feed block as 'in progress' which ensures that
	none of the member variables that may be used on a completion
	port thread are touched by Updates().
	The function ApplyUpdate() will ensure that updates too
	block happen when the block is no longer in use.

Arguments :

	feedBlock - The guy to be marked as 'in progress'

Return Value ;

	The old 'in progress' value.
	This is a long indicating how many times MarkInProgress()
	has been called.  UnmarkInProgress() must be called
	for each MarkInProgress() call.

--*/

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	_ASSERT( feedBlock->FeedsInProgress >= 0 ) ;

	long	lReturn = feedBlock->FeedsInProgress ++ ;

	ReleaseResource( &m_ListLock ) ;

	return	lReturn ;
}

long
CFeedList::UnmarkInProgress(	
					PNNTP_SERVER_INSTANCE pInstance,
					PFEED_BLOCK	feedBlock
					)	{
/*++

Routine Description :

	This does the opposite of MarkInProgress
	This function must be called once for each call to
	MarkInProgress.

	If ApplyUpdate() had been called while the block
	was marked 'InProgress' this function will find
	the update and replace the orignal with it.

Arguments :

	feedBlock - The block which is no longer in progress

Return Value :

	0 if the block is no longer in progress
	>0 otherwise.

--*/

	PFEED_BLOCK	feedExtraRef = 0 ;
	PFEED_BLOCK	feedRemove2Refs = 0 ;

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	feedBlock->FeedsInProgress -- ;
	long	lReturn = feedBlock->FeedsInProgress ;

	if( lReturn == 0 &&
		feedBlock->MarkedForDelete ) {

		//
		//	We may be replaced by another feed with new settings !
		//
	
		_ASSERT( feedBlock->Replaces == 0 ) ;
		_ASSERT( !feedBlock->ReplacedBy || feedBlock->pFeedQueue == feedBlock->ReplacedBy->pFeedQueue ) ;

		feedExtraRef = feedBlock->ReplacedBy ;

        if( feedBlock->State == FeedBlockStateClosed && feedExtraRef) {
    	    feedExtraRef->State = FeedBlockStateClosed ;
		}

        if( feedExtraRef && feedExtraRef->State == FeedBlockStateClosed ) {
            feedBlock->State = FeedBlockStateClosed;
        }

        if( feedBlock->ReplacedBy ) {
		    feedBlock->ReplacedBy->Replaces = 0 ;
        }

		//
		//	So that destruction of this guy doesnt close the queue !!!
		//
		feedBlock->pFeedQueue = 0 ;

		//
		//	Unlink this block
		//
		Remove( feedBlock, TRUE ) ;
		feedRemove2Refs = feedBlock ;

	}
	
	_ASSERT( feedBlock->FeedsInProgress >= 0 ) ;

	ReleaseResource( &m_ListLock) ;

	//
	//	removed the reference on the updating block !
	//
	if( feedExtraRef != 0 )
		DereferenceFeedBlock( pInstance, feedExtraRef ) ;

	//
	//	Remove the reference that the updating block had
	//
	if( feedRemove2Refs != 0 ) {
		DereferenceFeedBlock( pInstance, feedRemove2Refs ) ;

		//
		//	Remove the reference that the list had !	
		//
		DereferenceFeedBlock( pInstance, feedRemove2Refs ) ;
	}

	return	lReturn ;
}


BOOL
CFeedList::Term()	{
	DeleteResource( &m_ListLock ) ;
	return	TRUE ;
}

int
NextLegalSz(	LPSTR*	rgsz,	
				DWORD	iCurrent	) {

	while( rgsz[iCurrent] != 0 ) {
		if( *rgsz[iCurrent] != '!' )
			return	iCurrent ;
		iCurrent++ ;
	}
	return	-1 ;
}

BOOL
InitializeFeedManager(
				PNNTP_SERVER_INSTANCE pInstance,
				BOOL& fFatal
                 )
/*++

Routine Description:

    Initializes feed manager data and threads

Arguments:

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
    ENTER("InitializeFeedManager")

    //
    // Compute initial time
    //
    GetSystemTimeAsFileTime( &pInstance->m_ftCurrentTime );
    LI_FROM_FILETIME( &pInstance->m_liCurrentTime, &pInstance->m_ftCurrentTime );

    //
    // Get metabase values
    //

    if ( !InitializeFeedsFromMetabase( pInstance, fFatal ) ) {
        goto error_exit;
    }

	//
	//	NOTE: setting this member to TRUE makes the instance ready for
	//	feed processing
	//

	if( TRUE ) {
		DebugTrace(0,"Enabling FeedManager");
		pInstance->m_FeedManagerRunning = TRUE;
	}

    LEAVE
    return(TRUE);

error_exit:
	
	NntpLogEvent(	NNTP_BAD_FEED_REGISTRY,	
					0,
					0,
					0 ) ;	

    TerminateFeedManager( pInstance );
    return(FALSE);

} // InitializeFeedManager

VOID
TerminateFeedManager(
				PNNTP_SERVER_INSTANCE pInstance
                )
/*++

Routine Description:

    Shuts down the feed manager

Arguments:

    None.

Return Value:

    None.

--*/
{
    //PLIST_ENTRY listEntry;
    PFEED_BLOCK feedBlock;

    ENTER("TerminateFeedManager")

    //
    // Prepare to shut down
    //

	CShareLockNH* pLockInstance = pInstance->GetInstanceLock();

	//
	//	if feed thread is partying on this instance, block
	//	till it finishes.
	//

	pLockInstance->ExclusiveLock();
    pInstance->m_FeedManagerRunning = FALSE;
	pLockInstance->ExclusiveUnlock();

    //
    // Free lists for this instance
    //

	feedBlock = (pInstance->m_pActiveFeeds)->Next( pInstance, 0 ) ;
	while( feedBlock != 0 ) {

		CloseFeedBlock( pInstance, feedBlock ) ;
		(pInstance->m_pActiveFeeds)->FinishWith( pInstance, feedBlock ) ;
		feedBlock = (pInstance->m_pActiveFeeds)->Next( pInstance, 0 ) ;
	}

	feedBlock = (pInstance->m_pPassiveFeeds)->Next( pInstance, 0 ) ;
	while( feedBlock != 0 ) {

		CloseFeedBlock( pInstance, feedBlock ) ;
		(pInstance->m_pPassiveFeeds)->FinishWith( pInstance, feedBlock ) ;
		feedBlock = (pInstance->m_pPassiveFeeds)->Next( pInstance, 0 ) ;
	}

    LEAVE
    return;

} // TerminateFeedManager

PFEED_BLOCK
AllocateFeedBlock(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN LPSTR	KeyName OPTIONAL,
	IN BOOL		fCleanSetup,	
    IN LPCSTR	ServerName,
    IN FEED_TYPE FeedType,
    IN BOOL		AutoCreate,
    IN PULARGE_INTEGER StartTime,
    IN PFILETIME NextPull,
    IN DWORD	FeedInterval,
    IN PCHAR	Newsgroups,
    IN DWORD	NewsgroupsSize,
    IN PCHAR	Distribution,
    IN DWORD	DistributionSize,
    IN BOOL		IsUnicode,
	IN BOOL		fEnabled,
   	IN LPCSTR	UucpName,
	IN LPCSTR	FeedTempDirectory,
	IN DWORD	MaxConnectAttempts,
	IN DWORD	ConcurrentSessions,
	IN DWORD	SessionSecurityType,
	IN DWORD	AuthenticationSecurityType,
	IN LPSTR	NntpAccount,
	IN LPSTR	NntpPassword,
	IN BOOL		fAllowControlMessages,
	IN DWORD	OutgoingPort,
	IN DWORD	FeedPairId,
	IN DWORD*	ParmErr	
)
/*++

Routine Description:

    Allocate a feed block

Arguments:

    KeyName - Name of the reg key where this feed info resides
	fCleanSetup - if TRUE then we want to start this feed from scratch -
		delete any old queue files that may be around etc...
		if FALSE then this feed has existed in the pass and we want to
		recover any old queue files etc... that were left around
    ServerName - Name of the remote server
    FeedType - Type of the feed.
    AutoCreate - Should we autocreate the tree (ask Neil what this means)
    StartTime - When feed should start
    NextPull - When the next pull should occur
    FeedInterval - Feed interval in minutes
    Newsgroups - list of newsgroup specs
    NewsgroupsSize - size of newsgroup spec list
    Distribution - distribution list
    DistributionSize - size of the distribution list
    IsUnicode - Is the server name in Unicode?
	fEnabled - if TRUE the feed is enabled and we should be scheduled !
	UucpName - The name of the remote server to be used for processing path headers
	FeedTempDirectory - Where to place temp files for the incoming feed
	MaxConnectAttempts - Maximum number of consecutive connect failures
		for an outgoing feed before disabling the feed
	ConcurrentSessions - The number of simultaneous sessions to be
		attempted for an outgoing feed.
	SessionSecurityType - FUTURE USE
	AuthenticationSecurityType - Do we issue authinfo's on outbound feeds ?
	NntpAccount - Account to be used for Authinfo user
	NntpPassword - Password to be used with Authinfo pass
	fAllowControlMessages - Allow control messages for this feed ?
	OutgoingPort - port to be used on outgoing feeds
	FeedPairId - associated feed pair id

Return Value:

    Pointer to the newly allocated feed block.

--*/
{
    PFEED_BLOCK feedBlock = NULL;
	char	queueFile[MAX_PATH] ;
	ZeroMemory( queueFile, sizeof( queueFile ) ) ;
	CFeedQ*	pQueue = 0 ;
	DWORD	parmErr = 0 ;
	LPSTR	ServerNameAscii = 0 ;
	LPSTR*	UucpNameAscii = 0 ;
	LPSTR	FeedTempDirectoryAscii = 0 ;
	LPSTR	NntpAccountAscii = 0 ;
	LPSTR	NntpPasswordAscii = 0 ;

    ENTER("AllocateFeedBlock")

	if( IsUnicode ) {

		ServerNameAscii =
			(LPSTR)ALLOCATE_HEAP( 2 * (wcslen( (LPWSTR)ServerName ) + 1) ) ;
		if( ServerNameAscii != 0 ) {
			CopyUnicodeStringIntoAscii( ServerNameAscii, (LPWSTR) ServerName ) ;
		}	else	{
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			goto	error ;
		}

	}	else	{

		ServerNameAscii =
			(LPSTR)ALLOCATE_HEAP( lstrlen(ServerName) + 1 ) ;
		if( ServerNameAscii != 0 ) {
			lstrcpy( ServerNameAscii, ServerName ) ;
		}	else	{
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			goto	error ;
		}
	}

	if( UucpName != 0 &&
			((IsUnicode && *((LPWSTR)UucpName) != L'\0') ||
			 (!IsUnicode && *UucpName != '\0'))  ) {
		if( IsUnicode ) {
			UucpNameAscii = MultiSzTableFromStrW( (LPWSTR)UucpName ) ;
		}	else	{
			UucpNameAscii = MultiSzTableFromStrA( UucpName ) ;
		}

		if( UucpNameAscii == 0 || *UucpNameAscii == 0 ) {
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			goto	error ;
		}	else if( **UucpNameAscii == '\0' ) {
			SetLastError( ERROR_INVALID_PARAMETER ) ;
			parmErr = FEED_PARM_UUCPNAME ;
			goto	error ;
		}

	}	else	{
		if( FEED_IS_PUSH( FeedType ) ) {

			if( ServerNameAscii == NULL || inet_addr( ServerNameAscii ) != INADDR_NONE ) {
				//
				//	A TCP/IP address was passed as the servername - we cant
				//	use this to produce the Uucp Name !
				//
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				parmErr = FEED_PARM_UUCPNAME ;
				goto	error ;
			}	else	{
				UucpNameAscii = MultiSzTableFromStrA( ServerNameAscii ) ;
				if( UucpNameAscii == 0 ) {
					SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
					goto	error ;
				}
			}
		}	else	{
			//
			//	In this case the UUCP Name may be NULL !
			//
		}
	}

	if( FeedTempDirectory != 0 &&
			((IsUnicode && *((LPWSTR)FeedTempDirectory) != L'\0') ||
			 (!IsUnicode && *FeedTempDirectory != '\0'))  ) {

		if( IsUnicode ) {
			FeedTempDirectoryAscii =
				(LPSTR)ALLOCATE_HEAP( 2 * (wcslen( (LPWSTR)FeedTempDirectory ) + 1) ) ;
			if( FeedTempDirectoryAscii != 0 ) {
				CopyUnicodeStringIntoAscii( FeedTempDirectoryAscii, (LPWSTR)FeedTempDirectory ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}	else	{
			FeedTempDirectoryAscii =
				(LPSTR)ALLOCATE_HEAP( lstrlen( FeedTempDirectory ) + 1 ) ;
			if( FeedTempDirectoryAscii != 0 ) {
				lstrcpy( FeedTempDirectoryAscii, FeedTempDirectory ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}
	}	else	{

		if( FEED_IS_PASSIVE( FeedType ) || FEED_IS_PULL( FeedType ) ) {

			//
			//	Passive feeds must have a feed directory - so pick up a default !
			//
			FeedTempDirectoryAscii = (LPSTR)ALLOCATE_HEAP( lstrlen( pInstance->m_PeerTempDirectory ) + 1 ) ;
			if( FeedTempDirectoryAscii != 0 ) {
				lstrcpy( FeedTempDirectoryAscii, pInstance->m_PeerTempDirectory ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}
	}
	//
	//	Check that the temp directory exists if it was specified !
	//

	if( FeedTempDirectoryAscii != 0 && !CreateDirectory( FeedTempDirectoryAscii, NULL ) ) {
		if( GetLastError() != ERROR_ALREADY_EXISTS ) {
			parmErr = FEED_PARM_TEMPDIR ;
			goto	error ;
		}
	}

	if( AuthenticationSecurityType != AUTH_PROTOCOL_CLEAR &&
		AuthenticationSecurityType != AUTH_PROTOCOL_NONE ) {

		parmErr = FEED_PARM_AUTHTYPE ;
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		goto	error ;
	}

	if( AuthenticationSecurityType == AUTH_PROTOCOL_CLEAR ) {

#if 0
		//
		//	Passive feeds dont need authentication settings !
		//	#if 0 since feeds are now added in pairs, so the
		//	active counterpart will have auth strings.
		//
		if( FEED_IS_PASSIVE( FeedType ) ) {
			parmErr = FEED_PARM_AUTHTYPE ;
			SetLastError( ERROR_INVALID_PARAMETER ) ;
			goto	error ;
		}
#endif

		//
		//	Account & Password must both be non-null if the user
		//	wants clear authentication !
		//
		if( NntpAccount == 0 || * NntpAccount == 0 ) {
			parmErr = FEED_PARM_ACCOUNTNAME ;
			SetLastError( ERROR_INVALID_PARAMETER ) ;
			goto	error ;
		}

		if( NntpPassword == 0 || *NntpPassword == 0 ) {
			parmErr = FEED_PARM_PASSWORD ;
			SetLastError( ERROR_INVALID_PARAMETER ) ;
			goto	error ;
		}

		if( IsUnicode ) {
			NntpAccountAscii =
				(LPSTR)ALLOCATE_HEAP( 2 * (wcslen( (LPWSTR)NntpAccount ) + 1) ) ;
			if( NntpAccountAscii != 0 ) {
				CopyUnicodeStringIntoAscii( NntpAccountAscii , (LPWSTR)NntpAccount ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}	else	{
			NntpAccountAscii =
				(LPSTR)ALLOCATE_HEAP( lstrlen( NntpAccount ) + 1 ) ;
			if( NntpAccountAscii != 0 ) {
				lstrcpy( NntpAccountAscii, NntpAccount ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}

		if( IsUnicode ) {
			NntpPasswordAscii =
				(LPSTR)ALLOCATE_HEAP( 2 * (wcslen( (LPWSTR)NntpPassword ) + 1) ) ;
			if( NntpPasswordAscii != 0 ) {
				CopyUnicodeStringIntoAscii( NntpPasswordAscii, (LPWSTR)NntpPassword ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}	else	{
			NntpPasswordAscii =
				(LPSTR)ALLOCATE_HEAP( lstrlen( NntpPassword ) + 1 ) ;
			if( NntpPasswordAscii != 0 ) {
				lstrcpy( NntpPasswordAscii, NntpPassword ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}
	}


	EnterCriticalSection( &pInstance->m_critFeedConfig ) ;

	if( !ValidateFeedType(FeedType) ) {
		parmErr = FEED_PARM_FEEDTYPE ;
		SetLastError(	ERROR_INVALID_PARAMETER ) ;
		goto	error_unlock ;
	}	else	{

		if( FEED_IS_MASTER( FeedType ) ) {
			if( FEED_IS_PASSIVE( FeedType ) ) {

				if( pInstance->m_NumberOfMasters + 1 > 1 ) {
					parmErr = FEED_PARM_FEEDTYPE ;
					SetLastError( ERROR_INVALID_PARAMETER ) ;
					goto	error_unlock ;
				}
			}
		}
		
		if( FEED_IS_MASTER( FeedType ) )	{
			if( pInstance->m_OurNntpRole == RoleMaster ) {
				parmErr = FEED_PARM_FEEDTYPE ;
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				goto	error_unlock ;
			}
		}	else	if( FEED_IS_SLAVE( FeedType ) ) {
			if( pInstance->m_OurNntpRole == RoleSlave ) {
				parmErr = FEED_PARM_FEEDTYPE ;
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				goto	error_unlock ;
			}
		}

		if( pInstance->m_OurNntpRole == RoleSlave ) {
			if( FEED_IS_PULL(FeedType) ||
				(FEED_IS_PEER(FeedType) && FEED_IS_PASSIVE(FeedType)) ){
				parmErr = FEED_PARM_FEEDTYPE ;
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				goto	error_unlock ;
			}
		}	else if( pInstance->m_OurNntpRole == RolePeer &&
				pInstance->m_ConfiguredPeerFeeds != 0 ) {
			if( FEED_IS_MASTER(FeedType) ) {
				parmErr = FEED_PARM_FEEDTYPE ;
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				goto	error_unlock ;
			}
		}
	}

    feedBlock = (PFEED_BLOCK)ALLOCATE_HEAP( sizeof(FEED_BLOCK) );
    if ( feedBlock != NULL ) {

		//
		//	Validate our arguments !?
		//

        ZeroMemory(feedBlock, sizeof(FEED_BLOCK));
        feedBlock->Signature = FEED_BLOCK_SIGN;
        feedBlock->FeedType = FeedType;
        feedBlock->AutoCreate = AutoCreate;
        feedBlock->FeedIntervalMinutes = FeedInterval;
        feedBlock->StartTime.QuadPart = StartTime->QuadPart;
        feedBlock->State = FeedBlockStateActive;
        feedBlock->PullRequestTime = *NextPull;
		feedBlock->LastNewsgroupPulled = 0 ;
		feedBlock->fEnabled = fEnabled ;
		feedBlock->UucpName = UucpNameAscii ;
		feedBlock->FeedTempDirectory = FeedTempDirectoryAscii ;
		feedBlock->MaxConnectAttempts = MaxConnectAttempts ;
		feedBlock->ConcurrentSessions = ConcurrentSessions ;
		feedBlock->AuthenticationSecurity = AuthenticationSecurityType ;
		feedBlock->NntpAccount = NntpAccountAscii ;
		feedBlock->NntpPassword = NntpPasswordAscii ;
		feedBlock->fAllowControlMessages = fAllowControlMessages;
		feedBlock->OutgoingPort = OutgoingPort;
		feedBlock->FeedPairId = FeedPairId;
		feedBlock->cSuccessfulArticles = 0;
		feedBlock->cTryAgainLaterArticles = 0;
		feedBlock->cSoftErrorArticles = 0;
		feedBlock->cHardErrorArticles = 0;

		if( FEED_IS_PUSH(feedBlock->FeedType) && KeyName != 0 ) {

			_ASSERT( FEED_IS_PUSH(feedBlock->FeedType) ) ;

			if( !BuildFeedQFileName( queueFile, sizeof( queueFile )-4 , KeyName, pInstance->QueryGroupListFile()) ) {
				goto	error_unlock ;
			}	else	{

				lstrcat( queueFile, ".fdq" ) ;
				
				if( fCleanSetup )
					DeleteFile( queueFile ) ;

				pQueue= XNEW CFeedQ() ;
				if( pQueue == 0 )	{
					goto	error_unlock ;
				}	else	{
					if( !pQueue->Init( queueFile ) )	{

						PCHAR	tmpBuf[1] ;
						tmpBuf[0] = KeyName ;

						NntpLogEventEx(	NNTP_CANT_CREATE_QUEUE,
										1,
										(const CHAR **)tmpBuf,
										GetLastError(),
										pInstance->QueryInstanceId() ) ;

						goto	error_unlock ;
					}
				}
			}
		}

		feedBlock->pFeedQueue = pQueue ;

        //
        // Put it in the queue
        //

        if ( KeyName != NULL ) {

            DWORD id = 0;

            lstrcpy( feedBlock->KeyName, KeyName );

            //
            // Compute the feed id
            //

            sscanf(KeyName+4, "%d", &id );

            //
            // Cannot be zero
            //

            if ( id == 0 ) {
                ErrorTrace(0,"Key name %s gave us 0\n",KeyName);
                _ASSERT(FALSE);
                goto error_unlock;
            }

            feedBlock->FeedId = id;
        }

        //
        // refcount
        //  +1 -> in queue
        //  +1 -> being processed
        //

        feedBlock->ReferenceCount = 1;

        //
        // Allocate server name
        //

		_ASSERT( ServerNameAscii != 0 ) ;
		feedBlock->ServerName = ServerNameAscii ;

        //
        // store distribution list
        //

        feedBlock->Distribution = AllocateMultiSzTable(
                                                Distribution,
                                                DistributionSize,
                                                IsUnicode
                                                );

        if ( feedBlock->Distribution == NULL ) {
            goto error_unlock;
        }

        //
        // store newsgroup list
        //

        feedBlock->Newsgroups = AllocateMultiSzTable(
                                                Newsgroups,
                                                NewsgroupsSize,
                                                IsUnicode
                                                );


        if ( feedBlock->Newsgroups == NULL ) {
            goto error_unlock;
        }


        //
        // put it in our global queue
        //

        InsertFeedBlockIntoQueue( pInstance, feedBlock );

		//
		//	At this point - we know we will be successfull so manipulate
		//	globals to reflect the new configuration !
		//
		if( FEED_IS_MASTER( feedBlock->FeedType ) ) {
			pInstance->m_OurNntpRole = RoleSlave ;

			if( FEED_IS_PASSIVE( feedBlock->FeedType ) ) {
				++pInstance->m_NumberOfMasters ;
			}
			pInstance->m_ConfiguredMasterFeeds ++ ;

			_ASSERT( pInstance->m_ConfiguredSlaveFeeds == 0 ) ;
			_ASSERT( pInstance->m_NumberOfMasters <= 1 ) ;	// error check should be done before we get here !
		}	else	if( FEED_IS_SLAVE( feedBlock->FeedType ) ) {

			pInstance->m_OurNntpRole = RoleMaster ;

			if( FEED_IS_PASSIVE( feedBlock->FeedType ) ) {
				++pInstance->m_NumberOfPeersAndSlaves ;
			}
			_ASSERT( pInstance->m_ConfiguredMasterFeeds == 0 ) ;
			pInstance->m_ConfiguredSlaveFeeds ++ ;
		}	else	{

			if( (	FEED_IS_PASSIVE( feedBlock->FeedType ) &&
					FEED_IS_PEER( feedBlock->FeedType )) ||
				FEED_IS_PULL( feedBlock->FeedType ) ) {

				pInstance->m_ConfiguredPeerFeeds ++ ;

			}

		}

    } else {
        ErrorTrace(0,"Unable to allocate feed block\n");
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

	LeaveCriticalSection( &pInstance->m_critFeedConfig ) ;

    LEAVE
    return(feedBlock);


error_unlock :

	LeaveCriticalSection( &pInstance->m_critFeedConfig ) ;

error:

	DWORD	dw = GetLastError() ;
	if( ParmErr != 0 ) {
		*ParmErr = parmErr ;
	}

	if( feedBlock != NULL ) {
		if ( feedBlock->Newsgroups != NULL ) {
			FREE_HEAP(feedBlock->Newsgroups);
			feedBlock->Newsgroups = 0 ;
		}

		if ( feedBlock->Distribution ) {
			FREE_HEAP(feedBlock->Distribution);
			feedBlock->Distribution = 0 ;
		}
	}

    if ( ServerNameAscii ) {
        FREE_HEAP(ServerNameAscii);
    }

	if( UucpNameAscii ) {
		FREE_HEAP(UucpNameAscii);
	}

	if(FeedTempDirectoryAscii)	{
		FREE_HEAP(FeedTempDirectoryAscii);
	}

	if(NntpAccountAscii)	{
		FREE_HEAP(NntpAccountAscii);
	}

	if(NntpPasswordAscii)	{
		SecureZeroMemory(NntpPasswordAscii, strlen(NntpPasswordAscii));
		FREE_HEAP(NntpPasswordAscii);
	}

	if(pQueue)    {
		XDELETE	pQueue;
	}
	
	if( feedBlock != 0 ) {
		FREE_HEAP(feedBlock);
	}

	SetLastError( dw ) ;

    return(NULL);

} // AllocateFeedBlock

VOID
InsertFeedBlockIntoQueue(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Inserts the feed block into the queue

Arguments:

    FeedBlock - Pointer to the feed block to insert

Return Value:

    None.

--*/
{
    //
    // Insert to the correct list
    //

    ENTER("InsertFeedBlockIntoQueue")

    if ( FEED_IS_PASSIVE(FeedBlock->FeedType) ) {

		(pInstance->m_pPassiveFeeds)->Insert( FeedBlock ) ;

    } else {

        //
        // Compute for the next active time
        //

        ComputeNextActiveTime( pInstance, FeedBlock, 0, FALSE );

		(pInstance->m_pActiveFeeds)->Insert( FeedBlock ) ;
    }

    LEAVE
    return;

} // InsertFeedBlockIntoQueue

BOOL
InitializeFeedsFromMetabase(
    PNNTP_SERVER_INSTANCE pInstance,
	BOOL& fFatal
    )
/*++

Routine Description:

    Initializes the feed blocks from the registry

Arguments:

    None

Return Value:

    TRUE, if everything went ok. FALSE, otherwise

--*/
{
    DWORD error, i = 0;
    CHAR serverName[MAX_DOMAIN_NAME+1];
    FEED_TYPE feedType;
    DWORD dataSize, dw;
    DWORD feedInterval = 0;
    PFEED_BLOCK feedBlock= 0 ;
    BOOL autoCreate = FALSE ;
    DWORD temp = 0 ;
	DWORD	ParmErr = 0 ;
	BOOL	fEnabled = TRUE ;
	BOOL	fAllowControlMessages = TRUE;
	DWORD   OutgoingPort = NNTP_PORT;
	DWORD	FeedPairId = 0;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	DWORD	MaxConnectAttempts = 0 ;
	DWORD	ConcurrentSessions = 1 ;
	DWORD	AuthenticationType = AUTH_PROTOCOL_NONE ;

    CHAR	distribution[1024];
    CHAR	szNewsGroups[1024];
    PCHAR Newsgroups;
	CHAR	UucpNameBuff[1024] ;
	CHAR	NntpAccountBuff[512] ;
	CHAR	NntpPasswordBuff[512] ;
	CHAR	FeedTempDirBuff[MAX_PATH];

	LPSTR	UucpName = 0 ;
	LPSTR	NntpAccount = 0 ;
	LPSTR	NntpPassword = 0 ;
	LPSTR	FeedTempDir = 0 ;

    DWORD	NewsgroupsSize = 0;
    DWORD	distributionSize = sizeof( distribution ) ;
	DWORD	UucpNameSize = sizeof( UucpNameBuff ) ;
	DWORD	NntpAccountSize = sizeof( NntpAccountBuff ) ;
	DWORD	NntpPasswordSize = sizeof( NntpPasswordBuff ) ;
	DWORD	FeedTempDirSize = sizeof( FeedTempDirBuff ) ;

	ZeroMemory( distribution, sizeof( distribution ) ) ;
	ZeroMemory( UucpNameBuff, sizeof( UucpNameBuff ) ) ;	
	ZeroMemory( NntpAccountBuff, sizeof( NntpAccountBuff ) ) ;	
	ZeroMemory( NntpPasswordBuff, sizeof( NntpPasswordBuff ) ) ;	
	ZeroMemory( FeedTempDirBuff, sizeof( FeedTempDirBuff ) ) ;

    DWORD   dwMask;
    MULTISZ mszNewsGroups(szNewsGroups, 1024);

    ENTER("InitializeFeedsFromMetabase")

	//
	//	Open the metabase key for this instance and
	//	read all params !
	//

    if ( mb.Open( pInstance->QueryMDFeedPath(),
        METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
	{
		//
		//	PeerGapSize
		//

        if ( !mb.GetDword( "",
                           MD_FEED_PEER_GAP_SIZE,
                           IIS_MD_UT_SERVER,
                           &pInstance->m_PeerGapSize ) )
        {
            // default !
        }

        DebugTrace(0,"PeerGapSize set to %d\n",temp);

		//
		//	PeerTempDirectory
		//

		dataSize = MAX_PATH;
		if( !mb.GetString(	"",
							MD_FEED_PEER_TEMP_DIRECTORY,
							IIS_MD_UT_SERVER,
							pInstance->m_PeerTempDirectory,
							&dataSize  ) )
		{
			// get system default
            _VERIFY( GetTempPath( dataSize, (LPTSTR)pInstance->m_PeerTempDirectory ) );
		}

		DO_DEBUG(REGISTRY) {
			DebugTrace(0,"Peer temp directory set to %s\n", pInstance->m_PeerTempDirectory);
		}

		if ( !CreateDirectory( pInstance->m_PeerTempDirectory, NULL) ) {

			error = GetLastError();
			if ( error != ERROR_ALREADY_EXISTS ) {
				ErrorTrace(0,"Error %d creating temp directory %s\n",
                GetLastError(), pInstance->m_PeerTempDirectory);
			}
		}

		for ( ; ; )
		{
			CHAR keyName[128];
			ULARGE_INTEGER feedStart;
			FILETIME nextPull;

			if( !mb.EnumObjects( "",
								 keyName,
								 i++ ) )
			{
				// done enumerating feed keys
				break ;
			}

#if 0
			if ( error != NO_ERROR ) {
				if (error != ERROR_NO_MORE_ITEMS) {
					ErrorTrace(0,"Error %d enumerating feeds\n",error);
					goto error_exit;
				}
				break;
			}
#endif

            //
            // KangYan:
            // Before loading the feed from metabase, check
            // if it's a bad feed by reading its mask.
            //
            if ( mb.GetDword(  keyName,
                                MD_FEED_ERR_PARM_MASK,
                                IIS_MD_UT_SERVER,
                                &dwMask )) {
                if (dwMask != 0) {
                    continue;
                }
            } else {
                if (!mb.SetDword(keyName,
                    MD_FEED_ERR_PARM_MASK,
                    IIS_MD_UT_SERVER,
                    0)) {
                    ErrorTrace(0, 
                        "Error writing MD_FEED_ERR_PARM_MASK for %s, GLE: %d",
                        keyName, GetLastError());
                }
            }

			//
			// Open the feed key and read in all values
			//

			DO_DEBUG(REGISTRY) {
				DebugTrace(0,"Scanning Feed %s\n",keyName);
			}

			//
			// Default missing values as needed 
			//  

			if (!mb.GetDword(keyName, MD_FEED_ADMIN_ERROR, IIS_MD_UT_SERVER, &dw)) {
			    if (!mb.SetDword(keyName, MD_FEED_ADMIN_ERROR, IIS_MD_UT_SERVER, 0)) {
			        ErrorTrace(0,
			            "Error writing MD_FEED_ADMIN_ERROR for %s, GLE: %d",
                        keyName, GetLastError());
                }
            }

			if (!mb.GetDword(keyName, MD_FEED_HANDSHAKE, IIS_MD_UT_SERVER, &dw)) {
			    if (!mb.SetDword(keyName, MD_FEED_HANDSHAKE, IIS_MD_UT_SERVER, 0)) {
			        ErrorTrace(0,
			            "Error writing MD_FEED_HANDSHAKE for %s, GLE: %d",
                        keyName, GetLastError());
                }
            }


			if ( !mb.GetDword(	keyName,
								MD_FEED_DISABLED,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				fEnabled = TRUE ;   //  Default - allow feeds to post !
			} else {
				fEnabled = !!dw ;
			}

			//
			// Get the values for this feed
			//

			dataSize = MAX_DOMAIN_NAME+1;
			if( !mb.GetString(	keyName,
								MD_FEED_SERVER_NAME,
								IIS_MD_UT_SERVER,
								serverName,
								&dataSize  ) )
			{
				// default !
				PCHAR	tmpBuf[2] ;

				tmpBuf[0] = StrServerName ;
				tmpBuf[1] = keyName ;

				NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;

				goto error_exit;
			}

			DO_DEBUG(REGISTRY) {
				DebugTrace(0,"Server name is %s\n",serverName);
			}

			//
			// Feed Type
			//

			if ( !mb.GetDword(	keyName,
								MD_FEED_TYPE,
								IIS_MD_UT_SERVER,
								&feedType ) )
			{
				// default !
				PCHAR	tmpBuf[2] ;

				tmpBuf[0] = StrFeedType ;
				tmpBuf[1] = keyName ;

				NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;

				goto	error_exit ;
			}

			if ( !ValidateFeedType(feedType) ) {
				PCHAR	tmpBuf[2] ;
				CHAR    szId [20] ;
				_itoa( pInstance->QueryInstanceId(), szId, 10 );
				tmpBuf[0] = szId ;
				tmpBuf[1] = keyName ;
				NntpLogEvent(	NNTP_BAD_FEEDTYPE,
								2,
								(const CHAR **)tmpBuf,
								0) ;
				goto error_exit;
			}

			DO_DEBUG(REGISTRY) {
				DebugTrace(0,"FeedType is %d\n",feedType);
			}

			//
			// Verify the feeds
			//

			if ( FEED_IS_MASTER(feedType) ) {

			{
                //
                // Since we talk to a master, we must be a slave
                //

				if( pInstance->m_OurNntpRole == RoleMaster ) {

					PCHAR args [1];
					CHAR  szId [20];
					_itoa( pInstance->QueryInstanceId(), szId, 10 );
					args [0] = szId;

					NntpLogEvent( NNTP_MASTERSLAVE_CONFLICT, 1, (const CHAR **)args, 0 ) ;
					goto	error_exit ;

				}

				if( FEED_IS_PASSIVE( feedType ) ) {
					if( 1+pInstance->m_NumberOfMasters > 1 ) {

						PCHAR args [1];
						CHAR  szId [20];
						_itoa( pInstance->QueryInstanceId(), szId, 10 );
						args [0] = szId;

						NntpLogEvent( NNTP_TOO_MANY_MASTERS, 1, (const CHAR **)args, 0 ) ;
						goto	error_exit ;

					}
				}
            }

			} else {

				//
				// Not a master.  Reject if there are already masters.
				//

				{


                //
                // If we are talking to a slave, then we must be the master
                //

                if ( FEED_IS_SLAVE(feedType) ) {
					if( pInstance->m_OurNntpRole == RoleSlave ) {

						PCHAR args [1];
						CHAR  szId [20];
						_itoa( pInstance->QueryInstanceId(), szId, 10 );
						args [0] = szId;

						NntpLogEvent( NNTP_MASTERSLAVE_CONFLICT, 1, (const CHAR **)args, 0 ) ;
						goto	error_exit ;

					}
					//OurNntpRole = RoleMaster ;
                    ErrorTrace(0,"Server configured as a master\n");
                }

				}
			}

			//
			// Auto Create
			//

			if ( !mb.GetDword(	keyName,
								MD_FEED_CREATE_AUTOMATICALLY,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				autoCreate = FALSE;
			} else {
				autoCreate = dw ? TRUE : FALSE ;
			}

			//
			// Feed Interval.  Valid only for active feeds.
			//

			nextPull.dwHighDateTime = 0;
			nextPull.dwLowDateTime = 0;

			if ( !FEED_IS_PASSIVE(feedType) )
			{
				if ( !mb.GetDword(	keyName,
									MD_FEED_INTERVAL,
									IIS_MD_UT_SERVER,
									&feedInterval ) )
				{
					feedInterval = DEF_FEED_INTERVAL;
				} else {
					if ( feedInterval < MIN_FEED_INTERVAL ) {
						feedInterval = MIN_FEED_INTERVAL;
					}
				}

				DO_DEBUG(REGISTRY) {
					DebugTrace(0,"Feed interval is %d minutes\n",feedInterval);
				}

				if ( !mb.GetDword(	keyName,
									MD_FEED_START_TIME_HIGH,
									IIS_MD_UT_SERVER,
									&feedStart.HighPart ) ||
					 (feedStart.HighPart == 0)  ||
					 !mb.GetDword(	keyName,
									MD_FEED_START_TIME_LOW,
									IIS_MD_UT_SERVER,
									&feedStart.LowPart ))
				{
					feedStart.QuadPart = 0;
				}

				DO_DEBUG(REGISTRY) {
					DebugTrace(0,"Start time set to %x %x\n",
						feedStart.HighPart, feedStart.LowPart);
				}

				//
				// If pull feed, get the next time for the newnews
				//

				if ( FEED_IS_PULL(feedType) )
				{
					if ( !mb.GetDword(	keyName,
										MD_FEED_NEXT_PULL_HIGH,
										IIS_MD_UT_SERVER,
										&nextPull.dwHighDateTime ) )
					{
						nextPull.dwHighDateTime = 0;
						goto end_time;
					}

					if ( !mb.GetDword(	keyName,
										MD_FEED_NEXT_PULL_LOW,
										IIS_MD_UT_SERVER,
										&nextPull.dwLowDateTime ) )
					{
						nextPull.dwHighDateTime = 0;
						nextPull.dwLowDateTime = 0;
						goto end_time;
					}

					DO_DEBUG(REGISTRY) {
						DebugTrace(0,"Next pull time set to %x %x\n",
							nextPull.dwHighDateTime, nextPull.dwLowDateTime);
					}
				}	

			} else {
				feedStart.QuadPart = 0;
				feedInterval = 0;
			}

end_time:

			//
			// Get Distribution
			//

			{
				distributionSize = sizeof( distribution );
				MULTISZ msz( distribution, distributionSize );
				if( !mb.GetMultisz(	keyName,
									MD_FEED_DISTRIBUTION,
									IIS_MD_UT_SERVER,
									&msz ) )
				{
					PCHAR	tmpBuf[2] ;

					tmpBuf[0] = StrFeedDistribution ;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
									2,	
									(const CHAR **)tmpBuf,
									GetLastError(),
									pInstance->QueryInstanceId()) ;

					goto error_exit;
				}

                distributionSize = msz.QueryCCH();
			}

			//
			// Get Newsgroups
			//

			{
				// raid 190991 - Use mszNewsGroups and keep data around.
				if( !mb.GetMultisz(	keyName,
									MD_FEED_NEWSGROUPS,
									IIS_MD_UT_SERVER,
									&mszNewsGroups  ) )
				{
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrFeedNewsgroups ;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
									2,
									(const CHAR **)tmpBuf,
									GetLastError(),
									pInstance->QueryInstanceId()) ;

					goto error_exit;
				}
				NewsgroupsSize= mszNewsGroups.QueryCCH();
				Newsgroups = mszNewsGroups.QueryStr();
			}

			FeedTempDirSize = sizeof( FeedTempDirBuff ) ;
			if( !mb.GetString(	keyName,
								MD_FEED_TEMP_DIRECTORY,
								IIS_MD_UT_SERVER,
								FeedTempDirBuff,
								&FeedTempDirSize  ) )
			{
				DebugTrace(0,"Error in FeedTempDir is %d", GetLastError());

				if( GetLastError() == MD_ERROR_DATA_NOT_FOUND )
				{
					FeedTempDir = 0 ;
				} else {
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrFeedTempDir ;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;
					goto	error_exit ;
				}
			} else {
				FeedTempDir = FeedTempDirBuff ;
			}

			if( FEED_IS_PUSH( feedType ) )
			{
				UucpNameSize = sizeof( UucpNameBuff ) ;
				if( !mb.GetString(	keyName,
									MD_FEED_UUCP_NAME,
									IIS_MD_UT_SERVER,
									UucpNameBuff,
									&UucpNameSize  ) )
				{
					//
					//	Attempt to use the remote server name
					//

					if(  inet_addr( serverName ) == INADDR_NONE ) {
						lstrcpy( UucpName, serverName ) ;
						UucpNameSize = lstrlen( UucpName ) ;
					}	else	{
						PCHAR	tmpBuf[2] ;
						tmpBuf[0] = StrFeedUucpName ;
						tmpBuf[1] = keyName ;

						NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
									2,
									(const CHAR **)tmpBuf,
									GetLastError(),
									pInstance->QueryInstanceId()) ;
						goto	error_exit ;
					}
				}

				UucpName = &UucpNameBuff[0] ;

				if ( !mb.GetDword(	keyName,
									MD_FEED_CONCURRENT_SESSIONS,
									IIS_MD_UT_SERVER,
									&ConcurrentSessions ) )
				{
					goto error_exit;
				}
			}

            if( FEED_IS_PUSH( feedType ) || FEED_IS_PULL( feedType) ) {
				if ( !mb.GetDword(	keyName,
									MD_FEED_MAX_CONNECTION_ATTEMPTS,
									IIS_MD_UT_SERVER,
									&MaxConnectAttempts ) )
				{
					goto error_exit;
				}
            }

			if ( !mb.GetDword(	keyName,
								MD_FEED_AUTHENTICATION_TYPE,
								IIS_MD_UT_SERVER,
								&AuthenticationType ) )
			{
				goto error_exit;
			}

			if( AuthenticationType == AUTH_PROTOCOL_NONE ) {

			}	else if( AuthenticationType == AUTH_PROTOCOL_CLEAR )
			{
				NntpAccountSize = sizeof( NntpAccountBuff ) ;
				if( !mb.GetString(	keyName,
									MD_FEED_ACCOUNT_NAME,
									IIS_MD_UT_SERVER,
									NntpAccountBuff,
									&NntpAccountSize  ) )
				{
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrFeedAuthAccount;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;

					goto error_exit;
				}	else	{
					NntpAccount = NntpAccountBuff ;
				}

				NntpPasswordSize = sizeof( NntpPasswordBuff ) ;
				if( !mb.GetString(	keyName,
									MD_FEED_PASSWORD,
									IIS_MD_UT_SERVER,
									NntpPasswordBuff,
									&NntpPasswordSize,
									METADATA_INHERIT | METADATA_SECURE ) )
				{
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrFeedAuthPassword;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;

					goto error_exit;
				}	else	{
					NntpPassword = NntpPasswordBuff ;
				}
			}

			//
			// Allow control messages
			//

			if ( !mb.GetDword(	keyName,
								MD_FEED_ALLOW_CONTROL_MSGS,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				fAllowControlMessages = TRUE;
			} else {
				fAllowControlMessages = dw ? TRUE : FALSE ;
			}

			//
			// Outgoing ports
			//

			if ( mb.GetDword(	keyName,
								MD_FEED_OUTGOING_PORT,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				OutgoingPort = dw ;
			}

			//
			// FeedPairId
			//

			if ( mb.GetDword(	keyName,
								MD_FEED_FEEDPAIR_ID,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				FeedPairId = dw ;
			}

			//
			// OK, now let's create the feed blocks
			//

			feedBlock = AllocateFeedBlock(
							pInstance,
                            keyName,
							FALSE,
                            serverName,
                            feedType,
                            autoCreate,
                            &feedStart,
                            &nextPull,
                            feedInterval,
                            Newsgroups,
                            NewsgroupsSize,
                            distribution,
                            distributionSize,
                            FALSE,       // not unicode
                            fEnabled,
							UucpName,
							FeedTempDir,
							MaxConnectAttempts,
							1,
							0,
							AuthenticationType,
							NntpAccount,
							NntpPassword,
							fAllowControlMessages,
							OutgoingPort,
							FeedPairId,
							&ParmErr
							);
		}	// end for
	}	// end mb.open

	mb.Close();

    LEAVE
    SecureZeroMemory(NntpPasswordBuff, sizeof(NntpPasswordBuff));
    return(TRUE);

error_exit:

	mb.Close();

    LEAVE
    SecureZeroMemory(NntpPasswordBuff, sizeof(NntpPasswordBuff));
    return(FALSE);

} // InitializeFeedsFromMetabase

DWORD
WINAPI
FeedScheduler(
        LPVOID Context
        )
/*++

Routine Description:

    This is the worker routine that schedules feeds.

Arguments:

    Context - unused.

Return Value:

    Bogus

--*/
{
    DWORD status;
    DWORD timeout;
	PNNTP_SERVER_INSTANCE pInstance = NULL ;

    ENTER("FeedScheduler")

    timeout = g_pNntpSvc->m_FeedSchedulerSleepTime * 1000 ;

    //
    // Loop until the termination event is signalled
    //

    while ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_STOP_PENDING ) {

        status = WaitForSingleObject(
                            g_pNntpSvc->m_hFeedEvent,
                            timeout
                            );

#if ALLOC_DEBUG
        ErrorTrace(0,"field %d article %d\n",numField,numArticle);
        ErrorTrace(0,"Datefield %d frompeerArt %d\n",numDateField,numFromPeerArt);
        ErrorTrace(0,"Pcstring %d PCParse %d\n",numPCString,numPCParse);
        ErrorTrace(0,"CCmd %d CMapFile %d\n",numCmd,numMapFile);
#endif

        if (status == WAIT_TIMEOUT )	{

			if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
				continue;
			}

			//	Get the min and max instance ids
			DWORD dwMinInstanceId = 0;
			DWORD dwMaxInstanceId = 0;

			if( FindIISInstanceRange( g_pNntpSvc, &dwMinInstanceId, &dwMaxInstanceId ) )
			{
				//
				//	Iterate over all instances
				//
				for( DWORD dwCurrInstance = dwMinInstanceId;
						dwCurrInstance <= dwMaxInstanceId; dwCurrInstance++)
				{
					pInstance = FindIISInstance( g_pNntpSvc, dwCurrInstance, FALSE );
					if( pInstance == NULL ) {
						ErrorTrace(0,"Feed thread: FindIISInstance returned NULL: instance %d", dwCurrInstance);
						continue;
					}

					//
					//	Call method to process feeds for an instance
					//	This call is guarded by a r/w lock. shutdown code
					//	acquires this lock exclusively.
					//

					CShareLockNH* pLockInstance = pInstance->GetInstanceLock();

					pLockInstance->ShareLock();
					if( !ProcessInstanceFeed( pInstance ) ) {
						ErrorTrace(0,"ProcessInstanceFeed %d failed", dwCurrInstance );
					} else {
						DebugTrace(0, "ProcessInstanceFeed %d returned success", dwCurrInstance );
					}
					pLockInstance->ShareUnlock();

					//	Release the ref added by FindIISInstance()
					pInstance->Dereference();

					//	No use continuing the iteration if service is stopping !
					if ( g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING ) break;
				}
			} else {
				ErrorTrace(0, "FindIISInstanceRange failed" );
			}

        }	else if (status == WAIT_OBJECT_0) {

            DebugTrace(0,"Termination event signalled\n");
            break;
        } else {

            ErrorTrace(0,"Unexpected status %d from WaitForSingleEntry\n", status);
            _ASSERT(FALSE);
            break;
        }
    }

    LEAVE
    return 1;

} // FeedScheduler

//
//	Process feeds for a given virtual server instance
//
void GenerateFeedReport(PNNTP_SERVER_INSTANCE pInstance,
						PFEED_BLOCK pFeedBlock)
{
	TraceFunctEnter("GenerateFeedReport");

	if (pFeedBlock == NULL) {
		_ASSERT(FALSE);
		return;
	}

	DWORD cSuccessfulArticles;
	DWORD cTryAgainLaterArticles;
	DWORD cSoftErrorArticles;
	DWORD cHardErrorArticles;
	char szFeedId[32];
	char szFeedPeriod[32];
	char szSuccessfulArticles[32];
	char szTryAgainLaterArticles[32];
	char szSoftErrorArticles[32];
	char szHardErrorArticles[32];
	const char *rgszEventArgs[6] = {
		szFeedId,
		szFeedPeriod,
		szSuccessfulArticles,
		szTryAgainLaterArticles,
		szSoftErrorArticles,
		szHardErrorArticles
	};

	// get the current values and reset the values to 0
	cSuccessfulArticles = InterlockedExchange(&(pFeedBlock->cSuccessfulArticles), 0);
	cTryAgainLaterArticles = InterlockedExchange(&(pFeedBlock->cTryAgainLaterArticles), 0);
	cSoftErrorArticles = InterlockedExchange(&(pFeedBlock->cSoftErrorArticles), 0);
	cHardErrorArticles = InterlockedExchange(&(pFeedBlock->cHardErrorArticles), 0);

	DWORD iMessageId;

	switch (pFeedBlock->FeedId) {
	case (DWORD) -2:
		// directory pickup
		iMessageId = FEED_STATUS_REPORT_PICKUP;
		break;
	case (DWORD) -1:
		// client postings
		iMessageId = FEED_STATUS_REPORT_POSTS;
		break;
	default:
		// a real feed
		// figure out which event log message we want to use
		if (pFeedBlock->FeedType & FEED_TYPE_PASSIVE ||
			pFeedBlock->FeedType & FEED_TYPE_PULL)
		{
			iMessageId = FEED_STATUS_REPORT_INBOUND;
		} else {
			iMessageId = FEED_STATUS_REPORT_OUTBOUND;
		}

		break;
	}

	_ltoa(pFeedBlock->FeedId, szFeedId, 10);
	_ltoa(pInstance->GetFeedReportPeriod(), szFeedPeriod, 10);
	_ltoa(cSuccessfulArticles, szSuccessfulArticles, 10);
	_ltoa(cTryAgainLaterArticles, szTryAgainLaterArticles, 10);
	_ltoa(cSoftErrorArticles, szSoftErrorArticles, 10);
	_ltoa(cHardErrorArticles, szHardErrorArticles, 10);


	// log the event
	NntpLogEventEx(iMessageId, 6, rgszEventArgs, 0,
				   pInstance->QueryInstanceId());

	TraceFunctLeave();	
}

BOOL
ProcessInstanceFeed(
				PNNTP_SERVER_INSTANCE	pInstance
				)
{
	TraceFunctEnter("ProcessInstanceFeed");
	MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	BOOL fDoFeedReport;

	// bail if service is stopping or instance is not ready for feed processing
	if( (pInstance->QueryServerState() != MD_SERVER_STATE_STARTED)	||
		!pInstance->m_FeedManagerRunning							||
		pInstance->m_BootOptions									||
		(pInstance->QueryServerState() == MD_SERVER_STATE_STOPPING)	||
		(g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) )
	{
		ErrorTrace(0,"Instance %d cannot process feeds", pInstance->QueryInstanceId());
		return FALSE ;
	}

    PFEED_BLOCK feedBlock;
	BOOL		fInProgress = FALSE ;

    //
    // Compute expiration time
    //

    DO_DEBUG(FEEDMGR) {
        DebugTrace(0,"Wake up\n");
    }

    GetSystemTimeAsFileTime( &pInstance->m_ftCurrentTime );
    LI_FROM_FILETIME( &pInstance->m_liCurrentTime, &pInstance->m_ftCurrentTime );

	//
	// see if its time to do a feed report
	//
	fDoFeedReport = pInstance->IncrementFeedReportTimer();
	if (fDoFeedReport) {
		// go through the passive feeds and do feed reports (active
		// feeds will be reported on in the loop below...)
		feedBlock = (pInstance->m_pPassiveFeeds)->Next(pInstance, NULL);
		GenerateFeedReport(pInstance, pInstance->m_pFeedblockClientPostings);
		GenerateFeedReport(pInstance, pInstance->m_pFeedblockDirPickupPostings);
		while (feedBlock != 0) {
			GenerateFeedReport(pInstance, feedBlock);
			feedBlock = (pInstance->m_pPassiveFeeds)->Next( pInstance, feedBlock ) ;
		}
	}

    //
    // Go through active list and see if we need to party
	//	ActiveFeeds.Next() will add a reference to the feedblock
	//	so it is not deleted while we are using the pointer, but
	//	it does not hold the enumeration lock, so other threads
	//	can do stuff while we enumerate the threads.
    //
	feedBlock = (pInstance->m_pActiveFeeds)->Next( pInstance, NULL ) ;
    while ( feedBlock != 0 ) {
		//
		// check to see if we need to make a feed report about this feed
		//
		if (fDoFeedReport) GenerateFeedReport(pInstance, feedBlock);

		//
		//	If the feed is not already in progress, this will mark it as in
		//	progress.  This ensures that any Admin RPC's which try to
		//	change the Feed Block now and which go through ActiveFeeds.ApplyUpdate()
		//	don't change the Feed Block member variables while we look at them.
		//
		long	lInProgress = (pInstance->m_pActiveFeeds)->MarkInProgress( feedBlock ) ;
        DO_DEBUG(FEEDMGR) {
            DebugTrace(0,"server %s\n",feedBlock->ServerName);
        }

		//
		//	Check if it is really time to start this feed
		//
        if ( !feedBlock->MarkedForDelete  &&
			 !FEED_IS_PASSIVE(feedBlock->FeedType) &&
			 lInProgress == 0 &&
			 feedBlock->fEnabled
             /*(feedBlock->ReferenceCount == 1)*/ ) {

			//
			//	Determine where the time is right for the feed - if this
			//	is the first time since boot, or our time has come - do the feed !
			//

			if( IsFeedTime( pInstance, feedBlock, pInstance->m_liCurrentTime ) ) {
				DO_DEBUG(FEEDMGR) {
					DebugTrace(0,"ok. feed starting for %x\n",feedBlock);
				}
		
				//
				//	Add a reference to the feedBlock.
				//	If we successfully start the socket, then this reference will be
				//	removed when the session completes, for errors we need to remove it
				//	immediately.
				//
				ReferenceFeedBlock( feedBlock );

				//
				//	Try to start a session !
				//
				if ( InitiateOutgoingFeed( pInstance, feedBlock ) ) {

					//
					//	Touch the member varialbles that we know only this thread uses.
					//
					
					fInProgress = TRUE ;
					feedBlock->cFailedAttempts = 0 ;

					feedBlock->NumberOfFeeds ++ ;

					PCHAR	args[2] ;
					CHAR    szId[20];
					_itoa( pInstance->QueryInstanceId(), szId, 10 );
					args[0] = szId;
					args[1] = feedBlock->ServerName ;
					NntpLogEvent(	NNTP_SUCCESSFUL_FEED,
									2,
									(const CHAR **)args,
									0 ) ;

				}	else	{

					//
					//	Grab the critical section that all Feed RPCs must
					//	go through.  We do this to control access to the
					//	cFailedAttempts, MaxConnectAttempts, and Enabled fields !
					//
					//	NOTE : It is important that no other locks be held at this
					//	point so that we don't deadlock with the feed RPCs, fortunately
					//	thats true.
					//

					EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;

					if( GetLastError() != ERROR_NO_DATA ) {

					    ErrorTrace( 0,
					                "Peer feed failed for %s Outgoing %d Error %d\n",
						            feedBlock->ServerName, 
						            feedBlock->OutgoingPort,
						            GetLastError() );

						feedBlock->cFailedAttempts ++ ;
						PCHAR	args[3] ;
						CHAR    szId[20];
						char	szAttempts[20] ;
						_itoa( feedBlock->cFailedAttempts, szAttempts, 10 ) ;
						_itoa( pInstance->QueryInstanceId(), szId, 10 ) ;
						args[0] = szId ;
						args[1] = feedBlock->ServerName ;
						args[2] = szAttempts ;

						//
						//	Log some events about the feed we failed to start.
						//

						if( feedBlock->cFailedAttempts < 5 ) {
							//
							//	Warning event log !
							//
							NntpLogEvent(	NNTP_WARNING_CONNECT,
											2,
											(const CHAR **)args,
											0 ) ;
						}	else	if( feedBlock->cFailedAttempts == 5 ) {
							//	
							//	Error event log !
							//
							NntpLogEvent(	NNTP_ERROR_CONNECT,
											2,
											(const CHAR **)args,
											0 ) ;
						}

						//
						//	Check if we should disable future feeds !!!
						//
						if( feedBlock->cFailedAttempts ==
								feedBlock->MaxConnectAttempts &&
								feedBlock->MaxConnectAttempts != 0xFFFFFFFF )	{


							NntpLogEvent(	NNTP_FEED_AUTO_DISABLED,
											3,
											(const CHAR **)args,
											0
											) ;

							feedBlock->fEnabled = FALSE ;

							UpdateFeedMetabaseValues( pInstance, feedBlock, FEED_PARM_ENABLED ) ;

						}

					} else {

					    ErrorTrace( 0, "Active feed list is empty" );
					}

					LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;

					//
					// Compute next active time
					//
					ComputeNextActiveTime( pInstance, feedBlock, 0, FALSE );

					//
					//	Since we failed to get a session going, we need to
					//	remove the reference we had added before calling
					//	InitiateOutgoingFeed()
					//
					DereferenceFeedBlock( pInstance, feedBlock ) ;
				}
			}
        }
		if( !fInProgress )
			(pInstance->m_pActiveFeeds)->UnmarkInProgress( pInstance, feedBlock ) ;
		fInProgress = FALSE ;
		feedBlock = (pInstance->m_pActiveFeeds)->Next( pInstance, feedBlock ) ;
    }

	TraceFunctLeave();
	return TRUE ;
}

VOID
ReferenceFeedBlock(
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Reference the block.
    *Assumes lock held*

Arguments:

    FeedBlock - Pointer to the Feeds block.

Return Value:

    None.

--*/
{
    DO_DEBUG(FEEDBLOCK) {
        DebugTraceX(0,"Referencing Feed Block %x\n",FeedBlock);
    }
	InterlockedIncrement( (long*)&FeedBlock->ReferenceCount ) ;
    //FeedBlock->ReferenceCount++;

} // ReferenceFeedBlock

VOID
DereferenceFeedBlock(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Dereference the block
    *Assumes lock held*

Arguments:

    FeedBlock - Pointer to the Feeds block.

Return Value:

    None.

--*/
{
    DO_DEBUG(FEEDBLOCK)  {
        DebugTraceX(0,"Dereferencing Feed block %x\n",FeedBlock);
    }

	long	sign = InterlockedDecrement( (long*)&FeedBlock->ReferenceCount ) ;
    if ( /*--FeedBlock->ReferenceCount*/ sign == 0 /*&& FeedBlock->MarkedForDelete*/ ) {

        //
        // Time to go !!
        //

		if( !FEED_IS_PASSIVE( FeedBlock->FeedType ) ) {

			(pInstance->m_pActiveFeeds)->Remove( FeedBlock ) ;

		}	else	{

			(pInstance->m_pPassiveFeeds)->Remove( FeedBlock ) ;

		}

        DO_DEBUG(FEEDMGR) {
            DebugTraceX(0,"Freeing feed block %x\n",FeedBlock);
        }

        _ASSERT( FeedBlock->Signature == FEED_BLOCK_SIGN );
        _ASSERT( FeedBlock->State == FeedBlockStateClosed );

        FeedBlock->Signature = 0xffffffff;

		//
		//	If this block is being deleted because it was replaced by user action
		//	then we do not adjust any of the server config properties.
		//

		if( FeedBlock->ReplacedBy == 0 ) {

			EnterCriticalSection( &pInstance->m_critFeedConfig ) ;

			if( FEED_IS_MASTER( FeedBlock->FeedType ) ) {
				_ASSERT( pInstance->m_OurNntpRole = RoleSlave ) ;
				_ASSERT( pInstance->m_ConfiguredSlaveFeeds == 0 ) ;
				if( FEED_IS_PASSIVE( FeedBlock->FeedType ) ) {
					--pInstance->m_NumberOfMasters ;
				}
				pInstance->m_ConfiguredMasterFeeds -- ;

				if( pInstance->m_ConfiguredMasterFeeds == 0 ) {
					_ASSERT( pInstance->m_NumberOfMasters == 0 ) ;
					pInstance->m_OurNntpRole = RolePeer ;
				}
			}	else	if( FEED_IS_SLAVE( FeedBlock->FeedType ) )	{
				_ASSERT( pInstance->m_OurNntpRole = RoleMaster ) ;
				_ASSERT( pInstance->m_ConfiguredMasterFeeds == 0 ) ;

				pInstance->m_ConfiguredSlaveFeeds -- ;

				if( pInstance->m_ConfiguredSlaveFeeds == 0 ) {
					pInstance->m_OurNntpRole = RolePeer ;
				}
			}	else	{

				if( (	FEED_IS_PASSIVE( FeedBlock->FeedType ) &&
						FEED_IS_PEER( FeedBlock->FeedType )) ||
					FEED_IS_PULL( FeedBlock->FeedType ) ) {

					pInstance->m_ConfiguredPeerFeeds -- ;

				}

			}

			LeaveCriticalSection( &pInstance->m_critFeedConfig ) ;
		}

        //
        // Free everything
        //

        FREE_HEAP( FeedBlock->ServerName );
        FREE_HEAP( FeedBlock->Newsgroups );
        FREE_HEAP( FeedBlock->Distribution );

		if( FeedBlock->pFeedQueue != 0 )	{
			FeedBlock->pFeedQueue->Close(FeedBlock->MarkedForDelete && !FeedBlock->ReplacedBy) ;
			XDELETE	FeedBlock->pFeedQueue ;
		}
		FeedBlock->pFeedQueue = 0 ;

		if( FeedBlock->UucpName != 0 ) {
			FREE_HEAP( FeedBlock->UucpName ) ;
			FeedBlock->UucpName = 0 ;
		}
		if( FeedBlock->FeedTempDirectory != 0 ) {
			FREE_HEAP( FeedBlock->FeedTempDirectory ) ;
			FeedBlock->FeedTempDirectory = 0 ;
		}
		if( FeedBlock->NntpAccount != 0 ) {
			FREE_HEAP( FeedBlock->NntpAccount ) ;
			FeedBlock->NntpAccount = 0 ;
		}
		if( FeedBlock->NntpPassword != 0 ) {
		    	SecureZeroMemory(FeedBlock->NntpPassword, strlen(FeedBlock->NntpPassword));			
			FREE_HEAP( FeedBlock->NntpPassword ) ;
			FeedBlock->NntpPassword = 0 ;
		}
        FREE_HEAP( FeedBlock );
    }

    return;

} // DereferenceFeedBlock

VOID
CloseFeedBlock(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Closes the feed block
    *Assumes lock held*

Arguments:

    FeedBlock - Pointer to the Feeds block.

Return Value:

    None.

--*/
{
    if ( FeedBlock->State == FeedBlockStateActive ) {

        //
        // Close it.
        //

        DO_DEBUG(FEEDMGR) {
            DebugTraceX(0,"Closing feed block %x\n",FeedBlock);
        }

		if( !FEED_IS_PASSIVE( FeedBlock->FeedType ) ) {
			(pInstance->m_pActiveFeeds)->Remove( FeedBlock, TRUE ) ;
		}	else	{
			(pInstance->m_pPassiveFeeds)->Remove( FeedBlock, TRUE ) ;
		}
        _ASSERT( FeedBlock->Signature == FEED_BLOCK_SIGN );
        DereferenceFeedBlock( pInstance, FeedBlock );
    }

    return;

} // CloseFeedBlock

VOID
CompleteFeedRequest(
			PNNTP_SERVER_INSTANCE pInstance,
            IN PVOID Context,
			IN FILETIME	NextPullTime,
            BOOL Success,
			BOOL NoData
            )
/*++

Routine Description:

    Completion routine for a pull feed request

Arguments:

    Context - Actually a pointer the feed block being completed
    Success - Whether the pull was successful or not

Return Value:

    None.

--*/
{
    PFEED_BLOCK feedBlock = (PFEED_BLOCK)Context;

    //
    // No feedblock to complete. return.
    //

    if ( feedBlock == NULL ||
		 feedBlock == pInstance->m_pFeedblockClientPostings ||
		 feedBlock == pInstance->m_pFeedblockDirPickupPostings)
	{
        return;
    }

    DO_DEBUG(FEEDMGR) {
        DebugTraceX(0,"Feed Completion called for %x refc %d\n",
            feedBlock, feedBlock->ReferenceCount);
    }

	// Decrement feed conx counters
	BumpOutfeedCountersDown( pInstance );

    //
    // Compute the next Timeout period for this block if we are done
    // with the feed object
    //

    if ( feedBlock->ReferenceCount > 1 ) {

        if ( Success && ResumePeerFeed( pInstance, feedBlock ) ) {

			//
			//	If we successfully resumed the feed,
			//	then return now as we want to leave without
			//	decrementing the reference count !
			//

			return	;
        }	else	{

			ComputeNextActiveTime( pInstance, feedBlock, &NextPullTime, Success );

			if( FEED_IS_PULL(feedBlock->FeedType) && (Success || NoData) ) {
				feedBlock->AutoCreate = FALSE ;
			}

			// Log an event
			PCHAR args [4];
			CHAR  szId[20];
			char szServerName [MAX_DOMAIN_NAME];
			_itoa( pInstance->QueryInstanceId(), szId, 10 );
			args [0] = szId;

			// get the server name *before* we UnmarkInProgress !
			// lstrcpyn guarantees null-termination
			lstrcpyn( szServerName, feedBlock->ServerName, sizeof(szServerName) );
			args [2] = szServerName;

			if( !FEED_IS_PASSIVE( feedBlock->FeedType ) ) {
				(pInstance->m_pActiveFeeds)->UnmarkInProgress( pInstance, feedBlock ) ;
				args [1] = "an active";
			}
			else {
				(pInstance->m_pPassiveFeeds)->UnmarkInProgress( pInstance, feedBlock ) ;
				args [1] = "a passive";
			}

			args[3] = Success ? "SUCCESS" : "FAILURE";
			NntpLogEvent(		
				NNTP_SUCCESSFUL_FEED_COMPLETED,
				4,
				(const CHAR **)args,
				0 ) ;

		}
    }

    DereferenceFeedBlock( pInstance, feedBlock );

} // CompleteFeedRequest

BOOL
IsFeedTime(	
		PNNTP_SERVER_INSTANCE pInstance,
		PFEED_BLOCK	feedBlock,	
		ULARGE_INTEGER	liCurrentTime
		)
{
	BOOL	fReturn = FALSE ;
	EnterCriticalSection( &pInstance->m_critFeedTime ) ;

	fReturn =
		(feedBlock->NumberOfFeeds == 0) ||
		((pInstance->m_liCurrentTime).QuadPart > feedBlock->NextActiveTime.QuadPart) ;

	LeaveCriticalSection( &pInstance->m_critFeedTime ) ;

	return	fReturn ;
}

VOID
ComputeNextActiveTime(
		IN PNNTP_SERVER_INSTANCE pInstance,
        IN PFEED_BLOCK FeedBlock,
		IN FILETIME*	NextPullTime,
        IN BOOL SetNextPullTime
        )
/*++

Routine Description:

    Computes when the next pull should take place

Arguments:

    Context - A pointer the feed block
    SetNextPullTime - Changes next pull time in registry

Return Value:

    None.

--*/
{
    ULARGE_INTEGER liInterval;
	FILETIME ftCurrTime = {0};
	ULARGE_INTEGER liCurrTime = {0};

	// current time
    GetSystemTimeAsFileTime( &ftCurrTime );
    LI_FROM_FILETIME( &liCurrTime, &ftCurrTime );
	
	EnterCriticalSection( &pInstance->m_critFeedTime ) ;

    DWORD interval = FeedBlock->FeedIntervalMinutes;
	
    ENTER("ComputeNextActiveTime")

    //
    // if this is a pull feed, record the time for the next pull
    //

    if ( SetNextPullTime &&
         FEED_IS_PULL(FeedBlock->FeedType) ) {

        SetNextPullFeedTime( pInstance, NextPullTime, FeedBlock );
    }

    //
    // Make sure the interval is at least the minimum
    //

    if ( interval < MIN_FEED_INTERVAL ) {
        interval = MIN_FEED_INTERVAL;
    }

    liInterval.QuadPart = (ULONGLONG)1000 * 1000 * 10 * 60;
    liInterval.QuadPart *= interval;

    if ( FeedBlock->StartTime.QuadPart == 0 ) {

        //
        // Simple scheduling
        //

        FeedBlock->NextActiveTime.QuadPart =
                liCurrTime.QuadPart + liInterval.QuadPart;

    } else {

        //
        // Complicated scheduling
        //

        FeedBlock->NextActiveTime.QuadPart = FeedBlock->StartTime.QuadPart;

        //
        // if interval is zero, that means that the admin want a
        // single scheduled feed.
        //

        if ( FeedBlock->FeedIntervalMinutes != 0  ) {

            //
            // Adjust so we get a time that's later than now.  If they
            // want complex, we'll give them complex.
            //

            while ( liCurrTime.QuadPart >
                    FeedBlock->NextActiveTime.QuadPart ) {

                FeedBlock->NextActiveTime.QuadPart += liInterval.QuadPart;
            }

        } else {

			// the RPC now returns an error for zero interval times
			_ASSERT( FEED_IS_PASSIVE(FeedBlock->FeedType) || (1==0) );

            //
            // if the start time is earlier than the current time,
            // then don't do it.
            //

            if ( FeedBlock->StartTime.QuadPart <  liCurrTime.QuadPart ) {
                FeedBlock->NextActiveTime.HighPart = 0x7fffffff;
            }
        }
    }

	LeaveCriticalSection( &pInstance->m_critFeedTime ) ;

    return;

} // ComputeNextActiveTime

VOID
SetNextPullFeedTime(
	PNNTP_SERVER_INSTANCE pInstance,
	FILETIME*	pNextPullTime,
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Sets next pull time in registry

Arguments:

    Context - A pointer the feed block

Return Value:

    None.

--*/
{
    DWORD error;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ENTER("SetNextPullFeedTime")

	if( pNextPullTime != 0 &&
		pNextPullTime->dwLowDateTime != 0 &&
		pNextPullTime->dwHighDateTime != 0 ) {

		FeedBlock->PullRequestTime = *pNextPullTime ;
	
	}	else	{

		FeedBlock->PullRequestTime = pInstance->m_ftCurrentTime;

	}

    //
    //  Avoid saving to the metabase during instance stop !!
    //
    if( pInstance->QueryServerState() != MD_SERVER_STATE_STOPPING ) {

	    if( !mb.Open( pInstance->QueryMDFeedPath(), METADATA_PERMISSION_WRITE ) )
	    {
		    error = GetLastError();
            ErrorTrace(0,"Error %d opening %s\n",error,FeedBlock->KeyName);
            return;
	    }

	    if ( !mb.SetDword(	FeedBlock->KeyName,
						    MD_FEED_NEXT_PULL_HIGH,
						    IIS_MD_UT_SERVER,
						    FeedBlock->PullRequestTime.dwHighDateTime ) )
	    {
		    error = GetLastError();
            ErrorTrace(0,"Error %d setting %s for %s\n",
                error, StrFeedNextPullHigh, FeedBlock->KeyName);
	    }

	    if ( !mb.SetDword(	FeedBlock->KeyName,
						    MD_FEED_NEXT_PULL_LOW,
						    IIS_MD_UT_SERVER,
						    FeedBlock->PullRequestTime.dwLowDateTime ) )
	    {
		    error = GetLastError();
            ErrorTrace(0,"Error %d setting %s for %s\n",
                error, StrFeedNextPullLow, FeedBlock->KeyName);
	    }

        mb.Close();
    }

    return;

} // SetNextPullFeedTime

VOID
ConvertTimeToString(
    IN PFILETIME Ft,
    OUT CHAR Date[],
    OUT CHAR Time[]
    )
/*++

Routine Description:

    Converts a FILETIME into a date and time string

Arguments:

    Ft - the filetime to convert
    Date - points to a buffer to receive the date
    Time - points to a buffer to receive the time string

Return Value:

    None.

--*/
{
    SYSTEMTIME st;
    INT len;

    if ( Ft->dwHighDateTime != 0 ) {

        (VOID)FileTimeToSystemTime( Ft, &st );
        len = wsprintf(Date,"%02d%02d%02d",(st.wYear % 100),st.wMonth,st.wDay);
        _ASSERT(len == 6);

        wsprintf(Time,"%02d%02d%02d",st.wHour,st.wMinute,st.wSecond);
        _ASSERT(len == 6);

    } else {

        //
        // if no date specified, then use today's date + midnight
        //

        GetSystemTime( &st );
        len = wsprintf(Date,"%02d%02d%02d",(st.wYear % 100),st.wMonth,st.wDay);
        _ASSERT(len == 6);
        lstrcpy( Time, DEF_PULL_TIME );
    }

    return;
} // ConvertTimeToString

//!!!Need to generalize to other types of pull feeds
BOOL
InitiateOutgoingFeed(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Initiates a peer feed

Arguments:

    FeedBlock - Pointer to the feed block

Return Value:

    TRUE, if successful. FALSE, otherwise

--*/
{

    DWORD inetAddress;
    IN_ADDR addr;
	SOCKADDR_IN sockaddr;
	CAuthenticator*	pAuthenticator = 0 ;

    INT err;
	DWORD	status = NO_ERROR ;

	SetLastError( NO_ERROR ) ;

    ENTER("InitializePeerFeed")

	inetAddress = inet_addr(FeedBlock->ServerName);
    if ( inetAddress == INADDR_NONE ) {

        PHOSTENT hp;

        //
        // Ask the dns for the address
        //

        hp = gethostbyname( FeedBlock->ServerName );
        if ( hp == NULL ) {
            err = WSAGetLastError();
            ErrorTrace(0,"Error %d in gethostbyname\n",err);
            return(FALSE);
        }

        addr = *((PIN_ADDR)*hp->h_addr_list);

    } else {

        addr.s_addr = inetAddress;
    }

	sockaddr.sin_family = AF_INET;
	sockaddr.sin_port = htons((USHORT)FeedBlock->OutgoingPort); //htons(NNTP_PORT);
	sockaddr.sin_addr = addr;


	if( FeedBlock->AuthenticationSecurity == AUTH_PROTOCOL_CLEAR &&
		FeedBlock->NntpAccount != 0 &&
		FeedBlock->NntpPassword != 0 ) {

		pAuthenticator = XNEW CClearTextAuthenticator( FeedBlock->NntpAccount, FeedBlock->NntpPassword ) ;
		if( pAuthenticator == 0 ) {
			return	FALSE ;
		}

	}	else	{
		
		//
		//	No other types supported for the time being !
		//


	}

    //
    // ok, allocate the Peer feed object
    //

	if(	FEED_IS_PULL(FeedBlock->FeedType) )	{

		_ASSERT(	FeedBlock->pFeedQueue == 0 ) ;

		CFromPeerFeed *	pfeedPeer = new CFromPeerFeed();
		if ( pfeedPeer == NULL ) {
			ErrorTrace(0,"Unable to allocate PeerFeed object\n");
			return(FALSE);
		}

		pfeedPeer->fInit(
				(PVOID)FeedBlock,
				pInstance->m_PeerTempDirectory,
				FeedBlock->Newsgroups[0],
				pInstance->m_PeerGapSize,
				FeedBlock->AutoCreate,
				FALSE,	/* No security checks for pull feeds*/
				FeedBlock->fAllowControlMessages,
				FeedBlock->FeedId
				);

		//
		// Set feedblock data
		//

		int	isz = NextLegalSz( FeedBlock->Newsgroups, 0 ) ;

		if( isz < 0 )	{
			status = ERROR_INVALID_PARAMETER ;
			delete	pfeedPeer ;
			goto	error ;
		}

		FeedBlock->LastNewsgroupPulled = (DWORD)isz ;

		pfeedPeer->SetCurrentGroupString(	FeedBlock->Newsgroups[ FeedBlock->LastNewsgroupPulled ] ) ;
		
		FeedBlock->IPAddress = addr.s_addr;

		//
		// Get the newnews Time/Dates
		//

		ConvertTimeToString(
					&FeedBlock->PullRequestTime,
					pfeedPeer->newNewsDate(),
					pfeedPeer->newNewsTime()
					);

		//
		// Create session socket object
		//

		CSessionSocket *pSocket =
			new CSessionSocket( pInstance, INADDR_NONE, FeedBlock->OutgoingPort, TRUE );

		if ( pSocket == NULL ) {
			status = ERROR_OUTOFMEMORY ;
			delete	pfeedPeer ;
			ErrorTraceX(0,"Unable to create SessionSocket object\n");
			goto error;
		}

		//
		//	We are no longer responsible for destroying pAuthenticator in any
		//	circumstances after calling ConnectSocket()
		//
		if( !pSocket->ConnectSocket( &sockaddr,  pfeedPeer, pAuthenticator ) )	{
			pAuthenticator = 0 ;
			status = ERROR_PIPE_BUSY ;
			IncrementStat( pInstance, OutboundConnectsFailed );
			delete	pfeedPeer ;
			delete	pSocket ;
			goto	error ;
		}
		pAuthenticator = 0 ;

		IncrementStat( pInstance, TotalPullFeeds );
		BumpOutfeedCountersUp( pInstance );

	}	else	{

		if(	FeedBlock->pFeedQueue != 0 ) {

			if( FeedBlock->pFeedQueue->FIsEmpty() )	{

				status = ERROR_NO_DATA ;
				goto	error ;

			}	else	{

				COutFeed*	pOutFeed = 0 ;

				if(FEED_IS_MASTER(FeedBlock->FeedType))	{

					pOutFeed = new	COutToMasterFeed( FeedBlock->pFeedQueue, pInstance) ;

				}	else	if(FEED_IS_SLAVE(FeedBlock->FeedType))	{

					pOutFeed = new	COutToSlaveFeed( FeedBlock->pFeedQueue, pInstance) ;

				}	else	if(FEED_IS_PEER(FeedBlock->FeedType))	{

					pOutFeed = new	COutToPeerFeed( FeedBlock->pFeedQueue, pInstance) ;

				}	else	{

					//
					//	What other type of feed is there ??
					//
					_ASSERT( 1==0 ) ;

				}

				if( pOutFeed != 0 ) {

					pOutFeed->fInit(
							(PVOID)FeedBlock ) ;

					//
					//	Create a CSessionSocket object
					//

					CSessionSocket *pSocket =
						new CSessionSocket( pInstance, INADDR_NONE, FeedBlock->OutgoingPort, TRUE );

					if ( pSocket == NULL ) {
						ErrorTraceX(0,"Unable to create SessionSocket object\n");
						status = ERROR_OUTOFMEMORY ;
						delete	pOutFeed ;
						goto error;
					}

					//
					//	After calling ConnectSocket we are not responsible for
					//	destroying pAuthenticator !
					//
					if( !pSocket->ConnectSocket( &sockaddr,  pOutFeed, pAuthenticator ) )	{
						status = ERROR_PIPE_BUSY ;
						IncrementStat( pInstance, OutboundConnectsFailed );
						delete	pSocket ;
						delete	pOutFeed ;
						pAuthenticator = 0 ;
						goto	error ;
					}
					pAuthenticator = 0 ;
					IncrementStat( pInstance, TotalPushFeeds );
					BumpOutfeedCountersUp(pInstance);

				}	else	{

					status = ERROR_OUTOFMEMORY ;
				}
			}
		}
	}

    return(TRUE);

error:

	if( pAuthenticator )
		XDELETE	pAuthenticator ;

	SetLastError( status ) ;
    return(FALSE);

} // InitiateOutgoingFeed

LPSTR
ServerNameFromCompletionContext(	LPVOID	lpv )	{

	if( lpv != 0 ) {	
		PFEED_BLOCK	FeedBlock = (PFEED_BLOCK)lpv ;

		_ASSERT( FeedBlock->Signature == FEED_BLOCK_SIGN ) ;

		return	FeedBlock->ServerName ;
	}
	return	0 ;
}

BOOL
ResumePeerFeed(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Try to resume a peer feed with the next newsgroup

Arguments:

    FeedBlock - Pointer to the feed block

Return Value:

    TRUE, if successful. FALSE, otherwise

--*/
{

    //DWORD inetAddress;
    //IN_ADDR addr;
    SOCKADDR_IN sockaddr;
    CInFeed *infeed = NULL;
    //INT err;
    PCHAR newsgroup;
	CFromPeerFeed*	peerfeed = NULL ;
	CAuthenticator*	pAuthenticator = 0 ;

    ENTER("ResumePeerFeed")

    //
    // See if we have more newsgroups to process
    //

	if( FEED_IS_PULL( FeedBlock->FeedType ) )	{

		_ASSERT( FeedBlock->Newsgroups[ FeedBlock->LastNewsgroupPulled ] != 0 ) ;

		FeedBlock->LastNewsgroupPulled ++ ;
		int	iNextGroup = NextLegalSz( FeedBlock->Newsgroups, FeedBlock->LastNewsgroupPulled ) ;

		if( iNextGroup < 0 ) {

			//
			//	No more newsgroups !!
			//
			return	FALSE ;

		}	else	{

			FeedBlock->LastNewsgroupPulled = (DWORD)iNextGroup ;
			newsgroup = FeedBlock->Newsgroups[ FeedBlock->LastNewsgroupPulled ] ;

		}
	}	else	{

		return	FALSE ;

	}


	if( FeedBlock->AuthenticationSecurity == AUTH_PROTOCOL_CLEAR &&
		FeedBlock->NntpAccount != 0 &&
		FeedBlock->NntpPassword != 0 ) {

		pAuthenticator = XNEW CClearTextAuthenticator( FeedBlock->NntpAccount, FeedBlock->NntpPassword ) ;
		if( pAuthenticator == 0 ) {
			return	FALSE ;
		}

	}	else	{
		
		//
		//	No other types supported for the time being !
		//


	}


	//
	// Fill up the sockaddr structure
	//

	sockaddr.sin_family = AF_INET;
	sockaddr.sin_port = htons((USHORT)FeedBlock->OutgoingPort); //(NNTP_PORT);
	sockaddr.sin_addr.s_addr = FeedBlock->IPAddress;

	//
	// ok, allocate the Peer feed object
	//

	if ( FEED_IS_MASTER(FeedBlock->FeedType) ) {

		infeed = new CFromMasterFeed( );

	} else if ( FEED_IS_PEER(FeedBlock->FeedType) ) {

		infeed = peerfeed =  new CFromPeerFeed( );
	} else {

		infeed = peerfeed = new CFromPeerFeed( );
	}


	if ( infeed == NULL ) {
		ErrorTrace(0,"Unable to allocate CInFeed object\n");
		if( pAuthenticator != 0 )
			XDELETE	pAuthenticator ;
		return(FALSE);
	}

	infeed->fInit(
			(PVOID)FeedBlock,
			pInstance->m_PeerTempDirectory,
			FeedBlock->Newsgroups[0],
			pInstance->m_PeerGapSize,
			FALSE,
			FALSE,	/* No security checks for this feed */
			FeedBlock->fAllowControlMessages,
			FeedBlock->FeedId
			);

	if( peerfeed != 0 ) {

		peerfeed->SetCurrentGroupString( FeedBlock->Newsgroups[ FeedBlock->LastNewsgroupPulled ] ) ;

	}


	//
	// Get the newnews Time/Dates
	//

	ConvertTimeToString(
				&FeedBlock->PullRequestTime,
				infeed->newNewsDate(),
				infeed->newNewsTime()
				);

	//
	// Create session socket object
	//

	CSessionSocket *pSocket =
		new CSessionSocket( pInstance, INADDR_NONE, FeedBlock->OutgoingPort, TRUE );

	if ( pSocket == NULL ) {
		ErrorTraceX(0,"Unable to create SessionSocket object\n");
		goto error;
	}

	//
	//	We are not responsible for destroying pAuthenticator
	//	after calling ConnectSocket !!
	//
	if( !pSocket->ConnectSocket( &sockaddr,  infeed, pAuthenticator ) )	{
		pAuthenticator = 0 ;
		IncrementStat( pInstance, OutboundConnectsFailed );
		delete	pSocket ;
		goto	error ;
	}

	BumpOutfeedCountersUp(pInstance);

	return(TRUE);

error:

	if( pAuthenticator )
		XDELETE	pAuthenticator ;

    delete infeed;
    return(FALSE);

} // ResumePeerFeed

BOOL
ValidateFeedType(
    DWORD FeedType
    )
{

    ENTER("ValidateFeedType")

    //
    // Make sure the values are reasonable
    //

    if ( (FeedType & FEED_ACTION_MASK) > 0x2 ) {
        goto error;
    }

    if ( (FeedType & FEED_REMOTE_MASK) > 0x20 ) {
        goto error;
    }

	if( (FeedType & FEED_ACTION_MASK) == FEED_TYPE_PULL ) {
		if( !FEED_IS_PEER( FeedType ) ) {
			goto	error ;
		}
	}

    return TRUE;

error:

    ErrorTrace(0,"Invalid Feed type %x\n",FeedType);
    return FALSE;

} // ValidFeedType

PFEED_BLOCK
GetRemoteRole(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PSOCKADDR_IN SockAddr,
    IN BOOL fRemoteEqualsLocal
    )
{

	INT			err ;
	PFEED_BLOCK	feedBlock = 0 ;
	PFEED_BLOCK	feedBlockNext = 0 ;
	IN_ADDR		addr[2] ;
	PIN_ADDR*	ppaddr = 0 ;

	TraceFunctEnter( "GetRemoteRole" ) ;

	ZeroMemory( addr, sizeof( addr ) ) ;
	PIN_ADDR	paddr[2] ;
	paddr[0] = &addr[0] ;
	paddr[1] = 0 ;

	
	for( feedBlockNext = feedBlock = (pInstance->m_pPassiveFeeds)->StartEnumerate();
					feedBlock != 0;
					feedBlock = feedBlockNext = (pInstance->m_pPassiveFeeds)->NextEnumerate( feedBlockNext ) )	{

		_ASSERT( FEED_IS_PASSIVE( feedBlock->FeedType ) ) ;
		if( !feedBlock->fEnabled ) continue;	// Ignore disabled feeds

		if( FEED_IS_PASSIVE( feedBlock->FeedType ) ) {

			addr[0].s_addr = inet_addr( feedBlock->ServerName ) ;

			if( addr[0].s_addr == INADDR_NONE )	{

			    PHOSTENT	hp ;
			
				hp = gethostbyname( feedBlock->ServerName ) ;
				if( hp == NULL ) {
					err = WSAGetLastError() ;
					ErrorTrace( 0, "Error %d in gethostbyname", err ) ;
					feedBlock = 0 ;
					continue ;
				}	else	{
					ppaddr = ((PIN_ADDR*)hp->h_addr_list) ;
				}
			}	else	{

				ppaddr = &paddr[0] ;
				
			}

			while( *ppaddr != 0 ) {
				if( (*ppaddr)->s_addr == SockAddr->sin_addr.s_addr ) {
					break ;
				}
				ppaddr++ ;
			}
			if( *ppaddr != 0 )	{
				//
				//	Add a reference to the feedBlock we are going to return !
				//
				ReferenceFeedBlock( feedBlock ) ;
				(pInstance->m_pPassiveFeeds)->FinishEnumerate( feedBlock ) ;
				break ;
			}
		}
		feedBlock = 0 ;

	}

    return feedBlock ;

} // GetRemoteRole

/*++

Routine Description:

	this function loop through all feed blocks,
	add the newsgroups into CInFeed if the ip address matches
	
Arguments:

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
BOOL SetAcceptFeedGroups(	IN PNNTP_SERVER_INSTANCE pInstance,
						IN PSOCKADDR_IN SockAddr,
						CInFeed *pInfeed)
{
	TraceFunctEnter( "SetAcceptFeedGroups" );
	PFEED_BLOCK	feedBlock = 0 ;
	IN_ADDR addr;
	PIN_ADDR	paddr[2];
	paddr[0] = &addr;
	paddr[1] = NULL;
	PIN_ADDR*	ppaddr = 0 ;

	// we are sure we will loop through the whole list. therefore we don't need to call FinishEnumerate at the end
	for( feedBlock = (pInstance->m_pPassiveFeeds)->StartEnumerate();
					feedBlock != 0;
					feedBlock = (pInstance->m_pPassiveFeeds)->NextEnumerate( feedBlock ) )	
	{
		_ASSERT( FEED_IS_PASSIVE( feedBlock->FeedType ) ) ;
		if( !FEED_IS_PASSIVE( feedBlock->FeedType ) ) continue;

		if( !feedBlock->fEnabled ) continue;	// Ignore disabled feeds

		// try to get ip address		
		addr.s_addr = inet_addr(feedBlock->ServerName);

		if ( addr.s_addr == INADDR_NONE ) {
			// If this is not an ip address
			// Ask the dns for the address

			PHOSTENT hp;
			hp = gethostbyname( feedBlock->ServerName );
			if ( hp == NULL ) {
				ErrorTrace(0,"Error %d in gethostbyname(%s)",WSAGetLastError(),feedBlock->ServerName);
				continue;
			}
			// get the list of ip address
			ppaddr = ((PIN_ADDR*)hp->h_addr_list);
		}
		// else point to paddr
		else ppaddr = &paddr[0];

		// loop through the ip address list, if we found a match we'll call AddMultiszAcceptGroups
		while( *ppaddr != 0 ) {
			if( (*ppaddr)->s_addr == SockAddr->sin_addr.s_addr ) {
				break ;
			}
			ppaddr++ ;
		}
		if( *ppaddr != 0 )	{
			if (!pInfeed->AddMultiszAcceptGroups( *(feedBlock->Newsgroups) ) )
			{
				// memory low. don't continue. finish and return false
				(pInstance->m_pPassiveFeeds)->FinishEnumerate( feedBlock );
				ErrorTrace(0, "AddMultiszAcceptGroups failed - memory low");
				return FALSE;
			}
		}		
	}
	return TRUE;
}

CInFeed *
pfeedCreateInFeed(
	PNNTP_SERVER_INSTANCE pInstance,
    PSOCKADDR_IN sockaddr,
    BOOL        fRemoteEqualsLocal,
    CInFeed * & pInFeedFromClient,
    CInFeed * & pInFeedFromMaster,
    CInFeed * & pInFeedFromSlave,
    CInFeed * & pInFeedFromPeer
    )

/*++

Routine Description:

	Used to create a feed of the right type given a socket. Also,
	initializes the object.

Arguments:

	sockaddr - address of the the socket of the feed
	pInFeedFromClient - If this is a client, a pointer to the feed, otherwise, NULL
	pInFeedFromMaster - If this is a master, a pointer to the feed, otherwise, NULL
	pIfeedFromSlave - If this is a slave, a pointer to the feed, otherwise, NULL
	pInFeedFromPeer - If this is a peer, a pointer to the feed, otherwise, NULL

Return Value:

	A pointer to the new feed object or NULL

--*/
{

	TraceFunctEnter( "pfeedCreateInFeed" );
	DWORD	dwMessageId = NNTP_INCOMING_PEER ;


	//
	// Initialize all to Null
	//

	CInFeed * pInFeed = NULL;
		
    pInFeedFromClient = NULL;
    pInFeedFromMaster = NULL;
	pInFeedFromSlave = NULL;
	pInFeedFromPeer = NULL;

	//
	// Here is where we look to find if it is FromMaster, FromPeer, or FromSlave
	//

    FEED_BLOCK*	feedBlock = GetRemoteRole( pInstance, sockaddr, fRemoteEqualsLocal );

	if( feedBlock == 0 ) {


		pInFeedFromClient = pInstance->NewClientFeed();

		pInFeed = pInFeedFromClient;

		if( pInFeed != 0 ) {
			//
			// Init InFeedFromClient feed
			// !!! need to put correct directory, correct netnews pattern, correct
			// !!! gap, and correct user login name.
			//


			pInFeed->fInit( (PVOID)pInstance->m_pFeedblockClientPostings,
							pInstance->m_PeerTempDirectory,
							0,
							0,
							0,
							TRUE,	/* Do security checks on clients */
							TRUE,	/* allow control messages from clients */
							pInstance->m_pFeedblockClientPostings->FeedId
							);
		}

	}	else	{

		_ASSERT( FEED_IS_PASSIVE( feedBlock->FeedType ) ) ;

		DWORD	cbGap = 0 ;

		(pInstance->m_pPassiveFeeds)->MarkInProgress( feedBlock ) ;

		if( FEED_IS_SLAVE( feedBlock->FeedType ) ) {
			pInFeedFromSlave = new CFromPeerFeed( ) ;
			pInFeed = pInFeedFromSlave;
			//Getting a feed from a slave is just like getting one from a peer
			dwMessageId = NNTP_INCOMING_SLAVE ;
		}	else	if(	FEED_IS_MASTER( feedBlock->FeedType ) ) {
			pInFeedFromMaster = new CFromMasterFeed( ) ;
			pInFeed = pInFeedFromMaster;
			dwMessageId = NNTP_INCOMING_MASTER ;
		}	else	if(	FEED_IS_PEER(	feedBlock->FeedType ) ) {
			pInFeedFromPeer = new CFromPeerFeed( ) ;
			pInFeed = pInFeedFromPeer;
			dwMessageId = NNTP_INCOMING_PEER ;
		}

		if( pInFeed != 0 ) {
			//
			// Init InFeedFromClient feed
			// !!! need to put correct directory, correct netnews pattern, correct
			// !!! gap, and correct user login name.
			//

			_ASSERT( feedBlock->FeedTempDirectory != 0 ) ;
			_ASSERT( feedBlock->Newsgroups[0] != 0 ) ;

			pInFeed->fInit( (PVOID)feedBlock,
							feedBlock->FeedTempDirectory,
							feedBlock->Newsgroups[0],
							cbGap,
							feedBlock->AutoCreate,
							FALSE,
							feedBlock->fAllowControlMessages,
							feedBlock->FeedId,
							( FEED_IS_PEER(	feedBlock->FeedType ) || FEED_IS_SLAVE( feedBlock->FeedType ) )	/* this is accept feed */
							);
			// if this is an accepf feed, but not from master, we should do group check when we receive article
			if ( FEED_IS_PEER(	feedBlock->FeedType ) || FEED_IS_SLAVE( feedBlock->FeedType ) )
			{
				if (!SetAcceptFeedGroups(pInstance, sockaddr, pInFeed))
				{
					// we're almost out of memory, should not continue doing feed.
					delete pInFeed;
					pInFeed = NULL;
					(pInstance->m_pPassiveFeeds)->UnmarkInProgress( pInstance, feedBlock ) ;
					//	Need to remove the reference GetRemoteRole() added
					DereferenceFeedBlock( pInstance, feedBlock ) ;
					ErrorTrace(0, "SetAcceptFeedGroups failed.");
					return NULL;
				}
			}

			// bump the counter
			IncrementStat( pInstance, TotalPassiveFeeds );

			//
			//	Log the event
			//
			char	*szAddress = inet_ntoa( sockaddr->sin_addr ) ;

			PCHAR	args[3] ;
			CHAR    szId[12];
			_itoa( pInstance->QueryInstanceId(), szId, 10 );

			args [0] = szId ;
			if( szAddress != 0 )
				args[1] = szAddress ;
			else
				args[1] = "UNKNOWN" ;
			args[2] = feedBlock->ServerName ;

			NntpLogEvent(		
				dwMessageId,
				3,
				(const CHAR **)args,
				0 ) ;

		}	else	{
			//
			//	Need to remove the reference GetRemoteRole() added
			//
			(pInstance->m_pPassiveFeeds)->UnmarkInProgress( pInstance, feedBlock ) ;
			DereferenceFeedBlock( pInstance, feedBlock ) ;
		}

	}

	return pInFeed;
}

BOOL
BuildFeedQFileName(	
					char*	szFileOut,	
					DWORD	cbFileOut,	
					char*   szFileIn,
					char*	szPathIn
					)
/*++

Routine Description :

	This function uses the directory passed in to build a full pathname for the feedq files.

Arguments :
	szFileOut - Buffer in which to save path
	cbFileOut - size of output buffer
	szFileIn  - Feedq key name
	szPathIn  - Path name to use as base

Return Value :
	TRUE if successfull, FALSE otherwise.

--*/
{
	DWORD cbPathIn;
	ZeroMemory( szFileOut, cbFileOut ) ;

	if( cbFileOut > (cbPathIn = lstrlen( szPathIn )) )
	{
		lstrcpy( szFileOut, szPathIn );

		char* pch = szFileOut+cbPathIn-1;
		while( pch >= szFileOut && (*pch-- != '\\') );	// skip till we see a \
		if( pch == szFileOut ) return FALSE;

		// null-terminate the path
		*(pch+2) = '\0';

		if( cbFileOut > DWORD(lstrlen( szFileOut ) + lstrlen( szFileIn ) + 1) )
		{
			lstrcat( szFileOut, szFileIn );
			return TRUE;
		}
	}

	return	FALSE ;
}

void
BumpOutfeedCountersUp( PNNTP_SERVER_INSTANCE pInstance )	{

	LockStatistics( pInstance ) ;

	IncrementStat( pInstance, CurrentOutboundConnects ) ;
	IncrementStat( pInstance, TotalOutboundConnects ) ;

#if 0	// NYI
	if( NntpStat.MaxOutboundConnections < NntpStat.CurrentOutboundConnects ) {
		NntpStat.MaxOutboundConnections = NntpStat.CurrentOutboundConnects ;	
	}
#endif

	UnlockStatistics( pInstance ) ;

}

void
BumpOutfeedCountersDown( PNNTP_SERVER_INSTANCE pInstance )	{

	LockStatistics( pInstance ) ;

	if ( (pInstance->m_NntpStats).CurrentOutboundConnects > 0 )
		DecrementStat(	pInstance, CurrentOutboundConnects ) ;

	UnlockStatistics( pInstance ) ;
}

DWORD
AddFeedToFeedBlock(
    IN  NNTP_HANDLE ServerName,
    IN  DWORD       InstanceId,
    IN  LPI_FEED_INFO FeedInfo,
    IN  LPSTR       szKeyName,
    OUT PDWORD ParmErr OPTIONAL,
    OUT LPDWORD pdwFeedId
    )
{
    DWORD err = NERR_Success;
    PFEED_BLOCK feedBlock;
    DWORD parmErr = 0;
    ULARGE_INTEGER liStart;
    BOOL IsUnicode = TRUE;

    BOOL serverNamePresent;
    BOOL distPresent;
    BOOL newsPresent;

    DWORD   feedId = 0;
    *pdwFeedId = 0;

    ENTER("NntprAddFeed");

    ACQUIRE_SERVICE_LOCK_SHARED();

    //
    //  Locate the instance object given id
    //

    PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
    if( pInstance == NULL ) {
        ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //
    // KangYan: This goes away
    /*
    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }*/

    EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;

    //
    // Check feed type
    //

    if ( !ValidateFeedType(FeedInfo->FeedType) ) {
        parmErr = FEED_PARM_FEEDTYPE;
        goto invalid_parm;
    }

    //
    // Check feed interval
    //

    if ( !FEED_IS_PASSIVE(FeedInfo->FeedType) && !FeedInfo->FeedInterval ) {
        parmErr = FEED_PARM_FEEDINTERVAL;
        goto invalid_parm;
    }

    LI_FROM_FILETIME( &liStart, &FeedInfo->StartTime );

    serverNamePresent = ((FeedInfo->ServerName != FEED_STRINGS_NOCHANGE) &&
                         (*FeedInfo->ServerName != L'\0'));

    newsPresent = VerifyMultiSzListW(
                        FeedInfo->Newsgroups,
                        FeedInfo->cbNewsgroups
                        );

    distPresent = VerifyMultiSzListW(
                        FeedInfo->Distribution,
                        FeedInfo->cbDistribution
                        );

    //
    // ok, let's do the new feed stuff first
    //

    if ( !serverNamePresent ) {
        parmErr = FEED_PARM_SERVERNAME;
        goto invalid_parm;
    }

    if ( !newsPresent ) {
        parmErr = FEED_PARM_NEWSGROUPS;
        goto invalid_parm;
    }

    if ( !distPresent ) {
        parmErr = FEED_PARM_DISTRIBUTION;
        goto invalid_parm;
    }

    //
    //  validate all buffer lengths - NOTE: the max lengths allowed are those used
    //  in the registry reading code at startup. we will fail RPCs that attempt to
    //  set a length greater than that used during startup.
    //

    if( ( FeedInfo->ServerName ) &&
            (*FeedInfo->ServerName != L'\0') && wcslen(FeedInfo->ServerName)+1 > MAX_DOMAIN_NAME ) {
        parmErr = FEED_PARM_SERVERNAME;
        goto invalid_parm;
    }

    if( (IsUnicode && FeedInfo->cbNewsgroups > 1024*2) || (!IsUnicode && FeedInfo->cbNewsgroups > 1024) ) {
        parmErr = FEED_PARM_NEWSGROUPS;
        goto invalid_parm;
    }

    if( (IsUnicode && FeedInfo->cbDistribution > 1024*2) || (!IsUnicode && FeedInfo->cbDistribution > 1024) ) {
        parmErr = FEED_PARM_DISTRIBUTION;
        goto invalid_parm;
    }

    if( ( FeedInfo->UucpName ) &&
            (*FeedInfo->UucpName != L'\0') && wcslen((LPWSTR)FeedInfo->UucpName)+1 > 1024 ) {
        parmErr = FEED_PARM_UUCPNAME;
        goto invalid_parm;
    }

    if( ( FeedInfo->NntpAccountName ) &&
            (*FeedInfo->NntpAccountName != L'\0') && wcslen((LPWSTR)FeedInfo->NntpAccountName)+1 > 512 ) {
        parmErr = FEED_PARM_ACCOUNTNAME;
        goto invalid_parm;
    }

    if( ( FeedInfo->NntpPassword ) &&
            (*FeedInfo->NntpPassword != L'\0') && wcslen((LPWSTR)FeedInfo->NntpPassword)+1 > 512 ) {
        parmErr = FEED_PARM_PASSWORD;
        goto invalid_parm;
    }

    if( ( FeedInfo->FeedTempDirectory ) &&
            (*FeedInfo->FeedTempDirectory != L'\0') && wcslen((LPWSTR)FeedInfo->FeedTempDirectory)+1 > MAX_PATH ) {
        parmErr = FEED_PARM_TEMPDIR;
        goto invalid_parm;
    }

    //
    // make sure interval and start times are not both zeros
    //

    if ( !FEED_IS_PASSIVE(FeedInfo->FeedType) &&
         (FeedInfo->FeedInterval == 0) &&
         (liStart.QuadPart == 0) ) {

        parmErr = FEED_PARM_STARTTIME;
        goto invalid_parm;
    }

    /*  This goes away
    if( NO_ERROR != AllocateFeedId( pInstance, keyName, feedId ) ) {
        err = GetLastError() ;
        goto    exit ;
    }*/

    //
    // OK, now let's create the feed blocks
    //

    feedBlock = AllocateFeedBlock(
                        pInstance,
                        szKeyName,
                        TRUE,
                        (PCHAR)FeedInfo->ServerName,
                        FeedInfo->FeedType,
                        FeedInfo->AutoCreate,
                        &liStart,
                        &FeedInfo->PullRequestTime,
                        FeedInfo->FeedInterval,
                        (PCHAR)FeedInfo->Newsgroups,
                        FeedInfo->cbNewsgroups,
                        (PCHAR)FeedInfo->Distribution,
                        FeedInfo->cbDistribution,
                        IsUnicode,   // unicode strings
                        FeedInfo->Enabled,
                        (PCHAR)FeedInfo->UucpName,
                        (PCHAR)FeedInfo->FeedTempDirectory,
                        FeedInfo->MaxConnectAttempts,
                        FeedInfo->ConcurrentSessions,
                        FeedInfo->SessionSecurityType,
                        FeedInfo->AuthenticationSecurityType,
                        (PCHAR)FeedInfo->NntpAccountName,
                        (PCHAR)FeedInfo->NntpPassword,
                        FeedInfo->fAllowControlMessages,
                        FeedInfo->OutgoingPort,
                        FeedInfo->FeedPairId,
                        &parmErr
                        );

    if ( feedBlock == NULL ) {
        err = GetLastError() ;
        //DeleteFeedId( pInstance, szKeyName ) ;
        goto exit;
    }

    //
    // Add the feed into the registry -
    // UpdateFeedMetabaseValues will close 'key' in all circumstances !!
    //
    // KangYan: This operation is cancelled for the new feed admin, because
    //          admin should have already done the metabase part

    /*if( !UpdateFeedMetabaseValues( pInstance, feedBlock, FEED_ALL_PARAMS ) ) {

        //
        // Destroy the feed object
        //

        ErrorTrace(0,"Cannot add feed to registry.\n");
        CloseFeedBlock( pInstance, feedBlock );
        err = NERR_InternalError;
    }   else    { */

        LogFeedAdminEvent( NNTP_FEED_ADDED, feedBlock, pInstance->QueryInstanceId() ) ;

    //}

    // return the feed id allocated
    *pdwFeedId = feedId;

exit:

    LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    if( ParmErr != NULL ) {
        *ParmErr = parmErr ;
    }
    return err;

invalid_parm:

    LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    if ( ParmErr != NULL ) {
        *ParmErr = parmErr;
    }
    return(ERROR_INVALID_PARAMETER);

} // AddFeedToFeedBlock

DWORD
DeleteFeedFromFeedBlock(
    IN  NNTP_HANDLE ServerName,
    IN  DWORD       InstanceId,
    IN  DWORD FeedId
    )
{
    DWORD err = NERR_Success;
    PFEED_BLOCK feedBlock = NULL;
    CFeedList*  pList = 0 ;

    ENTER("NntprDeleteFeed");

    ACQUIRE_SERVICE_LOCK_SHARED();

    //
    //  Locate the instance object given id
    //

    PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
    if( pInstance == NULL ) {
        ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //
    //  KangYan:  This goes away
    //
    /*
    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }*/

    //
    // Check feed id
    //

    if ( FeedId == 0 ) {
        err = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;

    //
    // Look for the feed
    //

    pList = pInstance->m_pActiveFeeds ;
    feedBlock = pList->Search( FeedId ) ;
    if( feedBlock == NULL ) {
        pList = pInstance->m_pPassiveFeeds ;
        feedBlock = pList->Search( FeedId ) ;
    }

    if( feedBlock == NULL ) {

        LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ResourceNotFound);

    }   else    {

        //
        // *Lock still held*
        // Delete the registry
        //
        // KangYan: This operation is cancelled because the new feed admin
        //          should have already done that.

        /*if ( (err = DeleteFeedMetabase( pInstance, feedBlock )) == NO_ERROR ) {*/

            //
            // Delete the block
            //

            LogFeedAdminEvent( NNTP_FEED_DELETED, feedBlock, pInstance->QueryInstanceId() ) ;

            feedBlock->MarkedForDelete = TRUE;
            CloseFeedBlock( pInstance, feedBlock );
        //}

        // Search() should always be matched with FinishWith()
        pList->FinishWith( pInstance, feedBlock ) ;

        LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
    }

exit:

    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
    LEAVE
    return(err);

} // DeleteFeedFromFeedBlock

DWORD
SetFeedInformationToFeedBlock(
    IN  NNTP_HANDLE ServerName,
    IN  DWORD       InstanceId,
    IN  LPI_FEED_INFO FeedInfo,
    OUT PDWORD ParmErr OPTIONAL
    )
{
    DWORD err = NERR_Success;
    //PLIST_ENTRY listEntry;
    //PCHAR bufStart;
    //PWCHAR bufEnd;
    PFEED_BLOCK feedBlock;
    DWORD parmErr = 0 ;
    ULARGE_INTEGER liStart;

    BOOL serverNamePresent;
    BOOL distPresent;
    BOOL newsPresent;
    BOOL uucpPresent = FALSE ;
    BOOL acctnamePresent = FALSE ;
    BOOL pswdPresent = FALSE ;
    BOOL tempdirPresent = FALSE ;
    BOOL IsUnicode = TRUE;

    DWORD feedMask = 0;
    PCHAR tempName = NULL;
    LPSTR* tempDist = NULL;
    LPSTR* tempNews = NULL;
    LPSTR*  tempUucp = 0 ;
    PCHAR   tempDir = 0 ;
    PCHAR   tempAccount = 0 ;
    PCHAR   tempPassword = 0 ;

    PFEED_BLOCK Update = 0 ;
    CFeedList*  pList = 0 ;

    ENTER("NntprSetFeedInformation")

    ACQUIRE_SERVICE_LOCK_SHARED();

    //
    //  Locate the instance object given id
    //

    PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
    if( pInstance == NULL ) {
        ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //
    //  KangYan: This goes away
    //
    /*
    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }*/

    err = ERROR_NOT_ENOUGH_MEMORY ;


    //
    // Check feed type
    //

    if ( FeedInfo->FeedType != FEED_FEEDTYPE_NOCHANGE && !ValidateFeedType(FeedInfo->FeedType) ) {
        parmErr = FEED_PARM_FEEDTYPE;
        goto invalid_parm;
    }

    //
    // Check feed interval
    //

    if ( FeedInfo->FeedType != FEED_FEEDINTERVAL_NOCHANGE && !FEED_IS_PASSIVE(FeedInfo->FeedType) && !FeedInfo->FeedInterval ) {
        parmErr = FEED_PARM_FEEDINTERVAL;
        goto invalid_parm;
    }

    LI_FROM_FILETIME( &liStart, &FeedInfo->StartTime );

    serverNamePresent = ((FeedInfo->ServerName != FEED_STRINGS_NOCHANGE) &&
                         (*FeedInfo->ServerName != L'\0'));

    newsPresent = VerifyMultiSzListW(
                        FeedInfo->Newsgroups,
                        FeedInfo->cbNewsgroups
                        );

    distPresent = VerifyMultiSzListW(
                        FeedInfo->Distribution,
                        FeedInfo->cbDistribution
                        );

    uucpPresent = ((FeedInfo->UucpName != FEED_STRINGS_NOCHANGE) &&
                   (*FeedInfo->UucpName != L'\0'));

    acctnamePresent = ((FeedInfo->NntpAccountName != FEED_STRINGS_NOCHANGE) &&
                   (*FeedInfo->NntpAccountName != L'\0'));

    pswdPresent = ((FeedInfo->NntpPassword != FEED_STRINGS_NOCHANGE) &&
                   (*FeedInfo->NntpPassword != L'\0'));

    tempdirPresent = ((FeedInfo->FeedTempDirectory != FEED_STRINGS_NOCHANGE) &&
                   (*FeedInfo->FeedTempDirectory != L'\0'));

    //
    //  validate all buffer lengths - NOTE: the max lengths allowed are those used
    //  in the registry reading code at startup. we will fail RPCs that attempt to
    //  set a length greater than that used during startup.
    //

    if( serverNamePresent ) {
        if( wcslen(FeedInfo->ServerName)+1 > MAX_DOMAIN_NAME ) {
            parmErr = FEED_PARM_SERVERNAME;
            goto invalid_parm;
        }
    }

    // Raid 190991 - Remove check for NewsGroups. They can be larger then 1024

    if( distPresent ) {
        if( (IsUnicode && FeedInfo->cbDistribution > 1024*2) || (!IsUnicode && FeedInfo->cbDistribution > 1024) ) {
            parmErr = FEED_PARM_DISTRIBUTION;
            goto invalid_parm;
        }
    }

    if( uucpPresent ) {
        if( wcslen((LPWSTR)FeedInfo->UucpName)+1 > 1024 ) {
            parmErr = FEED_PARM_UUCPNAME;
            goto invalid_parm;
        }
    }

    if( acctnamePresent ) {
        if( wcslen((LPWSTR)FeedInfo->NntpAccountName)+1 > 512 ) {
            parmErr = FEED_PARM_ACCOUNTNAME;
            goto invalid_parm;
        }
    }

    if( pswdPresent ) {
        if( wcslen((LPWSTR)FeedInfo->NntpPassword)+1 > 512 ) {
            parmErr = FEED_PARM_PASSWORD;
            goto invalid_parm;
        }
    }

    if( tempdirPresent ) {
        if( wcslen((LPWSTR)FeedInfo->FeedTempDirectory)+1 > MAX_PATH ) {
            parmErr = FEED_PARM_TEMPDIR;
            goto invalid_parm;
        }
    }

    if( tempdirPresent ) {
        if( !CreateDirectoryW(  (LPWSTR)FeedInfo->FeedTempDirectory, NULL ) ) {
            if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                parmErr = FEED_PARM_TEMPDIR ;
                goto    invalid_parm ;
            }
        }
    }

    //
    // First, go find the feed block
    // NOTE: This prevents a user from changing a feed type from a passive
    // to an active one and vice versa
    //

    pList = pInstance->m_pActiveFeeds ;
    feedBlock = pList->Search( FeedInfo->FeedId ) ;
    if( feedBlock != NULL ) {
        goto    found ;
    }

    pList = pInstance->m_pPassiveFeeds ;
    feedBlock = pList->Search( FeedInfo->FeedId ) ;
    if( feedBlock != NULL ) {
        goto    found ;
    }

    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
    return  NERR_ResourceNotFound ;

found:

    if( feedBlock->FeedType != FeedInfo->FeedType &&
        FeedInfo->FeedType != FEED_FEEDTYPE_NOCHANGE ) {
        parmErr = FEED_PARM_FEEDTYPE ;
        pList->FinishWith( pInstance, feedBlock ) ;
        goto    invalid_parm ;
    }

    pList->ExclusiveLock() ;

    Update = (PFEED_BLOCK)ALLOCATE_HEAP( sizeof( *feedBlock ) ) ;

    if( Update != 0 ) {
        *Update = *feedBlock ;
        //
        //  Copied the other guys reference count ! - dont want that
        //
        Update->ReferenceCount = 0 ;
    }   else    {
        goto    alloc_error ;
    }

    //
    // *Lock still held*
    //

    if ( serverNamePresent ) {

        feedMask |= FEED_PARM_SERVERNAME;
        tempName = (PCHAR)ALLOCATE_HEAP( 2 * (wcslen(FeedInfo->ServerName) + 1) );
        if ( tempName == NULL ) {
            goto alloc_error;
        }
        CopyUnicodeStringIntoAscii(tempName, FeedInfo->ServerName);
    }   else    {
        tempName = (PCHAR)ALLOCATE_HEAP( lstrlen( feedBlock->ServerName )+1 ) ;
        if( tempName == NULL ) {
            goto    alloc_error ;
        }
        lstrcpy( tempName, feedBlock->ServerName ) ;
    }


    if ( newsPresent ) {

        feedMask |= FEED_PARM_NEWSGROUPS;
        tempNews = AllocateMultiSzTable(
                                (PCHAR)FeedInfo->Newsgroups,
                                FeedInfo->cbNewsgroups,
                                TRUE    // unicode
                                );

        if ( tempNews == NULL ) {
            goto alloc_error;
        }
    }   else    {

        tempNews = AllocateMultiSzTable(
                                (PCHAR)feedBlock->Newsgroups[0],
                                MultiListSize( feedBlock->Newsgroups ),
                                FALSE
                                ) ;
        if( tempNews == NULL ) {
            goto    alloc_error ;
        }
    }

    if ( distPresent ) {

        feedMask |= FEED_PARM_DISTRIBUTION;
        tempDist = AllocateMultiSzTable(
                            (PCHAR)FeedInfo->Distribution,
                            FeedInfo->cbDistribution,
                            TRUE    // unicode
                            );

        if ( tempDist == NULL ) {
            goto alloc_error;
        }
    }   else    {

        tempDist = AllocateMultiSzTable(
                            (PCHAR)feedBlock->Distribution[0],
                            MultiListSize( feedBlock->Distribution ),
                            FALSE ) ;
        if( tempDist == NULL ) {
            goto    alloc_error ;
        }
    }

    if( uucpPresent )   {

        feedMask |= FEED_PARM_UUCPNAME ;

        tempUucp = MultiSzTableFromStrW( (LPWSTR)FeedInfo->UucpName ) ;
        if( tempUucp == 0 ) {
            goto    alloc_error ;
        }   else if( **tempUucp == '\0' ) {
            err = ERROR_INVALID_PARAMETER ;
            parmErr = FEED_PARM_UUCPNAME;
            goto    alloc_error ;
        }

    }   else    {

        if( feedBlock->UucpName != 0 ) {
            tempUucp = CopyMultiList( feedBlock->UucpName ) ;
            if( tempUucp == 0 ) {
                goto    alloc_error ;
            }
        }
    }

    if( tempdirPresent )    {

        feedMask |= FEED_PARM_TEMPDIR ;

        tempDir = (PCHAR)ALLOCATE_HEAP( 2 * (wcslen((LPWSTR)FeedInfo->FeedTempDirectory) + 1) );
        if ( tempDir == NULL ) {
            goto alloc_error;
        }
        CopyUnicodeStringIntoAscii(tempDir, (LPWSTR)FeedInfo->FeedTempDirectory);
    }   else    {

        if( feedBlock->FeedTempDirectory ) {
            tempDir = (PCHAR)ALLOCATE_HEAP( lstrlen( feedBlock->FeedTempDirectory)+1 ) ;
            if( tempDir == NULL ) {
                goto    alloc_error ;
            }
            lstrcpy( tempDir, feedBlock->FeedTempDirectory ) ;
        }
    }

    // auth type could change from clear text to none - if so ignore account / password fields
    if( (FeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_NONE ||
        FeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_CLEAR) &&
        FeedInfo->AuthenticationSecurityType != Update->AuthenticationSecurity)
    {
        Update->AuthenticationSecurity = FeedInfo->AuthenticationSecurityType ;
        feedMask |= FEED_PARM_AUTHTYPE ;

        if( Update->AuthenticationSecurity == AUTH_PROTOCOL_NONE )
        {
            acctnamePresent = FALSE;
            pswdPresent = FALSE;
        }
    }

    if( acctnamePresent )   {

        feedMask |= FEED_PARM_ACCOUNTNAME ;

        tempAccount = (PCHAR)ALLOCATE_HEAP( 2 * (wcslen((LPWSTR)FeedInfo->NntpAccountName) + 1) );
        if ( tempAccount == NULL ) {
            goto alloc_error;
        }
        CopyUnicodeStringIntoAscii(tempAccount, (LPWSTR)FeedInfo->NntpAccountName);
    }   else    {

        if( feedBlock->NntpAccount && (Update->AuthenticationSecurity != AUTH_PROTOCOL_NONE) ) {
            tempAccount = (PCHAR)ALLOCATE_HEAP( lstrlen( feedBlock->NntpAccount )+1 ) ;
            if( tempAccount == NULL ) {
                goto    alloc_error ;
            }
            lstrcpy( tempAccount, feedBlock->NntpAccount ) ;
        }
    }

    if( pswdPresent)    {

        feedMask |= FEED_PARM_PASSWORD ;

        tempPassword = (PCHAR)ALLOCATE_HEAP( 2 * (wcslen((LPWSTR)FeedInfo->NntpPassword) + 1) );
        if ( tempPassword == NULL ) {
            goto alloc_error;
        }
        CopyUnicodeStringIntoAscii(tempPassword, (LPWSTR)FeedInfo->NntpPassword);
    }   else    {

        if( feedBlock->NntpPassword && (Update->AuthenticationSecurity != AUTH_PROTOCOL_NONE) ) {
            tempPassword = (PCHAR)ALLOCATE_HEAP( lstrlen( feedBlock->NntpPassword )+1 ) ;
            if( tempPassword == NULL ) {
                goto    alloc_error ;
            }
            lstrcpy( tempPassword, feedBlock->NntpPassword ) ;
        }
    }


    if( tempName != NULL )
        Update->ServerName = tempName ;

    if( tempNews != NULL )
        Update->Newsgroups = tempNews ;

    if( tempDist != NULL )
        Update->Distribution = tempDist ;

    if( tempUucp != NULL )
        Update->UucpName = tempUucp ;

    if( tempDir != NULL )
        Update->FeedTempDirectory = tempDir ;

    //if( tempAccount != NULL )
        Update->NntpAccount = tempAccount ;

    //if( tempPassword != NULL )
        Update->NntpPassword = tempPassword ;

    //
    // change the fixed part
    //

    if ( FeedInfo->StartTime.dwHighDateTime != FEED_STARTTIME_NOCHANGE ) {
        feedMask |= FEED_PARM_STARTTIME;
        Update->StartTime.QuadPart = liStart.QuadPart;
    }

    if ( FeedInfo->PullRequestTime.dwHighDateTime != FEED_PULLTIME_NOCHANGE ) {
        feedMask |= FEED_PARM_PULLREQUESTTIME;
        Update->PullRequestTime = FeedInfo->PullRequestTime;
    }

    if ( FeedInfo->FeedInterval != FEED_FEEDINTERVAL_NOCHANGE ) {
        feedMask |= FEED_PARM_FEEDINTERVAL;
        Update->FeedIntervalMinutes = FeedInfo->FeedInterval;
    }

    if ( FeedInfo->AutoCreate != FEED_AUTOCREATE_NOCHANGE ) {
        feedMask |= FEED_PARM_AUTOCREATE;
        Update->AutoCreate = FeedInfo->AutoCreate;
    }

    if ( newsPresent ) {
        feedMask |= FEED_PARM_AUTOCREATE;
        Update->AutoCreate = TRUE;
    }


    {
        feedMask |= FEED_PARM_ALLOW_CONTROL;
        Update->fAllowControlMessages = FeedInfo->fAllowControlMessages;
    }

    if( FeedInfo->MaxConnectAttempts != FEED_MAXCONNECTS_NOCHANGE ) {
        feedMask |= FEED_PARM_MAXCONNECT;
        Update->MaxConnectAttempts = FeedInfo->MaxConnectAttempts;
    }

    {
        feedMask |= FEED_PARM_OUTGOING_PORT;
        Update->OutgoingPort = FeedInfo->OutgoingPort;
    }

    {
        feedMask |= FEED_PARM_FEEDPAIR_ID;
        Update->FeedPairId = FeedInfo->FeedPairId;
    }

    {
        feedMask |= FEED_PARM_ENABLED;
        Update->fEnabled = FeedInfo->Enabled;
    }

    //
    // Write changes to the registry
    //
    // KangYan: This operation is cancelled for new feed admin, because admin
    //          did the metabase update part

    //(VOID)UpdateFeedMetabaseValues( pInstance, Update, feedMask );

    pList->ApplyUpdate( feedBlock, Update ) ;

    LogFeedAdminEvent(  NNTP_FEED_MODIFIED, feedBlock, pInstance->QueryInstanceId() ) ;

    pList->ExclusiveUnlock();

    pList->FinishWith( pInstance, feedBlock ) ;
    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return NERR_Success;

alloc_error:

    pList->ExclusiveUnlock() ;

    pList->FinishWith( pInstance, feedBlock ) ;
    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    if ( tempName != NULL ) {
        FREE_HEAP(tempName);
    }

    if ( tempDist != NULL ) {
        FREE_HEAP(tempDist);
    }

    if ( tempNews != NULL ) {
        FREE_HEAP(tempNews);
    }

    if( tempUucp != NULL ) {
        FREE_HEAP(tempUucp) ;
    }

    if( tempDir != NULL ) {
        FREE_HEAP( tempDir ) ;
    }

    if( tempAccount != NULL ) {
        FREE_HEAP( tempAccount ) ;
    }

    if( tempPassword != NULL ) {
    	SecureZeroMemory(tempPassword, strlen(tempPassword));
        FREE_HEAP( tempPassword ) ;
    }

    if( Update != NULL ) {
        FREE_HEAP( Update ) ;
    }

    if ( ParmErr != NULL ) {
        *ParmErr = parmErr;
    }

    return(err);

invalid_parm:

    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    if ( ParmErr != NULL ) {
        *ParmErr = parmErr;
    }
    return(ERROR_INVALID_PARAMETER);

} // SetFeedInformationToFeedBlock

//
// look at the internal result code from a posting and use it to increment
// the appropriate recieved article counter in the feed block.
//
void IncrementFeedCounter(PFEED_BLOCK pFeedBlock, DWORD nrc) {
	if (pFeedBlock == NULL) {
		_ASSERT(FALSE);
		return;
	}

	switch (nrc) {
		case 0:
		case nrcOK:
		case nrcSTransferredOK:
		case nrcArticleTransferredOK:
		case nrcArticlePostedOK:
		case nrcPostOK:
		case nrcXReplicOK:
		case nrcIHaveOK:
			InterlockedIncrement(&(pFeedBlock->cSuccessfulArticles));
			break;
		// 4xx
		case nrcSTryAgainLater:
		case nrcTransferFailedTryAgain:
			InterlockedIncrement(&(pFeedBlock->cTryAgainLaterArticles));
			break;
		// 4xx
		case nrcSNotAccepting:
		case nrcSAlreadyHaveIt:
		case nrcSArticleRejected:
		case nrcPostingNotAllowed:
		case nrcNoSuchGroup:
		case nrcNoGroupSelected:
		case nrcNoCurArticle:
		case nrcNoNextArticle:
		case nrcNoPrevArticle:
		case nrcNoArticleNumber:
		case nrcNoSuchArticle:
		case nrcNotWanted:
		// 6xx
		case nrcArticleTooManyFieldOccurances:
		case nrcArticleMissingField:
		case nrcArticleBadField:
		case nrcArticleIncompleteHeader:
		case nrcArticleMissingHeader:
		case nrcArticleFieldZeroValues:
		case nrcArticleFieldMessIdNeedsBrack:
		case nrcArticleFieldMissingValue:
		case nrcArticleFieldIllegalNewsgroup:
		case nrcArticleTooManyFields:
		case nrcArticleFieldMessIdTooLong:
		case nrcArticleDupMessID:
		case nrcPathLoop:
		case nrcArticleBadFieldFollowChar:
		case nrcArticleBadChar:
		case nrcDuplicateComponents:
		case nrcArticleFieldIllegalComponent:
		case nrcArticleBadMessageID:
		case nrcArticleFieldBadChar:
		case nrcArticleFieldDateIllegalValue:
		case nrcArticleFieldDate4DigitYear:
		case nrcArticleFieldAddressBad:
		case nrcArticleNoSuchGroups:
		case nrcArticleDateTooOld:
		case nrcArticleTooLarge:
    	case nrcIllegalControlMessage:
    	case nrcBadNewsgroupNameLen:
    	case nrcNewsgroupDescriptionTooLong:
    	case nrcControlMessagesNotAllowed:
		case nrcHeaderTooLarge:
		case nrcServerEventCancelledPost:
		case nrcMsgIDInHistory:
		case nrcMsgIDInArticle:
		case nrcNoAccess:
		case nrcPostModeratedFailed:
		case nrcSystemHeaderPresent:
			InterlockedIncrement(&(pFeedBlock->cSoftErrorArticles));
			break;
		// 4xx
		case nrcTransferFailedGiveUp:
		case nrcPostFailed:
		// 6xx
		case nrcMemAllocationFailed:
		case nrcErrorReadingReg:
		case nrcArticleMappingFailed:
		case nrcArticleAddLineBadEnding:
		case nrcArticleInitFailed:
		case nrcNewsgroupInsertFailed:
		case nrcNewsgroupAddRefToFailed:
		case nrcHashSetArtNumSetFailed:
		case nrcHashSetXrefFailed:
		case nrcOpenFile:
		case nrcArticleXoverTooBig:
		case nrcCreateNovEntryFailed:
		case nrcArticleXrefBadHub:
		case nrcHashSetFailed:
		case nrcArticleTableCantDel:
		case nrcArticleTableError:
		case nrcArticleTableDup:
		case nrcCantAddToQueue:
		case nrcSlaveGroupMissing:
		case nrcInconsistentMasterIds:
		case nrcInconsistentXref:
    	case nrcNotYetImplemented:
    	case nrcControlNewsgroupMissing:
    	case nrcCreateNewsgroupFailed:
    	case nrcGetGroupFailed:
		case nrcNotSet:
		case nrcNotRecognized:
		case nrcSyntaxError:
		case nrcServerFault:
			InterlockedIncrement(&(pFeedBlock->cHardErrorArticles));
			break;
		default:
			_ASSERT(FALSE);
			InterlockedIncrement(&(pFeedBlock->cHardErrorArticles));
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\expire.h ===
#ifndef	_EXPIRE_H_
#define	_EXPIRE_H_

//
//	Forwards
//
// class CNewsTree ;

//
//	Expire data structures - these consist of expire policies, expire heap
//	rmgroup queue etc. Each virtual server instance will contain a set of
//	these structures. The CExpire class will abstract all of this.
//

#define	EXPIRE_KEY_LENGTH	20
#define DEFAULT_EXPIRE_HORIZON (5*24)
#define INITIAL_NUM_GROUPS 10
#define DEFAULT_EXPIRE_SPACE 500

typedef	struct	_EXPIRE_BLOCK	{
public : 

	struct	_EXPIRE_BLOCK*	m_pNext ;
	struct	_EXPIRE_BLOCK*	m_pPrev ;

	long	m_references ;			// only delete when m_refences goes to 0 and marked !
	BOOL	m_fMarkedForDeletion ;	// set to TRUE when RPC delete request is made
	LPSTR*	m_Newsgroups ;			// 
	DWORD	m_ExpireSize ;			// Megabytes
	DWORD	m_ExpireHours ;
	DWORD	m_ExpireId ;			// for use with RPCs
	LPSTR	m_ExpirePolicy ;		// user-friendly names

}	EXPIRE_BLOCK, *LPEXPIRE_BLOCK ;

//
// simple multi-thread safe queue. enqueue/dequeue operations are synchronized
// TODO: smart ptr stuff
//
typedef struct _QueueElem
{
	struct _QueueElem *pNext;
	CGRPPTR pGroup;

} QueueElem;

class CQueue
{
private:

	DWORD               m_cNumElems;        // number of queue elements, 0 == empty
    CRITICAL_SECTION    m_csQueueLock;      // lock to synch access to the queue
	QueueElem           *m_pHead, *m_pTail;
    
    void LockQ(){ EnterCriticalSection(&m_csQueueLock);}
    void UnlockQ(){ LeaveCriticalSection(&m_csQueueLock);}

public:
	CQueue();
	~CQueue();
	BOOL  Dequeue( CGRPPTR *ppGroup );
	BOOL  Enqueue( CGRPPTR  pGroup );
	BOOL  Search( CGRPPTR *ppGroup, LPSTR lpGroupName );
    BOOL  IsEmpty(){ return m_cNumElems == 0;}
};

BOOL	FillExpireInfoBuffer(
					IN	PNNTP_SERVER_INSTANCE pInstance,
					IN	LPEXPIRE_BLOCK	expire,
					IN OUT LPSTR	*FixedPortion,
					IN OUT LPWSTR	*EndOfVariableData 
					) ;

//
//  <Iterator, filetime, multiszNewsgroups> tuple
//  Required to round-robin groups across expire policies into the thrdpool
//

typedef struct _IteratorNode 
{
    CGroupIterator* pIterator;
    FILETIME        ftExpireHorizon;
    PCHAR	        multiszNewsgroups;
} IteratorNode;

//
//	Class CExpire abstracts the expire operations for a virtual NNTP server.
//	There will be one instance of this class per virtual server instance.
//	The expire thread will loop through the list of virtual server instances,
//	and call expire methods using its CExpire object.
//

class CExpire
{
public:

	//
	//	Expire block policies
	//
	LPEXPIRE_BLOCK		m_ExpireHead ;
	LPEXPIRE_BLOCK		m_ExpireTail ;
	CRITICAL_SECTION	m_CritExpireList ;
    DWORD               m_cNumExpireBlocks;
	BOOL				m_FExpireRunning ;
	CHAR				m_szMDExpirePath [MAX_PATH+1];

	//
	//  Remove group processing
	//
	CQueue*				m_RmgroupQueue ;

	//
	//	Member functions
	//
	CExpire( LPCSTR lpMDExpirePath );
	~CExpire();

	BOOL	InitializeExpires( SHUTDOWN_HINT_PFN pfnHint, BOOL& fFatal, DWORD dwInstanceId ) ;
	BOOL	TerminateExpires( CShareLockNH* pLockInstance ) ;
	BOOL	ReadExpiresFromMetabase() ;
	LPEXPIRE_BLOCK	AllocateExpireBlock(
					IN	LPSTR	keyName	OPTIONAL,
					IN	DWORD	dwExpireSize,
					IN	DWORD	dwExpireHours,
					IN	PCHAR	Newsgroups,
					IN	DWORD	cbNewsgroups,
					IN  PCHAR	ExpirePolicy,
					IN	BOOL	IsUnicode ) ;

	void	CloseExpireBlock(	LPEXPIRE_BLOCK	expire ) ;

	DWORD	CalculateExpireBlockSize( LPEXPIRE_BLOCK	expire ) ;
	LPSTR	QueryMDExpirePath() { return m_szMDExpirePath; }

	BOOL	CreateExpireMetabase(	LPEXPIRE_BLOCK	expire ) ;
	BOOL	SaveExpireMetabaseValues(	MB* pMB, LPEXPIRE_BLOCK	expire ) ;

	LPEXPIRE_BLOCK	NextExpireBlock(	LPEXPIRE_BLOCK	lpExpireBlock, BOOL fIsLocked = FALSE ) ;
	void	MarkForDeletion( LPEXPIRE_BLOCK	lpExpireBlock ) ;
    void    LockBlockList();
    void    UnlockBlockList();

	BOOL	GetExpireBlockProperties(	
								IN	LPEXPIRE_BLOCK	lpExpireBlock, 
								IN	PCHAR&	Newsgroups,
								IN	DWORD&	cbNewsgroups,
								IN	DWORD&	dwHours,	
								IN	DWORD&	dwSize,
								IN	BOOL	fWantUnicode,
                                IN  BOOL&   fIsRoadKill ) ;

	void	SetExpireBlockProperties(	
								IN	LPEXPIRE_BLOCK	lpExpireBlock,
								IN	PCHAR	Newsgroups,
								IN	DWORD	cbNewsgroups,
								IN	DWORD	dwHours,
								IN	DWORD	dwSize,
								IN  PCHAR   ExpirePolicy,
								IN	BOOL	fUnicode ) ;

	void	InsertExpireBlock( LPEXPIRE_BLOCK ) ;
	void	RemoveExpireBlock( LPEXPIRE_BLOCK ) ;
	void	ReleaseExpireBlock(	LPEXPIRE_BLOCK	) ;

	LPEXPIRE_BLOCK	SearchExpireBlock(	DWORD	ExpireId ) ;
	void	ExpireArticlesBySize( CNewsTree* pTree );
	void	ExpireArticlesByTime( CNewsTree* pTree );

	BOOL	DeletePhysicalArticle( CNewsTree* pTree, GROUPID GroupId, ARTICLEID ArticleId, STOREID *pStoreId, HANDLE hToken, BOOL fAnonymous );

	BOOL	ExpireArticle(
					CNewsTree*	  pTree,	
					GROUPID       GroupId,
					ARTICLEID     ArticleId,
					STOREID       *pStoreId,
					class	      CNntpReturn & nntpReturn,
					HANDLE        hToken,
					BOOL          fMustDelete,
					BOOL          fAnonymous,
					BOOL          fFromCancel,
                    BOOL          fExtractNovDone = FALSE,
                    LPSTR         lpMessageId = NULL
					);

    BOOL    ProcessXixBuffer(
                    CNewsTree*  pTree,
                    BYTE*       lpb,
                    int         cb,
                    GROUPID     GroupId,
                    ARTICLEID   artidLow,
                    ARTICLEID   artidHigh,
                    DWORD&      dwXixSize
                    );

    BOOL    ExpireXix( 
                    CNewsTree*  pTree, 
                    GROUPID     GroupId, 
                    ARTICLEID   artidBase,
                    DWORD&      dwXixSize 
                    );

	//
	// Queue of rmgroups to be applied before expiry:
	// An RPC to remove a newsgroup or a rmgroup control message adds the newsgroup object
	// to a queue. The expiry thread actually applies these rmgroup commands before each
	// expiry cycle. 
	//
	BOOL	InitializeRmgroups();
	BOOL	TerminateRmgroups( CNewsTree* );
	void	ProcessRmgroupQueue( CNewsTree* );

	BOOL    MatchGroupEx(	LPMULTISZ	,	CGRPPTR  ) ;
	BOOL    MatchGroupExpire( CGRPPTR pGroup );
};

//
//  CThreadPool manages the creation/deletion of threads and the distribution
//  of work items to the thread pool. Derived classes need to implement the
//  virtual WorkCompletion() function which will be called to process a work item.
//
class CExpireThrdpool : public CThreadPool
{
public:
	CExpireThrdpool()  {}
	~CExpireThrdpool() {}

protected:
    //
    //  Routine that does the actual expire work. pvExpireContext is a newsgroup object.
    //
	virtual VOID WorkCompletion( PVOID pvExpireContext );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\iisnntp.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        iisnntp.cxx

   Abstract:

        This module defines the NNTP_IIS_SERVICE class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996

--*/

#include "tigris.hxx"
#include <aclapi.h>

extern DWORD
WINAPI
FeedScheduler(
        LPVOID Context
        );

extern BOOL fSuccessfullInitIDirectoryNotification;

VOID WINAPI
NotifyCert11Touched(
    VOID
    )
/*++

Routine Description:

    Notification function called when any Cert11 mapper modified in metabase

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    //
    // If someone has asked to be notified for SSL events, forward notification
    //

    if ( g_pSslKeysNotify )
    {
        (g_pSslKeysNotify)( SIMSSL_NOTIFY_MAPPER_CERT11_TOUCHED, NULL );
    }
}


BOOL
NNTP_IIS_SERVICE::AddInstanceInfo(
                     IN DWORD dwInstance,
                     IN BOOL fMigrateRoots
                     )
{
    PNNTP_SERVER_INSTANCE pInstance = NULL;
    DWORD   err = NO_ERROR;
    CHAR    szInstance [20];
	MB      mb( (IMDCOM*) QueryMDObject() );

	TraceFunctEnter("NNTP_IIS_SERVICE::AddInstanceInfo");

    DebugTrace(0, "AddInstanceInfo: instance %d reg %s\n", dwInstance, QueryRegParamKey() );

	//
	//  Validate instance parameters -
	//  If <nntpfile>, <nntproot> directories do not exist, create them
	//

	if( !ValidateNewInstance( dwInstance ) ) {
	    ErrorTrace(0, "Failed to validate new instance %d", dwInstance );
	    SetLastError( ERROR_FILE_NOT_FOUND );
	    goto err_exit;
    }

    //
    //	Create the new instance
	//	Use different ports per virtual server as defaults
	//	The IIS_SERVER_INSTANCE constructor will read the IP bindings
	//	from the metabase !
    //

    pInstance = XNEW NNTP_SERVER_INSTANCE(
                                this,
                                dwInstance,
                                IPPORT_NNTP, // +(USHORT)dwInstance-1,
                                QueryRegParamKey(),
                                NNTP_ANONYMOUS_SECRET_W,
                                NNTP_ROOT_SECRET_W,
                                fMigrateRoots
                                );

    if ( (pInstance == NULL) ||
		 (pInstance->QueryServerState() == MD_SERVER_STATE_INVALID) )
    {
        FatalTrace(0, "Cannot allocate new server instance or constructor failed");
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
		goto err_exit;
	}

#if 0				// Never force instance to be autostart
	if ( !pInstance->IsAutoStart() )
	{
	    //
	    //  instance is not auto-start - make it !
	    //
	
    	if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) )
    	{
			if(	!mb.SetDword( "", MD_SERVER_AUTOSTART, IIS_MD_UT_SERVER, 1) )
			{
				//
				//	failed to make server auto-start
				//
				ErrorTrace(0,"Failed to make server autostart\n");
			}
    	    mb.Close();
   	    }

	    if( dwInstance != 1 ) {
			DebugTrace(0,"Is not autostart\n");
			SetLastError( ERROR_SERVICE_DISABLED );
			LEAVE
			return FALSE ;
		}
	}
#endif

	//
	//	The helper function associates the instance with the service.
	//	Associating an instance with the service starts off the ATQ engine
	//	ie. the flood-gates are open for this instance. This also calls
	//	the StartInstance() method.
	//

    if( !AddInstanceInfoHelper( pInstance ) )
	{
		PCHAR args[1];
		_itoa( dwInstance, szInstance, 10 );
		args[0] = szInstance;
		NntpLogEventEx(NNTP_ADD_INSTANCE_FAILED,
			1,
			(const char **) args,
			GetLastError(),
			dwInstance);
		FatalTrace(0,"AddInstanceInfoHelper failed: Instance %d\n", dwInstance );
		SetLastError( ERROR_SERVICE_DISABLED );
		LEAVE
		return FALSE ;
	}

	LEAVE
	return TRUE ;

err_exit:

    //
    //  Set win32err code in metabase if create fails
    //

   	if( mb.Open( "/LM/Nntpsvc/", METADATA_PERMISSION_WRITE ) )
   	{
   	    _itoa( dwInstance, szInstance, 10 );
		if(	!mb.SetDword( szInstance, MD_WIN32_ERROR, IIS_MD_UT_SERVER, GetLastError(), METADATA_VOLATILE ) )
		{
			//
			//	failed to set win32 error code
			//
			ErrorTrace(0,"Failed to set win32 error code");
		}
   	    mb.Close();
    }

    LEAVE
    return FALSE;

} // NNTP_IIS_SERVICE::AddInstanceInfo

DWORD
NNTP_IIS_SERVICE::DisconnectUsersByInstance(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Virtual callback invoked by IIS_SERVER_INSTANCE::StopInstance() to
    disconnect all users associated with the given instance.

    Arguments:

        pInstance - All users associated with this instance will be
            forcibly disconnected.

--*/
{
	PNNTP_SERVER_INSTANCE pNntpInstance = (PNNTP_SERVER_INSTANCE)pInstance;
	CSocketList* pInUseList = pNntpInstance->m_pInUseList;

	TraceFunctEnter("NNTP_IIS_SERVICE::DisconnectUsersByInstance");

	//
	// wait for all pickup operations to complete
	//
	pNntpInstance->WaitForPickupThreads();

	//
	//	Call the session shutdown enumerator on the session socket list
	//	This is called by StopInstance() and CloseInstance().	
	//
	if( pInUseList ) {

		DWORD  cSessions = pInUseList->GetListCount() ;

		//
		// enumerate all users to call their Disconnect method
		//
		pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
		//
		// Tell crawler threads to abbreviate their work.
		//	NOTE : Do this after we make a first try of dropping all of our sessions,
		//	because we want any Newnews commands which are in progress to just drop with no
		//	further bytes sent.  The complication is that a thread can spin looking for
		//	message-id's even though we've dropped the socket, and the CNewnewsCmd::PartialExecute
		//	function will need to provide some bytes in case of early termination.
		//	So, when we bail out of newnews commands early, we have to provide some
		//	bytes, so we will send the terminating ".\r\n" from the newnews command.
		//	However, clients probably won't get these because the socket will already
		//	be dead due to the EnumSessionShutdown().  This is the behaviour we want !
		//
		if( pNntpInstance->GetTree() ) {
			pNntpInstance->GetTree()->StopTree() ;
		}

        //
        //  This lock is grabbed shared by the feed & expire thread when
        //  either one processes an instance. We need to grab this exclusive
        //  so we can cleanup any outbound sockets initiated by the feed thread.
        //  Since the instance state is now MD_SERVER_STATE_STOPPING, the feed
        //  thread will skip this instance when we release the exclusive lock.
        //  NOTE: Since we called StopTree(), the expire thread will eventually
        //  release its read lock.
        //
        CShareLockNH* pLockInstance = pNntpInstance->GetInstanceLock();
	    pLockInstance->ExclusiveLock();
        pNntpInstance->m_FeedManagerRunning = FALSE;
	    pLockInstance->ExclusiveUnlock();

		//
		//  Use j just to figure out when to do StopHint()'s
		//
		DWORD   j = 0 ;

		if( cSessions ) {
			Sleep( 1000 );
			StopHintFunction() ;
		}

		cSessions = pInUseList->GetListCount() ;
        if( cSessions ) {
            //  This should catch any sessions that snuck in past the
            //  call to EnumAllSess() before we locked out the feed thread..
		    pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
        }

		for( int i=0; cSessions && i<120; i++, j++ )
		{
			Sleep( 1000 );
			DebugTrace( (LPARAM)this, "Shutdown sleep %d seconds. Count: %d", i,
						pInUseList->GetListCount() );

			if( (j%10) == 0 ) {
				StopHintFunction() ;
			}

			//
			//  If we make progress, then reset i.  This will mean that the server
			//  wont stop until 2 minutes after we stop making progress.
			//
			DWORD   cSessionsNew = pInUseList->GetListCount() ;
			if( cSessions != cSessionsNew ) {
				i = 0 ;
            } else {
                // We are not making progress - might as well have a shot at
                // shutting down these sessions...
                pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
            }

			cSessions = cSessionsNew ;
		}

		if ( pInUseList->GetListCount() )
		{
			pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
		}

		_ASSERT( i<1200 );
	}

    return NO_ERROR;

}   // NNTP_IIS_SERVICE::DisconnectUsersByInstance

NNTP_IIS_SERVICE::NNTP_IIS_SERVICE(
        IN  LPCSTR                           pszServiceName,
        IN  LPCSTR                           pszModuleName,
        IN  LPCSTR                           pszRegParamKey,
        IN  DWORD                            dwServiceId,
        IN  ULONGLONG                        SvcLocId,
        IN  BOOL                             MultipleInstanceSupport,
        IN  DWORD                            cbAcceptExRecvBuffer,
        IN  ATQ_CONNECT_CALLBACK             pfnConnect,
        IN  ATQ_COMPLETION                   pfnConnectEx,
        IN  ATQ_COMPLETION                   pfnIoCompletion
        ) : IIS_SERVICE( pszServiceName,
                         pszModuleName,
                         pszRegParamKey,
                         dwServiceId,
                         SvcLocId,
                         MultipleInstanceSupport,
                         cbAcceptExRecvBuffer,
                         pfnConnect,
                         pfnConnectEx,
                         pfnIoCompletion
                         ),
			m_cStartHints( 2 ),     // Gibraltar sets the hint to 1 before they call us !?!
			m_cStopHints( 2 ),
			m_SockRecvBufSize( BUFSIZEDONTSET ),
			m_SockSendBufSize( BUFSIZEDONTSET ),
			m_fNonBlocking( TRUE ),
			m_FeedSchedulerSleepTime( 60 ),
			m_pRebuildThread( NULL ),
            m_pExpireThrdpool( NULL ),
			m_hFeedEvent( NULL ),
			m_hFeedThread( NULL ) 
{
    //
    //	Init global version strings
    //
    InitializeServerStrings();

	//
	//	This context is passed to simssl for use in retrieving mapper objects
	//
	m_smcMapContext.ServerSupportFunction = ServerMapperCallback;

#if 0
    //
    // Set the notification function in NSEP for mapping ( NSEPM )
    //

    if ( QueryMDNseObject() != NULL ) {

        MB mbx( (IMDCOM*)QueryMDNseObject() );

        if ( mbx.Open( "", METADATA_PERMISSION_WRITE ) ) {

            mbx.SetDword(
                      "",
                      MD_NOTIFY_CERT11_TOUCHED,
                      IIS_MD_UT_SERVER,
                      (DWORD)::NotifyCert11Touched
                    );

            mbx.Close();
        }
    }
#endif	

} // NNTP_IIS_SERVICE::NNTP_IIS_SERVICE

NNTP_IIS_SERVICE::~NNTP_IIS_SERVICE()
{

#if 0
    //
    // Reset the notification function in NSEP for mapping ( NSEPM )
    //

    if ( QueryMDNseObject() != NULL ) {

        MB mbx( (IMDCOM*)QueryMDNseObject() );

        if ( mbx.Open( "", METADATA_PERMISSION_WRITE ) )
        {
            mbx.SetDword("",
                         MD_NOTIFY_CERT11_TOUCHED,
                         IIS_MD_UT_SERVER,
                         (DWORD)NULL
                         );

            mbx.Close();
        }
    }
#endif
}

VOID
NNTP_IIS_SERVICE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this service

  Arguments:

    hMDHandle - Metabase handle generating the change notification
    pcoChangeList - path and id that has changed

--*/
{
    DWORD   i;
    BOOL    fSslModified = FALSE;

    AcquireServiceLock();

    IIS_SERVICE::MDChangeNotify( pcoChangeList );

    for ( i = 0; i < pcoChangeList->dwMDNumDataIDs; i++ )
    {
        switch ( pcoChangeList->pdwMDDataIDs[i] )
        {
        case 0:     // place holder
            break;

        case MD_SSL_PUBLIC_KEY:
        case MD_SSL_PRIVATE_KEY:
        case MD_SSL_KEY_PASSWORD:
            fSslModified = TRUE;
            break;

        default:
            break;
        }
    }

    if ( !fSslModified && g_pSslKeysNotify )
    {
        if ( strlen( (LPSTR)pcoChangeList->pszMDPath ) >= sizeof("/LM/NNTPSVC/SSLKeys" )-1 &&
             !_memicmp( pcoChangeList->pszMDPath,
                        "/LM/NNTPSVC/SSLKeys",
                        sizeof("/LM/NNTPSVC/SSLKeys" )-1 ) )
        {
            fSslModified = TRUE;
        }
    }

    if ( fSslModified && g_pSslKeysNotify )
    {
        (g_pSslKeysNotify)( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED, this );
    }

    ReleaseServiceLock();
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::InitializeServerThreads
//
//  Synopsis:   Kick off server wide threads
//
//  Arguments:
//
//  Returns:    FALSE on failure - this is a fatal error !
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_IIS_SERVICE::InitiateServerThreads()
{
	TraceFunctEnter("NNTP_IIS_SERVICE::InitializeServerThreads");

    //
    //  Initialize the thrdpool class - used by nntpbld and expire
    //

	if( !CWorkerThread::InitClass( 1 ) ) {
		ErrorTrace(0,"Failed to init thrdpool class - error %d", GetLastError());
		return FALSE ;
	}

	//
	//	create the expire thread - this will expire articles in all
	//  server instances that are in the MD_SERVER_STARTED state !
	//
	CNewsTree::m_hTermEvent = CreateEvent( 0, TRUE, FALSE, 0 ) ;
	if ( CNewsTree::m_hTermEvent == 0 )
	{
		ErrorTrace( (DWORD_PTR)this, "CreateEvent Failed %d", GetLastError() ) ;
		return FALSE ;
	}
	else
	{
		DWORD	tid ;
		CNewsTree::m_hCrawlerThread = CreateThread( 0, 0, CNewsTree::NewsTreeCrawler, 0, 0, &tid ) ;
		if ( CNewsTree::m_hCrawlerThread == 0 )
		{
			ErrorTrace( (DWORD_PTR)this, "CreateThread Failed %d", GetLastError() ) ;
			return FALSE ;
		}
	}		

    //
    //  create the expire thread pool
    //

    if( (m_pExpireThrdpool = XNEW CExpireThrdpool) == NULL ) {
        ErrorTrace( (DWORD_PTR)this,"Failed to create an expire thrdpool object");
        return FALSE ;
    } else {
        if( !m_pExpireThrdpool->Initialize( dwNumExpireThreads, dwNumExpireThreads*2, dwNumExpireThreads ) ) {
            ErrorTrace( (DWORD_PTR)this,"Failed to initialize expire thrdpool");
            return FALSE ;
        }
    }

	//
	//	create the feed scheduler thread - this will initiate outgoing
	//	feeds on all server instances !
	//

	// Create Termination event
	m_hFeedEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
	if ( m_hFeedEvent == NULL ) {
		ErrorTrace(0,"Error %d on CreateEvent\n",GetLastError());
		return FALSE ;
	}

	m_hFeedThread = NULL ;

	//
	// Start threads
	//

    DWORD threadId;
	m_hFeedThread = CreateThread(
						NULL,               // attributes
						0,                  // stack size
						FeedScheduler,      // thread start
						NULL,
						0,
						&threadId
						);

	if ( m_hFeedThread == NULL ) {
		ErrorTrace(0,"Error %d on CreateThread\n",GetLastError());
		return FALSE ;
	}

	TraceFunctLeave();
	return TRUE ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::TerminateServerThreads
//
//  Synopsis:   Shutdown server wide threads
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_IIS_SERVICE::TerminateServerThreads()
{
	TraceFunctEnter("NNTP_IIS_SERVICE::TerminateServerThreads");

	//
	//	Before shutting down, we need to signal server threads to stop
	//	any work they are doing. We do this by setting the m_bStoppingTree
	//	member of each instance's newstree to TRUE. This is checked in
	//	all big loops in the server.
	//

	//	Get the min and max instance ids
	DWORD dwMinInstanceId = 0;
	DWORD dwMaxInstanceId = 0;
	CNewsTree* pTree = NULL ;
	PNNTP_SERVER_INSTANCE pInstance = NULL;

	StopHintFunction();

	if( FindIISInstanceRange( this, &dwMinInstanceId, &dwMaxInstanceId ) )
	{
		//
		//	Iterate over all instances
		//
		for( DWORD dwCurrInstance = dwMinInstanceId;
				dwCurrInstance <= dwMaxInstanceId; dwCurrInstance++)
		{
			pInstance = ::FindIISInstance( this, dwCurrInstance, FALSE );
			if( pInstance == NULL ) {
				ErrorTrace(0,"Expire thread: FindIISInstance returned NULL: instance %d", dwCurrInstance);
				continue;
			}

			//	Stop the newstree
			pTree = pInstance->GetTree() ;
			if( pTree ) {
				pTree->StopTree();
			}

			//	Release the ref added by FindIISInstance()
			pInstance->Dereference();
		}
	} else {
		ErrorTrace(0, "FindIISInstanceRange failed" );
	}

	StopHintFunction();

	//
	// shutdown directory notification retry queue thread
	//
	if( fSuccessfullInitIDirectoryNotification ) {
		IDirectoryNotification::GlobalShutdown();
		fSuccessfullInitIDirectoryNotification = FALSE;
	}

	//
	//	Shutdown the expire thread
	//
	if ( CNewsTree::m_hTermEvent != 0 )
		SetEvent( CNewsTree::m_hTermEvent );

	if ( CNewsTree::m_hCrawlerThread != 0 ) {
		WaitForSingleObject( CNewsTree::m_hCrawlerThread, INFINITE );
	}

	StopHintFunction();

	if ( CNewsTree::m_hTermEvent != 0 )
	{
		_VERIFY( CloseHandle( CNewsTree::m_hTermEvent ) );
		CNewsTree::m_hTermEvent = 0;
	}

	if ( CNewsTree::m_hCrawlerThread != 0 )
	{
		_VERIFY( CloseHandle( CNewsTree::m_hCrawlerThread ) );
		CNewsTree::m_hCrawlerThread = 0;
	}

	StopHintFunction();

    //
    //  Shutdown the expire thrdpool
    //  Since the expire thread is gone, we should have no work items
    //  pending on this pool.
    //

    if( m_pExpireThrdpool ) {
        _VERIFY( m_pExpireThrdpool->Terminate() );
        XDELETE m_pExpireThrdpool;
        m_pExpireThrdpool = NULL;
    }

	//
	//	Shutdown the feed scheduler thread
	//

	if ( m_hFeedThread != NULL ) {

		_ASSERT( m_hFeedEvent != NULL );
		SetEvent(m_hFeedEvent);

		DebugTrace(0,"Waiting for thread to terminate\n");
		(VOID)WaitForSingleObject( m_hFeedThread, INFINITE );
		_VERIFY( CloseHandle( m_hFeedThread ) );
		m_hFeedThread = NULL;
	}

	//
	// Close event handle
	//

	if ( m_hFeedEvent != NULL ) {

		_VERIFY( CloseHandle( m_hFeedEvent ) );
		m_hFeedEvent = NULL;
	}

	StopHintFunction();

	//
	//	Shutdown the rebuild thread if required !
	//

	if( m_pRebuildThread ) {
		// base class destructor will shutdown and cleanup rebuild thread
		XDELETE m_pRebuildThread ;
		m_pRebuildThread = NULL ;
	}

	//
	//	Call base class TermClass
	//
	_VERIFY( CWorkerThread::TermClass() );

	TraceFunctLeave();
	return TRUE ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::ValidateNewInstance
//
//  Synopsis:   Check for existence of new instance directories
//
//  Arguments:  DWORD dwInstance
//
//  Returns:    TRUE on success and FALSE on failure
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_IIS_SERVICE::ValidateNewInstance(DWORD dwInstance)
{
	TraceFunctEnter("NNTP_IIS_SERVICE::ValidateNewInstance");
	MB      mb( (IMDCOM*) QueryMDObject() );
	BOOL    fRet = TRUE ;
	CHAR	szFile [1024];
	CHAR	szDropDirectory [1024];
    char*   pchSlash = NULL;
	HRESULT hr;

    DWORD dwRes, dwDisposition;
    PSID pLocalSystemSID = NULL, pAdminSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS ea[2];
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;
    LONG lRes;
	DWORD dwSize = 1024 ;

    wsprintf( szFile, "/LM/nntpsvc/%d/", dwInstance );
    if( !mb.Open( szFile, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {
        FatalTrace(0,"Failed to open mb path %s", szFile );
        return FALSE ;
    }

    // Create a security descriptor for the files

		if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
			SECURITY_LOCAL_SYSTEM_RID,
			0, 0, 0, 0, 0, 0, 0,
			&pLocalSystemSID) )
		{
			fRet = FALSE;
			goto Exit;
		}
		if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
			SECURITY_BUILTIN_DOMAIN_RID,
			DOMAIN_ALIAS_RID_ADMINS,
			0, 0, 0, 0, 0, 0,
			&pAdminSID) )
		{
			fRet = FALSE;
			goto Exit;
		}

    // Initialize an EXPLICIT_ACCESS structure for an ACE.

    ZeroMemory(&ea, 2*sizeof(EXPLICIT_ACCESS));
		ea[0].grfAccessPermissions = GENERIC_ALL;
		ea[0].grfAccessMode = SET_ACCESS;
		ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
		ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
		ea[0].Trustee.ptstrName  = (LPTSTR) pLocalSystemSID;

		ea[1].grfAccessPermissions = GENERIC_ALL;
		ea[1].grfAccessMode = SET_ACCESS;
		ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
		ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
		ea[1].Trustee.ptstrName  = (LPTSTR) pAdminSID;

    // Create a new ACL that contains the new ACEs.

    dwRes = SetEntriesInAcl(2, ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes) 
    {
        fRet = FALSE;
        goto Exit;
    }

    // Initialize a security descriptor.  
 
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                         SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL) 
    {
        fRet = FALSE;
        goto Exit; 
    }
 
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) 
    {
        fRet = FALSE;
        goto Exit; 
    }
 
    // Add the ACL to the security descriptor. 
 
    if (!SetSecurityDescriptorDacl(pSD, 
        TRUE,     // fDaclPresent flag   
        pACL, 
        FALSE))   // not a default DACL 
    {
        fRet = FALSE;
        goto Exit; 
    }

    // Initialize a security attributes structure.

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = FALSE;

	if( !mb.GetString(	"",
						MD_ARTICLE_TABLE_FILE,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		//
		//	Path to article table file does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to article table file missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}

    //  Truncate file name from path
    pchSlash = strrchr( szFile, '\\' );
    if( !pchSlash ) {
		fRet = FALSE ;
		goto Exit;
    } else {
        *pchSlash = '\0';
    }

	//
	//  Now we have the path to the article hash table - check for existence !
	//  if dir does not exist - create it
	//

    if( !CreateDirectory( szFile, &sa ) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS && GetLastError() != ERROR_BUSY) {

            //
            // Be careful when a drive letter is given
            //
            if ( *szFile && *(szFile+strlen(szFile)-1) == ':' ) {

                //
                // Check for accessibility
                //
                HANDLE hTemp = CreateFile(	szFile,
		    					GENERIC_READ | GENERIC_WRITE,
			    				FILE_SHARE_READ | FILE_SHARE_WRITE,
				    			&sa,
					    		OPEN_ALWAYS,
						    	FILE_FLAG_BACKUP_SEMANTICS,
							    INVALID_HANDLE_VALUE
        						) ;
                if ( INVALID_HANDLE_VALUE == hTemp ) {
                    FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szFile);
		            fRet = FALSE ;
	    	        goto Exit;
	    	    }

	    	    _VERIFY( CloseHandle( hTemp ) );
	    	} else {
	    	    FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szFile);
		        fRet = FALSE ;
	    	    goto Exit;
            }
        }
    }
    
	dwSize = 1024 ;
	if( !mb.GetString(	"/Root",
						MD_VR_PATH,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		//
		//	Path to nntproot does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to nntproot missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}


    //
    //  Create pickup, failedpickup and drop dirs
    //

	dwSize = 1024 ;
	if( !mb.GetString(	"",
						MD_PICKUP_DIRECTORY,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		//
		//	Path to pickup dir does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to pickup dir missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}

    if( !CreateDirectory( szFile, &sa ) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS && GetLastError() != ERROR_BUSY) {
            FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szFile);
    		fRet = FALSE ;
	    	goto Exit;
        }
    }
	
	dwSize = 1024 ;
	if( !mb.GetString(	"",
						MD_FAILED_PICKUP_DIRECTORY,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		//
		//	Path to pickup dir does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to failed pickup dir missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}

    if( !CreateDirectory( szFile, &sa ) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS && GetLastError() != ERROR_BUSY) {
            FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szFile);
    		fRet = FALSE ;
	    	goto Exit;
        }
    }

	dwSize = 1024 ;
	if( !mb.GetString(	"",
						MD_DROP_DIRECTORY,
						IIS_MD_UT_SERVER,
						szDropDirectory,
						&dwSize  ) )
	{
		//
		//	Path to pickup dir does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to drop dir missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}

    if( !CreateDirectory( szDropDirectory, &sa ) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS && GetLastError() != ERROR_BUSY) {
            FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szDropDirectory);
    		fRet = FALSE ;
	    	goto Exit;
        }
    }

    //
    //	Create ADSI keys for nntp objects
    //

    if( !mb.SetString( 	"/Feeds",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_FEEDS,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for feeds: error is %d", GetLastError());
	}
    					
    if( !mb.SetString( 	"/Expires",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_EXPIRES,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for expires: error is %d", GetLastError());
	}

    if( !mb.SetString( 	"/Groups",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_GROUPS,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for groups: error is %d", GetLastError());
	}

    if( !mb.SetString( 	"/Sessions",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_SESSIONS,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for sessions: error is %d", GetLastError());
	}

    if( !mb.SetString( 	"/Rebuild",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_REBUILD,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for rebuild: error is %d", GetLastError());
	}

Exit:
    if (pAdminSID) 
            FreeSid(pAdminSID);
    if (pLocalSystemSID)
            FreeSid(pLocalSystemSID);    	
    if (pACL) 
        LocalFree(pACL);
    if (pSD) 
        LocalFree(pSD);

    if( !fRet ) {
        ErrorTrace(0,"GetLastError is : %d", GetLastError());
    }
	mb.Close();

	if (fRet) {
		//
		// do the server events registration
		//
		hr = RegisterSEOInstance(dwInstance, szDropDirectory);
		if (FAILED(hr)) {
	   	    ErrorTrace(0,"Instance %d: RegisterServerEvents returned %x",
				dwInstance, hr);
			_ASSERT(FALSE);
			NntpLogEventEx(SEO_REGISTER_INSTANCE_FAILED,
						   0,
						   (const char **) NULL,
						   hr,
						   dwInstance);
		}
	}


	TraceFunctLeave();
    return fRet ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::InitializeServerStrings
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_IIS_SERVICE::InitializeServerStrings( VOID )
{
	CHAR szServerPath [MAX_PATH+1];

    CopyMemory( szServerPath, "c:\\", sizeof( "c:\\" ) ) ;
    HMODULE hModule = GetModuleHandle( NNTP_MODULE_NAME ) ;
    if( hModule != 0 ) {
        //GetModuleFileName truncates string without placing a null terminator at the end.
        szServerPath[ sizeof(szServerPath) -1 ] = '\0';
        if( !GetModuleFileName( hModule, szServerPath, sizeof( szServerPath ) -1 ) )   {
            CopyMemory( szServerPath, "c:\\", sizeof( "c:\\" ) ) ;
        }   else    {
            SetVersionStrings(  szServerPath, szTitle, szVersionString, 128 );
        }
    }

	return TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::ServerMapperCallback
//
//  Synopsis:   Callback to return mapper object for an instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL WINAPI NNTP_IIS_SERVICE::ServerMapperCallback(
	PVOID pInstance,
	PVOID pData,
	DWORD dwPropId )
{
	PNNTP_SERVER_INSTANCE pNntpInst = (PNNTP_SERVER_INSTANCE)pInstance;

	TraceFunctEnter("NNTP_IIS_SERVICE::ServerMapperCallback");

	switch( dwPropId )
	{
		case SIMSSL_PROPERTY_MTCERT11:
			if( pNntpInst ) {
				*(LPVOID*) pData = pNntpInst->QueryMapper( MT_CERT11 );
			}
			break;
				
		case SIMSSL_PROPERTY_MTCERTW:
			if( pNntpInst ) {
				*(LPVOID*) pData = pNntpInst->QueryMapper( MT_CERTW );
			}
			break;

        case SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED:
        case SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED:
            return SetFlushMapperNotify( dwPropId, (PFN_SF_NOTIFY)pData );

        case SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED:
            return SetSllKeysNotify( (PFN_SF_NOTIFY)pData );
			
		default:
			ErrorTrace(0,"Invalid property id - no such mapper");
			SetLastError( ERROR_INVALID_PARAMETER );
			return FALSE ;
	}

	return TRUE;
	
	SetLastError( ERROR_INVALID_PARAMETER );
	return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\io.cpp ===
/*++

	io.cpp

	This file contains all the code which manages completion of IO operations.

	There is one class hierarchy which has several branches for all of the below objects :


				CChannel
					
					(This is an abstract base classes -
					A user can issue Read, Writes and Transmits against a
					CChannel and have a specified function called when they complete.

               /                 \                 \
              /                   \                  \
             /                     \                   \

		CHandleChannel		      CIODriver            CIOFileChannel

			Issues reads 		   Can Issue Reads&Writes      Issues Reads and Writes against Files
			and writes against	   Also insures single
			Handles				   thread completion



	The CHandleChannel class has two child classes, CFileChannel for File handles and CSocketChannel
	for sockets.  All of the CHandleChannel derived classes support Read() and Write() APIs for issueing
	async IO's.   CSocketChannel additionally supports Transmit() for issuing Transmit operations.
	Read(), WRite() and Transmit() will all take a CPacket derived class which contains all of the
	parameters of the IO, (ie, buffers, length of data, etc....)

	The CIODriver class als has two child classes.  The main function of CIODriver and child classes
	is to process completed IO requests.  Since all IO operations are represented by CPacket derived
	objects, CIODriver mostly manipulates queues of CPacket objects.
	The CIODriver class will place each completed packet on a queue, and call a completion function for
	that packet.  The CIODriver maintains a pointer to a 'Current CIO' object (object derived from CIO)
	which reflects the current high level IO we are doing (ie. CIOReadArticle - copy an article from
	a socket to a file).  The interface between CIODriver and CIO objects allows the CIO object
	to 'block' and 'unblock' the driver, complete only portions of buffers etc...
	(ie.  When a client connects and sends multiple commands, CIOReadLine will 'block' the CIODriver
	queue after it has parsed one line of text (one command) by setting the CIODriver's current CIO
	pointer to NULL.  This allows whoever is parsing commands to operate irregardless of how many
	commands are sent in one packet.)
	There are two forms of CIODriver's - CIODriverSource and CIODriverSink.
	CIODriverSource's support all of the REad(), Write(), etc... API's that a CChannel does.
	Essentially, a CIODriverSource can be used to massage each packet before it reaches a really
	socket handle. (We use it to do encryption.)
	CIODriverSink objects do not support Read(), Write() etc... and can only be used as a Sink for data.

	Finally CIOFileChannel is similar to CFileChannel (which is derived from CHandleChannel) except
	that it supports both Read()s and Write()s simultaneously.

	CIODriver's are always used in conjunction with another CChannel derived object.
	Generally, a CIODriver is used with either a CSocketChannel or CIOFileChannel.  The CIODriver
	will contain a pointer to its paired CChannel.  All calls to IssuePacket() etc... will eventually
	map to a call to the other CChannel's Read(), Write(), Transmit() interface.
	The other CChannel will be set up to call the owning CIODriver's completion function when
	packets complete.
	When doing encryption, there will be 2 CIODriver's and one CChannel associated -
	There will be a CSocketChannel over which packets are sent, a CIODriverSource which will
	massage the data in the packets and a CIODriverSink which will operate the regular NNTP state
	machines.
	This means that all CIO and CSessionState derived classes can largely ignore encryption issues,
	as the date will be transparently encrypted/decrypted for them.

	Internally, CIODriver's use CStream objects to manage the completion of packets.
	A large portion of the CIODriver interface is inline functions which route to the proper CStream.
	(A CStream exists for each direction of data flow - ie. outgoing (CWritePacket & CTransmitPacket)
	and incoming (CReadPacket))

--*/

#include    "tigris.hxx"

#ifdef  CIO_DEBUG
#include    <stdlib.h>      // For Rand() function
#endif


extern	class	TSVC_INFO*	g_pTsvcInfo ;

//
//	All CChannel derived objects have the following sting stamped in them for debug purposes ....
//
//

#ifdef	CIO_DEBUG
//
//	These variables are never used.
//	They're only declared so that people using decent debuggers can more easily
//	examine arbitrary objects !
//
class	CIODriverSink*		pSinkDebug = 0 ;
class	CIODriverSource*	pSourceDebug = 0 ;
class	CChannel*			pChannelDebug = 0 ;
class	CReadPacket*		pReadDebug = 0 ;
class	CWritePacket*		pWriteDebug = 0 ;
class	CHandleChannel*		pHandleDebug = 0 ;
class	CSocketChannel*		pSocketDebug = 0 ;
class	CFileChannel*		pFileDebug = 0 ;
class	CIOFileChannel*		pIOFileDebug = 0 ;
class	CIO*				pIODebug = 0 ;
class	CIOReadLine*		pReadLineDebug = 0 ;
class	CIOReadArticle*		pReadArticleDebug = 0 ;
class	CIOWriteLine*		pWriteLineDebug = 0 ;
class	CSessionState*		pStateDebug = 0 ;
#endif

const	unsigned	cbMAX_CHANNEL_SIZE	= MAX_CHANNEL_SIZE ;

CPool	CChannel::gChannelPool(CHANNEL_SIGNATURE) ;


BOOL
CChannel::InitClass() {
/*++

Routine Description :

	Initialize the CChannel class - handles all initialization issues for CChannel
	and all derived classes.
	The only thing to do is ReserveMemory in our CPool

Arguments :

	None.

Return Value :

	True if Succesfull, FALSE Otherwise

--*/

#ifdef	CIO_DEBUG
	srand( 10 ) ;
#endif

	return	gChannelPool.ReserveMemory(	MAX_CHANNELS, cbMAX_CHANNEL_SIZE ) ;
}

BOOL
CChannel::TermClass() {
/*++

Routine Description :

	The twin of CChannel::TermClass() - call when all sessions are Dead !

Arguments :

	None.

Return Value :

	True if Succesfull, FALSE Otherwise

--*/

	_ASSERT( gChannelPool.GetAllocCount() == 0 ) ;
	return	gChannelPool.ReleaseMemory() ;
}


//
//
//	The following functions should be overridden by classes derived from CChannel
//
//

BOOL
CChannel::FSupportConnections( ) {
	ChannelValidate() ;

    return  TRUE ;
}

BOOL
CChannel::FRequiresBuffers()    {
	ChannelValidate() ;

    return  TRUE ;
}

BOOL
CChannel::FReadChannel()    {
	ChannelValidate() ;

    return  TRUE ;
}

void
CChannel::GetPaddingValues( unsigned    &cbFront,
							unsigned    &cbTail )   {
	ChannelValidate() ;

    cbFront = 0 ;
    cbTail = 0 ;
}

void
CChannel::CloseSource(	
				CSessionSocket*	pSocket
				) {

	ChannelValidate() ;
	
	_ASSERT(1==0 ) ;
}

void
CChannel::Timeout()	{
}

void
CChannel::ResumeTimeouts()	{
}

#ifdef	CIO_DEBUG
void	CChannel::SetDebug( DWORD	dw ) {
}
#endif

CChannel::~CChannel()   {

	TraceFunctEnter( "CChannel::~CChannel" ) ;
	DebugTrace( (DWORD_PTR)this, "Destroying CChannel" ) ;

	ChannelValidate() ;
}

#define	OwnerValidate()
#define	DriverValidate( driver )


//
//	shutdownState is a special object we use when terminating CIODriver objects.
//	It exists to swallow any outstanding IO's that may be lying around when
//	a CIODriver is destroyed.
//
//

CIOShutdown	CIODriver::shutdownState ;

CStream::CStream(    unsigned    index   ) :
/*++

Routine Description :

	Construct a CStream object.
	Set everything up to a NULL state.

Arguments :

	An index - usually these things are declared as arrays within a CIODriver
	the index is our position in this array.

Return Value :
	
	None.

--*/


	//
	//	Initialize a CStream object.
	//	Two CStream objects exist in each CIODriver object,
	//	one for each direction (outgoing packets - CWritePacket, CTransmitPacket,
	//	and incomint packets CReadPacket )
	//
    m_pSourceChannel( 0 ),			// The CChannel object
	/* m_pIOCurrent( 0 ), */
	m_index( index ),
    m_age( GetTickCount() ),
	m_fRead( FALSE ),
    m_cbFrontReserve( UINT_MAX ),
	m_cbTailReserve( UINT_MAX ),
	m_pOwner( 0 ),
	m_pSpecialPacket( 0 ),
	m_pSpecialPacketInUse( 0 ),
	m_fCreateReadBuffers( TRUE ),
	m_pUnsafePacket( 0 ),
	m_pUnsafeInuse( 0 ),
	m_cShutdowns( 0 ),
	m_fTerminating( FALSE )
#ifdef  CIO_DEBUG
		//
		//	The following are all used in debug asserts - generally to insure
		//	that onlly the expected number of threads are simultaneously executing
		//
        ,m_dwThreadOwner( 0 ),
		m_cThreads( 0 ),
		m_cSequenceThreads( 0 ),
		m_cThreadsSpecial( 0 ),
        m_cNumberSends( 0 )
#endif
{
		TraceFunctEnter( "CStream::CStream" ) ;

		ASSIGNI( m_sequencenoOut, UINT_MAX );
		ASSIGNI( m_iStreamIn, UINT_MAX );
		ASSIGNI( m_sequencenoIn, UINT_MAX );

		DebugTrace( (DWORD_PTR)this, "New CStream size %d index %d", sizeof( *this ), index ) ;
}

CStream::~CStream(   )   {
/*++

Routine Description :

	Destroy a CStream object.

Arguments :

	None.

Return Value :

	None.


--*/

	//
	//	We zap all of our members to illegal values
	//	Hopefully this will help fire _ASSERTs if somebody attempts to
	//	use this after its destroyed.
	//
	//

	TraceFunctEnter( "CStream::~CStream" ) ;
	DebugTrace( (DWORD_PTR)this, "destroying CIODriver" ) ;

    m_pSourceChannel = 0 ;
    /*m_pIOCurrent = 0 ;*/
    ASSIGNI( m_sequencenoOut, UINT_MAX );
    m_age = 0 ;
    ASSIGNI( m_iStreamIn, UINT_MAX );
    ASSIGNI( m_sequencenoIn, UINT_MAX );
    m_fRead = FALSE ;
    m_cbFrontReserve = UINT_MAX ;
    m_cbTailReserve = UINT_MAX ;
    m_pOwner = 0 ;
    m_pSpecialPacket = 0 ;
	m_pSpecialPacketInUse = 0 ;
	m_pUnsafePacket = 0 ;
	m_pUnsafeInuse = 0 ;
	m_cShutdowns = 0 ;
#ifdef  CIO_DEBUG
    m_dwThreadOwner = 0 ;
    m_cThreads = 0 ;
    m_cSequenceThreads = 0 ;
    m_cThreadsSpecial = 0 ;
    m_cNumberSends = 0 ;
#endif

}

CIOStream::CIOStream( CIODriverSource*	pdriver,
								/*CSessionSocket*	pSocket,*/
								unsigned   cid ) :
/*++

Routine Description :

	Initialize a CIOStream object.  Most work is done by our base class
	CStream.

Arguments :

	pdriver - the CIODriverSource we are contained within
	cid -		An index to an array we are within.


Return Value :

	None.

--*/
	//
	//	A CIOStream supports request packets as well completions.
	//	(ie. it is used in CIODriverSource objects.)
	//	Very similar to CStream objects, so let CStream::CStream do the
	//	brunt of the work.
	//
	//

	CStream( cid ),
	m_fAcceptRequests( FALSE ),
	m_fRequireRequests( FALSE ),
	/*( pSocket ),*/ m_pDriver( pdriver ) {

    ASSIGNI(m_sequencenoNext, 1 );
}

CIOStream::~CIOStream( ) {
/*++

Routine Description :

	Destory a CIOStream object.
	Most work done in base class.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CIOStream::~CIOStream" ) ;
	DebugTrace( (DWORD_PTR)this, "destroying CIODriver" ) ;
}


BOOL
CIOStream::Init(   CCHANNELPTR&    pChannel,
							CIODriver&  driver,
							CIOPassThru*    pInitial,
							BOOL fRead,
							CIOPassThru&	pIOReads,
							CIOPassThru&	pIOWrites,
							CIOPassThru&	pIOTransmits,
							CSessionSocket* pSocket,
							unsigned    cbOffset )  {

	if( CStream::Init( pChannel,
				driver,
				fRead,
				pSocket,
				cbOffset ) ) {

		m_pIOCurrent = pInitial ;

		m_fAcceptRequests = TRUE ;

		m_pIOFilter[0] = &pIOReads ;
		m_pIOFilter[1] = &pIOWrites ;
		m_pIOFilter[2] = &pIOTransmits ;

		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIStream::Init(   CCHANNELPTR&    pChannel,
							CIODriver&  driver,
							CIO*    pInitial,
							BOOL fRead,
							CSessionSocket* pSocket,
							unsigned    cbOffset,
							unsigned	cbTrailer )  {


	if( CStream::Init( pChannel,
				driver,
				fRead,
				pSocket,
				cbOffset,
				cbTrailer ) ) {

		m_pIOCurrent = pInitial ;

		return	TRUE ;

	}
	return	FALSE ;
}


BOOL
CStream::Init(   CCHANNELPTR&    pChannel,
							CIODriver&  driver,
							/* CIO*    pInitial, */
							BOOL fRead,
							CSessionSocket* pSocket,
							unsigned    cbOffset,
							unsigned	cbTrailer
							)  {
/*++

Routine Description :

	Initialize a CStream object.
	We set all of our member variables to legal values.

Arguemtns :

	pChannel - The CChannel we will be calling to do actual Read()'s and Write()'s
	pdriver -	The CIODriver we are contained within
	pInitial -	The Initial CIO object which will issue the first IO's
	fRead -		if TRUE this is a read Stream, if FALSE this is an outgoing (Write) stream
	pSocket-	The socket we are associated with
	cbOffset -	The offset at which we are to have data placed in all packets we complete

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	//
	//	We need to allocate a few special packets
	//	and then set things to legal values.
	//

    BOOL    fRtn = TRUE ;

    #ifdef  CIO_DEBUG
    m_cThreadsSpecial = -1 ;
    m_cNumberSends = -1 ;
    m_dwThreadOwner = 0 ;
    m_cThreads = -1 ;
    m_cSequenceThreads = -1 ;
    #endif

    //  Validate Arguements
    _ASSERT( pChannel != 0 ) ;
    _ASSERT( pSocket != 0 ) ;

    //  Validate State
    _ASSERT( m_fRead == FALSE ) ;
    _ASSERT( !m_pSourceChannel ) ;
/*    _ASSERT( m_pIOCurrent == 0 ) ;*/
    _ASSERT( EQUALSI( m_sequencenoOut, UINT_MAX ) );
    _ASSERT( EQUALSI( m_sequencenoIn, UINT_MAX )  );
    _ASSERT( EQUALSI( m_iStreamIn, UINT_MAX ) );
    #ifdef  CIO_DEBUG
    _ASSERT( m_dwThreadOwner == 0 ) ;
    _ASSERT( InterlockedIncrement( &m_cThreads ) == 0 ) ;
    #endif

    m_pOwner = &driver ;
    ASSIGNI( m_sequencenoOut, 1 );
    ASSIGNI( m_sequencenoIn, 1 );
    ASSIGNI( m_iStreamIn, 0 );
    m_pSourceChannel = pChannel ;
    pChannel->GetPaddingValues( m_cbFrontReserve, m_cbTailReserve ) ;
    m_cbFrontReserve = max( m_cbFrontReserve, cbOffset ) ;
	m_cbTailReserve = max( m_cbTailReserve, cbTrailer ) ;
    m_fRead = fRead ;
/*    m_pIOCurrent = pInitial ;*/

    m_pSpecialPacket =	new	CControlPacket( driver ) ;
	m_pUnsafePacket =	new	CControlPacket( driver ) ;
	m_cShutdowns = -1 ;
	m_fTerminating = FALSE ;

    if( m_pSpecialPacket == 0 || m_pUnsafePacket == 0 )    {
        fRtn = FALSE ;
    }

    _ASSERT( m_pOwner != 0 ) ;
    _ASSERT( !EQUALSI( m_sequencenoOut, 0 ) );
    _ASSERT( !EQUALSI( m_sequencenoIn, 0 ) );

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedDecrement( &m_cThreads ) < 0 ) ;
    #endif

	OwnerValidate() ;

    return  fRtn ;
}

BOOL
CStream::IsValid( ) {
/*++

Routine Description :

	For debug use - determine whether a CStream is in a valid state.
	Call this after calling Init().

Arguments :

	None.

Return Value :

	TRUE if in valid state, FALSE otherwise

--*/

	//
	//	Check whether member variables are internally consistent
	//


	OwnerValidate() ;

    if( m_pSourceChannel == 0 ) {
        _ASSERT( 1==0 ) ;
        return  FALSE ;
    }
#ifdef  CIO_DEBUG
    if( m_dwThreadOwner != GetCurrentThreadId() ) {
        _ASSERT( 1==0 ) ;
        return  FALSE ;
    }
#endif
    if( !m_pOwner->FIsStream( this ) )  {
        return  FALSE ;
    }
    if( GREATER( m_sequencenoIn, m_sequencenoOut ) ) {
        _ASSERT( 1==0 ) ;
        return  FALSE ;
    }
    if( m_cbFrontReserve == UINT_MAX ) {
        return  FALSE ;
    }
    if( m_cbTailReserve == UINT_MAX )   {
        return  FALSE ;
    }
    return  TRUE ;
}

BOOL
CIOStream::IsValid() {
/*++

Routine Description :

	For debug use - determine whether a CIOStream is in a valid state.
	Call this after calling Init().

Arguments :

	None.

Return Value :

	TRUE if in valid state, FALSE otherwise

--*/

	//
	//	Check whether member variables are internally consistent
	//	(for use in _ASSERTs etc...)
	//
    if( !CStream::IsValid() ) {
        return  FALSE ;
    }
    return  TRUE ;
}

void	CIODriver::SourceNotify(	CIODriver*	pdriver,	
									SHUTDOWN_CAUSE	cause,	
									DWORD	dwOpt ) {

	//
	//	This is a place holder function for now - needs more work later.
	//

	//_ASSERT( 1==0 ) ;

}

void
CStream::InsertSource(	CIODriverSource&	source,	
									CSessionSocket*	pSocket,
									unsigned	cbAdditional,
									unsigned	cbTrailer
									) {
/*++

Routine Description :

	This function exists to change the m_pSourceChannel of this CStream.
	We would want to do so if we negogtiate encryption over this CChannel and wish
	to insert a CIODriverSource with state machine to handle encryption/decryption.

Arguments :

	source -	The CIODriverSource which is to replace m_pSourceChannel
	pSocket -	The CSessionSocket we are associated with.
	cbAdditional	-	Additional bytes to reserve in packets

Return Value :

	None.

--*/
	
	//
	//	This function is used in SSL logons etc.... Once
	//	challenge responses are completed we can be used to
	//	place a CIODriverSource between this CIODriver and
	//	a CChannel for encryption purposes.
	//	

	// We are called while completing a packet - so it can be the case that
	// there is one ounstanding packet !!
#ifdef DEBUG
	SEQUENCENO seqTemp; ASSIGN( seqTemp, m_sequencenoOut ); ADDI( seqTemp, 1 );
#endif
	_ASSERT( !GREATER( m_sequencenoOut, seqTemp ) && (!LESSER( m_sequencenoOut, m_sequencenoIn )) ) ;

	//source.GetPaddingValues( m_cbFrontReserve, m_cbTailReserve ) ; 	
	m_cbFrontReserve += cbAdditional ;
	m_cbTailReserve += cbTrailer ;	
	m_pSourceChannel = &source ;
}


#ifdef	CIO_DEBUG
LONG
CIODriver::AddRef()	{

	//
	//	This function exists only for the tracing.
	//

	TraceFunctEnter( "CIODriver::AddRef" ) ;

	LONG	lReturn = CRefCount::AddRef() ;

	DebugTrace( (DWORD_PTR)this, "Added a ref - count is now %d lReturn %d", m_refs, lReturn ) ;

	return	lReturn ;
}

LONG
CIODriver::RemoveRef()	{

	//
	//	This function exists only for the tracing.
	//	otherwise we'd let RemoveRef() be called directly.
	//

	TraceFunctEnter( "CIODriver::RemoveRef" ) ;
	
	LONG	lReturn = CRefCount::RemoveRef() ;

	DebugTrace( (DWORD_PTR)this, "Removed a ref - count is now %d lReturn %d", m_refs, lReturn ) ;

	return	lReturn ;
}
#endif

BOOL
CIODriver::InsertSource(	CIODriverSource&	source,
							CSessionSocket*	pSocket,
							unsigned	cbReadOffset,
							unsigned	cbWriteOffset,
							unsigned	cbReadTailReserve,
							unsigned	cbWriteTailReserve,
							CIOPassThru&	pIOReads,
							CIOPassThru&	pIOWrites,
							CIOPassThru&	pIOTransmits,
							CIOPASSPTR&	pRead,
							CIOPASSPTR&	pWrite ) {
/*++

Routine Description :

	This function exists to change the m_pSourceChannel of the two CStream objects.
	We would want to do so if we negogtiate encryption over this CChannel and wish
	to insert a CIODriverSource with state machine to handle encryption/decryption.

Arguments :

	source -	The CIODriverSource which is to replace m_pSourceChannel
	pSocket -	The CSessionSocket we are associated with.
	cbReadOffset -	Reserve cbReadOffset in the front of packets from now on
	cbWriteOffset - Reserve cbWriteOffset bytes in the front of packets.
	pRead -		The CIOPassThru which starts reading on the CIODriverSource machine
	pWrite -	The CIOPassThru for handling writes

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/


	//
	//	This function is used in SSL logons etc.... Once
	//	challenge responses are completed we can be used to
	//	place a CIODriverSource between this CIODriver and
	//	a CChannel for encryption purposes.
	//	

	BOOL	fRtn = TRUE ;	// We're optimists !
	#ifdef	CIO_DEBUG
	_ASSERT( InterlockedIncrement( &m_cConcurrent ) == 0 ) ;
	#endif

	if( source.Init(	&m_pReadStream->GetChannel(),
						pSocket,
						(PFNSHUTDOWN)SourceNotify,
						this,
						this,
						pIOReads,
						pIOWrites,
						pIOTransmits,
						m_pReadStream->GetFrontReserve(),
						m_pWriteStream->GetFrontReserve() ) ) {

		if( source.Start( pRead, pWrite, pSocket ) )	{

			m_pReadStream->InsertSource( source, pSocket, cbReadOffset, cbReadTailReserve ) ;
			m_pWriteStream->InsertSource( source, pSocket, cbWriteOffset, cbWriteTailReserve ) ;

		}	else	{
			fRtn = FALSE ;
		}
	}
	#ifdef	CIO_DEBUG
	_ASSERT( InterlockedDecrement( &m_cConcurrent ) < 0 ) ;
	#endif
	return	fRtn ;
}



CIODriver::FIsStream(   CStream*    pStream )   {

	//
	//	This function is for debugging use - it checks
	//	that the given CStream object is actually a member
	//	variable of a given CIODriver.
	//

	ChannelValidate() ;

    if( pStream != m_pReadStream && pStream != m_pWriteStream )
        return  FALSE ;
    else
        return  TRUE ;
}

BOOL
CStream::Stop(   )   {
	
	//
	//	Placeholder function.
	//

	OwnerValidate() ;

    return  FALSE ;
}

void
CIStream::SetShutdownState(	CSessionSocket*	pSocket,
										BOOL fCloseSource )	{
/*++

Routine Description :

	Terminate the CStream.   We notify the current CIO object
	of its impending doom, and let it tell us whether it wants to be deleted.
	Then we set m_pIOCurrent to point to a CIO object which will swallow
	all remaining packets.

Arguments :

	pSocket - The socket we are associated with
	fCloseSOurce - TRUE means we should call CloseSource() on our m_pSourceChannel object.

Return Value :

	None.


--*/
	
	//
	//	This function does all the work necessary to start a CIODriver
	//	object on the road to destruction.
	//	After this is executed, the CIODriver will be destroyed when
	//	the last reference is removed (ie. last CPacket completes)
	//

	CIODriver&	Owner = *m_pOwner ;

	TraceFunctEnter( "CStream::SetShutdownState" ) ;

	_ASSERT( pSocket != 0 ) ;
	OwnerValidate() ;

	// Notify the current IO operation that we're going down !!!!!
	if( m_pIOCurrent != 0 )		{
		m_pIOCurrent->DoShutdown(	pSocket,
									Owner,
									Owner.m_cause,
									Owner.m_dwOptionalErrorCode ) ;
	}


	// Remove our reference to our owner !!
	m_pOwner = 0 ;
	// The Reference to our source channel is removed when we destroy ourselves !!
	// Set the state to the shutdown state !!

	if( fCloseSource )
		m_pSourceChannel->CloseSource( pSocket ) ;

	CIO*	pTemp = m_pIOCurrent.Replace( &CIODriver::shutdownState ) ;
	if( pTemp ) {
		CIO::Destroy( pTemp, Owner ) ;
	}
}

void
CIOStream::SetShutdownState(	CSessionSocket*	pSocket,
										BOOL fCloseSource )	{
/*++

Routine Description :

	Terminate the CStream.   We notify the current CIO object
	of its impending doom, and let it tell us whether it wants to be deleted.
	Then we set m_pIOCurrent to point to a CIO object which will swallow
	all remaining packets.

Arguments :

	pSocket - The socket we are associated with
	fCloseSOurce - TRUE means we should call CloseSource() on our m_pSourceChannel object.

Return Value :

	None.


--*/
	
	//
	//	This function does all the work necessary to start a CIODriver
	//	object on the road to destruction.
	//	After this is executed, the CIODriver will be destroyed when
	//	the last reference is removed (ie. last CPacket completes)
	//

	TraceFunctEnter( "CStream::SetShutdownState" ) ;

	_ASSERT( pSocket != 0 ) ;
	OwnerValidate() ;

	// Notify the current IO operation that we're going down !!!!!
	if( m_pIOCurrent != 0 )		{
		m_pIOCurrent->DoShutdown(	pSocket,
									*m_pOwner,
									m_pOwner->m_cause,
									m_pOwner->m_dwOptionalErrorCode ) ;
	}

	// Remove our reference to our owner !!
	m_pOwner = 0 ;
	// The Reference to our source channel is removed when we destroy ourselves !!
	// Set the state to the shutdown state !!

	if( fCloseSource )
		m_pSourceChannel->CloseSource(	pSocket ) ;

	m_pIOCurrent = &CIODriver::shutdownState ;

	m_pIOFilter[0] = &CIODriver::shutdownState ;
	m_pIOFilter[1] = &CIODriver::shutdownState ;
	m_pIOFilter[2] = &CIODriver::shutdownState ;

}


CIStream::CIStream(  unsigned    index ) :
	//
	//	Let base class do work.
	//

	CStream( index ){
}

CIStream::~CIStream( )   {

	//
	//	Let base class do work. We get some usefull tracing here.
	//

	TraceFunctEnter( "CIStream::~CIStream" ) ;
	DebugTrace( (DWORD_PTR)this, "Destroying CIStream" ) ;

}

void
CStream::CleanupSpecialPackets()	{

	CControlPacket*	pPacketTmp = 0 ;

	pPacketTmp = (CControlPacket*)InterlockedExchangePointer( (void**)&m_pUnsafePacket, 0 ) ;
	if( pPacketTmp )	{
		//delete	pPacketTmp ;
		CPacket::DestroyAndDelete( pPacketTmp ) ;
	}
	pPacketTmp = (CControlPacket*)InterlockedExchangePointer( (void**)&m_pSpecialPacket, 0 ) ;
	if( pPacketTmp ) {
		//delete	pPacketTmp ;
		CPacket::DestroyAndDelete( pPacketTmp ) ;
	}
}



void
CIOStream::ProcessPacket(    CPacket*    pPacketCompleted,
                            CSessionSocket* pSocket )   {
/*++

Routine Description :

	All packets which complete must be processed with a call to this function.
	We will handle all the work related to completing a packet.

Arguments :

	pPacketCompleted - the packet that completed.
	pSocket -	The CSessionSocket on which the packet was sent.

Return Value :

	None.

--*/


	TraceFunctEnter( "CIOStream::ProcessPacket" ) ;

	OwnerValidate() ;

	//
	//	Tjos function is the core of CIODriverSource processing.
	//	Each packet that completes is placed on the m_pending Queue.
	//	If no other thread is processing on that queue, we will continue
	//	past the Append().  (And be safe in the knowledge that no other
	//	thread will join us.)
	//	Once we are past the Append() we need to determine whether the
	//	packet we got is the next one we want to process.  To do that
	//	we use a Queue ordered by sequence number.
	//	(All packets are stamped with a sequence number when issued.)
	//
	//	We get two types of packets - requests and completions.
	//	These both need to be processed in sequenceno order.
	//	
	//	There are a couple of special packets which may come our way
	//	which indicate we should do a special operation immediately and
	//	ignore completion order. (ie. Shutdown.)
	//


	CDRIVERPTR	pExtraRef = 0 ;
    CIOPassThru*   pIO = 0 ;

#ifdef	CIO_DEBUG
	if( pPacketCompleted->ControlPointer() == 0 )
		m_pSourceChannel->ReportPacket( pPacketCompleted ) ;
#endif

    //
    //  This is either a read stream, or a write stream.
    //  Read streams accept only CReadPackets, Write Streams accept
    //  CWritePackets and CTransmitPackets
    //
    //_ASSERT( pPacketCompleted->FLegal( m_fRead ) ) ;

    //
    //  We will append a completed packet to the pending Queue.  If this is
    //  the first packet to be appended, then Append will return TRUE.
    //
    if( m_pending.Append( pPacketCompleted ) )  {
        //
        // We will use listForward to Queue up packets which complete so that
        // we can call the other channels AFTER we no longer have the m_pending queue
        // locked.  We do this so that processing within the following channel can
        // overlap with completions occurring in here.
        // (We could alternatively : call immediately, or Post to a completion port.)
        //
        CPACKETLIST listForward ;
        _ASSERT( listForward.IsEmpty() ) ;

		// The owner should not be NULL unless we are terminating.
		_ASSERT( m_pOwner != 0 || m_fTerminating ) ;

        DebugTrace( (DWORD_PTR) this, "Appended Packet ", this ) ;

        CPacket*    pPacket ;
        while( (pPacket = m_pending.RemoveAndRelease( )) != 0 )   {

			DebugTrace( (DWORD_PTR)this, "Got Packet %x sequenceno %d", pPacket, (DWORD)LOW(pPacket->m_sequenceno) ) ;

			if( m_fTerminating )
				pExtraRef = pPacket->m_pOwner ;

            #ifdef  CIO_DEBUG
            m_dwThreadOwner = GetCurrentThreadId() ;
            _ASSERT( InterlockedIncrement( &m_cThreads ) == 0 ) ;
            #endif  //  CIO_DEBUG

			ControlInfo	control ;
			_ASSERT( control.m_type == ILLEGAL ) ;
			_ASSERT( control.m_pioPassThru == 0 ) ;
			_ASSERT( control.m_fStart == FALSE ) ;

            if( pPacket == m_pSpecialPacketInUse )   {
                //
                // This packet includes an IO* pointer !!
                //
 				_ASSERT( !pPacket->m_fRequest ) ;
                _ASSERT( pPacket->ControlPointer() ) ;
                _ASSERT( pPacket->IsValidRequest( m_fRead ) ) ;
                DebugTrace( (DWORD_PTR)this, "Processing Special Packet - CIStream %x", this ) ;

				control = m_pSpecialPacketInUse->m_control ;
				m_pSpecialPacketInUse->Reset() ;
				//
				//	Return The Packet so it can be used again !
				//
				m_pSpecialPacketInUse = 0 ;
				if( m_fTerminating )	{
					//delete	pPacket ;
					pPacket->m_pOwner->DestroyPacket( pPacket ) ;
					pPacket = 0 ;
				}	else
					m_pSpecialPacket = (CControlPacket*)pPacket ;
				#ifdef	CIO_DEBUG
				_ASSERT( InterlockedDecrement( &m_cNumberSends ) < 0 ) ;
				#endif
			}	else	if( pPacket == m_pUnsafeInuse ) {
 				_ASSERT( !pPacket->m_fRequest ) ;
                _ASSERT( pPacket->ControlPointer() ) ;
                _ASSERT( pPacket->IsValidRequest( m_fRead ) ) ;
				_ASSERT( m_pUnsafeInuse->m_control.m_type == SHUTDOWN ) ;
				DebugTrace( (DWORD_PTR)this, "Processing UnSafeInUse packet - %x", m_pUnsafeInuse ) ;
				control = m_pUnsafeInuse->m_control ;
				m_pUnsafeInuse->Reset() ;
				m_pUnsafeInuse = 0 ;
				//delete	pPacket ;
				pPacket->m_pOwner->DestroyPacket( pPacket ) ;
				pPacket = 0 ;
			}	else	{
				if( pPacket->m_fRequest ) {
					m_pendingRequests.Append( pPacket ) ;
				}	else	{
	                m_completePackets.Append( pPacket ) ;
				}
			}
			CControlPacket*	pPacketTmp = 0 ;
			if( control.m_type != ILLEGAL ) {

				if( control.m_type == SHUTDOWN ) {
					m_fTerminating = TRUE ;
					pExtraRef = m_pOwner ;

					CleanupSpecialPackets() ;

					SetShutdownState( pSocket, control.m_fCloseSource ) ;
				}	else	{
					//_ASSERT( m_pIOCurrent == 0 || m_fTerminating ) ;

					if( m_fTerminating ) {
						//
						//	We know that pPacket == m_pSpecialPacket now because this
						//	control structure was set up immediately preceeding this code
						//	using pPacket !
						//
						control.m_pioPassThru->DoShutdown(
								pSocket,
								*pExtraRef,
								pExtraRef->m_cause,
								pExtraRef->m_dwOptionalErrorCode ) ;
						//
						//	This will also have the effect of deleting pPacket since
						//	pPacket == m_pUnsafePacket - InterlockedExchange should not be
						//	necessary but do it for safety's sake !
						//
						CleanupSpecialPackets() ;

					}	else	{
						m_pIOCurrent = control.m_pioPassThru ;
						if( control.m_fStart ) {

							SEQUENCENO liTemp;
							DIFF( m_sequencenoOut, m_sequencenoIn, liTemp );

							if( !m_pIOCurrent->Start( *m_pDriver, pSocket, m_fAcceptRequests, m_fRequireRequests,
									unsigned( LOW(liTemp) ) ) ) {
								// FATAL ERROR !!!
								_ASSERT( 1==0 ) ;
							}		
						}
					}
					control.m_pioPassThru = 0 ;
				}				
			}

			_ASSERT( control.m_pioPassThru == 0 ) ;
			_ASSERT( control.m_pio == 0 ) ;

			//
			//	NOTE MAY DELETE pPacket in Preceding code !!!! DO NOT USE IT !!!!!
			//
            pPacket = 0 ;

            pIO = m_pIOCurrent ;


			CPacket*	pPacketRequest = 0 ;
			CPacket*	pPacketPending = 0 ;

			if( m_fTerminating ) {

				DebugTrace( (DWORD_PTR)this, "TERMINATING - m_pIOCurrent %x", m_pIOCurrent ) ;

				pPacketRequest = m_pendingRequests.GetHead() ;

				DebugTrace( (DWORD_PTR)this, "pPacketRequest - %x", pPacketRequest ) ;

				while( pPacketRequest ) {
					m_pendingRequests.RemoveHead() ;

					DebugTrace( (DWORD_PTR)this, "Closing owner %x source %x",
							pPacketRequest->m_pOwner, pPacketRequest->m_pSource );

					pPacketRequest->m_pOwner->UnsafeClose(	
													pSocket,
													pExtraRef->m_cause,		
													pExtraRef->m_dwOptionalErrorCode
													) ;
					pPacketRequest->m_cbBytes = 0 ;
					pPacketRequest->m_fRequest = FALSE ;
					listForward.Append( pPacketRequest ) ;
					pPacketRequest = m_pendingRequests.GetHead() ;

					DebugTrace( (DWORD_PTR)this, "pPacketRequest - %x", pPacketRequest ) ;

				}
				
				pPacketPending = m_requestPackets.GetHead() ;

				DebugTrace( (DWORD_PTR)this, "pPacketPending - %x", pPacketPending ) ;

				while( pPacketPending ) {
					m_requestPackets.RemoveHead() ;

					DebugTrace( (DWORD_PTR)this, "Closing owner %x source %x",
							pPacketPending->m_pOwner, pPacketPending->m_pSource );

					pPacketPending->m_pOwner->UnsafeClose(	
													pSocket,	
													pExtraRef->m_cause,
													pExtraRef->m_dwOptionalErrorCode ) ;
					pPacketPending->m_cbBytes = 0 ;
					pPacketPending->m_fRequest = FALSE ;
					listForward.Append( pPacketPending ) ;
					pPacketPending = m_requestPackets.GetHead() ;

					DebugTrace( (DWORD_PTR)this, "pPacketPending - %x", pPacketPending ) ;

				}

				pPacketCompleted = m_completePackets.GetHead() ;
		
				DebugTrace( (DWORD_PTR)this, "pPacketCompleted - %x", pPacketCompleted ) ;
	
				while( pPacketCompleted ) {
					m_completePackets.RemoveHead() ;
					pPacketCompleted->m_pOwner->DestroyPacket( pPacketCompleted ) ;
					pPacketCompleted = m_completePackets.GetHead() ;
					INC(m_sequencenoIn);

					DebugTrace( (DWORD_PTR)this, "pPacketCompleted - %x - m_sequncenoIn %x",
						pPacketCompleted, (DWORD)LOW(m_sequencenoIn) ) ;
				}

			}	else	{

				BOOL	fAdvanceRequests = FALSE ;
				BOOL	fAdvanceCompletes = FALSE ;

				pPacketRequest = m_pendingRequests.GetHead() ;

				DebugTrace( (DWORD_PTR)this, "INPROGRESS - pPacketRequest %x", pPacketRequest ) ;

				do	{

					fAdvanceRequests =	m_fAcceptRequests &&
										pPacketRequest &&
										EQUALS( pPacketRequest->m_sequenceno, m_sequencenoNext ) &&
										(m_pIOFilter[pPacketRequest->m_dwPassThruIndex] ==
											m_pIOCurrent || m_pIOCurrent == 0) ;

					DebugTrace(	(DWORD_PTR)this,	"fAdvRqsts %x m_fAcptRqsts %x pPcktRqst %x "
										"pPcktRqst->m_seq %x m_seqNext %x m_pIOCurrent %x "
										"m_pIOFilter[] %x",
						fAdvanceRequests, m_fAcceptRequests, pPacketRequest,
						pPacketRequest ? (DWORD)LOW(pPacketRequest->m_sequenceno) : 0,
						(DWORD)LOW(m_sequencenoNext), m_pIOCurrent,
						pPacketRequest ? (DWORD)pPacketRequest->m_dwPassThruIndex : (DWORD)0xFFFFFFFF
						) ;
						
		

					if( fAdvanceRequests ) {
			
						if( m_pIOCurrent == 0 ) {
							m_pIOCurrent = m_pIOFilter[pPacketRequest->m_dwPassThruIndex] ;
						}
				
						m_pendingRequests.RemoveHead() ;
						if( !pPacketRequest->InitRequest(
											*m_pDriver,
											pSocket,
											m_pIOCurrent,
											m_fAcceptRequests ) )	{

							ErrorTrace( (DWORD_PTR)this, "InitRequest for pPacketRequest %x failed", pPacketRequest ) ;

							// error occurred - we should shutdown !!

							m_pDriver->UnsafeClose(	pSocket, CAUSE_IODRIVER_FAILURE, 0 ) ;

							//
							//	Send this failed reqest back to the originator !
							//

							pPacketRequest->m_cbBytes = 0 ;
							pPacketRequest->m_fRequest = FALSE ;
							listForward.Append( pPacketRequest ) ;


							break ;
			
						}
						m_requestPackets.Append( pPacketRequest ) ;
						INC(m_sequencenoNext);
						pPacketRequest = m_pendingRequests.GetHead() ;

					}	else	{

						pPacketRequest = 0 ;				

						pPacketPending = m_requestPackets.GetHead() ;
						pPacketCompleted = m_completePackets.GetHead() ;
						fAdvanceCompletes =	pPacketCompleted &&
											pPacketPending &&
											EQUALS( pPacketCompleted->m_sequenceno, m_sequencenoIn) &&
											m_pIOCurrent ;

						DebugTrace( (DWORD_PTR)this,	"fAdvComp %x pPcktComp %x pPcktPend %x"
											"pPcktComp->m_seq %x m_seq %x m_pIOCurrent %x",
							fAdvanceCompletes, pPacketCompleted, pPacketPending,
							pPacketCompleted ? (DWORD)LOW(pPacketCompleted->m_sequenceno) : 0,
							(DWORD)LOW(m_sequencenoIn),	m_pIOCurrent
							) ;

						if( fAdvanceCompletes ) {

							BOOL	fCompleteRequest = FALSE ;
							ASSIGN( pPacketCompleted->m_iStream, m_iStreamIn ) ;
					
							unsigned	cbConsumed = pPacketCompleted->Complete( m_pIOCurrent, pSocket, pPacketPending, fCompleteRequest ) ;
							ADDI( m_iStreamIn, cbConsumed );
							pPacketCompleted->m_cbBytes -= cbConsumed ;

							DebugTrace( (DWORD_PTR)this, "pPacketCompleted %x m_cbBytes %x cbConsumed %x fComplete",
								pPacketCompleted, pPacketCompleted->m_cbBytes, cbConsumed, fCompleteRequest ) ;

							if( pPacketCompleted->m_cbBytes == 0 ) {
								m_completePackets.RemoveHead() ;
								pPacketCompleted->m_pOwner->DestroyPacket( pPacketCompleted ) ;
								pPacketCompleted = m_completePackets.GetHead() ;
								INC(m_sequencenoIn);
							}
							if( fCompleteRequest ) {
								pPacketPending->m_fRequest = FALSE ;
								m_requestPackets.RemoveHead() ;
								listForward.Append( pPacketPending ) ;

								pPacketRequest = m_pendingRequests.GetHead() ;
								m_fAcceptRequests = TRUE ;

								if( m_requestPackets.GetHead() == 0 )
									m_pIOCurrent = 0 ;

								DebugTrace( (DWORD_PTR)this, "pPacketRequest %x m_pIOCurrent %x m_fAcceptRequests %x",
									pPacketRequest, m_pIOCurrent, m_fAcceptRequests ) ;

							}							
						}
					}
				}	while( fAdvanceRequests || fAdvanceCompletes ) ;
			}

			#ifdef	CIO_DEBUG
			m_dwThreadOwner = 0 ;
			_ASSERT( InterlockedDecrement( &m_cThreads ) < 0 ) ;
			#endif
		}

        //
        //  Now, all the requests packets that were completed are forwarded to
        //  the channel which originated them.   Because this code falls outside
        //  the GetHead() loop, multiple threads could be executing here for the
        //  same object.  We must be carefull to not touch any member variables.
        //
        while( (pPacket = listForward.RemoveHead()) != 0 ) {
            pPacket->ForwardRequest( pSocket ) ;
        }
        _ASSERT( listForward.IsEmpty() ) ;   // Must empty this queue before leaving !!!
    }
}

void
CIStream::ProcessPacket( CPacket*    pPacketCompleted,
                            CSessionSocket* pSocket )   {

/*++

Routine Description :

	All packets which complete must be processed with a call to this function.
	We will handle all the work related to completing a packet.

Arguments :

	pPacketCompleted - the packet that completed.
	pSocket -	The CSessionSocket on which the packet was sent.

Return Value :

	None.

--*/

    TraceFunctEnter(    "CIStream::ProcessPacket" ) ;

	CDRIVERPTR	pExtraRef = 0 ;	

	//
	//	This function is the heart of CIODriver processing.
	//	We are very similar to CIOStream with the exception being
	//	that we only process completed packets, and get no requests.
	//


    CIO*    pIO = 0 ;

#ifdef	CIO_DEBUG
	if( pPacketCompleted->ControlPointer() == 0 )
		m_pSourceChannel->ReportPacket( pPacketCompleted ) ;
#endif

    //
    //  This is either a read stream, or a write stream.
    //  Read streams accept only CReadPackets, Write Streams accept
    //  CWritePackets and CTransmitPackets
    //
    _ASSERT( !pPacketCompleted->m_fRequest ) ;
    _ASSERT( pPacketCompleted->FLegal( m_fRead ) ) ;

	DebugTrace( (DWORD_PTR)this, "Completing packet %x with sequenceno %d bytes %d owner %x", pPacketCompleted,
		(DWORD)LOW(pPacketCompleted->m_sequenceno),
		pPacketCompleted->m_cbBytes, (CIODriver*)m_pOwner ) ;

    //
    //  We will append a completed packet to the pending Queue.  If this is
    //  the first packet to be appended, then Append will return TRUE.
    //
    if( m_pending.Append( pPacketCompleted ) )  {
        //
        // Each call to GetHead removes an element from the pending queue.
        // When the queue is finally empty, GetHead will return FALSE.  After GetHead
        // returns FALSE another thread calling Append() could get a TRUE value
        // (but as long as GetHead() returns TRUE to US, no one is getting TRUE from
        // Append.  )
        //

		// The owner should not be NULL unless we are terminating.
		_ASSERT( m_pOwner != 0 || m_fTerminating ) ;

        DebugTrace( (DWORD_PTR) this, "Appended Packet ", this ) ;

        CPacket*    pPacket ;
        while( (pPacket = m_pending.RemoveAndRelease( )) != 0  )   {

			DebugTrace( (DWORD_PTR)this, "Got Packet %x sequenceno %d", pPacket, (DWORD)LOW(pPacket->m_sequenceno) ) ;

			if( m_fTerminating )
				pExtraRef = pPacket->m_pOwner ;

            #ifdef  CIO_DEBUG
            m_dwThreadOwner = GetCurrentThreadId() ;
            _ASSERT( InterlockedIncrement( &m_cThreads ) == 0 ) ;
            #endif  //  CIO_DEBUG

			ControlInfo	control ;
			_ASSERT( control.m_type == ILLEGAL ) ;
			_ASSERT( control.m_pio == 0 ) ;
			_ASSERT( control.m_fStart == FALSE ) ;

            if( pPacket == m_pSpecialPacketInUse )   {
                //
                // This packet includes an IO* pointer !!
                //
 				_ASSERT( !pPacket->m_fRequest ) ;
                _ASSERT( pPacket->ControlPointer() ) ;
                _ASSERT( pPacket->IsValidRequest( m_fRead ) ) ;
                DebugTrace( (DWORD_PTR)this, "Processing Special Packet - CIStream %x", this ) ;

				control = m_pSpecialPacketInUse->m_control ;
				m_pSpecialPacketInUse->Reset() ;
				m_pSpecialPacketInUse = 0;
				if( m_fTerminating )	{
					//delete	pPacket ;
					pPacket->m_pOwner->DestroyPacket( pPacket ) ;
					pPacket = 0 ;
				}	else
					m_pSpecialPacket = (CControlPacket*)pPacket ;
				#ifdef	CIO_DEBUG
				_ASSERT( InterlockedDecrement( &m_cNumberSends ) < 0 ) ;
				#endif
			}	else	if( pPacket == m_pUnsafeInuse ) {
 				_ASSERT( !pPacket->m_fRequest ) ;
                _ASSERT( pPacket->ControlPointer() ) ;
                _ASSERT( pPacket->IsValidRequest( m_fRead ) ) ;
				_ASSERT( m_pUnsafeInuse->m_control.m_type == SHUTDOWN ) ;
				DebugTrace( (DWORD_PTR)this, "Processing UnSafeInUse packet - %x", m_pUnsafeInuse ) ;
				control = m_pUnsafeInuse->m_control ;
				m_pUnsafeInuse->Reset() ;
				m_pUnsafeInuse = 0 ;
				//delete	pPacket ;
				pPacket->m_pOwner->DestroyPacket( pPacket ) ;
				pPacket = 0 ;
			}	else	{
				_ASSERT( !pPacket->m_fRequest ) ;
				if( pPacket->m_fSkipQueue ) {
					pIO = m_pIOCurrent ;
					pPacket->Complete( pIO, pSocket ) ;
					_ASSERT( pIO == m_pIOCurrent ) ;
				}	else	{
	                m_completePackets.Append( pPacket ) ;
				}
			}
			if( control.m_type != ILLEGAL ) {

				if( control.m_type == SHUTDOWN ) {
					m_fTerminating = TRUE ;
					pExtraRef = m_pOwner ;

					if( m_fRead ) {
						if( m_pSourceChannel != 0 && pExtraRef != 0 && pExtraRef->m_cause == CAUSE_TIMEOUT )
							m_pSourceChannel->Timeout() ;
					}

					CleanupSpecialPackets() ;
					
					SetShutdownState( pSocket, control.m_fCloseSource ) ;


				}	else	{
					// START_IO's only arrive on m_pSpecialPacket
					//_ASSERT( m_pIOCurrent == 0 || m_fTerminating ) ;


					if( m_fTerminating ) {
						//
						//	We know that pPacket == m_pSpecialPacket now because this
						//	control structure was set up immediately preceeding this code
						//	using pPacket !
						//
						control.m_pio->DoShutdown(
								pSocket,
								*pExtraRef,
								pExtraRef->m_cause,
								pExtraRef->m_dwOptionalErrorCode ) ;
						//
						//	This will also have the effect of deleting pPacket since
						//	pPacket == m_pUnsafePacket - InterlockedExchange should not be
						//	necessary but do it for safety's sake !
						//
						CleanupSpecialPackets() ;

					}	else	{
						m_pIOCurrent = control.m_pio ;
						if( control.m_fStart ) {

							SEQUENCENO seqTemp;
							DIFF( m_sequencenoOut, m_sequencenoIn, seqTemp );

							if( !m_pIOCurrent->Start( *m_pOwner, pSocket,
									unsigned( LOW(seqTemp) ) ) ) {

								//
								//	This is a fatal error - need to drop the session !
								//
								m_pOwner->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;

							}		
						}
					}
					control.m_pio = 0 ;
				}				
			}

			_ASSERT( control.m_pioPassThru == 0 ) ;
			_ASSERT( control.m_pio == 0 ) ;

			//
			//	NOTE MAY DELETE pPacket in Preceding code !!!! DO NOT USE IT !!!!!
			//
            pPacket = 0 ;

            pPacketCompleted = m_completePackets.GetHead() ;
            pIO = m_pIOCurrent ;

            DebugTrace( (DWORD_PTR)this, "Completed %x pIO %x m_sequenceno %d m_sequncenoIn %d", pPacketCompleted, pIO,
				pPacketCompleted ? LOW(pPacketCompleted->m_sequenceno) : 0, LOW(m_sequencenoIn) ) ;

            while( pPacketCompleted &&
                    EQUALS( pPacketCompleted->m_sequenceno, m_sequencenoIn ) &&
                    pIO ) {

                ASSIGN( pPacketCompleted->m_iStream, m_iStreamIn ) ;

                _ASSERT( pIO != 0 ) ;


                unsigned    cbConsumed = 0 ;
				if( pPacketCompleted->m_cbBytes != 0 )
					cbConsumed = pPacketCompleted->Complete( pIO, pSocket ) ;

				// MUST Consume some Bytes !!!!
                _ASSERT( cbConsumed != 0 || m_fTerminating || pPacketCompleted->m_cbBytes == 0  ) ;
                _ASSERT( cbConsumed <= pPacketCompleted->m_cbBytes ) ;
                _ASSERT( (cbConsumed == pPacketCompleted->m_cbBytes) ||
                        pPacketCompleted->FConsumable() ) ; // If the packet is not consumed than
                                                            // it must be a read packet.

                DebugTrace( (DWORD_PTR)this, "Consumed %d bytes of %d total pIO is now %x", cbConsumed, pPacketCompleted->m_cbBytes, pIO ) ;

                ADDI( m_iStreamIn, cbConsumed );
                pPacketCompleted->m_cbBytes -= cbConsumed ;

                if( pPacketCompleted->m_cbBytes == 0 ) {
                    m_completePackets.RemoveHead() ;

					// Note : Since we are reference counted by the packets we destroy
					// we could potentially kill ourselves here.  To fix this we require
					// that a control packet be sent which will prepare ourselves for our
					// own destruction. If a control packet is sent, we will add a
					// reference temporarily (by assigning to pExtraRef which is a smart
					// pointer).
                    //delete  pPacketCompleted ;
					pPacketCompleted->m_pOwner->DestroyPacket( pPacketCompleted ) ;

                    pPacketCompleted = m_completePackets.GetHead() ;
                    INC(m_sequencenoIn);
                }
                _ASSERT( !GREATER( m_sequencenoIn, m_sequencenoOut) ) ;

                if( pIO != m_pIOCurrent )   {
					DebugTrace( (DWORD_PTR)this, "New pIO %x Old %x", pIO, m_pIOCurrent ) ;
                    if( pIO )   {
                        _ASSERT( !((!!m_fRead) ^ (!!pIO->IsRead())) ) ;
						DebugTrace( (DWORD_PTR)this, "Starting pIO %x, m_sequencenoOut %d m_sequencenoIn %d",
							pIO, (DWORD)LOW(m_sequencenoIn), (DWORD)LOW(m_sequencenoOut) ) ;

						SEQUENCENO seqTemp;
						DIFF( m_sequencenoOut, m_sequencenoIn, seqTemp );

                        if( !pIO->Start( *m_pOwner, pSocket, unsigned( LOW(seqTemp) ) ) )    {

							//
							//	We should drop the session, as this is an entirely fatal error !!!
							//
							m_pOwner->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;

                        }
                    }
					CIO*	pTemp = m_pIOCurrent.Replace( pIO ) ;
					if( pTemp ) {
						CIO::Destroy( pTemp, *m_pOwner ) ;
					}
                }
            }
#ifdef  CIO_DEBUG
        m_dwThreadOwner = 0 ;
        _ASSERT( InterlockedDecrement( &m_cThreads ) < 0 ) ;
#endif  //  CIO_DEBUG
        }
        //
        //  Final Call to m_pending.GetHead() should zero pPacket if it returns FALSE.
        //
        _ASSERT( pPacket == 0 ) ;
    }
	// At this point - pExtraRef will be Destroyed - which may destroy EVERYTHING !!
	//	In fact this should be the only point at which we destroy ourselves !!
}


DWORD	CIODriver::iMediumCache = 0 ;
DWORD	CIODriver::cMediumCaches = 128 ;
class	CMediumBufferCache*	CIODriver::pMediumCaches = 0 ;

BOOL
CIODriver::InitClass()	{

	iMediumCache = 0 ;
	cMediumCaches = 128 ;
	pMediumCaches = new	CMediumBufferCache[ cMediumCaches ] ;
	if( pMediumCaches ) {
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIODriver::TermClass()	{

	XDELETE[]	pMediumCaches ;
	return	TRUE ;
}


CIODriver::CIODriver( class	CMediumBufferCache*	pCache ) :
	//
	//	Create a CIODriver object
	//
	m_pMediumCache( 0 ),
	m_pfnShutdown( 0 ),
	m_pvShutdownArg( 0 ),
	m_cause( CAUSE_UNKNOWN ),
	m_pReadStream( 0 ),
	m_pWriteStream( 0 ),
	m_dwOptionalErrorCode( 0 ),
	m_cShutdowns( -1 )
#ifdef	CIO_DEBUG
	,m_cConcurrent( -1 ),
	m_fSuccessfullInit( FALSE ),
	m_fTerminated( FALSE )
#endif
{

	TraceFunctEnter( "CIODriver::CIODriver" ) ;
	DebugTrace( (DWORD_PTR)this, "just created Driver" ) ;

	if( m_pMediumCache == 0 ) {
		DWORD	iCache = iMediumCache ++ ;
		iCache %= cMediumCaches ;

		m_pMediumCache = &pMediumCaches[iCache] ;
	}

	ChannelValidate() ;
}

CIODriver::~CIODriver()	{

	//
	//	We must call the registered notification function to let somebody know that
	//	we are now gone.  In most instances, this is a function registered by CSessionSocket	
	//	which lets it know when the socket is really dead.
	//

#ifdef	CIO_DEBUG
	_ASSERT( !m_fSuccessfullInit || m_fTerminated ) ;
#endif

	TraceFunctEnter( "CIODriver::~CIODriver" ) ;

	DebugTrace( (DWORD_PTR)this, "destroying driver" ) ;	

	ChannelValidate() ;

	if( m_pfnShutdown ) {
		m_pfnShutdown( m_pvShutdownArg, m_cause, m_dwOptionalErrorCode ) ;
	}
	m_pfnShutdown = 0 ;
	m_pvShutdownArg = 0 ;
	m_dwOptionalErrorCode = 0 ;
	m_cause = CAUSE_UNKNOWN ;
}

CIODriverSink::CIODriverSink( class	CMediumBufferCache*	pCache) :
	CIODriver( pCache ),
	m_ReadStream( 0 ),
	m_WriteStream( 1 )  {

	//
	//	Create a CIODriverSink - we just to need to initialize pointers to
	//	2 CIStream objects.
	//

	TraceFunctEnter( "CIODriverSInk::CIODriverSink" ) ;

	ChannelValidate() ;

	DebugTrace( (DWORD_PTR)this, "New Sink size %d", sizeof( *this )  ) ;

    m_pReadStream = &m_ReadStream ;
    m_pWriteStream = &m_WriteStream ;

}

CIODriverSink::~CIODriverSink()	{

	//
	//	The tracing is usefull for debugging - not much else happens.
	//

	TraceFunctEnter(	"CIODriverSink::~CIODriverSink"  ) ;
	DebugTrace( (DWORD_PTR)this, "Destroying IODriverSink" ) ;
	ChannelValidate() ;
}

BOOL
CIODriverSink::Init(    CChannel    *pSource,
						CSessionSocket  *pSocket,
						PFNSHUTDOWN	pfnShutdown,	
						void*	pvShutdownArg,
						unsigned cbReadOffset,
						unsigned cbWriteOffset,
						unsigned cbTrailer
						) {
/*++

Routine Description :

	Initialize a CIODriverSink object.

Arguments :

	pSource - The CChannel to which all Read()'s and Write()'s should be directed
	pSocket - The CSessionSocket with which we are associated
	pfnShutdown-	A function to call when we die
	pvShutdownArg -	Arguments to pass to pfnShutdown
	cbReadOffset -	Number of bytes to reserve at the head of CReadPacket buffer's
	cbWriteOffset -	Number of bytes to reserve at the head of CWritePacket buffer's

Returns :
	
	TRUE if successfull, FALSE otherwise.

--*/

	//
	//	Initialize our CIStream objects
	//	We add a reference to ourself to force people to call UnsafeCLose() to
	//	shut us down.
	//

	ChannelValidate() ;

	// We add a reference to ourself has we only want to be destoyed through Close()
	AddRef() ;

	m_pfnShutdown = pfnShutdown ;
	m_pvShutdownArg = pvShutdownArg ;

    BOOL    fSuccess = TRUE ;
    fSuccess &= m_ReadStream.Init( CCHANNELPTR(pSource), *this,  0, TRUE, pSocket, cbReadOffset, cbTrailer  ) ;
    if( fSuccess )
        fSuccess &= m_WriteStream.Init( CCHANNELPTR(pSource), *this, 0, FALSE, pSocket, cbWriteOffset, cbTrailer ) ;

#ifdef	CIO_DEBUG
	if( fSuccess )
		m_fSuccessfullInit = TRUE ;
#endif

    return  fSuccess ;
}

void
CIODriver::Close(	CSessionSocket*	pSocket,
					SHUTDOWN_CAUSE	cause,	
					DWORD	dw,
					BOOL fCloseSource	)	{
/*++

Routine Description :

	Same as UnsafeClose()... This function needs to be retired.

Arguments :

	See UnsafeClose(),

Return Value  :

	None.

--*/

	//
	//	This function was intended to be used in certain thread safe situations only
	//	however it is now identical to UnsafeClose() and consequently needs to be retired.
	//

#ifdef	CIO_DEBUG
	_ASSERT( m_fSuccessfullInit ) ;	// Should only be called if successfully init'd
	m_fTerminated = TRUE ;
#endif

	ChannelValidate() ;

	if( InterlockedIncrement( &m_cShutdowns ) == 0 )	{

		m_cause = cause ;
		m_dwOptionalErrorCode = dw ;

		m_pReadStream->UnsafeShutdown( pSocket, fCloseSource ) ;
		m_pWriteStream->UnsafeShutdown( pSocket, fCloseSource ) ;

		// Remove Reference to self - we should disappear shortly after this !!
		if( RemoveRef() < 0 )
			delete	this ;
	}
}

void
CIODriver::UnsafeClose(	CSessionSocket*	pSocket,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dw,
						BOOL fCloseSource )	{
/*++

Routine Description :

	Terminate a CIODriver - force all outstanding packets to complete, notify
	whatever CIO is currently active that we're dieing and wind everything up.

Arguments :

	pSocket -	The socket we're associated with
	cause	-	The reason we're terminating
	dw -		Optional DWORD providing further info on why we're terminating.
	fCloseSource -	TRUE means we should close our the CChannel we were passed on
				out Init() call.

Return Value :

	None.

--*/

	TraceFunctEnter( "CIODriver::UnsafeClose" ) ;
	DebugTrace( (DWORD_PTR)this, "Terminating cause of %d err %d CloseSource %x socket %x",
					cause, dw, fCloseSource, pSocket ) ;

	//
	//	Start a CIODriver on the path to destruction.
	//	NOTE : We can be called many times however there
	//	should only be ONE call that actually does anything.	
	//

#ifdef	CIO_DEBUG
	_ASSERT( m_fSuccessfullInit ) ;	// Should only be called if successfully init'd
	m_fTerminated = TRUE ;
#endif

	ChannelValidate() ;

	if( InterlockedIncrement( &m_cShutdowns ) == 0 )	{

		m_cause	= cause ;
		m_dwOptionalErrorCode = dw ;

		m_pReadStream->UnsafeShutdown( pSocket, fCloseSource ) ;
		m_pWriteStream->UnsafeShutdown( pSocket, fCloseSource ) ;

		if( RemoveRef() < 0 )
			delete	this ;
	}
}

#ifdef	CIO_DEBUG
void	CIODriver::SetChannelDebug( DWORD	dw ) {
	m_pReadStream->SetChannelDebug( dw ) ;
}
#endif



BOOL
CIODriverSink::Start(   CIOPTR&    pRead,
						CIOPTR&	pWrite,
						CSessionSocket* pSocket )   {
/*++

Routine Description :

	Now that the CIODriverSink is all setup, issue the initial CIO's
	to get packet's flowing.

Argurments :

	pRead -	The CIO which will issue CReadPacket's
	pWrite -	The CIO which will issue CWritePacket's
	pSocket -	The Socket we are associated with.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	//
	//	We've got out initial CIO derived objects which want to do
	//	some work.  So start them !
	//

	ChannelValidate() ;
	AddRef() ;

    BOOL    eof = FALSE ;
    BOOL    fSuccess = TRUE ;
    if( fSuccess && pRead )     {
        fSuccess &= pRead->Start( *this, pSocket, 0 ) ;

		if( fSuccess ) {
			fSuccess &= m_ReadStream.SendIO( pSocket, *pRead, FALSE ) ;
			if( !fSuccess )	{
				pRead->DoShutdown( pSocket, *this, m_cause, 0 ) ;
			}
		}
    }
    if( fSuccess && pWrite )    {
        fSuccess &= pWrite->Start( *this, pSocket, 0 ) ;

		if( fSuccess )	{
			fSuccess &= m_WriteStream.SendIO( pSocket, *pWrite, FALSE ) ;
			if( !fSuccess )		{
				pWrite->DoShutdown( pSocket, *this, m_cause, 0 ) ;
			}
		}

    }
    _ASSERT( !eof ) ;

	if( RemoveRef() < 0 )
		delete	this ;
    return  fSuccess ;
}

#ifdef	CIO_DEBUG
void
CStream::SetChannelDebug( DWORD dw ) {
	m_pSourceChannel->SetDebug( dw ) ;
}
#endif

void
CIODriver::DestroyPacket(	CPacket*	pPacket )	{

	//
	//	Reference ourselves so that we don't get destroyed in the middle of this func
	//	in case the packet we are eliminating has the last reference to us.
	//
	CDRIVERPTR	pExtraRef = this ;

	pPacket->ReleaseBuffers( &m_bufferCache, m_pMediumCache ) ;

	m_packetCache.Free( CPacket::Destroy( pPacket ) ) ;

	//
	//	The desctructor of pExtraRef may destroy us at this point !
	//
}

CReadPacket*
CStream::CreateDefaultRead(		CIODriver   &driver,
								unsigned    cbRequest
								) {

	//
	//	CReadPacket's should only be created through appropriate CreateDefaultRead
	//	calls.  We will ensure that the CReadPacket is properly initialized for completion
	//	to THIS CIODriver.  Additionally, we will make sure the buffer is properly padded
	//	for encryption support etc....
	//
	
	DriverValidate( &driver ) ;

    _ASSERT( driver.FIsStream( this ) ) ;
    _ASSERT( m_cbFrontReserve != UINT_MAX ) ;
    _ASSERT( m_cbTailReserve != UINT_MAX ) ;

    CReadPacket*    pPacket = 0 ;
    if( m_fCreateReadBuffers )  {

        DWORD	cbOut = 0 ;

		DWORD	cbAdd = m_cbFrontReserve + m_cbTailReserve ;
		DWORD	cbFront = m_cbFrontReserve ;
		DWORD	cbTail = m_cbTailReserve ;

        CBuffer*    pbuffer = new(	cbRequest+cbAdd,
									cbOut,
									&driver.m_bufferCache,
									driver.m_pMediumCache )     CBuffer( cbOut ) ;
        if( pbuffer == 0 )  {
            return 0 ;
        }
        _ASSERT( cbOut > 0 ) ;
        _ASSERT( unsigned(cbOut) >= cbRequest ) ;

        pPacket = new( &driver.m_packetCache )
									CReadPacket(	driver,
													cbOut,
													cbFront,
													cbTail,
													*pbuffer ) ;
        if( !pPacket )  {
            delete  pbuffer ;
            return  0 ;
        }
        _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    }   else    {
        pPacket = new( &driver.m_packetCache )   CReadPacket( driver ) ;
        _ASSERT( pPacket->IsValidRequest( FALSE ) ) ;
    }
    return  pPacket ;
}

CWritePacket*
CStream::CreateDefaultWrite( CIODriver&  driver,
            CBUFPTR&    pbuffer,
            unsigned    ibStart,
			unsigned    ibEnd,
			unsigned    ibStartData,
			unsigned	ibEndData
			) {

	//
	//	CWritePacket's should only be created through appropriate CreateDefaultWrite calls.
	//	We will ensure that the CWritePacket is properly initialized for completion to
	//	this CIODriver.
	//

	DriverValidate( &driver ) ;

    _ASSERT( driver.FIsStream( this ) ) ;
    _ASSERT( m_cbFrontReserve != UINT_MAX ) ;
    _ASSERT( m_cbTailReserve != UINT_MAX ) ;
    return  new( &driver.m_packetCache )
					CWritePacket(	driver,
									*pbuffer,
									ibStartData,
									ibEndData,
									ibStart,
									ibEnd,
									m_cbTailReserve
									) ;
}

CWritePacket*
CStream::CreateDefaultWrite( CIODriver&  driver,
            unsigned    cbRequest )     {

	//
	//	CWritePacket's should only be created through appropriate CreateDefaultWrite calls.
	//	We will ensure that the CWritePacket is properly initialized for completion to
	//	this CIODriver.
	//

	DriverValidate( &driver ) ;

    _ASSERT( driver.FIsStream( this ) ) ;
    _ASSERT( m_cbFrontReserve != UINT_MAX ) ;
    _ASSERT( m_cbTailReserve != UINT_MAX ) ;

    CWritePacket*   pPacket = 0 ;

    DWORD	cbOut = 0 ;
    CBuffer*    pbuffer = new(	m_cbFrontReserve+m_cbTailReserve+cbRequest,
								cbOut,
								&driver.m_bufferCache,
								driver.m_pMediumCache	)  CBuffer( cbOut ) ;
    if(     pbuffer != 0 )  {
        pPacket = new( &driver.m_packetCache )
								CWritePacket(	driver,
												*pbuffer,
												m_cbFrontReserve,
												cbOut - m_cbTailReserve,
												0,
												cbOut - m_cbTailReserve,
												m_cbTailReserve
												) ;
        if( !pPacket )  {
            delete  pbuffer ;
        }
    }
    return  pPacket ;
}


CTransmitPacket*
CStream::CreateDefaultTransmit(  CIODriver&  driver,
			FIO_CONTEXT*	pFIOContext,
			unsigned		ibOffset,	
			unsigned		cbLength
			)  {

	//
	//	CTransmitPacket's should only be created through appropriate CreateDefaultWrite calls.
	//	We will ensure that the CWritePacket is properly initialized for completion to
	//	this CIODriver.
	//

	DriverValidate( &driver ) ;

    _ASSERT( driver.FIsStream( this ) ) ;
    _ASSERT( m_cbFrontReserve != UINT_MAX ) ;
    _ASSERT( m_cbTailReserve != UINT_MAX ) ;
    return  new( &driver.m_packetCache ) CTransmitPacket( driver, pFIOContext, ibOffset, cbLength ) ;
}

BOOL
CIODriverSink::FSupportConnections()    {

	//
	//	We can not be used as a regular CHandleChannel so return FALSE
	//

	ChannelValidate() ;

    return  FALSE ;
}

void
CIODriverSink::CloseSource(
					CSessionSocket*	pSocket
					)	{
	//
	//	We are not a Source like CHandleChannel is so don't call us as if we were !
	//
	_ASSERT(1==0 ) ;
}


BOOL
CIODriverSink::Read(    CReadPacket*,   CSessionSocket*,
						BOOL& eof  )   {

	//
	//	This function is only supported by CChannel derived objects which can
	//	actually make an IO happen.
	//

	ChannelValidate() ;

    _ASSERT( 1==0 ) ;
    return  FALSE ;
}

BOOL
CIODriverSink::Write(	CWritePacket*,
						CSessionSocket*,
						BOOL&  eof )   {
	//
	//	This function is only supported by CChannel derived objects which can
	//	actually make an IO happen.
	//

	ChannelValidate() ;

    _ASSERT( 1==0 ) ;
    return  FALSE ;
}

BOOL
CIODriverSink::Transmit(    CTransmitPacket*,
							CSessionSocket*,
							BOOL&   eof )   {

	//
	//	This function is only supported by CChannel derived objects which can
	//	actually make an IO happen.
	//

	ChannelValidate() ;

    _ASSERT( 1==0 ) ;
    return  FALSE ;
}

CIODriverSource::CIODriverSource(	
					class	CMediumBufferCache*	pCache
					) :
	CIODriver( pCache ),
	//
	//	Create a CIODriverSource by initializing two CIOStream's.
	//
	//
	m_ReadStream( 0, 0 ),	
	m_WriteStream( 0, 1 )	{

	TraceFunctEnter( "CIODriverSource::CIODriverSource" ) ;

	m_ReadStream.m_pDriver = this ;
	m_WriteStream.m_pDriver = this ;

	m_pReadStream = &m_ReadStream ;
	m_pWriteStream = &m_WriteStream ;

	DebugTrace( (DWORD_PTR)this, "Complete Initialization - sizeof this %d", sizeof( *this ) ) ;

}

CIODriverSource::~CIODriverSource() {

	//
	//	Usefull mainly for the tracing.
	//

	TraceFunctEnter( "CIODriverSource::~CIODriverSource" ) ;
	DebugTrace( (DWORD_PTR)this, "Destroying CIODriverSource" ) ;

}

BOOL
CIODriverSource::Read(  CReadPacket*    pPacket,
						CSessionSocket* pSocket,
						BOOL&   eof )   {

	//
	//	All requests are passed to ProcessPacket so that
	//	we don't have threading issues dealing with these !
	//

	ChannelValidate() ;

    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;

	pPacket->m_dwPassThruIndex = 0 ;

    eof = FALSE ;
    m_pReadStream->ProcessPacket(   pPacket,    pSocket ) ;
    return  TRUE ;
}

BOOL
CIODriverSource::Write( CWritePacket*   pPacket,
						CSessionSocket* pSocket,
						BOOL&   eof )   {

	//
	//	All requests are passed to ProcessPacket so that
	//	we don't have threading issues dealing with these !
	//

	ChannelValidate() ;

    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;

	pPacket->m_dwPassThruIndex = 1 ;

    eof = FALSE ;
    m_pWriteStream->ProcessPacket(  pPacket,    pSocket ) ;
    return  TRUE ;
}

BOOL
CIODriverSource::Transmit(  CTransmitPacket*    pPacket,
							CSessionSocket* pSocket,
							BOOL&   eof )   {

	//
	//	All requests are passed to ProcessPacket so that
	//	we don't have threading issues dealing with these !
	//

	//
	//	Figure out if the source of this HANDLE stored it with a terminating
	//	CRLF.CRLF.  If it didn't, and nobody has specified a termination sequence -
	//	do so now !
	//
	if( !GetIsFileDotTerminated( pPacket->m_pFIOContext ) ) {
		static	char	szTerminator[] = "\r\n.\r\n" ;
		if( pPacket->m_buffers.Tail == 0 ) 	{
			pPacket->m_buffers.Tail = szTerminator ;
			pPacket->m_buffers.TailLength = sizeof( szTerminator ) - 1 ;
		}
	}


    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;

	pPacket->m_dwPassThruIndex = 2 ;

    eof = FALSE ;
    m_pWriteStream->ProcessPacket(  pPacket,    pSocket ) ;
    return  TRUE ;
}


BOOL
CIODriverSource::Init(	CChannel*	pSource,	
						CSessionSocket*	pSocket,	
						PFNSHUTDOWN	pfnShutdown,
						void*	pvShutdownArg,	
						CIODriver*		pOwnerDriver,
						CIOPassThru&	pIOReads,
						CIOPassThru&	pIOWrites,
						CIOPassThru&	pIOTransmits,
						unsigned	cbReadOffset,	
						unsigned	cbWriteOffset ) {


	//
	//	Let the CIOStream objects to most of the work og
	//	initialization.  Add a reference to our self so that the caller
	//	uses UnsafeClose() to destroy us.
	//

	ChannelValidate() ;

	AddRef() ;

	m_pfnShutdown = pfnShutdown ;
	m_pvShutdownArg = pvShutdownArg ;

	BOOL	fSuccess = TRUE ;
	fSuccess &= m_ReadStream.Init(
						CCHANNELPTR(pSource),
						*this,
						0,
						TRUE,
						pIOReads,
						pIOWrites,
						pIOTransmits,
						pSocket,
						cbReadOffset
						) ;
	if( fSuccess )
		fSuccess &= m_WriteStream.Init(
							CCHANNELPTR(pSource),
							*this,
							0,
							FALSE,
							pIOReads,
							pIOWrites,
							pIOTransmits,
							pSocket,
							cbWriteOffset
							) ;

#ifdef	CIO_DEBUG
	if( fSuccess )
		m_fSuccessfullInit = TRUE ;
#endif

	return	fSuccess ;
}

void
CIODriverSource::SetRequestSequenceno(	SEQUENCENO&	sequencenoRead,	
										SEQUENCENO&	sequencenoWrite ) {

	//
	//	Used when we want to match a CIODriverSource with a CIODriver which
	//	has already issued some packets, and we want all new requests to be
	//	properly routed through this CIODriverSource object.
	//

	ASSIGN( m_ReadStream.m_sequencenoNext,  sequencenoRead ) ;
	ASSIGN( m_WriteStream.m_sequencenoNext, sequencenoWrite) ;
}


BOOL
CIODriverSource::Start(	CIOPASSPTR&	pRead,	
						CIOPASSPTR&	pWrite,	
						CSessionSocket*	pSocket )  {

	//
	//	Given initial CIOPassThru derived objects start work !
	//

	ChannelValidate() ;

	BOOL	eof = FALSE ;
	BOOL	fSuccess = TRUE ;

	if( fSuccess && pRead ) {
		fSuccess &= pRead->Start( *this, pSocket, m_ReadStream.m_fAcceptRequests, m_ReadStream.m_fRequireRequests, 0 ) ;
		m_ReadStream.m_pIOCurrent = pRead ;
	}

	if( fSuccess && pWrite ) {
		fSuccess &= pWrite->Start( *this, pSocket, m_WriteStream.m_fAcceptRequests, m_WriteStream.m_fRequireRequests, 0 ) ;
		m_WriteStream.m_pIOCurrent = pWrite ;
	}
	return	fSuccess ;
}

void
CIODriverSource::CloseSource(
				CSessionSocket*	pSocket
				)	{

	UnsafeClose(	pSocket,	
					CAUSE_USERTERM	) ;

}




CHandleChannel::CHandleChannel()    :
	//
	//	Initialize a CHandleChannel object
	//
	m_cAsyncWrites( 0 ),
	m_handle( (HANDLE)INVALID_SOCKET ),
    m_lpv( 0 ),
	m_pPacket( 0 ),
	m_patqContext( NULL )
#ifdef	CIO_DEBUG
	,m_cbMax( 0x10000000 ),
	m_fDoDebugStuff( FALSE )
#endif
{
	TraceFunctEnter( "CHandleChannel::CHandleChannel" ) ;
	DebugTrace( (DWORD_PTR)this, "New Handle Channel size %d", sizeof( *this ) ) ;

	ChannelValidate() ;
}

#ifdef	CIO_DEBUG

//
//	The following code exists for debug purposes -
//	it lets us easily find out what the outstanding IO's may be when we
//	close a CChannel.
//
//


CChannel::CChannel()	{
	ZeroMemory( &m_pOutReads, sizeof( m_pOutReads ) ) ;
	ZeroMemory( &m_pOutWrites, sizeof( m_pOutWrites ) ) ;
}
void
CChannel::RecordRead( CReadPacket*	pRead ) {

	//
	//	Record that we've issued the specified CReadPacket
	//
	for( int i=0; i<sizeof( m_pOutReads ) / sizeof( m_pOutReads[0] ) ; i++ ) {
		if( m_pOutReads[i] == 0 )	{
			m_pOutReads[i] = pRead ;
			break ;
		}
	}
}
void
CChannel::RecordWrite( CWritePacket*	pWrite ) {

	//
	//	Record that we've issued the specified CWritePacket
	//

	for( int i=0; i<sizeof( m_pOutWrites ) / sizeof( m_pOutWrites[0] ) ; i++ ) {
		if( m_pOutWrites[i] == 0 )	{
			m_pOutWrites[i] = pWrite ;
			break ;
		}
	}
}
void
CChannel::RecordTransmit( CTransmitPacket*	pTransmit ) {
	//
	//	Record that we've issued the specified CTransmitPacket
	//

	for( int i=0; i<sizeof( m_pOutWrites ) / sizeof( m_pOutWrites[0] ) ; i++ ) {
		if( m_pOutWrites[i] == 0 )	{
			m_pOutWrites[i] = pTransmit ;
			break ;
		}
	}
}
void
CChannel::ReportPacket( CPacket*	pPacket ) {

	//
	//	Report the completion of a packet and remove it from our records.
	//

	for( int i=0; i<sizeof(m_pOutWrites ) / sizeof( m_pOutWrites[0] ); i++ ) {
		if( m_pOutWrites[i] == pPacket ) {
			m_pOutWrites[i] = 0 ;
			return ;
		}
	}		
	for( i=0; i<sizeof(m_pOutReads) / sizeof( m_pOutReads[0] ); i++ ) {
		if( m_pOutReads[i] == pPacket ) {
			m_pOutReads[i] = 0 ;
			return ;
		}
	}		
	//_ASSERT( 1==0 ) ;
	return	;
}
void
CChannel::CheckEmpty() {

	//
	//	Call this function when you think there should be no CPacket's pending -
	//	it will verify that they've all been reported.
	//

	for( int i=0; i<sizeof(m_pOutReads)/sizeof( m_pOutReads[0]); i++ ) {
		if( m_pOutReads[i] != 0 ) {
			_ASSERT( 1==0 ) ;
		}
	}
	for( i=0; i<sizeof(m_pOutWrites)/sizeof(m_pOutWrites[0]); i++ ) {
		if( m_pOutWrites[i]!=0 ) {
			_ASSERT( 1==0 ) ;
		}
	}
}
#endif

CHandleChannel::~CHandleChannel()       {
	
	//
	//	Close our atq Context if present.	
	//

	TraceFunctEnter( "CHandleChannel::~CHandleChannel" ) ;

	ChannelValidate() ;

	DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

#ifdef	CIO_DEBUG
	CheckEmpty() ;
#endif	

	if( m_patqContext )
		Close() ;

    _ASSERT( m_patqContext == 0 ) ;
    _ASSERT( m_handle == (HANDLE)INVALID_SOCKET ) ;
}

BOOL
CHandleChannel::Init(   BOOL	BuildBreak,
						HANDLE  h,
						void    *pSocket,
						void*	patqContext,
						ATQ_COMPLETION    pfn )       {

	//
	//	This initialization function will call the appropriate ATQ stuff
	//	to get us set up for Async IO.
	//

	TraceFunctEnter( "CHandleChannel::Init" ) ;
	ChannelValidate() ;

	m_lpv = (void*)pSocket ;
	if( patqContext ) {
		m_patqContext = (PATQ_CONTEXT)patqContext ;
		m_handle = h ;

		DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

		AtqContextSetInfo( m_patqContext, ATQ_INFO_COMPLETION, (DWORD_PTR)pfn ) ;
		AtqContextSetInfo( m_patqContext, ATQ_INFO_COMPLETION_CONTEXT, (DWORD_PTR)this )  ;
		return	TRUE ;
	}	else	{
		if( AtqAddAsyncHandle(
					&m_patqContext,
					NULL,				// No endpoint object for outbound sockets and file handles !
					this,
					pfn,
					INFINITE,
					h ) )       {
			m_handle = h ;

			DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

			return  TRUE ;
		}
	}

	DWORD	dwError = GetLastError() ;

	ErrorTrace( (DWORD_PTR)this, "Error calling AtqAddAsyncHandle - %x", dwError ) ;
    return  FALSE ;
}

void
CHandleChannel::Close(	)    {

	//
	//	Close our ATQ Context.
	//

	TraceFunctEnter( "CHandleChannel::Close" ) ;

	_ASSERT( m_handle == INVALID_HANDLE_VALUE ) ;

	ChannelValidate() ;

	DebugTrace( (DWORD_PTR)this, "Freeing m_patqContext %x", m_patqContext ) ;

    AtqFreeContext( m_patqContext, TRUE ) ;
    m_patqContext = 0 ;
}

void
CHandleChannel::CloseSource(	
					CSessionSocket*	pSocket
					)	{

	//
	//	This function closes our handle so that all pending IO's complete,
	//	however it does not discard the ATQ context yet.
	//

	TraceFunctEnter( "CHandleChannel::CloseSource" ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;

	DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

	HANDLE	h = (HANDLE)InterlockedExchangePointer( &m_handle, INVALID_HANDLE_VALUE ) ;

	if(	h != INVALID_HANDLE_VALUE )	{
		// BUGBUG - the handle should be closed by the message object, not
		// the protocol
		AtqCloseFileHandle( m_patqContext ) ;
		//	bugbug .... clean up this debug code someday !
		DWORD	dw = GetLastError() ;
	}
}

HANDLE
CHandleChannel::ReleaseSource()	{

	TraceFunctEnter(	"CHandleChannel::ReleaseSource" ) ;
	DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;
	HANDLE	h = (HANDLE)InterlockedExchangePointer( &m_handle, INVALID_HANDLE_VALUE ) ;
	return	h ;
}

#ifdef	CIO_DEBUG
void
CHandleChannel::SetDebug( DWORD	dw ) {
	m_fDoDebugStuff = TRUE ;
	m_cbMax = dw ;
}
#endif


CSocketChannel::CSocketChannel()	:
	m_fNonBlockingMode( FALSE ),
	m_cbKernelBuff( 0 ) {
}

BOOL
CSocketChannel::Init(	HANDLE	h,	
						void*	lpv,	
						void*	patqContext,
						ATQ_COMPLETION	pfn
						) {

	TraceFunctEnter( "CSocketChannel::Init" ) ;
	BOOL	fRtn = FALSE ;

	if(	CHandleChannel::Init( FALSE, h, lpv, patqContext, pfn ) ) {

		if( g_pNntpSvc->GetSockRecvBuffSize() != BUFSIZEDONTSET ) {

			int	i = g_pNntpSvc->GetSockRecvBuffSize() ;
			if( setsockopt( (SOCKET)h, SOL_SOCKET, SO_RCVBUF,
					(char *)&i, sizeof(i) ) != 0 ) {
				ErrorTrace( (DWORD_PTR)this, "Unable to set recv buf size %i",
						WSAGetLastError() ) ;
			}
		}
		if( g_pNntpSvc->GetSockSendBuffSize() != BUFSIZEDONTSET ) {

			int	i = g_pNntpSvc->GetSockSendBuffSize() ;
			if( setsockopt((SOCKET)h, SOL_SOCKET, SO_SNDBUF,
					(char*) &i, sizeof(i) ) != 0 )	{
			
				ErrorTrace( (DWORD_PTR)this, "Unable to set send buf size %i",
					WSAGetLastError() ) ;
			}
		}
		if( g_pNntpSvc->FNonBlocking() ) {
			ULONG	ul = 1 ;
			if( 0!=ioctlsocket( (SOCKET)h, FIONBIO, &ul ) )	{
				ErrorTrace( (DWORD_PTR)this, "Unable to set non blocking mode %i",
					WSAGetLastError() ) ;
			}	else	{
				m_fNonBlockingMode = TRUE ;
			}
		}

#if 0
		struct	linger	lingerData ;
		DWORD	cblinger = sizeof( lingerData ) ;

		if( 0!=getsockopt( (SOCKET)h, SOL_SOCKET, SO_LINGER, &lingerData, &cblinger ) ) {
			DWORD	dwError = WSAGetLastError() ;
			ErrorTrace( DWORD(this), "Unable to get linger info %d", dwError ) ;
		}

		lingerData.l_onoff = 1 ;
		lingerData.l_linger = 1 ;
		if( 0!=setsockopt( (SOCKET)h, SOL_SOCKET, SO_LINGER, &lingerData, sizeof( lingerData ) ) {
			DWORD	dwError = WSAGetLastError() ;
			ErrorTrace( DWORD(this), "Unable to set linger info %d", dwError ) ;
		}
#endif

		PNNTP_SERVER_INSTANCE pInst = (((CSessionSocket*)lpv)->m_context).m_pInstance ;
		AtqContextSetInfo( m_patqContext, ATQ_INFO_TIMEOUT, pInst->QueryConnectionTimeout() ) ;

		fRtn = TRUE ;
	}

	int		dwSize = sizeof( m_cbKernelBuff ) ;
	if( 0!=getsockopt( (SOCKET)h, SOL_SOCKET, SO_SNDBUF, (char*)&m_cbKernelBuff, &dwSize ) )	{
		ErrorTrace( (DWORD_PTR)this, "Unable to get new kernel send buf size %i",
				WSAGetLastError() ) ;
		m_cbKernelBuff = 0 ;
	}		

	return	fRtn ;
}

BOOL
CSocketChannel::Write(	CWritePacket*	pPacket,	
						CSessionSocket*	pSocket,	
						BOOL&	eof )	{

    _ASSERT( (void*)pSocket == m_lpv) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
	_ASSERT( !pPacket->m_fRead ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

	int	cb = pPacket->m_ibEndData - pPacket->m_ibStartData ;
#ifdef	CIO_DEBUG
	int	cbTemp = cb; // ((rand() > 16000) ? 2 : 1 ) ;
#endif
	int	count = 0 ;
	if( m_fNonBlockingMode && m_cAsyncWrites == 0 && cb < m_cbKernelBuff ) {

		count = send(	(SOCKET)m_handle,
						pPacket->StartData(),
#ifdef	CIO_DEBUG
						cbTemp,
#else
						cb,
#endif
						0 ) ;
		if( count == cb ) {
			//
			//	Complete the packet - it was succcessfully sent !!
			//
			pPacket->m_fRequest = FALSE ;
			pPacket->m_cbBytes = count ;			
			
			pPacket->m_pOwner->CompleteWritePacket( pPacket, pSocket ) ;
			return	TRUE ;
		}	else	if(	count > cb || count <= 0 )	{
			count = 0 ;
			if( WSAGetLastError() != WSAEWOULDBLOCK ) {
				return	FALSE ;
			}
		}
	}
	if( count != 0 ) {
		pPacket->m_cbBytes = count ;
	}
	InterlockedIncrement( &m_cAsyncWrites ) ;
	BOOL	fRtn = AtqWriteFile(	m_patqContext,
									pPacket->StartData()+count,
									cb-count,
									(LPOVERLAPPED)&pPacket->m_ovl.m_ovl ) ;
#ifdef	CIO_DEBUG
	DWORD	dw = GetLastError() ;
#endif
	return	fRtn ;
}	

void
CSocketChannel::CloseSource(
						CSessionSocket*	pSocket
						)	{

	//
	//	This function closes our socket so that all pending IO's (CPackets) complete.
	//

	TraceFunctEnter( "CSocketChannel::CloseSource" ) ;

	DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

	SOCKET	s = (SOCKET)InterlockedExchangePointer( (void**)&m_handle, (void*)INVALID_SOCKET ) ;
	if( s != INVALID_SOCKET )	{
		BOOL f = AtqCloseSocket(	m_patqContext, TRUE ) ;
		_ASSERT( f ) ;
	}
}

void
CSocketChannel::Timeout()	{

	static	char	szTimeout[] = "503 connection timed out \r\n" ;

	if( m_handle != INVALID_HANDLE_VALUE ) {
		send(	(SOCKET)m_handle,
					szTimeout,
					sizeof( szTimeout )-1,
					0 ) ;
	}
}

void
CSocketChannel::ResumeTimeouts()	{

	if( m_patqContext != 0 ) {
		AtqContextSetInfo( m_patqContext, ATQ_INFO_RESUME_IO, 0 ) ;
	}
}

BOOL
CHandleChannel::Read(   CReadPacket*    pPacket,
						CSessionSocket  *pSocket,
						BOOL    &eof )  {

	//
	//	Issue a CReacPacket
	//

	TraceFunctEnter( "CHandleChannel::Read" ) ;

	ChannelValidate() ;

    _ASSERT( (void*)pSocket == m_lpv) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    //_ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;

	DebugTrace( (DWORD_PTR)this, "Issuing IO to context %x handle %x packet %x pSocket %x",
			m_patqContext, m_handle, pPacket, pSocket ) ;


	// Calculate how big a read we can perform !!
	DWORD	cbToRead = pPacket->m_ibEnd - pPacket->m_ibStartData ;

	#ifdef	CIO_DEBUG
	RecordRead( pPacket ) ;
	if( m_fDoDebugStuff ) {
		cbToRead = min( m_cbMax, cbToRead ) ;
	}
	#endif

    eof = FALSE ;
    BOOL fRtn = AtqReadFile(    m_patqContext,
                    pPacket->StartData(),
                    cbToRead,
                    (LPOVERLAPPED)&pPacket->m_ovl.m_ovl
					) ;

    DWORD   dw = GetLastError() ;

	#ifdef	CIO_DEBUG
	if( !fRtn )
		ReportPacket( pPacket ) ;
	#endif

    return  fRtn ;
}

BOOL
CHandleChannel::Write(  CWritePacket*   pPacket,
						CSessionSocket  *pSocket,
						BOOL    &eof )  {

	//
	//	Issue a CWritePacket
	//

	TraceFunctEnter( "CHandleChannel::Write" ) ;

	ChannelValidate() ;

    _ASSERT( (void*)pSocket == m_lpv) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;

	DebugTrace( (DWORD_PTR)this, "Issuing IO to context %x handle %x packet %x pSocket %x",
			m_patqContext, m_handle, pPacket, pSocket ) ;

	#ifdef	CIO_DEBUG
	RecordWrite( pPacket ) ;
	#endif

    eof = FALSE ;
    BOOL	fRtn = AtqWriteFile(   m_patqContext,
                            pPacket->StartData(),
                            pPacket->m_ibEndData - pPacket->m_ibStartData,
                            (LPOVERLAPPED)&pPacket->m_ovl.m_ovl
							) ;

	#ifdef	CIO_DEBUG
	if( !fRtn )
		ReportPacket( pPacket ) ;
	#endif
	return	fRtn ;
}

BOOL
CHandleChannel::Transmit(   CTransmitPacket*    pPacket,
							CSessionSocket* pSocket,
							BOOL    &eof )  {

	//
	//	Issue a CTransmitPacket
	//

	ChannelValidate() ;

    _ASSERT( (void*)pSocket == m_lpv ) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;

    //LARGE_INTEGER   l ;
    //l.QuadPart = 0 ;
	DWORD dwBytesInFile = 0;

	_ASSERT( m_pPacket == 0 ) ;
	m_pPacket = pPacket ;

    eof = FALSE ;

	m_patqContext->Overlapped.Offset = pPacket->m_cbOffset ;
	// l.LowPart = pPacket->m_cbLength ;
	dwBytesInFile = pPacket->m_cbLength ;

	#ifdef	CIO_DEBUG
	RecordTransmit( pPacket ) ;
	#endif

#ifdef DEBUG
    DWORD   dwFileSize = GetFileSize( pPacket->m_pFIOContext->m_hFile, 0 );
#endif

	//
	//	Figure out if the source of this HANDLE stored it with a terminating
	//	CRLF.CRLF.  If it didn't, and nobody has specified a termination sequence -
	//	do so now !
	//
	if( !GetIsFileDotTerminated( pPacket->m_pFIOContext ) ) {
		static	char	szTerminator[] = "\r\n.\r\n" ;
		if( pPacket->m_buffers.Tail == 0 ) 	{
			pPacket->m_buffers.Tail = szTerminator ;
			pPacket->m_buffers.TailLength = sizeof( szTerminator ) - 1 ;
		}
	}

    BOOL	fRtn =   AtqTransmitFile(
								m_patqContext,
                                pPacket->m_pFIOContext->m_hFile,
                                dwBytesInFile, //l,
                                &pPacket->m_buffers, //&pPacket->m_ovl.m_ovl,
                                0 ) ;
	#ifdef	CIO_DEBUG
	if( !fRtn )
		ReportPacket( pPacket ) ;
	#endif
	return	fRtn ;
}

BOOL
CHandleChannel::IsValid()   {
    return  TRUE ;
}

void
CHandleChannel::Completion( CHandleChannel* pChannel,
							DWORD cb,
							DWORD dwStatus,
							ExtendedOverlap *povl ) {

	//
	//	Complete a packet - if an error occurred close the CIODriver.
	//

	CSessionSocket*	pSocket = (CSessionSocket*)pChannel->m_lpv ;
	TraceFunctEnter( "CHandleChannel::Completion" ) ;

	CPacket*	pPacket = 0 ;
	if( povl == 0 ) {
		//
		//	This is an ATQ generated timeout !!
		//
		pSocket->Disconnect( CAUSE_TIMEOUT, 0 ) ;
		return ;
	} else if( (OVERLAPPED*)povl == &pSocket->m_pHandleChannel->m_patqContext->Overlapped ) {
		pPacket = pSocket->m_pHandleChannel->m_pPacket ;
		pSocket->m_pHandleChannel->m_pPacket = 0 ;
		CopyMemory( &pPacket->m_ovl.m_ovl, &povl->m_ovl, sizeof( povl->m_ovl ) ) ;
	}	else	{
		pPacket = povl->m_pHome ;
	}
	if( dwStatus != 0 ) {
		DebugTrace( (DWORD_PTR)pSocket, "Error on IO Completion - %x pSocket %x", dwStatus, pSocket ) ;
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_NTERROR, dwStatus ) ;
	}	else	if( cb == 0 ) {
		DebugTrace( (DWORD_PTR)pSocket, "Zero BYTE IO Completion - %x pSocket %x", dwStatus, pSocket ) ;
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_USERTERM, 0 ) ;
	}
    _ASSERT( pPacket != 0 ) ;
    _ASSERT( pPacket->m_fRequest == TRUE ) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    pPacket->m_fRequest = FALSE ;
    pPacket->m_cbBytes += cb ;

	DebugTrace( 0, "Completing on Socket %x cb %d dwStatus %x povl %x pPacket %x",
		pSocket, cb, dwStatus, povl, pPacket ) ;


    if( pPacket->m_fRead )  {
		AddByteStat( ((pSocket->m_context).m_pInstance), TotalBytesReceived, pPacket->m_cbBytes ) ;
        pPacket->m_pOwner->m_pReadStream->ProcessPacket( pPacket, pSocket ) ;
    }   else    {
		AddByteStat( ((pSocket->m_context).m_pInstance), TotalBytesSent, pPacket->m_cbBytes ) ;
		InterlockedDecrement( &pChannel->m_cAsyncWrites ) ;
        pPacket->m_pOwner->m_pWriteStream->ProcessPacket( pPacket, pSocket ) ;
    }
}



CFileChannel::CFileChannel() :
	//
	//	Initialize a CFileChannel
	//	CFileChannel's do some extra work to keep track of where they
	//	are reading and writing in the file, hence the extra
	//	member variables such as m_cbInitialOffset.
	//	Initalize to all illegal values - user must call Init() before
	//	we'll work.
	//
	//
	m_cbInitialOffset( UINT_MAX ),
    m_cbCurrentOffset( UINT_MAX ),
	m_cbMaxReadSize( UINT_MAX ),
    m_fRead( FALSE ),
	m_pSocket( 0 ),
	m_pFIOContext( 0 ),
	m_pFIOContextRelease( 0 )
#ifdef  CIO_DEBUG
    ,m_cReadIssuers( 0 ),   m_cWriteIssuers( 0 )
#endif
{

	TraceFunctEnter( "CFileChannel::CFileChannel" ) ;
	DebugTrace( (DWORD_PTR)this, "New CFileChannel size %d", sizeof( *this ) ) ;
}

CFileChannel::~CFileChannel()	{
	if( m_pFIOContextRelease )
		ReleaseContext( m_pFIOContextRelease ) ;
}

BOOL
CFileChannel::Init( FIO_CONTEXT*	pFIOContext,
					CSessionSocket* pSocket,
					unsigned    offset,
 					BOOL    fRead,
					unsigned	cbMaxBytes
					) {

	//
	//	Initialize a CFileChannel -
	//	use CHandleChannel to do the grunt work of registering with ATQ,
	//	then figure out where we are in the file etc... and set up
	//	member variables so we start Reads and Writes at the write position.
	//
	//

	TraceFunctEnter( "CFileChannel::Init" ) ;

	ChannelValidate() ;

    _ASSERT( pFIOContext != 0 ) ;
	_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
    _ASSERT( pSocket != 0 ) ;
    _ASSERT( offset != UINT_MAX ) ;

	//
	//	Add a reference to the FIO_CONTEXT so that it does not disappear before
	//	we've completed all of our IO's !
	//
	AddRefContext( pFIOContext ) ;

	m_pFIOContext = pFIOContext ;
	m_pFIOContextRelease = pFIOContext ;
	m_fRead = fRead ;
	m_pSocket = pSocket ;
	m_cbCurrentOffset = m_cbInitialOffset = offset ;
	if( fRead ) 	{

		DWORD	cbHigh ;
		DWORD	cb = GetFileSizeFromContext( pFIOContext, &cbHigh ) ;
		if( cbMaxBytes == 0 ) {
			m_cbMaxReadSize = cb ;
		}	else	{
			_ASSERT( offset+cbMaxBytes <= cb ) ;
			m_cbMaxReadSize = min( offset + cbMaxBytes, cb ) ;
		}
	}

	DebugTrace( (DWORD_PTR)this, "Successfule Init - pSocket %x m_cbCurrentOffset %d",
		pSocket, m_cbCurrentOffset ) ;

    #ifdef  CIO_DEBUG
    m_cReadIssuers = -1 ;
    m_cWriteIssuers = -1 ;
    #endif
    return  TRUE ;
}

BOOL
CFileChannel::FReadChannel( )   {
	//
	//	Does this channel support Read()'s ?
	//
	ChannelValidate() ;

    _ASSERT( m_pFIOContext != 0 ) ;
	_ASSERT( m_pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
    _ASSERT( m_pSocket != 0 ) ;
    _ASSERT( m_cbCurrentOffset != UINT_MAX ) ;

    return  m_fRead ;
}

BOOL
CFileChannel::Reset(    BOOL    fRead,
								unsigned    cbOffset )  {

	//
	//	After this all Read(), Write()'s etc... will start at a new position
	//	in the file.
	//

	ChannelValidate() ;

    _ASSERT( m_pFIOContext != 0 ) ;
	_ASSERT( m_pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
    _ASSERT( m_pSocket != 0 ) ;
    _ASSERT( m_cbCurrentOffset != UINT_MAX ) ;


    m_fRead = fRead ;
    if( m_fRead )   {
		DWORD	cbHigh = 0 ;
		DWORD	cb = GetFileSizeFromContext( m_pFIOContext, &cbHigh ) ;
		m_cbMaxReadSize = cb ;
	}
    m_cbCurrentOffset = m_cbInitialOffset = cbOffset ;
    return  TRUE ;
}

void
CFileChannel::CloseSource(	CSessionSocket*	pSocket	)	{
	CloseNonCachedFile( m_pFIOContextRelease ) ;
}


FIO_CONTEXT*
CFileChannel::ReleaseSource()	{

	TraceFunctEnter(	"CHandleChannel::ReleaseSource" ) ;
	m_lock.ExclusiveLock() ;
	FIO_CONTEXT*	pContext = (FIO_CONTEXT*)InterlockedExchangePointer( (PVOID *)&m_pFIOContext, 0 ) ;
	m_lock.ExclusiveUnlock() ;

	DebugTrace( (DWORD_PTR)this, "p %x m_handle %x", pContext, pContext ? pContext->m_hFile : 0 ) ;
	return	pContext ;
}




void
CFileChannel::Close(    )   {

	//
	//	Use CHandleChannel to do the work.
	//

	ChannelValidate() ;

	TraceFunctEnter( "CFileChannel::CLose" ) ;
	
	//
	//	We have to do our own thing here - the FIO_Context should always be
	//	removed before this !
	//
	_ASSERT( m_pFIOContext == 0 ) ;



	DebugTrace( (DWORD_PTR)this, "Our size is %d ", sizeof( *this ) ) ;
}

BOOL
CFileChannel::Read( CReadPacket*    pPacket,
					CSessionSocket* pSocket,
					BOOL&   eof )   {

	//
	//	Issue a Read into the file.
	//	Setup the overlapped structures so that we get the
	//	correct bytes out of the file.
	//

	TraceFunctEnter( "CFileChannel::Read" ) ;

	ChannelValidate() ;

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedIncrement( &m_cReadIssuers ) == 0 ) ;
    #endif
    _ASSERT( m_fRead ) ;
    _ASSERT( pSocket == m_pSocket ) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	_ASSERT( m_pFIOContext != 0 ) ;
	_ASSERT( m_pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

#ifdef	_IMPLEMENT_LATER_
	_ASSERT( pPacket->m_pFileChannel == 0 ) ;
	pPacket->m_pFileChannel = this ;
#endif

    eof = FALSE ;

    pPacket->m_ovl.m_ovl.Offset = m_cbCurrentOffset ;
    unsigned    cb = pPacket->m_ibEnd - pPacket->m_ibStartData ;

    if( cb > (m_cbMaxReadSize - m_cbCurrentOffset) )    {
        cb = (m_cbMaxReadSize - m_cbCurrentOffset) ;
        eof = TRUE ;
    }
    m_cbCurrentOffset += cb ;

	DebugTrace( (DWORD_PTR)this, "Issuing IO to context %x packet %x pSocket %x",
			m_pFIOContext, pPacket, pSocket ) ;

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedDecrement( &m_cReadIssuers ) < 0 ) ;
    #endif

	pPacket->m_ovl.m_ovl.pfnCompletion = (PFN_IO_COMPLETION)CFileChannel::Completion ;
	pPacket->m_pFileChannel = this ;

	BOOL	fRtn = FALSE ;
	fRtn =	FIOReadFile(	m_pFIOContext,
							pPacket->StartData(),
							cb,
							&pPacket->m_ovl.m_ovl
							) ;

    DWORD   dw = GetLastError() ;
    return  fRtn ;
}

BOOL
CFileChannel::Write(    CWritePacket*   pPacket,
						CSessionSocket* pSocket,
						BOOL&  eof )   {

	//
	//	Issue a Write into the file.
	//	Setup the overlapped structures so that we get the
	//	correct bytes out of the file.
	//

	TraceFunctEnter( "CFileChannel::Write" ) ;

	ChannelValidate() ;

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedIncrement( &m_cWriteIssuers ) == 0 ) ;
    #endif
    _ASSERT( !m_fRead ) ;
    _ASSERT( pSocket == m_pSocket ) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

#ifdef	_IMPLEMENT_LATER_
	_ASSERT( pPacket->m_pFileChannel == 0 ) ;
	pPacket->m_pFileChannel = this ;
#endif

    eof = FALSE ;

    pPacket->m_ovl.m_ovl.Offset = m_cbCurrentOffset ;
    unsigned    cb = pPacket->m_ibEndData - pPacket->m_ibStartData ;
    m_cbCurrentOffset += cb ;

	DebugTrace( (DWORD_PTR)this, "Issuing IO to context %x packet %x pSocket %x",
			m_pFIOContext, pPacket, pSocket ) ;

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedDecrement( &m_cWriteIssuers ) < 0 ) ;
    #endif

	pPacket->m_ovl.m_ovl.pfnCompletion = (PFN_IO_COMPLETION)CFileChannel::Completion ;
	pPacket->m_pFileChannel = this ;

    BOOL    fRtn = FALSE ;
	fRtn =	FIOWriteFileEx(	m_pFIOContext,
							pPacket->StartData(),
							cb,
                            cb,
							&pPacket->m_ovl.m_ovl,
							pPacket->m_dwExtra2 == 1 ? TRUE : FALSE,
							TRUE
							) ;

    DWORD   dw = GetLastError() ;
    return  fRtn ;
}

BOOL
CFileChannel::Transmit( CTransmitPacket*    pPacket,
						CSessionSocket* pSocket,
						BOOL&   eof )   {

	//
	//	Cant do TransmitFile's into a file.
	//

	ChannelValidate() ;

    _ASSERT( 1==0 ) ;
    eof = FALSE ;
    return  FALSE ;
}

void
CFileChannel::Completion(	FIO_CONTEXT*	pFIOContext,
							ExtendedOverlap *povl,
							DWORD cb,
							DWORD dwStatus
							) {

	//
	//	Complete a CPacket which was issued against a file.
	//
	//

	TraceFunctEnter( "CFileChannel::Completion" ) ;

    if( dwStatus == ERROR_SEM_TIMEOUT ) return ;

    CPacket*    pPacket = povl->m_pHome ;

	CFileChannel*	pFileChannel = (CFileChannel*)pPacket->m_pFileChannel ;
	_ASSERT( pFileChannel != 0 ) ;
    //_ASSERT( pFileChannel->m_lpv == (void*)pFileChannel ) ;

    _ASSERT( pPacket != 0 ) ;
    _ASSERT( pPacket->m_fRequest == TRUE ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset >= pFileChannel->m_cbInitialOffset ) ;

	#ifdef	CIO_DEBUG

    //
    //  The calling CStream class will independently track
    //  each packets stream position.  We subtract cbInitialOffset
    //  so that these numbers should be in sync.
    //  This will be checked within the packet IsValidCompletion() functions.
    //
    pPacket->m_ovl.m_ovl.Offset -= pFileChannel->m_cbInitialOffset ;
    pPacket->m_ovl.m_ovl.Offset ++ ;

    //Sleep(    rand() / 1000 ) ;
    #endif
	if( dwStatus != 0 ) {
		DebugTrace( (DWORD_PTR)pFileChannel->m_pSocket, "Error on IO Completion - %x pSocket %x", dwStatus, pFileChannel) ;
		cb = 0 ;
		pPacket->m_pOwner->UnsafeClose( (CSessionSocket*)pFileChannel->m_pSocket, CAUSE_NTERROR, dwStatus ) ;
	}	else	if( cb == 0 ) {
		DebugTrace( (DWORD_PTR)pFileChannel->m_pSocket, "Zero BYTE IO Completion - %x pSocket %x", dwStatus, pFileChannel ) ;
		pPacket->m_pOwner->UnsafeClose( (CSessionSocket*)pFileChannel->m_pSocket, CAUSE_USERTERM, 0 ) ;
	}

    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    pPacket->m_fRequest = FALSE ;
    pPacket->m_cbBytes = cb ;

	DebugTrace( 0, "Completing on FileChannel %x cb %x dwStatus %x povl %x pPacket %x",
		pFileChannel, dwStatus, povl, pPacket ) ;

    if( pPacket->m_fRead )  {
        pPacket->m_pOwner->m_pReadStream->ProcessPacket( pPacket, pFileChannel->m_pSocket ) ;
    }   else    {
        pPacket->m_pOwner->m_pWriteStream->ProcessPacket( pPacket, pFileChannel->m_pSocket ) ;
    }
}

#if 0
BOOL
CIOFileChannel::Init(   HANDLE  hFileIn,
						HANDLE  hFileOut,
						CSessionSocket* pSocket,
						unsigned    cbInputOffset,
						unsigned    cbOutputOffset )    {
	
	//
	//	CIOFileChannel's use two CFileChannel's to support both
	//	directions of IO, and can use a separate file for each direction.
	//	This is usefull for debugging where you want to use a file to simulate
	//	a socket.
	//
	TraceFunctEnter( "CIOFileChannel::Init" ) ;

	ChannelValidate() ;

    if( !m_Reads.Init( hFileIn, pSocket, cbInputOffset, TRUE ) )
        return  FALSE ;

    if( !m_Writes.Init( hFileOut, pSocket, cbOutputOffset, FALSE ) )
        return  FALSE ;

	DebugTrace( (DWORD_PTR)this, "Successfull Initializeation size %d", sizeof( *this ) ) ;

    return  TRUE ;
}
#endif

BOOL
CIOFileChannel::Read(   CReadPacket*    pReadPacket,
						CSessionSocket* pSocket,
						BOOL    &eof )  {

	//
	//	Forward Read to appropriate member
	//

	ChannelValidate() ;

    return  m_Reads.Read(   pReadPacket,    pSocket,    eof ) ;
}

BOOL
CIOFileChannel::Write(  CWritePacket*   pWritePacket,
						CSessionSocket* pSocket,
						BOOL    &eof )  {
	//
	//	Forward Write to appropriate member
	//

	ChannelValidate() ;

    return  m_Writes.Write( pWritePacket,   pSocket, eof ) ;
}

BOOL
CIOFileChannel::Transmit(   CTransmitPacket*    pTransmitPacket,
							CSessionSocket* pSocket,
							BOOL    &eof )  {
	//
	//	Forward Transmit to appropriate member
	//

	ChannelValidate() ;

    return  m_Writes.Transmit(  pTransmitPacket,    pSocket,    eof ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\feedq.h ===
/*++

	feedq.h	
	
	This code will maintain queues of GROUPID:ARTICLEID pairs.
	We attempt to provide some robust persistence by regularily saving
	the Queue information to disk.

--*/

#ifndef _FEEDQ_H_
#define _FEEDQ_H_

#ifdef	UNIT_TEST
typedef	DWORD	GROUPID ;
typedef	DWORD	ARTICLEID ;
#define	MAX_ENTRIES	256
#define	MAX_DEAD_BLOCKS	8
#else
#define	MAX_ENTRIES	256
#define	MAX_DEAD_BLOCKS	8
#endif


//
//	A individual entry within the queue
//
struct	ENTRY	{
	GROUPID		m_groupid ;
	ARTICLEID	m_articleid ;

	inline	BOOL	operator == (	ENTRY&	rhs ) ;
	inline	BOOL	operator != (	ENTRY&	rhs ) ;
	inline	ENTRY(	GROUPID,	ARTICLEID ) ;
	inline	ENTRY() {}
} ;


//
//	Structure for keeping track of queue removal and insertion points
//
struct	HEADER	{
	DWORD		m_iRemovalPoint ;
	DWORD		m_iAppendPoint ;
} ;

//
//	Buffer of Queue ENTRY's
//
typedef		ENTRY	BLOCK[MAX_ENTRIES] ;

//
//	The CFeedQ class manages the queue entirely.
//
//	The class uses 2 CQPortion objects, 1 for managing Append() calls and
//	the other for fulfilling Remove() calls.  Each CQPortion has a fraction
//	of the Queue loaded in memory, the remainder sits in a file on the hard disk.
//	The TWO CQPortions may reference the same buffer of ENTRY's if the 
//	removal and append points are close together.
//
//
class	CFeedQ	{
private :

	//
	//	CQPortion - This is a helper class which keeps track of 
	//	'half' of the queue - ie. either the point in the queue where
	//	we are appending or the point where we are removing.
	//
	class	CQPortion	{
	public : 
		ENTRY	*m_pEntries ;
		DWORD	m_iFirstValidEntry ;
		DWORD	m_iLastValidEntry ;
	public : 
		CQPortion( ) ;

		void	Reset() ;
		BOOL	LoadAbsoluteEntry(	HANDLE	hFile,	ENTRY*	pEntry,	DWORD	iFirstValid,	DWORD	iLastValid ) ;
		void	SetEntry(	ENTRY*	pEntry,	DWORD	i ) ;
		void	SetLimits(	DWORD	i ) ;
		void	Clone( CQPortion&	portion ) ;
		BOOL	FlushQPortion(	HANDLE	hFile ) ;

		BOOL	FIsValidOffset( DWORD	i ) ;
		ENTRY&	operator[](	DWORD	i ) ;

		BOOL	GetAbsoluteEntry(	DWORD	iOneBasedOffset, ENTRY&	entry );
		BOOL	AppendAbsoluteEntry(	DWORD	iOffset,	ENTRY&	entry ) ;
		BOOL	FIsSharing(	CQPortion& ) ;
	} ;

	

	//
	//	CQPortion for location where we are appending
	//	
	CQPortion	m_Append ;

	//
	//	CQPortion for location where we are removing
	//
	CQPortion	m_Remove ;

	//
	//	if m_fShared == TRUE then m_Append and m_Remove are using the same
	//	underlying ENTRY buffer
	//
	BOOL		m_fShared ;

	//
	//	Two buffers for holding the portion of the queue we have in memory
	//
	BLOCK		m_rgBlock[2] ;

	//
	//	Index to buffer being used to hold the Removal buffer
	//	If m_fShared==FALSE then the buffer being used to hold
	//	Appends is m_iRewmoveBlock XOR 1, otherwise it is also
	//	m_iRemoveBlock
	//
	int			m_iRemoveBlock ;	// Index to block being used
									// for removals

	//
	//	Keep track of append and removal points
	//
	HEADER		m_header ;

	//
	//	Number of blocks that we have consumed through Remove() calls
	//
	DWORD		m_cDeadBlocks ;

	//
	//	The file which is backing the Queue
	//
	char		m_szFile[ MAX_PATH ] ;

	//
	//	Handle to the file backing the Queue
	//
	HANDLE		m_hFile ;

	//
	//	Critical section for synchronizing Append() operations
	//
	CRITICAL_SECTION	m_critAppends ;

	//
	//	Critical section for synchronizing Remove() operations.
	//	When both critical sections need to be held m_critRemoves must
	//	always be grabbed first .
	//
	CRITICAL_SECTION	m_critRemoves ;

	//
	//	Get rid of Dead Space in the Queue file.
	//
	BOOL	CompactQueue() ;

	//
	//	Utility functions
	//
	DWORD	ComputeEntryOffset(	DWORD	iEntry ) ;
	BOOL	InternalInit(	LPSTR	lpstrFile ) ;

public : 

	static	inline	DWORD	ComputeBlockFileOffset(	DWORD	iEntry ) ;
	static	inline	DWORD	ComputeFirstValid(	DWORD	iEntry ) ;
	static	inline	DWORD	ComputeBlockStart( DWORD iEntry ) ;

	CFeedQ() ;
	~CFeedQ() ;

	//
	//	Open the specified file if it exists and use it to 
	//	start the queue, other wise create an empty queue and save
	//	to the specified file.
	//
	BOOL	Init(	LPSTR	lpstrFile ) ;

	//
	//	Check whether the queue is empty or not !
	//
	BOOL	FIsEmpty() ;

	//
	//	Close all our handles and flush all queue info to disk.
	//
	BOOL	Close( BOOL fDeleteFile = FALSE ) ;

	//
	//	Add an entry - if FALSE is returned a fatal error occurred
	//	accessing the Queue object.
	//
	BOOL	Append(	GROUPID	groupid,	ARTICLEID	artid ) ;

	//
	//	Remove a Queue entry - if FALSE is returned a fatal error occurred
	//	manipulating the Queue file.  If the queue is empty the function 
	//	will return TRUE and groupid and artid will be 0xFFFFFFFF
	//
	BOOL	Remove(	GROUPID&	groupid,	ARTICLEID&	artid ) ;

	//
	//	Dump the Queue To Disk
	//
	BOOL	StartFlush() ;

	//
	//	Finish dumping to disk - let other threads Append() and Remove() !
	//
	void	CompleteFlush() ;
} ;
	
#endif // _FEEDQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\io.h ===
//
// io.h 
//
//	This file contains the classes implement socket IO used by the NNTP server.
//  We define classes to represent the following : 
//
//     struct OVLEXT - This is an extension to the NT OVERLAPPED structure which 
//        appends a pointer we can use to find NNTP Server data structures.
//
//     class CIO - A base class defining the interface for objects representing socket IO 
//	      operations.
//         
//        subclass CIORead - A subclass of CIO representing a socket read.
//        subclass CIOReadLine - A subclass of CIO representing a socket read which will not 
//                 complete until an entire line has been read.
//        etc.... See subclass definitions below.
//
//     Objects derived from CIO interoperate with three other objects : 
//     CSessionState's, and CBuffer's.
//
//     CSessionState represents the state of a client session.  When an IO object has 
//     completed all of the necessary operations, it will call a Complete function on the
//     CSessionState object.  The CSessionState Object can then create new IO objects
//     based on the state of the session.  
//
//  Implementation Schedule for all classes in this file : 
//      0.5 weeks
//
//  Unit Test Schedule for all classes in this file : 
//      These will be tested as part of the CSessionSocket unit testing.
//


#ifndef	_IO_H_
#define	_IO_H_


//
//	We require the following tigris class - CRefPtr, TLockQueue, CQElement 
//
#include	<limits.h>
#include	"atq.h"
#include	"filehc.h"
#include	"smartptr.h"
#include	"queue.h"
#include	"lockq.h"
#include	"cpool.h"
#include	"pcache.h"


#define	IN
#define	OUT
#define	INOUT

#ifndef	Assert
#define	Assert	_ASSERT
#endif

#ifdef	DEBUG
#define	CIO_DEBUG
#endif

//
// CPool Signature
//

#define CHANNEL_SIGNATURE (DWORD)'2597'


//---------------------------------------------------------
//
// Forward definitions
//
class	CSessionState ;
class	CIO ;
class	CIORead ;
class	CIOWrite ;
class	CIOPassThru ;
class	CChannel ;
class	CFileChannel ;
class	CIODriver ;
class	CIODriverSink ;
class	CBuffer ;
class	CPacket ;
class	CSessionSocket ;
class	CPacket ;
class	CRWPacket ;
class	CReadPacket ;
class	CWritePacket ;
class	CTransmitPacket ;
class	CControlPacket ;
class	CExecutePacket ;
#define	INVALID_SEQUENCENO	(-1)
#define	INVALID_STRMPOSITION	(-1)

#ifndef _X86_		// use LARGE_INTEGER on RISC to avoid alignment exception on __int64

typedef	LARGE_INTEGER		SEQUENCENO ;
typedef	LARGE_INTEGER		STRMPOSITION ;

#define QUAD(x)				(x).QuadPart
#define LOW(x)				(x).LowPart
#define HIGH(x)				(x).HighPart
#define ASSIGN(x,y)			(x).LowPart = (y).LowPart; (x).HighPart = (y).HighPart
#define ASSIGNI(x,y)		(x).LowPart = (y); (x).HighPart = 0
#define SETLO(x,y)			(x).LowPart = (y)
#define SETHI(x,y)			(x).HighPart = (y)
#define INC(x)				ADDI((x),1)
#define ADD( x, y )			if( ((x).LowPart) > ( ULONG_MAX - (ULONG)((y).LowPart) ) ) { (x).HighPart++;} (x).LowPart += (y).LowPart; (x).HighPart += (y).HighPart;
#define ADDI( x, y )		if( ((x).LowPart) > ( ULONG_MAX - (ULONG)(y) ) ) { (x).HighPart++;} (x).LowPart += (y)
#define DIFF( x, y, z )		(z).HighPart = (x).HighPart - (y).HighPart; (z).LowPart = (x).LowPart - (y).LowPart
#define GREATER(x,y)		(((x).HighPart == (y).HighPart) ? ((x).LowPart > (y).LowPart)  : ((x).HighPart > (y).HighPart))
#define LESSER(x,y)			(((x).HighPart == (y).HighPart) ? ((x).LowPart < (y).LowPart)  : ((x).HighPart < (y).HighPart))
#define EQUALS(x, y)		(((x).HighPart == (y).HighPart) ? ((x).LowPart == (y).LowPart) : FALSE)
#define EQUALSI(x, y)		(((x).HighPart) ? FALSE : ((x).LowPart == (y)))

#else	// use native __int64 for x86

typedef	__int64	SEQUENCENO ;
typedef	__int64 STRMPOSITION ;

#define QUAD(x)				(x)
#define LOW(x)				(x)
#define HIGH(x)				(x)
#define ASSIGN(x,y)			x = y
#define ASSIGNI(x,y)		x = y
#define SETLO(x,y)			x = y
#define SETHI(x,y)			x = y
#define INC(x)				x++
#define ADD( x, y )			x += y
#define ADDI( x, y )		x += y
#define DIFF( x, y, z )		z = x - y
#define GREATER(x,y)		(x > y)
#define LESSER(x,y)			(x < y)
#define EQUALS(x, y)		(x == y)
#define EQUALSI(x, y)		(x == y)

#endif

typedef	CRefPtr< CSessionState >	CSTATEPTR ;
typedef	CRefPtr< CSessionSocket >	CSESSPTR ;
typedef	CRefPtr< CBuffer >	CBUFPTR ;
typedef	CRefPtr< CChannel >	CCHANNELPTR ;
typedef	CRefPtr< CIODriver >	CDRIVERPTR ;
typedef	CRefPtr< CIODriverSink >	CSINKPTR ;
typedef	CRefPtr< CFileChannel >	CFILEPTR ;	
typedef	CSmartPtr< CIO >			CIOPTR ;
typedef	CSmartPtr< CIORead >		CIOREADPTR ;
typedef	CSmartPtr< CIOWrite >		CIOWRITEPTR ;
typedef	CSmartPtr< CIOPassThru >	CIOPASSPTR ;

typedef	TLockQueue<	CPacket	>	CPACKETQ ;
typedef	TOrderedList< CPacket >	CPACKETLIST ;

//
//	The CIO derived classes operate with all CIODriver 
//	classes defined in this file - to speed up allocation
//	of CIO objects we define some CIO helper classes here !
//

//
//	Constant used for CPool initialization - all CIO derived objects
//	come out of the same CPool - this is the size of the largest class !
//
extern	const	unsigned	cbMAX_IO_SIZE ;

//
//	Utility classes related to CIO - 
//	classes which let us use the CCache mechanisms to reduce 
//	thread contention when allocating CIO objects !
//
class	CCIOAllocator : public	CClassAllocator	{
//
//	This class wraps the CPool used to allocate CIO objects so that 
//	we can use the CCache classes for low contention allocation of CIO objects !
//
private : 
	//
	//	CIO knows us well
	//
	friend	class	CIO ;

	//
	//	CPool object used to allocate objects derived from CIO 
	//	
	static	CPool	IOPool ;

public : 

	CCIOAllocator() ;

	//
	//	Initialize our CPool !
	//
	static	BOOL	InitClass()	{
			return	IOPool.ReserveMemory( MAX_CHANNELS,	cbMAX_IO_SIZE ) ;
	} 

	//
	//	Terminate our CPool
	//
	static	BOOL	TermClass()	{
			_ASSERT( IOPool.GetAllocCount() == 0 ) ;
			return	IOPool.ReleaseMemory( ) ;
	}
	
	//
	//	The function which gets the memory we wish to use !
	//
	LPVOID	Allocate(	DWORD	cb,	DWORD	&cbOut = CClassAllocator::cbJunk ) {
				cbOut = cb ;	return	IOPool.Alloc() ;
	}

	//
	//	The function which releases allocated memory !
	//
	void	Release(	void*	lpv )	{	
				IOPool.Free( lpv ) ;	
	}

#ifdef	DEBUG
	void	Erase(	void*	lpv ) ;
	BOOL	EraseCheck(	void*	lpv ) ;
	BOOL	RangeCheck( void*	lpv ) ;
	BOOL	SizeCheck(	DWORD	cb ) ;
#endif

} ;

extern	CCIOAllocator	gCIOAllocator ;

class	CCIOCache	:	public	CCache	{
//
//	This class actually cache's CIO objects in the 
//	hopes that we can reduce contention against our allocator !
//
private: 
	//
	//	Keep a pointer to the CClassAllocator derived object
	//	which manages the CPool for us !
	//
	static	CCIOAllocator*	gpCIOAllocator ;

	//
	//	space to hold cache'd pointers
	//
	void*	lpv[3] ;

public : 
	//
	//	Set static pointer - can not fail !
	//
	static	void	InitClass( CCIOAllocator*	pCIOAllocator  )	{
			gpCIOAllocator = pCIOAllocator ;
	}

	//
	//	Create a cache - just let CCache do the work !
	//
	inline	CCIOCache()	:	CCache( lpv, 3 )	{}

	//
	//	Release everything that may have been in the cache !
	//
	inline	~CCIOCache()	{	Empty( gpCIOAllocator ) ;	}

	//
	//	Free a CIO objects memory to the cache if possible 
	//	
	inline	void	Free( void*	lpv )	{	CCache::Free( lpv, gpCIOAllocator ) ;	}

	//
	//	Allocate memory from the cache if possible !
	//
	inline	void*	Alloc(	DWORD	size, DWORD&	cbOut = CCache::cbJunk )	{
			return	CCache::Alloc( size, gpCIOAllocator, cbOut ) ;
	}
} ;




struct	ExtendedOverlap	{
//
//	The ExtendedOverlap structure is used by completion port threads
//	to find the CPacket Derived class which represents the IO just completed.
//	This structure will be embedded in all CPacket objects
//

	//
	//	overlapped structure passed to Atq
	//
	FH_OVERLAPPED	m_ovl ;

	//
	//	Pointer to the packet this is embedded in
	//
	CPacket*	m_pHome ;

	//
	//	Default constructor NULLS stuff out
	//
	inline	ExtendedOverlap() ;
} ;

#define	ChannelValidate()	

class	CChannel : public	CRefCount	{
//
//	This class defines the interface to be followed by 
//	derived classes for doing async IO.  The interface takes
//	packets with embedded overlapped structures which are then
//	passed to a NT Async IO call, or to a sockets call, depending
//	on what the derived class represents.
//
private : 
	//
	//	CPool for handling all allocations 
	//
	static	CPool	gChannelPool ;		// used for allocating all such objects !!

	//
	//	Debug information - the following members and functions
	//	can be used to keep track of pending IO operations.
	//
#ifdef	CIO_DEBUG
public :
	CPacket*		m_pOutReads[6] ;
	CPacket*		m_pOutWrites[6] ;

	void	RecordRead(	CReadPacket*	pRead ) ;
	void	RecordWrite(	CWritePacket*	pWrite ) ;
	void	RecordTransmit(	CTransmitPacket*	pTransmit ) ;
	void	ReportPacket(	CPacket*	pPacket ) ;
	void	CheckEmpty() ;
	CChannel() ;
#endif

public :

	//
	//	Must have a virtual destructor as these are destroyed thru pointers
	//
	virtual	~CChannel() ;

	//
	//	Derived classes will use this to cache packets 
	//
	void	DestroyPacket( CPacket *p ) ;

	//
	//	Interfaces to determine the capacity of a Channel
	//	
	virtual	BOOL	FReadChannel( ) ;
	virtual	BOOL	FSupportConnections() ;	// By Default Return TRUE Always
	virtual	BOOL	FRequiresBuffers() ;

	//
	//	Determine how much space is being reserved in the packets that
	//	are being issued.  Typically space is being reserved so that 
	//	a filter (ie SSL) can do in place modifications (encryption) of the data.
	//
	virtual	void	GetPaddingValues(	unsigned	&cbFront,	unsigned	&cbTail ) ;

	//
	//	Close the underlying handle
	//
	virtual	void	CloseSource(	
							CSessionSocket*	pSocket	
							) ;

#ifdef	CIO_DEBUG
	virtual	void	SetDebug( DWORD	dw ) ;
#endif

	//
	//	Class Initialization - reserve CPool Memory
	//
	static	BOOL	InitClass() ;

	//
	//	Class Termination - release CPool Memory
	//	
	static	BOOL	TermClass() ;

	//
	//	Allocate memory for Channel's from CPool
	//
	inline	void*	operator	new( size_t	size ) ;

	//
	//	Release CChannel's memory to CPool
	//
	inline	void	operator	delete( void *pvv ) ;

	//
	//	The following interface is used to issue IO operations against a channel
	//

	//
	//	Issue an async read - CReadPacket contains the overlapped structure
	//
	virtual	BOOL	Read(	CReadPacket*,	CSessionSocket*, BOOL &eof ) = 0 ;

	//
	//	Issue a sync or async write.  Regardless of how the write is handled
	//	the completion should happen as if async.
	//	(ie. for CSocketChannel's where we may optimize writes by doing 
	//	blocking writes)
	//
	virtual	BOOL	Write( CWritePacket*,	CSessionSocket*, BOOL &eof ) = 0 ;

	//
	//	Issue an async TramsitFile
	//
	virtual	BOOL	Transmit(	CTransmitPacket*,	CSessionSocket*, BOOL &eof ) = 0 ;

	//
	//	Send timeout message to remote end !
	//
	virtual	void	Timeout( ) ;

	//
	//	Make sure Timeout processing continues
	//	
	virtual	void	ResumeTimeouts() ;

} ;


#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC(	CChannel ) 

#endif


//	@class	The CHandleChannel class manages generic NT Handles and allows us to issue 
//	all operations against them (EXCEPT Transmit())
//
//
class	CHandleChannel : public	CChannel	{
protected : 
	//
	//	Number of async writes.  For derived classes which wish to optimize writes
	//	by mixing async and sync versions.
	//
	long	m_cAsyncWrites ;	

	//
	//	The NT handle (Socket of File handle)
	//
	HANDLE	m_handle ;		// NT Handle

	//
	//	m_lpv holds a 'context' that we will pass to ProcessPacket when completing packets.
	//	(this is usually a CSessionSocket pointer)
	//
	void	*m_lpv ;

	//
	//	If a TransmitFile is issued we have to hack around Gibraltars poor support in AtqTransmitFile
	//	this is used for that
	//
	CTransmitPacket*	m_pPacket ;

	//
	//	The ATQ context we are using.
	//
	PATQ_CONTEXT	m_patqContext ;		// ATQ Context 
	//	The follwoing is the completion function we pass to ATQ
	friend	VOID ServiceEntry( DWORD cArgs, LPWSTR pArgs[], PTCPSVCS_GLOBAL_DATA    pGlobalData );	

	//
	//	Function we register with ATQ to get completion notifications.
	//
	static	void	Completion( CHandleChannel*, 
								DWORD cb, 
								DWORD dwStatus, 
								ExtendedOverlap *peo 
								) ;
#ifdef	CIO_DEBUG
	BOOL	m_fDoDebugStuff ;
	DWORD	m_cbMax ;
#endif
public :
	CHandleChannel() ; 
	~CHandleChannel() ;

	//
	//	Init sets up the Atq completion context and gets us ready to go
	//
	virtual	BOOL	Init(	BOOL	BuildBreak,
							HANDLE	h,	
							void	*lpv, 
							void *patqContext = 0,
							ATQ_COMPLETION pfn = (ATQ_COMPLETION)CHandleChannel::Completion 
							) ;

	//
	//	Close() merely releases our Atq context stuff
	//
	virtual	void	Close() ;

	//
	//	CloseSource() will close the underlying handle and force IO's to complete
	//
	void			CloseSource(	
							CSessionSocket*	pSocket 
							) ;

	//
	//	ReleaseSource() will give us the handle for our use, and will enable us to 
	//	tear things down without invalidating the handle
	//
	HANDLE			ReleaseSource() ;

	//
	//	For debug - check everything looks good.
	//
	virtual	BOOL	IsValid() ;

#ifdef	CIO_DEBUG
	void	SetDebug(	DWORD	dw ) ;

#endif

	//
	//	Map CReadPackets onto calls to AtqRead()
	//
	BOOL	Read(	CReadPacket*, CSessionSocket*, BOOL &eof ) ;
	
	//
	//	Map CWritePackets onto calls to AtqWriteFile()
	//
	BOOL	Write(	CWritePacket*,	CSessionSocket*, BOOL &eof ) ;

	//
	//	Map CTransmitPackets onto calls to AtqTransmitFile
	//
	BOOL	Transmit(	CTransmitPacket*,	CSessionSocket*, BOOL &eof ) ;
} ;

//
//	CSocketChannel - 
//	This is used to manage IO to a socket.
//	Our main addition beyond what CHandleChannel does is to provide support for 
//	mixing synchronous and async writes - NOTE : CIODriver as an extra function 
//	CompleteWritePacket which also helps to support sync. writes.
//
class	CSocketChannel	:	public	CHandleChannel	{
private : 
	//
	//	Are we doing Non blocking writes ?
	//
	BOOL	m_fNonBlockingMode ;

	//
	//	Size of the kernel buffers for this socket
	//
	int		m_cbKernelBuff ;
public : 	
	CSocketChannel() ;
	void			CloseSource(
							CSessionSocket*	pSocket
							) ;

	//
	//	Must initialize before use.  We use the same completion function as CHandleChannel.
	//
	BOOL	Init( HANDLE	h,	void	*lpv, void *patqContext = 0,
						ATQ_COMPLETION pfn = (ATQ_COMPLETION)CHandleChannel::Completion ) ;

	//
	//	Override Write() so that we can try blocking IO.
	//
	BOOL	Write(	CWritePacket*,	CSessionSocket*	pSocket,	BOOL&	eof ) ;

	//
	//	Do a blocking send of our Timeout() message.
	//
	void	Timeout() ;

	//
	//	Multiple IO's to gibraltar can cause timeouts to be lost - use this to recover that.
	//
	void	ResumeTimeouts() ;
} ;

//
//	CFileChannel - 
//	this class manages one direction of flow to a NT File.
//	(ie. you can only use it for Reads, or Writes but not both !!)
//
class	CFileChannel	:	public	CChannel	{
private : 
	//
	//	Number of async writes.  For derived classes which wish to optimize writes
	//	by mixing async and sync versions.
	//
	long	m_cAsyncWrites ;	

	//
	//	m_lpv holds a 'context' that we will pass to ProcessPacket when completing packets.
	//	(this is usually a CSessionSocket pointer)
	//
	void	*m_lpv ;

	//
	//	This holds the File Cache Context that we use to do operations !
	//
	FIO_CONTEXT*	m_pFIOContext ;

	//
	//	This holds the File Cache Context that we release in our destruction !
	//
	FIO_CONTEXT*	m_pFIOContextRelease ;

	//
	//	Initial byte offset within the file that we will start reading 
	//	or writing
	//
	unsigned	m_cbInitialOffset ;
	
	//
	//	Current position in the file - we track this as we will modify
	//	the OVERLAPPED structure of async IO's against a file to specify
	//	exactly where the IO should happen
	//
	unsigned	m_cbCurrentOffset ;

	//
	//	Maximum number of bytes we can transfer to/from the file
	//
	unsigned	m_cbMaxReadSize ;

	//
	//	Socket associated with all this IO
	//
	CSessionSocket*	m_pSocket ;

	//
	//	Are we Reading or Writing to the file ?
	//
	BOOL		m_fRead ;

	//
	//	This lock protects access to m_pFIOContext !
	//
	CShareLockNH	m_lock ;

	
#ifdef	CIO_DEBUG
	long		m_cReadIssuers ;		// Number of people doing read operations
	long		m_cWriteIssuers ;		// Number of people doing Write operations
#endif	// CIO_DEBUG

	//	We use our own completion function !!
	static	void	Completion(	FIO_CONTEXT*	pFIOContext, 
								ExtendedOverlap *peo,
								DWORD cb, 
								DWORD dwStatus
								) ;
public :
	CFileChannel() ;
	~CFileChannel() ;
	
	//
	//	Init function - set up ATQ context etc...
	//	NOTE : cbOffset lets us reserve space in the front of the file when doing writes, 
	//	or start reads from an arbitrary position.
	//
	BOOL	Init(	FIO_CONTEXT*	pContext,	
					CSessionSocket*	pSocket, 
					unsigned	cbOffset,	
					BOOL	fRead  = TRUE,
					unsigned	cbMaxBytes = 0
					) ;

	//
	//	CloseSource() will close the underlying handle and force IO's to complete
	//
	void			
	CloseSource(	
			CSessionSocket*	pSocket 
			) ;

	//
	//	File Channels manage these FIO_CONTEXT structures
	//	instead of ATQ thing'a'ma'jigs.
	//
	FIO_CONTEXT*
	ReleaseSource() ;

	//
	//	Closing CFileChannel's needs special work as ATQ is setup to only handle sockets.
	//
	void	Close() ;
	BOOL	FReadChannel( ) ;

	//
	//	Get initial file offset
	//
	DWORD	InitialOffset()		{	return	m_cbInitialOffset ;	}

	//
	//	Reset() lets us start reading from the beginning again.
	//
	BOOL	Reset(	BOOL	fRead,	unsigned	cbOffset = 0 ) ;

	//
	//	Read and Write to the file.
	//
	BOOL	Read(	
					CReadPacket*, 
					CSessionSocket*,	
					BOOL	&eof 
					) ;

	BOOL	Write(	
					CWritePacket*,	
					CSessionSocket*, 
					BOOL	&eof 
					) ;

	//
	//	TransmitFile is non-functional for CFIleChannel's
	//
	BOOL	Transmit(	
					CTransmitPacket*,	
					CSessionSocket*,	
					BOOL	&eof 
					) ;

	//
	//	Map down to NT's FlushFileBuffers()
	//
	inline	void	FlushFileBuffers() ;
} ;


#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CFileChannel ) 

#endif


//
//	CIOFileChannel - 
//	Contains two CFileChannel's, can two file IO's in both
//	directions - would be weird if done at same time !
//
class	CIOFileChannel	:	public	CChannel	{
private : 
	CFileChannel	m_Reads ;
	CFileChannel	m_Writes ;
public : 

	BOOL	Init(	HANDLE	hFileIn,	HANDLE	hFileOut,	CSessionSocket*	pSocket, 
						unsigned cbInputOffset = 0, unsigned cbOutputOffset=0 ) ;
	BOOL	Read(	CReadPacket*,	CSessionSocket*,	BOOL	&eof ) ;
	BOOL	Write(	CWritePacket*,	CSessionSocket*,	BOOL	&eof ) ;
	BOOL	Transmit(	CTransmitPacket*,	CSessionSocket*,	BOOL	&eof ) ;
} ;



//
//	Enumerate the possible reasons a session can be torn down.
//
enum	SHUTDOWN_CAUSE	{
	CAUSE_UNKNOWN = 0,
	CAUSE_FORCEOFF,			// Admin is trying to shut us down
	CAUSE_ILLEGALINPUT,		// We got stuff that we can't make sense of 
	CAUSE_USERTERM,			// User terminated politely (ie. quit command.)
	CAUSE_TIMEOUT,			// Session Timed Out
	CAUSE_LEGIT_CLOSE,		// Somebody killed it for a good reason !
	CAUSE_NODATA,			// Killed for a good reason, but before we accomplished anything
	CAUSE_IODRIVER_FAILURE,	// A CIODriver object failed to initialize
	CAUSE_PROTOCOL_ERROR,	// We got a bad return code upon issuing a NNTP command
	CAUSE_OOM,				// Out of Memory
	CAUSE_NTERROR,			// Hit an error on a call to NT 
	CAUSE_NORMAL_CIO_TERMINATION,	// For use by CIO objects which want to know when they're dieing gracefully !!
	CAUSE_FEEDQ_ERROR,		// Hit an error processing the feed Queue
	CAUSE_LOGON_ERROR,		// We were unable to logon to remote server!
	CAUSE_CIOREADLINE_OVERFLOW,	//	CIOReadLine was given too much data - the command line is too long !
	CAUSE_ARTICLE_LIMIT_EXCEEDED,	// A CIOReadArticle got more bytes for an article than the server allows !
	CAUSE_ENCRYPTION_FAILURE,	// Failed to encrypt something
	CAUSE_ASYNCCMD_FAILURE,		// Something went wrong with an Async Command !
	CAUSE_SERVER_TIMEOUT	// A Timeout occurred on a session we initiated - don't send 502 Timeout !!
} ;



class		CStream	{
//
//	This class keeps track of one direction of IO.
//	ie. We can use this to keep track of all the reads we are issuing, or we may use this to keep
//	track of all the rights we are issuing (to either a socket or a file).
//
//
private : 
	friend	class	CControlPacket ;
	CStream() ;		// Not allowed to build these without providing ID !
public : 
	//
	//	like these up front just for convenience of debugging
	//
	unsigned	m_index ;
	unsigned	m_age ;
	CDRIVERPTR	m_pOwner ;			// The CIODriver derived object we are contained in !
protected : 
	inline	CStream( unsigned	index	) ;	// Derive classes may construct 
	virtual		~CStream( ) ;
	#ifdef	CIO_DEBUG
	DWORD		m_dwThreadOwner ;		// The threadid of the thread processing packets
	long		m_cThreads ;			// Only one thread can be processing Packets
	long		m_cSequenceThreads ;	// Only one thread can be assigning outgoing sequence numbers
	#endif	// CIO_DEBUG

	#ifdef	CIO_DEBUG
	long		m_cThreadsSpecial ;	//Number of threads attempting to use special packet !!
	long		m_cNumberSends ;
	#endif
	CControlPacket*	m_pSpecialPacket ;	// Special Packet reserved for doing control operations !!!
	CControlPacket*	m_pSpecialPacketInUse ;

	long			m_cShutdowns ;		// Count of the number of times we have tried to shutdown the stream.
	CControlPacket*	m_pUnsafePacket ;	// Special Packet reserved for closing the session down - for use by
										// forcefull shutdowns only.
	CControlPacket*	m_pUnsafeInuse ;
	BOOL		m_fTerminating ;

	// The following memeber variables are common to both CIOStream and CIStream !!!!
	// The usage of these is slightly different, see the ProcessPacket calls !!
	BOOL		m_fRead ;		// If TRUE then only read and control packets can be issued
								// If False then only writes, transmits and control packets can be issued
	BOOL		m_fCreateReadBuffers ;	// If TRUE then we must allocate a Buffer for all CReadPackets which 
								// we pass to the m_pSouceChannel !
	CPACKETQ	m_pending ;		// The Queue of recently IO operations
	CPACKETLIST	m_completePackets ;		// A list sorted by sequenceno used to order packet arrival
	SEQUENCENO	m_sequencenoIn ;// The sequenceno of the packet we are waiting for
	STRMPOSITION	m_iStreamIn ;	// The stream position of the next packet we are waiting for
	SEQUENCENO	m_sequencenoOut ;	// The sequenceno of the next packet we will issue
	CCHANNELPTR	m_pSourceChannel ;	// The channel to which we forward Read, Write and Transmit operations
	unsigned	m_cbFrontReserve ;	// Padding to save in front of buffers for SourceChannel's benefit
	unsigned	m_cbTailReserve ;	// Padding to save in tail of buffers for SourceChannel's benefit
	void		CleanupSpecialPackets() ;

public : 

	//
	//	The interface below corresponds very closely to the interface for CIODriver.
	//	
	//	A CIODriver will forward each call to 1 of 2 CStream derived objects.
	//	(Depending on whether a request is a read or a write.)
	//

	virtual	BOOL	IsValid() ;	// Can only be called after calling Child Initialization


	BOOL	Init(	CCHANNELPTR&	pChannel, 
					CIODriver	&driver, 
					BOOL fRead, 
					CSessionSocket* pSocket, 
					unsigned	cbOffset,
					unsigned	cbTrailer = 0 
					) ;

	//
	//	When we want to set up an extra layer of processing - ie.
	//	SSL encryption, use this to get it going.
	//
	void	InsertSource(	
					class	CIODriverSource&	source, 
					CSessionSocket*	pSocket, 
					unsigned	cbAdditional,
					unsigned	cbTrailer
					) ;

	virtual	BOOL	Stop( ) ;

	//
	//	ProcessPacket - this function will do everything to make sure IO's are processed in the 
	//	correct order etc... For any packet that has completed
	//
	virtual	void	ProcessPacket(	
						CPacket*	pPacket,	
						CSessionSocket*	pSocket 
						) = 0 ;

	//
	//	The following functions will call the appropriate 
	//	function in the source channel interface
	//	(Read() or Write() or Transmit() derived from CChannel).
	//	The main thing they do to the packet before doing this
	//	is to give the packet a sequence number to ensure
	//	IO's are processed in the correct order upon completion.
	//
	
	//
	//	Call Read() on the underlying CChannel object
	//
	inline	void	IssuePacket( 
						CReadPacket	*pPacket,	
						CSessionSocket*	pSocket,	
						BOOL&	eof 
						) ;

	//
	//	Call Write() on the underlying CChannel object
	//
	inline	void	IssuePacket( 
						CWritePacket	*pPacket,	
						CSessionSocket*	pSocket,	
						BOOL&	eof 
						) ;

	//
	//	Call Transmit() on the underlying CChannel object
	//
	inline	void	IssuePacket( 
						CTransmitPacket	*pPacket,	
						CSessionSocket*	pSocket,	
						BOOL&	eof 
						) ;

	//
	//	The following functions should be the only way that Packet's are created - 
	//	they initialize the packets correctly so that all our reference counting etc...
	//	will be correct.	
	//	They also take care that if the underlying CChannel is doing extra
	//	processing (ie. encryption) that the packet is set up so this can
	//	be done in place.
	//

	//
	//	Create a Read that can hold at least cbRequest bytes
	//
	CReadPacket*	CreateDefaultRead(	
						CIODriver&,	
						unsigned	int	cbRequest
						) ;

	//
	//	Create a write using the specified buffer and offsets 
	//
	CWritePacket*	CreateDefaultWrite(	
						CIODriver&,	
						CBUFPTR&	pbuffer,	
						unsigned	ibStart,		
						unsigned	ibEnd,
						unsigned	ibStartData,	
						unsigned	ibEndData
						) ;

	//
	//	Create a write that will hold at least cbRequest bytes
	//
	CWritePacket*	CreateDefaultWrite(	
						CIODriver&,	
						unsigned	cbRequest 
						) ;

	//
	//	Create a Transmit packet that will hold use the specified file
	//
	CTransmitPacket*	CreateDefaultTransmit(	
							CIODriver&,	
							FIO_CONTEXT*	pFIOContext,	
							unsigned	ibOffset,	
							unsigned	cbLength 
							) ;

	//
	//	This function will build a control packet which will get the CIO object started.
	//
	inline	BOOL	SendIO(	
							CSessionSocket*	pSocket,	
							CIO&	pio,	
							BOOL	fStart 
							) ;

	//
	//	This function will prepare a control packet for our use !
	//
	inline	CControlPacket*	
					PrepForSendIO(
							CSessionSocket*	pSocket, 
							CIO&	pio,
							BOOL	fStart
							) ;

#ifdef	RETIRED
	inline	void	Shutdown(	CSessionSocket*	pSocket, BOOL	fCloseSource = TRUE ) ;
#endif

	//
	//	Whenever we want to wind down processing call UnsafeShutdown().  This will 
	//	ensure that all our packets etc... are destroyed etc...
	//
	inline	void	UnsafeShutdown( 
							CSessionSocket*	pSocket, 
							BOOL fCloseSource = TRUE 
							) ;

	//
	//	Release the current CIO object and set the state so all pending packets
	//	are swallowed
	//
	virtual	void	SetShutdownState(	
							CSessionSocket*	pSocket, 
							BOOL fCloseSource 
							) = 0 ;


	//
	//	The following functions are used to setup SSL sessions.
	//
	inline	CChannel&	GetChannel()	{	return	*m_pSourceChannel ; }
	inline	unsigned	GetFrontReserve()	{	return	m_cbFrontReserve ; }
	inline	unsigned	GetTailReserve()	{	return	m_cbTailReserve ; }	
	inline	void		ResumeTimeouts()	{	if( m_pSourceChannel != 0 ) { m_pSourceChannel->ResumeTimeouts() ; } }

#ifdef	CIO_DEBUG
	void	SetChannelDebug( DWORD	dw ) ;
#endif
} ;


class		CIOStream : public	CStream 	{
//
//	A CIOStream object is for use in CIODriverSource objects - such an object
//	processes both request and completion packets.
//
	friend	class	CControlPacket ;
public : 
	CPACKETLIST	m_requestPackets ;
	CPACKETLIST	m_pendingRequests ;	// list of request packets
	SEQUENCENO	m_sequencenoNext ;
	BOOL		m_fAcceptRequests ;
	BOOL		m_fRequireRequests ;

	//
	//	Index 0 - reads
	//	Index 1 - writes
	//	Index 2 - TransmitFiles
	//
	CIOPASSPTR	m_pIOFilter[3] ;

	//CPacket*	m_pCurRequest ;		// The current request packet !
	class	CIODriverSource*	m_pDriver ;
	//class	CSessionSocket*		m_pSocket ;
public : 

	CIOStream(	
				class	CIODriverSource*	pDriver,	
				unsigned	index	
				) ;

	~CIOStream() ;

	BOOL	IsValid() ;			// Can only be called after Initialization

	//
	//	There is only one current CIOPassThru object.
	//
	CIOPASSPTR	m_pIOCurrent ;

	//
	//	Initialize a CIOStream object
	//
	BOOL	Init( 
				CCHANNELPTR&	pChannel, 
				CIODriver	&driver, 
				CIOPassThru* pInitial, 
				BOOL fRead, 
				CIOPassThru&	pIOReads,
				CIOPassThru&	pIOWrites,
				CIOPassThru&	pIOTransmits,
				CSessionSocket* pSocket, 
				unsigned	cbOffset 
				) ;

	//
	//	Process a completed IO or a control packet
	//
	void	ProcessPacket( 
				CPacket*	pPacket, 
				CSessionSocket*	pSocket 
				) ;

	//
	//	Set the Stream into a state which will swallow all IO's
	//	and eventually destroy the object.
	//
	void	SetShutdownState(	
				CSessionSocket*	pSocket, 
				BOOL fCloseSource 
				) ;
} ;


class	CIStream : public CStream	{
//
//	A CIStream object if for use by CIODriverSink objects - such an object processes
//	only completions
//

public : 
	friend	class	CControlPacket ;

	//
	//	There is only every 1 CIO operation current
	//
	CIOPTR		m_pIOCurrent ;

	CIStream(	unsigned	index	) ;
	~CIStream( ) ;

	//
	//	Initialize a CIStream has one of two directions
	//	(outbound data - writes and transmitfiles, inbound - reads)
	//
	BOOL	Init( 
					CCHANNELPTR&	pChannel, 
					CIODriver	&driver, 
					CIO* pInitial, 
					BOOL fRead, 
					CSessionSocket* pSocket, 
					unsigned	cbOffset,
					unsigned	cbTrailer = 0
					) ;

	//
	//	Process an IO completion 
	//
	void	ProcessPacket( 
					CPacket*	pPacket,	
					CSessionSocket*	pSocket 
					) ;

	//
	//	Set the current CIO to something that will eat all remaining IO,
	//	and prepare the CIODriver for its doom
	//
	void	SetShutdownState(	
					CSessionSocket*	pSocket, 
					BOOL fCloseSource 
					) ;
} ;



//
//	Shutdown Notification function - 
//	This is the signature of the function a CIODriver will
//	call when it is about to be destoyed.
//	CSessionSocket's and others use this to figure out 
//	when to do their own destruction.
//
typedef	void	(*	PFNSHUTDOWN)(	
						void*,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptionalError 
						) ;



//
//	The CIODriver class is a base class derived from CChannel which is used
//	to build objects which process IO Completions AND also want to issue operations
//	against this object !!
//
class	CIODriver : public	CChannel	{
private: 
	//
	//	The constructor's and operators are private as we don't
	//	want people to copy CIODriver's
	//
	CIODriver() ;
	CIODriver( CIODriver& ) ;
	CIODriver&	operator=( CIODriver& ) ;

	//
	//	Number of CMediumBufferCache's pointed to by pMediumCaches
	//
	static	DWORD		cMediumCaches ;
	//
	//	Index of the Cache that should be used next time a CIODriver is created
	//
	static	DWORD		iMediumCache ;
	//
	//	Cache's allocated by CIODriver::InitClass()
	//
	static	class		CMediumBufferCache*	pMediumCaches ;

protected : 
	//
	//	Create a CIODriver, using a specified Cache
	//	NOTE : this is protected, as we want people to only
	//	create objects derived from CIODriver.
	//
	CIODriver(	class	CMediumBufferCache*	) ; 

	//
	//	We have a lot of friends !! - People who need to know about the classes
	//	we declare within !
	//
	friend	void	CHandleChannel::Completion( CHandleChannel*, DWORD cb, 
						DWORD dwStatus, ExtendedOverlap *peo ) ;
	friend	void	CFileChannel::Completion(	
								FIO_CONTEXT*, 
								ExtendedOverlap *peo,
								DWORD cb, 
								DWORD dwStatus
								) ;

	
	friend	class	CPacket ;
	friend	class	CStream ;
	friend	class	CIStream;
	friend	class	CIOStream ;


	//
	//	ALL CIODriver's share this one CIO object to do all the 
	//	IO processing when being shutdown.
	//
	static	class	CIOShutdown	shutdownState ;

	//
	//	The CStream derived object which handles reads 
	//
	CStream*	m_pReadStream ;

	//
	//	The CStream derivied object which handles writes
	//
	CStream*	m_pWriteStream ;

	//
	//	Function to call when we are finally destroyed - and some 
	//	arguments to pass to that function
	//
	PFNSHUTDOWN	m_pfnShutdown ;
	void*		m_pvShutdownArg ;
	long		m_cShutdowns ;


	//
	//	We keep some caches of recently used buffers etc... to avoid unnecessary 
	//	block calls to CPool's
	//
	CPacketCache		m_packetCache ;
	CSmallBufferCache	m_bufferCache ;
	CMediumBufferCache	*m_pMediumCache ;
	

#ifdef	CIO_DEBUG
	//
	//	The debug variables will be used in _ASSERT's sprinkled throughout the code.
	//

	//
	//	Ensure only one thread is doing something
	//
	long		m_cConcurrent ;

	//
	//	Ensure our interfaces are called only after we've been successfully initialized
	//
	BOOL		m_fSuccessfullInit ;

	//
	//	Ensure that we have been terminated when we do shutdown stuff.
	//
	BOOL		m_fTerminated ;
#endif


	static	void	SourceNotify(	
							CIODriver*	pdriver,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dwOpt 
							) ; 

public : 

	//
	//	Initialize this class - this sets up all of our Caching
	//
	static	BOOL	InitClass() ;

	//
	//	Terminate the class - dump out our global caches.
	//
	static	BOOL	TermClass() ;


	//
	//	These should only be accessed by member functions -
	//	Some C++ problems on some platforms with making these accessible to 
	//	CIStream etc... force us to put them here.
	//
	SHUTDOWN_CAUSE	m_cause ;
	DWORD		m_dwOptionalErrorCode ;

	//
	//	Cache for allocating CIO objects !
	//
	CCIOCache	m_CIOCache ;
	
#ifdef	CIO_DEBUG
	//
	//	For debug we override the usual AddRef and RemoveRef so we can get extra tracing
	//	for reference counting problems.
	//
	LONG	AddRef() ;
	LONG	RemoveRef() ;
#endif	

	BOOL	FIsStream( CStream*	pStream ) ;
	virtual	~CIODriver() ;	


	//
	//	The following Interfaces are for the IO operations which execute within our 
	//	framework !!
	//

	//
	//	STOP all IO's and tear everything down !!
	//
	void	Close(	CSessionSocket*	pSocket, SHUTDOWN_CAUSE	cause,	DWORD	dwOptional = 0, BOOL fCloseSource = TRUE ) ;
	void	UnsafeClose(	CSessionSocket*	pSocket,	SHUTDOWN_CAUSE	cause,	DWORD	dwOptional = 0, BOOL fCloseSource = TRUE ) ;


	//
	//	Interface for issuing reads writes and TransmitFiles.
	//
	//	This functions call a matching function on either our 
	//	m_pWriteStream or m_pReadStream CStream objects.
	//
	//	Do a read - redirect this to IssuePacket for our internal m_pReadStream
	//
	inline	void	IssuePacket( 
							CReadPacket	*pPacket,	
							CSessionSocket*	pSocket,	
							BOOL&	eof 
							) ;

	//
	//	Write a packet - call IssuePacket for our internal m_pWriteStream
	//
	inline	void	IssuePacket( 
							CWritePacket	*pPacket,	
							CSessionSocket*	pSocket,	
							BOOL&	eof 
							) ;

	//
	//	Transmit a file - call IssuePacket for our internal m_pWriteStream
	//
	inline	void	IssuePacket( 
							CTransmitPacket	*pPacket,	
							CSessionSocket*	pSocket,	
							BOOL&	eof 
							) ;

	//
	//	Let the CIODriver create all the packets - it keeps a Cache and also 
	//	wants to set things up to reserve space in buffers for SSL encryption etc...
	//	All of the CPacket derived objects created by these functions will have 
	//	a smartptr back to us, and are all set to be issued.
	//
	//	Create a read which can handle at least cbRequest bytes (maybe more!)
	//
	inline	CReadPacket*	CreateDefaultRead( 
								unsigned cbRequest
								) ;

	//
	//	Create a write which will send the specified buffer
	//
	inline	CWritePacket*	CreateDefaultWrite( 
								CBUFPTR&	pbuffer, 
								unsigned	ibStart,	
								unsigned	ibEnd,
								unsigned	ibStartData,	
								unsigned	ibEndData 
								) ;

	//
	//	Create a write packet which can hold at least cbRequired bytes,
	//	although we have yet to fill those bytes in
	//
	inline	CWritePacket*	CreateDefaultWrite(	
								unsigned	cbRequired 
								) ;

	//
	//	Create a write packet we can use to write the bytes we have 
	//	in the completed read packet.
	//
	inline	CWritePacket*	CreateDefaultWrite(	
								CReadPacket*	pRead 
								) ;

	//
	//	Create a Transmit File packet
	//
	inline	CTransmitPacket*	CreateDefaultTransmit(	
									FIO_CONTEXT*	pFIOContext,	
									DWORD	cbOffset,	
									DWORD	cbLength 
									) ;

	//
	//	Create an Execute Packet 
	//
	inline	CExecutePacket*	
	CreateExecutePacket() ;

	//
	//	Process an Execute Packet !
	//
	inline
	void
	ProcessExecute(	CExecutePacket*	pExecute,	
					CSessionSocket*	pSocket 
					) ;


	//
	//	Get the cache being used by one CIODriver, so that we can make
	//	another CIODriver use the same cache
	//
	class	CMediumBufferCache*	GetMediumCache()	{	return	m_pMediumCache ;	}

	//
	//	Allocate a buffer using our cache !
	//
	inline	CBuffer*	AllocateBuffer( DWORD	cbBuffer ) ;


	//
	//	If you have a CIO derived object you want to do something, you need to sent it - 
	//	this will result in all the necessary packets being created and issued.
	//
	inline	BOOL	SendReadIO(	
							CSessionSocket*	pSocket,	
							CIO&		pRead,	
							BOOL fStart = TRUE 
							) ;

	//
	//	Make the specified CIO the current CIO for the write stream
	//
	inline	BOOL	SendWriteIO(
							CSessionSocket*	pSocket,	
							CIO&		pWrite,	
							BOOL fStart = TRUE 
							) ;

	//
	//	If you want an intermediate CIODriverSource object to massage each packet - call this guy !
	//
	//
	BOOL	InsertSource(	
					CIODriverSource&	source,	
					CSessionSocket*	pSocket,
					unsigned	cbReadOffset,	
					unsigned	cbWriteOffset, 
					unsigned	cbTailReadReserve,
					unsigned	cbTailWriteReserve,
					CIOPassThru&	pIOReads,
					CIOPassThru&	pIOWrites,
					CIOPassThru&	pIOTransmits,
					CIOPASSPTR&	pRead,	
					CIOPASSPTR&	pWrite 
					) ;

	//
	//	For use by Source Channel's which can optimize write completions 
	//
	inline	void	CompleteWritePacket(	CWritePacket*	pWritePacket,	CSessionSocket*	pSocket ) ;

	//
	//	To determine how many bytes this CIODriver is reserving in packets
	//
	void	GetReadReserved(	DWORD&	cbFront,	DWORD&	cbTail )		{	
				cbFront = m_pReadStream->GetFrontReserve(); 
				cbTail = m_pReadStream->GetTailReserve() ; 
			}

	void	GetWriteReserved(	DWORD&	cbFront,	DWORD&	cbTail )	{	
				cbFront = m_pWriteStream->GetFrontReserve(); 
				cbTail = m_pWriteStream->GetTailReserve() ; 
			}

	//
	//	This will release the packet to our cache etc...
	//
	void		DestroyPacket(	CPacket*	pPacket ) ;
	

#ifdef	CIO_DEBUG
	void	SetChannelDebug( DWORD	dw ) ;
#endif
} ;

#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CIODriver ) 

#endif


//
//	There are special 'control' packets which we circulate through CIODriver;s
//	(on top of the usual Read Writes and Transmits)
//	These can have one of two functions - either signal that its time to terminate
//	or make a new CIO derived object active.
//
//
enum	CONTROL_TYPES	{
	ILLEGAL		= 0,
	START_IO	= 1,
	SHUTDOWN	= 2,
} ;


//
//	This structure will be embedded in CControlPackets - 
//	This carries all the information we need when we want to start a new CIO object
//
//
struct	ControlInfo	{
	CONTROL_TYPES	m_type ;

	CIOPTR			m_pio ;
	CIOPASSPTR		m_pioPassThru ;
	BOOL			m_fStart ;

	BOOL			m_fCloseSource ;

	ControlInfo() : m_type(ILLEGAL)	{
		m_fStart = FALSE ;
		m_fCloseSource = FALSE ;
	}
} ;		

//
//	CIODriverSource - 
//	Used for SSL processing.  A CIODriverSource will issue IO's to a lower level
//	object as well as get requests from a CIODriverSink.
//
class	CIODriverSource : public	CIODriver	{
protected : 
	//
	//	Stream used to process reads
	//
	CIOStream	m_ReadStream ;

	//
	//	Stream used to process Writes and TransmitFiles
	//
	CIOStream	m_WriteStream ;

public : 
	CIODriverSource( 
				class	CMediumBufferCache*	pCache
				) ;

	~CIODriverSource() ;

	//
	//	Most of the below functions override virtual functions in the CChannel class ...
	//


	BOOL	Init(	
				CChannel*	pSource, 
				CSessionSocket*	pSocket,	
				PFNSHUTDOWN	pfnShutdown, 
				void*	pvShutdownArg, 
				CIODriver*		driverOwner,
				CIOPassThru&	pIOReads,
				CIOPassThru&	pIOWrites,
				CIOPassThru&	pIOTransmits,
				unsigned	cbReadOffset = 0,	
				unsigned	cbWriteOffset = 0 
				) ;

	BOOL	Start(	
				CIOPASSPTR&	pRead,	
				CIOPASSPTR&	pWrite,	
				CSessionSocket*	pSocket 
				) ;

	//
	//	Occasionally we need to make copies of some packets - here are some convenient functions for 
	//	doing so.
	//
	//
	inline	CReadPacket*	Clone(	CReadPacket *pRead ) ;
	inline	CWritePacket*	Clone(	CWritePacket*	pWrite ) ;
	inline	CTransmitPacket*	Clone(	CTransmitPacket*	pTransmit ) ;


	//
	//	This is the interface that will be called when somebody has a packet they want encrypted 
	//	or whatever.
	//
	BOOL	Read(	
				CReadPacket*,	
				CSessionSocket	*pSocket, 
				BOOL	&eof 
				) ;

	BOOL	Write(	
				CWritePacket*,	
				CSessionSocket	*pSocket, 
				BOOL	&eof 
				) ;

	BOOL	Transmit(	
				CTransmitPacket*,	
				CSessionSocket*	pSocket, 
				BOOL	&eof 
				) ;

	//void	GetPaddingValues(	unsigned	
	void	SetRequestSequenceno(	
				SEQUENCENO&	sequencenoRead,	
				SEQUENCENO&	sequencenoWrite 
				) ;

	void	CloseSource(
				CSessionSocket*	pSocket
				) ;

	
} ;


//
//	CIODriverSink
//
//
class	CIODriverSink : public	CIODriver	{
protected : 
	CIStream	m_ReadStream ;
	CIStream	m_WriteStream ;

public : 
	BOOL	FSupportConnections() ;		// return FALSE always

	void	CloseSource(	
					CSessionSocket*	pSocket	
					) ;

	//
	// Following All DebugBreak() - these are not supported by CIODriverSink's
	//
	BOOL	Read(	CReadPacket*,	
					CSessionSocket*,	
					BOOL	&eof 
					) ;

	BOOL	Write(	CWritePacket*,	
					CSessionSocket*,	
					BOOL	&eof 
					) ;

	BOOL	Transmit(	CTransmitPacket*,	
						CSessionSocket*,	
						BOOL	&eof 
						) ;

	CIODriverSink( class	CMediumBufferCache*	pCache ) ;
	~CIODriverSink() ;

	//
	//	To Initialize we require a 'source' - a CChannel derived object who's Read() Write() etcc
	//	functions we will be calling.
	//
	BOOL	Init(	CChannel*	pSource,	
					CSessionSocket*	pSocket, 
					PFNSHUTDOWN	pfnShutdown,	
					void	*pvShutdownArg,	
					unsigned cbReadOffset = 0, 
					unsigned cbWriteOffset = 0,
					unsigned cbTrailer = 0
					) ;

	//
	//	Issue the first bunch of CIO's.  This should only be called once, after that 
	//	the SendReadIO and SendWriteIO functions should be used by that state machines to keep
	//	things moving.
	//
	BOOL	Start(	CIOPTR&	pRead,	
					CIOPTR&	pWrite,	
					CSessionSocket*	pSocket 
					) ;

	//
	//	There are some situations where ATQ can lose track of timeouts - use this function
	//	to make sure that doesn't happen
	//
	void	ResumeTimeouts()	{	m_ReadStream.ResumeTimeouts() ;	}

} ;

#ifdef		_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CIODriverSink ) 

#endif


#define	MAX_CHANNEL_SIZE	max(	sizeof( CChannel ),				\
							max(	sizeof( CHandleChannel ),		\
							max(	sizeof(	CSocketChannel ),		\
							max(	sizeof(	CFileChannel ),			\
							max(	sizeof(	CIOFileChannel ),		\
							max(	sizeof(	CIODriver ),			\
							max(	sizeof( CIODriverSource ),		\
									sizeof(	CIODriverSink ) ) ) ) ) ) ) ) 

extern	const	unsigned	cbMAX_CHANNEL_SIZE ;


#include	"packet.h"
#include	"cio.h"

#include	"packet.inl"
#include	"io.inl"
#include	"cio.inl"


#endif	// _IO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfilt.h $(O)\nntpfilt_i.c : $(STAXNNTP)\core\include\nntpfilt.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfilt_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfilt_i.c \
    -header $@ \
    -tlb $(O)\nntpfilt.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpsvc.h $(O)\nntpsvc_s.c : ..\..\nntpsvc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -oldnames \
    -client none \
    -sstub $(O)\nntpsvc_s.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpmsg.h $(O)\nntpmsg.rc $(O)\msg00001.bin: nntpmsg.mc ..\..\..\..\inc\inetamsg.mc
    copy /a ..\..\..\..\inc\inetamsg.mc + /a nntpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\nntpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\nntpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\io.inl ===
/*++
	io.inl

	This file contains the inline functions specified in io.h
	These are generally all helper functions which forward their calls with some
	argument massaging.

--*/


inline	void*
CChannel::operator	new(	size_t	size )	{

	//
	//	This function routes all allocations of any CChannel derived object
	//	into our CPool which exists just for that purpose


	Assert( size <= cbMAX_CHANNEL_SIZE ) ;
	void*	pv = gChannelPool.Alloc() ;
	return	pv ;
}

inline	void
CChannel::operator	delete(	void*	pv ) {
	//
	//	All deletions of CChannel derived objects go into our CPool as well
	//
	gChannelPool.Free( pv ) ;
}	

void	CFileChannel::FlushFileBuffers()	{
	m_lock.ShareLock() ;
	if( m_pFIOContext )
		::FlushFileBuffers( m_pFIOContext->m_hFile ) ;
	m_lock.ShareUnlock() ;
}

inline	void	CStream::IssuePacket(	CReadPacket*	pPacket,	
													CSessionSocket	*pSocket,
													BOOL& eof )	{

	//
	//	Stamp this packet with a sequence number and
	//	then send to the Source Channel to be issued.
	//	NOTE : This function should only be called by one thread at a time
	//	for a given CStream !
	//

	TraceFunctEnter( "CStream::IssuePacket" ) ;

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cSequenceThreads ) == 0 ) ;
	#endif
	Assert( m_fRead ) ;
	Assert( pPacket->m_pOwner == m_pOwner || m_pOwner == 0 ) ;

	ASSIGN(pPacket->m_sequenceno, m_sequencenoOut);
	INC(m_sequencenoOut);

	DebugTrace( (DWORD_PTR)this, "Issuing Packet %x, pPacket->m_sequenceno %d m_sequencenoOut %d", pPacket, LOW(pPacket->m_sequenceno),
			LOW(m_sequencenoOut) ) ;

	#ifdef	CIO_DEBUG
	Assert(	InterlockedDecrement( &m_cSequenceThreads ) < 0 ) ;
	Assert( m_cSequenceThreads == -1 ) ;
	#endif

	BOOL	fRtn = m_pSourceChannel->Read( pPacket,	pSocket, eof ) ;

	if( !fRtn ) {
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_NTERROR, GetLastError() ) ;
		//delete	pPacket ;
		//pPacket->m_pOwner->DestroyPacket( pPacket ) ;
		pPacket->m_fRequest = FALSE;
		pPacket->m_pOwner->m_pReadStream->ProcessPacket( pPacket, pSocket ) ;
	}
}

inline	void	CStream::IssuePacket(	CWritePacket*	pPacket,	
													CSessionSocket	*pSocket,
													BOOL&	eof )	{

	//
	//	Stamp this packet with a sequence number and
	//	then send to the Source Channel to be issued.
	//	NOTE : This function should only be called by one thread at a time
	//	for a given CStream !
	//

	TraceFunctEnter( "CStream::IssuePacket" ) ;

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cSequenceThreads ) == 0 ) ;
	#endif
	Assert( !m_fRead ) ;
	Assert( pPacket->m_pOwner == m_pOwner || m_pOwner == 0  ) ;

	ASSIGN(pPacket->m_sequenceno, m_sequencenoOut);
	INC(m_sequencenoOut);

	DebugTrace( (DWORD_PTR)this, "Issuing Packet %x, pPacket->m_sequenceno %d m_sequencenoOut %d", pPacket, LOW(pPacket->m_sequenceno),
		LOW(m_sequencenoOut) ) ;

	#ifdef	CIO_DEBUG
	Assert(	InterlockedDecrement( &m_cSequenceThreads ) < 0 ) ;
	Assert( m_cSequenceThreads == -1 ) ;
	#endif
	BOOL	fRtn = m_pSourceChannel->Write( pPacket,	pSocket, eof ) ;
	if( !fRtn ) {
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_NTERROR, GetLastError() ) ;
		//delete	pPacket ;
		//pPacket->m_pOwner->DestroyPacket( pPacket ) ;
		pPacket->m_fRequest = FALSE;
		pPacket->m_pOwner->m_pWriteStream->ProcessPacket( pPacket, pSocket ) ;
	}
}	

inline	void	CStream::IssuePacket(	CTransmitPacket*	pPacket,	
													CSessionSocket	*pSocket,
													BOOL&	eof )	{

	//
	//	Stamp this packet with a sequence number and
	//	then send to the Source Channel to be issued.
	//	NOTE : This function should only be called by one thread at a time
	//	for a given CStream !
	//

	TraceFunctEnter( "CStream::IssuePacket" ) ;

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cSequenceThreads ) == 0 ) ;
	#endif
	Assert( !m_fRead ) ;
	Assert( pPacket->m_pOwner == m_pOwner || m_pOwner == 0  ) ;

	ASSIGN(pPacket->m_sequenceno, m_sequencenoOut);
	INC(m_sequencenoOut);

	DebugTrace( (DWORD_PTR)this, "Issuing Packet %x, pPacket->m_sequenceno %d m_sequencenoOut %d", pPacket, LOW(pPacket->m_sequenceno),
			LOW(m_sequencenoOut) ) ;

	#ifdef	CIO_DEBUG
	Assert(	InterlockedDecrement( &m_cSequenceThreads ) < 0 ) ;
	Assert( m_cSequenceThreads == -1 ) ;
	#endif

	BOOL	fRtn = m_pSourceChannel->Transmit( pPacket,	pSocket, eof ) ;
	if( !fRtn ) {
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_NTERROR, GetLastError() ) ;
		//delete	pPacket ;
		pPacket->m_pOwner->DestroyPacket( pPacket ) ;
	}
}

inline	BOOL	CStream::SendIO(	CSessionSocket*	pSocket,	
											CIO&	pio,	
											BOOL	fStart )	{

	//
	//	This function will set the m_pIOCurrent member variable to pio
	//	However, since we want the CIO objects to be called on only
	//	one thread for all Start calls and Completion calls, we will
	//	use ProcessPacket to slip this object in.
	//	ProcessPacket will ensure that only one thread mucks with m_pIOCurrent.
	//

//	Assert( !((!!m_fRead) ^ (!!pio->IsRead())) ) ;

	TraceFunctEnter( "CStream::SendIO" ) ;

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cNumberSends ) == 0 ) ;
	#endif

	CControlPacket*	pSpecialPacket = (CControlPacket*)InterlockedExchangePointer( (void**)&m_pSpecialPacket, 0 ) ;

	if( pSpecialPacket != 0 )		{

		DebugTrace( (DWORD_PTR)this, "m_pSpecialPacket %x", m_pSpecialPacket ) ;

		Assert( pSpecialPacket->m_control.m_type == ILLEGAL ) ;
#if 0
		Assert( pSpecialPacket->m_control.m_StartIO.m_pio == 0 ) ;
		Assert( pSpecialPacket->m_control.m_StartIO.m_fStart == FALSE ) ;
#else
		_ASSERT( pSpecialPacket->m_control.m_pio == 0 ) ;
		_ASSERT( pSpecialPacket->m_control.m_pioPassThru == 0 ) ;
		_ASSERT( pSpecialPacket->m_control.m_fStart == FALSE ) ;
#endif
	
		m_pSpecialPacketInUse = pSpecialPacket ;		

		pSpecialPacket->StartIO( pio, fStart ) ;
		ProcessPacket(	pSpecialPacket, pSocket ) ;	

	}	else	{

		// An error occurred - should we call the IO objects Shutdown function !?!?
		// Let the caller handle the problem !
		
		return	FALSE ;
	}
	return	TRUE ;
}

#ifdef	RETIRED
inline	void	CStream::Shutdown(	CSessionSocket*	pSocket,
												BOOL	fCloseSource )		{

	//
	//	This function exists to Shutdown a driver -
	//	This should be retired and replaced by UnsafeShutdown().
	//

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cThreadsSpecial ) == 0 ) ;
	#endif

	Assert( m_pSpecialPacket->m_control.m_type == ILLEGAL ) ;
	Assert( m_pSpecialPacket->m_control.m_StartIO.m_pio == 0 ) ;
	Assert( m_pSpecialPacket->m_control.m_StartIO.m_fStart == FALSE ) ;

	if( InterlockedIncrement( &m_cShutdowns ) > 0 ) {
		// somebody has already shut the system down !!
		// It must be somebody forcing the session closed !!
	}	else	{
		m_pSpecialPacket->Shutdown( fCloseSource ) ;
		ProcessPacket(	m_pSpecialPacket,	pSocket ) ;
	}

	#ifdef	CIO_DEBUG
	Assert( InterlockedDecrement( &m_cThreadsSpecial ) < 0 ) ;
	Assert(	m_cThreadsSpecial >= -1 ) ;
	#endif
}
#endif

inline	void	CStream::UnsafeShutdown(	CSessionSocket*	pSocket,
													BOOL fCloseSource )	{

	//
	//	UnsafeShutdown will send exactly 1 packet to the CStream
	//	which when processed will tell the CStream to shut itself down.
	//	We can be called by multiple threads.
	//

	CControlPacket*	pShutdownPacket = (CControlPacket*)InterlockedExchangePointer( (void**)&m_pUnsafePacket, 0 ) ;
	if( pShutdownPacket ) {
 		if( InterlockedIncrement( &m_cShutdowns ) > 0 ) {
			// somebody has already shut the system down !
			//delete	pShutdownPacket ;
			CPacket::DestroyAndDelete( pShutdownPacket ) ;
		}	else	{
			// we get to shut the socket down !
			m_pUnsafeInuse = pShutdownPacket ;
			pShutdownPacket->Shutdown( fCloseSource ) ;
			ProcessPacket( m_pUnsafeInuse, pSocket ) ;
		}
	}	
}


inline	BOOL
CIODriver::SendReadIO(	CSessionSocket*	pSocket,	
						CIO&			pRead,	
						BOOL	fStart )		{

	//
	//	This function sends CIORead derived objects to the
	//	appropriate CStream object.
	//

	if( !m_pReadStream->SendIO( pSocket, pRead, fStart ) ) {
		pRead.DoShutdown( pSocket, *this,  m_cause, 0 ) ;
		return	FALSE ;
	}
	return	TRUE ;
}		

inline	BOOL	
CIODriver::SendWriteIO(	CSessionSocket*	pSocket,	
						CIO&	pWrite,	
						BOOL	fStart )	{

	//
	//	This function sends CIOWrite derived objects to the
	//	appropriate CStream object.
	//	We use CStream::SendIO to do the brunt of the work.
	//

	if( !m_pWriteStream->SendIO( pSocket, pWrite, fStart ) ) {
		pWrite.DoShutdown( pSocket, *this, m_cause, 0 ) ;
		return	FALSE ;
	}
	return	TRUE ;
}

inline	void
CIODriver::CompleteWritePacket(	CWritePacket*	pPacket,	CSessionSocket*	pSocket ) {
/*++

Routine Description :

	This function is for use by CChannel's which can optimize Write's and
	complete them immediately.  We call ProcessPacket(), the grunt worker of
	processing packets.

Arguments :

	pPacket -	The Completed packet
	pSocket-	The socket associated with this packet

Return Value :

	None.

--*/

	m_pWriteStream->ProcessPacket( pPacket, pSocket ) ;

}

inline	CReadPacket*
CIODriver::CreateDefaultRead(	unsigned	cbRequest
								)	{
	//
	//	Route the CreateDefaultRead call to the CStream object
	//	which handles Reads for this stream.
	//	All the work will happen there.
	//
	return	m_pReadStream->CreateDefaultRead( *this,	cbRequest ) ;
}

inline	CWritePacket*
CIODriver::CreateDefaultWrite(	unsigned	cbRequest )		{
	//
	//	Route this call to the CStream object which handles all writes
	//
	return	m_pWriteStream->CreateDefaultWrite( *this, cbRequest ) ;
}

inline	CWritePacket*
CIODriver::CreateDefaultWrite(	CBUFPTR&	pbuffer,	
								unsigned	ibStart,	
								unsigned	ibEnd,	
								unsigned	ibStartData,	
								unsigned	ibEndData )	{

	//
	//	Route this call to the CStream object which handles all writes
	//
	return	m_pWriteStream->CreateDefaultWrite(	*this,	pbuffer,
													ibStart,	ibEnd,
													ibStartData,	ibEndData ) ;
}

inline	CWritePacket*	
CIODriver::CreateDefaultWrite(	CReadPacket*	pRead )		{
	//
	//	Route this call to the CStream object which handles all writes
	//
	return	m_pWriteStream->CreateDefaultWrite( *this, pRead->m_pbuffer, pRead->m_ibStart,
									pRead->m_ibEnd, pRead->m_ibStartData, pRead->m_ibEndData ) ;
}

inline	CTransmitPacket*	
CIODriver::CreateDefaultTransmit(	FIO_CONTEXT*	pFIOContext,	
									DWORD	ibOffset,	
									DWORD	cbLength ) {
	//
	//	Route this call to the CStream object which handles all writes
	//
	return	m_pWriteStream->CreateDefaultTransmit( *this, pFIOContext, ibOffset, cbLength ) ;
}

inline	CExecutePacket*
CIODriver::CreateExecutePacket(	)	{
	return	new(	&m_packetCache )	CExecutePacket( *this ) ;
}

inline	void
CIODriver::ProcessExecute(	CExecutePacket*	pExecute,
							CSessionSocket*	pSocket
							)	{
	pExecute->m_fRequest = FALSE ;
	m_pWriteStream->ProcessPacket(	pExecute, pSocket ) ;	
}

inline	CReadPacket*	
CIODriverSource::Clone(		CReadPacket*	pRead ) {
	//
	//	Makes a copy of a CReadPacket
	//
	return	new CReadPacket( *this, *pRead ) ;
}

inline	CWritePacket*	
CIODriverSource::Clone(		CWritePacket*	pWrite ) {
	//
	//	Makes a copy of a CWritePacket
	//
	return	new CWritePacket( *this, *pWrite ) ;
}

inline	CTransmitPacket*	
CIODriverSource::Clone(	CTransmitPacket*	pTransmit ) {
	return	new	CTransmitPacket(	*this, *pTransmit ) ;
}


inline	void	
CIODriver::IssuePacket(	CReadPacket	*pPacket,	
						CSessionSocket	*pSocket,	
						BOOL&	eof )	{

	//
	//	Route this call to the CStream object which handles all reads
	//
	m_pReadStream->IssuePacket( pPacket,	pSocket,	eof ) ;
}

inline	void	
CIODriver::IssuePacket(	CWritePacket *pPacket,	
						CSessionSocket	*pSocket,	
						BOOL&	eof )	{

	//
	//	Route this call to the CStream object which handles all writes
	//
	m_pWriteStream->IssuePacket( pPacket,	pSocket,	eof ) ;
}

inline	void	
CIODriver::IssuePacket(	CTransmitPacket	*pPacket,	
						CSessionSocket	*pSocket,	
						BOOL&	eof )	{

	//
	//	Route this call to the CStream object which handles all writes
	//
	m_pWriteStream->IssuePacket( pPacket,	pSocket,	eof ) ;
}

inline	CBuffer*
CIODriver::AllocateBuffer(	DWORD	cbBuffer	) {


	DWORD	cbOut = 0 ;
	CBuffer*	pbuffer = new(	cbBuffer,
								cbOut,
								&m_bufferCache,
								m_pMediumCache )
								CBuffer( cbOut ) ;

	return	pbuffer ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\lockq.cpp ===
//
//	LOCKQ.CPP
//
//	This file contains classes which define a queue mechanism which will
//	safely synchronize additions and removals from the queue, where every
//	thread which appends to the Queue must be prepared to deal with owning the
//	queue.  Additionally, elements will come off the queue in the same order
//	that they are appended.
//
//	The structure of a thread using this stuff should be the following :
//
//	class	CUsefull : public CQElement { } ;
//	template	CLockQueue< CUsefull >	UsefullQ ;
//
//
//		if( UsefullQ.Append( pUsefull ) ) {
//
//			while( UsefullQ.GetHead( &pUsefullWorkItem )  ) {
//				/* Do some usefull work. */
//
//				UsefullQ.Remove() ;
//			}
//		}
//
//	Implementation Schedule for all classes defined in this file :
//		1 day
//
//	Unit Test schedule for all classes defined in this file :
//		1 day
//		Unit Testing should consist of a multi theaded appli
//
//

//
//	K2_TODO: move this into an independent lib
//
#define _TIGRIS_H_
#include "tigris.hxx"

#include    <windows.h>
#ifndef	UNIT_TEST
#include    <dbgtrace.h>
#else
#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif
#endif

#ifdef  PPC
#define _NO_TEMPLATES_
#endif

#include	"qbase.h"
#include	"lockq.h"



CQueueLockV1::CQueueLockV1( ) : m_pHead( &m_special ), m_pTail( &m_special ) {

	//
	// This function initializes the queue to an empty state.
	// In the empty state the queue contains one element which
	// has a Next pointer of 'LOCKVAL'.
	// The next pointer is initialized to LOCKVAL so that the first
	// append to the Queue owns the removal lock.
	//
 	m_special.m_pNext = (CQElement*)((SIZE_T)LOCKVAL) ;

#ifdef	LOCKQ_DEBUG
	m_dwOwningThread = 0 ;
	m_lock = -1 ;
#endif

}


CQueueLockV1::~CQueueLockV1( ) {
	_ASSERT( m_pHead == m_pTail ) ;
	_ASSERT( m_pHead == &m_special ) ;
#ifdef	LOCKQ_DEBUG
//	_ASSERT( m_dwOwningThread == 0 || m_dwOwningThread == GetCurrentThreadId() ) ;
#endif

}

CQElement*
CQueueLockV1::GetFront( ) {

	//
	// This is an internally used function only.
	// This function will set the m_pHead pointer to point
	// to the first legal element.
	// The function assumes there is at least one valid element
	// in the queue.
	//


	_ASSERT( m_pHead != 0 ) ;	// Check head pointer is valid.
#ifdef	LOCKQ_DEBUG
	_ASSERT( m_dwOwningThread == GetCurrentThreadId() ) ;
	_ASSERT( InterlockedIncrement( &m_lock ) > 0 ) ;
#endif

	if( m_pHead == &m_special ) {

		// There is one valid element in queue, so this must be TRUE.
		_ASSERT( m_pHead->m_pNext != 0 ) ;

		CQElement*	pTemp = m_pHead ;
		m_pHead = pTemp->m_pNext ;
		pTemp->m_pNext = 0 ;
		// We ignore the return code of Append() as the caller must already
		// have the remove lock.
		Append( pTemp ) ;

#ifdef	LOCKQ_DEBUG
		_ASSERT( InterlockedDecrement( &m_lock ) == 0 ) ;
#endif
		if( !OfferOwnership( m_pHead ) )
			return	0 ;
	}	else	{
#ifdef	LOCKQ_DEBUG
		_ASSERT( InterlockedDecrement( &m_lock ) == 0 ) ;
#endif
	}

	return	m_pHead ;
}


BOOL
CQueueLockV1::OfferOwnership( CQElement* p ) {

	BOOL	fRtn = TRUE ;
	//
	// This function implementes our InterlockedExchange protocol with the
	// appending thread.  We place LOCKVAL into the Next pointer.  If we get
	// NULL back, some other thread is going to get LOCKVAL so we lost the
	// removal lock.
	//

	// The if() is not necessary but maybe eliminates some redundant InterlockedExchanges.
	_ASSERT( p->m_pNext != (CQElement*)((SIZE_T)LOCKVAL) ) ;
	if( p->m_pNext == 0 || p->m_pNext == (CQElement*)((SIZE_T)LOCKVAL) ) {
		CQElement*	pTemp = (CQElement*)InterlockedExchangePointer( (void**)&(p->m_pNext), (void*)LOCKVAL ) ;
		_ASSERT( pTemp != (CQElement*)((SIZE_T)LOCKVAL) ) ;
		if( pTemp == 0 || pTemp == (CQElement*)((SIZE_T)LOCKVAL) ) {
			fRtn = FALSE ;
		}	else	{
			p->m_pNext = pTemp ;
		}
	}
	return	fRtn ;
}

void
CQueueLockV1::Remove( ) {
	//
	//	GetHead() must have been called before this.   Calling GetHead will ensure
	//	that the Head Elements next pointer is NOT NULL.
	//
	_ASSERT( m_pHead->m_pNext != 0 ) ;	// We owned the lock so this should be non-null
	_ASSERT( m_pHead != &m_special ) ;	// A prior GetHead() call should leave us
										// pointing at something other than the special element.

#ifdef	LOCKQ_DEBUG
	_ASSERT( m_dwOwningThread == GetCurrentThreadId() ) ;
	_ASSERT( InterlockedIncrement( &m_lock ) == 0 ) ;

#endif

	CQElement*	p = m_pHead ;
	_ASSERT( p->m_pNext != 0 ) ;
	m_pHead = m_pHead->m_pNext ;
	p->m_pNext = 0 ;
#ifdef	LOCKQ_DEBUG
	_ASSERT( InterlockedDecrement( &m_lock ) < 0 ) ;
#endif
}

BOOL
CQueueLockV1::RemoveAndRelease( ) {

#ifdef	LOCKQ_DEBUG
	_ASSERT( InterlockedIncrement( &m_lock ) == 0 ) ;
	_ASSERT( m_dwOwningThread == GetCurrentThreadId() ) ;
#endif

	_ASSERT( m_pHead->m_pNext != 0 ) ;
	_ASSERT( m_pHead != &m_special ) ;
	m_pHead = m_pHead->m_pNext ;

#ifdef	LOCKQ_DEBUG
	_ASSERT( InterlockedDecrement( &m_lock ) < 0 ) ;
#endif
	BOOL	fRtn = OfferOwnership( m_pHead ) ;

	return	fRtn ;
}


BOOL
CQueueLockV1::GetHead( CQElement*& pFront ) {
	//
	// This function will return the element that is at the head of the
	// Queue as long as this thread continues to own the Remove Lock.
	//


	BOOL	fRtn = FALSE ;

	pFront = 0 ;
	if( OfferOwnership( m_pHead ) ) {
#ifdef	LOCKQ_DEBUG
		_ASSERT( m_dwOwningThread == GetCurrentThreadId() ) ;
		_ASSERT( InterlockedIncrement( &m_lock ) == 0 ) ;
#endif
		pFront = GetFront( ) ;
		if( pFront != 0 )
			fRtn = TRUE ;

#ifdef	LOCKQ_DEBUG
		_ASSERT( InterlockedDecrement( &m_lock ) < 0 ) ;
#endif

	}

	return	fRtn ;
}

BOOL
CQueueLockV1::Append( CQElement*	pAppend ) {
	//
	// We must set the Next pointer to NULL so that the next
	//	we come to append the tail pointer is properly set up.
	//
	_ASSERT( pAppend->m_pNext == 0 ) ;
	pAppend->m_pNext = 0 ;

	// Get the old tail pointer.  This guy won't be touched by the
	// remove thread if his next pointer is still NULL.
	CQElement*	pTemp = (CQElement*)InterlockedExchangePointer( (PVOID *)&m_pTail, pAppend ) ;

	// After we set the old tail pointer's next pointer to NON NULL
	// he becomes fair game for whoever is removing from the queue.
	// We may become the thread removing from the queue if whoever was
	// previously removing got to the last element and changed its next pointer
	// to LOCKVAL.
	//
	// NOTE : This thread and any thread doing removals should be the only
	//	threads touching the pNext field of the pTemp element.
	//
	PVOID l = InterlockedExchangePointer( (PVOID *)&(pTemp->m_pNext), pAppend ) ;


#ifdef	LOCKQ_DEBUG
	if( l== (PVOID)LOCKVAL ) {
		_ASSERT( InterlockedIncrement( &m_lock ) == 0 ) ;
		m_dwOwningThread = GetCurrentThreadId() ;
		_ASSERT( InterlockedDecrement( &m_lock ) < 0 ) ;
	}
#endif


	return	l == (PVOID)LOCKVAL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the W3 Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        JohnL   ????
        MuraliK     11-July-1995 Used Ipc() functions from Inetsvcs.dll

*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"

#define HEAP_INIT_SIZE (KB * KB)

//
// RPC related includes
//

extern "C" {
#include <inetinfo.h>
#include <nntpsvc.h>
};

#include "isrpcexp.h"

//
//  Private globals.
//

DEFINE_TSVC_INFO_INTERFACE();
DECLARE_DEBUG_PRINTS_OBJECT( );
DECLARE_DEBUG_VARIABLE();

BOOL ServiceBooted      = FALSE;
BOOL g_fRpcInitialized  = FALSE;

//
//	Global startup named event
//
HANDLE              ghStartupEvent = INVALID_HANDLE_VALUE;
PNNTP_IIS_SERVICE   g_pNntpSvc = NULL ;

//
// The following critical section synchronizes execution in ServiceEntry().
// This is necessary because the NT Service Controller may reissue a service
// start notification immediately after we have set our status to stopped.
// This can lead to an unpleasant race condition in ServiceEntry() as one
// thread cleans up global state as another thread is initializing it.
//

CRITICAL_SECTION g_csServiceEntryLock;

//
//  Private prototypes.
//

APIERR
InitializeService(
			LPVOID pContext
			);

APIERR
TerminateService(
			LPVOID pContext
			);

//
//	Dll entry point
//

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

BOOL	WINAPI
DllEntryPoint(
			HINSTANCE	hinstDll,	
			DWORD		dwReason,	
			LPVOID		lpvReserved ) {

	switch( dwReason ) {

		case	DLL_PROCESS_ATTACH :

            CREATE_DEBUG_PRINT_OBJECT(NNTP_MODULE_NAME);
            LOAD_DEBUG_FLAGS_FROM_REG_STR(StrParmKey, 0);

			_Module.Init(ObjectMap, hinstDll);

			//
			// To help performance, cancel thread attach and detach notifications
			//
			DisableThreadLibraryCalls((HMODULE) hinstDll );
            InitializeCriticalSection( &g_csServiceEntryLock );
			break ;

		case	DLL_THREAD_ATTACH :
			break ;

		case	DLL_THREAD_DETACH :
			break ;

		case	DLL_PROCESS_DETACH :

			_Module.Term();

			if( ghStartupEvent != INVALID_HANDLE_VALUE ) {
				_VERIFY( CloseHandle( ghStartupEvent ) );
			}

            DELETE_DEBUG_PRINT_OBJECT();
            DeleteCriticalSection( &g_csServiceEntryLock );

			break ;

	}
	return	TRUE ;
}


BOOL	WINAPI
DllMain(	HANDLE	hInst,
			ULONG	dwReason,
			LPVOID	lpvReserve )	{

	return	DllEntryPoint( (HINSTANCE)hInst, dwReason, lpvReserve ) ;

}

//
//  Public functions.
//

VOID ServiceEntry( DWORD                cArgs,
                   LPWSTR               pArgs[],
                   PTCPSVCS_GLOBAL_DATA    pGlobalData     // unused
                    )

/*++

Routine Description :

	This function is the first thing called by the service control
	manager during boot up.
	The server can boot into one of 2 modes :

		1) Normal operations -
			In this case we want start everything, start listening
			for client connections and do the regular NNTP stuff.

		2) Recovery Boot -
			In this case we are being launched by a companion tool
			(nntpbld.exe) and are being provided with a bunch of
			arguments.  Those arguments specify what kind of
			error recovery we want to do.  In this mode the
			server does not accept clients, RPC's or anything -
			we attempt to rebuild disk base data structures.

	K2 NOTE: This is not true anymore - we will always boot in normal mode !

Arguments :

	cArgs - Number of args passed to service. If more than
		1 we assume we are doing a Recovery Boot.

	pArgs - Array of arguments.

	pGlobalData - Gibraltar data.

Return Value :

	No return value.
	If an error occurs during, we will return immediately.

--*/
{
    APIERR err = NO_ERROR;
    BOOL fInitSvcObject = FALSE;
    BOOL fHeapCreated;

    EnterCriticalSection( &g_csServiceEntryLock );

    //
    // Initialize the global heap
    //
    _VERIFY( fHeapCreated = CreateGlobalHeap( NUM_EXCHMEM_HEAPS, 0, HEAP_INIT_SIZE, 0 ) );
    if ( !fHeapCreated ) {
        OutputDebugString( "\n Failed to initialize exchmem \n" );
        err = ERROR_NOT_ENOUGH_MEMORY;
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    //
    //	Initialize atq etc
    //
    if( !InitCommonDlls() ) {
        _VERIFY( DestroyGlobalHeap() );
        OutputDebugString( "\n Failed to Init common Dlls \n");
        err = GetLastError();
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    InitAsyncTrace();
    //ENTER("ServiceEntry")

    //
    //  Initialize the service status structure.
    //

    g_pInetSvc = new NNTP_IIS_SERVICE(
                                    NNTP_SERVICE_NAME_A,        // Service name
                                    NNTP_MODULE_NAME,           // Module name
                                    NNTP_PARAMETERS_KEY_A,      // Param reg key
                                    INET_NNTP_SVC_ID,           // Service Id
                                    INET_NNTP_SVCLOC_ID,        // Service locator Id
                                    TRUE,                       // Multiple instances supported
                                    0,                          // Default recv buffer for AcceptEx - pass 0 to disable !
                                    NntpOnConnect,              // Connect callback
                                    NntpOnConnectEx,            // Connect callback on AcceptEx
                                    (ATQ_COMPLETION)&CHandleChannel::Completion	// ATQ I/O completion routine
									);

    //
    //  If we couldn't allocate memory for the service info struct, then the
    //  machine is really hosed
    //

    if ( (g_pInetSvc != NULL) && g_pInetSvc->IsActive() )
    {
        fInitSvcObject = TRUE;

        //
        //	Use this as the global service ptr
        //
        g_pNntpSvc = (PNNTP_IIS_SERVICE)g_pInetSvc ;

        //
        //  This blocks until the service is shutdown
        //

        DebugTraceX( 0, "ServiceEntry success: Blocking on StartServiceOperation");
        err = g_pInetSvc->StartServiceOperation(
                                    SERVICE_CTRL_HANDLER(),
                                    InitializeService,
                                    TerminateService
                                    );

        if ( err )
        {
                //
                //  The event has already been logged
                //
                ErrorTraceX( 0, "StartServiceOperation returned %d", err);
        }
    } else if ( g_pInetSvc == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        err = g_pInetSvc->QueryCurrentServiceError();
    }

    //
    //	Cleanup stuff !
    //
    if ( g_pInetSvc != NULL ) {
        //
        //	NOTE: this bumps a ref count down which will cause g_pInetSvc to be deleted !
        //
        g_pInetSvc->CloseService( );
        g_pNntpSvc = NULL ;
    }

    //LEAVE
    TermAsyncTrace();

    //
    //	Cleanup Rpcs, atq etc
    //
    _VERIFY( TerminateCommonDlls() );
    _VERIFY( DestroyGlobalHeap() );
    LeaveCriticalSection( &g_csServiceEntryLock );

notify_scm:
    //
    // We need to tell the Service Control Manager that the service
    // is stopped if we haven't called g_pInetSvc->StartServiceOperation.
    //  1) InitCommonDlls fails, or
    //  2) InitializeGlobals failed, or
    //  3) new operator failed, or
    //  4) NNTP_IIS_SERVICE constructor couldn't initialize properly
    //

    if ( !fInitSvcObject ) {
        SERVICE_STATUS_HANDLE hsvcStatus;
        SERVICE_STATUS svcStatus;

        hsvcStatus = RegisterServiceCtrlHandler( NNTP_SERVICE_NAME,
                                                 SERVICE_CTRL_HANDLER() );

        if ( hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
            svcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
            svcStatus.dwCurrentState = SERVICE_STOPPED;
            svcStatus.dwWin32ExitCode = err;
            svcStatus.dwServiceSpecificExitCode = err;
            svcStatus.dwControlsAccepted = 0;
            svcStatus.dwCheckPoint = 0;
            svcStatus.dwWaitHint = 0;

            SetServiceStatus( hsvcStatus, (LPSERVICE_STATUS) &svcStatus );
        }
    }

}  // ServiceEntry

//
//  Private functions.
//


APIERR
InitializeService(
            LPVOID pContext
			)
/*++

Routine description :

	This function initializes all the gibraltar stuff we need.

Arguments :

	pContext - Gibraltar stuff

Return Value :

	0 if successfull, ERROR code otherwise.

--*/
{
    APIERR err = ERROR_SERVICE_DISABLED;
    PNNTP_IIS_SERVICE psi = (PNNTP_IIS_SERVICE) pContext;

    ENTER("InitializeService")

    //
    //	Create a startup named event. If this already exists, refuse to boot !!
    //
    HANDLE hEvent = CreateEvent( NULL, FALSE, FALSE, "MicrosoftInternetNewsServerVersion2BootCheckEvent" );
    if( !hEvent || GetLastError() != 0 ) {
    	if( hEvent && GetLastError() == ERROR_ALREADY_EXISTS ) {
	    	_VERIFY( CloseHandle( hEvent ) );
        }

        NntpLogEvent(	NNTP_BOOT_ERROR,
	        			0,
		        		(const char **)NULL,
			        	ERROR_SERVICE_ALREADY_RUNNING
				        ) ;

    	g_pInetSvc->ShutdownService( );
	    return ERROR_SERVICE_ALREADY_RUNNING ;
    }

    //	set the global startup event. this is closed when our DLL_PROCESS_DETACH is called
    ghStartupEvent = hEvent;
    ServiceBooted  = TRUE;

    //
    //  Initialize various components.  The ordering of the
    //  components is somewhat limited.  Globals should be
    //  initialized first, then the event logger.  After
    //  the event logger is initialized, the other components
    //  may be initialized in any order with one exception.
    //  InitializeSockets must be the last initialization
    //  routine called.  It kicks off the main socket connection
    //  thread.
    //

    if( ( err = InitializeGlobals() ) ) {

        //
        //  We set ServiceBooted to FALSE to avoid unnecessary cleanup
        //  in TerminateService(). Need to call TerminateGlobals() in
        //  order to cleanup stuff initialized in InitializeGlobals().
        //

        g_pInetSvc->ShutdownService( );
        TerminateGlobals();
        ServiceBooted = FALSE;

        return	err ;
    }

    //
    //	If we are doing some kind of recovery boot, don't initialize this stuff !!
    //
    if( ( err = psi->InitializeDiscovery())		||
	    ( err = psi->InitializeSockets()  ) )	
    {
	    FatalTrace(0,"Cannot initialize service %d\n",err);
    	g_pInetSvc->ShutdownService( );
	    LEAVE
    	return err;
    }

    //
    // Read and activate all the instances configured
    //

    if( (err = InitializeInstances( psi ) ) ) {
	    g_pInetSvc->ShutdownService( );
    	return err ;
    }

    //
    // Initialize RPCs after booting instances
    //

    if( !InitializeServiceRpc( NNTP_SERVICE_NAME, nntp_ServerIfHandle ) )
    {
        NntpLogEvent(	NNTP_INIT_RPC_FAILED,
	        			0,
		        		(const char **)NULL,
			        	GetLastError()
				        ) ;
        g_pInetSvc->ShutdownService( );
        return ERROR_SERVICE_DISABLED;
    }

	g_fRpcInitialized = TRUE ;

    //
    //  Success!
    //

    DebugTrace(0,"InitializeService Successful\n");

    LEAVE
    return NO_ERROR;

}   // InitializeService

APIERR
TerminateService(
			LPVOID pContext
			)
/*++

Routine Description :

	This function is called when the service is stopped -
	it tears down all of our data structures and
	release everything.

Arguments :

	pContext - Context for Gibraltar stuff.

Return Value :

	0 if successfull,
	otherwise NT error code.

--*/
{
    PNNTP_IIS_SERVICE psi = (PNNTP_IIS_SERVICE)pContext;
    PCHAR args [1];
    DWORD err;

    ENTER("terminating service\n")

    //
    //	Check that the service booted - if not return
    //
    if( !ServiceBooted ) {
	    return NO_ERROR;
    }
    ServiceBooted = FALSE ;

    TerminateInstances( psi );

    //
    //  Components should be terminated in reverse
    //  initialization order.
    //

    g_pInetSvc->ShutdownService( );
    (VOID)psi->CleanupSockets( );

    if ( (err = psi->TerminateDiscovery()) != NO_ERROR) {
        ErrorTrace(0, "TerminateDiscovery() failed. Error = %u\n", err);
    }

    if(	g_fRpcInitialized ) {
	    CleanupServiceRpc();
    }

    TerminateGlobals();
#ifdef EXEXPRESS
	TsFlushMetaCache(METACACHE_NNTP_SERVER_ID, TRUE);
#endif

    // Log a successful stop event !
    args [0] = szVersionString;
    NntpLogEvent( NNTP_EVENT_SERVICE_STOPPED, 1, (const char**)args, 0) ;

    if (ghStartupEvent != INVALID_HANDLE_VALUE) {
    	CloseHandle (ghStartupEvent);
    	ghStartupEvent = INVALID_HANDLE_VALUE;
    }    	

    LEAVE
    return NO_ERROR;

}  // TerminateService

VOID
NntpLogEvent(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode                 // error code if any
    )
/*++

Routine Description :

	Log an NT event.
	This function wraps the call to the Gibraltar NT Event Log interface.

Arguments :

	idMessage - The Message-Id from the .mc file
	cSubStrings - Number of args to log
	apszSubStrings - Strings to be logged
	errCode - a DWORD that will end up in the Event Data.

Return Value :

	None.

--*/
{
    //
    // Use the Gibraltar logging facility
    //

    g_pInetSvc->LogEvent(
					idMessage,
                    cSubStrings,
                    apszSubStrings,
                    errCode
                    );

    return;

} // NntpLogEvent

VOID
NntpLogEventEx(
    IN DWORD  idMessage,               // id for log message
    IN WORD   cSubStrings,             // count of substrings
    IN const  CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode,                 // error code if any
	IN DWORD  dwInstanceId			   // virtual server instance id
    )
/*++

Routine Description :

	Log an NT event. Use FormatMessage() to print descriptive strings for NT error codes.
	This function wraps the call to NntpLogEvent()

Arguments :

	idMessage - The Message-Id from the .mc file
	cSubStrings - Number of args to log
	apszSubStrings - Strings to be logged
	errCode - a DWORD that will end up in the Event Data.

Return Value :

	None.

--*/
{
    //
    // Use FormatMessage() to get the descriptive text
    //
	LPVOID lpMsgBuf;
	CHAR   szId [20];

	TraceFunctEnter( "NntpLogEventEx" );

    if( !FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        errCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL
        ) )
    {
        DWORD dwError = GetLastError();
        ErrorTrace(0, "FormatMessage error : %d", dwError );
        lpMsgBuf = (LPVOID)LocalAlloc( LPTR, 20 );
        if( lpMsgBuf == NULL ) return;
        wsprintf( (LPTSTR)lpMsgBuf, "%d", dwError );
    }

    PCHAR* args = new PCHAR [cSubStrings+2];
    if( args ) {
        //	Get the instance id
        _itoa( dwInstanceId, szId, 10 );
        args [0] = szId;

        for(int i=1; i<cSubStrings+1; i++)
        {
            args [i] = (PCHAR)apszSubStrings [i-1];
        }

        //	NT error description
        args [i] = (PCHAR)lpMsgBuf;

        NntpLogEvent( idMessage,
                      cSubStrings+2,
                      (const char**)args,
                      errCode
                    );

        delete [] args;
    }

    LocalFree( lpMsgBuf );
    TraceFunctLeave();

    return;

} // NntpLogEventEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\newsgrp.cpp ===
/*++

	newsgrp.cpp

	This file contains the code implementing the CNewsGroup class.

	Each CNewsGroup object represents a newsgroup on the hard disk.
	Newsgroup information is saved in a file (group.lst) between boots.
	
	CNewsGroup objects are referenced 3 ways :

	Through a Hash Table which hashes newsgroup names
	Through a Hash Table which hashes group id's
	Through a Doubly Linked list sorted by newsgroup name

	Each Hash Table contains reference counting pointers to the
	newsgroup lists.  Also, anybody who searches for a newsgroup
	gets a reference counting pointer to the newsgroup.
	The only reference to CNewsGroup objects which is not referenced counted
	are those of the doubly linked list. Consequently, when the last reference
	to a newsgroup is removed, the destructor of the newsgroup will
	unlink the doubly linked lists.

--*/

#include    "tigris.hxx"

#include	<ctype.h>
#include	<stdlib.h>

#ifdef	DEBUG
#ifndef	NEWSGRP_DEBUG
#define	NEWSGRP_DEBUG
#endif
#endif

#ifdef DEBUG
DWORD g_cDelete = 0;
#endif

//
//	Error recovery constant - number of article id's to check before
//	assuming that a newsgroup's m_artHigh field is valid.
//
const	int	MAX_FILE_TESTS = 3 ;

const	char	*szArticleFileExtNoDot = "nws" ;
const	char	szArticleFileExtension[] = ".nws" ;

void
BuildVirtualPath(	
			LPSTR	lpstrOut,	
			LPSTR	lpstrGroupName
			) {
/*++

Routine Description -

	Given a newsgroup name generate a path string suitable
	for use with Gibralatar virtual root api's.

Arguments :

	lpstrOut - place to store path
	lpstrGroupName - newsgroup name

Return Value :

	Nothin

--*/

	lstrcpy(lpstrOut, lpstrGroupName);
}

VOID
CExpireThrdpool::WorkCompletion( PVOID pvExpireContext )
{
    GROUPID GroupId  = (GROUPID) ((DWORD_PTR)pvExpireContext);
    CNewsTree* pTree = (CNewsTree*)QueryJobContext();

    TraceFunctEnter("CExpireThrdpool::WorkCompletion");
    _ASSERT( pTree );

    //
    //  Process this group - expire articles that are older than the time horizon
    //

    CGRPPTR pGroup = pTree->GetGroupById( GroupId );
    if( pGroup ) {

        // We need bump the reference of vroot, to avoid the vroot going
        // away or changing while we are doing expiration work.
        // MatchGroupExpire is checked again due to the time window before
        // our last check
        CNNTPVRoot *pVRoot = pGroup->GetVRoot();
        if ( pVRoot && !pVRoot->HasOwnExpire()) {
            DebugTrace(0,"ThreadId 0x%x : expiring articles in group %s", GetCurrentThreadId(), pGroup->GetName());

            //
            //  Special case expiry of large groups - additional threads will be
            //  spawned if the number of articles in this group exceeds a threshold !
            //
            if( ( (lstrcmp( pGroup->GetName(), g_szSpecialExpireGroup ) == 0) ||
                  (lstrcmp( g_szSpecialExpireGroup, "" ) == 0) ) &&
                    (pGroup->GetArticleEstimate() > gSpecialExpireArtCount) ) {
                DebugTrace(0,"Special case expire triggered for %s: art count is %d", pGroup->GetName(), pGroup->GetArticleEstimate());
                if( pGroup->ExpireArticlesByTimeSpecialCase( pGroup->GetGroupExpireTime() ) ) {
                    pVRoot->Release();
                    return;
                }
                DebugTrace(0,"Group %s: Falling thro to normal expire: Low is %d High is %d", pGroup->GetName(), pGroup->GetFirstArticle(), pGroup->GetLastArticle());
            }

            //
            //  Articles in a group can be expired either by walking the article watermarks
            //  or the physical files on disk. Every Xth (X is a reg key) time we will do a
            //  FindFirst/Next so that orphaned files are cleaned up.
            //

            BOOL fDoFileScan = FALSE;
            pTree->CheckExpire( fDoFileScan );
            if( !fDoFileScan ) {
                //  Expires based on watermarks
                pGroup->ExpireArticlesByTime( pGroup->GetGroupExpireTime() );

                // Save fixed properties
                pGroup->SaveFixedProperties();
            } else {
              //  Expires based on FindFirst/Next
              pGroup->ExpireArticlesByTimeEx( pGroup->GetGroupExpireTime() );
            }

            _ASSERT( pVRoot );
            //pVRoot->Release();
        } else {
            DebugTrace( 0, "Vroot changed, we don't need to expire anymore" );
        }

        if ( pVRoot ) pVRoot->Release();

    } else {
        DebugTrace(0,"ThreadId 0x%x : GroupId %d group not found", GetCurrentThreadId(), GroupId );
    }

    TraceFunctLeave();
}

//       Binary search a range of old article from xover hash table
//       FOR every logical article in the news group
//           IF file date of article is too old
//               Expire Article
//           ENDIF
//       ENDFOR

BOOL
CNewsGroup::ExpireArticlesByTime(
					FILETIME ftExpireHorizon
					)
/*++

Routine Description :

	Expire articles in a newsgoroup.

Arguments :

--*/
{
    TraceFunctEnter( "CNewsGroup::ExpireArticlesByTime" );

    char  szMessageId[MAX_MSGID_LEN];
    DWORD cMessageId = sizeof( szMessageId ) ;
    PNNTP_SERVER_INSTANCE pInst = ((CNewsTree*)m_pNewsTree)->GetVirtualServer();

    //
    // Lock for group access
    //
    ExclusiveLock();

    ARTICLEID LowId = m_iLowWatermark, HighId = m_iHighWatermark;


    DebugTrace((LPARAM)this,"Fast expire - LowId is %d HighId is %d", LowId, HighId );

	if( !m_fAllowExpire || m_fDeleted || (LowId > HighId) || ((CNewsTree*)m_pNewsTree)->m_bStoppingTree) {
	    ExclusiveUnlock();
		return FALSE;
    }

    //
    //  Probe the *real* low mark ie first id with valid NOV entry.
    //  This call to SearchNovEntry() will delete orphaned logical entries...
    //

    while( LowId <= HighId && !pInst->XoverTable()->SearchNovEntry( m_dwGroupId, LowId, 0, 0, TRUE ) ) {
        if( GetLastError() != ERROR_FILE_NOT_FOUND ) break;
        LowId++;
    }

    //
    //  Fix the low watermark if we found a new low.
    //  This handles cases where the low mark is stuck on an orphaned id.
    //

	//EnterCriticalSection( &(m_pNewsTree->m_critLowAllocator) ) ;
	
    if( LowId > m_iLowWatermark ) {
        ErrorTrace((LPARAM)this,"Moving low watermark up from %d to %d ", 
                    m_iLowWatermark, 
                    LowId );
        m_iLowWatermark = LowId;
#ifdef DEBUG
        VerifyGroup();
#endif
    }
	//LeaveCriticalSection( &(m_pNewsTree->m_critLowAllocator) ) ;
	ExclusiveUnlock();

    //
    //  Start a linear sweep from LowId to HighId. If we find an article whose filetime is
    //  younger than the expire time horizon, we stop the scan.
    //

    DebugTrace((LPARAM)this,"Fast Expire - Scanning range %d to %d", LowId, HighId );
    for( ARTICLEID iCurrId = LowId; iCurrId <= HighId && !((CNewsTree*)m_pNewsTree)->m_bStoppingTree; iCurrId++ ) {

        BOOL  fPrimary;
        FILETIME FileTime;
        WORD	HeaderOffset ;
        WORD	HeaderLength ;
        DWORD   cMessageId = sizeof( szMessageId ) ;
        DWORD cStoreId = 0;

        if ( pInst->XoverTable()->ExtractNovEntryInfo(
                                        m_dwGroupId,
                                        iCurrId,
                                        fPrimary,
    			    		            HeaderOffset,
					    	            HeaderLength,
                                        &FileTime,
                                        cMessageId,
                                        szMessageId,
                                        cStoreId,
                                        NULL,
                                        NULL ) ) {

            szMessageId[ min(cMessageId, sizeof( szMessageId)-1) ] = '\0';
            if ( CompareFileTime( &FileTime, &ftExpireHorizon ) > 0 ) {
                // Current article has a filetime younger than the expire horizon - stop scan
                DebugTrace((LPARAM)this,"article %d is younger than expire horizon - bailing", iCurrId);
                break;
            } else {
	            CNntpReturn NntpReturn;
	            _ASSERT( g_hProcessImpersonationToken );
	            // We are using the process context to do expire
	            if (  pInst->ExpireObject()->ExpireArticle( (CNewsTree*)m_pNewsTree,
	                                                        m_dwGroupId,
	                                                        iCurrId,
	                                                        NULL,
	                                                        NntpReturn,
	                                                        NULL,
	                                                        FALSE,  // fMustDelete
	                                                        FALSE,
	                                                        FALSE,
	                                                        TRUE,
	                                                        szMessageId )
	                /* don't delete the physical article, we'll come back and
	                    expire this article the next round - if we delete the
	                    physical article now, the hash tables are going to
	                    grow wildly
	                || DeletePhysicalArticle(   NULL,
	                                            FALSE,
	                                            iCurrId,
	                                            NULL ) */
	                )
	            {
		            DebugTrace((LPARAM)0,"Expired/deleted on time basis article %d group %d", iCurrId, m_dwGroupId );
		            continue;
	            }
	            else
	            {
		            ErrorTrace((LPARAM)0,"Failed to expire/delete article %d group %d", iCurrId, m_dwGroupId );
	            }
            }
        } else {
            DWORD dwError = GetLastError();
            DebugTrace(0,"ExtractNovEntryInfo returned error %d", dwError );
        }
    }

    return TRUE;
}

//
//       FOR every physical article in the news group
//           IF file date of article is too old
//               Expire Article
//           ENDIF
//       ENDFOR

BOOL
CNewsGroup::ExpireArticlesByTimeEx(
					FILETIME ftExpireHorizon
					)
/*++

Routine Description :

	Expire articles in a newsgoroup.

Arguments :

--*/
{
	return FALSE;
}

//
//  Context for each thread
//

typedef struct _EXPIRE_CONTEXT_ {
    //
    //  Group object
    //
    CNewsGroup* pGroup;

    //
    //  LowId of this threads range
    //
    ARTICLEID   LowId;

    //
    //  HighId of this threads range
    //
    ARTICLEID   HighId;

    //
    //  FILETIME to use
    //
    FILETIME    ftExpireHorizon;
} EXPIRE_CONTEXT,*PEXPIRE_CONTEXT;

DWORD	__stdcall
SpecialExpireWorker( void	*lpv );

//
//  Spawn X threads with divvied up range and wait for all threads to complete
//

BOOL
CNewsGroup::ExpireArticlesByTimeSpecialCase(
					FILETIME ftExpireHorizon
					)
/*++

Routine Description :

	Special case expire for large groups like control.cancel

Arguments :

--*/
{
    BOOL fRet = TRUE;
    ARTICLEID LowId = GetFirstArticle(), HighId = GetLastArticle();
    PNNTP_SERVER_INSTANCE pInst = ((CNewsTree*)m_pNewsTree)->GetVirtualServer();

    TraceFunctEnter( "CNewsGroup::ExpireArticlesByTimeSpecialCase" );
    DebugTrace((LPARAM)this,"Special case expire - LowId is %d HighId is %d", LowId, HighId );

	if(IsDeleted() || (LowId > HighId) || ((CNewsTree*)m_pNewsTree)->m_bStoppingTree)
		return FALSE;

	HANDLE* rgExpireThreads;
    PEXPIRE_CONTEXT rgExpContexts;
	DWORD dwThreadId, cThreads, dwRange, CurrentLow;
    DWORD dwWait, i;
    PCHAR	args[5] ;
    CHAR    szId[12], szHigh[12], szLow[12];
    CHAR    szThreads[12];

    //
    //  Arrays of thread handles and expire contexts per thread. This is allocated
    //  off the stack as the total size is expected to be small...
    //
    rgExpireThreads = (HANDLE*) _alloca( gNumSpecialCaseExpireThreads * sizeof(HANDLE) );
    rgExpContexts = (PEXPIRE_CONTEXT) _alloca( gNumSpecialCaseExpireThreads * sizeof(EXPIRE_CONTEXT) );

    _ASSERT( rgExpireThreads );
    _ASSERT( rgExpContexts );

    //
    //  Instead of using the group HighId as the high part of the range, we want
    //  to "guess" an id between LowId and HighId that better approximates the
    //  range to be expired. This is done by CalcHighExpireId().
    //

    HighId = CalcHighExpireId( LowId, HighId, ftExpireHorizon, gNumSpecialCaseExpireThreads );
    if( HighId <= LowId ) {
        return FALSE;
    }

    dwRange = (HighId - LowId) / gNumSpecialCaseExpireThreads;
    CurrentLow = LowId;
	for( cThreads = 0; cThreads < gNumSpecialCaseExpireThreads; cThreads++ ) {
		rgExpireThreads [cThreads] = NULL;

        //
        //  Setup the contexts for each thread ie divvy up the range
        //
        rgExpContexts [cThreads].pGroup = this;
        rgExpContexts [cThreads].LowId = CurrentLow;
        rgExpContexts [cThreads].HighId = CurrentLow + dwRange - 1;
        rgExpContexts [cThreads].ftExpireHorizon = ftExpireHorizon;
        CurrentLow += dwRange;
	}

    //
    //  Override HighId of last entry
    //
    rgExpContexts [cThreads-1].HighId = HighId;

	//
    //  Spawn X worker threads
    //
	for( cThreads = 0; cThreads < gNumSpecialCaseExpireThreads; cThreads++ )
	{
        PVOID pvContext = (PVOID) &rgExpContexts [cThreads];
		rgExpireThreads [cThreads] = CreateThread(
										NULL,				// pointer to thread security attributes
										0,					// initial thread stack size, in bytes
										SpecialExpireWorker,// pointer to thread function
										(LPVOID)pvContext,	// argument for new thread
										CREATE_SUSPENDED,	// creation flags
										&dwThreadId			// pointer to returned thread identifier
										) ;

		if( rgExpireThreads [cThreads] == NULL ) {
            ErrorTrace(0,"CreateThread failed %d",GetLastError());
            fRet = FALSE;
			goto Cleanup;
		}
	}

    //
    //  Log an event warning admin about huge group
    //

    _itoa( ((CNewsTree*)m_pNewsTree)->GetVirtualServer()->QueryInstanceId(), szId, 10 );
    args[0] = szId;
    args[1] = GetNativeName();
    _itoa( cThreads, szThreads, 10 );
    args[2] = szThreads;
    _itoa( LowId, szLow, 10 );
    _itoa( HighId, szHigh, 10 );
    args[3] = szLow;
    args[4] = szHigh;

    NntpLogEvent(
	    	NNTP_EVENT_EXPIRE_SPECIAL_CASE_LOG,
		    5,
		    (const char **)args,
		    0
		    ) ;

	//
	//	Resume all threads and wait for threads to terminate
	//
	for( i=0; i<cThreads; i++ ) {
		_ASSERT( rgExpireThreads[i] );
		DWORD dwRet = ResumeThread( rgExpireThreads[i] );
		_ASSERT( 0xFFFFFFFF != dwRet );
	}

	//
	//	Wait for all threads to finish
	//
	dwWait = WaitForMultipleObjects( cThreads, rgExpireThreads, TRUE, INFINITE );

	if( WAIT_FAILED == dwWait ) {
		DebugTrace(0,"WaitForMultipleObjects failed: error is %d", GetLastError());
		fRet = FALSE;
	}

    //
    //  Check to see how good our guess was....
    //  If it turns out that HighId+1 needs to be expired,
    //  there is more work to be done in this group ie we fall thro to normal expire..
    //
    fRet = !ProbeForExpire( HighId+1, ftExpireHorizon );

Cleanup:

    //
	//	Cleanup
	//
	for( i=0; i<cThreads; i++ ) {
        if( rgExpireThreads [i] != NULL ) {
		    _VERIFY( CloseHandle( rgExpireThreads[i] ) );
		    rgExpireThreads [i] = NULL;
        }
	}

    return fRet;
}

DWORD	__stdcall
SpecialExpireWorker( void	*lpv )
/*++

Routine Description :

	Expire articles in a newsgroup in a given range

Arguments :

--*/
{
    PEXPIRE_CONTEXT pExpContext = (PEXPIRE_CONTEXT)lpv;
    CNewsGroup* pGroup = pExpContext->pGroup;
    ARTICLEID LowId = pExpContext->LowId, HighId = pExpContext->HighId;
    CNewsTree* pTree = (CNewsTree*)(pGroup->GetTree());
    PNNTP_SERVER_INSTANCE pInst = pTree->GetVirtualServer();
    char  szMessageId[MAX_MSGID_LEN];
    DWORD cMessageId = sizeof( szMessageId ) ;

    TraceFunctEnter( "SpecialExpireWorker" );
    DebugTrace(0,"special case expire - LowId is %d HighId is %d", LowId, HighId );

	if( (LowId > HighId) || pTree->m_bStoppingTree)
		return 0;

    //
    //  Start a linear sweep from LowId to HighId. If we find an article whose filetime is
    //  younger than the expire time horizon, we stop the scan.
    //

    DebugTrace((LPARAM)pGroup,"Special Case Expire - Scanning range %d to %d", LowId, HighId );
    for( ARTICLEID iCurrId = LowId; iCurrId <= HighId && !pTree->m_bStoppingTree; iCurrId++ ) {

        BOOL  fPrimary;
        FILETIME FileTime;
        WORD	HeaderOffset ;
        WORD	HeaderLength ;
        DWORD   cMessageId = sizeof( szMessageId ) ;
        DWORD   cStoreId = 0;

        if ( pInst->XoverTable()->ExtractNovEntryInfo(
                                        pGroup->GetGroupId(),
                                        iCurrId,
                                        fPrimary,
    			    		            HeaderOffset,
					    	            HeaderLength,
                                        &FileTime,
                                        cMessageId,
                                        szMessageId,
                                        cStoreId,
                                        NULL,
                                        NULL ) ) {

            szMessageId[ cMessageId ] = '\0';
            if ( CompareFileTime( &FileTime, &pExpContext->ftExpireHorizon ) > 0 ) {
                // Current article has a filetime younger than the expire horizon - stop scan
                DebugTrace((LPARAM)pGroup,"article %d is younger than expire horizon - bailing", iCurrId);
                break;
            } else {
	            CNntpReturn NntpReturn;

	            // We use the process imperonation token to do expire
	            _ASSERT( g_hProcessImpersonationToken );
	            if (  pInst->ExpireObject()->ExpireArticle( pTree,
	                                                        pGroup->GetGroupId(),
	                                                        iCurrId,
	                                                        NULL,
	                                                        NntpReturn,
	                                                        NULL,
	                                                        FALSE,
	                                                        FALSE,
	                                                        FALSE,
	                                                        TRUE,
	                                                        szMessageId ) /*
	                || ((CNewsGroup*)pGroup)->DeletePhysicalArticle(   NULL,
	                                                    FALSE,
	                                                    iCurrId,
	                                                    NULL )*/
	                )
	            {
		            DebugTrace((LPARAM)0,"Expired/deleted on time basis article %d group %d", iCurrId, pGroup->GetGroupId() );
		            continue;
	            }
	            else
	            {
		            ErrorTrace((LPARAM)0,"Failed to expire/delete article %d group %d", iCurrId, pGroup->GetGroupId() );
	            }
            }
        } else {
            DWORD dwError = GetLastError();
            DebugTrace(0,"ExtractNovEntryInfo returned error %d", dwError );
        }
    }

    return 0;
}

BOOL
CNewsGroup::ProbeForExpire(
                       ARTICLEID ArtId,
                       FILETIME ftExpireHorizon
                       )
/*++

Routine Description :

	Return TRUE if ArtId needs to be expired, FALSE otherwise

Arguments :

--*/

{
	return FALSE;
}

ARTICLEID
CNewsGroup::CalcHighExpireId(
                       ARTICLEID LowId,
                       ARTICLEID HighId,
                       FILETIME  ftExpireHorizon,
                       DWORD     NumThreads
                       )
/*++

Routine Description :

	Calculate an estimate of the highest id that needs to be expired.
    This is done per following formula:

    T1 = timestamp of LowId
    T2 = timestamp of HighId
    TC = current timestamp
    E  = expire horizon

    Average# of articles per time unit = (HighId - LowId) / (T2 - T1)

    if (TC - T1) < E => No work to do since oldest article is < horizon
    if (TC - T1) > E => (TC - T1) - E = Number of time units we are behind

    So, calculated high expire id = LowId + ((Avg# per time unit) * (TC - T1 - E))
    Note that we are given ftExpireHorizon which is (TC - E)

Arguments :

--*/

{

	return 0;
}

//       FOR every physical article in the news group in our range
//               Expire Article
//       ENDFOR
//       FOR every xover index file in the news group in our range
//               Delete the index file
//       ENDFOR
//		 NOTE: This function will DELETE all xover index files (in our range) in this directory !

BOOL
CNewsGroup::DeleteArticles(
					SHUTDOWN_HINT_PFN	pfnHint,
					DWORD				dwStartTick
					)
/*++

Routine Description :

	Delete all articles in a newsgroup. This function could be called with a
	NULL value for pfnHint. In this case, the function will bail if the service
	is stopped (a global is checked for this). Once the service is stopped,
	this function should not spend more than dwShutdownLatency amount of time
	deleting articles. (use dwStartTick as the base)

Arguments :

	pfnHint			-	pointer to stop hint function
	dwStartTick		-	timestamp of start of shutdown process

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/
{
	//WIN32_FIND_DATA FileStats;
	//HANDLE hFind;
	ARTICLEID iArticleId;
	BOOL fRet = TRUE;

    TraceFunctEnter( "CNewsGroup::DeleteArticles" );

	CNewsTree* ptree = (CNewsTree *) GetTree();
	DWORD iFreq = 0;
	PNNTP_SERVER_INSTANCE pInstance = ptree->GetVirtualServer() ;

	//
	//	First delete all articles in the group
	//

	// Expire/Delete articles ONLY if it is within our range - we dont want to delete
	// new articles in a re-created avtar of this group
	for( iArticleId = m_iLowWatermark; iArticleId <= m_iHighWatermark; iArticleId++, iFreq++ )
	{
		CNntpReturn NntpReturn;

		// If we need to bail on service stop, do so. Else give stop hints if needed
		if( ptree->m_bStoppingTree ) {
			if( !pfnHint ) {
				return FALSE;
			} else if( (iFreq%200) == 0 ) {
				pfnHint() ;
				if( (GetTickCount() - dwStartTick) > dwShutdownLatency ) {
					return FALSE;	// upper bound on shutdown latency
				}
			}
		}

		GROUPID groupidPrimary;
		ARTICLEID artidPrimary;
		DWORD DataLen;
		WORD HeaderOffset, HeaderLength;
		CStoreId storeid;

		if (pInstance->XoverTable()->GetPrimaryArticle(GetGroupId(),
														iArticleId,
														groupidPrimary,
														artidPrimary,
														0,
														NULL,
														DataLen,
														HeaderOffset,
														HeaderLength,
														storeid) &&
			(pInstance->ExpireObject()->ExpireArticle(ptree,
													  GetGroupId(),
													  iArticleId,
													  &storeid,
													  NntpReturn,
													  NULL,
													  TRUE, //fMustDelete
													  FALSE,
													  FALSE ) /*||
			 DeletePhysicalArticle(NULL, FALSE, iArticleId, &storeid)*/))
		{
			DebugTrace((LPARAM)this, "Expired/deleted article group:%d article:%d", GetGroupId(), iArticleId);
			continue;
		}
		else
		{
			// error
			ErrorTrace((LPARAM)this, "Error deleting article: group %d article %d", GetGroupId(), iArticleId);
		}
	}

	//
	//	Now delete all xover indices (*.xix) files in the newsgroup
	//	Flush all entries for this group from the xover cache so all file handles are closed
	//
	if(!FlushGroup())
	{
		// If this fails, DeleteFile may fail !
		ErrorTrace((LPARAM)this,"Error flushing xover cache entries" );
	}

	char	szCachePath[MAX_PATH*2] ;
	BOOL	fFlatDir ;
	if( ComputeXoverCacheDir( szCachePath, fFlatDir ) )	{
		ARTICLEID	artNewLow ;
		BOOL	fSuccess =
			XOVER_CACHE(((CNewsTree*)m_pNewsTree))->ExpireRange(	
										m_dwGroupId,
										szCachePath,
										fFlatDir,
										m_artXoverExpireLow,
										m_iHighWatermark+256,	// ADD MAGIC NUMBER - This ensures we delete all the .XIX files !
										artNewLow
										) ;
		if( fSuccess )
			m_artXoverExpireLow = artNewLow ;
	}

    return fRet;
}

//
// This must be the primary group for the Article.
//
BOOL
CNewsGroup::DeletePhysicalArticle(
                                HANDLE hToken,
                                BOOL    fAnonymous,
								ARTICLEID ArticleId,
								STOREID *pStoreId
									)
/*++

Routine Description :

	Delete an article file within a newsgroup.

Arguments :

	ArticleId - id of the article to be deleted.
	pStoreId  - Pointer to the store id

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "CNewsGroup::DeletePhysicalArticle" );


    HRESULT hr = S_OK;
    CNntpSyncComplete scComplete;
    INNTPPropertyBag *pPropBag = NULL;

    // get vroot
    CNNTPVRoot *pVRoot = GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Set vroot to completion object
    //
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Call the vroot wrapper
    pVRoot->DeleteArticle(  pPropBag,
                            1,
                            &ArticleId,
                            pStoreId,
                            hToken,
                            NULL,
                            &scComplete,
                            fAnonymous );

    // Wait for it to complete
    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();

    // Property bag should have already been released
    pPropBag = NULL;

Exit:

    if ( pVRoot ) pVRoot->Release();
    if ( pPropBag ) pPropBag->Release();

    if ( FAILED( hr ) ) SetLastError( hr );
    else {
        // this cast should be safe
        PNNTP_SERVER_INSTANCE pInst = ((CNewsTree*)m_pNewsTree)->GetVirtualServer() ;
        InterlockedIncrementStat( pInst, ArticlesExpired );
    }

    TraceFunctLeave();
    return SUCCEEDED( hr );
}

BOOL
CNewsGroup::DeleteLogicalArticle(
							ARTICLEID ArticleId
							)
/*++

Routine Description :

	Advance the newsgroups high and low water marks.
	If an article is deleted from the newsgroup
	we scan the xover table to determine whether there
	is a consecutive run of articles now gone from
	the group so that we can advance the low water mark
	considerably.

Arguments :

	ArticleId - id of the deleted article.

Return Value :

	TRUE if successfull (always successfull)

--*/
{
#ifdef DEBUG
    g_cDelete++;
#endif
    TraceFunctEnter( "CNewsGroup::DeleteLogicalArticle" );

    _ASSERT( m_cMessages > 0 );

    // Possibley update m_artLow
    //
    // Expiry will always delete articles in ArticleId order, but control message won't, so we have'ta
    // consider the case where deleting the m_artLow'th article will cause m_artLow to increase by more
    // than one article (up to and equal to m_artHigh).
    //
    // However, m_artHigh should never be decremented because two different articles would be assigned
    // the same ArticleId.
    //
    //

	ExclusiveLock();

	m_cMessages--;

    if ( ArticleId == m_iLowWatermark )
    {
        for ( m_iLowWatermark++; m_iLowWatermark <= m_iHighWatermark; m_iLowWatermark++ )
        {
            if ( TRUE == (((CNewsTree*)m_pNewsTree)->GetVirtualServer()->XoverTable())->SearchNovEntry( m_dwGroupId, m_iLowWatermark, 0, 0, TRUE ) )
            {
                // Next ArticleId is known valid.
                //
                break;
            }
            if ( ERROR_FILE_NOT_FOUND == GetLastError() )
            {
                // Next ArticleId is known invalid.
                //
                continue;
            }
            // We cannot make any decisions about the next ArticleId, so update
            // of m_artLow will wait. The expiry thread will start with m_artLow
            // next time. That activity should also bump m_artLow up. There could
            // be a conflict if the expiry thread and a control message try to
            // update m_artLow at the same time.
            //
            break;
        }
    }

	//LeaveCriticalSection( &(m_pNewsTree->m_critLowAllocator) ) ;
	ExclusiveUnlock();

	DebugTrace((LPARAM)this, "Deleting xover data for (%lu/%lu)", m_dwGroupId, ArticleId );

	DeleteXoverData( ArticleId ) ;
	ExpireXoverData() ;	

    return TRUE;
}

BOOL
CNewsGroup::RemoveDirectory()
{

	return FALSE;
}

DWORD	
ScanWS(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ' ' || pchBegin[i] == '\t' ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
Scan(	char*	pchBegin,	char	ch,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ch ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
ScanEOL(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
			i++ ;
			return i ;			
		}		
	}
	return	0 ;
}

DWORD	
ScanEOLEx(	char*	pchBegin,	DWORD	cb ) {
    //
    //  This is a utility used when reading a newsgroup
    //  info. from disk.
    //  This utility handles special cases of the active.txt
    //  file when the last newsgroup name is not ended with CRLF.
	//

    for( DWORD	i=0; i < cb; i++ ) {
        if( pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
            i++ ;
            return i ;			
        }		
    }
    return	i ;
}

DWORD	
ScanTab(	char*	pchBegin,	DWORD	cb ) {
    //
    //  This is a utility used when reading a newsgroup
    //  info. from disk.
    //  This utility handles special cases of the active.txt
    //  file when the last newsgroup name is not ended with CRLF.
	//

    for( DWORD	i=0; i < cb; i++ ) {
        if( pchBegin[i] == '\n' || pchBegin[i] == '\r' || pchBegin[i] == '\t' ) {
            i++ ;
            return i ;			
        }		
    }
    return	0 ;
}

DWORD
ScanNthTab( char* pchBegin, DWORD nTabs ) {

    char *pchCurrent, *pch;
    pch = pchCurrent = pchBegin;
    for( DWORD i=1; i<=nTabs && pch; i++ ) {
        pch = strchr( pchCurrent, '\t' );
        if( pch )
            pchCurrent = pch+1;
    }

    return (DWORD)(pchCurrent-pchBegin);
}

BOOL
CNewsGroup::Init(	
			char	*szVolume,	
			char	*szGroup,
			char	*szNativeGroup,
			char	*szVirtualPath,
			GROUPID	groupid,
			DWORD	dwAccess,
			HANDLE	hImpersonation,
			DWORD	dwFileSystem,
			DWORD	dwSslAccess,
			DWORD	dwContentIndexFlag
			) {
/*++

Routine Description :

	Intialize a newly created newsgroup.

Arguments :

	szVolume - path to the newsgroup
	szGroup - name of the group
	szVirtualPath - The String to use for doing Virtual Root Lookups
	groupid - groupid of the group
	dwAccess - Access as figured out by a call to LookupVirtualRoot
	hImpersonation - Impersonation Handle for this newsgroup
	dwFileSystem - File system tyep
	dwSslAccess - SSL access mask
	dwContentIndexFlag - Is content indexed ?

Return Value :

	TRUE if successfull.

--*/

	return FALSE;
}

BOOL
CNewsGroup::SetArticleWatermarks()
/*++

Routine Description :

	This should be called for a newsgroup being re-created ie. created after a recent
	delete. This function will search the newsgroups directory for existing article
	files and set its low and high watermarks past the highest article id found in the
	directory. This handles the case where a previous delete of the group failed to remove
	old article fails (ie. DeleteFile failed for some reason).

Arguments :


Return Value :

	TRUE if successfull.

--*/

{
	return FALSE;
}

FILETIME
CNewsGroup::GetGroupTime() {
/*++

Routine Description :

	Get the time the newsgroup was created.

Arguments :

	None.

Return Value :

	Time group was created.

--*/

	return	GetCreateDate() ;
}

void
CNewsGroup::SetGroupTime(FILETIME time) {
/*++

Routine Description :

	Set the time the newsgroup was created.

Arguments :

	time - the new group creation time

Return Value :

	none.

--*/
}

BOOL			
CNewsGroup::GetArticle(	IN	ARTICLEID	artid,
						IN	CNewsGroup*	pCurrentGroup,
						IN	ARTICLEID	artidCurrentGroup,
						IN	STOREID&	storeid,
						IN	class	CSecurityCtx*	pSecurity,
						IN	class	CEncryptCtx*	pEncrypt,
						IN	BOOL	fCacheIn,
						OUT	FIO_CONTEXT*	&pContext,
						IN	CNntpComplete*	pComplete						
						)	{
/*++

Routine Description :

	This function retrieves an article from the Driver.
	This should be called on the primary group object !

Arguments :

	artid - The id of the article we want to get
	pSecurity - the Session's NTLM bassed security context
	pEncrypt - the Session's SSL based security context
	fCacheIn - do we want this handle to reside in the cache ? - IGNORED
	hFile - the location that gets the file handle
	pContext - the address that gets the context pointer
	dwFileLength

Return Value :

	TRUE if operation successfully pended
	FALSE otherwise !


--*/

	DWORD	dwFileLengthHigh ;

	pContext = 0 ;

	TraceFunctEnter( "CNewsGroup::GetArticle" ) ;



	ShareLock() ;

	DWORD	dwError = 0 ;

	HANDLE	hImpersonate = NULL ;
	BOOL	fCache = fCacheIn ;
    BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
        fAnonymous = pSecurity->IsAnonymous();

	}

	fCache = fCache && fCacheIn ;

	m_pVRoot->GetArticle(	this,
							pCurrentGroup,
							artid,
							artidCurrentGroup,
							storeid,
							&pContext,
					        hImpersonate,		
							pComplete,
                            fAnonymous
							) ;
	ShareUnlock() ;

	return	TRUE ;
}



void
CNewsGroup::FillBufferInternal(
				IN	ARTICLEID	articleIdLow,
				IN	ARTICLEID	articleIdHigh,
				IN	ARTICLEID*	particleIdNext,
				IN	LPBYTE		lpb,
				IN	DWORD		cbIn,
				IN	DWORD*		pcbOut,
				IN	CNntpComplete*	pComplete
				)	{
/*++

Routine Description :

	Get Xover data from the index files.

Arguments :

	lpb - buffer where we are to store xover data
	cb -	number of bytes available in the buffer
	artidStart - First article we want in the query results
	artidFinish - Last article we want in the query results (inclusive)
	artidLast - Next article id we should query for
	hXover - Handle which will optimize future queries

Return Value :

	Number of bytes placed in the buffer.

--*/

	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	m_pVRoot->GetXover(	
				this,
				articleIdLow,
				articleIdHigh,
				particleIdNext,
				(char*)lpb,
				cbIn,
				pcbOut,
				hImpersonate,
				pComplete,
				fAnonymous
				) ;
}




void
CNewsGroup::FillBuffer(
				IN	class	CSecurityCtx*	pSecurity,
				IN	class	CEncryptCtx*	pEncrypt,
				IN	class	CXOverAsyncComplete&	complete
				)	{
/*++

Routine Description :

	Get Xover data from the index files.

Arguments :

	lpb - buffer where we are to store xover data
	cb -	number of bytes available in the buffer
	artidStart - First article we want in the query results
	artidFinish - Last article we want in the query results (inclusive)
	artidLast - Next article id we should query for
	hXover - Handle which will optimize future queries

Return Value :

	Number of bytes placed in the buffer.

--*/

	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
		fAnonymous = pSecurity->IsAnonymous();

	}

	HitCache() ;

	if(	ShouldCacheXover() ) {

		BOOL	fFlatDir;
		HXOVER	hXover;

		char* szPath = XNEW char[MAX_PATH*2];

		if (szPath && ComputeXoverCacheDir(szPath, fFlatDir)) {

			complete.m_groupHighArticle = GetHighWatermark() ;

            //
            // Pend a FillBuffer operation.  If it fails, fall thru
            // to the old way of getting xover data
            //
			if (XOVER_CACHE(((CNewsTree*)m_pNewsTree))->FillBuffer(
			        &complete.m_CacheWork,
					szPath,
					fFlatDir,
					hXover
				)) {
				XDELETE [] szPath;
				return;
			}
		}
		if (szPath)
			XDELETE [] szPath;
	}

	m_pVRoot->GetXover(	
				this,
				complete.m_currentArticle,
				complete.m_hiArticle,
				&complete.m_currentArticle,
				(char*)complete.m_lpb,
				complete.m_cb,
				&complete.m_cbTransfer,
				hImpersonate,
				&complete,
				fAnonymous
				) ;
	

}

void
CNewsGroup::FillBuffer(
				IN	class	CSecurityCtx*	pSecurity,
				IN	class	CEncryptCtx*	pEncrypt,
				IN	class	CXHdrAsyncComplete&	complete
				)	{
/*++

Routine Description :

	Get Xhdr data from the index files.

Arguments :

    CSecurityCtx    *pSecurity  - Security context
    CEncryptCtx     *pEncrypt   - Encrypt context
    CXHdrAsyncComplete& complete - Completion object

Return Value :

	Number of bytes placed in the buffer.

--*/

	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
		fAnonymous = pSecurity->IsAnonymous();

	}

	m_pVRoot->GetXhdr(	
				this,
				complete.m_currentArticle,
				complete.m_hiArticle,
				&complete.m_currentArticle,
				complete.m_szHeader,
				(char*)complete.m_lpb,
				complete.m_cb,
				&complete.m_cbTransfer,
				hImpersonate,
				&complete,
				fAnonymous
				) ;
}

void
CNewsGroup::FillBuffer(
				IN	class	CSecurityCtx*	pSecurity,
				IN	class	CEncryptCtx*	pEncrypt,
				IN	class	CSearchAsyncComplete&	complete
				)	{


	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
		fAnonymous = pSecurity->IsAnonymous();

	}

	m_pVRoot->GetXover(	
				this,
				complete.m_currentArticle,
				complete.m_currentArticle,
				&complete.m_currentArticle,
				(char*)complete.m_lpb,
				complete.m_cb,
				&complete.m_cbTransfer,
				hImpersonate,
				complete.m_pComplete,
				fAnonymous
				) ;
	
}

void
CNewsGroup::FillBuffer(
				IN	class	CSecurityCtx*	pSecurity,
				IN	class	CEncryptCtx*	pEncrypt,
				IN	class	CXpatAsyncComplete&	complete
				)	{
/*++

Routine Description :

	Get Xhdr data from the index files for search.

Arguments :

    CSecurityCtx    *pSecurity  - Security context
    CEncryptCtx     *pEncrypt   - Encrypt context
    CXHdrAsyncComplete& complete - Completion object

Return Value :

	Number of bytes placed in the buffer.

--*/

	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
		fAnonymous = pSecurity->IsAnonymous();

	}

	m_pVRoot->GetXhdr(	
				this,
				complete.m_currentArticle,
				complete.m_currentArticle,
				&complete.m_currentArticle,
				complete.m_szHeader,
				(char*)complete.m_lpb,
				complete.m_cb,
				&complete.m_cbTransfer,
				hImpersonate,
				complete.m_pComplete,
				fAnonymous
				) ;
}


CTOCLIENTPTR
CNewsGroup::GetArticle(
				ARTICLEID		artid,
				IN	STOREID&	storeid,
				CSecurityCtx*	pSecurity,
				CEncryptCtx*	pEncrypt,
				BOOL			fCacheIn
				)	{
/*++

Routine Description :

	given an articleid create a CArticle derived object which
	can be used to send the article to a client.

Arguments :

	artid - id of the article we want to open
	pSecurity - The CSecurityCtx which logged on the client.
		In the case of feeds etc, we may be passed NULL which indicates
		that we should not bother with any impersonation.
	fCache - TRUE if we want the article to reside in the cache

Return Value :

	Smart pointer to a CArticle object
	Will be NULL if call failed.

--*/

	CToClientArticle	*pArticle = NULL;

	TraceFunctEnter( "CNewsGroup::GetArticle" ) ;
	CNntpSyncComplete	complete ;
	if( complete.IsGood() ) 	{
		FIO_CONTEXT*	pFIOContext = 0 ;
		GetArticle(	artid,
					0,
					INVALID_ARTICLEID,
					storeid,
					pSecurity,
					pEncrypt,
					fCacheIn,
					pFIOContext,
					&complete
					) ;

        _ASSERT( complete.IsGood() );
		HRESULT	hr = complete.WaitForCompletion() ;
		if( hr == S_OK 	&&	pFIOContext != 0 )	{
			_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
			
			pArticle = new CToClientArticle;
			if ( pArticle ) {
				//
				// Create allocator for storing parsed header values
				// Must last longer than the article that uses it.
				//
				const DWORD cchMaxBuffer = 1 * 1024;
				char rgchBuffer[cchMaxBuffer];
				CAllocator allocator(rgchBuffer, cchMaxBuffer);
				CNntpReturn	nntpReturn ;
				if ( ! pArticle->fInit( pFIOContext, nntpReturn, &allocator ) ) {
					DebugTrace( 0, "Initialize article object failed %d",
								GetLastError() );
	
					// But I will still try to loop thru other articles
					ReleaseContext( pFIOContext ) ;
					delete pArticle;
					pArticle = NULL;
				}	else	{
					return	pArticle ;
				}
			}
		}
	}
	return	0 ;
}

CToClientArticle *
CNewsGroup::GetArticle(
                CNntpServerInstanceWrapper  *pInstance,
				ARTICLEID		            artid,
				IN	STOREID&	            storeid,
				CSecurityCtx*	            pSecurity,
				CEncryptCtx*	            pEncrypt,
				CAllocator                  *pAllocator,
				BOOL			            fCacheIn
				)	{
/*++

Routine Description :

	given an articleid create a CArticle object which
	can be used to send the article to moderator.

Arguments :

    pInstance   - Instance wrapper
	artid       - id of the article we want to open
	pSecurity   - The CSecurityCtx which logged on the client.
		            In the case of feeds etc, we may be passed NULL which indicates
		            that we should not bother with any impersonation.
	fCache      - TRUE if we want the article to reside in the cache

Return Value :

	Smart pointer to a CArticle object
	Will be NULL if call failed.

--*/

	CToClientArticle	*pArticle = NULL;

	TraceFunctEnter( "CNewsGroup::GetArticle" ) ;
	CNntpSyncComplete	complete ;
	if( complete.IsGood() ) 	{
		FIO_CONTEXT*	pFIOContext = 0 ;
		GetArticle(	artid,
					0,
					INVALID_ARTICLEID,
					storeid,
					pSecurity,
					pEncrypt,
					fCacheIn,
					pFIOContext,
					&complete
					) ;

        _ASSERT( complete.IsGood() );
		HRESULT	hr = complete.WaitForCompletion() ;
		if( hr == S_OK 	&&	pFIOContext != 0 )	{
			_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
			
			pArticle = new CToClientArticle;
			if ( pArticle ) {
				//
				// Create allocator for storing parsed header values
				// Must last longer than the article that uses it.
				//
				CNntpReturn	nntpReturn ;
				if ( ! pArticle->fInit( NULL,
	                                    nntpReturn,
	                                    pAllocator,
	                                    pInstance,
	                                    pFIOContext->m_hFile,
	                                    0,
	                                    TRUE
	                                   ) ){
					DebugTrace( 0, "Initialize article object failed %d",
								GetLastError() );
	
					ReleaseContext( pFIOContext ) ;
					delete pArticle;
					pArticle = NULL;
				}	else	{
					return	pArticle ;
				}
			}
		}
	}
	return	0 ;
}

DWORD
CNewsGroup::CopyHelpText(	
		char*	pchDest,	
		DWORD	cbDest
		) {
/*++

Routine Description :

	Copy the string specifying the help text for the newsgroup
	into the provided buffer.
	We will also copy in the terminating CRLF for the line.

Arguments :

	pchDest - buffer to store string in
	cbDest - size of output buffer

Return Value :

	Number of bytes copied.
	0 if the buffer is to small to hold the help text.
	Since we always put in the CRLF, a 0 return unambiguously
	indicates that the callers buffer is to small.
	
--*/

	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;

	static	char	szEOL[] = "\r\n" ;

	DWORD cchHelpText;
	const char *pszHelpText = GetHelpText(&cchHelpText);
	if (GetHelpText(&cchHelpText) != NULL ) {
		if (cbDest >= cchHelpText + sizeof(szEOL)) {
			CopyMemory(pchDest, pszHelpText, cchHelpText);
			cbRtn = cchHelpText;
		} else {
			return	0;
		}
	}	

	CopyMemory( pchDest+cbRtn, szEOL, sizeof( szEOL ) - 1 ) ;
	cbRtn += sizeof( szEOL ) - 1 ;

	return	cbRtn ;
}


DWORD
CNewsGroup::CopyHelpTextForRPC(	
		char*	pchDest,	
		DWORD	cbDest
		) {
/*++

Routine Description :

	Copy the string specifying the help text for the newsgroup
	into the provided buffer.
	We will NOT place a terminting CRLF into the buffer

Arguments :

	pchDest - buffer to store string in
	cbDest - size of output buffer

Return Value :

	Number of bytes copied.
	0 if the buffer is to small to hold the help text.
	Since we always put in the CRLF, a 0 return unambiguously
	indicates that the callers buffer is to small.
	
--*/

	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;

	DWORD cchHelpText;
	const char *pszHelpText = GetHelpText(&cchHelpText);
	if (GetHelpText(&cchHelpText) != NULL ) {
		if (cbDest >= cchHelpText) {
			CopyMemory(pchDest, pszHelpText, cchHelpText);
			cbRtn = cchHelpText;
		} else {
			return	0;
		}
	}	

	return	cbRtn ;
}

DWORD
CNewsGroup::CopyModerator(	
		char*	pchDest,	
		DWORD	cbDest
		)	{
/*++

Routine Description :

	This function retrieves the name of the moderator for a newsgroup.
	If there is no moderator, we return 0, otherwise we return the
	number of bytes copied into the provided buffer.

Arguments :

	pchDest - Buffer to store moderator name
	cbDest -  Number of bytes in destination buffer

Return Value :

	0 == No Moderator
	Non zero - number of bytes in moderator name

--*/

	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;

	DWORD cchModerator;
	const char *pszModerator = GetModerator(&cchModerator);
	if (GetModerator(&cchModerator) != NULL ) {
		if (cbDest >= cchModerator) {
			CopyMemory(pchDest, pszModerator, cchModerator);
			cbRtn = cchModerator;
		} else {
			return	0;
		}
	}	

	return	cbRtn ;
}

DWORD
CNewsGroup::CopyPrettynameForRPC(	
		char*	pchDest,	
		DWORD	cbDest
		)	{
/*++

Routine Description :

	This function retrieves the prettyname for a newsgroup.
	If there is no prettyname, we return 0, otherwise we return the
	number of bytes copied into the provided buffer.
	We will NOT place a terminting CRLF into the buffer

Arguments :

	pchDest - Buffer to store prettyname
	cbDest -  Number of bytes in destination buffer

Return Value :

	0 == No Prettyname
	Non zero - number of bytes in prettyname

--*/
	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;

	DWORD cchPrettyName;
	const char *pszPrettyName = GetPrettyName(&cchPrettyName);
	if (GetPrettyName(&cchPrettyName) != NULL ) {
		if (cbDest >= cchPrettyName ) {
			CopyMemory(pchDest, pszPrettyName, cchPrettyName);
			cbRtn = cchPrettyName;
		} else {
			return	0;
		}
	}	

	return	cbRtn ;
}

DWORD
CNewsGroup::CopyPrettyname(	
		char*	pchDest,	
		DWORD	cbDest
		)	{
/*++

Routine Description :

	This function retrieves the prettyname for a newsgroup.
	If there is no prettyname, we return 0, otherwise we return the
	number of bytes copied into the provided buffer.
	We will also copy in the terminating CRLF for the line.

Arguments :

	pchDest - Buffer to store prettyname
	cbDest -  Number of bytes in destination buffer

Return Value :

	0 == No Prettyname
	Non zero - number of bytes in prettyname

--*/

	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;
	DWORD cch;
	const char *psz = GetPrettyName(&cch);
	static	char	szEOL[] = "\r\n" ;

	//
	//	per RFC, return newsgroup name if no prettyname is available
	//
	
	if( psz == 0 ) {
		psz = GetNativeName();
		cch = GetGroupNameLen();
	}
		
	if( cbDest >= cch + sizeof( szEOL ) ) {
		CopyMemory( pchDest, psz, cch ) ;
		cbRtn = cch ;
	}	else	{
		return	0 ;
	}

	CopyMemory( pchDest+cbRtn, szEOL, sizeof( szEOL ) - 1 ) ;
	cbRtn += sizeof( szEOL ) - 1 ;

	return cbRtn ;
}

BOOL
CNewsGroup::IsGroupVisible(
					CSecurityCtx&	ClientLogon,
					CEncryptCtx&    ClientSslLogon,
					BOOL			IsClientSecure,
					BOOL			fPost,
					BOOL			fDoTest
					) {
/*++

Routine Description :

	Determine whether the client has visibility to this newsgroup.

Arguments :

	ClientLogon -	The CSecurityCtx containing the clients logon
			information etc...
	IsClientSecure - Is the client connected over a secure (SSL)
			session
	fPost -		Does the client want to post to the group or
			read from the group.

Return Value :

	TRUE	if the client has visibility to the newsgroup

	NOTE: check for visibility is done only if enabled in the vroot info mask

--*/

	BOOL fReturn = TRUE;



	if( IsVisibilityRestrictedInternal() )
	{
		fReturn = IsGroupAccessibleInternal(
									ClientLogon,
									ClientSslLogon,
									IsClientSecure,
									fPost,
									fDoTest
									) ;
	}


	return	fReturn ;
}

BOOL
CNewsGroup::IsGroupAccessible(
					CSecurityCtx    &ClientLogon,
					CEncryptCtx     &EncryptCtx,
					BOOL			IsClientSecure,
					BOOL			fPost,
					BOOL			fDoTest
					) {
/*++

Routine Description :

	Determine whether the client has access to this newsgroup.

	****** This is now done via instant update in the expiry thread ********
	Do this after updating our virtual root information, and
	the grab the necessary locks to make sure virtual root
	info. doesn't change while we're running !

Arguments :

	ClientLogon -	The CSecurityCtx containing the clients logon
			information etc...
	SslContext - The CEncryptCtx containing all the SSL connection
			information like cert-mapping, key size etc.
	IsClientSecure - Is the client connected over a secure (SSL)
			session
	fPost -		Does the client want to post to the group or
			read from the group.

Return Value :

	TRUE	if the client can access the newsgroup

--*/



	BOOL	fReturn = IsGroupAccessibleInternal(
									ClientLogon,
									EncryptCtx,
									IsClientSecure,
									fPost,
									fDoTest
									) ;


	return	fReturn ;
}

BOOL
CNewsGroup::IsGroupAccessibleInternal(
					CSecurityCtx&	ClientLogon,
					CEncryptCtx&	SslContext,
					BOOL			IsClientSecure,
					BOOL			fPost,
					BOOL			fDoTest
					) {
/*++

Routine Description :

	Determine whether the client has access to this newsgroup.

	******** Assumes locks are held **************

Arguments :

	ClientLogon -	The CSecurityCtx containing the clients logon
			information etc...
	SslContext - The CEncryptCtx containing all the SSL connection
			information like cert-mapping, key size etc.
	IsClientSecure - Is the client connected over a secure (SSL)
			session
	fPost -		Does the client want to post to the group or
			read from the group.
	hCertToken - If SSL client cert has been mapped to an NT account,
			this is the mapped token.

Return Value :

	TRUE	if the client can access the newsgroup

--*/

	TraceFunctEnter("CNewsGroup::IsGroupAccessibleInternal");

	HANDLE hCertToken = SslContext.QueryCertificateToken();

	if( IsSecureGroupOnlyInternal() &&
			(!IsClientSecure || !IsSecureEnough( SslContext.QueryKeySize() ))  )
		return	FALSE ;

	// check write access
	if( fPost && IsReadOnlyInternal() )
		return	FALSE ;

	if( !ClientLogon.IsAuthenticated() && !hCertToken )
		return	FALSE ;

	//
	//	Don't bother doing all this access checking stuff we
	//	go through below if we're on a FAT drive.
	//

	BOOL	fReturn = FALSE ;
	DWORD	dwError = ERROR_SUCCESS ;

	if( !fDoTest ) {

		return	TRUE ;
	
	}	else	{

		DWORD	dwTest = NNTP_ACCESS_READ ;

		if( fPost ) {

			dwTest = NNTP_ACCESS_POST ;

		}	

		//
		//	Do the SSL session based auth first
		//
		
		if( hCertToken )
		{
            fReturn = CNewsGroupCore::IsGroupAccessible(    hCertToken,
                                                            dwTest );
		} else {

			//
			// ok, now do the auth level check
			// NOTE: SSL session token takes precedence over logon context
			//

			HANDLE hToken = NULL;
			BOOL fNeedsClosed = FALSE;

			SelectToken(&ClientLogon, &SslContext, &hToken);

            fReturn = CNewsGroupCore::IsGroupAccessible(
                                hToken,
                                dwTest );

		}
	}
	SetLastError( dwError ) ;

	return	fReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\newsgrp.h ===
/*++
// newsgrp.h -
//
// This file provides classes defining the interfaces to newsgroups.
//
// A newsgroup will be represented on disk as a directory containing a set
// of files.  Each of those files will be an article in the newsgroup.
// CNewsGroup will represent a newsgroup within a server.  Each newsgroup directory
// on the hard disk will contain a file which holds config information for the
// newsgroup.  If there is no such file, than we will inherit the config information of
// a parent newsgroup.
//
// In this file we provide two classes - CNewsGroup, the generic newsgroup,
//	and CNewsTree a class which will be used to manipulate the newstree as a whole.
//  Only one CNewsTree object will exist in the NNTP server.
//
//	The following are registry keys which we will examine on Boot Up to determine newsgroup
//	properties :
//
//		NNTP\Roots - this key will contain a sub key for each directory specified in the
//			Admin Roots dialog.  During boot up we will recursively scan all subdirectories
//			from each of these roots to locate every newsgroup object.
//
//		NNTP\Expirations - this registry key will contain expiration information for newsgroups.
//			Each subkey will have an 'expiration name'.  The subkey will contain reg values
//			that represent Expiration Time, Expiration Disk Size, and a REG_MULTI_SZ that contains
//			a regular expression strings which specify which newsgroups use this expiration
//			policy.
//
//		In addition there will be some values under NNTP\ServerSettings which specify how
//		large the newsgroup hash tables should be which can be tweaked to improve server
//		performance.
//
//	The following newsgroup properties will be stored in config files which are
//	stored in each newsgroup directory.  If a newsgroup directory does not have such a config
//	file it can inherit the properties from a file farther up the directory tree.
//	(Not the newsgroup tree.)
//
//		MSN Token for the newsgroup
//		Moderated flag
//		Read Only flag
//		Low Article Number
//		High Article Number
//		Number of Articles.
//
//	These properties will be accessed through the NT GetPrivateProfile, WritePrivateProfile api's
//	and the .ini files will be hand editable.
//
//	Initialization -
//
//		The CNewsTree object must be initialized before News Feeds are read from the registry.
//		Upon boot the CNewsTree object will do the following steps :
//
//			1) Recursively Scan from Volume Root directories and create a Newsgroup object
//				for every newsgroup.
//			2) Read the NNTP\Expirations registry key and set the Newsgroup expiration policies
//				appropriately.
//			
//		After this has been completed, the Feeds will be read from the registry and each Newsgroup
//		object will be visited to set its Feed pointers.
//
//	Iteration -
//
//		In the following situations it will be necessary to enumerate newsgroups
//		in combination with some pattern string
//		(A pattern string is something in the form of 'comp.*')
//
//			Expiration Configuration - setting newsgroup expiration properties
//			Feed Configuration - setting newsgroup feed information
//			Client Requests - processing commands such as 'list comp.*' and 'newnews comp.*'
//
//		To support this file will defined a CGroupIterator class which can handle
//		all of these requests.   This CGroupIterator will be able to work its way through an
//		Alphabetically sorted list of newsgroup (held by CNewsTree) and check that each
//		newsgroup meets the pattern matching requirements.  Each time somebody with
//		a CGroupIterator object calls its Next() function, the iterator will start examining
//		from its current position in the list to find the next valid CNewsGroup object.
//
//		This is done in terms of an Iteration function instead of a call back for the following
//		reasons :
//			1) When processing Client Requests the session code will want to be able to build
//			partial results to send to the Client.
//
//
//  Implementation Schedule for all classes defined by this file :
//
//		Milestone 1 related work ;
//			Build complete tree of objects, and save articles in news groups 	1w  dev and test
//			(Unit Test : An .exe that will build the entire CNewsTree structure in memory and
//			do multi-threaded searches in that structure.)
//
//		Milestone 2 related work :
//			Expire articles from the news tree	1w dev and test
//			(Unit test : an .exe that will build entire CNewsTree structure in memory, and will start
//			deleting articles.)
//
//		Milestone 3 related work :
//			Newsgroup spread across volumes and iteration through newsgroups based on pattern match strings.
//			(This covers the CGroupIterator class)
//			Time Estimate : 2weeks dev. and test
//
//		Milestone 4 related work :
//			Caching of group information, especially CArticle objects.
//	
--*/




#ifndef	_NEWSGRP_H_
#define	_NEWSGRP_H_


#include    "smartptr.h"
#include    "string.h"
#include	"fhash.h"
#include	"rwnew.h"
#include	"addon.h"

// built from news\server\newstree\src\newstree.idl
// both are in news\core\include
#include	"group.h"
#include 	"nwstree.h"

class	CArticle ;
class	CArticleRef ;
class	COutFeed ;
class	CArticleCore ;
class	CToClientArticle ;

// extern	CXoverCache	gXCache ;

typedef CRefPtr< CArticle > CARTPTR ;
typedef CRefPtr< COutFeed > COUTFEEDPTR ;
typedef	CRefPtr< CArticle >	CARTPTR ;
typedef	CRefPtr< CToClientArticle >	CTOCLIENTPTR ;

//
//	Utility functions
//
extern	DWORD	Scan(	char*	pchBegin,	char	ch,	DWORD	cb ) ;
extern	DWORD	ScanEOL(	char*	pchBegin,	DWORD	cb ) ;
extern	DWORD	ScanEOLEx(	char*	pchBegin,	DWORD	cb ) ;
extern	DWORD	ScanTab(	char*	pchBegin,	DWORD	cb ) ;
extern	DWORD	ScanWS(	char*	pchBegin,	DWORD	cb ) ;
extern  DWORD	ScanDigits(	char*	pchBegin,	DWORD	cb ) ;
extern  DWORD   ScanNthTab( char* pchBegin, DWORD nTabs ) ;
extern	void	BuildVirtualPath(	LPSTR	lpstrOut,	LPSTR	lpstrGroupName ) ;

#define	CREATE_FILE_STRING	"\\\\?\\"

//
//	This is a protototype for a function that will be called during
//	shutdown. This is needed to send stop hints to SCM
//
typedef	void	(*	SHUTDOWN_HINT_PFN)(	void	) ;

//---------------------------------
//
//  This section defines some basic info which
//  needs to be specified in other header files.
//


#define	FIRST_RESERVED_GROUPID	1
#define	LAST_RESERVED_GROUPID	256
#define	FIRST_GROUPID			257
#define MAX_HIGHMARK_GAP		100000

class	CNewsGroup : public CNewsGroupCore {

	friend CGroupIterator;

//
//	A CNewsGroup object represents one newsgroup.
//	Newsgroups are accessed through 3 mechanisms that are
//	supported in CNewsTree -
//	
//	Hash Table by newsgroup name
//	Hash Table by newsgroup id
//	CGroupIterator - iterate through all newsgroups alphabetically
//
//	We store everything that represents a newsgroup.
//	In some cases such as for moderators and descriptive text,
//	the data references locations within a Memory Mapping
//	managed by a CAddon derived object.  In these cases
//	we must carefully synchronize access to the info.
//
private :

	FILETIME m_time;

    //
    //  Expire time horizon
    //
    FILETIME    m_ftExpireHorizon;

	//
	//	Determine whether this newsgroup is Read Only
	//
	inline	BOOL	IsReadOnlyInternal() ;

	//
	//	Determine whether this newsgroup requires SSL
	//
	inline	BOOL	IsSecureGroupOnlyInternal() ;

	//
	//	Determine if key size is secure enough for this newsgroup
	//
	inline	BOOL	IsSecureEnough( DWORD dwKeySize ) ;

	//
	//	Determine whether visibility is restricted on this newsgroup
	//
	inline	BOOL	IsVisibilityRestrictedInternal() ;

	//
	//	Function for determining whether a newsgroup is accessible
	//	by a client, assumes all the necessary locks are held when
	//	called !!!
	//
	BOOL	IsGroupAccessibleInternal(	
						class	CSecurityCtx&	ClientLogon,	
						class	CEncryptCtx&	SslContext,	
						BOOL			IsClientSecure,
						BOOL			fPost,
						BOOL			fDoTest = FALSE
						) ;


	//
	//	Helper function for generating file system article ids that
	//	optimize CreateFile() performance.
	//
	inline	DWORD	ByteSwapper( DWORD ) ;

	//
	//	This function mucks with bits in articleid's so that when
	//	we create/open files we get good performance from CreateFile()
	//	on NTFS systems.  (Results in file names which give better
	//	performance with the OS's poorly balanced B-Trees)
	//	
	inline	ARTICLEID	ArticleIdMapper( ARTICLEID ) ;

    //
    // Private Interface for CNewsTree for hashing CNewsGroup objects.
    //
    friend      class   CNewsTree ;

    // for debugger extension
	friend		CNewsGroup* DbgPrintNewsgroup(CNewsGroup * pSrcGroup);

public :

	//------------------------------------
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects.
    //
    // Lightweight Constructors -
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //
    CNewsGroup(CNewsTreeCore *pNewsTree) :
    	CNewsGroupCore(pNewsTree) {}

    BOOL    Init(	char *szVolume,
					char *szGroup,
					char *szNativeGroup,
					char *szVirtualPath,
					GROUPID	groupid,
					DWORD	dwAccess,
					HANDLE	hImpersonation,
					DWORD	dwFileSystem,
					DWORD   dwSslAccess = 0,
					DWORD   dwContentIndexFlag = 0
					) ;

	BOOL	SetArticleWatermarks();


	//------------------------------------
	//  Article Management Interface -
	//   The following functions allow the caller to manipulation
	//	 Articles within the newsgroup.
	
	//
	// Call this function when you wish to read the article into memory.
	// This function will create a memory mapping and the use this to
	// initialize a CArticle.  This class may cache CArticle's.
	//
	CTOCLIENTPTR
	GetArticle(
				ARTICLEID		artid,
				IN	STOREID&	storeid,
				CSecurityCtx*	pSecurity,
				CEncryptCtx*	pEncrypt,
				BOOL			fCacheIn
				)	;

	//	
	//	This function will retrieve an article from the driver !
	//
	BOOL			GetArticle(	IN	ARTICLEID	artid,
								IN	CNewsGroup*	pCurrentGroup,
								IN	ARTICLEID	artidCurrent,
								IN	STOREID&	storeid,
								IN	class	CSecurityCtx*	pSecurity,
								IN	class	CEncryptCtx*	pEncrypt,
								IN	BOOL	fCache,
								OUT	FIO_CONTEXT*	&pContext,
								IN	CNntpComplete*	pComplete
								) ;

	//
	// retrieve article with a different fInit function
	//
	CToClientArticle *  GetArticle(
                CNntpServerInstanceWrapper  *pInstance,
				ARTICLEID		            artid,
				IN	STOREID&	            storeid,
				CSecurityCtx*	            pSecurity,
				CEncryptCtx*	            pEncrypt,
				CAllocator                  *pAllocator,
				BOOL			            fCacheIn );
		
	void			CalibrateWatermarks( ARTICLEID	LowestFound, ARTICLEID HighestFound ) ;

	//
	//	Copy an article into the tree, doing necessary security stuff !
	//
	BOOL			InsertArticle(
							CArticle *pArticle,
							void *pGrouplist,
							DWORD dwFeedId,
							ARTICLEID,
							LPSTR	lpstrFileName,
							class	CSecurityCtx*	pSecurity,
							BOOL	fIsSecureSession,
							const char *multiszNewsgroups
							) ;

	//
	//	Create an ArticleFile and do the necessary IO to create an article -
	//	this is used when incoming articles are small enough to fit in memory cache !
	//
	BOOL			InsertArticle(
							CArticle *pArticle,
							void *pGrouplist,
							DWORD dwFeedId,
							ARTICLEID,
							char*	pchHead,
							DWORD	cbHead,
							char*	pchBody,
							DWORD	cbBody,
							class	CSecurityCtx*	pSecurity,
							BOOL	fIsSecureSession,
							const char *multiszNewsgroups
							) ;


	//
	//	Interface used by XOVER cache for doing cache fills !
	//
	void
	FillBufferInternal(
					IN	ARTICLEID	articleIdLow,
					IN	ARTICLEID	articleIdHigh,
					IN	ARTICLEID*	particleIdNext,
					IN	LPBYTE		lpb,
					IN	DWORD		cbIn,
					IN	DWORD*		pcbOut,
					IN	CNntpComplete*	pComplete
					)	;

	//
	//	Interface for getting Xover data from the index files !
	//
	void			FillBuffer(
							IN	class	CSecurityCtx*	pSecurity,
							IN	class	CEncryptCtx*	pEncrypt,
							class	CXOverAsyncComplete&	complete
							) ;

    //
    // Interface for getting xhdr data from the index files !
    //
    void            FillBuffer(
				            IN	class	CSecurityCtx*	pSecurity,
				            IN	class	CEncryptCtx*	pEncrypt,
				            IN	class	CXHdrAsyncComplete&	complete
				            );

	//
	//	Interface for getting Xover data for the search command
	//
	void			FillBuffer(
							IN	class	CSecurityCtx*	pSecurity,
							IN	class	CEncryptCtx*	pEncrypt,
							class	CSearchAsyncComplete&	complete
							) ;

	//
	//	Interface for getting Xhdr data for the xpat command
	//
	void			FillBuffer(
							IN	class	CSecurityCtx*	pSecurity,
							IN	class	CEncryptCtx*	pEncrypt,
							class	CXpatAsyncComplete&	complete
							) ;




	//
	//	Interface for expiring an Xover entry from an index file !	
	//
	inline
	BOOL			ExpireXoverData( ) ;

	//
	//	Interface for getting rid of all xover index files !
	//

	//
	//	Interface for flushing all entries for this group
	//
	inline
	BOOL			FlushGroup( ) ;

	//
	//	Interface for deleting an Xover entry - use for cancel'd articles !
	//
	inline
	BOOL			DeleteXoverData(
							ARTICLEID	article
							) ;

    // Physically (and Logically) remove an article from the news tree. This
    // function only affects the news tree. Other data structure that keep
    // information pointing to this article need to be changed before calling
    // this function. Of course, physical deletion implies primary group.
    //
    BOOL           ExpireArticlesByTime( FILETIME ftExpireHorizon );
    BOOL           ExpireArticlesByTimeSpecialCase( FILETIME ftExpireHorizon );
    BOOL           ProbeForExpire( ARTICLEID ArtId, FILETIME ftExpireHorizon );
    ARTICLEID      CalcHighExpireId( ARTICLEID LowId, ARTICLEID HighId, FILETIME ftExpireHorizon, DWORD NumThreads );
    BOOL           ExpireArticlesByTimeEx( FILETIME ftExpireHorizon );
    BOOL           DeleteArticles( SHUTDOWN_HINT_PFN pfnHint = NULL, DWORD dwStartTick = 0 );
    BOOL           DeletePhysicalArticle( HANDLE, BOOL, ARTICLEID, STOREID* );
    BOOL           DeleteLogicalArticle( ARTICLEID );
    BOOL           RemoveDirectory();
	

	//
	//	This function is for use when rebuilding the server, we will rescan the newsgroups
	//	and rebuild the high low watermarks, as well as the count of articles.
	//	This function will reset the count of articles back to 0.
	//
	inline	void		ResetCount() {
		SetMessageCount(0);
	}

	//
	// Call this function to create an article in the Newsgroup
	// with an article id of ARTICLEID which is
	// a reference to another Article in another Newsgroup.  This will be
	// used when processing Cross Posted Articles.
	//

	//
	//	Copy moderator's name into a buffer - returns number
	//	of bytes copied.
	//	This function will try to grab a lock before copying the
	//	data
	//
	DWORD	CopyModerator(	char*	lpbDestination,	DWORD	cbSize ) ;

	//
	//	Copy prettyname into a buffer - returns number
	//	of bytes copied.
	//	This function will try to grab a lock before copying the
	//	data
	//
	DWORD	CopyPrettyname(	char*	lpbDestination,	DWORD	cbSize ) ;

	//
	//	This function copies the prettyname without the terminating CRLF appended !
	//
	DWORD	CopyPrettynameForRPC(	char*	lpstrPrettyname, DWORD	cbPrettyname ) ;

	//
    // Command interface - used to implement NNTP commands
    //

	//
	//	This function copies whatever help text we have for a group
	//	into a buffer
	//
	DWORD	CopyHelpText(	char*	lpbDestination,	DWORD	cbSize ) ;

	//
	//	This function copies the help text without the terminating CRLF appended !
	//
	DWORD	CopyHelpTextForRPC(	char*	lpbDestintation,	DWORD	cbSize ) ;

	//
	//	Determine whether this newsgroup is Read Only
	//
	inline	BOOL	IsReadOnly();

	//
	//	Determine whether visibility is restricted on this newsgroup
	//
	inline	BOOL	IsVisibilityRestricted() ;

	//
	//	Determine whether this newsgroup requires SSL
	//
	inline	BOOL	IsSecureGroupOnly() ;

	BOOL	IsGroupVisible(
					class CSecurityCtx&	ClientLogon,
					class CEncryptCtx&  ClientSslLogon,
					BOOL			IsClientSecure,
					BOOL			fPost,
					BOOL			fDoTest = FALSE
					) ;

	//
	//	Check whether a newsgroup is accessible
	//
	BOOL	IsGroupAccessible(	
						class	CSecurityCtx&	ClientLogon,	
						class	CEncryptCtx&	SslContext,	
						BOOL			IsClientSecure,
						BOOL			fPost,
						BOOL			fDoTest = FALSE
						) ;

	//
	//	If TRUE, nntpbld will rebuild this group by scanning articles on disk !
	//
	BOOL		m_fRebuild;

	//
	//	This function returns the character that should be displayed
	//	next to the newsgroup in response to a list active command !
	//
	inline	char	GetListCharacter() ;

	//
	//	Number of articles in newsgroup
	//
    inline  DWORD GetArticleEstimate() ;

	//
	//	Smallest ARTICLEID in group
	//
    inline  ARTICLEID GetFirstArticle() ;

	//
	//	Largest ARTICLEID in group
	//
    inline  ARTICLEID GetLastArticle() ;

	//
	//
	//
	inline	DWORD	FillNativeName(char*	szBuff, DWORD	cbSize)	{
		LPSTR	lpstr = GetNativeName() ;
		DWORD	cb = strlen( lpstr ) ;
		if( cbSize >= cb ) {
			CopyMemory( szBuff, GetNativeName(), cb ) ;
			return	cb ;
		}
		return	0 ;
	}

	//
	//	Get owning newstree object
	//
	//inline  CNewsTree* GetTree();

	//
	//	Set GROUPID for newsgroup
	//
    inline  void         SetGroupId( GROUPID groupid ) {
		_ASSERT(FALSE);
	}
	
	//
	//	Reference to newsgroup name
	//	
    inline  LPSTR&       GetGroupName() {
		return GetName();
	}

    inline  LPCSTR       GetNativeGroupName() {
		return GetNativeName();
	}

	//
	//	Time newsgroup was created
	//
	FILETIME	GetGroupTime() ;
	void		SetGroupTime(FILETIME ft);

	//
	//	Expire time horizon for this group
	//
    FILETIME	    GetGroupExpireTime() { return m_ftExpireHorizon; }
    inline VOID     SetGroupExpireTime(FILETIME ft) { m_ftExpireHorizon = ft; }

	//
	//	Compute the hash value of a newsgroup name
	//
    static	DWORD   ComputeNameHash( LPSTR  lpstr ) {
		return CNewsGroupCore::ComputeNameHash(lpstr);
	}

	//
	//	Compute the hash value of a newsgroup id
	//
    static	DWORD   ComputeIdHash( GROUPID  group ) {
		return CNewsGroupCore::ComputeIdHash(group);
	}

	//
	//	During Boot recovery this function will scan the newsgroups
	//	directory and re-enter all of the article files into hash tables etc...
	//
	BOOL	ProcessGroup(	class	CBootOptions*	pOptions,
							BOOL	fParseFile
							) ;

	BOOL	ProcessGroupEx(	class	CBootOptions*	pOptions ) ;


    BOOL    ParseXoverEntry( CBootOptions*       pOptions,
                             IN PCHAR            pbXover,
                             IN DWORD            cbXover,
                             IN OUT GROUPID&     groupid,
                             IN OUT ARTICLEID&   LowestFound,
                             IN OUT ARTICLEID&   HighestFound,
                             IN OUT int&         cArticle,
                             IN OUT BOOL&        fCheckNative );
} ;



typedef CRefPtr2< CNewsGroup >               CGRPPTR ;
typedef CRefPtr2HasRef< CNewsGroup >               CGRPPTRHASREF ;

//
//	Function for matching Newsgroups - all Negations must precede all other pattern matching strings !
//
extern		BOOL	MatchGroup( LPMULTISZ	multiszPatterns,	CGRPCOREPTR	pGroup ) ;	
extern		BOOL	MatchGroupList(	LPMULTISZ	multiszPatterns,	LPMULTISZ	multiSzNewgroups ) ;




//-----------------------------------------------------------
//
// This class is used to find CNewsGroup objects.   There should only
// ever exist one object of this class.
//
// Group's can be found through two means :
//   1) Use the name of the group as it appears in an article
//	 2) Using a Group ID number
//
// Group ID Numbers are used in Article Links.  A link from one article to another
// will contain a Group ID Number and Article Number to represent the link.
//
// We will maintain a Hash Table to find CNewsGroup objects based on newsgroup name.
// We will also maintain a Hash Table to find CNewsGroup objects based on Group ID.
//
// Finally, we will maintain a doubly linked list of CNewsGroups which is sorted by
//	name.  This linked list will be used to support pattern matching iterators.
//
class	CNewsTree: public CNewsTreeCore	{
private :

	friend	class	CGroupIterator ;
	friend	class CNewsGroup;
	friend	NNTP_IIS_SERVICE::InitiateServerThreads();
	friend  NNTP_IIS_SERVICE::TerminateServerThreads();

	friend  VOID DbgPrintNewstree(CNewsTree* ptree, DWORD nGroups);

	//
	//	Pointer to owning virtual server
	//
	PNNTP_SERVER_INSTANCE	m_pInstance ;

	//
	//	Handle to thread which crawls through newsgroups
	//
	static HANDLE	m_hCrawlerThread ;

	//
	//	Handle to event used to terminate crawler thread
	//
	static HANDLE	m_hTermEvent ;

	//
	//	Crawler thread - top level function of thread
	//
	static	DWORD	__stdcall	NewsTreeCrawler( void* ) ;

    BOOL    Init( PNNTP_SERVER_INSTANCE	pInstance, BOOL& fFatal );

protected:
	CNewsGroupCore *AllocateGroup() {
		return XNEW CNewsGroup(this);
	}

public :
	
	//-----------------------------
	// Initialization Interface - functions for getting the CNewsTree into memory,
	//  and load all our configuration information at server startup.
	//

    CNewsTree( INntpServer *pServerObject) ;
	CNewsTree( CNewsTree& ) ;
	~CNewsTree() ;
	
    inline	CNewsTree*	GetTree() { return this; }

	//
	//	Create the initial news tree the server will work with.
	//
	static	BOOL  InitCNewsTree( PNNTP_SERVER_INSTANCE pInstance,
								 BOOL& fFatal);

	//
	//	Expire articles in this tree's virtual server instance
	//
	static	BOOL		ExpireInstance(
								PNNTP_SERVER_INSTANCE	pInstance
								) ;

    //
    //  Begin/End an expire job on this tree
    //
    void    BeginExpire( BOOL& fDoFileScan );
    void    EndExpire();
    void    CheckExpire( BOOL& fDoFileScan );

	//
	//	Update the vroot info of all newsgroups in the tree
	//
	void	UpdateVrootInfo() ;

	//
	//	Stop all background processing - kill any threads we started etc...
	//
    BOOL        StopTree();

	//
	//	Get owning virtual server instance
	//
	inline PNNTP_SERVER_INSTANCE GetVirtualServer() { return m_pInstance; }

	//
	//	Copy the file containing newsgroups to a backup
	//
	void	RenameGroupFile( ) ;


	//
	//	Number of Locks we are using to protect access to
	//	our m_lpstrPath and fields
	//
	DWORD		m_NumberOfLocks ;


	//
	//	Variable to indicate that we wish background threads to STOP
	//
    volatile BOOL        m_bStoppingTree; // TRUE when the crawler thread should abbreviate it's work.

    //
    //  Count of number of expire by time cycles on this tree
    //
    DWORD                m_cNumExpireByTimes;

    //
    //  number of times we expired by find first/next
    //
    DWORD                m_cNumFFExpires;

	//
	//	Indicate to background threads that the newstree has changed and needs to be saved.
	//
	void	Dirty() ;	// mark the tree as needing to be saved !!



	
	//
	//	Check that the group.lst file is intact - this verifies the checksum.
	//	This code is used by the chkhash/boot recovery code.
	//
	BOOL	VerifyGroupFile() ;

	//
	//	Delete the group.lst file, whatever its actual name may be.
	//	We do this when we want to rebuild all the server data structures from scratch.
	//
	BOOL	DeleteGroupFile() ;
	
		


	//---------------------------------
	// Group Location Interface - find a news Group for an article
	//

	// Find an article based on a string and its length
	CGRPPTRHASREF GetGroup(const char *szGroupName, int cch ) {
		CGRPCOREPTR p = CNewsTreeCore::GetGroup(szGroupName, cch);
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
	CGRPPTRHASREF GetGroupPreserveBuffer(const char	*szGroupName, int cch ) {
		CGRPCOREPTR p = CNewsTreeCore::GetGroupPreserveBuffer(szGroupName, cch);
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
	
	// Find a newsgroup given an CArticleRef
	CGRPPTRHASREF GetGroup( CArticleRef& art) {
		CGRPCOREPTR p = CNewsTreeCore::GetGroup(art);
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
	
	// Find a newsgroup based on its GROUPID
	CGRPPTRHASREF GetGroupById( GROUPID id, BOOL fFirm = FALSE  ) {
		CGRPCOREPTR p = CNewsTreeCore::GetGroupById(id, fFirm );
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
	
	GROUPID	GetSlaveGroupid() ;

	// Find the parent of a newsgroup
	CGRPPTRHASREF GetParent( IN  char* lpGroupName,
					   IN  DWORD cbGroup,
					   OUT DWORD& cbConsumed
					   )
	{
		CGRPCOREPTR p = CNewsTreeCore::GetParent(lpGroupName,
											     cbGroup,
												 cbConsumed);
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}
    //
    // The following function takes a list of strings which are
	// terminated by a double NULL and builds an iterator object
	// which can be used examine all the group objects.
    //
    CGroupIterator  *GetIterator(	LPMULTISZ	lpstrPattern,	
									BOOL		fIncludeSecureGroups = FALSE,
									BOOL		fIncludeSpecialGroups = FALSE,
									class CSecurityCtx* pClientLogon = NULL,
									BOOL		IsClientSecure = FALSE,
									class CEncryptCtx* pClientSslLogon = NULL
									) ;

	//----------------------------------
	//	Active NewsGroup Interface - Specify an interface for generating a
	//  list of active newsgroups and estimates of their contents.
	//
    CGroupIterator	*ActiveGroups( 	BOOL		fIncludeSecureGroups = FALSE,
									class CSecurityCtx* pClientLogon = NULL,
									BOOL		IsClientSecure = FALSE,
									class CEncryptCtx* pClientSslLogon = NULL,
                                    BOOL        fReverse = FALSE
									) ;	

	//----------------------------------
    // Group Control interface - These functions can be used to remove
    // and add newsgroups.

    //
    // RemoveGroup is called once we've parsed an article that kills
    // a newsgroup or the Admin GUI decides to destroy an article.
    //
    BOOL RemoveGroup( CGRPPTR    pGroup ) ;



	//
	//	Build all of the newsgroups from a list active file on disk somewhere !
	//
	BOOL	BuildTree( LPSTR	szFile ) ;
	BOOL	BuildTreeEx( LPSTR	szFile ) ;
    BOOL    HashGroupId( CNewsGroup *pGroup ) ;

	//
	//	Check whether a GROUPID is in the 'special' range
	//

	inline	BOOL	IsSpecial( GROUPID	groupid ) ;


	//
	//	For use by CNewsGroup objects only !!
	//
	//	LockHelpText - lock the text in the description object
	//	so that we don't it doesn't change while we try to read it !
	//
	inline	void	LockHelpText() ;
	//	
	//	reverse of LockHelpText()
	//
	inline	void	UnlockHelpText() ;
	//
	//	Lock moderator object in shared mode to access contents
	//
	inline	void	LockModeratorText() ;
	//
	//	unlock CModerator object
	//
	inline	void	UnlockModeratorText() ;
	//
	//	Lock prettynames object in shared mode to access contents
	//
	inline	void	LockPrettynamesText() ;
	//
	//	unlock CPrettyname object
	//
	inline	void	UnlockPrettynamesText() ;

	//
	//	The following functions will add and delete moderator and description
	//	entries.
	//	These are for use by the Admin RPC's which set this information !
	//



    void    Remove( CNewsGroup *pGroup ) ;
    void    RemoveEx( CNewsGroup *pGroup ) ;
} ;

//	wildmat strings have the following pattern matching elements :
//		Range of characters ie:  com[p-z]
//		Asterisk ie:	comp.*   (matches all newsgroups descended from 'comp')
//		Negations ie:	!comp.*  (excludes all newsgroups descended from 'comp' )
//
//	The CGroupIterator will implement these semantics in the following way :
//
//		All newsgroups are held in the CNewsTree object in a doubly linked list in alphabetical order.
//		The CGroupIterator will hold onto a CRefPtr2<> for the current newsgroup.
//		Because the CNewsGroup objects are reference counted, the current newsgroup can never be destroyed from
//		underneath the iterator.
//
//		When the user calls the Iterator's Next() or Prev() functions, we will simply follow next pointers
//		untill we find another newsgroup which matches the pattern and to which the user has access.
//
//		In order to determine whether the any given newsgroup matches the specified pattern, we will use the
//		wildmat() function that is part of the INN source.  We will have to call the wildmat() function for each
//		pattern string until we get a succesfull match.
//

class	CGroupIterator : public CGroupIteratorCore {
private:

	// visibility check
	CSecurityCtx*	m_pClientLogon ;
	CEncryptCtx*	m_pClientSslLogon ;
	BOOL			m_IsClientSecure ;
	BOOL			m_fIncludeSecureGroups;

	//
	//	Only the CNewsTree Class can create CGroupIterator objects.
	//
	friend	class	CNewsTree ;
	//
	//	Constructor
	//	
	//	The CGroupIterator constructor does no memory allocation - all of the arguments
	//	passed are allocated by the caller.  CGroupIterator will destroy the arguments within
	//	its destructor.
	//
	CGroupIterator(	
				CNewsTree*  pTree,
				LPMULTISZ	lpPatterns,
				CGRPCOREPTR &pFirst,
				BOOL		fIncludeSecureGroups,
				BOOL		fIncludeSpecial,
				class CSecurityCtx* pClientLogon = NULL,	// NON-NULL for visibility check
				BOOL		IsClientSecure = FALSE,
				class CEncryptCtx*  pClientSslLogon = NULL
				);

	CGroupIterator(
				CNewsTree*  	pTree,
				CGRPCOREPTR		&pFirst,
				BOOL			fIncludeSecureGroups,
				class CSecurityCtx* pClientLogon = NULL,	// NON-NULL for visibility check
				BOOL	IsClientSecure = FALSE,
				class CEncryptCtx*  pClientSslLogon = NULL
				);

public :
	CGRPPTRHASREF Current() {
		CGRPCOREPTR p = CGroupIteratorCore::Current();
		return (CNewsGroup *) ((CNewsGroupCore *) p);
	}

	virtual void	__stdcall Next() ;
	virtual void	__stdcall Prev() ;

    // Check if two iterators meet each other
	BOOL    Meet( CGroupIterator *iter )  {
	    return m_pCurrentGroup == iter->m_pCurrentGroup;
	}
} ;

#include    "newsgrp.inl"


#endif	// _NEWSGRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\newsgrp.inl ===
DWORD
CNewsGroup::GetArticleEstimate( ) {
	return GetMessageCount();
}

ARTICLEID
CNewsGroup::GetFirstArticle() {
	return GetLowWatermark();
}

ARTICLEID
CNewsGroup::GetLastArticle() {
	return GetHighWatermark();
}

inline	DWORD	
CNewsGroup::ByteSwapper( 
		DWORD	dw 
		) {
/*++

Routine Description : 

	Given a DWORD reorder all the bytes within the DWORD.

Arguments : 

	dw - DWORD to shuffle

Return Value ; 

	Shuffled DWORD

--*/

	WORD	w = LOWORD( dw ) ;
	BYTE	lwlb = LOBYTE( w ) ;
	BYTE	lwhb = HIBYTE( w ) ;

	w = HIWORD( dw ) ;
	BYTE	hwlb = LOBYTE( w ) ;
	BYTE	hwhb = HIBYTE( w ) ;

	return	MAKELONG( MAKEWORD( hwhb, hwlb ), MAKEWORD( lwhb, lwlb )  ) ;
}

inline	ARTICLEID
CNewsGroup::ArticleIdMapper( 
		ARTICLEID	dw
		)	{
/*++

Routine Description : 

	Given an articleid mess with the id to get something that when
	converted to a string will build nice even B-trees on NTFS file systems.
	At the same time, the function must be easily reversible.
	In fact - 

	ARTICLEID == ArticleMapper( ArticleMapper( ARTICLEID ) ) 

Arguments : 

	articleId - the Article Id to mess with

Return Value : 

	A new article id 

--*/
	return	ByteSwapper( dw ) ;
}





inline	char
CNewsGroup::GetListCharacter()	{
/*++

Routine Description : 

	This function returns the character that should be 
	displayed next to the newsgroup in the list active command.
	For moderated groups this is 'm'
	For read/only groups this is 'n'

Arguments : 

	None.

Return Value : 

	A character to display.

--*/

	char	ch = 'y' ;


	if( IsModerated() ) {
		ch = 'm' ;
	}
	if( ch == 'y' ) {
		if( IsReadOnly() ) {
			ch =  'n' ;
		}
	}
	return	ch ;
}




inline	BOOL
CNewsGroup::IsReadOnlyInternal(	)	{
/*++

Routine Description : 

	Determine whether a newsgroup is read only, 
	basically we do this by checking if the WRITE flag is missing.

	***** ASSUMES LOCKS ARE HELD **********


Arguments : 

	None.

Return Value : 

	TRUE if the group is read only - this can be set on a per newsgroup basis.
	(by default a newsgroup is NOT read-only. It becomes read-only if either
	its virtual root is made read-only OR the newsgroup is made read-only via an RPC)

	FALSE otherwise.

--*/

	return	( CNewsGroupCore::IsReadOnly() || !(GetAccessMask() & VROOT_MASK_WRITE) );
}

inline	BOOL
CNewsGroup::IsSecureGroupOnlyInternal()	{
/*++

Routine Description : 

	Determine whether the newsgroup is accessible only 
	through SSL encrypted sessions.
	Basically we check if the VROOT_MASK_SSL bit is present.


	***** ASSUMES LOCKS ARE HELD **********

Arguments : 

	None.
	
Return Value

	TRUE if the group should only be accessed through SSL.

--*/

	return 	(GetSSLAccessMask() & MD_ACCESS_SSL ) ||
			(GetSSLAccessMask() & MD_ACCESS_SSL128 );
}

inline	BOOL
CNewsGroup::IsSecureEnough( DWORD dwKeySize )	{
/*++

Routine Description : 

	Determine whether the key size of the SSL session is secure enough
	based on virtual root settings for this group.


	***** ASSUMES LOCKS ARE HELD **********

Arguments : 

	DWORD	dwKeySize

Return Value

	TRUE if the right key size is being used

--*/

	if( GetSSLAccessMask() & MD_ACCESS_SSL128 ) {
		return ( 128 == dwKeySize );
	}

	return TRUE;
}

inline	BOOL
CNewsGroup::IsVisibilityRestrictedInternal()	{
/*++

Routine Description : 

	Determine whether a newsgroup is to be checked for visibility, 
	basically we do this by checking if the EXECUTE flag is set.
	NOTE: this is a hack - we are over-riding the EXECUTE bit !!

	***** ASSUMES LOCKS ARE HELD **********


Arguments : 

	None.

Return Value : 

	TRUE if the EXECUTE bit is set, FALSE otherwise

--*/

	return	(GetAccessMask() & VROOT_MASK_EXECUTE) ;
}

inline	BOOL
CNewsGroup::IsReadOnly(	)	{
/*++

Routine Description : 

	Determine whether a newsgroup is read only, 
	basically we do this by checking if the WRITE flag is missing.

Arguments : 

	None.

Return Value : 

	TRUE if the group is read only,.
	FALSE otherwise.

--*/


	BOOL	fReturn = IsReadOnlyInternal() ;


	return	fReturn ;
}

inline	BOOL
CNewsGroup::IsSecureGroupOnly()	{
/*++

Routine Description : 

	Determine whether the newsgroup is accessible only 
	through SSL encrypted sessions.
	Basically we check if the VROOT_MASK_SSL bit is present.

Arguments : 

	None.

Return Value

	TRUE if the group should only be accessed through SSL.

--*/


	BOOL	fReturn  = IsSecureGroupOnlyInternal() ;


	return	fReturn ;
}

inline	BOOL
CNewsGroup::IsVisibilityRestricted()	{
/*++

Routine Description : 

	Determine whether visibility is restricted on this newsgroup. If visibility is restricted
	on a newsgroup, it will not appear in LIST and other wildmat iterators if the client does
	not have read access.

	Basically we check if the VROOT_MASK_EXECUTE bit is present.

Arguments : 

	None.

Return Value

	TRUE if visibility is restricted on this newsgroup

--*/


	BOOL	fReturn  = IsVisibilityRestrictedInternal() ;


	return	fReturn ;
}



inline	BOOL
CNewsGroup::ExpireXoverData()	{
/*++

Routine Description : 

	Expire xover index files

Arguments : 

	None.

Retun Value : 

	TRUE if successfull, FALSE if an error occurred !


--*/

	CGrabShareLock	lock( this ) ;

	ARTICLEID	artNewLow ;

	BOOL	fSuccess = TRUE ;
	if( m_iLowWatermark != 0 ) {

		char	szCachePath[MAX_PATH*2] ;
		BOOL	fFlatDir ;
		if( ComputeXoverCacheDir( szCachePath, fFlatDir, TRUE ) )	{
	
			fSuccess = 
				XOVER_CACHE(((CNewsTree*)m_pNewsTree))->ExpireRange(	
											m_dwGroupId, 
											szCachePath,
											fFlatDir,
											m_artXoverExpireLow,
											m_iLowWatermark - 1,
											artNewLow 
											) ;
			if( fSuccess ) 
				m_artXoverExpireLow = artNewLow ;
		}
	}
	return	fSuccess ;
}

inline	BOOL
CNewsGroup::DeleteXoverData(
					ARTICLEID	artid	
					)	{
/*++

Routine Description : 

	An article has been cancelled - get rid of its xover information.

Arguments ; 

	artid - The cancelled article

Return Value : 

	TRUE if successfull, FALSE otherwise.

--*/

	BOOL	fSuccess = FALSE ;

	char	szCachePath[MAX_PATH*2] ;
	BOOL	fFlatDir ;
	if( ComputeXoverCacheDir( szCachePath, fFlatDir ) )	{
		fSuccess = 
			XOVER_CACHE(((CNewsTree*)m_pNewsTree))->RemoveEntry(	
									m_dwGroupId,
									szCachePath,
									fFlatDir,
									artid 
									) ;
	}

	return	fSuccess ;
}
inline	BOOL
CNewsGroup::FlushGroup()	{
/*++

Routine Description : 

	Flush all xover cache entries for this group

Arguments : 

	None.

Retun Value : 

	TRUE if successfull, FALSE if an error occurred !


--*/

	BOOL	fSuccess = TRUE ;

	fSuccess = XOVER_CACHE(((CNewsTree*)m_pNewsTree))->FlushGroup( m_dwGroupId ) ;
	return	fSuccess ;
}



inline
CGroupIterator::CGroupIterator(	
	CNewsTree*  pTree,
	LPMULTISZ	lpPatterns, 
	CGRPCOREPTR &pFirst,
	BOOL		fIncludeSecureGroups,
	BOOL		fIncludeSpecial,
	class CSecurityCtx* pClientLogon,	// NON-NULL for visibility check
	BOOL		IsClientSecure,
	class CEncryptCtx*  pClientSslLogon
	) : 
		CGroupIteratorCore(pTree, lpPatterns, pFirst, fIncludeSpecial),
		m_pClientLogon(pClientLogon),
		m_IsClientSecure(IsClientSecure),
		m_pClientSslLogon(pClientSslLogon),
		m_fIncludeSecureGroups(fIncludeSecureGroups)
	{

	// OK, now that we're here, we're pointing to the first non-deleted,
	// non-special(unless requested) group that matches the pattern.

	BOOL fSawInvisible = FALSE;

	CGRPPTR pGroup = Current();

	if (pGroup == NULL)
	    return;

	if (m_pClientLogon && m_pClientSslLogon) {

		fSawInvisible = !pGroup->IsGroupVisible(
			*m_pClientLogon,
			*m_pClientSslLogon,
			m_IsClientSecure,
			FALSE, TRUE);
	}

	if (fSawInvisible || (!m_fIncludeSecureGroups && pGroup->IsSecureGroupOnly()))
		Next();

}

inline
CGroupIterator::CGroupIterator( 
	CNewsTree*  	pTree,
	CGRPCOREPTR		&pFirst,
	BOOL			fIncludeSecureGroups,
	class CSecurityCtx* pClientLogon,	// NON-NULL for visibility check
	BOOL	IsClientSecure,
	class CEncryptCtx*  pClientSslLogon
	) :
		CGroupIteratorCore(pTree, pFirst),
		m_pClientLogon(pClientLogon),
		m_IsClientSecure(IsClientSecure),
		m_pClientSslLogon(pClientSslLogon),
		m_fIncludeSecureGroups(fIncludeSecureGroups)
	{

	// OK, now that we're here, we're pointing to the first non-deleted,
	// non-special(unless requested) group that matches the pattern.

	BOOL fSawInvisible = FALSE;

	CGRPPTR pGroup = Current();

	if (pGroup == NULL)
	    return;

	if (m_pClientLogon && m_pClientSslLogon) {

		fSawInvisible = !pGroup->IsGroupVisible(
			*m_pClientLogon,
			*m_pClientSslLogon,
			m_IsClientSecure,
			FALSE, TRUE);
	}

	if (fSawInvisible || (!m_fIncludeSecureGroups && pGroup->IsSecureGroupOnly()))
		Next();

}


inline void __stdcall
CGroupIterator::Next() {

	CGroupIteratorCore::Next();

	while (!IsEnd()) {

		CGRPPTR pGroup = Current();

       	if (pGroup == NULL)
	        return;

		if (!m_fIncludeSecureGroups && pGroup->IsSecureGroupOnly()) {
			CGroupIteratorCore::Next();
			continue;
		}

		if (m_pClientLogon && m_pClientSslLogon &&
			!pGroup->IsGroupVisible(
				*m_pClientLogon,
				*m_pClientSslLogon,
				m_IsClientSecure,
				FALSE, TRUE)) {
			CGroupIteratorCore::Next();
			continue;
		}

		// Made it here, so the group is OK

		break;

	}


}

inline void __stdcall
CGroupIterator::Prev() {

	CGroupIteratorCore::Prev();

	while (!IsBegin()) {

		CGRPPTR pGroup = Current();

	    if (pGroup == NULL)
	        return;

		if (!m_fIncludeSecureGroups && pGroup->IsSecureGroupOnly()) {
			CGroupIteratorCore::Prev();
			continue;
		}

		if (m_pClientLogon && m_pClientSslLogon &&
			!pGroup->IsGroupVisible(
				*m_pClientLogon,
				*m_pClientSslLogon,
				m_IsClientSecure,
				FALSE, TRUE)) {
			CGroupIteratorCore::Prev();
			continue;
		}

		// Made it here, so the group is OK

		break;

	}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\newwild.cpp ===
#include	"tigris.hxx"
#include "wildmat.h"

//---[ Description of the Wildmat standard ]-----------------------------------
//
//  Taken from:
//
//  INTERNET-DRAFT                                               S. Barber
//  Expires: September 1, 1996                  Academ Consulting Services
//                                                              April 1996
//                           Common NNTP Extensions
//                        draft-barber-nntp-imp-03.txt
//  
//      The WILDMAT format was first developed by Rich Salz to provide
//      a uniform mechanism for matching patterns in the same manner
//      that the UNIX shell matches filenames. There are five pattern
//      matching operations other than a strict one-to-one match
//      between the pattern and the source to be checked for a match.
//      The first is an asterisk (*) to match any sequence of zero or
//      more characters. The second is a question mark (?) to match any
//      single character. The third specifies a specific set of
//      characters. The set is specified as a list of characters, or as
//      a range of characters where the beginning and end of the range
//      are separated by a minus (or dash) character, or as any
//      combination of lists and ranges. The dash can also be included
//      in the range as a character it if is the beginning or end of
//      the range. This set is enclosed in square brackets. The close
//      square bracket (]) may be used in a range if it is the first
//      character in the set. The fourth operation is the same as the
//      logical not of the third operation and is specified the same
//      way as the third with the addition of a caret character (^) at
//      the beginning of the test string just inside the open square
//      bracket. The final operation uses the backslash character to
//      invalidate the special meaning of the a open square bracket ([),
//      the asterisk, or the question mark.
//  
//  3.3.1 Examples
//  
//      a. [^]-] -- matches any character other than a close square bracket
//                  or a minus sign/dash.
//  
//      b. *bdc  -- matches any string that ends with the string "bdc"
//                  including the string "bdc" (without quotes).
//  
//      c. [0-9a-zA-Z] -- matches any string containing any alphanumeric string
//                  in English.
//  
//      d. a??d  --  matches any four character string which begins
//                   with a and ends with d.
//  
//-----------------------------------------------------------------------------



//----[ NOTES ]----------------------------------------------------------------
//                                                                            
// 		This function will raise an invalid access exception if either pszText                                                     
// 		or pszPattern is invalid or not null terminated while dereferencing the                                                    
// 		string. If this is possible, surround the call in a try-except block.                                                      
//  
//-----------------------------------------------------------------------------



//---[ Defines ]---------------------------------------------------------------

#define STACK_SIZE      256



//---[ HrMatchWildmat ]--------------------------------------------------------
//
//  Description:
//
//      Provides support for the "Wildmat" wild-card matching standard. See
//      description above.
//
//  Params:
//
//      pszText         String to test
//      pszPattern      Pattern to test against
//
//  Returns:
//      
//      ERROR_SUCCESS               If function succeeded, and match was found
//      ERROR_INVALID_PARAMETER     Text or pattern string is invalid
//      
//      ERROR_CAN_NOT_COMPLETE      Some other error occurred.
//
//  
//-----------------------------------------------------------------------------


HRESULT HrMatchWildmat(const char* pszText, const char* pszPattern)
{


	_ASSERT(pszText != NULL && pszPattern != NULL);



	BOOL fCharSet = FALSE;	// TRUE if currently parsing a character set in a pattern
	BOOL fNegated = FALSE;	// TRUE if there is a '^' at the beginning of the set
	BOOL fInSet   = FALSE;  // indicates when matching of a character set has completed
				// used to short-circuit character set evaluation
	int iStackPtr = 0;	// stack pointer
    
	const char* textStack[STACK_SIZE];	// stack of text pointers
	const char* patternStack[STACK_SIZE];	// stack of pattern pointers


	// If the pattern consists solely of a * then any text will match
	if (strcmp(pszPattern, "*") == 0)
		return ERROR_SUCCESS;


	while (TRUE) 
    {
		switch (*pszPattern) 
        {
		    case '*':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
                    

				// If there is a * at the end of the pattern then at this point we are
				// sure that we got a match
				if (pszPattern[1] == '\0')
					return ERROR_SUCCESS;


				// We could write a simpler recursive wildmat function. Here we would
				// recursively call wildmat. Instead, for performance reasons this
				// solution is iterative.
				// Here we save the current values of the text pointer and stack pointer
				// on a stack and we leave the * in the pattern, with the effect of
				// matching one character with the *. The next time through the while
				// loop, the * will still be in the pattern, thus we will try to match
				// the rest of the input with this *. If it turns to fail, we go back
				// one character.
				// See the comments right before the BACK label below.
		    	if (*pszText != '\0') 
                {
		    		if (iStackPtr == STACK_SIZE) 
                        return ERROR_CAN_NOT_COMPLETE;			// stack overflow
                        
		    		textStack[iStackPtr] = pszText;			// save current text pointer
		    		patternStack[iStackPtr] = pszPattern;	// save current pattern pointer
		    		iStackPtr++;
		    		pszPattern--;	// leave * in the input pattern and match one character
		    	}
		    	break;

		    case '?':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
		    	if (*pszText == '\0') 
                    goto BACK;
		    	break;

		    case '[':
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
                    
		    	fCharSet = TRUE;		    // beginning a character set
		    	fNegated = FALSE;			// so far we haven't seen a '^'
		    	fInSet = FALSE;				// used to short-circuit the evaluation of
		    						// membership to the character set

		    	// treat '^', '-' and ']' as special cases if they are
		    	// at the beginning of the character set (also "[^-a]" and "[^]a]")
		    	if (pszPattern[1] == '^') 
                {
		    		fNegated = TRUE;
		    		pszPattern++;
		    	}
		    	// '-' and ']' are literals if they appear at the beggining of the set
		    	if (pszPattern[1] == '-' || pszPattern[1] == ']') 
                {
		    		fInSet = (*pszText == pszPattern[1]);
		    		pszPattern++;
		    	}
		    	break;
		    		
		    case ']':
		    	if (fCharSet) 
                {
		    		if ((!fNegated && !fInSet) || (fNegated && fInSet)) 
                        goto BACK;
                        
		    		fCharSet = FALSE;		// this marks the end of a character set
		    	} 
                else 
                {
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '-':
		    	if (fCharSet) 
                {
		    		unsigned char startRange = pszPattern[-1];	// we use unsigned char
					unsigned char endRange;						// to support extended
					unsigned char ch;							// characters

		    		if (pszPattern[1] == '\0')
		    			return ERROR_INVALID_PARAMETER;
		    		else 
                    {
                        if (pszPattern[1] == ']')		// a dash at the end of the set is
		    			    fInSet = (*pszText == '-');	// treated as a literal
		    		    else 
                        {							    // we have a range
		    		    	if (pszPattern[1] == '\\')  // escape character, skip it
                            {	
		    		    		pszPattern++;
		    		    		if (pszPattern[1] == '\0') 
                                    return ERROR_INVALID_PARAMETER;
		    		    	}
							ch = *pszText;
							endRange = pszPattern[1];

							if (startRange > endRange)
								return ERROR_INVALID_PARAMETER;
							// here is where we could need unsigned characters
		    		    	fInSet = (ch >= startRange && ch <= endRange);
		    		    	pszPattern++;
		    		    	break;
		    		    }
                    }
		    	} 
                else 
                {						// outside a character set '-' has no special meaning
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '\0':					// end of the pattern
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
		    	if (*pszText == '\0')
		    		return ERROR_SUCCESS;
		    	else
		    		goto BACK;
		    	break;

		    default:				
DEFAULT:    	
                if (*pszPattern == '\\') 
                {
		    		pszPattern++;		// escape character, treat the next character as a literal
		    		if (*pszPattern == '\0') 
                        return ERROR_INVALID_PARAMETER;
		    	}
		    	if (!fCharSet) 
                {						// any other character is treated as a literal
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	} 
                else 
                {
		    		// the following if takes care of the two "special" cases:
		    		//		[c-a]       (we don't want to accept c), and
		    		//		[c-]		(we want to accept c)
		    		if (!(pszPattern[1] == '-' && pszPattern[2] != ']'))
		    			fInSet = (*pszText == *pszPattern);
		    	}
		    	break;
		} // switch

		pszPattern++;
		
        if (!fCharSet) 
        {
			if (*pszText != '\0') 
                pszText++;
		} 
        else 
        {               			// code to short-circuit character set evaluation
			if (fInSet) 			// skip the rest of the character set
            {		
				while (*pszPattern != '\0' && *pszPattern != ']') 
                {
					if (*pszPattern == '\\')
                    {				// escape character, treat the next character as a literal
						pszPattern++;
						if (*pszPattern == '\0') 
                            return ERROR_INVALID_PARAMETER;
					}
					pszPattern++;
				}
			}
		}
		continue;	// the continue statement is to jump to the beginning of the loop,
					// we could have used used goto some label but that's what continue's
					// are for.


		// This is only reached by jumping to BACK.
		// This is equivalent to returning from a recursive solution of wildmat.
		// If the stack pointer is zero then the bottommost "recursive call" failed,
		// otherwise we "unwind one stack frame" and resume execution of the previous
		// call at the top of the while loop. Notice that since "recursive calls" are
		// only done when we find a '*' in the pattern outside a character set, the
		// value of fCharSet has to be set to false.
BACK:	
        if (iStackPtr == 0)                     	// we exhausted all possibilities
            return ERROR_FILE_NOT_FOUND;
            
		iStackPtr--;						    	// try matching no characters with the '*'
		pszText = textStack[iStackPtr];
		pszPattern = patternStack[iStackPtr] + 1;	// eat the '*' matching no input characters
		fCharSet = FALSE;				        	// this has to be the case
	} // while

    // should never get here
	_ASSERT(FALSE);						
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\nnprocs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nnprocs.h

Abstract:

    This module contains function prototypes used by the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     12-Sept-1995

Revision History:

    Kangrong Yan ( KangYan )    28-Feb-1998
        Added one prototype for fixed length Unicode-Ascii convertion func.

--*/

#ifndef	_NNPROCS_
#define	_NNPROCS_

#include "nntputil.h"

//
//  uuencode/uudecode
//
//  Taken from NCSA HTTP and wwwlib.
//  (Copied from Gibraltar code -johnsona)
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

class BUFFER;

BOOL
uudecode(
    char   * bufcoded,
    BUFFER * pbuffdecoded,
    DWORD  * pcbDecoded
    );

BOOL
uuencode(
    BYTE *   bufin,
    DWORD    nbytes,
    BUFFER * pbuffEncoded
    );

DWORD
NntpGetTime(
    VOID
    );

BOOL
fMultiSzRemoveDupI(
    char * multiSz,
    DWORD & c,
	CAllocator * pAllocator
    );

void
vStrCopyInc(
    char * szIn,
    char * & szOut
    );

DWORD
multiszLength(
	  char const * multisz
	  );

const char *
multiszCopy(
    char const * multiszTo,
    const char * multiszFrom,
    DWORD dwCount
    );

char *
szDownCase(
		   char * sz,
		   char * szBuf
		   );

VOID
NntpLogEventEx(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode,                // error code if any
	IN DWORD  dwInstanceId			  // virtual server instance id
    );

VOID
NntpLogEvent(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode                 // error code if any
    );

BOOL
IsIPInList(
    IN PDWORD IPList,
    IN DWORD IPAddress
    );

//
// nntpdata.cpp
//

APIERR
InitializeGlobals();

VOID
TerminateGlobals();

//
//  Socket utilities.
//

APIERR InitializeSockets( VOID );

VOID TerminateSockets( VOID );

VOID
NntpOnConnect(
    SOCKET        sNew,
    SOCKADDR_IN * psockaddr,
    PVOID         pEndpointContext,
    PVOID         pAtqEndpointObject
    );

VOID
NntpOnConnectEx(
    VOID * pAtqContext,
    DWORD  cdWritten,
    DWORD  err,
    OVERLAPPED * lpo
    );

VOID
NntpCompletion(
    PVOID        Context,
    DWORD        BytesWritten,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo
    );

VOID
BuzzOff( 
	SOCKET s,
	SOCKADDR_IN* psockaddr,
	DWORD dwInstance );

BOOL
VerifyClientAccess(
			  IN CSessionSocket*	   pSocket,
			  IN SOCKADDR_IN * 		   psockaddr
			  );

//
//  IPC functions.
//

APIERR InitializeIPC( VOID );
VOID TerminateIPC( VOID );

//
// security.cpp
//

BOOL
NntpInitializeSecurity(
            VOID
            );

VOID
NntpTerminateSecurity(
            VOID
            );

//
// feedmgr.cpp
//

PFEED_BLOCK
AllocateFeedBlock(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN LPSTR	KeyName OPTIONAL,
	IN BOOL		fCleanSetup,
    IN LPCSTR	ServerName,
    IN FEED_TYPE FeedType,
    IN BOOL		AutoCreate,
    IN PULARGE_INTEGER StartTime,
    IN PFILETIME NextPull,
    IN DWORD	FeedInterval,
    IN PCHAR	Newsgroups,
    IN DWORD	NewsgroupsSize,
    IN PCHAR	Distribution,
    IN DWORD	DistributionSize,
    IN BOOL		IsUnicode,
	IN BOOL		fEnabled,
	IN LPCSTR	UucpName,
	IN LPCSTR	FeedTempDirectory,
	IN DWORD	MaxConnectAttempts,
	IN DWORD	ConcurrentSessions,
	IN DWORD	SessionSecurityType,
	IN DWORD	AuthenticationSecurityType,
	IN LPSTR	NntpAccount,
	IN LPSTR	NntpPassword,
	IN BOOL		fAllowControlMessages,
	IN DWORD	OutgoingPort,
	IN DWORD	FeedPairId,
	IN DWORD*	ParmErr
    );

BOOL
InitializeFeedManager(
				PNNTP_SERVER_INSTANCE pInstance,
                BOOL&	fFatal
                 );

VOID
TerminateFeedManager(
                PNNTP_SERVER_INSTANCE pInstance
                 );
VOID
DereferenceFeedBlock(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    );

VOID
CloseFeedBlock(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    );

LPSTR
ServerNameFromCompletionContext(	
	LPVOID	lpv 
	) ;

VOID
ConvertTimeToString(
    IN PFILETIME Ft,
    OUT CHAR Date[],
    OUT CHAR Time[]
    );

VOID
CompleteFeedRequest(
			IN PNNTP_SERVER_INSTANCE pInstance,
            IN PVOID Context,
			IN FILETIME	NextPullTime,
            BOOL Success,
			BOOL NoData
            );

BOOL
ValidateFeedType(
    DWORD FeedType
    );

//
// svcstat.c
//


#endif // _NNPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\nntpdata.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpdata.h

Abstract:

    This module contains declarations for globals.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPDATA_
#define _NNTPDATA_
#define _LMACCESS_              // prevents duplicate defn. in lmaccess.h


extern GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName;

//
//	Xover Sort Performance global - used to determine how frequently we
//	sort xover entries !
//
extern	DWORD	gdwSortFactor ;


//
//	Do we put rejected articles into .err files ?
//
extern	BOOL	fGenerateErrFiles ;


//
//	Global config of hash table use of PageEntry's -
//	The more RAM a box has, the more PageEntry's the
//	better the caching of frequently used hash table pages !
//
//	Number of PageEntry objects for the Xover table
//
extern	DWORD	XoverNumPageEntry ;

//
//	Number of PageEntry objects for the Article table
//
extern	DWORD	ArticleNumPageEntry ;

//
//	Number of PageEntry objects for the History table
//
extern	DWORD	HistoryNumPageEntry ;

//
//	Size of hash table page cache in bytes
//
extern	DWORD	dwPageCacheSize ;

//
//	Limit on file handle cache
//
extern	DWORD	dwFileHandleCacheSize ;

//
//	Limit on xix handles per table
//
extern	DWORD	dwXixHandlesPerTable ;

//
//	Do we allow NT to buffer our hash table files ??
//
extern	BOOL	HashTableNoBuffering ;

//
//	Number of Hash Table locks we should use !
//
extern	DWORD	gNumLocks ;

//
//	Global config of buffer sizes
//

//
//	The largest buffer we will use - must be big enough to hold
//	encrypted SSL blobs in contiguous chunks
//
extern	DWORD	cbLargeBufferSize ;

//
//	Medium size buffers - will be used for commands which generate large
//	responses, and when sending files through SSL
//
extern	DWORD	cbMediumBufferSize ;

//
//	Small buffers - used to read client commands and send small responses.
//
extern	DWORD	cbSmallBufferSize ;

//
//	Time limits for the history table
//
extern	DWORD	HistoryExpirationSeconds ;
extern	DWORD	ArticleTimeLimitSeconds ;

//
//	Service version string
//
extern  CHAR	szVersionString[128] ;

//
//	Service title
//
extern  char    szTitle[] ;

//
//	This is the time the newstree crawler thread sleeps between
//	expiration cycles on the newstree.
//
extern	DWORD	dwNewsCrawlerTime ;

//
//	This is an upper bound on the time the server will wait
//	for an instance to start !
//
extern	DWORD	dwStartupLatency ;

//
//	This is an upper bound on the time spent by the server in
//	cleaning up on net stop !
//
extern	DWORD	dwShutdownLatency ;

//
//  Number of threads in expire thread pool
//
extern  DWORD	dwNumExpireThreads ;

//
//  Number of special case expire threads
//
extern  DWORD	gNumSpecialCaseExpireThreads ;

//
//  Special expire article count threshold -
//  special case code executes if art count is greater
//  than this number !
//
extern  DWORD	gSpecialExpireArtCount ;

//
//  Rate at which expire by time does file scans
//
extern  DWORD	gNewsTreeFileScanRate ;

//
//	Switch for type of from header to use in mail messages
//
extern	MAIL_FROM_SWITCH	mfMailFromHeader;

//
//	control how frequently we use LookupVirtualRoot to
//	update newsgroup information !
//
extern	DWORD	gNewsgroupUpdateRate ;

//
//	Bool used to determine whether we will use a message-id a client puts
//	in his post !
//
extern	BOOL	gHonorClientMessageIDs ;

//
//	Bool used to determine whether we will use a Date: a client puts
//	in his post !
//
extern	BOOL	gHonorClientDateHeader ;

//
//	Bool used to determine whether the server enforces Approved: header
//	matching on moderated posts !
//
extern	BOOL	gHonorApprovedHeaders ;

//
//	BOOL used to determine whether we will generate the NNTP-Posting-Host
//	header on client Posts. Default is to not generate this.
//
extern	BOOL	gEnableNntpPostingHost ;

//
//  Shall we backfill the lines header during inbound ?
//
extern BOOL     g_fBackFillLines;

//
// Name of the list file
//

extern CHAR ListFileName[];

//
// Global service ptr
//
extern PNNTP_IIS_SERVICE g_pNntpSvc ;

//
// Name of newsgroup to special case for expire
//
extern char g_szSpecialExpireGroup[];

//
// misc externs
//

extern DWORD GroupFileNameSize;
extern BOOL RejectGenomeGroups;
extern const char szWSChars[];
extern const char szWSNullChars[];
extern const char szNLChars[];
extern const char szWSNLChars[];
extern const char StrNewLine[];
extern const char StrTermLine[];
extern LPSTR StrUnknownUser;

//
// strings
//

extern LPSTR StrParmKey;
extern LPSTR StrFeedKey;
extern LPSTR StrVirtualRootsKey;
extern LPSTR StrExpireKey;
extern LPSTR StrExpireNewsgroups;
extern LPSTR StrExpirePolicy;
extern LPSTR StrTreeRoot;
extern LPSTR StrRejectGenome;
extern LPSTR StrServerName;
extern LPSTR StrFeedType;
extern LPSTR StrFeedInterval;
extern LPSTR StrFeedDistribution;
extern LPSTR StrFeedNewsgroups;
extern LPSTR StrFeedAutoCreate;
extern LPSTR StrPeerTempDir;
extern LPSTR StrPeerGapSize;
extern LPSTR StrFeedTempDir;
extern LPSTR StrFeedUucpName ;
extern LPSTR StrFeedMaxConnectAttempts;
extern LPSTR StrFeedConcurrentSessions ;
extern LPSTR StrFeedSecurityType ;
extern LPSTR StrFeedAuthType;
extern LPSTR StrFeedAuthAccount ;
extern LPSTR StrFeedAuthPassword ;
extern LPSTR StrFeedStartHigh;
extern LPSTR StrFeedStartLow;
extern LPSTR StrFeedIsMaster;
extern LPSTR StrNntpHubName;
extern LPSTR StrFeedNextPullLow;
extern LPSTR StrFeedNextPullHigh;
extern LPSTR StrFeedAllowControl;
extern LPSTR StrFeedOutgoingPort;
extern LPSTR StrFeedPairId;
extern LPSTR StrMasterIPList;
extern LPSTR StrPeerIPList;
extern LPSTR StrListFileName;
extern LPSTR StrQueueFile;
extern LPSTR StrExpireHorizon;
extern LPSTR StrExpireSpace;
extern LPSTR StrCleanBoot ;
extern LPSTR StrSocketRecvSize ;
extern LPSTR StrSocketSendSize ;
extern LPSTR StrBuffer ;
extern LPSTR StrCommandLogMask ;
extern LPSTR StrActiveFile ;
extern LPSTR StrDescriptiveFile ;
extern LPSTR StrGroupList ;
extern LPSTR StrModeratorFile ;
extern LPSTR StrFeedDisabled ;
extern LPSTR StrAFilePath ;
extern LPSTR StrHFilePath ;
extern LPSTR StrXFilePath ;
extern LPSTR StrModeratorPath ;
extern LPSTR StrHistoryExpiration ;
extern LPSTR StrArticleTimeLimit ;
extern LPSTR StrAllowClientPosts ;
extern LPSTR StrAllowFeedPosts ;
extern LPSTR StrServerSoftLimit ;
extern LPSTR StrServerHardLimit ;
extern LPSTR StrFeedSoftLimit ;
extern LPSTR StrFeedHardLimit ;
extern LPSTR StrServerOrg ;
extern LPSTR StrAllowControlMessages;
extern LPWSTR StrSmtpAddressW ;
extern LPWSTR StrUucpNameW ;
extern LPSTR StrUucpNameA ;
extern LPWSTR StrDefaultModeratorW ;
extern LPWSTR StrAuthPackagesW ;
extern LPSTR StrSmallBufferSize ;
extern LPSTR StrMediumBufferSize ;
extern LPSTR StrLargeBufferSize ;
extern LPSTR StrNewsCrawlerTime ;
extern LPSTR StrNewsVrootUpdateRate ;
extern LPSTR StrHonorClientMessageIDs ;
extern LPSTR StrHonorClientDateHeader ;
extern LPSTR StrDisableNewnews ;
extern LPSTR StrEnableNntpPostingHost ;
extern LPSTR StrNumExpireThreads ;
extern LPSTR StrNumSpecialCaseExpireThreads ;
extern LPSTR StrSpecialExpireGroup ;
extern LPSTR StrSpecialExpireArtCount ;
extern LPSTR StrNewsTreeFileScanRate ;
extern LPSTR StrGenerateErrFiles ;
extern LPSTR StrXoverPageEntry ;
extern LPSTR StrArticlePageEntry ;
extern LPSTR StrHistoryPageEntry ;
extern LPSTR StrShutdownLatency ;
extern LPSTR StrStartupLatency ;
extern LPSTR StrHonorApprovedHeader ;
extern LPSTR StrMailFromHeader ;
extern LPSTR StrPageCacheSize ;
extern LPSTR StrFileHandleCacheSize ;
extern LPSTR StrXixHandlesPerTable ;
extern LPSTR StrHashTableNoBuffering ;
extern LPSTR StrPostBackFillLines;

#endif // _NNTPDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\nntpinst.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        nntpinst.cxx

   Abstract:

        This module defines the NNTP_SERVER_INSTANCE class
		and the NNTP_IIS_SERVICE class.

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996

   Revision History:

        Kangrong Yan    ( KangYan )     Feb-28-1998
            Have MD notification function pick up MB events of feed config
            change.  Feed config used to be done thru RPCs.  But now Admin
            is supposed to write config updates directly to metabase and
            this change should be picked up by instance.  The instance is
            also responsible for feeding this update into feed blocks.

        Kangrong Yan    ( KangYan )     Oct-21-1998
            Rebuild code consolidation.

--*/

#include "tigris.hxx"
#include "smtpdll.h"

#include <nsepname.hxx>
#include <malloc.h>

//
//	Auth defaults
//

#define DEFAULT_ALLOW_ANONYMOUS         TRUE
#define DEFAULT_ALLOW_GUEST_ACCESS      TRUE
#define DEFAULT_ANONYMOUS_ONLY          FALSE

#define DEFAULT_READ_ACCESS_MASK        0
#define DEFAULT_WRITE_ACCESS_MASK       0
#define DEFAULT_MSDOS_DIR_OUTPUT        TRUE

#define DEFAULT_LOGON_METHOD            LOGON32_LOGON_NETWORK_CLEARTEXT 
#define DEFAULT_ANONYMOUS_PWD           ""
#define INETA_DEF_LEVELS_TO_SCAN		2

//
//	Globals
//
static  char    szPostsCode[] = "200 " ;
static  char    szPostsAllowed[] = " Posting Allowed \r\n" ;
static  char    szNoPostsCode[] = "201 " ;
static  char    szPostsNotAllowed[] = " Posting Not Allowed \r\n" ;
char    szTitle[] = "Nntpsvc" ;

const LPSTR     pszPackagesDefault = "NTLM\0";
const DWORD     ccbPackagesDefault = sizeof( "NTLM\0" );

PFN_SF_NOTIFY   g_pFlushMapperNotify[MT_LAST] = { NULL, NULL, NULL, NULL };
PFN_SF_NOTIFY   g_pSslKeysNotify = NULL;

static char mszStarNullNull[3] = "*\0";

extern STORE_CHANGE_NOTIFIER *g_pCAPIStoreChangeNotifier;

inline BOOL
ConvertToMultisz(LPSTR szMulti, DWORD *pdwCount, LPSTR szAuthPack)
{
	CHAR *pcStart = szAuthPack, *pc;
	DWORD dw = 0;

	pc = pcStart;
	if (*pc == '\0' || *pc == ',') return FALSE;

	*pdwCount = 0;
	while (TRUE) {
		if (*pc == '\0') {
			strcpy(&szMulti[dw], pcStart);
			(*pdwCount)++;
			dw += lstrlen(pcStart);
			szMulti[dw + 1] = '\0';
			return TRUE;
		}
		else if (*pc == ',') {
			*pc = '\0';
			strcpy(&szMulti[dw], pcStart);
			(*pdwCount)++;
			dw += lstrlen(pcStart);
			dw++;
			*pc = ',';
			pcStart = ++pc;
		}
		else {
			pc++;
		}
	}
}

DWORD
ParseDescriptor(
    IN const CHAR * Descriptor,
    OUT LPDWORD IpAddress,
    OUT PUSHORT IpPort,
    OUT const CHAR ** HostName
    );

DWORD
InitializeInstances(
    PNNTP_IIS_SERVICE pService
    )
/*++

Routine Description:

    Reads the instances from the metabase

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
{
    DWORD   i;
    DWORD   cInstances = 0;
	MB      mb( (IMDCOM*) pService->QueryMDObject() );
    CHAR    szKeyName[MAX_PATH+1];
    DWORD   err = NO_ERROR;
    BUFFER  buff;
    BOOL    fMigrateRoots = FALSE;
    DWORD   dwEvent ;
	BOOL	fAtLeastOne = FALSE ;

	TraceFunctEnter("InitializeInstances");

    //
    //  Open the metabase for write to get an atomic snapshot
    //

ReOpen:

    if ( !mb.Open( "/LM/nntpsvc/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DebugTrace(0, "InitializeInstances: Cannot open path %s error %lu\n",
                    "/LM/NNTPSVC/", GetLastError() );

        //
        //  If the nntp service key isn't here, just create it
        //

        if ( !mb.Open( "",
                       METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ||
             !mb.AddObject( "/LM/NNTPSVC/" ))
        {
            return GetLastError();
        }

        DebugTrace(0, "/LM/NNTPSVC not found auto-created\n");

        mb.Close();
        goto ReOpen;
    }

    //
    // Loop through instance keys and build a list.  We don't keep the
    // metabase open because the instance instantiation code will need
    // to write to the metabase
    //

TryAgain:
    i = 0;
    while ( mb.EnumObjects( "",
                            szKeyName,
                            i++ ))
    {
        //BOOL fRet;
        DWORD dwInstance;
        //CHAR szRegKey[MAX_PATH+1];

        //
        // Get the instance id
        //

        DebugTrace(0,"instance key %s\n",szKeyName);

        dwInstance = atoi( szKeyName );
        if ( dwInstance == 0 ) {
            DebugTrace(0,"invalid instance ID %s\n",szKeyName);
            continue;
        }

        if ( buff.QuerySize() < (cInstances + 1) * sizeof(DWORD) )
        {
            if ( !buff.Resize( (cInstances + 10) * sizeof(DWORD)) )
            {
                return GetLastError();
            }
        }

        ((DWORD *) buff.QueryPtr())[cInstances++] = dwInstance;
    }

    if ( cInstances == 0 )
    {
        DebugTrace(0,"No defined instances\n");

        if ( !mb.AddObject( "1" ) )
        {
            DebugTrace(0,"Unable to create first instance: error %d\n", GetLastError() );
            return GetLastError();
        }

        fMigrateRoots = TRUE; // Force reg->metabase migration of virtual directories
        goto TryAgain;
    }

    _VERIFY( mb.Close() );

	//
	//	At this point we have at least one instance !
	//
    for ( i = 0; i < cInstances; i++ )
    {
        DWORD dwInstance = ((DWORD *)buff.QueryPtr())[i];

        if( !g_pInetSvc->AddInstanceInfo( dwInstance, fMigrateRoots ) ) {

            err = GetLastError();
            DebugTrace(0,"InitializeInstances: cannot create instance %lu error %lu\n",
					dwInstance,err);

#if 0
			// failure to boot an instance is fatal !
            break;
#endif
        } else {
			// at least one instance booted !
			fAtLeastOne = TRUE ;
		}
	}

	// the service will boot if at least one instance booted ok
	if( fAtLeastOne ) {
		err = NO_ERROR ;
	}

	//
	//	Now, that all instances have booted, kick off server wide threads
	//	like feeds and expires. These threads should skip any instances
	//	that are not in the started state. It is important to terminate these
	//	threads FIRST on the shutdown path !
	//
	if( !pService->InitiateServerThreads() ) {
		err = GetLastError();
		ErrorTrace(0,"Failed to InitiateServerThreads: error is %d", err);
		NntpLogEventEx( NNTP_INIT_SERVER_THREADS_FAILED, 0, (const CHAR**)NULL, err, 0 );
	}

	if( NO_ERROR == err )
	{
		//
		//	At this point, we have initialized all globals (including CPools),
		//	booted all server instances and started their ATQ engines.
		//

		// log an event on startup
		dwEvent = NNTP_EVENT_SERVICE_STARTED ;
		err = NO_ERROR ;

		// Log a successful boot event !
		PCHAR args [1];
		args [0] = szVersionString;

		NntpLogEvent(
				dwEvent,
				1,
				(const char**)args,
				0
				) ;
	}

    return err;

} // InitializeInstances

VOID
TerminateInstances(
    PNNTP_IIS_SERVICE pService
    )
/*++

Routine Destion:

    Shutdown each instance and terminate all global cpools

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
{
	TraceFunctEnter("TerminateInstances");

    //
    //  Acquire and release global r/w lock
    //  This lock is acquired shared by all RPC code paths
    //  This enables any RPC threads that have "snuck" past
    //  FindIISInstance() to complete...
    //  NOTE that new RPCs will not get past FindIISInstance()
    //  because the service state is SERVICE_STOP_PENDING.
    //
    ACQUIRE_SERVICE_LOCK_EXCLUSIVE();
    RELEASE_SERVICE_LOCK_EXCLUSIVE();

	//
	//	Signal system threads (eg: rebuild threads) to stop
	//
	if( !pService->TerminateServerThreads() ) {
		//
		//	TODO: handle error
		//
		_ASSERT( FALSE );
	}

	TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:   CheckIISInstance
//
//  Synopsis:   Checks an instance to see if it is running
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------
BOOL
CheckIISInstance(
    PNNTP_SERVER_INSTANCE pInstance
    )
{
	TraceFunctEnter("CheckIISInstance");

	//
	//	If the server instance is not in the started state, return FALSE
	//
	if( !pInstance ||
		(pInstance->QueryServerState() != MD_SERVER_STATE_STARTED) ||
		pInstance->m_BootOptions ||
		(g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING)
		   )
	{
		// instance is not runnable
		return FALSE ;
	}

	TraceFunctLeave();

	// instance is good
	return TRUE ;
}

PNNTP_SERVER_INSTANCE
FindIISInstance(
    PNNTP_IIS_SERVICE pService,
	DWORD	dwInstanceId,
	BOOL	fStarted
    )
/*++

Routine Description:

    Find an instance given the instance id

	!! If an instance is returned we will AddRef it, caller needs
	   to Deref !!

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
{
	PFN_INSTANCE_ENUM pfnInstanceEnum = NULL ;
	PNNTP_SERVER_INSTANCE pInstance = NULL ;

	TraceFunctEnter("FindIISInstance");

	//
	//	Iterate over all instances
	//
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&CheckInstanceId;

	if( !pService->EnumServiceInstances(
									(PVOID)(SIZE_T)dwInstanceId,
									(PVOID)&pInstance,
									pfnInstanceEnum
									) )
	{
		DebugTrace(0,"Finished enumerating instances");
	}

	_ASSERT( !pInstance || (dwInstanceId == pInstance->QueryInstanceId()) );

	//
	//	If the server instance is not in the started state, return NULL !
	//
	if( fStarted && pInstance &&
		((pInstance->QueryServerState() != MD_SERVER_STATE_STARTED) ||
		  pInstance->m_BootOptions ||
		  (pService->QueryCurrentServiceState() != SERVICE_RUNNING)
		  ) )
	{
		pInstance->Dereference();
		pInstance = NULL;
	}

	TraceFunctLeave();

	return pInstance ;
}

//+---------------------------------------------------------------
//
//  Function:   CheckInstanceId
//
//  Synopsis:   Callback from IIS_SERVICE iterator
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------

BOOL
CheckInstanceId(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{
	PNNTP_SERVER_INSTANCE pNntpInstance = (PNNTP_SERVER_INSTANCE)pInstance ;
	DWORD dwInstanceId = (DWORD)((DWORD_PTR)pvContext);
	PNNTP_SERVER_INSTANCE* ppNntpInstance = (PNNTP_SERVER_INSTANCE*)pvContext1 ;

	//
	//	Check this instance for its id - if it matches the id we are looking for
	//	return FALSE to discontinue the iteration.
	//
	if( dwInstanceId == pNntpInstance->QueryInstanceId() )
	{
		// found it
		*ppNntpInstance = pNntpInstance ;
		pInstance->Reference();			// Caller needs to do a Deref !
		return FALSE ;
	}

	// did not find it - continue iteration
	return TRUE;
}

BOOL
FindIISInstanceRange(
    PNNTP_IIS_SERVICE pService,
	LPDWORD		pdwMinInstanceId,
	LPDWORD		pdwMaxInstanceId
    )
/*++

Routine Description:

    Find the min and max instance ids

Arguments:

    pService - Server instances added to.

Return Value:

    If TRUE, *pdwMinInstanceId and *pdwMaxInstanceId contain the
	right min and max values. If FALSE, they are both set to 0.

--*/
{
	PFN_INSTANCE_ENUM pfnInstanceEnum = NULL ;
	BOOL fRet = TRUE ;
	*pdwMinInstanceId = 0;
	*pdwMaxInstanceId = 0;

	TraceFunctEnter("FindIISInstanceRange");

	//
	//	Iterate over all instances
	//
	pfnInstanceEnum = (PFN_INSTANCE_ENUM)&CheckInstanceIdRange;

	if( !pService->EnumServiceInstances(
									(PVOID)pdwMinInstanceId,
									(PVOID)pdwMaxInstanceId,
									pfnInstanceEnum
									) ) {
		_ASSERT( FALSE );	// this should not happen !
	}

	_ASSERT( *pdwMinInstanceId != 0 );
	_ASSERT( *pdwMaxInstanceId != 0 );

	TraceFunctLeave();

	return fRet ;
}

//+---------------------------------------------------------------
//
//  Function:   CheckInstanceIdRange
//
//  Synopsis:   Callback from IIS_SERVICE iterator
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------

BOOL
CheckInstanceIdRange(
		PVOID					pvContext,
		PVOID					pvContext1,
		PIIS_SERVER_INSTANCE	pInstance
		)
{
	LPDWORD	pdwMinInstanceId = (LPDWORD) pvContext  ;
	LPDWORD	pdwMaxInstanceId = (LPDWORD) pvContext1 ;
	DWORD	dwInstanceId	 = pInstance->QueryInstanceId();

	if( *pdwMinInstanceId == 0 )
	{
		//
		//	Initially set min and max to the first id
		//
		_ASSERT( *pdwMaxInstanceId == 0 );
		*pdwMinInstanceId = dwInstanceId ;
		*pdwMaxInstanceId = dwInstanceId ;
	} else {
		//
		//	Check to see if this instance's ID changes our min or max
		//
		if( dwInstanceId < *pdwMinInstanceId ) {
			//	found someone with an id lower than our min so far
			*pdwMinInstanceId = dwInstanceId ;
		}
		if( dwInstanceId > *pdwMaxInstanceId ) {
			//	found someone with an id higher than our max so far
			*pdwMaxInstanceId = dwInstanceId ;
		}
	}

	// continue iteration
	return TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::NNTP_SERVER_INSTANCE
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

NNTP_SERVER_INSTANCE::NNTP_SERVER_INSTANCE(
        IN PNNTP_IIS_SERVICE pService,
        IN DWORD  dwInstanceId,
        IN USHORT Port,
        IN LPCSTR lpszRegParamKey,
        IN LPWSTR lpwszAnonPasswordSecretName,
        IN LPWSTR lpwszVirtualRootsSecretName,
        IN BOOL   fMigrateRoots
        )
:   IIS_SERVER_INSTANCE(pService,
                        dwInstanceId,
                        Port,
                        lpszRegParamKey,
                        lpwszAnonPasswordSecretName,
                        lpwszVirtualRootsSecretName,
                        fMigrateRoots),

    m_signature                 (NNTP_SERVER_INSTANCE_SIGNATURE),
    m_fRecoveryBoot( FALSE ),
	m_ServiceStartCalled( FALSE ),
    m_hRegKey( 0 ),
    m_cbPostsAllowed( 0 ),
    m_cbPostsNotAllowed( 0 ),
	m_NntpDNSNameSize( 0 ),
	m_PeerGapSize( 0 ),
	m_BootOptions( NULL ),
	m_OurNntpRole( RolePeer ),
	m_HubNameSize( 0 ),
	m_pTree( NULL ),
	m_pNntpServerObject(NULL),
	m_pInstanceWrapper(NULL),
	m_pInstanceWrapperEx( NULL ),
	m_FeedManagerRunning( FALSE ),
	m_NumberOfMasters( 0 ),
	m_NumberOfPeersAndSlaves( 0 ),
	m_ConfiguredMasterFeeds( 0 ),
	m_ConfiguredSlaveFeeds( 0 ),
	m_ConfiguredPeerFeeds( 0 ),
	m_InitVar( 0 ),
	m_fAllFilesMustExist( FALSE ),
	m_fUseOriginal( TRUE ),
	m_pDirNot( NULL ),
	m_heNoPickups( NULL ),
	m_dwSslAccessPerms( 0 ),
	m_lpAdminEmail( NULL ),
	m_cbAdminEmail( 0 ),
	m_dwLevelsToScan( INETA_DEF_LEVELS_TO_SCAN ),
	m_cbCleartextAuthPackage(0),
	m_ProviderPackages( NULL ),
	m_cProviderPackages( 0 ),
	m_cFeedReportTimer( 0 ),
	m_cFeedReportInterval( 0 ),
	m_cMaxSearchResults( 0 ),
    m_pSSLInfo( NULL ),
    m_pIMailMsgClassFactory( NULL ),
    m_pRebuild( NULL ),
    m_dwLastRebuildError( NO_ERROR ),
    m_dwProgress( 0 )
{
	TraceFunctEnter("NNTP_SERVER_INSTANCE::NNTP_SERVER_INSTANCE");
    DebugTrace(0,"Init instance from %s\n", lpszRegParamKey );

	m_ProviderNames[0] = '\0';
	m_szMembershipBroker[0] = '\0';
	m_szCleartextAuthPackage[0] = '\0';

	//
	//	Init certificate mappers
	//

    for ( DWORD i = 0 ; i < MT_LAST ; ++i ) {
        m_apMappers[i] = NULL;
    }

#if 0
    // This check is done in iisnntp.cxx. Returning at this point
    // causes problems when the destructor is called !
    if ( QueryServerState( ) == MD_SERVER_STATE_INVALID ) {
        return;
    }
#endif

	//
	//	Set Metabase paths
	//

	lstrcpyn( m_szMDFeedPath, QueryMDPath(), sizeof(m_szMDFeedPath) -7 );
	lstrcat( m_szMDFeedPath, "/Feeds/" );
	lstrcpyn( m_szMDVRootPath, QueryMDPath(), sizeof(m_szMDVRootPath) - 6 );
	lstrcat( m_szMDVRootPath, "/ROOT/" );

    //
    // Init statistics object
    //
    INIT_LOCK( &m_StatLock );
    ClearStatistics();

	// Misc Feeds stuff
	ZeroMemory( (PVOID)&m_ftCurrentTime, sizeof(FILETIME) );
	ZeroMemory( (PVOID)&m_liCurrentTime, sizeof(ULARGE_INTEGER) );

	//
	//	Initialize server greeting strings, file paths, DNS name etc
	//
	if( !InitializeServerStrings() ) {
		// handle error
	}

    //
    // Initialize Critical sections
    //
	InitializeCriticalSection( &m_critFeedRPCs ) ;
	InitializeCriticalSection( &m_critFeedTime ) ;
	InitializeCriticalSection( &m_critFeedConfig ) ;
	InitializeCriticalSection( &m_critNewsgroupRPCs ) ;
	InitializeCriticalSection( &m_critRebuildRpc ) ;
	InitializeCriticalSection( &m_critBoot ) ;

	// should be NULL to begin with
	m_pArticleTable = NULL ;
	m_pHistoryTable = NULL ;
	m_pXoverTable = NULL ;
	m_pXCache = NULL ;
	m_pExpireObject = NULL ;
	m_pVRootTable = NULL;
	m_pActiveFeeds = NULL ;
	m_pPassiveFeeds = NULL ;
	m_pInUseList = NULL ;

	// reset counters for client postings and directory pickup
	m_pFeedblockClientPostings = XNEW FEED_BLOCK;
	if (m_pFeedblockClientPostings != NULL) {
		ZeroMemory(m_pFeedblockClientPostings, sizeof(FEED_BLOCK));
		m_pFeedblockClientPostings->FeedId = (DWORD) -1;
		m_pFeedblockClientPostings->FeedType = FEED_TYPE_PASSIVE;
		m_pFeedblockClientPostings->Signature = FEED_BLOCK_SIGN;
		m_pFeedblockClientPostings->ServerName = 0;
	}
	m_pFeedblockDirPickupPostings = XNEW FEED_BLOCK;
	if (m_pFeedblockDirPickupPostings != NULL) {
		ZeroMemory(m_pFeedblockDirPickupPostings, sizeof(FEED_BLOCK));
		m_pFeedblockDirPickupPostings->FeedId = (DWORD) -2;
		m_pFeedblockDirPickupPostings->FeedType = FEED_TYPE_PASSIVE;
		m_pFeedblockDirPickupPostings->Signature = FEED_BLOCK_SIGN;
		m_pFeedblockDirPickupPostings->ServerName = 0;
	}

    TraceFunctLeave();

    return;

} // NNTP_SERVER_INSTANCE::NNTP_SERVER_INSTANCE

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::~NNTP_SERVER_INSTANCE
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

NNTP_SERVER_INSTANCE::~NNTP_SERVER_INSTANCE(
                        VOID
                        )
{
    DWORD i = 0;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::~NNTP_SERVER_INSTANCE");

	//
	// Stop() the instance - needs to be called after we unbind atq
	//

	Stop() ;

	if( m_ProviderPackages != NULL ) {
		LocalFree( (PVOID)m_ProviderPackages );
		m_ProviderPackages = NULL;
	}

    //
    // delete statistics object
    //
    DELETE_LOCK( &m_StatLock );

	//
	// delete the directory notification object
	//
	if (m_pDirNot != NULL) XDELETE m_pDirNot;
	m_pDirNot = NULL;
	if (m_heNoPickups != NULL) _VERIFY(CloseHandle(m_heNoPickups));
	m_heNoPickups = NULL;

	//
	// delete feed blocks
	//
    if ( m_pFeedblockClientPostings ) XDELETE m_pFeedblockClientPostings;
    m_pFeedblockClientPostings = NULL;
    if ( m_pFeedblockDirPickupPostings ) XDELETE m_pFeedblockDirPickupPostings;
    m_pFeedblockDirPickupPostings = NULL;

    //
    // Terminate Critical Sections
    //

	DeleteCriticalSection( &m_critFeedRPCs ) ;
	DeleteCriticalSection( &m_critFeedTime ) ;
	DeleteCriticalSection( &m_critFeedConfig ) ;
	DeleteCriticalSection( &m_critNewsgroupRPCs ) ;
	DeleteCriticalSection( &m_critRebuildRpc ) ;
	DeleteCriticalSection( &m_critBoot ) ;

    UINT iM;
    for ( iM = 0 ; iM < MT_LAST ; ++iM )
    {
        if ( m_apMappers[iM] )
        {
            ((RefBlob*)(m_apMappers[iM]))->Release();
        }
    }

    TraceFunctLeave();

} // NNTP_SERVER_INSTANCE::~NNTP_SERVER_INSTANCE

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::Start
//
//  Synopsis:   Called to start -
//				This function should return FALSE on all
//				boot errors. The fFatal param will be set to
//				TRUE if the boot error is fatal.
//
//				Returning FALSE will prevent the instance from
//				being started ie. it will be in the stopped state.
//				The only actions possible on such an
//				instance are things like nntpbld that correct
//				non-fatal boot errors.
//
//				All such non-fatal errors, will result in an
//				event log that tells the admin what to do to
//				correct the situation (eg run nntpbld)
//
//  Arguments:  fFatal - is set to TRUE if a fatal error occurs on boot
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         23 May 1995
//
//----------------------------------------------------------------
BOOL NNTP_SERVER_INSTANCE::Start( BOOL& fFatal )
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::Start" );

	BOOL	fSuccess = TRUE ;
	DWORD	err ;
	PCHAR	args [2];
	CHAR	szId [20];
	HRESULT hr;
	BOOL    fUpgrade = FALSE;

	EnterCriticalSection( &m_critBoot );

	m_ServiceStartCalled = TRUE ;
	//m_dwProgress = 0;
	fFatal = FALSE ;

	StartHintFunction() ;

	//
	//	Allocate memory for member objects
	//	These are freed in the Stop() function which will be called
	//	when the service stops.
	//
	if( !AllocateServerStructures() ) {
		fFatal = TRUE ;	// fatal
		goto Exit ;
	}

    //
    // Read the Nntp specfic params
	//	- private params are read from registry
	//	- public params are read from the metabase
    //

    if ( !ReadPrivateNntpParams( ) || !ReadPublicNntpParams( FC_NNTP_ALL ) ) {
		fFatal = TRUE ;	// fatal
		goto Exit ;
    }

	err = ReadAuthentInfo();
	if( err != NO_ERROR ) {
		// TODO: handle error
	}

    //  Read IP sec info from metabase
	ReadIpSecList();

	_VERIFY( m_pActiveFeeds->Init()  );
	_VERIFY( m_pPassiveFeeds->Init() );
    INITIALIZE_VAR( m_InitVar, FEEDLIST_INIT );

    //
    // Make sure all hash tables are either not here or
    // are all here.
    //

	if (!VerifyHashTablesExist()) {
		fSuccess = FALSE ;
	}

    //
	//	We will attempt to boot all data structures always. If any data str
	//	(like hash tables) do not boot, the server will be in a stopped state.
    //


	if( !(CNewsTree::InitCNewsTree( this, fFatal ) ) )  {
		fSuccess = FALSE ;
		if( fFatal ) { goto Exit ; }
    }

    INITIALIZE_VAR( m_InitVar, CNEWSTREE_INIT );

	if (!m_pTree->LoadTree( QueryGroupListFile(),
	                        QueryGroupVarListFile(),
	                        fUpgrade,
	                        QueryInstanceId(),
	                        m_fAllFilesMustExist)) {
		fSuccess = FALSE;
		goto Exit;
	}

	//
	//	Initialize expire policies from metabase and the rmgroup queue
	//	Only fatal errors are failure to allocate memory.
	//

    if( !m_pExpireObject->InitializeExpires( StopHintFunction, fFatal, QueryInstanceId() ) ) {
		fSuccess = FALSE ;
		if( fFatal ) { goto Exit ; }
	}

	INITIALIZE_VAR( m_InitVar, EXPIRE_INIT );
    INITIALIZE_VAR( m_InitVar, RMGROUP_QUEUE_INIT );


	//
	//	so far so good - lets do the hash tables now.
	//	if any one of them fail to boot, we will return FALSE
	//	and remain in the stopped state.

    if( !m_pArticleTable->Initialize( m_ArticleTableFile, 0, HashTableNoBuffering )  ) {

		args[0] = m_ArticleTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, ARTICLE_TABLE_INIT );

    StartHintFunction() ;

    if( !m_pHistoryTable->Initialize(	m_HistoryTableFile,
										TRUE,
										0,
										DEF_EXPIRE_INTERVAL, // Default Expire Interval !
										4,					// Crawl at least 4 pages all the time !
										HashTableNoBuffering) ) {

		args[0] = m_HistoryTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, HISTORY_TABLE_INIT );

    StartHintFunction() ;

    if( !m_pXoverTable->Initialize( m_XoverTableFile, 0, HashTableNoBuffering ) ) {

		args[0] = m_XoverTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, XOVER_TABLE_INIT );

    StartHintFunction();

    //
    // Check consistency between xover table and newstree
    //
    if ( !ServerDataConsistent() ) {
        _ASSERT( 0 );
		NntpLogEventEx(NNTP_HASH_TABLE_INCONSISTENT,
			0,
			(const CHAR**)NULL,
			0,
			QueryInstanceId()
			);
        fSuccess = FALSE;
        goto Exit;
    }

    StartHintFunction() ;

	if (FAILED(m_pVRootTable->Initialize(QueryMDVRootPath(), m_pInstanceWrapperEx, fUpgrade ))) {
		fSuccess = FALSE;
		goto Exit;
	}

    INITIALIZE_VAR( m_InitVar, VROOTTABLE_INIT );

    //
    //	Call UpdateVrootInfo() to decorate the newsgroups with
    //	vroot properties like SSL access perms..
    //	UpdateVrootInfo() will try to read the MB only once per vroot
    //
    //  Dummy call, take out
    //m_pTree->UpdateVrootInfo();

    if( !m_pXCache->Init(MAX_HANDLES,StopHintFunction) ) {
		fFatal = TRUE ;	// fatal
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, CXOVER_CACHE_INIT );

    StartHintFunction() ;

    //
    // Start feed manager
    //

    if ( !InitializeFeedManager( this, fFatal ) ) {
		fSuccess = FALSE ;
		if( fFatal ) { goto Exit ; }
    }

    INITIALIZE_VAR( m_InitVar, FEED_MANAGER_INIT );

    StartHintFunction() ;

    //
	// initialize shinjuku
	//
	m_pSEORouter = NULL;
	/*
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (hr == CO_E_ALREADYINITIALIZED || SUCCEEDED(hr)) {
	*/

	//
    // Get interface pointer for IMailMsg class factory
    //
    CLSID clsidIMsg;
	hr = CLSIDFromProgID( L"Exchange.MailMsg", &clsidIMsg );
	if (SUCCEEDED(hr)) {
	    hr = CoGetClassObject((REFCLSID) clsidIMsg,
		                       CLSCTX_INPROC_SERVER,
		                       NULL,
		                       (REFIID) IID_IClassFactory,
		                       (void**)&m_pIMailMsgClassFactory );
	}

	if ( FAILED( hr ) || NULL == m_pIMailMsgClassFactory ) {
	    _ASSERT( 0 );
	    ErrorTrace( 0, "Create IMailMsg class factory failed %x", hr );
	    m_pIMailMsgClassFactory = NULL;
	    fFatal = TRUE;
	    goto Exit;
	}


	hr = SEOGetRouter(NNTP_SOURCE_TYPE_GUID,
	    			  (REFGUID) CStringGUID(GUID_NNTPSVC, QueryInstanceId()),
						  &m_pSEORouter);
	if (hr != S_OK) {
		m_pSEORouter = NULL;
		NntpLogEventEx(SEO_INIT_FAILED_INSTANCE,
	    			   0,
					   (const char **) NULL,
					   hr,
					   QueryInstanceId());
	}
	else INITIALIZE_VAR(m_InitVar, SEO_INIT);

    StartHintFunction() ;

	//
	// Start directory pickup - should check server state
	// If server is in MD_SERVER_STATE_PAUSED, this should
	// be disabled.
	//
	if (m_szPickupDirectory[0] == (WCHAR) 0) {
		ErrorTrace(0, "no pickup directory specified");
	} else {
		//
		// we do not want dir notifications active during rebuilds !!
		// Ideally, we should be able to start this up, so
		// that we do not have special switches based on boot options !!
		// this check means that after nntpbld, the instance will
		// need to be restarted for dir notifications to be enabled.
		//

		if( m_BootOptions == NULL ) {
			//
			// create and start the pickup directory monitor
			//
			m_pDirNot = XNEW IDirectoryNotification;
			if (m_pDirNot == NULL) {
				TraceFunctLeave();
				fFatal = TRUE;
				goto Exit;
			}

			m_cPendingPickups = 0;
			m_heNoPickups = CreateEvent(NULL, TRUE, TRUE, NULL);
			if (m_heNoPickups == NULL) {
				XDELETE m_pDirNot;
				m_pDirNot = NULL;
			} else {
				this->Reference();
				hr = m_pDirNot->Initialize( m_szPickupDirectory,
							                this,
							                FALSE,
							                FILE_NOTIFY_CHANGE_FILE_NAME,
							                FILE_ACTION_ADDED,
							                PickupFile);
				if (FAILED(hr)) {
					this->Dereference();
					XDELETE m_pDirNot;
					m_pDirNot = NULL;
					//
					//	Failure to init dir not is not fatal
					//

					NntpLogEvent(NNTP_INIT_DIRNOT_FAILED,
						0,
						(const char **)NULL,
						hr
						);

				} else {
					INITIALIZE_VAR(m_InitVar, DIRNOT_INIT);
				}
			}
		}
	}


Exit:

	if( GetLastError() == ERROR_NOT_ENOUGH_MEMORY ) {
		fFatal = TRUE ;	// fatal
	}

	if( fFatal ) fSuccess = FALSE;	// No success with fatal errors !

	if( fSuccess ) {

		//  Log a successful boot event !
		args [0] = szVersionString;
		_itoa( QueryInstanceId(), szId, 10 );
		args [1] = szId;

		NntpLogEvent( NNTP_EVENT_INSTANCE_STARTED, 2, (const char**)args, 0 ) ;


	} else {
		ErrorTrace(0,"Instance %d boot failed: rebuild needed", QueryInstanceId() );
	}

	LeaveCriticalSection( &m_critBoot );

    TraceFunctLeave();
    return fSuccess ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::Stop
//
//  Synopsis:   Called to stop
//
//  Arguments:  VOID
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         23 May 1995
//
//----------------------------------------------------------------

BOOL NNTP_SERVER_INSTANCE::Stop()
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::Stop" );

	EnterCriticalSection( &m_critBoot );

	if( !m_ServiceStartCalled ) {
		LeaveCriticalSection( &m_critBoot );
		return FALSE ;
	}

    //
    //  Dont want feeds started while we're stopping !
    //
    if( IS_INITIALIZED( m_InitVar, FEED_MANAGER_INIT ) ) {
        TerminateFeedManager( this ) ;
		TERMINATE_VAR( m_InitVar, FEED_MANAGER_INIT ) ;
	}

	StopHintFunction() ;

	//
	// we shutdown directory notification in pTree->StopTree!
	//
	// note: sometimes StopTree doesn't get called (if the newstree
	// wasn't started for instance).  in those cases we shutdown here.
	//
	if (IS_INITIALIZED(m_InitVar, DIRNOT_INIT)) {
		WaitForPickupThreads();
		ShutdownDirNot();
		TERMINATE_VAR( m_InitVar, DIRNOT_INIT ) ;
	}

	StopHintFunction() ;

    //
    // enumerate all users to call their Disconnect method
    //
    if( m_pInUseList ) {
        m_pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
    }

    //
    // Release IMailmsg class factory
    //
    //_ASSERT( m_pIMailMsgClassFactory );
    if ( m_pIMailMsgClassFactory ) {
        m_pIMailMsgClassFactory->Release();
        m_pIMailMsgClassFactory = NULL;
    }

	//
	// shutdown shinjuku
	//
	if (IS_INITIALIZED(m_InitVar, SEO_INIT)) {
		// this causes SEO to drop all loaded objects (like ddrop)
		m_pSEORouter->Release();
		m_pSEORouter = NULL;
		TERMINATE_VAR( m_InitVar, SEO_INIT ) ;
	}

	//
	// here we see if we are getting shutdown because we are being
	// deleted.  if so then we'll remove all of our bindings from
	// the shinjuku event binding database
	//
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    if (mb.Open(QueryMDPath())) {
		// our metabase path still exists, so we aren't being deleted
		mb.Close();
	} else {
		// our metabase path is gone, delete the shinjuku binding
		// database
		HRESULT hr = UnregisterSEOInstance(QueryInstanceId());
		if (FAILED(hr)) {
			ErrorTrace(0, "UnregisterSEOInstance(%lu) failed with %x",
				QueryInstanceId(), hr);
			NntpLogEventEx(SEO_DELETE_INSTANCE_FAILED,
						   0,
						   (const char **) NULL,
						   hr,
						   QueryInstanceId());
		}
	}

	// clean up any dirnot references in the retryq
	if ( m_pDirNot ) m_pDirNot->CleanupQueue();

	CoFreeUnusedLibraries();
	StopHintFunction() ;

    //
    //  Terminate CNewsTree first so that all references to groups are aren't dead
    //  when we kill this guy !
    //
    if( IS_INITIALIZED( m_InitVar, RMGROUP_QUEUE_INIT ) ) {
        m_pExpireObject->TerminateRmgroups( m_pTree ) ;
		TERMINATE_VAR( m_InitVar, RMGROUP_QUEUE_INIT ) ;
    }

    //
    // Tell crawler threads to abbreviate their work.
    //
    if( IS_INITIALIZED( m_InitVar, CNEWSTREE_INIT ) ) {
		_ASSERT( m_pTree );
        m_pTree->StopTree() ;
	}

    if( IS_INITIALIZED( m_InitVar, EXPIRE_INIT ) ) {
        m_pExpireObject->TerminateExpires( GetInstanceLock() ) ;
		TERMINATE_VAR( m_InitVar, EXPIRE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, CNEWSTREE_INIT ) ) {
		_ASSERT( m_pTree );
		m_pTree->TermTree() ;
	}

    if( IS_INITIALIZED( m_InitVar, VROOTTABLE_INIT ) ) {
		_ASSERT(m_pVRootTable != NULL);
		XDELETE m_pVRootTable;
		m_pVRootTable = NULL;
		TERMINATE_VAR( m_InitVar, VROOTTABLE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, CNEWSTREE_INIT ) ) {
		_ASSERT( m_pTree );
		XDELETE m_pTree;
		m_pTree = NULL;
		TERMINATE_VAR( m_InitVar, CNEWSTREE_INIT ) ;
	}

	StopHintFunction();

    if( IS_INITIALIZED( m_InitVar, XOVER_TABLE_INIT ) ) {
        m_pXoverTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, XOVER_TABLE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, HISTORY_TABLE_INIT ) ) {
        m_pHistoryTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, HISTORY_TABLE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, ARTICLE_TABLE_INIT ) ) {
        m_pArticleTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, ARTICLE_TABLE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, CXOVER_CACHE_INIT ) ) {
        m_pXCache->Term() ;
		TERMINATE_VAR( m_InitVar, CXOVER_CACHE_INIT ) ;
	}

	StopHintFunction() ;

    if( IS_INITIALIZED( m_InitVar, FEEDLIST_INIT ) ) {
        _ASSERT( m_pActiveFeeds && m_pPassiveFeeds );
    	m_pActiveFeeds->Term() ;
	    m_pPassiveFeeds->Term() ;
		TERMINATE_VAR( m_InitVar, FEEDLIST_INIT ) ;
	}

    //
    // free the SSL info object
    //
    if ( m_pSSLInfo != NULL ) {
        DWORD dwCount = IIS_SSL_INFO::Release( m_pSSLInfo );
        m_pSSLInfo = NULL;
    }

	m_rfAccessCheck.Reset( (IMDCOM*)g_pInetSvc->QueryMDObject() );

	FreeServerStructures();

    RegCloseKey( m_hRegKey ) ;
    m_hRegKey = 0 ;

    // Log a successful stop event !
    PCHAR args [2];
	CHAR  szId [20];
    args [0] = szVersionString;
	_itoa( QueryInstanceId(), szId, 10 );
	args [1] = szId;

    NntpLogEvent(
            NNTP_EVENT_INSTANCE_STOPPED,
            2,
            (const char**)args,
            0
            ) ;

	m_ServiceStartCalled = FALSE ;

	LeaveCriticalSection( &m_critBoot );
    return TRUE;
}

#if 0
//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::StartHashTables
//
//  Synopsis:   Call this function to boot several NNTP hash table
//				include XOVER.HSH, ARTICLE.HSH, XoverCache.
//				It also allocates all server structures.
//				TRUE if all tables boot successfully.
//
//				This is call from the rebuid thread to only boot
//				the hash table for STANDARD rebuild of group.lst.
//				Caller should be responsible to call StopHashTables()
//				upon rebuild complete to stop all hash tables before
//				attempting to boot the entire instance.
//
//				All such non-fatal errors, will result in an
//				event log that tells the admin what to do to
//				correct the situation (eg run MEDIUM/THOROUGH rebuild)
//
//  Arguments:  fFatal - is set to TRUE if a fatal error occurs on boot
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------
BOOL NNTP_SERVER_INSTANCE::StartHashTables( void )
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::StartHashTables" );

	BOOL	fSuccess = TRUE ;
    BOOL    fFatal = FALSE;
    DWORD   err;
	PCHAR	args [2];

	EnterCriticalSection( &m_critBoot );

	m_ServiceStartCalled = TRUE ;

	//
	//	Allocate memory for member objects
	//	These are freed in the StopHashTables() function which will be called
	//	when rebuild finishes.
	//
	if( !AllocateServerStructures() ) {
		fSuccess = FALSE ;	// fatal
		goto Exit ;
	}

    //
    // Read the Nntp specfic params
	//	- private params are read from registry
	//	- public params are read from the metabase
    //  only need to read public params.
    //

    if ( !ReadPublicNntpParams( FC_NNTP_ALL ) ) {
		fSuccess = FALSE ;
		goto Exit ;
    }

    //
    // If we are booting up with the correct boot option:
    // a) Delete m_BootOptions->szGroupListTmp
    // b) Swap the value for m_GroupListFile and
    // m_BootOptions->szGroupListTmp so we rebuild on szGroupListTmp
    //
    if (m_BootOptions)
    {
        if (m_BootOptions->ReuseIndexFiles == NNTPBLD_DEGREE_STANDARD)
        {
            _ASSERT( m_BootOptions->szGroupListTmp );
            _ASSERT( m_GroupListFile );

            DeleteFile( m_BootOptions->szGroupListTmp );

            CHAR    psz[MAX_PATH];
            lstrcpy( psz, m_GroupListFile );
            lstrcpy( m_GroupListFile, m_BootOptions->szGroupListTmp );
            lstrcpy( m_BootOptions->szGroupListTmp, psz );
        }
    }

    //
    // Make sure both hash tables exists!!!
    //

	if (!VerifyHashTablesExist( TRUE )) {
		// TODO: BINLIN add eventlog to indicate running Thorough rebuild
        fSuccess = FALSE;
        goto Exit;
	}

#if 0
    m_pTree = XNEW CNewsTree() ;
	if( !m_pTree ) { fSuccess = FALSE;	goto Exit; }

	if( !(CNewsTree::InitCNewsTree( this, fFatal ) ) )  {

		if( fFatal ) { fSuccess = FALSE ; goto Exit ; }
    }

    INITIALIZE_VAR( m_InitVar, CNEWSTREE_INIT );
#endif

    //
    //	Call UpdateVrootInfo() to decorate the newsgroups with
    //	vroot properties like SSL access perms..
    //	UpdateVrootInfo() will try to read the MB only once per vroot
    //
#if 0
    m_pTree->UpdateVrootInfo();
#endif

    //
    // Boot the XoverCache data structure
    //
    if( !m_pXCache->Init(MAX_HANDLES,StopHintFunction) ) {
		fSuccess = FALSE;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, CXOVER_CACHE_INIT );

	//
	//	so far so good - lets do the hash tables now.
	//	if any one of them fail to boot, we will return FALSE
	//

    if( !m_pArticleTable->Initialize( m_ArticleTableFile, 0, HashTableNoBuffering )  ) {

		args[0] = m_ArticleTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, ARTICLE_TABLE_INIT );

    if( !m_pXoverTable->Initialize( m_XoverTableFile, 0, HashTableNoBuffering ) ) {

		args[0] = m_XoverTableFile;
		NntpLogEventEx( NNTP_BAD_HASH_TABLE, 1, (const CHAR**)args, GetLastError(), QueryInstanceId() );

		fSuccess = FALSE ;
		goto Exit ;
	}

    INITIALIZE_VAR( m_InitVar, XOVER_TABLE_INIT );

Exit:

	err = GetLastError();
	if( !fSuccess ) {

		ErrorTrace(0,"Instance %d failed to boot hash tables during rebuild - %X", QueryInstanceId(), err );
	}

	LeaveCriticalSection( &m_critBoot );

    TraceFunctLeave();
    return fSuccess ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::StopHashTables
//
//  Synopsis:   Called to stop hash tables booted by StartHashTables
//
//  Arguments:  VOID
//
//  Returns:    TRUE is success, else FALSE
//
//  History:
//
//----------------------------------------------------------------

BOOL NNTP_SERVER_INSTANCE::StopHashTables()
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::StopHashTables" );

	EnterCriticalSection( &m_critBoot );

	if( !m_ServiceStartCalled ) {
		LeaveCriticalSection( &m_critBoot );
		return FALSE ;
	}

    if( IS_INITIALIZED( m_InitVar, CNEWSTREE_INIT ) ) {
		_ASSERT( m_pTree );
		m_pTree->TermTree( ) ;
		XDELETE m_pTree;
		m_pTree = NULL;
		TERMINATE_VAR( m_InitVar, CNEWSTREE_INIT ) ;
	}

    if( IS_INITIALIZED( m_InitVar, XOVER_TABLE_INIT ) ) {
        m_pXoverTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, XOVER_TABLE_INIT ) ;
	}

    if( IS_INITIALIZED( m_InitVar, ARTICLE_TABLE_INIT ) ) {
        m_pArticleTable->Shutdown() ;
		TERMINATE_VAR( m_InitVar, ARTICLE_TABLE_INIT ) ;
	}

    if( IS_INITIALIZED( m_InitVar, CXOVER_CACHE_INIT ) ) {
        m_pXCache->Term() ;
		TERMINATE_VAR( m_InitVar, CXOVER_CACHE_INIT ) ;
	}

	FreeServerStructures();

	m_ServiceStartCalled = FALSE ;

	LeaveCriticalSection( &m_critBoot );
    return TRUE;
}
#endif

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadPrivateNntpParams
//
//  Synopsis:   Read private reg settings
//				Reads reg values not defined in UI
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::ReadPrivateNntpParams()
{
    DWORD   dw;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::ReadPrivateNntpParams");

    //
    //  Default set of commands to log.
    //  Unless we pick up something otherwise from the registry -
    //  we will generate transaction logs for the following commands.
    //

    m_dwCommandLogMask = (DWORD) (
                            eArticle |
                            eBody	 |
                            eHead    |
                            eIHave   |
                            ePost    |
                            eXReplic |
                            eQuit    |
                            eUnimp   |	// eUnimp - really means anything we dont recognize
							eOutPush ) ;


	//	NOTE: this is closed in the instance destructor
    if (!RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_READ | KEY_WRITE,
                        &m_hRegKey ) == ERROR_SUCCESS)

    {
        return  FALSE ;

    }   else    {

		BOOL fNonBlocking = TRUE;
        if( GetRegDword( m_hRegKey, StrBuffer, &dw )  ) {
			fNonBlocking = (dw != 0) ;
            g_pNntpSvc->SetNonBlocking(fNonBlocking) ;
        }

        DebugTrace( (DWORD_PTR)this,    "Buffered Writes %sabled",
                    fNonBlocking ? "En" : "Dis" ) ;

        //
        // if buffered writes are disabled then the default is
        // set the send buffer sizes to 0 to control buffer
        // allocations at the applcation level
        //
        if( fNonBlocking == FALSE ) {
            g_pNntpSvc->SetSockSendBuffSize( 0 ) ;
        }

        if( GetRegDword(m_hRegKey, StrSocketRecvSize, &dw ) ) {
            g_pNntpSvc->SetSockSendBuffSize( (int)dw ) ;
        }
        if( GetRegDword(m_hRegKey, StrSocketSendSize, &dw ) ) {
            g_pNntpSvc->SetSockRecvBuffSize( (int)dw ) ;
        }

        if( GetRegDword(m_hRegKey, StrCommandLogMask, &dw ) ) {
            m_dwCommandLogMask = dw ;
        }
	}

    if( GetRegDword(    m_hRegKey,  StrCleanBoot,   &dw ) ) {
        if( dw == 0 ) {
            m_fRecoveryBoot = TRUE ;
        }
    }

    if( !ReadMappers() ) {
    	//
    	//	No mapper configured
    	//
    	DebugTrace(0,"ReadMappers failed");
   	}

	return TRUE ;

} // NNTP_SERVER_INSTANCE::ReadPrivateNntpParams

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadPublicNntpParams
//
//  Synopsis:   Read public config info from metabase
//
//  Arguments:
//
//  Returns:    TRUE if successful, FALSE on error
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::ReadPublicNntpParams(
    IN FIELD_CONTROL FieldsToRead
    )
{
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
	DWORD   dwSize = MAX_PATH, dw ;
	CHAR	data [1024];
	DWORD   err = NO_ERROR;
	BOOL	fSuccess = TRUE;
	STR		str;

    ENTER("ReadPublicNntpParams")

	//
	//	This lock is grabbed by any code that reads config params like
	//	SmtpServerAddress etc.
	//

    LockConfigWrite();

	//
	//	Open the metabase key for this instance and
	//	read all params !
	//

    if ( mb.Open( QueryMDPath() ) )
	{
		if( IsFieldSet( FieldsToRead, FC_NNTP_AUTHORIZATION ) ) {
			if ( !mb.GetDword( "",
							   MD_AUTHORIZATION,
							   IIS_MD_UT_SERVER,
							   &m_dwAuthorization ) )
			{
				m_dwAuthorization = MD_AUTH_ANONYMOUS;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_POSTINGMODES ) ) {
			if ( !mb.GetDword( "",
							   MD_ALLOW_CLIENT_POSTS,
							   IIS_MD_UT_SERVER,
							   &dw ) )
			{
				m_fAllowClientPosts = NNTP_DEF_ALLOWCLIENTPOSTS ;
			} else {
				m_fAllowClientPosts = dw ? TRUE : FALSE ;
			}

			if ( !mb.GetDword( "",
							   MD_ALLOW_FEED_POSTS,
							   IIS_MD_UT_SERVER,
							   &dw ) )
			{
				m_fAllowFeedPosts = NNTP_DEF_ALLOWFEEDPOSTS ;
			} else {
				m_fAllowFeedPosts = dw ? TRUE : FALSE ;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_POSTLIMITS ) ) {
			if ( !mb.GetDword( "",
							   MD_CLIENT_POST_SOFT_LIMIT,
							   IIS_MD_UT_SERVER,
							   &m_cbSoftLimit ) )
			{
				m_cbSoftLimit = NNTP_DEF_CLIENTPOSTSOFTLIMIT ;
			}

			if ( !mb.GetDword( "",
							   MD_CLIENT_POST_HARD_LIMIT,
							   IIS_MD_UT_SERVER,
							   &m_cbHardLimit ) )
			{
				m_cbHardLimit = NNTP_DEF_CLIENTPOSTHARDLIMIT ;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_FEEDLIMITS ) ) {
			if ( !mb.GetDword( "",
							   MD_FEED_POST_SOFT_LIMIT,
							   IIS_MD_UT_SERVER,
							   &m_cbFeedSoftLimit ) )
			{
				m_cbFeedSoftLimit = NNTP_DEF_FEEDPOSTSOFTLIMIT ;
			}

			if ( !mb.GetDword( "",
							   MD_FEED_POST_HARD_LIMIT,
							   IIS_MD_UT_SERVER,
							   &m_cbFeedHardLimit ) )
			{
				m_cbFeedHardLimit = NNTP_DEF_FEEDPOSTHARDLIMIT ;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_CONTROLSMSGS ) ) {
			if ( !mb.GetDword( "",
							   MD_ALLOW_CONTROL_MSGS,
							   IIS_MD_UT_SERVER,
							   &dw ) )
			{
				m_fAllowControlMessages = NNTP_DEF_ALLOWCONTROLMSGS ;
			} else {
				m_fAllowControlMessages = dw ? TRUE : FALSE ;
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_SMTPADDRESS ) ) {
			dwSize = MAX_PATH ;
			if( !mb.GetString(	"",
								MD_SMTP_SERVER,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_szSmtpAddress[0] = (WCHAR)0;
				m_cbSmtpAddress = sizeof(WCHAR);
			} else {
				ZeroMemory( m_szSmtpAddress, sizeof( m_szSmtpAddress ) ) ;

				m_cbSmtpAddress =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szSmtpAddress,
						sizeof( m_szSmtpAddress ) / sizeof( m_szSmtpAddress[0] ) ) ;
				m_cbSmtpAddress *= sizeof(WCHAR);
			}
		}

		//
    	// Update auth stuff
		//

    	if (IsFieldSet( FieldsToRead, FC_NTAUTHENTICATION_PROVIDERS))
		{
			// m_ProviderNames is a MultiSz, so it's length should be 1 byte greater than szAuthPack
			CHAR szAuthPack[MAX_PATH-1];
			if (mb.GetStr("", MD_NTAUTHENTICATION_PROVIDERS, IIS_MD_UT_SERVER, &str, METADATA_INHERIT, ""))
			{
				lstrcpyn(szAuthPack, str.QueryStr(), sizeof(szAuthPack));
				DebugTrace((LPARAM)this, "Authentication packages=%s", szAuthPack);
				if (!ConvertToMultisz(m_ProviderNames, &m_cProviderPackages, szAuthPack))
				{
					CopyMemory(m_ProviderNames, pszPackagesDefault, ccbPackagesDefault);
					m_cProviderPackages = 1;
				}
			}
			else
			{
				DebugTrace((LPARAM)this, "Use default authentication packages=%s", pszPackagesDefault);
				CopyMemory(m_ProviderNames, pszPackagesDefault, ccbPackagesDefault);
				m_cProviderPackages = 1;
			}

			// set the AUTH_BLOCK info
			if (!SetProviderPackages())
			{
				ErrorTrace((LPARAM)this, "Unable to allocate AUTH_BLOCK");
			}
		}

		//
		// Read the Membership Broker name that will be used with MBS_BASIC
		//

	    if (IsFieldSet( FieldsToRead, FC_MD_SERVER_SS_AUTH_MAPPING))
		{
			if (mb.GetStr("", MD_MD_SERVER_SS_AUTH_MAPPING, IIS_MD_UT_SERVER, &str, METADATA_INHERIT, ""))
			{
				lstrcpyn(m_szMembershipBroker, str.QueryStr(), sizeof(m_szMembershipBroker));
				StateTrace((LPARAM)this, "Membership Broker name is set to %s", m_szMembershipBroker);
			}
			else
			{
				m_szMembershipBroker[0] = '\0';
				StateTrace((LPARAM)this, "No Membership Broker name configured");
			}
		}

	    if (IsFieldSet( FieldsToRead, FC_NNTP_CLEARTEXT_AUTH_PROVIDER))
		{
			m_cbCleartextAuthPackage = sizeof(m_szCleartextAuthPackage);
			if (mb.GetStr("", MD_NNTP_CLEARTEXT_AUTH_PROVIDER, IIS_MD_UT_SERVER, &str, METADATA_INHERIT, ""))
			{
				lstrcpyn(m_szCleartextAuthPackage, str.QueryStr(), sizeof(m_szCleartextAuthPackage));
				m_cbCleartextAuthPackage = lstrlen(m_szCleartextAuthPackage) + 1;

				StateTrace((LPARAM)this, "Cleartext authentication provider: <%s>, length %u",
							m_szCleartextAuthPackage,
							m_cbCleartextAuthPackage);
			}
			else
			{
				m_szCleartextAuthPackage[0] = '\0';
				m_cbCleartextAuthPackage = 0;
				StateTrace((LPARAM)this, "No default cleartext authentication provider specified, using CleartextLogon");
			}
		}

		//	TODO: define a bit mask if this param can be changed on the fly
		if( FieldsToRead == FC_NNTP_ALL ) {
			if (!mb.GetDword( "",
							  MD_FEED_REPORT_PERIOD,
							  IIS_MD_UT_SERVER,
							  &dw))
			{
				m_cFeedReportInterval = NNTP_DEF_FEED_REPORT_PERIOD;
			} else {
				m_cFeedReportInterval = dw;
			}

			if (!mb.GetDword( "",
							  MD_MAX_SEARCH_RESULTS,
							  IIS_MD_UT_SERVER,
							  &dw))
			{
				m_cMaxSearchResults = NNTP_DEF_MAX_SEARCH_RESULTS;
			} else {
				m_cMaxSearchResults = dw;
			}

			dwSize = MAX_PATH ;
			if( !mb.GetString(	"",
								MD_PICKUP_DIRECTORY,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_szPickupDirectory[0] = (WCHAR)0;
				m_cbPickupDirectory = sizeof(WCHAR);
			} else {
				ZeroMemory( m_szPickupDirectory, sizeof( m_szPickupDirectory ) ) ;

				m_cbPickupDirectory =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szPickupDirectory,
						sizeof( m_szPickupDirectory ) / sizeof( m_szPickupDirectory[0] ) ) ;
				m_cbPickupDirectory *= sizeof(WCHAR);

				if (m_szPickupDirectory[lstrlenW(m_szPickupDirectory) - 1] != L'\\')
					lstrcatW(m_szPickupDirectory, L"\\");
			}

			dwSize = MAX_PATH ;
			if( !mb.GetString(	"",
								MD_FAILED_PICKUP_DIRECTORY,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_szFailedPickupDirectory[0] = (WCHAR)0;
				m_cbFailedPickupDirectory = sizeof(WCHAR);
			} else {
				ZeroMemory( m_szFailedPickupDirectory, sizeof( m_szFailedPickupDirectory ) ) ;

				m_cbFailedPickupDirectory =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szFailedPickupDirectory,
						sizeof( m_szFailedPickupDirectory ) / sizeof( m_szFailedPickupDirectory[0] ) ) ;
				m_cbFailedPickupDirectory *= sizeof(WCHAR);

				if (m_szFailedPickupDirectory[lstrlenW(m_szFailedPickupDirectory) - 1] != L'\\')
					lstrcatW(m_szFailedPickupDirectory, L"\\");
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_UUCPNAME ) ) {
			dwSize = MAX_PATH ;
			ZeroMemory( m_szUucpName, sizeof( m_szUucpName ) ) ;
			if( !mb.GetString(	"",
								MD_NNTP_UUCP_NAME,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_cbUucpName =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, m_NntpHubName, m_HubNameSize, m_szUucpName,
						sizeof( m_szUucpName ) / sizeof( m_szUucpName[0] ) ) ;
			} else {
				m_cbUucpName =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szUucpName,
						sizeof( m_szUucpName ) / sizeof( m_szUucpName[0] ) ) ;
			}
			m_cbUucpName *= sizeof(WCHAR);
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_DEFAULTMODERATOR ) ) {
			dwSize = MAX_MODERATOR_NAME ;
			if( !mb.GetString(	"",
								MD_DEFAULT_MODERATOR,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_szDefaultModerator[0] = (WCHAR)0;
				m_cbDefaultModerator = sizeof(WCHAR);
			} else {
				m_cbDefaultModerator =
					MultiByteToWideChar(	CP_ACP, MB_PRECOMPOSED, data, dwSize, m_szDefaultModerator,
						sizeof( m_szDefaultModerator ) / sizeof( m_szDefaultModerator[0] ) ) ;
				m_cbDefaultModerator *= sizeof(WCHAR);
			}
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_UUCPNAME ) ) {

    		//
	    	// Get the name of the master
	    	// Pickup MB notification only if in no-posting mode !
	    	// The hub name is used in the posting path for the path hdr etc
		    //

		    if( (!FAllowClientPosts() && !FAllowFeedPosts()) ||
		        (FieldsToRead == FC_NNTP_ALL) ) {

    		    // default !
        		lstrcpy(m_NntpHubName, m_NntpDNSName ) ;
	        	dwSize = 1024 ;
		        if( mb.GetString(	"",
			        				MD_NNTP_UUCP_NAME,
				        			IIS_MD_UT_SERVER,
					        		data,
						        	&dwSize  ) )
        		{
	        		if( data[0] != '\0' ) {
		        		lstrcpy(m_NntpHubName, data);
			        }
		        }

    		    m_HubNameSize = lstrlen(m_NntpHubName);

        		DO_DEBUG(REGISTRY) {
	        		DebugTrace(0,"Hubname set to %s\n", m_NntpHubName);
		        }
	        }
		}

		if( IsFieldSet( FieldsToRead, FC_NNTP_DISABLE_NEWNEWS ) ) {
			if ( !mb.GetDword( "",
							   MD_DISABLE_NEWNEWS,
							   IIS_MD_UT_SERVER,
							   &dw ) )
			{
		        //	Default should already be set !
		        m_fNewnewsAllowed = FALSE ;
			} else {
				m_fNewnewsAllowed = dw ? FALSE : TRUE ;
			}
		}

		//
		//	Get the vroot depth level - default is 2
		//

    	if( !mb.GetDword( 	"",
            		     	MD_LEVELS_TO_SCAN,
		                 	IIS_MD_UT_SERVER,
                		 	&m_dwLevelsToScan
		                 	) )
		{
			m_dwLevelsToScan = INETA_DEF_LEVELS_TO_SCAN ;
		}

		//	TODO: define a bit mask if this param can be changed on the fly
		if( FieldsToRead == FC_NNTP_ALL ) {
			dwSize = sizeof(m_ListFileName) -sizeof("\\\\?\\") + 1 ;
    			lstrcpy( m_ListFileName, "\\\\?\\" ) ;
			if( !mb.GetString(	"",
								MD_LIST_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				// default !
				lstrcat(m_ListFileName, NNTP_DEF_LISTFILE);
			} else {
				lstrcat(m_ListFileName, data);
			}

			DO_DEBUG(REGISTRY) {
				DebugTrace(0,"List file set to %s\n",m_ListFileName);
			}

			dwSize = sizeof(m_ArticleTableFile) ;
			if( !mb.GetString(	"",
								MD_ARTICLE_TABLE_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpyn( m_ArticleTableFile, data, sizeof(m_ArticleTableFile)) ;
			}

			dwSize = sizeof(m_HistoryTableFile) ;
			if( !mb.GetString(	"",
								MD_HISTORY_TABLE_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpyn( m_HistoryTableFile, data, sizeof(m_HistoryTableFile) ) ;
			}

			dwSize = sizeof(m_XoverTableFile) ;
			if( !mb.GetString(	"",
								MD_XOVER_TABLE_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpyn( m_XoverTableFile, data, sizeof(m_XoverTableFile) ) ;
			}

			dwSize = sizeof(m_GroupListFile) ;
			if( !mb.GetString(	"",
								MD_GROUP_LIST_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpyn( m_GroupListFile, data, sizeof(m_GroupListFile) ) ;
	                SetGroupListBakTmpPath();
			}

			dwSize = sizeof(m_GroupVarListFile) ;
			if( !mb.GetString(	"",
								MD_GROUPVAR_LIST_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	This is a hack to make groupvar.lst path the same as group.lst
				//  This should be taken out once we can configure virtual instances
				//  using rserver.vbs
				//
				strcpy( m_GroupVarListFile, m_GroupListFile );
				LPSTR lpstrPtr = m_GroupVarListFile + strlen( m_GroupVarListFile );
				int cbLeft = sizeof (m_GroupVarListFile) - strlen (m_GroupVarListFile) - 1;
				while( lpstrPtr != m_GroupVarListFile && *lpstrPtr != '\\' )
					{ lpstrPtr--; cbLeft ++;}
				lstrcpyn( lpstrPtr + 1, "groupvar.lst", cbLeft );
			} else {
				lstrcpyn( m_GroupVarListFile, data, sizeof(m_GroupVarListFile) ) ;
                //SetGroupListBakTmpPath();
			}

			dwSize = sizeof(m_GroupHelpFile) ;
			if( !mb.GetString(	"",
								MD_GROUP_HELP_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpyn( m_GroupHelpFile, data, sizeof(m_GroupHelpFile) ) ;
			}

			dwSize = sizeof(m_ModeratorFile) ;
			if( !mb.GetString(	"",
								MD_MODERATOR_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpyn( m_ModeratorFile, data, sizeof(m_ModeratorFile)) ;
			}

			dwSize = sizeof(m_PrettynamesFile) ;
			if( !mb.GetString(	"",
								MD_PRETTYNAMES_FILE,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpyn( m_PrettynamesFile, data, sizeof(m_PrettynamesFile) ) ;
			}

			dwSize = sizeof(m_szDropDirectory) ;
			if( !mb.GetString(	"",
								MD_DROP_DIRECTORY,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				//
				//	There should already be a default set up before we are called !
				//
			} else {
				lstrcpyn( m_szDropDirectory, data, sizeof(m_szDropDirectory)) ;
			}

			dwSize = MAX_MODERATOR_NAME ;
			if( mb.GetString(	"",
								MD_ADMIN_EMAIL,
								IIS_MD_UT_SERVER,
								data,
								&dwSize  ) )
			{
				m_lpAdminEmail =  XNEW char [dwSize];
				if( m_lpAdminEmail ) {
					lstrcpy( m_lpAdminEmail, data );
					m_cbAdminEmail = dwSize;
				}
			}
		}

	} else {

        ErrorTrace(0,"Error opening %s\n", QueryMDPath() );
		UnLockConfigWrite();
        LEAVE
		return FALSE ;
    }

    mb.Close();
    UnLockConfigWrite();

    LEAVE
    return(TRUE);

} // NNTP_SERVER_INSTANCE::ReadPublicNntpParams

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadMappers
//
//  Synopsis:   Read mappers for this instance
//
//  Arguments:  None
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  Notes  :    Instance must be locked before calling this function
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::ReadMappers(
    )
{
    MB      			mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    DWORD               dwR;
    UINT                iM;
    LPVOID              aOldMappers[MT_LAST];
    BOOL                fSt = FALSE;

    LockConfigWrite();

	//
	// get ssl setting
	//

    if ( mb.Open( QueryMDPath() ) )
	{
		if ( !mb.GetDword( "",
						   MD_SSL_ACCESS_PERM,
						   IIS_MD_UT_SERVER,
						   &m_dwSslAccessPerms ) )
		{
			m_dwSslAccessPerms = 0;
		}
		mb.Close();
	}

    //
    // release reference to current mappers
    //

    memcpy( aOldMappers, m_apMappers, MT_LAST*sizeof(LPVOID) );

    for ( iM = 0 ; iM < MT_LAST ; ++iM )
    {
        if ( m_apMappers[iM] )
        {
            ((RefBlob*)(m_apMappers[iM]))->Release();
            m_apMappers[iM] = NULL;
        }
    }

    //
    // Read mappers from Name Space Extension Metabase
    //

    if ( !g_pInetSvc->QueryMDNseObject() )
    {
    	UnLockConfigWrite();
        return FALSE;
    }

    MB                  mbx( (IMDCOM*) g_pInetSvc->QueryMDNseObject() );

    if ( mbx.Open( QueryMDPath() ) )
    {
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_CERT11_PATH,
                           MD_CPP_CERT11,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_CERT11],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_CERT11] = NULL;
        }
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_CERTW_PATH,
                           MD_CPP_CERTW,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_CERTW],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_CERTW] = NULL;
        }
#if 0
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_BASIC_PATH,
                           MD_CPP_ITA,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_ITA],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_ITA] = NULL;
        }
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_DIGEST_PATH,
                           MD_CPP_DIGEST,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_MD5],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_MD5] = NULL;
        }
#endif
        mbx.Close();

        fSt = TRUE;
    }

    //
    // Call notification functions for mappers existence change
    // ( i.e. from non-exist to exist or exist to non-exist )
    //

    if ( (aOldMappers[MT_CERT11] == NULL) != (m_apMappers[MT_CERT11] == NULL)
         && g_pFlushMapperNotify[MT_CERT11] )
    {
        (g_pFlushMapperNotify[MT_CERT11])( SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED, this );
    }

    if ( (aOldMappers[MT_CERTW] == NULL) != (m_apMappers[MT_CERTW] == NULL)
         && g_pFlushMapperNotify[MT_CERTW] )
    {
        (g_pFlushMapperNotify[MT_CERTW])( SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED, this );
    }

#if 0
    if ( (aOldMappers[MT_ITA] == NULL) != (m_apMappers[MT_ITA] == NULL)
         && g_pFlushMapperNotify[MT_ITA] )
    {
        (g_pFlushMapperNotify[MT_ITA])( SF_NOTIFY_MAPPER_ITA_CHANGED, this );
    }

    if ( (aOldMappers[MT_MD5] == NULL) != (m_apMappers[MT_MD5] == NULL)
         && g_pFlushMapperNotify[MT_MD5] )
    {
        (g_pFlushMapperNotify[MT_MD5])( SF_NOTIFY_MAPPER_MD5_CHANGED, this );
    }
#endif

	UnLockConfigWrite();
    return fSt;
}

LPVOID
NNTP_SERVER_INSTANCE::QueryMapper(
    MAPPER_TYPE mt
    )
/*++

   Description

       Returns mapper

   Arguments:

       mt - mapper type

   Returns:

       ptr to Blob referencing mapper or NULL if no such mapper

--*/
{
    LPVOID pV;

    LockConfigRead();

    if ( pV = m_apMappers[(UINT)mt] )
    {
        ((RefBlob*)pV)->AddRef();
    }
    else
    {
        pV = NULL;
    }

    UnLockConfigRead();

    return pV;
}

BOOL
SetFlushMapperNotify(
    DWORD nt,
    PFN_SF_NOTIFY pFn
    )
/*++

   Description

       Set the function called to notify that a mapper is being flushed
       Can be called only once for a given mapper type

   Arguments:

       nt - notification type
       pFn - function to call to notify mapper flushed

   Returns:

       TRUE if function reference stored, FALSE otherwise

--*/
{
    MAPPER_TYPE mt;

    switch ( nt )
    {
#if 0
        case SF_NOTIFY_MAPPER_MD5_CHANGED:
            mt = MT_MD5;
            break;

        case SF_NOTIFY_MAPPER_ITA_CHANGED:
            mt = MT_ITA;
            break;
#endif
        case SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED:
            mt = MT_CERT11;
            break;

        case SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED:
            mt = MT_CERTW;
            break;

        default:
            return FALSE;
    }

    if ( g_pFlushMapperNotify[(UINT)mt] == NULL || pFn == NULL )
    {
        g_pFlushMapperNotify[(UINT)mt] = pFn;
        return TRUE;
    }

    return FALSE;
}


BOOL
SetSllKeysNotify(
    PFN_SF_NOTIFY pFn
    )
/*++

   Description

       Set the function called to notify SSL keys have changed
       Can be called only once

   Arguments:

       pFn - function to call to notify SSL keys change

   Returns:

       TRUE if function reference stored, FALSE otherwise

--*/
{
    if ( g_pSslKeysNotify == NULL || pFn == NULL )
    {
        g_pSslKeysNotify = pFn;
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadAuthentInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::ReadAuthentInfo(
    IN BOOL ReadAll,
    IN DWORD SingleItemToRead,
	IN BOOL Notify
    )
/*++

    Reads per-instance authentication info from the metabase.

    Arguments:

        ReadAll - If TRUE, then all authentication related items are
            read from the metabase. If FALSE, then only a single item
            is read.

        SingleItemToRead - The single authentication item to read if
            ReadAll is FALSE. Ignored if ReadAll is TRUE.

		Notify - If TRUE, this is a MB notification

    Returns:

        DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD tmp;
    DWORD err = NO_ERROR;
    BOOL rebuildAcctDesc = FALSE;
	TCP_AUTHENT_INFO* pTcpAuthentInfo = NULL;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

	TraceFunctEnter("NNTP_SERVER_INSTANCE::ReadAuthentInfo");

    //
    // Lock our configuration (since we'll presumably be making changes)
    // and open the metabase.
    //

    LockConfigWrite();

    if( !mb.Open( QueryMDPath() ) ) {
        err = GetLastError();
        DebugTrace(0,"ReadAuthentInfo: cannot open metabase, error %lx\n",err);
    }

	//
	// Read into one of two copies depending on BOOL switch. This is so
	// we sync with usage of this struct in simauth.
	//
	pTcpAuthentInfo = &m_TcpAuthentInfo ;
	if( Notify && m_fUseOriginal ) {
		pTcpAuthentInfo = &m_TcpAuthentInfo2;
	}


    //
    // Read the "use subauthenticator" flag if necessary. This is an
    // optional property.
    // -- Subauth is no longer supported.  Never allow it

	(pTcpAuthentInfo->fDontUseAnonSubAuth) = TRUE;


    //
    // Read the default logon domain if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_DEFAULT_LOGON_DOMAIN ) ) {

        if( !mb.GetStr(
                "",
                MD_DEFAULT_LOGON_DOMAIN,
                IIS_MD_UT_SERVER,
                &(pTcpAuthentInfo->strDefaultLogonDomain)
                ) ) {

            //
            // Generate a default domain name.
            //

            err = GetDefaultDomainName( &(pTcpAuthentInfo->strDefaultLogonDomain) );

            if( err != NO_ERROR ) {

                DebugTrace(0,"ReadAuthentInfo: cannot get default domain name, error %d\n",err);

            }

        }

    }

    //
    // Read the logon method if necessary. This is an optional property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_LOGON_METHOD ) ) {

        if( !mb.GetDword(
                "",
                MD_LOGON_METHOD,
                IIS_MD_UT_SERVER,
                &tmp
                ) || (LOGON32_LOGON_INTERACTIVE == tmp) ) {

            tmp = DEFAULT_LOGON_METHOD;

        }

        pTcpAuthentInfo->dwLogonMethod = tmp;

    }

    //
    // If anything changed that could affect the anonymous account
    // descriptor, then rebuild the descriptor.
    //

    if( err == NO_ERROR && rebuildAcctDesc ) {

        if( !BuildAnonymousAcctDesc( pTcpAuthentInfo ) ) {

            DebugTrace(0,"ReadAuthentInfo: BuildAnonymousAcctDesc() failed\n");
            err = ERROR_NOT_ENOUGH_MEMORY;  // SWAG

        }

    }

	//
	//	ok, done updating the copy - pull the switch
	//
	if( Notify ) {
		m_fUseOriginal = !m_fUseOriginal ;
	}

    UnLockConfigWrite();
    return err;

}   // NNTP_SERVER_INSTANCE::ReadAuthentInfo

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::MDChangeNotify
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

VOID
NNTP_SERVER_INSTANCE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this instance

  Arguments:

    pcoChangeList - path and id that has changed

--*/
{
    FIELD_CONTROL control = 0;
    DWORD i;
    DWORD err;
    DWORD id;
    BOOL  fUpdateVroot = FALSE;
    BOOL  fReadMappers = FALSE;
    DWORD dwFeedID;
    BOOL  fSslModified = FALSE;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::MDChangeNotify");

    //
    // Let the parent deal with it.
    //

    IIS_SERVER_INSTANCE::MDChangeNotify( pcoChangeList );

    //
    //  The instance needs to be started !
    //

    if( QueryServerState() != MD_SERVER_STATE_STARTED ) {
        return;
    }


    //
    // Interpret the changes.
    //

    for( i = 0 ; i < pcoChangeList->dwMDNumDataIDs ; i++ ) {

        id = pcoChangeList->pdwMDDataIDs[i];

        switch( id ) {

        case MD_ALLOW_CLIENT_POSTS :
        case MD_ALLOW_FEED_POSTS :
            control |= FC_NNTP_POSTINGMODES;
            break;

        case MD_CLIENT_POST_SOFT_LIMIT :
        case MD_CLIENT_POST_HARD_LIMIT :
            control |= FC_NNTP_POSTLIMITS;
            break;

        case MD_FEED_POST_SOFT_LIMIT :
        case MD_FEED_POST_HARD_LIMIT :
            control |= FC_NNTP_FEEDLIMITS;
            break;

        case MD_ALLOW_CONTROL_MSGS :
            control |= FC_NNTP_CONTROLSMSGS;
            break;

        case MD_SMTP_SERVER :
            control |= FC_NNTP_SMTPADDRESS;
            break;

        case MD_NNTP_UUCP_NAME :
            control |= FC_NNTP_UUCPNAME;
            break;

        case MD_DISABLE_NEWNEWS :
            control |= FC_NNTP_DISABLE_NEWNEWS;
            break;

        case MD_DEFAULT_MODERATOR :
            control |= FC_NNTP_DEFAULTMODERATOR;
            break;

        case MD_AUTHORIZATION :
            control |= FC_NNTP_AUTHORIZATION;
            break;

        case MD_NTAUTHENTICATION_PROVIDERS :
            control |= FC_NTAUTHENTICATION_PROVIDERS;
            break;

		case MD_NNTP_CLEARTEXT_AUTH_PROVIDER:
            control |= FC_NNTP_CLEARTEXT_AUTH_PROVIDER;
            break;

		case MD_MD_SERVER_SS_AUTH_MAPPING:
            control |= FC_MD_SERVER_SS_AUTH_MAPPING;
            break;

        case MD_IP_SEC :
            ReadIpSecList();
            break;

        case MD_IS_CONTENT_INDEXED:
            fUpdateVroot = TRUE;
            break;

        case MD_ACCESS_PERM :
        case MD_SSL_ACCESS_PERM :
       		if ( !_strnicmp( (const char*)pcoChangeList->pszMDPath,
							 QueryMDVRPath(), lstrlen(QueryMDVRPath()) ) ) {
            	fUpdateVroot = TRUE;
           	} else if( !_strnicmp( (const char*)pcoChangeList->pszMDPath,
        							QueryMDPath(), lstrlen(QueryMDPath()) ) ) {
        		fReadMappers = TRUE;
       		}
       		break;

#if 0
        case MD_ALLOW_ANONYMOUS :
            control |= FC_NNTP_ALLOW_ANONYMOUS;
            break;

        case MD_ANONYMOUS_ONLY :
            control |= FC_NNTP_ANONYMOUS_ONLY;
            break;
#endif

        case MD_ANONYMOUS_USER_NAME :
        case MD_ANONYMOUS_PWD :
        case MD_ANONYMOUS_USE_SUBAUTH :
        case MD_DEFAULT_LOGON_DOMAIN :
        case MD_LOGON_METHOD :
            err = ReadAuthentInfo( TRUE, id, TRUE );

            if( err != NO_ERROR ) {

                DebugTrace(
					0,
					"NNTP_SERVER_INSTANCE::MDChangeNotify() cannot read authentication info, error %d",
                    err
                    );
            }
            break;

        case MD_SSL_CERT_HASH:
        case MD_SSL_CERT_CONTAINER:
        case MD_SSL_CERT_PROVIDER:
        case MD_SSL_CERT_OPEN_FLAGS:
        case MD_SSL_CERT_STORE_NAME:
        case MD_SSL_CTL_IDENTIFIER:
        case MD_SSL_CTL_CONTAINER:
        case MD_SSL_CTL_PROVIDER:
        case MD_SSL_CTL_PROVIDER_TYPE:
        case MD_SSL_CTL_OPEN_FLAGS:
        case MD_SSL_CTL_STORE_NAME:
		case MD_SSL_CTL_SIGNER_HASH:
		case MD_SSL_USE_DS_MAPPER:
            fSslModified = TRUE;
            break;
        }
    }

    //
    // If anything related to SSL has changed, call the function used to flush
    // the SSL / Schannel credential cache and reset the server certificate
    //
    if ( fSslModified && g_pSslKeysNotify ) {
        (g_pSslKeysNotify) ( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED, this );
        ResetSSLInfo( this );
    }

    if( control != 0 ) {
        if( !ReadPublicNntpParams( control ) ) {
            DebugTrace(0,"NNTP_SERVER_INSTANCE::MDChangeNotify() cannot read config");
        }
    }

    if( fUpdateVroot ) {
		// received reg change notification on virtual root update -
		// update all newsgroups
		// LATER - since we have the vroot path, we should be able
		// to do the update only for groups that match this path...
        _ASSERT( m_pTree );
        // this call is doing nothing, take out
		//m_pTree->UpdateVrootInfo() ;

#ifdef DEBUG
        NntpLogEvent( NNTP_EVENT_VROOT_UPDATED, 0, (const CHAR**)NULL, 0 );
#endif
    }

    if( fReadMappers ) {
    	ReadMappers();
   	}

    //
    // Here handles the feed config change notification
    //
    if ( VerifyFeedPath( ( LPSTR ) (pcoChangeList->pszMDPath), &dwFeedID ) &&
         IsNotMyChange( ( LPSTR ) (pcoChangeList->pszMDPath ) , pcoChangeList->dwMDChangeType ) )
        UpdateFeed( pcoChangeList, dwFeedID );
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ReadIpSecList
//
//  Synopsis:   read ip sec info from metabase
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::ReadIpSecList(void)
{
	IMDCOM*             pMBCom;
	METADATA_HANDLE     hMB;
	HRESULT             hRes;
	METADATA_RECORD     mdRecord;
	DWORD               dwRequiredLen;
	DWORD				dwErr;
	//BOOL                fMustRel;
	BOOL				fSuccess;

	m_rfAccessCheck.Reset( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    pMBCom = (IMDCOM*)g_pInetSvc->QueryMDObject();
    hRes = pMBCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                        (BYTE *) QueryMDPath(),
                                        METADATA_PERMISSION_READ,
                                        5000,
                                        &hMB );
    if ( SUCCEEDED( hRes ) )
     {
            mdRecord.dwMDIdentifier  = MD_IP_SEC;
            mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_REFERENCE;
            mdRecord.dwMDUserType    = IIS_MD_UT_FILE;
            mdRecord.dwMDDataType    = BINARY_METADATA;
            mdRecord.dwMDDataLen     = 0;
            mdRecord.pbMDData        = (PBYTE)NULL;

            hRes = pMBCom->ComMDGetMetaData( hMB,
                                             (LPBYTE)"",
                                             &mdRecord,
                                             &dwRequiredLen );
            if ( SUCCEEDED( hRes ) && mdRecord.dwMDDataTag )
            {
                m_rfAccessCheck.Set( mdRecord.pbMDData,
                                     mdRecord.dwMDDataLen,
                                     mdRecord.dwMDDataTag );
            }

            _VERIFY( SUCCEEDED(pMBCom->ComMDCloseMetaObject( hMB )) );
     }
     else
     {
            fSuccess = FALSE;
            dwErr = HRESULTTOWIN32( hRes );
     }

	 return TRUE;

}

DWORD
NNTP_SERVER_INSTANCE::GetCurrentSessionCount()
{
	return m_pInUseList->GetListCount() ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::LookupVirtualRoot
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::LookupVirtualRoot(
    IN     const CHAR *       pszRoot,
    OUT    CHAR *             pszDirectory,
    IN OUT LPDWORD            lpcbSize,
    OUT    LPDWORD            lpdwAccessMask,
    OUT    LPDWORD            pcchDirRoot,
    OUT    LPDWORD            pcchVroot,
    OUT    HANDLE*            phImpersonationToken,
    IN     const CHAR *       pszAddress,
    OUT    LPDWORD            lpdwFileSystem,
    IN	   VrootPropertyAddon* pvpaBlob
    )   {
/*++

Routine Description :

    Wrap the call to the Gibraltar virtual root stuff - we hide the GetTsvcCache() code etc...
    from the rest of the server.  Otherwise, we have the same interface as Gibraltar
    provides for virtual roots.

Arguments :
    pszRoot - Path to lookup
    pszDirectory - resolved path
    lpcbSize - IN/OUT resolved path length
    lpdwAccessMask - Access to allow to directory


Return Value :
    TRUE if successfull, FALSE otherwise.

--*/

	BOOL  fRet = TRUE;
	LPSTR lpstrNewRoot;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::LookupVirtualRoot");

	//
	// find the vroot object
	//
	NNTPVROOTPTR pVRoot;

	_ASSERT(m_pVRootTable != NULL);
	HRESULT hr = m_pVRootTable->FindVRoot(pszRoot, &pVRoot);
	_ASSERT(pVRoot != NULL);
	_ASSERT(hr == S_OK);

	_ASSERT(*lpcbSize != NULL);
	hr = pVRoot->MapGroupToPath(pszRoot, pszDirectory, *lpcbSize, pcchDirRoot,
								pcchVroot);
	_ASSERT(SUCCEEDED(hr));
	if (SUCCEEDED(hr)) {
		*lpcbSize = lstrlen(pszDirectory);
		if (lpdwAccessMask != NULL) *lpdwAccessMask = pVRoot->GetAccessMask();
		if (lpdwFileSystem != NULL) *lpdwFileSystem = FS_FAT;
		if (pvpaBlob != NULL) {
			pvpaBlob->fChanged = TRUE;
			pvpaBlob->dwSslAccessMask = pVRoot->GetSSLAccessMask();
			pvpaBlob->dwContentIndexFlag = pVRoot->IsContentIndexed();
		}
	}

	if (SUCCEEDED(hr)) return TRUE; else return FALSE;

}


//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::TsEnumVirtualRoots
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::TsEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext
    )
{
    MB              mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    if ( !mb.Open( QueryMDPath(),
               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        return FALSE;
    }

    return TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    IIS_MD_INSTANCE_ROOT "/",
                    m_dwLevelsToScan,
                    (LPVOID)&mb,
                    TRUE );
}


BOOL
NNTP_SERVER_INSTANCE::TsRecursiveEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext,
    LPSTR       pszCurrentPath,
    DWORD       dwLevelsToScan,
    LPVOID      pvMB,
    BOOL        fGetRoot
    )
/*++
    Description:

        Enumerates all of the virtual directories defined for this server
        instance

    Arguments:
        pfnCallback - Enumeration callback to call for each virtual directory
        pvContext - Context pfnCallback receives
        pszCurrentPath - path where to start scanning for VRoots
        dwLevelsToScan - # of levels to scan recursively for vroots
        pvMB - ptr to MB to access metabase. Is LPVOID to avoid having to include
               mb.hxx before any ref to iistypes.hxx
        fGetRoot - TRUE if pszCurrentPath is to be considered as vroot to process

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    DWORD           err;
    MB*             pMB = (MB*)pvMB;

    DWORD           dwMask;
    CHAR            szUser[UNLEN+1];
    CHAR            szPassword[PWLEN+1];
    CHAR            szDirectory[MAX_PATH + UNLEN + 3];
    DWORD           cb;

    CHAR            nameBuf[METADATA_MAX_NAME_LEN+2];
    CHAR            tmpBuf[sizeof(nameBuf)];

    DWORD           cbCurrentPath;
    VIRTUAL_ROOT    vr;
    DWORD           i = 0;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::TsRecursiveEnumVirtualRoots");

    //
    //  Enumerate all of the listed items in the metabase
    //  and add them
    //

    cbCurrentPath = strlen( pszCurrentPath );
    CopyMemory( nameBuf, pszCurrentPath, cbCurrentPath + 1);

    while ( TRUE ) {

        //METADATA_RECORD mdRecord;
        DWORD  dwFileSystem = FS_ERROR;

        err = NO_ERROR;

        if ( fGetRoot ) {

            fGetRoot = FALSE;

        } else {

            if ( !pMB->EnumObjects( pszCurrentPath,
                                  nameBuf + cbCurrentPath,
                                  i++ ))
            {
                break;
            }

            if ( dwLevelsToScan > 1 )
            {
                cb = strlen( nameBuf );
                nameBuf[ cb ] = '/';
                nameBuf[ cb + 1 ] = '\0';

                if ( !TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    nameBuf,
                    dwLevelsToScan - 1,
                    pMB,
                    FALSE ) )
                {
                    return FALSE;
                }

                nameBuf[ cb ] = '\0';
            }
        }

        //
        // Get Directory path
        //

        cb = sizeof( szDirectory );

        if ( !pMB->GetString( nameBuf,
                            MD_VR_PATH,
                            IIS_MD_UT_FILE,
                            szDirectory,
                            &cb,
                            0 ))
        {
            DebugTrace(0,"Error %x reading path from %s. Not a VR.\n",
                      GetLastError(), nameBuf);
            continue;
        }

        //
        // Get mask
        //

        if ( !pMB->GetDword( nameBuf,
                           MD_ACCESS_PERM,
                           IIS_MD_UT_FILE,
                           &dwMask,
                           0))
        {
            dwMask = VROOT_MASK_READ;

            DebugTrace(0,"Error %x reading mask from %s\n",
                  GetLastError(), nameBuf);
        }

        //
        // Get username
        //

        cb = sizeof( szUser );

        if ( !pMB->GetString( nameBuf,
                            MD_VR_USERNAME,
                            IIS_MD_UT_FILE,
                            szUser,
                            &cb,
                            0))
        {
//            DBGPRINTF((DBG_CONTEXT,"Error %d reading path from %s\n",
//                      GetLastError(), nameBuf));

            szUser[0] = '\0';
        }

        DebugTrace(0,"Reading %s: Path[%s] User[%s] Mask[%d]\n",
                  nameBuf, szDirectory, szUser, dwMask);

        if ( (szUser[0] != '\0') &&
             (szDirectory[0] == '\\') && (szDirectory[1] == '\\') ) {

            cb = sizeof( szPassword );

            //
            //  Retrieve the password for this address/share
            //

            if ( !pMB->GetString( nameBuf,
                                MD_VR_PASSWORD,
                                IIS_MD_UT_FILE,
                                szPassword,
                                &cb,
                                METADATA_SECURE))
            {
                DebugTrace(0,"Error %d reading path from %s\n",
                          GetLastError(), nameBuf);

                szPassword[0] = '\0';
            }
        }
        else
        {
            szPassword[0] = '\0';
        }

        //
        //  Now set things up for the callback
        //

        _ASSERT( !_strnicmp( nameBuf, IIS_MD_INSTANCE_ROOT, sizeof(IIS_MD_INSTANCE_ROOT) - 1));

        //
        //  Add can modify the root - don't modify the working
        //  vroot path
        //

        strcpy( tmpBuf, nameBuf );

        vr.pszAlias     = tmpBuf + sizeof(IIS_MD_INSTANCE_ROOT) - 1;
        vr.pszMetaPath  = tmpBuf;
        vr.pszPath      = szDirectory;
        vr.dwAccessPerm = dwMask;
        vr.pszUserName  = szUser;
        vr.pszPassword  = szPassword;

		if( m_BootOptions ) {
			m_BootOptions->ReportPrint("Scanning virtual root %s Physical Path %s\n",
							vr.pszAlias, vr.pszPath);
		}

        if ( !pfnCallback( pvContext, pMB, &vr ))
        {
            //
            // !!! so what do we do here?
            //

            DebugTrace(0,"EnumCallback returns FALSE\n");
            if( m_BootOptions ) {
				m_BootOptions->ReportPrint("Failed to scan vroot %s Path %s: error is %d\n",
								vr.pszAlias, vr.pszPath, GetLastError());
            }
        }

    } // while

    return TRUE;

} // Enum

BOOL
NNTP_SERVER_INSTANCE::ClearStatistics()
{
    LockStatistics( this );
    ZeroMemory((PVOID)&m_NntpStats, sizeof(NNTP_STATISTICS_0));
    m_NntpStats.TimeOfLastClear = NntpGetTime( );
    UnlockStatistics( this );
    return TRUE;

} // ClearStatistics

BOOL
NNTP_SERVER_INSTANCE::SetProviderPackages()
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetProviderPackages" );

	LPSTR	psz;
	DWORD	i;

	PAUTH_BLOCK	pBlock = NULL;

    if ( m_ProviderNames == NULL || m_cProviderPackages == 0)
	{
		ErrorTrace((LPARAM)this, "Invalid Parameters: 0x%08X, %d",
			m_ProviderNames, m_cProviderPackages );
		return FALSE;
    }

	pBlock = (PAUTH_BLOCK)LocalAlloc(0, m_cProviderPackages * sizeof(AUTH_BLOCK));
	if (pBlock == NULL)
	{
		ErrorTrace( 0, "AUTH_BLOCK LocalAlloc failed: %d", GetLastError() );
		return FALSE;
	}

	//
	// start at 1 since 0 indicates the Invalid protocol
	//
	for ( i=0, psz = (LPSTR)m_ProviderNames; i< m_cProviderPackages; i++ )
	{
		//
		// this would be the place to check whether the package was valid
		//
		DebugTrace( 0, "Protocol: %s", psz);

		pBlock[i].Name = psz;

		psz += lstrlen(psz) + 1;
	}

	//
	// if we're replacing already set packages; free their memory
	//
    if (m_ProviderPackages != NULL )
	{
        LocalFree((PVOID)m_ProviderPackages );
        m_ProviderPackages = NULL;
    }
	m_ProviderPackages = pBlock;

	return	TRUE;

} // SetAuthPackageNames


//+---------------------------------------------------------------
//
//  Function:  NNTP_SERVER_INSTANCE::GetPostsAllowed
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

LPSTR
NNTP_SERVER_INSTANCE::GetPostsAllowed(
                DWORD&  cb
                )
/*++

Routine description :

    Get the connection string to send to clients whom we are not going to
    allow to post.

Arguments :

    cb - out parameter to get the number of bytes in the string

Return Value :

    Pointer to the string !

--*/
{
    cb = 0 ;
    if( m_cbPostsAllowed != 0 ) {
        cb = m_cbPostsAllowed ;
        return  m_szPostsAllowed ;
    }
    return  0 ;
}

//+---------------------------------------------------------------
//
//  Function: NNTP_SERVER_INSTANCE::GetPostsNotAllowed
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

LPSTR
NNTP_SERVER_INSTANCE::GetPostsNotAllowed(
                        DWORD&  cb
                        )
/*++

Routine Description :

    Get the connection string to send to clients whom we are going to allow
    to post.

Arguments :

    cb - An out parameter to get the number of bytes in the greeting string.

Return Value :

    Pointer to the connection string.

--*/
{
    cb = 0 ;
    if( m_cbPostsNotAllowed != 0 ) {
        cb = m_cbPostsNotAllowed ;
        return  m_szPostsNotAllowed ;
    }
    return  0 ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetPostingModes
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetPostingModes(
		MB&		mb,
        BOOL    AllowClientPosts,
        BOOL    AllowFeedPosts,
        BOOL    fSaveSettings
        )
/*++

Routine Description :

    Save the posting modes for the server to the registry and modify
    the current settings for the posting modes.

Arguments :
    AllowClientPosts - TRUE means allow clients to post
    AllowFeedPosts - TRUE means allow feeds to post
    fSaveSettings - TRUE means modify the registry.

Return Value :
    TRUE    if saved successfully (if a registry error occurs
        the mode is still changed but the change won't be picked up on
        the next reboot !)
    FALSE - error occurred

--*/
{
    BOOL    fRtn = TRUE ;

    if( AllowClientPosts ||
        AllowFeedPosts ) {

        if( !   (m_pArticleTable->IsActive() &&
                 m_pHistoryTable->IsActive() &&
                 m_pXoverTable->IsActive()) ) {
            SetLastError( ERROR_DISK_FULL ) ;
            return  FALSE ;
        }
    }

    m_fAllowClientPosts = AllowClientPosts ;
    m_fAllowFeedPosts = AllowFeedPosts ;

    DWORD   dwData = m_fAllowClientPosts ;
    if ( fSaveSettings && !mb.SetDword( "",
                                        MD_ALLOW_CLIENT_POSTS,
                                        IIS_MD_UT_SERVER,
                                        dwData ) )
    {
        fRtn = FALSE ;
    }

    dwData = m_fAllowFeedPosts ;
    if ( fSaveSettings && !mb.SetDword( "",
                                        MD_ALLOW_FEED_POSTS,
                                        IIS_MD_UT_SERVER,
                                        dwData ) )
    {
        fRtn = FALSE ;
    }

    return  fRtn ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetPostingLimits
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetPostingLimits(
		MB&		mb,
        DWORD   cbHardLimit,
        DWORD   cbSoftLimit
        )
/*++

Routine Description :

    Set the limits on the size of postings the server will set, and save
    these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    cbHardLimit - Number of bytes the server will take before breaking the session
    cbSoftLimit - Largest post the server will take

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    BOOL    fRtn = TRUE ;

    m_cbHardLimit = cbHardLimit ;
    m_cbSoftLimit = cbSoftLimit ;

    DWORD   dwData = m_cbHardLimit;
    if ( !mb.SetDword( "",
						MD_CLIENT_POST_HARD_LIMIT,
						IIS_MD_UT_SERVER,
						dwData ) )
    {
        fRtn = FALSE ;
	}

    dwData = m_cbSoftLimit ;
    if ( !mb.SetDword( "",
						MD_CLIENT_POST_SOFT_LIMIT,
						IIS_MD_UT_SERVER,
						dwData ) )
    {
        fRtn = FALSE ;
	}

    return  fRtn ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetControlMessages
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetControlMessages(
		MB&		mb,
        BOOL    fControlMessages
        )
/*++

Routine Description :

    Sets the Boolean indicating whether control messages are processed and
    these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    fControlMessages - allow control messages

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    BOOL    fRtn = TRUE ;

    m_fAllowControlMessages = fControlMessages ;

    DWORD   dwData = m_fAllowControlMessages;
	if ( !mb.SetDword( "",
						MD_ALLOW_CONTROL_MSGS,
						IIS_MD_UT_SERVER,
						dwData ) )
	{
		fRtn = FALSE ;
	}

    return  fRtn ;
}

//+---------------------------------------------------------------
//
//  Function:  NNTP_SERVER_INSTANCE::SetFeedLimits
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------


BOOL
NNTP_SERVER_INSTANCE::SetFeedLimits(
		MB&		mb,
        DWORD   cbHardLimit,
        DWORD   cbSoftLimit
        )
/*++

Routine Description :

    Set the limits on the size of postings FROM A FEED the server will accept, and save
    these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    cbHardLimit - Number of bytes the server will take before breaking the session
    cbSoftLimit - Largest post the server will take

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    BOOL    fRtn = TRUE ;

    m_cbFeedHardLimit = cbHardLimit ;
    m_cbFeedSoftLimit = cbSoftLimit ;

    DWORD   dwData = m_cbFeedHardLimit;
	if ( !mb.SetDword( "",
						MD_FEED_POST_HARD_LIMIT,
						IIS_MD_UT_SERVER,
						dwData ) )
	{
		fRtn = FALSE ;
	}

    dwData = m_cbFeedSoftLimit ;
	if ( !mb.SetDword( "",
						MD_FEED_POST_SOFT_LIMIT,
						IIS_MD_UT_SERVER,
						dwData ) )
	{
		fRtn = FALSE ;
	}

    return  fRtn ;
}


//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetSmtpAddress
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetSmtpAddress(
		MB&		mb,
        LPWSTR  pszSmtpAddress
        )
/*++

Routine Description :

    Set the name of the SMTP server to send moderated newsgroup postings to
    and write these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszSmtpAddress - DNS name or stringized IP address of the SMTP server

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetSmtpAddress" );

    BOOL    fRtn = TRUE ;
    DWORD   cbAddress;
	CHAR	szSmtpAddressA [MAX_PATH+1];

    if ( pszSmtpAddress == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    cbAddress = lstrlenW( pszSmtpAddress ) + 1;
    cbAddress *= sizeof(WCHAR);
    if ( cbAddress > sizeof( m_szSmtpAddress ) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    LockConfigWrite();

    CopyMemory( m_szSmtpAddress, pszSmtpAddress, cbAddress );
    m_cbSmtpAddress = cbAddress;

    UnLockConfigWrite();

    // signal the moderated provider interface about the change
    SignalSmtpServerChange();

	CopyUnicodeStringIntoAscii( szSmtpAddressA, m_szSmtpAddress );
	if ( !mb.SetString( "",
						MD_SMTP_SERVER,
						IIS_MD_UT_SERVER,
						szSmtpAddressA ) )
	{
        ErrorTrace( (LPARAM)this,
                    "SetString failed: %d",
                    GetLastError() );
        return  FALSE;
	}

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::SetUucpName
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetUucpName(
		MB&     mb,
        LPWSTR  pszUucpName
        )
/*++

Routine Description :

    Set the server's UucpName name and write these values to the
    registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszSmtpAddress - server's UUCP name

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetUucpName" );

    BOOL    fRtn = TRUE ;
    DWORD   cbUucpName;
	CHAR	szUucpNameA [MAX_PATH+1];

    if ( pszUucpName == NULL  || *pszUucpName == '\0' )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    cbUucpName = lstrlenW( pszUucpName ) + 1;
    cbUucpName *= sizeof(WCHAR);
    if ( cbUucpName > sizeof( m_szUucpName ) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    LockConfigWrite();

    CopyMemory( m_szUucpName, pszUucpName, cbUucpName );
    m_cbUucpName = cbUucpName;

    UnLockConfigWrite();

	CopyUnicodeStringIntoAscii( szUucpNameA, m_szUucpName );
	if ( !mb.SetString( "",
						MD_NNTP_UUCP_NAME,
						IIS_MD_UT_SERVER,
						szUucpNameA ) )
	{
        ErrorTrace( (LPARAM)this,
                    "SetString failed: %d",
                    GetLastError() );
        return  FALSE;
	}

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::GetSmtpAddress
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------


BOOL
NNTP_SERVER_INSTANCE::GetSmtpAddress(
        LPSTR   pszSmtpAddress,
        PDWORD  pcbAddress
        )
/*++

Routine Description :

    Set the name of the SMTP server to send moderated newsgroup postings to
    and write these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszSmtpAddress: buffer to receive DNS name or stringized IP address
                    of the SMTP server

    pcbAddress:     max size of buffer to receive DNS name or stringized
                    IP address of the SMTP server and the returned size

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::GetSmtpAddress" );

    BOOL    fRtn = TRUE ;
    //DWORD   cbAddress;

    if ( m_cbSmtpAddress > *pcbAddress )
    {
        *pcbAddress = m_cbSmtpAddress;
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    if ( pszSmtpAddress == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    LockConfigRead();

    if ( m_cbSmtpAddress > sizeof(WCHAR) )
    {
        *pcbAddress = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            m_szSmtpAddress,
                            (int)m_cbSmtpAddress/sizeof(WCHAR),
                            pszSmtpAddress,
                            *pcbAddress,
                            NULL,
                            NULL
                        );
        if ( *pcbAddress == 0 )
        {
            ErrorTrace( (LPARAM)this,
                        "WideCharToMultiByte failed: %d",
                        GetLastError() );
        }
    }
    else
    {
        *pcbAddress = sizeof( "127.0.0.1" );
        CopyMemory( pszSmtpAddress, "127.0.0.1", *pcbAddress );
    }

    UnLockConfigRead();

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:  NNTP_SERVER_INSTANCE::GetUucpName
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::GetUucpName(
        LPSTR   pszUucpName,
        PDWORD  pcbUucpName
        )
/*++

Routine Description :

    Set the services' UUCP name
    and write these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszUucpName:    buffer to receive DNS name or stringized IP address
                    of the SMTP server

    pcbUucpName:    max size of buffer to receive DNS name or stringized
                    IP address of the SMTP server and the returned size

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::GetUucpName" );

    BOOL    fRtn = TRUE ;
    //DWORD   cbUucpName;

    if ( m_cbUucpName > *pcbUucpName )
    {
        *pcbUucpName = m_cbUucpName;
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    if ( pszUucpName == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    LockConfigRead();

    *pcbUucpName = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        m_szUucpName,
                        (int)m_cbUucpName/sizeof(WCHAR),
                        pszUucpName,
                        *pcbUucpName,
                        NULL,
                        NULL
                    );

    if ( *pcbUucpName == 0 )
    {
        ErrorTrace( (LPARAM)this,
                    "WideCharToMultiByte failed: %d",
                    GetLastError() );
    }

    UnLockConfigRead();

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:  NNTP_SERVER_INSTANCE::SetDefaultModerator
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::SetDefaultModerator(
		MB&		mb,
        LPWSTR  pszDefaultModerator
        )
/*++

Routine Description :

    Set the default moderator (email address) for moderated newsgroups
    and write these values to the registry if possible.
    The new values will always take effect, but if an error occurs they
    may not be saved in the registry.

Arguments :
    pszDefaultModerator - default moderator address

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetDefaultModerator" );

    BOOL    fRtn = TRUE ;
    DWORD   cbDefaultModerator;
	CHAR	szDefaultModeratorA [MAX_MODERATOR_NAME+1];

    if ( pszDefaultModerator == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

    cbDefaultModerator = lstrlenW( pszDefaultModerator ) + 1;
    cbDefaultModerator *= sizeof(WCHAR);
    if ( cbDefaultModerator > sizeof( m_szDefaultModerator ) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

    LockConfigWrite();

    CopyMemory( m_szDefaultModerator, pszDefaultModerator, cbDefaultModerator );
    m_cbDefaultModerator = cbDefaultModerator;

    UnLockConfigWrite();

	CopyUnicodeStringIntoAscii( szDefaultModeratorA, m_szDefaultModerator );
	if ( !mb.SetString( "",
						MD_DEFAULT_MODERATOR,
						IIS_MD_UT_SERVER,
						szDefaultModeratorA ) )
	{
        ErrorTrace( (LPARAM)this,
                    "SetString failed: %d",
                    GetLastError() );
        return  FALSE;
	}

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::GetDefaultModerator
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::GetDefaultModerator(
		LPSTR	pszNewsgroup,
        LPSTR   pszDefaultModerator,
        PDWORD  pcbDefaultModerator
        )
/*++

Routine Description :

    Get the name of the default moderator to send moderated newsgroup postings to.
	default moderator = hiphenated-newsgroup-name@default

Arguments :

	pszNewsgroup:			name of newsgroup
    pszDefaultModerator:	buffer to receive default moderator
    pcbDefaultModerator:    max size of buffer to receive default moderator;
							set to actual size returned.

Return Value :

    TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::GetDefaultModerator" );

    BOOL    fRtn = TRUE ;
    DWORD   cbDefaultModerator;
	DWORD	cbNewsgroup;

    if ( (pszDefaultModerator == NULL) || (pszNewsgroup == NULL) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return  FALSE;
    }

	cbNewsgroup = lstrlen( pszNewsgroup )+1;
	cbDefaultModerator = *pcbDefaultModerator;
    if ( m_cbDefaultModerator+cbNewsgroup+1 > cbDefaultModerator )
    {
        *pcbDefaultModerator = m_cbDefaultModerator+cbNewsgroup+1;
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return  FALSE;
    }

	DWORD i = 0;
	if( !wcschr( m_szDefaultModerator, (WCHAR)'@' ) )
	{
		//
		//	prefix hipehnated-newsgroup-name and @ sign
		//
		PCHAR pch = pszNewsgroup;
		for( i=0; *(pch+i) != '\0'; i++)
		{
			*(pszDefaultModerator+i) = ( *(pch+i) == '.' ) ? '-' : *(pch+i);
		}
		*(pszDefaultModerator+i) = '@';
		i++;
	}

	// null terminate string
	*(pszDefaultModerator+i) = '\0';
	*pcbDefaultModerator = i;

    LockConfigRead();

    if ( m_cbDefaultModerator > sizeof(WCHAR) )
    {
        *pcbDefaultModerator += WideCharToMultiByte(
									CP_ACP,
									0,
									m_szDefaultModerator,
									(int)m_cbDefaultModerator/sizeof(WCHAR),
									pszDefaultModerator+(*pcbDefaultModerator),
									cbDefaultModerator -(*pcbDefaultModerator),
									NULL,
									NULL
									);
        if ( *pcbDefaultModerator == i )
        {
            ErrorTrace( (LPARAM)this,
                        "WideCharToMultiByte failed: %d",
                        GetLastError() );
        }
    }
    else
    {
#if 0
        DWORD cbDefault = sizeof( "uunet.uu.net" );
        CopyMemory( pszDefaultModerator+(*pcbDefaultModerator), "uunet.uu.net", cbDefault);
        *pcbDefaultModerator += cbDefault;
#endif
		// no default configured !
		*pszDefaultModerator = '\0';
		*pcbDefaultModerator = 0;
    }

    UnLockConfigRead();

    return  TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::InitiateConnectionEx
//
//  Synopsis:   Called to resume
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         23 May 1995
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::InitiateConnectionEx(
        void*   patqContext
        )
/*++

Routine Description :

    This function accepts incoming calls from clients that are handled through AcceptEx.

Arguments :

    patqContext - an already allocate ATQ context for the session

Return Value :

    TRUE if we accepted the connection - FALSE otherwise.


--*/
{
    SOCKET  sNew = INVALID_SOCKET ;
    PVOID   pvBuff = 0 ;
    SOCKADDR*   psockaddrLocal = 0 ;
    SOCKADDR*   psockaddrRemote = 0 ;
    PIIS_ENDPOINT pEndpoint;

    AtqGetAcceptExAddrs(
        (PATQ_CONTEXT)patqContext,
        &sNew,
        &pvBuff,
		(PVOID*)&pEndpoint,
        &psockaddrLocal,
        &psockaddrRemote
        );

    return  InitiateConnection( (HANDLE)sNew, (SOCKADDR_IN*)psockaddrRemote,
                                (SOCKADDR_IN*)psockaddrLocal, patqContext,
								pEndpoint->IsSecure() ) ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::InitiateConnection
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::InitiateConnection(
    HANDLE			hSocket,
    SOCKADDR_IN*    psockaddr,
    SOCKADDR_IN*    psockaddrLocal,
    void*			patqContext,
	BOOL			fIsSecure
    )
/*++

Routine Description :

    Create the correct socket and context information for an incoming connection.
    Do so after making sure that the server is in a state to accept calls.

Arguments :

    hSocket - Winsock handle for the socket
    psockaddr - The remote guys IP address
    psockaddrLocal - The IP address the remote guy connected to
    patqContext - Optionally present Atq Context for session
	fIsSecure - Is this an SSL connection ?

Return Value :

    TRUE if successfull and socket accepted
    FALSE otherwise.


--*/
{
    USHORT  incomingPort = 119 ;
    if( psockaddrLocal )
        incomingPort = ntohs( psockaddrLocal->sin_port ) ;

    ENTER("NNTP_SERVER_INSTANCE::InitiateConnection")

    Assert( hSocket != (HANDLE)INVALID_SOCKET ) ;
    Assert( psockaddr != 0 ) ;



    CInFeed * pfeedFromClient = NULL;
    CInFeed * pfeedFromMaster = NULL;
    CInFeed * pfeedFromSlave = NULL;
    CInFeed * pfeedFromPeer = NULL;

    //
    // Create a feed, at most one of the CInFeed parameters will be nonnull.
    // Which one that is, tells the type of feed created.
    //

    CInFeed*    pFeed = pfeedCreateInFeed(
									this,
                                    psockaddr,
                                    psockaddrLocal?(psockaddrLocal->sin_addr.s_addr == psockaddr->sin_addr.s_addr) : FALSE,
                                    pfeedFromClient,
                                    pfeedFromMaster,
                                    pfeedFromSlave,
                                    pfeedFromPeer
                                    );

    if( pFeed ) {

        pFeed->SetLoginName("<feed>");

        DWORD localIP = 0 ;
        if( psockaddrLocal != 0 )
            localIP = psockaddrLocal->sin_addr.s_addr;
        CSessionSocket* pSocket =
            new CSessionSocket( this, localIP, incomingPort, FALSE) ;	// pass this instance to session socket !

        if( pSocket != NULL ) {

            //  Do the IP access check !
            if ( !VerifyClientAccess( pSocket, psockaddr ) ) {
                delete  pSocket ;		// does a Deref on this
                delete  pFeed ;
				ErrorTrace( 0, "connection denied - failed access check" ) ;
				return( FALSE);
            }

            if( pSocket->Accept(    hSocket,    pFeed, psockaddr, patqContext, fIsSecure ) ) {
                DebugTrace( 0, "CSessionSOcket::AcceptSocket succeeded!!" ) ;
                return  TRUE     ;
            }   else    {
                delete  pSocket ;		// does a Deref on this
                delete  pFeed;
				ErrorTrace( 0, "Failed to accept connection" ) ;
				return( FALSE);
            }
        }
    }
    ErrorTrace( 0, "Failed to accept connection" ) ;
	this->DecrementCurrentConnections();
	this->Dereference();
    return( FALSE);
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::InitializeServerStrings
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::InitializeServerStrings( VOID )
{
	BOOL 	fRet = TRUE ;
	PCHAR 	args [1];
	CHAR 	szId [20];
	char	szServerPath[ MAX_PATH ] ;

    CopyMemory( szServerPath, "c:\\", sizeof( "c:\\" ) ) ;
	_itoa( QueryInstanceId(), szId, 10 );
	args [0] = szId;

    m_szSmtpAddress[0] = (WCHAR)0;
    m_cbSmtpAddress = 1;

    m_szUucpName[0] = (WCHAR)0;
    m_cbUucpName = 1;

    HMODULE hModule = GetModuleHandle( NNTP_MODULE_NAME ) ;
    if( hModule != 0 ) {
        //GetModuleFileName truncates string without placing a null terminator at the end.
        szServerPath[ sizeof(szServerPath) -1 ] = '\0';
        if( !GetModuleFileName( hModule, szServerPath, sizeof( szServerPath )-1 ) )   {
            CopyMemory( szServerPath, "c:\\", sizeof( "c:\\" ) ) ;
        }   else    {

            CopyMemory( m_szPostsAllowed, szPostsCode, sizeof( szPostsCode ) ) ;
            CopyMemory( m_szPostsNotAllowed, szNoPostsCode, sizeof( szNoPostsCode ) ) ;

            m_cbPostsAllowed = sizeof( szPostsCode ) + SetVersionStrings(   szServerPath, szTitle,
                    &m_szPostsAllowed[sizeof(szPostsCode)-1], sizeof( m_szPostsAllowed ) - sizeof( szPostsCode ) ) ;

            if( m_cbPostsAllowed + sizeof( szPostsAllowed ) >= sizeof( m_szPostsAllowed ) ) {
                m_szPostsAllowed[ sizeof( szPostsCode )-1 ] = '\0' ;
            }
            lstrcat( m_szPostsAllowed, szPostsAllowed ) ;
            m_cbPostsAllowed = lstrlen( m_szPostsAllowed ) ;

            m_cbPostsNotAllowed = sizeof( szNoPostsCode ) + SetVersionStrings(  szServerPath, szTitle,
                    &m_szPostsNotAllowed[sizeof(szNoPostsCode)-1], sizeof( m_szPostsNotAllowed ) - sizeof( szNoPostsCode ) ) ;

            if( m_cbPostsNotAllowed + sizeof( szPostsNotAllowed ) >= sizeof( m_szPostsNotAllowed ) )    {
                m_szPostsNotAllowed[ sizeof( szNoPostsCode )-1 ] = '\0' ;
            }
            lstrcat( m_szPostsNotAllowed, szPostsNotAllowed ) ;
            m_cbPostsNotAllowed = lstrlen( m_szPostsNotAllowed ) ;

            SetVersionStrings(  szServerPath, szTitle, szVersionString, 128 );

            int cb = lstrlen( szServerPath ) ;
            while( szServerPath[cb] != '\\' ) {
                szServerPath[cb--] = '\0' ;
            }
        }
    }

	//
	//	Initialize file paths - GetRegistrySettings may overwrite defaults !
	//
	lstrcpy( m_ArticleTableFile, szServerPath ) ;
	lstrcat( m_ArticleTableFile, NNTP_DEF_ARTICLETABLEFILE ) ;

	lstrcpy( m_HistoryTableFile, szServerPath ) ;
	lstrcat( m_HistoryTableFile, NNTP_DEF_HISTORYTABLEFILE ) ;

	lstrcpy( m_XoverTableFile, szServerPath ) ;
	lstrcat( m_XoverTableFile, NNTP_DEF_XOVERTABLEFILE ) ;

	lstrcpy( m_GroupListFile, szServerPath ) ;
	lstrcat( m_GroupListFile, NNTP_DEF_GROUPLISTFILE ) ;
    SetGroupListBakTmpPath();

	lstrcpy( m_GroupVarListFile, szServerPath ) ;
	lstrcat( m_GroupVarListFile, NNTP_DEF_GROUPVARLISTFILE ) ;

	lstrcpy( m_GroupHelpFile, szServerPath ) ;
	lstrcat( m_GroupHelpFile, NNTP_DEF_GROUPHELPFILE ) ;

	lstrcpy( m_ModeratorFile, szServerPath ) ;
	lstrcat( m_ModeratorFile, NNTP_DEF_MODERATORFILE ) ;

	lstrcpy( m_PrettynamesFile, szServerPath ) ;
	lstrcat( m_PrettynamesFile, NNTP_DEF_PRETTYNAMESFILE ) ;

	lstrcpy( m_szDropDirectory, szServerPath ) ;
	lstrcat( m_szDropDirectory, NNTP_DEF_DROPDIRECTORY ) ;

	//
	//	Initialize DNS name
	//
	if( gethostname( m_NntpDNSName, sizeof( m_NntpDNSName ) ) == SOCKET_ERROR ) {
		NntpLogEvent(	NNTP_CANT_GET_DNSNAME, 1, (const CHAR **)args, 0 ) ;
		goto	error_exit ;
	}	else	{

		hostent	*phostent = gethostbyname( m_NntpDNSName ) ;
		if( phostent == 0 ) {
			NntpLogEvent( NNTP_CANT_GET_DNSNAME, 1, (const CHAR**)args, 0) ;
			goto	error_exit ;
		}	else	{
			DWORD	cbName = lstrlen( phostent->h_name ) ;
			if( 1+cbName > sizeof( m_NntpDNSName ) ) {
				NntpLogEvent( NNTP_DNS_TOO_LARGE, 1, (const CHAR**)args, 0 ) ;
				goto	error_exit ;
			}
			CopyMemory( m_NntpDNSName, phostent->h_name, cbName+1 ) ;
			m_NntpDNSNameSize = cbName ;
		}
	}

	return fRet;

error_exit:

	return FALSE ;
}

BOOL
NNTP_SERVER_INSTANCE::AllocateServerStructures( VOID )
{
	LPCSTR lpPath = QueryMDPath();

	// should be NULL to begin with
	_ASSERT( !m_pArticleTable );
	_ASSERT( !m_pHistoryTable );
	_ASSERT( !m_pXoverTable );
	_ASSERT( !m_pXCache );
	_ASSERT( !m_pExpireObject );
	_ASSERT( !m_pActiveFeeds );
	_ASSERT( !m_pPassiveFeeds );
	_ASSERT( !m_pInUseList );
	_ASSERT( !m_pNntpServerObject);
	_ASSERT( !m_pInstanceWrapper);
	_ASSERT( !m_pInstanceWrapperEx );

	if( !(m_pArticleTable 		= CMsgArtMap::CreateMsgArtMap())			||
		!(m_pHistoryTable 		= CHistory::CreateCHistory())				||
		!(m_pXoverTable	  		= CXoverMap::CreateXoverMap())				||
		!(m_pXCache		  		= CXoverCache::CreateXoverCache())			||
		!(m_pNntpServerObject  	= XNEW CNntpServer(this))					||
		!(m_pInstanceWrapper  	= XNEW CNntpServerInstanceWrapperImpl(this))	||
		!(m_pInstanceWrapperEx  = XNEW CNntpServerInstanceWrapperImplEx(this))   ||
		!(m_pTree	  	  		= XNEW CNewsTree(m_pNntpServerObject))		||
		!(m_pVRootTable   		= XNEW CNNTPVRootTable(GetINewsTree(),
									CNewsTree::VRootRescanCallback))		||
		!(m_pExpireObject 		= XNEW CExpire(lpPath))						||
		!(m_pActiveFeeds  		= XNEW CFeedList)							||
		!(m_pPassiveFeeds 		= XNEW CFeedList)							||
		!(m_pInUseList    		= XNEW CSocketList)
		) {

		//
		//	Failed to allocate an object - free allocs that succeeded !
		//
		DELETE_CHK( m_pArticleTable ) ;
		DELETE_CHK( m_pHistoryTable ) ;
		DELETE_CHK( m_pXoverTable ) ;
		DELETE_CHK( m_pXCache ) ;
		DELETE_CHK( m_pExpireObject ) ;
		DELETE_CHK( m_pActiveFeeds ) ;
		DELETE_CHK( m_pPassiveFeeds ) ;
		DELETE_CHK( m_pInUseList ) ;
		DELETE_CHK( m_pNntpServerObject ) ;
		DELETE_CHK( m_pInstanceWrapper ) ;
		DELETE_CHK( m_pInstanceWrapperEx );

        // failure to allocate is fatal at this point !
        return FALSE;
	}

	// success !
	return TRUE ;
}

VOID
NNTP_SERVER_INSTANCE::FreeServerStructures( VOID )
{
	//
	//	Free if members are non-NULL
	//
	DELETE_CHK( m_pArticleTable ) ;
	DELETE_CHK( m_pHistoryTable ) ;
	DELETE_CHK( m_pXoverTable ) ;
	DELETE_CHK( m_pXCache ) ;
	DELETE_CHK( m_pExpireObject ) ;
	DELETE_CHK( m_pActiveFeeds ) ;
	DELETE_CHK( m_pPassiveFeeds ) ;
	DELETE_CHK( m_pInUseList ) ;
	DELETE_CHK( m_pNntpServerObject ) ;
	DELETE_CHK( m_pInstanceWrapper ) ;
	DELETE_CHK( m_pInstanceWrapperEx );

	if( m_lpAdminEmail ) {
		XDELETE[] m_lpAdminEmail;
		m_lpAdminEmail = NULL;
		m_cbAdminEmail = 0;
	}
}

BOOL
NNTP_SERVER_INSTANCE::VerifyHashTablesExist(
            BOOL fIgnoreGroupList
            )
{
    DWORD nFiles = 0;
	BOOL  fRet = TRUE ;
	DWORD dwError = 0;
    HANDLE hFind;
    WIN32_FIND_DATA findData;

	m_fAllFilesMustExist = FALSE ;

    //
    // check for artmap file
    //

    hFind = FindFirstFile(
                m_ArticleTableFile,
                &findData
                );

    if ( hFind != INVALID_HANDLE_VALUE ) {
        nFiles++;
        FindClose(hFind);
    }

    //
    // check for artmap file
    //

    hFind = FindFirstFile(
                m_XoverTableFile,
                &findData
                );

    if ( hFind != INVALID_HANDLE_VALUE ) {
        nFiles++;
        FindClose(hFind);
    }

    if (!fIgnoreGroupList)
    {
        hFind = FindFirstFile(
                    m_GroupListFile,
                    &findData
                    );

        if ( hFind != INVALID_HANDLE_VALUE ) {
            nFiles++;
            FindClose(hFind);
        }
    }

    //
    // ok, nFiles should either be 0 or 3 if fIgnoreGroupList == FALSE
    // otherwise, both hash tables must exist!!!
    //

    if ( fIgnoreGroupList )
    {
        if (nFiles != 2)
        {
            PCHAR args [1];
            CHAR  szId [20];
            _itoa( QueryInstanceId(), szId, 10 );
            args [0] = szId;

            ErrorTraceX(0,"only %d files found", nFiles);
            NntpLogEvent( NNTP_EVENT_HASH_MISSING,
                          1,
                          (const CHAR**)args,
                          nFiles );

            SetLastError(ERROR_FILE_NOT_FOUND);
            return(FALSE);
        }
    }
    else
    {
        //  BUGBUG: group.lst can be missing in PT MM1
        if ((nFiles != 0) && (nFiles != 2) && (nFiles != 3))
        {
            PCHAR args [1];
            CHAR  szId [20];
            _itoa( QueryInstanceId(), szId, 10 );
            args [0] = szId;

            ErrorTraceX(0,"only %d files found", nFiles);
            NntpLogEvent( NNTP_EVENT_HASH_CORRUPT,
                          1,
                          (const CHAR**)args,
                          nFiles );

            SetLastError(ERROR_FILE_NOT_FOUND);
            return(FALSE);
        }
    }

	if( nFiles == 3 ) {
		m_fAllFilesMustExist = TRUE ;
	}

    return fRet ;

} // VerifyHashTablesExist

//
//	Query the metabase for server bindings
//

DWORD
NNTP_SERVER_INSTANCE::QueryServerIP()
{
    MB mb( (IMDCOM*)m_Service->QueryMDObject() );
    MULTISZ msz;
    DWORD status = NO_ERROR;
    const CHAR * scan;
    DWORD ipAddress;
    USHORT ipPort;
    const CHAR * hostName;

    //
    // Open the metabase and get the current binding list.
    //

    if( mb.Open( QueryMDPath() ) ) {

        if( !mb.GetMultisz(
                "",
                MD_SERVER_BINDINGS,
                IIS_MD_UT_SERVER,
                &msz
                ) ) {

            status = GetLastError();

            if( status == MD_ERROR_DATA_NOT_FOUND ) {
            	//
            	//	Did not find server bindings
            	//
            	SetLastError( status );
            	return 0;
           	}
		}

        //
        // Close the metabase before continuing, as anyone that needs
        // to update the service status will need write access.
        //

        mb.Close();

    } else {

        status = GetLastError();

    }

    //
    // Scan the multisz and look for instances we'll need to create.
    //

    if( status == NO_ERROR ) {

        for( scan = msz.First() ;
             scan != NULL ;
             scan = msz.Next( scan ) ) {

            //
            // Parse the descriptor (in "ip_address:port:host_name" form)
            // into its component parts.
            //

            status = ParseDescriptor(
                                     scan,
                                     &ipAddress,
                                     &ipPort,
                                     &hostName
                                     );

            if( status == NO_ERROR ) {
            	//
            	//	Return the first IP found in MultiSz
            	//
            	return ipAddress ;
            }
		}
	}

    SetLastError( status );
	return 0;
}

DWORD
ParseDescriptor(
    IN const CHAR * Descriptor,
    OUT LPDWORD IpAddress,
    OUT PUSHORT IpPort,
    OUT const CHAR ** HostName
    )
/*++

Routine Description:

    Parses a descriptor string of the form "ip_address:ip_port:host_name"
    into its component parts.

Arguments:

    Descriptor - The descriptor string.

    IpAddress - Receives the IP address component if present, or
        INADDR_ANY if not.

    IpPort - Recieves the IP port component.

    HostName - Receives a pointer to the host name component.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    const CHAR * ipAddressString;
    const CHAR * ipPortString;
    const CHAR * hostNameString;
    const CHAR * end;
    CHAR temp[sizeof("123.123.123.123")];
    INT length;
    LONG tempPort;

    //
    // Sanity check.
    //

    _ASSERT( Descriptor != NULL );
    _ASSERT( IpAddress != NULL );
    _ASSERT( IpPort != NULL );
    _ASSERT( HostName != NULL );

    //
    // Find the various parts of the descriptor;
    //

    ipAddressString = Descriptor;

    ipPortString = strchr( ipAddressString, ':' );

    if( ipPortString == NULL ) {
        goto fatal;
    }

    ipPortString++;

    hostNameString = strchr( ipPortString, ':' );

    if( hostNameString == NULL ) {
        goto fatal;
    }

    hostNameString++;

    //
    // Validate and parse the IP address portion.
    //

    if( *ipAddressString == ':' ) {

        *IpAddress = INADDR_ANY;

    } else {

        length = (INT)(ipPortString - ipAddressString - 1);

        if( length > ( sizeof(temp) - 1 )) {
            goto fatal;
        }

        memcpy(
            temp,
            ipAddressString,
            length
            );

        temp[length] = '\0';

        *IpAddress = (DWORD)inet_addr( temp );

        if( *IpAddress == INADDR_NONE ) {
            goto fatal;
        }

    }

    //
    // Validate and parse the port.
    //

    if( *ipPortString == ':' ) {
        goto fatal;
    }

    length = (INT)(hostNameString - ipPortString);

    if( length > ( sizeof(temp) - 1 )) {
        goto fatal;
    }

    memcpy(
        temp,
        ipPortString,
        length
        );

    temp[length] = '\0';

    tempPort = strtol(
                   temp,
                   (CHAR **)&end,
                   0
                   );

    if( tempPort <= 0 || tempPort > 0xFFFF ) {
        goto fatal;
    }

    if( *end != ':' ) {
        goto fatal;
    }

    *IpPort = (USHORT)tempPort;

    //
    // Validate and parse the host name.
    //

    if( *hostNameString == ' ' || *hostNameString == ':' ) {
        goto fatal;
    }

    *HostName = hostNameString;

    return NO_ERROR;

fatal:

    return ERROR_INVALID_PARAMETER;

}   // ParseDescriptor

NNTP_SERVER_INSTANCE::CreateControlGroups()
/*++

Routine Description:

    Create the control.* groups if they do not exist

Arguments:

Return Value:

    BOOL - TRUE on success and FALSE on failure !

--*/
{
	char	szNewsgroup [3][MAX_NEWSGROUP_NAME] ;
	BOOL    fRet = TRUE ;

	TraceFunctEnter( "NNTP_SERVER_INSTANCE::CreateControlGroups" ) ;

	lstrcpy( szNewsgroup[0], "control.newgroup" );
	lstrcpy( szNewsgroup[1], "control.rmgroup" );
	lstrcpy( szNewsgroup[2], "control.cancel" );

	CNewsTree*	ptree = GetTree() ;
	CGRPPTR	pGroup;

    for( int i=0; i<3; i++ ) {

	    EnterCriticalSection( &m_critNewsgroupRPCs ) ;

    	pGroup = ptree->GetGroup( szNewsgroup[i], lstrlen( szNewsgroup[i] ) ) ;
	    if( pGroup == 0 ) {
            //
            //  Group does not exist - create it !
            //
        	if( !ptree->CreateGroup( szNewsgroup[i], TRUE, NULL, FALSE ) ) {
        	    ErrorTrace(0,"Failed to create newsgroup %s", szNewsgroup[i]);
        	    fRet = FALSE ;
        	}	else	{
        	    DebugTrace(0,"Created newsgroup %s", szNewsgroup[i]);
       	    }
    	}

	    LeaveCriticalSection( &m_critNewsgroupRPCs ) ;
    }

    return fRet ;
}

void
NNTP_SERVER_INSTANCE::AdjustWatermarkIfNec( CNewsGroupCore *pNewGroup )
/*++
Routine description:

    Look up RmGroupQueue, to see if an old group with the same name
    exists.    If the old group exists, we'll have to bump our lowwatermark
    so that new posts will not overwrite old messages

Arguments:

    CNewsGroupCore *pNewsGroup  - The new group

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::AdjustWatermarkIfNec" );
    _ASSERT( pNewGroup );

    //
    // Find the old group from rmgroup queue, if it exists
    //
    CGRPPTR         pOldGroup = NULL;
    BOOL            fFound = FALSE;
    DWORD	        dwStartTick = GetTickCount();

    //
    // If there is no rmgroup queue, we are done
    //
    if ( NULL == m_pExpireObject->m_RmgroupQueue ) return;

    fFound = m_pExpireObject->m_RmgroupQueue->Search( &pOldGroup, pNewGroup->GetGroupName() );

    //
    // If not found, we are done
    //
    if ( FALSE == fFound ) return;

    //
    // OK, now we should update the watermark
    //
    pNewGroup->SetLowWatermark( pOldGroup->GetHighWatermark() + 1 );
    pNewGroup->SetHighWatermark( pOldGroup->GetHighWatermark() );
    pNewGroup->SetMessageCount( 0 );

    //
    // Save them to the fixed prop file
    //
    pNewGroup->SaveFixedProperties();

    //
    // Now I am going to help ProcessRmGroupQ to process this group
    //
    pOldGroup->DeleteArticles( NULL, dwStartTick );
}

void
NNTP_SERVER_INSTANCE::SetWin32Error(    LPSTR   szVRootPath,
                                        DWORD   dwErr )
/*++
Routine description:

    Set win32 error code into one metabase vroot.  This is done in server
    because the server has the knowledge of metabase internal interface.
    Doing so inside vroot only ( by using MB external interface caused
    one deadlock )

Arguments:

    LPSTR   szVRootPath - The vroot path in MB to set this error code in
    DWORD   dwErr       - The Win32 error code to set

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::SetWin32Error" );
    _ASSERT( szVRootPath );

    MB  mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    //
    // Open the key for read and write
    //
    if ( ! mb.Open( szVRootPath, METADATA_PERMISSION_WRITE ) ) {
        ErrorTrace(0, "Can't open feed key %d", GetLastError() );
        return;
    }

    //
    // Now set the error code
    //
    if ( !mb.SetDword(  "",
						MD_WIN32_ERROR,
						IIS_MD_UT_SERVER,
						dwErr,
						METADATA_VOLATILE) ) {
	    ErrorTrace( 0, "Set dword failed %d", GetLastError() );
	    mb.Close();
	    return;
	}

	//
	// Close MB
	//
	mb.Close();
	return;
}

BOOL
NNTP_SERVER_INSTANCE::EnqueueRmgroup(   CNewsGroupCore *pGroup )
/*++
Routine description:

    Insert the newsgroup into rmgroup queue

Arguments:

    CNewsGroupCore *pGroup - The newsgroup to be inserted

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::EnqueueRmgroup" );
    _ASSERT( pGroup );

    return ExpireObject()->m_RmgroupQueue->Enqueue( (CNewsGroup*)pGroup );
}

IIS_SSL_INFO*
NNTP_SERVER_INSTANCE::QueryAndReferenceSSLInfoObj( VOID )
/*++

   Description

       Returns SSL info for this instance; calls Reference() before returning

   Arguments:

       None

   Returns:

       Ptr to SSL info object on success, NULL if failure

--*/
{
    TraceFunctEnterEx((LPARAM)this, "NNTP_SERVER_INSTANCE::QueryAndReferenceSSLInfoObj");
    IIS_SSL_INFO *pPtr = NULL;

    LockThisForRead();

    //
    // If it's null, we may have to create it - unlock, lock for write and make sure it's
    // still NULL before creating it
    //
    if ( !m_pSSLInfo )
    {
        UnlockThis();

        LockThisForWrite();

        //
        // Still null, so create it now
        //
        if ( !m_pSSLInfo )
        {
            m_pSSLInfo = IIS_SSL_INFO::CreateSSLInfo( (LPTSTR) QueryMDPath(),
                                                            (IMDCOM *) g_pInetSvc->QueryMDObject() );

            if ( m_pSSLInfo == NULL )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                UnlockThis();
                return NULL;
            }

		 // Add an internal reference
		 m_pSSLInfo->Reference();

         //
         // Register for changes
         //
         IIS_SERVER_CERT *pCert = m_pSSLInfo->GetCertificate();
		 if ( pCert ) {
			LogCertStatus();
		 }

         IIS_CTL *pCTL = m_pSSLInfo->GetCTL();
		 if ( pCTL ) {
			LogCTLStatus();
		 }

         if ( g_pCAPIStoreChangeNotifier )
         {
             if ( pCert && pCert->IsValid() )
             {
                 if (!g_pCAPIStoreChangeNotifier->RegisterStoreForChange( pCert->QueryStoreName(),
                                                                  pCert->QueryStoreHandle(),
                                                                  ResetSSLInfo,
                                                                  (PVOID) this ) )
                 {
                     DebugTrace((LPARAM)this,
                                "Failed to register for change event on store %s",
                                pCert->QueryStoreName());
                 }
             }

             if ( pCTL && pCTL->IsValid() )
             {
                 if (!g_pCAPIStoreChangeNotifier->RegisterStoreForChange( pCTL->QueryStoreName(),
                                                      pCTL->QueryOriginalStore(),
                                                                      ResetSSLInfo,
                                                                      (PVOID) this ) )
                 {
                     DebugTrace((LPARAM)this,
                                "Failed to register for change event on store %s",
                                pCTL->QueryStoreName());
                 }
             }

			 if ( pCert && pCert->IsValid() || pCTL && pCTL->IsValid() ) {

				HCERTSTORE hRootStore = CertOpenStore( 	CERT_STORE_PROV_SYSTEM_A,
														0,
														NULL,
														CERT_SYSTEM_STORE_LOCAL_MACHINE,
														"ROOT" );
				if ( hRootStore ) {
					//
					// watch for changes to root store
					//
					if ( !g_pCAPIStoreChangeNotifier->RegisterStoreForChange( 	"ROOT",
																				hRootStore,
																				ResetSSLInfo,
																				(PVOID)this ) ) {
						DebugTrace( 0, "Failed to register for change event on root store" );
					}

					CertCloseStore( hRootStore, 0 );
				} else {

					DebugTrace( 0, "Failed to open root store %d", GetLastError() );
				}
			 }
         } // if (g_pStoreChangeNotifier)

     } // if ( !m_pSSLInfo )

 } //if ( !m_pSSLInfo )

 //
 // At this point, m_pSSLInfo should not be NULL anymore, so add a reference
 //
 m_pSSLInfo->Reference();

 pPtr = m_pSSLInfo;

 UnlockThis();

 TraceFunctLeaveEx( (LPARAM)this );

 return pPtr;
}

VOID NNTP_SERVER_INSTANCE::ResetSSLInfo( LPVOID pvParam )
/*++
    Description:

        Wrapper function for function to call to notify of SSL changes

    Arguments:

        pvParam - pointer to instance for which SSL keys have changed

    Returns:

        Nothing

--*/
{

	TraceFunctEnter( "NNTP_SERVER_INSTANCE::ResetSSLInfo" );

    //
    // Call function to flush credential cache etc
    //
    if ( g_pSslKeysNotify )
    {
        g_pSslKeysNotify( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED,
                          pvParam );
    }

    NNTP_SERVER_INSTANCE *pInst = (NNTP_SERVER_INSTANCE *) pvParam;

    pInst->LockThisForRead();

    if ( pInst->m_pSSLInfo )
    {
        pInst->UnlockThis();

        pInst->LockThisForWrite();

        if ( pInst->m_pSSLInfo )
        {
            //
            // Stop watching for change notifications
            //
            IIS_SERVER_CERT *pCert = pInst->m_pSSLInfo->QueryCertificate();
            IIS_CTL *pCTL = pInst->m_pSSLInfo->QueryCTL();

            if ( g_pCAPIStoreChangeNotifier )
            {
                if ( pCert && pCert->IsValid() )
                {
                    g_pCAPIStoreChangeNotifier->UnregisterStore( pCert->QueryStoreName(),
                                                             ResetSSLInfo,
                                                             (PVOID) pvParam );
                }

                if ( pCTL && pCTL->IsValid() )
                {
                    g_pCAPIStoreChangeNotifier->UnregisterStore( pCTL->QueryStoreName(),
                                                             ResetSSLInfo,
                                                             (PVOID) pvParam );
                }

				//
				// Stop watching for root store
				//
				g_pCAPIStoreChangeNotifier->UnregisterStore(	"ROOT",
																ResetSSLInfo,
																(PVOID)pvParam );

            }

            //
            // Release internal reference
            //
            IIS_SSL_INFO::Release( pInst->m_pSSLInfo );

            //
            // Next call to QueryAndReferenceSSLObj() will create it again
            //
            pInst->m_pSSLInfo = NULL;
        }
    }

    pInst->UnlockThis();

	TraceFunctLeaveEx( (LPARAM)NULL );
}

VOID NNTP_SERVER_INSTANCE::LogCertStatus()
/*++
    Description:

       Writes system log event about status of server certificate if the cert is in some
       way not quite kosher eg expired, revoked, not signature-valid

    Arguments:

       None

    Returns:

       Nothing
--*/
{
	TraceFunctEnterEx((LPARAM)this, "NNTP_SERVER_INSTANCE::LogCertStatus");
    _ASSERT( m_pSSLInfo );

    DWORD dwCertValidity = 0;

    //
    // If we didn't construct the cert fully, log an error
    //
    if ( !m_pSSLInfo->QueryCertificate()->IsValid() )
    {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCertificate()->Status();
        DWORD dwStringID = 0;

        DebugTrace((LPARAM)this,
                   "Couldn't retrieve server cert; status : %d",
                   dwStatus);

        switch ( dwStatus )
        {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CERT_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CERT_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CERT_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CERT_INTERNAL_ERROR;
            break;
        }

        NntpLogEvent(dwStringID,
                              2,
                              apszMsgs,
                              0 );

		TraceFunctLeaveEx((LPARAM)this);
        return;
    }


    //
    // If cert is invalid in some other way , write the appropriate log message
    //
    if ( m_pSSLInfo->QueryCertValidity( &dwCertValidity ) )
    {
        const CHAR *apszMsgs[1];
        CHAR achInstance[20];
        wsprintfA( achInstance,
                   "%lu",
                   QueryInstanceId() );
        apszMsgs[0] = achInstance;
        DWORD dwMsgID = 0;

        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_VALID ) ||
             ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_NESTED ) ||
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_TIME_VALID ) )
        {
            DebugTrace((LPARAM)this,
                       "Server cert/CTL is not time-valid or time-nested");

            dwMsgID = SSL_MSG_TIME_INVALID_SERVER_CERT;
        }


        if ( dwCertValidity & CERT_TRUST_IS_REVOKED )
        {
            DebugTrace((LPARAM)this,
                       "Server Cert is revoked");

            dwMsgID = SSL_MSG_REVOKED_SERVER_CERT;
        }

        if ( ( dwCertValidity & CERT_TRUST_IS_UNTRUSTED_ROOT ) ||
             ( dwCertValidity & CERT_TRUST_IS_PARTIAL_CHAIN ) )
        {
            DebugTrace((LPARAM)this,
                       "Server Cert doesn't chain up to a trusted root");

            dwMsgID = SSL_MSG_UNTRUSTED_SERVER_CERT;
        }

        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) ||
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID ) )
        {
            DebugTrace((LPARAM)this,
                       "Server Cert/CTL is not signature valid");

            dwMsgID = SSL_MSG_SIGNATURE_INVALID_SERVER_CERT;
        }

        if ( dwMsgID )
        {
            NntpLogEvent( dwMsgID,
                                1,
                         apszMsgs,
                               0 ) ;
        }
    }

	TraceFunctLeaveEx((LPARAM)this);

}

VOID NNTP_SERVER_INSTANCE::LogCTLStatus()
/*++
    Description:

       Writes system log event about status of server CTL if CTL isn't valid

    Arguments:

      None

    Returns:

       Nothing
--*/
{
	TraceFunctEnterEx((LPARAM)this, "NNTP_SERVER_INSTANCE::LogCTLStatus");

    _ASSERT( m_pSSLInfo );

    //
    // If we didn't construct the CTL fully, log an error
    //
    if ( !m_pSSLInfo->QueryCTL()->IsValid() )
    {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCTL()->QueryStatus();
        DWORD dwStringID = 0;

        DebugTrace((LPARAM)this,
                   "Couldn't retrieve server CTL; status : %d\n",
                   dwStatus);

        switch ( dwStatus )
        {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CTL_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CTL_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CTL_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CTL_INTERNAL_ERROR;
            break;
        }

        NntpLogEvent( dwStringID,
                              2,
                              apszMsgs,
                              0 );
		TraceFunctLeaveEx((LPARAM)this);
        return;
    }
	TraceFunctLeaveEx((LPARAM)this);
}

#if 0

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::BuildFileName
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::BuildFileName(
                    char*   szFileOut,
                    DWORD   cbFileOut,
                    char*   szFileIn
                    )
/*++

Routine Description :

    This function uses the directory where the service is installed to build
    paths for finding service files.

Arguments :
    szFileOut - Buffer in which to save path
    cbFileOut - size of output buffer
    szFileIn -  File name to be concatenated to service path

Return Value :
    TRUE if successfull, FALSE otherwise.

--*/
{

    DWORD   cbPath = 0 ;
    ZeroMemory( szFileOut, cbFileOut ) ;
    if( cbFileOut > ((cbPath = lstrlen( m_szServerPath )) + lstrlen( szFileIn ) + 1) ) {

        CopyMemory( szFileOut, m_szServerPath, cbPath ) ;
        if( szFileOut[cbPath-1] != '\\' ) {
            szFileOut[cbPath++] = '\\' ;
        }
        lstrcat( szFileOut, szFileIn ) ;
        return  TRUE ;
    }
    return  FALSE ;
}

#endif

#if 0
HRESULT NNTP_SERVER_INSTANCE::TriggerSEOPost(REFIID iidEvent,
											 CArticle *pArticle,
						   					 void *pGrouplist,
											 DWORD *pdwOperations,
											 char *szFilename,
											 HANDLE hFile,
											 DWORD dwFeedId)
{
	return TriggerServerEvent(m_pSEORouter, iidEvent, pArticle,
							  (CNEWSGROUPLIST *) pGrouplist,
							  pdwOperations, szFilename, hFile, dwFeedId);
}
#endif

BOOL NNTP_SERVER_INSTANCE::CancelMessage(const char *pszMessageID) {
	TraceFunctEnter("NNTP_SERVER_INSTANCE::CancelMessage");

	CInFeed *pInFeed;
	DWORD rc = TRUE;

	pInFeed = new CFromClientFeed();
	if (pInFeed != NULL) {
		CPCString pcMessageID;
		pcMessageID.m_pch = (char *) pszMessageID;
		pcMessageID.m_cch = lstrlen(pszMessageID);
		CNntpReturn nntpReturn;
		rc = pInFeed->fApplyCancelArticle(this->GetInstanceWrapper(), NULL, NULL, TRUE, pcMessageID, nntpReturn);

		if (!rc) {
			switch (nntpReturn.m_nrc) {
				case nrcArticleBadMessageID:
					SetLastError(ERROR_INVALID_PARAMETER);
					break;
				case nrcNoAccess:
					SetLastError(ERROR_ACCESS_DENIED);
					break;
				default:
					if (GetLastError() == 0)
						SetLastError(ERROR_NOT_ENOUGH_MEMORY);
					break;
			}
		}

		delete pInFeed;
	} else {
		ErrorTrace((DWORD_PTR) this, "new CFromClientFeed returned NULL");
		SetLastError(ERROR_OUTOFMEMORY);
		rc = FALSE;
	}

	DebugTrace((DWORD_PTR) this, "returning %lu, ec = %lu", rc, GetLastError());
	TraceFunctLeave();
	return rc;
}

void
NNTP_SERVER_INSTANCE::SetGroupListBakTmpPath( )
{
    DWORD   dwLen = lstrlen( m_GroupListFile );

    _ASSERT( dwLen > 0 );

    //
    // Generate Group.lst.bak path
    //

    lstrcpy( m_GroupListBak, m_GroupListFile );

    CHAR*   p=m_GroupListBak+dwLen;

    while (*p != '\\' && p > m_GroupListBak) p--;

    _ASSERT( p > m_GroupListBak );

    lstrcpy( p, NNTP_DEF_GROUPLISTBAK );

    //
    // Generate Group.lst.tmp path only if we have a valid
    // m_BootOptions member
    //

    if (m_BootOptions != NULL)
    {
        lstrcpy( m_BootOptions->szGroupListTmp, m_GroupListFile );

        p=m_BootOptions->szGroupListTmp+dwLen;

        while (*p != '\\' && p > m_BootOptions->szGroupListTmp) p--;

        _ASSERT( p > m_BootOptions->szGroupListTmp );

        lstrcpy( p, NNTP_DEF_GROUPLISTTMP );
    }
}

BOOL
NNTP_SERVER_INSTANCE::UpdateIsComplete( IN LPSTR   szMDPath,
                                        OUT PBOOL  pfCompleted )
/*++
Routine description:

    Check if one feed update transaction is over, by checking
    the MD_FEED_HANDSHAKE flag.

Arguements:

    IN LPSTR szMDPath - The MD path under which the flag will be checked
    OUT PBOOL pfCompleted - The buffer to return if it's completed

Return value:

    TRUE if the completion check is successful, FALSE otherwise, eg.
    the metabase key can't be opened for read.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::UpdateIsComplete" );
    _ASSERT( szMDPath );

    MB      mb( ( IMDCOM*) g_pInetSvc->QueryMDObject() );
    DWORD   dwHandShake;

    *pfCompleted = FALSE;

    //
    // Try open the metabase key with read permission
    //
    if ( !mb.Open(  szMDPath, METADATA_PERMISSION_READ ) ) {
        //
        // admin should have closed the feed key after writing
        // the handshake flag.  So if open error with read request,
        // we assume admin is not done with updating one feed yet:
        //
        // This assumption requires admin to close a write handle to
        // a metabase object and then save the object at least once
        // for every feed change.  Otherwise we'll lose information
        // for feed update
        //
        goto func_exit;
    }

    //
    // Read the handshake flag
    //
    if ( !mb.GetDword(  "",
                        MD_FEED_HANDSHAKE,
                        IIS_MD_UT_SERVER,
                        &dwHandShake ) ) {
        //
        // The handshake property should already have been
        // created when instance starts up.  This is an error
        //
        ErrorTrace( 0, "Get MD property %d failed", MD_FEED_HANDSHAKE );
        mb.Close();
        goto fail_exit;
    }

    switch( dwHandShake ) {

        case FEED_UPDATING:
            break;

        case FEED_UPDATE_COMPLETE:
            *pfCompleted = TRUE;
            break;

        default:
            _ASSERT( 0 );   // shouldn't be other values.
    }

func_exit:
    mb.Close();
    TraceFunctLeave();
    return TRUE;

fail_exit:
    TraceFunctLeave( );
    return FALSE;
}

BOOL
NNTP_SERVER_INSTANCE::VerifyFeedPath(   IN  LPSTR  szMDPath,
                                        OUT PDWORD  pdwFeedID )
/*++
Routine description:

    Verify if the MD notification path is really the feed path.
    If it is, extract the feed ID ( optional ).

Arguments:

    IN LPSTR szMDPath - The path to verify
    OUT PDWORD pdwFeedID - Pointer to buffer to return Feed ID

Return value:

    TRUE if verify succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::VerifyFeedPath" );
    _ASSERT( szMDPath );

    LPSTR   lpstrFeedPath = QueryMDFeedPath();
    LPSTR   lpstrDigitBegin;
    LPSTR   lpstrDigitEnd;
    CHAR    szBuffer[MAX_PATH];
    DWORD   dwIDLen;
    BOOL    fResult = FALSE;

    //
    // Instance feed path should be prefix of szMDPath
    //
    if ( _strnicmp( szMDPath, lpstrFeedPath, lstrlen( lpstrFeedPath ) ) != 0 ) {
        DebugTrace(0, "Shouldn't have been trapped in feed change notification" );
        goto Exit;
    }

    //
    // If feed ID wants to be extracted
    //
    if ( pdwFeedID ) {

        lpstrDigitBegin = szMDPath + lstrlen( lpstrFeedPath );

        while( *lpstrDigitBegin && !isdigit( (UCHAR)*lpstrDigitBegin ) )
            lpstrDigitBegin++;

        lpstrDigitEnd = lpstrDigitBegin;

        while( *lpstrDigitEnd && isdigit( (UCHAR)*lpstrDigitEnd ) )
            lpstrDigitEnd++;

        _ASSERT( lpstrDigitEnd <= szMDPath + lstrlen( szMDPath ) );

        dwIDLen = (DWORD)( lpstrDigitEnd - lpstrDigitBegin ) / sizeof ( CHAR );

        strncpy( szBuffer, lpstrDigitBegin, dwIDLen );
        *( szBuffer + dwIDLen ) = 0;

        *pdwFeedID = atol( szBuffer );

        //
        // if Feed ID is zero, failed
        //
        if ( 0 == pdwFeedID ) {
            ErrorTrace(0, "Notified MD path incorrect" );
            goto Exit;
        }
    }

    fResult = TRUE;

Exit:

    TraceFunctLeave( );
    return fResult;
}

BOOL
NNTP_SERVER_INSTANCE::AddSetFeed( IN DWORD dwFeedID )
/*++
Routine description:

    Add a feed or set feed info in the feed block data.  Parameters
    are loaded from metabase first.

Arguments:

    IN DWORD dwFeedID - The feed ID to set

Return value:

    TRUE if succeed, FALSE otherwise.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::AddSetFeed" );
    _ASSERT( dwFeedID > 0 );

    BOOL           fResult = FALSE;
    CHAR           szFeedPath[MAX_PATH+1];    // buffer for feed key
    MB              mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    NNTP_FEED_INFO  feedInfo;
    CHAR            szFeedServer[MAX_PATH+1];
    WCHAR           wszFeedServer[MAX_PATH+1];
    DWORD           dwDataSize;
    DWORD           dwErrorMask = 0;

    CHAR            Distribution[1024];
    WCHAR           wszDistribution[1024];
    CHAR            szBigBuffer[1024];
    DWORD           dwDistributionSize;
    CHAR            Newsgroup[1024];
    CHAR *          szNewsgroup = NULL;
    WCHAR *       wszNewsgroup = NULL;
    DWORD         dwNewsgroupSize = 0;
    CHAR            TempDir[1024];
    WCHAR           wszTempDir[1024];
    DWORD           dwTempDirSize;
    CHAR            UucpName[1024];
    WCHAR           wszUucpName[1024];
    DWORD           dwUucpNameSize;
    CHAR            NntpAccount[MAX_PATH+1];
    WCHAR           wszNntpAccount[MAX_PATH+1];
    DWORD           dwNntpAccountSize;
    CHAR            NntpPassword[MAX_PATH+1];
    WCHAR           wszNntpPassword[MAX_PATH+1];
    DWORD           dwNntpPassword;

    DWORD           dwAllowControlMsg;
    APIERR          err;
    DWORD           dwFeedIDToReturn;   // needed by AddFeed call

    DWORD           dwMetadataBuffer;
    CHAR            szKeyName[MAX_PATH];

    dwDistributionSize = sizeof( Distribution );
    ZeroMemory( Distribution, dwDistributionSize );
    MULTISZ         msz1( Distribution, dwDistributionSize );

    dwNewsgroupSize = sizeof( Newsgroup );
    ZeroMemory( Newsgroup, dwNewsgroupSize );
    MULTISZ  mszNewsgroup( Newsgroup, dwNewsgroupSize );

    PFEED_BLOCK     pfeedBlock1 = NULL;
    PFEED_BLOCK     pfeedBlock2 = NULL;

    if ( _snprintf( szFeedPath, sizeof(szFeedPath)-1,  "%sFeed%d/", QueryMDFeedPath(), dwFeedID ) < 0 )
    {
        ErrorTrace(0, "Can't open feed key" );
        goto fail_exit;    
    }
    else 
        szFeedPath[sizeof(szFeedPath)-1] = '\0';
    
    //
    // Open the feed key for read and write
    //
    if ( ! mb.Open( szFeedPath, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {
        ErrorTrace(0, "Can't open feed key" );
        goto fail_exit;
    }

    //
    // Set default info values
    //
    ZeroMemory( &feedInfo, sizeof( NNTP_FEED_INFO ) );
    feedInfo.Enabled = TRUE;
    feedInfo.fAllowControlMessages = TRUE;
    feedInfo.OutgoingPort = NNTP_PORT;
    feedInfo.ConcurrentSessions = 1;
    feedInfo.AuthenticationSecurityType = AUTH_PROTOCOL_NONE;

    //
    // Begin loading parameters
    //

    if ( !mb.GetDword(  "",
                        MD_FEED_DISABLED,
                        IIS_MD_UT_SERVER,
                        &dwMetadataBuffer ) )
        feedInfo.Enabled = TRUE;    // default - allow feed
    else
        feedInfo.Enabled = dwMetadataBuffer ? TRUE : FALSE ;

    dwDataSize = MAX_PATH;
    if ( mb.GetString(  "",
                        MD_FEED_SERVER_NAME,
                        IIS_MD_UT_SERVER,
                        szFeedServer,
                        &dwDataSize ) ) {
        CopyAsciiStringIntoUnicode( wszFeedServer, szFeedServer );
        feedInfo.ServerName = wszFeedServer;
    } else {
        dwErrorMask |= FEED_PARM_SERVERNAME;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    if ( ! mb.GetDword( "",
                        MD_FEED_TYPE,
                        IIS_MD_UT_SERVER,
                        &feedInfo.FeedType ) )
    {
        dwErrorMask |= FEED_PARM_FEEDTYPE;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    if ( !ValidateFeedType( feedInfo.FeedType ) ) {
        dwErrorMask |= FEED_PARM_FEEDTYPE;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    if ( !mb.GetDword(  "",
                        MD_FEED_CREATE_AUTOMATICALLY,
                        IIS_MD_UT_SERVER,
                        &dwMetadataBuffer ) )
        feedInfo.AutoCreate = FALSE;
    else
        feedInfo.AutoCreate = dwMetadataBuffer ? TRUE : FALSE;

    if ( !FEED_IS_PASSIVE( feedInfo.FeedType ) ) {

        if ( !mb.GetDword(  "",
                            MD_FEED_INTERVAL,
                            IIS_MD_UT_SERVER,
                            &feedInfo.FeedInterval ) )
            feedInfo.FeedInterval = DEF_FEED_INTERVAL;
        else if ( feedInfo.FeedInterval < MIN_FEED_INTERVAL )
                feedInfo.FeedInterval = MIN_FEED_INTERVAL;


        if ( !mb.GetDword(  "",
                            MD_FEED_START_TIME_HIGH,
                            IIS_MD_UT_SERVER,
                            &feedInfo.StartTime.dwHighDateTime ) ) {
           feedInfo.StartTime.dwHighDateTime = 0;
           feedInfo.StartTime.dwLowDateTime = 0;
           goto end_time;
        }

        if ( !mb.GetDword( "",
                           MD_FEED_START_TIME_LOW,
                           IIS_MD_UT_SERVER,
                           &feedInfo.StartTime.dwLowDateTime ) ) {
            feedInfo.StartTime.dwLowDateTime = 0;
            feedInfo.StartTime.dwHighDateTime = 0;
            goto end_time;
        }

        if ( FEED_IS_PULL( feedInfo.FeedType ) ) {

            if ( !mb.GetDword(  "",
                                MD_FEED_NEXT_PULL_HIGH,
                                IIS_MD_UT_SERVER,
                                &feedInfo.PullRequestTime.dwHighDateTime ) )
                feedInfo.PullRequestTime.dwHighDateTime = 0;

            if ( !mb.GetDword(  "",
                                MD_FEED_NEXT_PULL_LOW,
                                IIS_MD_UT_SERVER,
                                &feedInfo.PullRequestTime.dwLowDateTime ) ) {
                feedInfo.PullRequestTime.dwHighDateTime = 0;
                feedInfo.PullRequestTime.dwLowDateTime = 0;
            }
        }
    } else {
        feedInfo.StartTime.dwHighDateTime = 0;
        feedInfo.StartTime.dwLowDateTime = 0;
        feedInfo.FeedInterval = 0;
    }

end_time:


    if ( !mb.GetMultisz(    "",
                            MD_FEED_DISTRIBUTION,
                            IIS_MD_UT_SERVER,
                            &msz1 ) ) {
        dwErrorMask |= FEED_PARM_DISTRIBUTION;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    dwDistributionSize = msz1.QueryCCH();
    CopyMemory( szBigBuffer, msz1.QueryStr(), dwDistributionSize );
    CopyNAsciiStringIntoUnicode( wszDistribution, szBigBuffer,
        dwDistributionSize, sizeof(szBigBuffer) / sizeof(WCHAR) );
    feedInfo.Distribution =  wszDistribution;
    feedInfo.cbDistribution = sizeof( WCHAR ) * dwDistributionSize;

    if ( !mb.GetMultisz(    "",
                            MD_FEED_NEWSGROUPS,
                            IIS_MD_UT_SERVER,
                            &mszNewsgroup ) ) 
    {
        dwErrorMask |= FEED_PARM_NEWSGROUPS;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    dwNewsgroupSize = mszNewsgroup.QueryCCH();

    // X5:190991 Dynamically allocate news group buffers
    szNewsgroup = (PCHAR)ALLOCATE_HEAP(dwNewsgroupSize + 1);
    if (szNewsgroup == NULL)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto fail_exit;
    }

    wszNewsgroup = (WCHAR*)ALLOCATE_HEAP((dwNewsgroupSize + 1) * sizeof(WCHAR));
    if (wszNewsgroup == NULL)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto fail_exit;
    }

    CopyMemory( szNewsgroup, mszNewsgroup.QueryStr(), dwNewsgroupSize );
    CopyNAsciiStringIntoUnicode( wszNewsgroup, szNewsgroup, 
        dwNewsgroupSize, dwNewsgroupSize );
    
    feedInfo.Newsgroups = wszNewsgroup;
    feedInfo.cbNewsgroups = sizeof( WCHAR ) * dwNewsgroupSize;

    dwTempDirSize = sizeof( TempDir );
    ZeroMemory( TempDir, dwTempDirSize );
    if ( !mb.GetString(    "",
                            MD_FEED_TEMP_DIRECTORY,
                            IIS_MD_UT_SERVER,
                            TempDir,
                            &dwTempDirSize ) ) {
        // we'll use the system temp path so that we
        // don't fail those feeds that are missing temp
        // paths
        /*
        dwErrorMask |= FEED_PARM_TEMPDIR;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;*/
        _VERIFY( GetTempPath( 1023, TempDir ) );
    }

    CopyAsciiStringIntoUnicode( wszTempDir, TempDir );
    feedInfo.FeedTempDirectory = wszTempDir;
    feedInfo.cbFeedTempDirectory = 2 * dwTempDirSize;

    if ( FEED_IS_PUSH( feedInfo.FeedType ) ) {

        dwUucpNameSize =  sizeof( UucpName );
        if ( !mb.GetString( "",
                            MD_FEED_UUCP_NAME,
                            IIS_MD_UT_SERVER,
                            UucpName,
                            &dwUucpNameSize ) ) {
            //
            // attempt to use remote server name
            //
            if ( inet_addr( szFeedServer ) == INADDR_NONE ) {
                lstrcpy( UucpName, szFeedServer );
                dwUucpNameSize = lstrlen( UucpName );
            } else {
                dwErrorMask |= FEED_PARM_UUCPNAME;
                err = ERROR_INVALID_PARAMETER;
                goto mark_error;
            }
        }

        CopyAsciiStringIntoUnicode( wszUucpName, UucpName );
        feedInfo.UucpName = wszUucpName;
        feedInfo.cbUucpName = dwUucpNameSize;

        if ( !mb.GetDword( "",
                            MD_FEED_CONCURRENT_SESSIONS,
                            IIS_MD_UT_SERVER,
                            &feedInfo.ConcurrentSessions ) ) {
            dwErrorMask |= FEED_PARM_CONCURRENTSESSION;
            err = ERROR_INVALID_PARAMETER;
            goto mark_error;
        }
    }

    if ( FEED_IS_PUSH( feedInfo.FeedType ) || FEED_IS_PULL( feedInfo.FeedType ) ) {
        if ( !mb.GetDword(  "",
                            MD_FEED_MAX_CONNECTION_ATTEMPTS,
                            IIS_MD_UT_SERVER,
                            &feedInfo.MaxConnectAttempts ) ) {
            dwErrorMask |= FEED_PARM_MAXCONNECT;
            err = ERROR_INVALID_PARAMETER;
            goto mark_error;
        }
    }

    if ( !mb.GetDword(  "",
                        MD_FEED_AUTHENTICATION_TYPE,
                        IIS_MD_UT_SERVER,
                        &feedInfo.AuthenticationSecurityType ) ) {
        dwErrorMask |= FEED_PARM_AUTHTYPE;
        err = ERROR_INVALID_PARAMETER;
        goto mark_error;
    }

    if ( feedInfo.AuthenticationSecurityType != AUTH_PROTOCOL_NONE &&
         feedInfo.AuthenticationSecurityType == AUTH_PROTOCOL_CLEAR ) {

        dwNntpAccountSize = sizeof( NntpAccount );
        if ( !mb.GetString( "",
                            MD_FEED_ACCOUNT_NAME,
                            IIS_MD_UT_SERVER,
                            NntpAccount,
                            &dwNntpAccountSize ) ) {
            dwErrorMask |= FEED_PARM_ACCOUNTNAME;
            err = ERROR_INVALID_PARAMETER;
            goto mark_error;
        }

        CopyAsciiStringIntoUnicode( wszNntpAccount, NntpAccount );
        feedInfo.NntpAccountName = wszNntpAccount;
        feedInfo.cbAccountName = 2 * dwNntpAccountSize;

        dwNntpPassword= sizeof( NntpPassword );
        if ( !mb.GetString( "",
                            MD_FEED_PASSWORD,
                            IIS_MD_UT_SERVER,
                            NntpPassword,
                            &dwNntpPassword,
                            METADATA_SECURE) ) {
            dwErrorMask |= FEED_PARM_PASSWORD;
            err = ERROR_INVALID_PARAMETER;
            goto mark_error;
        }

        CopyAsciiStringIntoUnicode( wszNntpPassword, NntpPassword );
        feedInfo.NntpPassword = wszNntpPassword;
        feedInfo.cbPassword = dwNntpPassword;
    }

    if ( !mb.GetDword(  "",
                        MD_FEED_ALLOW_CONTROL_MSGS,
                        IIS_MD_UT_SERVER,
                        &dwAllowControlMsg ) )
        feedInfo.fAllowControlMessages = TRUE;
    else
        feedInfo.fAllowControlMessages = dwAllowControlMsg ? TRUE : FALSE;

    mb.GetDword(   "",
                   MD_FEED_OUTGOING_PORT,
                    IIS_MD_UT_SERVER,
                    &feedInfo.OutgoingPort );

    mb.GetDword(    "",
                    MD_FEED_FEEDPAIR_ID,
                    IIS_MD_UT_SERVER,
                    &feedInfo.FeedPairId );

    feedInfo.FeedId = dwFeedID;

    if ( !mb.GetDword(  "",
                        MD_FEED_SECURITY_TYPE,
                        IIS_MD_UT_SERVER,
                        &feedInfo.SessionSecurityType ) )
        feedInfo.SessionSecurityType = 0;

    //
    // OK, now it's time to do the right thing
    //

    //
    // We should find out if this is a feed add or set
    // Because when a feed is added, metabase notification
    // would be two steps:
    // 1. Add key
    // 2. Set new info
    // But we are ignoring the first notification because one
    // feed update transaction isn't over until new info is
    // set.  So the only way to check if this is a new feed
    // is to search the feed list, while not from the MB
    // notification object.
    //
    pfeedBlock1 = m_pActiveFeeds->Search( dwFeedID );
    pfeedBlock2 = m_pPassiveFeeds->Search( dwFeedID );
    if ( !pfeedBlock1 && !pfeedBlock2 ) {
        sprintf( szKeyName, "feed%d", dwFeedID );
        err = AddFeedToFeedBlock(   NULL,
                                    QueryInstanceId(),
                                    (LPI_FEED_INFO)&feedInfo,
                                    szKeyName,
                                    &dwErrorMask,
                                    &dwFeedIDToReturn );
    } else {
        if ( pfeedBlock1 ) m_pActiveFeeds->FinishWith( this, pfeedBlock1 );
        if ( pfeedBlock2 ) m_pActiveFeeds->FinishWith( this, pfeedBlock2 );
        err = SetFeedInformationToFeedBlock(    NULL,
                                                QueryInstanceId(),
                                                (LPI_FEED_INFO)&feedInfo,
                                                &dwErrorMask );
    }

mark_error:

    //
    // Now set the error code and masks
    //
    if ( !mb.SetDword(  "",
                        MD_FEED_ADMIN_ERROR,
                        IIS_MD_UT_SERVER,
                        err  ) ) {
        mb.Close();
        ErrorTrace(0, "Setting error code fail" );
        goto fail_exit;
    }

    if ( !mb.SetDword(  "",
                        MD_FEED_ERR_PARM_MASK,
                        IIS_MD_UT_SERVER,
                        dwErrorMask ) )  {
        mb.Close();
        ErrorTrace(0, "Setting parm mask fail" );
        goto fail_exit;
    }

    //
    // Now we may set handshake confirm
    //
    if ( !mb.SetDword(  "",
                        MD_FEED_HANDSHAKE,
                        IIS_MD_UT_SERVER,
                        FEED_UPDATE_CONFIRM ) ) {
        mb.Close();
        ErrorTrace(0, "Setting hand shake fail" );
        goto fail_exit;
    }

    mb.Close();
    mb.Save();

    fResult = TRUE;

cleanup:

    // X5: 190991 free up buffer.
    if (szNewsgroup)
    	FREE_HEAP(szNewsgroup);

    if (wszNewsgroup)
    	FREE_HEAP(wszNewsgroup);

    TraceFunctLeave( );
    return fResult;

fail_exit:

    fResult = FALSE;
    goto cleanup;

}

VOID
NNTP_SERVER_INSTANCE::DeleteFeed( IN DWORD dwFeedID )
/*++
Routine description:

    Delete the feed in the feed block data structure, when
    receiving the notification of feed deletion in metabase

Arguments:

    IN DWORD dwFeedID - Feed ID to delete

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::DeleteFeed" );
    _ASSERT( dwFeedID > 0 );

    DeleteFeedFromFeedBlock(    NULL,
                                QueryInstanceId(),
                      dwFeedID );

    TraceFunctLeave( );
}

VOID
NNTP_SERVER_INSTANCE::UpdateFeed( IN PMD_CHANGE_OBJECT pcoChangeList,
                                  IN DWORD dwFeedID )
/*++
Routine description:

    When the MB change occurs with feed ID level property change,
    this method gets called to check what has been changed in
    the metabase and do necessary updates to the feed block.

Arguments:

    IN MD_CHANGE_OBJECT *pcoChangeList - The metabase change object

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::UpdateFeed" );
    _ASSERT( pcoChangeList );

    BOOL            fOK;
    BOOL            fUpdateIsComplete;

    //
    // If it's a deletion, we don't need to ssync up with admin
    //
    if ( pcoChangeList->dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT ) {
        DeleteFeed( dwFeedID );
        goto func_exit;
    }

    //
    // Is one update transaction over ?
    //
    // For changes made before one transaction is over, we will remember
    // the parameter that has been changed by setting the feed update
    // mask.  Only when one transaction is over will we really update
    // the feed block info.
    //
    // Assume: admin behaves properly so that consecutive updates during
    //         one transaction happened to one feed and we assume the
    //         feed to change is specified by the MD path of last
    //         MD notification during one transaction
    //
    fOK = UpdateIsComplete( ( LPSTR ) ( pcoChangeList->pszMDPath ) ,
                            &fUpdateIsComplete );

    if ( !fOK ) {   // this is error, but what we can do is ignore
                    // this update
        ErrorTrace(0, "UpdateIsComplete failed" );
        goto func_exit;
    }

    //
    // If it's not complete, we should ignore this notification
    //
    if ( !fUpdateIsComplete ) goto func_exit;

    //
    // If it's completed, we should deal with two cases:
    // 1)  Feed info set
    // 2)  Feed Add
    // for which we should check the change type
    //
    if ( pcoChangeList->dwMDChangeType != MD_CHANGE_TYPE_ADD_OBJECT &&
         pcoChangeList->dwMDChangeType != MD_CHANGE_TYPE_SET_DATA &&
         pcoChangeList->dwMDChangeType != MD_CHANGE_TYPE_DELETE_DATA )
        // we ignore it
        goto func_exit;

    //
    // If it's feed info set or add, we should reload / load all
    // the parameters and feed them into feed block
    //
    if ( ! AddSetFeed( dwFeedID ) )
        ErrorTrace(0, "AddSetFeed fail" );  // currently we keep silent

func_exit:

    TraceFunctLeave( );
}

BOOL
NNTP_SERVER_INSTANCE::IsNotMyChange( IN LPSTR szMDPath, DWORD dwMDChangeType )
/*++
Routine description:

    Server instance is picking up MB change for feed and setting
    flags to MB.  This setting could also result in MB notification.
    We don't want to be trapped in this dead loop.  So this function
    checks if the notification is generated by myself.  If the handshake
    flag is "confirmed", it means the changed is caused by itself.
    Otherwise it's caused by admin.

Arguments:

    IN LPSTR szMDPath - The metabase path to check

Return value:

    TRUE if it's not changed by myself, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::IsNotChange" );
    _ASSERT( szMDPath );
    BOOL    fResult;
    DWORD   dwHandShake;

    MB mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    //
    // open the handshake key for read
    //
    if ( !mb.Open( szMDPath, METADATA_PERMISSION_READ ) ) {
        //
        // This could be a delete, when it's a deletion,
        // we should still go ahead updating feed block
        //
        if ( dwMDChangeType != MD_CHANGE_TYPE_DELETE_OBJECT ) {
            ErrorTrace(0, "open md key %s fail", szMDPath );
            fResult = FALSE;  // this doesn't necessarily mean
                                // my change.  But by returning
                                // false we are telling caller
                                // that there is no need to proceed
                                // with this update, since we even
                                // can not read the metabase key
            goto func_exit;
        } else {
            fResult = TRUE;
            goto func_exit;
        }
    }

    if ( !mb.GetDword(  "",
                        MD_FEED_HANDSHAKE,
                        IIS_MD_UT_SERVER,
                        &dwHandShake ) ) {
        ErrorTrace(0, "fail to read handshake" );
        fResult = FALSE;  // same comments as above
        mb.Close();
        goto func_exit;
    }

    fResult = dwHandShake == FEED_UPDATE_CONFIRM ? FALSE : TRUE;
    mb.Close();

func_exit:

    TraceFunctLeave( );
    return fResult;
}

BOOL
NNTP_SERVER_INSTANCE::MailArticle(  CNewsGroupCore *pGroupCore,
                                    ARTICLEID       artid,
                                    LPSTR           szModerator )
/*++
Routine description:

    Mail the article out to moderator

Arguments:

    CNewsGroupcore *pGroupCore  - The group to load the article from
    ARTICLEID       artid       - Article id inside that special group

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::MailArticle" );
    _ASSERT( pGroupCore );
    _ASSERT( artid > 0 );

    //
    // Init get the article object
    //
    STOREID storeid;
    const DWORD cchMaxBuffer = 2 * 1024; // this should be enough
    									 // for normal cases, if
    									 // it's not enough, CAllocator
    									 // will use "new"
    CHAR        pchBuffer[cchMaxBuffer];
    CAllocator  allocator(pchBuffer, cchMaxBuffer);
    CToClientArticle    *pArticle = ((CNewsGroup*)pGroupCore)->GetArticle(  GetInstanceWrapper(),
                                                                artid,
                                                                storeid,
                                                                NULL,
                                                                NULL,
                                                                &allocator,
                                                                TRUE );
    _ASSERT( pArticle );
    if ( !pArticle ) {
        ErrorTrace( 0, "Get article object failed %d", GetLastError());
        return FALSE;
    }

    //
    // Now use the article library to mail it
    //
    BOOL f = pArticle->fMailArticle( szModerator );

    delete pArticle;
    TraceFunctLeave();
    return f;
}

///////////////////////////////////////////////////////////////////////////////
// Rebuild related methods
///////////////////////////////////////////////////////////////////////////////
DWORD
NNTP_SERVER_INSTANCE::GetRebuildProgress()
{
    return m_dwProgress;
}

DWORD
NNTP_SERVER_INSTANCE::GetRebuildLastError()
{
    return m_dwLastRebuildError;
}

void
NNTP_SERVER_INSTANCE::SetRebuildProgress( DWORD dw )
{
    m_dwProgress = dw;
}

void
NNTP_SERVER_INSTANCE::SetRebuildLastError( DWORD dw )
{
    m_dwLastRebuildError = dw;
}

BOOL
NNTP_SERVER_INSTANCE::BlockUntilStable()
{
    return m_pVRootTable->BlockUntilStable( 1000 );
}

BOOL
NNTP_SERVER_INSTANCE::AllConnected()
{
    return m_pVRootTable->AllConnected();
}

BOOL
NNTP_SERVER_INSTANCE::CreateRebuildObject()
/*++
Routine description:

    Create the proper rebuild object ( standard or complete rebuild ), based
    on the options we have now.

Arguments:

    None.

Return value:

    TRUE, if succeeded, FALSE otherwise.  If false, LastError will be set
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::CreateRebuildObject" );

    //
    // There should be no previous rebuild going on here
    //
    _ASSERT( NULL == m_pRebuild );

    if ( NNTPBLD_DEGREE_STANDARD == m_BootOptions->ReuseIndexFiles ) {

        // We should create CStandardReBuild
        m_pRebuild = XNEW CStandardRebuild( this, m_BootOptions );
    } else {

        // We should create CCompleteRebuild
        m_pRebuild = XNEW CCompleteRebuild( this, m_BootOptions );

    }

    if ( NULL == m_pRebuild ) {
        ErrorTrace( 0, "Create rebuild object failed" );
        NntpLogEventEx( NNTP_REBUILD_FAILED,
                        0,
                        NULL,
                        GetLastError(),
                        QueryInstanceId() ) ;

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    TraceFunctLeave();
    return TRUE;
}

VOID
NNTP_SERVER_INSTANCE::Rebuild()
/*++
Routine description:

    Main driving routine to do per virtual server rebuild

Arguments:

    None.

Return value:

    None.
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::Rebuild" );
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    //
    // Step 1. Create the rebuild object
    //
    if ( !CreateRebuildObject() ) {

        ErrorTrace( 0, "Creating rebuild objects failed %d", GetLastError() );
        m_BootOptions->ReportPrint( "Creating rebuild object failed - error %d\n",
                                    GetLastError() );
        goto Exit;
    }

    _ASSERT( m_pRebuild );

    //
    // Step 2. Preparation for starting the server
    //
    if ( !m_pRebuild->PrepareToStartServer() ) {

        SetRebuildLastError( GetLastError() );
        ErrorTrace( 0, "Prepare building a tree failed %d", GetLastError() );
        m_BootOptions->ReportPrint( "Prepare building tree failed - error %d\n",
                                    GetLastError() );
        goto Exit;
    }

    //
    // I give it 10% progress on this
    //
    SetRebuildProgress( 10 );

    //
    // Step 3. Start the server
    //
    // We want to start the server at this point and let drivers' initialization
    // and decorate newstree take care of building a news tree.  The driver
    // should read property on INntpServer to see if the server is in rebuild
    // mode.  If the server is not in rebuild mode, he should go as usual,
    // otherwise, he should take special care.
    //
    if ( !m_pRebuild->StartServer() ) {

        SetRebuildLastError( GetLastError() );
        ErrorTrace( 0, "Start the server failed %d", GetLastError() );
        m_BootOptions->ReportPrint( "Start the server during rebuild failed - error %d\n",
                                    GetLastError() );
        goto Exit;
    }

    //
    // Delete all the special files ( in slave groups )
    //
    m_pRebuild->DeleteSpecialFiles();

    //
    // I give it 40% progress on this
    //
    SetRebuildProgress( 50 );

    //
    // Step 4. Build the group objects ( and hash tables for clean rebuild case )
    //
    if ( !m_pRebuild->RebuildGroupObjects() ) {

        SetRebuildLastError( GetLastError() );
        ErrorTrace( 0, "Rebuild group objects failed %d", GetLastError() );
        NntpLogEventEx( NNTP_REBUILD_FAILED,
                        0,
                        NULL,
                        GetLastError(),
                        QueryInstanceId() ) ;

        m_BootOptions->ReportPrint( "Rebuild group objects failed - error %d\n",
                                    GetLastError() );
        m_pRebuild->StopServer();
        goto Exit;
    }

    //
    // I give it another 45% progress on this
    //
    SetRebuildProgress( 95 );

    //
    // Step 5. Turn on posting
    //
	_ASSERT( QueryServerState() == MD_SERVER_STATE_STARTED );
	if( mb.Open( QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
    	SetPostingModes( mb, TRUE, TRUE, TRUE );
    	mb.Close();
   	}

   	//
   	// I confirm that it's completed
   	//
   	SetRebuildProgress( 100 );

Exit:
    //
    // Step 6. Rebuild completed, destroy rebulid object
    //
    if ( m_pRebuild ) {
        XDELETE m_pRebuild;
        m_pRebuild = NULL;
    }

   	//
   	// Step 7. Clean up rebuild option
   	//
   	EnterCriticalSection( &m_critRebuildRpc ) ;

	// NOTE: this is created on a rebuild RPC !
	if( m_BootOptions ) {
		if( INVALID_HANDLE_VALUE != m_BootOptions->m_hOutputFile ) {
			_VERIFY( CloseHandle( m_BootOptions->m_hOutputFile ) );
		}
		XDELETE m_BootOptions;
		m_BootOptions = NULL;
	}

	LeaveCriticalSection( &m_critRebuildRpc ) ;
}

BOOL
NNTP_SERVER_INSTANCE::ServerDataConsistent()
/*++
Routine description:

    Check consistency of server data: newstree against xover table

Arguments:

    None.

Return value:

    TRUE if server data are in consistent, FALSE otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::ServerDataConsistent" );

    //
    // Enumerate the newstree
    //
    CNewsTree *pTree = GetTree();
    if ( NULL == pTree || pTree->IsStopping() ) {
        ErrorTrace( 0, "Tree is null or beging shutdown" );
        return FALSE;
    }

    CGroupIterator *pIterator = pTree->GetIterator( mszStarNullNull, TRUE );
    if ( NULL == pIterator ) {
        ErrorTrace( 0, "Get newstree iterator failed %d", GetLastError());
        return FALSE;
    }

    while( !pTree->IsStopping() && !pIterator->IsEnd() ) {

        CGRPPTR pGroup = pIterator->Current();
        _ASSERT( pGroup );

#if 0
        DWORD   dwLowWatermark = pGroup->GetLowWatermark();
        DWORD   dwHighWatermark = pGroup->GetHighWatermark();
        DWORD   dwMessageCount = pGroup->GetMessageCount();

        //
        // Check against itself
        //
        if (    dwMessageCount == 0 && dwHighWatermark != dwLowWatermark - 1 ||
                dwMessageCount > 0 && dwHighWatermark - dwLowWatermark < dwMessageCount - 1 ) {
            XDELETE pIterator;
            return FALSE;
        }

        //
        // Check against hash table
        //
	    for (   DWORD i = dwLowWatermark; i <= dwHighWatermark;
			    i += (  dwHighWatermark - dwLowWatermark == 0 ? 1:
					    dwHighWatermark - dwLowWatermark ) ) {
            DWORD groupidPrimary, artidPrimary;
	        GROUP_ENTRY rgCrossposts[MAX_NNTPHASH_CROSSPOSTS];
	        BYTE rgcStoreCrossposts[MAX_NNTPHASH_CROSSPOSTS];
	        DWORD cGrouplistSize = sizeof(GROUP_ENTRY) * MAX_NNTPHASH_CROSSPOSTS;
	        DWORD cGroups;

            GROUPID groupidSecondary = pGroup->GetGroupId();
            ARTICLEID artidSecondary = i;
	        if (!XoverTable()->GetArticleXPosts(groupidSecondary,
			        					artidSecondary,
					        			FALSE,
							        	rgCrossposts,
								        cGrouplistSize,
								        cGroups,
								        rgcStoreCrossposts)) {
			    ErrorTrace( 0, "Article (%d/%d ) not found in xover table",
			                groupidSecondary, artidSecondary );
			    XDELETE pIterator;
			    return FALSE;
			}

			//
			// Primary article id must be between primary group's high/low watermark
			//
			CGRPPTR pPrimaryGroup = pTree->GetGroup( rgCrossposts[0].GroupId );
			if ( !pPrimaryGroup ) {
			    ErrorTrace( 0, "Primary group %d doesn't exist in tree", rgCrossposts[0].GroupId );
			    XDELETE pIterator;
			    return FALSE;
			}

            if ( rgCrossposts[0].ArticleId < pPrimaryGroup->GetLowWatermark() ||
                 rgCrossposts[0].ArticleId > pPrimaryGroup->GetHighWatermark() ) {
                ErrorTrace( 0, "Article id %d of group %d is outside watermarks",
                            rgCrossposts[0].ArticleId, rgCrossposts[0].GroupId );
                XDELETE pIterator;
                return FALSE;
            }
        }
#endif

        if ( !pGroup->WatermarkConsistent() ) {
            ErrorTrace( 0, "Group watermark inconsistent" );
            XDELETE pIterator;
            return FALSE;
        }

        //
        // OK, this group has passed, lets get to the next group
        //
        pIterator->Next();
    }

    //
    // If we have successfully come here, the server data is in good shape
    //
    XDELETE pIterator;
    TraceFunctLeave();
    return TRUE;
}

DWORD
NNTP_SERVER_INSTANCE::GetVRootWin32Error(   LPWSTR  wszVRootPath,
                                            PDWORD  pdwWin32Error )
/*++
Routine description:

    Get vroot connection status from vrtable, this is just a wrapper
    to relay the work to the vroot table

Arguments:

    LPWSTR wszVRootPath - The vroot path to look up for
    PDWORD pdwWin32Error - To return the win32 connection error code

Return value:

    NOERROR if succeeded, WIN32 error code otherwise
--*/
{
    TraceFunctEnter( "NNTP_SERVER_INSTANCE::GetVRootWin32Error" );
    _ASSERT( wszVRootPath );
    _ASSERT( pdwWin32Error );

    DWORD dw = m_pVRootTable->GetVRootWin32Error(   wszVRootPath,
                                                    pdwWin32Error );

    TraceFunctLeave();
    return dw;
}

#if 0
NET_API_STATUS
NET_API_FUNCTION
NntprAddDropNewsgroup(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR szNewsgroup
    )
{
	return NERR_Success;
}

NET_API_STATUS
NET_API_FUNCTION
NntprRemoveDropNewsgroup(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR szNewsgroup
    )
{
	return NERR_Success;
}
#endif

NET_API_STATUS
NET_API_FUNCTION
NntprCancelMessageID(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR pszMessageID
    )
{
    ACQUIRE_SERVICE_LOCK_SHARED();

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	DWORD err = NERR_Success;
	if (!pInstance->CancelMessage(pszMessageID)) {
		err = GetLastError();
		_ASSERT(err != NERR_Success);
	}

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return err;
}

CInFeed *NNTP_SERVER_INSTANCE::NewClientFeed() {
	if (m_OurNntpRole == RoleSlave) {
		return new CSlaveFromClientFeed();
	} else {
		return new CFromClientFeed();
	}
}

INewsTree *NNTP_SERVER_INSTANCE::GetINewsTree() {
	return m_pTree->GetINewsTree();
}

//
// this function performs service level server events registration
//
HRESULT RegisterSEOService() {
	HRESULT hr;
	CComBSTR bstrNNTPOnPostCatID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST);
	CComBSTR bstrNNTPOnPostFinalCatID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST_FINAL);

	//
	// see if we've done the service level registration by getting the list
	// of source types and seeing if the NNTP source type is registered
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	if (FAILED(hr)) return hr;
	// if this failed then we need to register the source type and event
	// component categories
	if (hr == S_FALSE) {
		// register the component categories
		CComPtr<IEventComCat> pComCat;
		hr = CoCreateInstance(CLSID_CEventComCat, NULL, CLSCTX_ALL,
						 	  IID_IEventComCat, (LPVOID *) &pComCat);
		if (hr != S_OK) return hr;
		CComBSTR bstrNNTPOnPostCATID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST);
		CComBSTR bstrOnPost = "NNTP OnPost";
		hr = pComCat->RegisterCategory(bstrNNTPOnPostCATID, bstrOnPost, 0);
		if (FAILED(hr)) return hr;
		CComBSTR bstrNNTPOnPostFinalCATID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST_FINAL);
		CComBSTR bstrOnPostFinal = "NNTP OnPostFinal";
		hr = pComCat->RegisterCategory(bstrNNTPOnPostFinalCATID, bstrOnPostFinal, 0);
		if (FAILED(hr)) return hr;

		// register the source type
		hr = pSourceTypes->Add(bstrSourceTypeGUID, &pSourceType);
		if (FAILED(hr)) return hr;
		_ASSERT(hr == S_OK);
		CComBSTR bstrSourceTypeDisplayName = "NNTP Server";
		hr = pSourceType->put_DisplayName(bstrSourceTypeDisplayName);
		if (FAILED(hr)) return hr;
		hr = pSourceType->Save();
		if (FAILED(hr)) return hr;

		// add the event types to the source type
		CComPtr<IEventTypes> pEventTypes;
		hr = pSourceType->get_EventTypes(&pEventTypes);
		if (FAILED(hr)) return hr;
		hr = pEventTypes->Add(bstrNNTPOnPostCatID);
		if (FAILED(hr)) return hr;
		_ASSERT(hr == S_OK);
		hr = pEventTypes->Add(bstrNNTPOnPostFinalCatID);
		if (FAILED(hr)) return hr;
		_ASSERT(hr == S_OK);
	}

	return S_OK;
}

//
// this function performs instance level server events registration
//
HRESULT RegisterSEOInstance(DWORD dwInstanceID, char *szDropDirectory) {
	HRESULT hr;
	CComBSTR bstrNNTPOnPostFinalCatID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST_FINAL);

	//
	// find the NNTP source type in the event manager
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	_ASSERT(hr != S_OK || pSourceType != NULL);
	if (hr != S_OK) return hr;

	//
	// generate a GUID for this source, which is based on GUID_NNTPSVC
	// mangled by the instance ID
	//
	CComPtr<IEventUtil> pEventUtil;
	hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
					 	  IID_IEventUtil, (LPVOID *) &pEventUtil);
	if (hr != S_OK) return hr;
	CComBSTR bstrNNTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_NNTPSVC);
	CComBSTR bstrSourceGUID;
	hr = pEventUtil->GetIndexedGUID(bstrNNTPSvcGUID, dwInstanceID, &bstrSourceGUID);
	if (FAILED(hr)) return hr;

	//
	// see if this source is registered with the list of sources for the
	// NNTP source type
	//
	CComPtr<IEventSources> pEventSources;
	hr = pSourceType->get_Sources(&pEventSources);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSource> pEventSource;
	hr = pEventSources->Item(&CComVariant(bstrSourceGUID), &pEventSource);
	if (FAILED(hr)) return hr;
	//
	// if the source guid doesn't exist then we need to register a new
	// source for the NNTP source type and add directory drop as a binding
	//
	if (hr == S_FALSE) {
		// register the NNTPSvc source
		hr = pEventSources->Add(bstrSourceGUID, &pEventSource);
		if (FAILED(hr)) return hr;
		char szSourceDisplayName[50];
		_snprintf(szSourceDisplayName, 50, "nntpsvc %lu", dwInstanceID);
		CComBSTR bstrSourceDisplayName = szSourceDisplayName;
		hr = pEventSource->put_DisplayName(bstrSourceDisplayName);
		if (FAILED(hr)) return hr;

		// create the event database for this source
		CComPtr<IEventDatabaseManager> pDatabaseManager;
		hr = CoCreateInstance(CLSID_CEventMetabaseDatabaseManager, NULL, CLSCTX_ALL,
						 	  IID_IEventDatabaseManager, (LPVOID *) &pDatabaseManager);
		if (hr != S_OK) return hr;
		CComBSTR bstrEventPath;
		CComBSTR bstrService = "nntpsvc";
		hr = pDatabaseManager->MakeVServerPath(bstrService, dwInstanceID, &bstrEventPath);
		if (FAILED(hr)) return hr;
		CComPtr<IUnknown> pDatabaseMoniker;
		hr = pDatabaseManager->CreateDatabase(bstrEventPath, &pDatabaseMoniker);
		if (FAILED(hr)) return hr;
		hr = pEventSource->put_BindingManagerMoniker(pDatabaseMoniker);
		if (FAILED(hr)) return hr;

		// save everything we've done so far
		hr = pEventSource->Save();
		if (FAILED(hr)) return hr;
		hr = pSourceType->Save();
		if (FAILED(hr)) return hr;

		// add a new binding for Directory Drop with an empty newsgroup
		// list rule
		CComPtr<IEventBindingManager> pBindingManager;
		hr = pEventSource->GetBindingManager(&pBindingManager);
		if (FAILED(hr)) return hr;
		CComPtr<IEventBindings> pEventBindings;
		hr = pBindingManager->get_Bindings(bstrNNTPOnPostFinalCatID, &pEventBindings);
		if (FAILED(hr)) return hr;
		CComPtr<IEventBinding> pEventBinding;
		hr = pEventBindings->Add(L"", &pEventBinding);
		if (FAILED(hr)) return hr;
		CComBSTR bstrBindingDisplayName = "Directory Drop";
		hr = pEventBinding->put_DisplayName(bstrBindingDisplayName);
		if (FAILED(hr)) return hr;
		CComBSTR bstrSinkClass = "NNTP.DirectoryDrop";
		hr = pEventBinding->put_SinkClass(bstrSinkClass);
		if (FAILED(hr)) return hr;
		CComPtr<IEventPropertyBag> pSourceProperties;
		hr = pEventBinding->get_SourceProperties(&pSourceProperties);
		if (FAILED(hr)) return hr;
		CComBSTR bstrPropName;
		CComBSTR bstrPropValue;
		bstrPropName = "NewsgroupList";
		bstrPropValue = "";
		hr = pSourceProperties->Add(bstrPropName, &CComVariant(bstrPropValue));
		if (FAILED(hr)) return hr;
		CComPtr<IEventPropertyBag> pSinkProperties;
		hr = pEventBinding->get_SinkProperties(&pSinkProperties);
		if (FAILED(hr)) return hr;
		bstrPropName = "Drop Directory";
		bstrPropValue = szDropDirectory;
		hr = pSinkProperties->Add(bstrPropName, &CComVariant(bstrPropValue));
		if (FAILED(hr)) return hr;
		hr = pEventBinding->Save();
		if (FAILED(hr)) return hr;
	}

	return S_OK;
}

//
// this function performs instance level unregistration
//
HRESULT UnregisterSEOInstance(DWORD dwInstanceID) {
	HRESULT hr;

	//
	// find the NNTP source type in the event manager
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	_ASSERT(hr != S_OK || pSourceType != NULL);
	if (hr != S_OK) return hr;

	//
	// generate a GUID for this source, which is based on GUID_NNTPSVC
	// mangled by the instance ID
	//
	CComPtr<IEventUtil> pEventUtil;
	hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
					 	  IID_IEventUtil, (LPVOID *) &pEventUtil);
	if (hr != S_OK) return hr;
	CComBSTR bstrNNTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_NNTPSVC);
	CComBSTR bstrSourceGUID;
	hr = pEventUtil->GetIndexedGUID(bstrNNTPSvcGUID, dwInstanceID, &bstrSourceGUID);
	if (FAILED(hr)) return hr;

	//
	// remove this source from the list of registered sources
	//
	CComPtr<IEventSources> pEventSources;
	hr = pSourceType->get_Sources(&pEventSources);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSource> pEventSource;
	hr = pEventSources->Remove(&CComVariant(bstrSourceGUID));
	if (FAILED(hr)) return hr;

	return S_OK;
}

HRESULT UnregisterOrphanedSources(void) {
	HRESULT hr;

	//
	// find the NNTP source type in the event manager
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	_ASSERT(hr != S_OK || pSourceType != NULL);
	if (hr != S_OK) return hr;

	//
	// get the list of sources registered for this source type
	//
	CComPtr<IEventSources> pSources;
	hr = pSourceType->get_Sources(&pSources);
	if (FAILED(hr)) return hr;
	CComPtr<IEnumVARIANT> pSourceEnum;
	hr = pSources->get__NewEnum((IUnknown **) &pSourceEnum);
	if (FAILED(hr)) return hr;

	do {
		VARIANT varSource;

		hr = pSourceEnum->Next(1, &varSource, NULL);
		if (FAILED(hr)) return hr;
		if (hr == S_OK) {
			if (varSource.vt == VT_DISPATCH) {
				CComPtr<IEventSource> pSource;

				// QI for the IEventSource interface
				hr = varSource.punkVal->QueryInterface(IID_IEventSource,
													 (void **) &pSource);
				if (FAILED(hr)) return hr;
				varSource.punkVal->Release();

				// get the binding manager
				CComBSTR bstrSourceID;
				hr = pSource->get_ID(&bstrSourceID);
				if (FAILED(hr)) return hr;

				// get the index from the SourceID
				CStringGUID guidIndex(bstrSourceID);
				DWORD iInstance;
				if (guidIndex.GetIndex(GUID_NNTPSVC, &iInstance)) {
					// see if this instance exists
    				MB mb((IMDCOM*)g_pInetSvc->QueryMDObject());
					char szMBPath[50];

					_snprintf(szMBPath, 50, "LM/nntpsvc/%lu", iInstance);
					if (mb.Open(szMBPath)) {
						// it exists, so just close the mb and keep going
						mb.Close();
					} else {
						// the instance is gone, clean up this source in
						// the metabase
						hr = pSources->Remove(&CComVariant(bstrSourceID));
						_ASSERT(SUCCEEDED(hr));
					}
				}

				pSource.Release();
			} else {
				_ASSERT(FALSE);
			}
		}
	} while (hr == S_OK);

	return S_OK;
}

//
// This function handles picking up files from the pickup directory.
//
// parameters:
// 		pvInstance [in] - a void pointer to the current instance
//		pwszFilename [in] - the filename that was detected in the pickup dir
// returns:
//		TRUE - the file was handled.  if TRUE is returned than directory
//				notification won't put this file on the retryq.
//		FALSE - the file was not handled.  this causes the file to be put
//				onto the retry q.  PickupFile will be called with this file
//				again.
// notes:
//  	pInstance->IncrementPickupCount() and DecrementPickupCount() should
//		be used to keep track of the number of threads which are currently
//		in this method.  the instance won't shutdown until there are no
// 		threads in this method.
//
BOOL NNTP_SERVER_INSTANCE::PickupFile(PVOID pvInstance, WCHAR *pwszFilename) {
	DWORD dwFileSizeHigh = 0;
    ULARGE_INTEGER liStart;
    ULARGE_INTEGER liNow;
    FILETIME now;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::PickupFile");

	//
	// Since this is a Sync event, we'll increase the number of runnable
	// threads in the Atq pool.
	//
	AtqSetInfo(AtqIncMaxPoolThreads, NULL);

	//
	// Now see if there is at least one Atq thread available to handle
	// any completions from the store
	//

	if (AtqGetInfo(AtqAvailableThreads) < 1) {
		AtqSetInfo(AtqDecMaxPoolThreads, NULL);
		TraceFunctLeave();
	    return FALSE;
	}


    GetSystemTimeAsFileTime(&now);
    LI_FROM_FILETIME(&liStart, &now);

	NNTP_SERVER_INSTANCE *pInstance = (NNTP_SERVER_INSTANCE *) pvInstance;

	pInstance->IncrementPickupCount();

	//
	// Check to see if the instance is good !
	//
	if( !CheckIISInstance( pInstance ) ) {
		ErrorTrace(0,"Instance %d not runnable", pInstance->QueryInstanceId() );
		pInstance->DecrementPickupCount();
		AtqSetInfo(AtqDecMaxPoolThreads, NULL);
		TraceFunctLeave();
		// we return TRUE so that this item isn't put back onto the retry q
		return TRUE;
	}

	//
	// open the file
	//
	HANDLE hFile = CreateFileW(pwszFilename, GENERIC_READ | GENERIC_WRITE,
							   0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		if (GetLastError() == ERROR_FILE_NOT_FOUND) {
			ErrorTrace(0, "%S reported in pickup dir, but doesn't exist",
				pwszFilename);
			pInstance->DecrementPickupCount();
		    AtqSetInfo(AtqDecMaxPoolThreads, NULL);
			TraceFunctLeave();
			return TRUE;
		} else {
			ErrorTrace(0, "%S reported in pickup dir, can't open, retry later",
				pwszFilename);
			pInstance->DecrementPickupCount();
		    AtqSetInfo(AtqDecMaxPoolThreads, NULL);
			TraceFunctLeave();
			return FALSE;
		}
	}

	//
	// handle 0 length files - zap 'em !
	//

	if( !GetFileSize( hFile, &dwFileSizeHigh ) && !dwFileSizeHigh ) {
		ErrorTrace(0,"%S is zero length - deleting", pwszFilename);
		_VERIFY( CloseHandle( hFile ) );
		DeleteFileW( pwszFilename );
		pInstance->DecrementPickupCount();
		AtqSetInfo(AtqDecMaxPoolThreads, NULL);
		TraceFunctLeave();
		return TRUE;
	}

	//
	// post this file
	//
	CInFeed *pFeed;

	pFeed = pInstance->NewClientFeed();
	if (pFeed == NULL) {
		ErrorTrace(0, "couldn't allocate CFromClientFeed to handle %S",
			pwszFilename);
    	_VERIFY(CloseHandle(hFile));
		pInstance->DecrementPickupCount();
		AtqSetInfo(AtqDecMaxPoolThreads, NULL);
		TraceFunctLeave();
		return FALSE;
	}
	BOOL fSuccess;
	DWORD dwSecondary;
	CNntpReturn nr;
	fSuccess = pFeed->fInit(pInstance->m_pFeedblockDirPickupPostings,
				 			pInstance->m_PeerTempDirectory,
				 			0,
				 			0,
				 			0,
				 			FALSE,
				 			TRUE,
				 			pInstance->m_pFeedblockDirPickupPostings->FeedId);

	if (fSuccess) {
		fSuccess = pFeed->PostPickup(pInstance->GetInstanceWrapper(),
									 NULL,
									 NULL,
									 TRUE,
									 hFile,
									 dwSecondary,
									 nr);
	}

	delete pFeed;
	_VERIFY(CloseHandle(hFile));

	WCHAR *pwszDestDirectory = pInstance->QueryFailedPickupDirectory();

	// check the status and act appropriately
	if (fSuccess || pwszDestDirectory[0] == (WCHAR) 0) {
		// the post was successful, delete the file
		if (!DeleteFileW(pwszFilename)) {
			ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
				pwszFilename, GetLastError());
//			_ASSERT(FALSE);
		}
	} else {
		// the post failed, move the file to a badarticles directory
		WCHAR wszDest[MAX_PATH + 1];
		WCHAR *pwszBasename = pwszFilename + lstrlenW(pwszFilename);
		while (pwszBasename[-1] != L'\\' && pwszBasename > pwszFilename)
			*pwszBasename--;
		_snwprintf(wszDest, MAX_PATH+1, L"%s%s", pwszDestDirectory, pwszBasename);
		wszDest[MAX_PATH]=L'\0';

		if (!MoveFileExW(pwszFilename, wszDest, MOVEFILE_COPY_ALLOWED)) {
			ErrorTrace(0, "MoveFileW(%S, %S) failed with %lu",
				pwszFilename, wszDest, GetLastError());

			// if this failed then we need to make a unique name to copy
			// to
			UINT cDest = GetTempFileNameW(pwszDestDirectory, L"nws", 0,
				wszDest);

			// this can fail if the bad articles directory has all temp file
			// names used or if the directory doesn't exist
			if (cDest == 0) {
				ErrorTrace(0, "GetTempFileNameW failed with %lu", GetLastError());
				if (!DeleteFileW(pwszFilename)) {
					ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
						pwszFilename, GetLastError());
					_ASSERT(FALSE);
				}
			} else {
				// GetTempFileName creates a 0 byte file with the name wszDest,
				// so we need to allow copying over that
				if (!MoveFileExW(pwszFilename, wszDest, MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING)) {
					// this should never happen.  just in case it does we just
					// delete the file
					ErrorTrace(0, "MoveFile(%S, %S) failed with %lu",
						pwszFilename, wszDest, GetLastError());
					if (!DeleteFileW(pwszFilename)) {
						ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
							pwszFilename, GetLastError());
//						_ASSERT(FALSE);
					}
				}
			}
		}
	}

#ifdef BUGBUG
	//
	// we log an event if they have event logging turned on for the Post
	// command and if this is an error or if they have erroronly logging
	// turned off
	//
	if (pInstance->GetCommandLogMask() & ePost &&
		((!(pInstance->GetCommandLogMask() & eErrorsOnly)) ||
		 (NNTPRET_IS_ERROR(nr.m_nrc))))
	{
		//
		// make a transaction log event
		//
	    INETLOG_INFORMATION request;			// log information
		char szFilename[MAX_PATH];				// the filename in ascii
		if (!WideCharToMultiByte(CP_ACP, 0, pwszFilename, -1, szFilename, MAX_PATH, NULL, NULL)) szFilename[0] = 0;

		// build the request structure
		ZeroMemory( &request, sizeof(request));
		request.pszClientUserName = "<pickup>";
	    // How long were we processing this?
	    GetSystemTimeAsFileTime( &now );
	    LI_FROM_FILETIME( &liNow, &now );
	    liNow.QuadPart -= liStart.QuadPart;
	    liNow.QuadPart /= (ULONGLONG)( 10 * 1000 );
	    request.msTimeForProcessing = liNow.LowPart;
		request.dwWin32Status = dwSecondary;
		request.dwProtocolStatus = nr.m_nrc;
		request.pszOperation = "post";
		request.cbOperation  = 4;
		if (*szMessageID != 0) {
			request.pszTarget = szGroups;
			request.cbTarget = lstrlen(szGroups);
		}
		if (*szGroups != 0) {
			request.pszParameters = szMessageID;
		}

		// log the event
	    if (pInstance->m_Logging.LogInformation(&request) != NO_ERROR) {
	        ErrorTrace(0,"Error %d Logging information!", GetLastError());
	    }
	}
#endif

	pInstance->DecrementPickupCount();
	AtqSetInfo(AtqDecMaxPoolThreads, NULL);
	TraceFunctLeave();
	return TRUE;
}

#include "seo_i.c"
#include "mailmsg_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\newstree.cpp ===
/*++

	newstree.cpp

	This file contains the code implementing the CNewsTree object.
	There can only be one CNewsTree object per Tigris server.
	Each CNewsTree object is responsible for helping callers
	search and find arbitrary newsgroups.

	To support this, the CNewsTree object maintains two HASH Tables -
	One hash table for searching for newsgroups by name, another
	to search by GROUP ID.
	Additionally, we maintain a linked list of (alphabetical) of all
	the newsgroups.  And finally, we maintain a thread which is used
	to periodically save newsgroup information and handle expiration.


--*/




#define		DEFINE_FHASH_FUNCTIONS
#include    "tigris.hxx"

#include <malloc.h>

//template	class	TFHash<	CGrpLpstr, LPSTR > ;
//template	class	TFHash<	CGrpGroupId,	GROUPID > ;

static	char	szSlaveGroup[]	= "_slavegroup._slavegroup" ;
#define VROOT_CHANGE_LATENCY 10000

#ifdef	_NO_TEMPLATES_

FHASH_CONSTRUCTOR( CGrpLpstr, LPSTR ) ;
FHASH_INIT( CGrpLpstr, LPSTR ) ;
FHASH_ISVALID( CGrpLpstr, LPSTR ) ;
FHASH_DESTRUCTOR( CGrpLpstr, LPSTR ) ;
FHASH_COMPUTEINDEX( CGrpLpstr, LPSTR ) ;
FHASH_INSERT( CGrpLpstr, LPSTR ) ;
FHASH_SEARCH( CGrpLpstr, LPSTR ) ;
FHASH_DELETE( CGrpLpstr, LPSTR ) ;


FHASH_CONSTRUCTOR( CGrpGroupId, GROUPID ) ;
FHASH_INIT( CGrpGroupId, GROUPID ) ;
FHASH_ISVALID( CGrpGroupId, GROUPID ) ;
FHASH_DESTRUCTOR( CGrpGroupId, GROUPID ) ;
FHASH_COMPUTEINDEX( CGrpGroupId, GROUPID ) ;
FHASH_INSERT( CGrpGroupId, GROUPID ) ;
FHASH_SEARCH( CGrpGroupId, GROUPID ) ;
FHASH_DELETE( CGrpGroupId, GROUPID ) ;

#endif

//
//	This sets up all of our static members etc...
//
HANDLE CNewsTree::m_hTermEvent = 0 ;
HANDLE CNewsTree::m_hCrawlerThread = NULL ;

BOOL
CNewsTree::InitCNewsTree( 
		PNNTP_SERVER_INSTANCE	pInstance,
		BOOL&	fFatal
		) {
/*++

Routine Description : 

	Create a singular newstree object and then initialize it.

Arguments : 

	pInstance - Virtual server instance
	fFatal    - set to TRUE if a fatal error occurs

Return Value : 

	TRUE on success

--*/


	CNewsTree* ptree = pInstance->GetTree();
	_ASSERT( ptree );

    if( ptree->Init( pInstance, fFatal ) )	{
		return TRUE;
	}

    return  FALSE ;
}

BOOL
CNewsTree::StopTree()	{
/*++

Routine Description : 

	This function signals all of the background threads we create that 
	it is time to stop and shuts them down.

Arguments : 

	None.

Return Value : 
	TRUE if Successfull.

--*/

    m_bStoppingTree = TRUE;
	CNewsTreeCore::StopTree();

	m_pInstance->ShutdownDirNot();

    return TRUE;
}

CNewsTree::CNewsTree(INntpServer *pServerObject) :
	m_bStoppingTree( FALSE ),
    m_cNumExpireByTimes( 1 ),
    m_cNumFFExpires( 1 ),
	CNewsTreeCore(pServerObject)
	{
	//
	//	Constructor sets newstree up into initially empty state
	//
}

CNewsTree::~CNewsTree()	{
	//
	//	All of our member destructors should take care of stuff !
	//
	TraceFunctEnter( "CNewsTree::~CNewsTree" ) ;
}

BOOL
CNewsTree::Init( 
			PNNTP_SERVER_INSTANCE	pInstance,
			BOOL& fFatal
			) {
/*++

Routine Description : 

	Initialize the news tree.
	We need to setup the hash tables, check that the root virtual root is intact
	and then during regular server start up we would load a list of newsgroups from 
	a file.

Arguments : 


Return Value : 

	TRUE if successfull.

--*/
	//
	//	This function will initialize the newstree object
	//	and read the group.lst file if it can.
	//

	TraceFunctEnter( "CNewsTree::Init" ) ;

	BOOL	fRtn;
	fRtn =  CNewsTreeCore::Init(pInstance->GetVRTable(), 
	                            pInstance->GetInstanceWrapperEx(),
								fFatal, 
								gNumLocks, 
								RejectGenomeGroups);

	m_pInstance = pInstance ;
    m_bStoppingTree = FALSE;

    return  fRtn ;
}

void    
CNewsTree::BeginExpire( BOOL& fDoFileScan )
{
    CheckExpire( fDoFileScan );
    g_pNntpSvc->m_pExpireThrdpool->BeginJob( (PVOID)this );
}

void    
CNewsTree::EndExpire()
{
    TraceFunctEnter("CNewsTree::EndExpire");

    DWORD dwWait = g_pNntpSvc->m_pExpireThrdpool->WaitForJob( INFINITE );
    if( WAIT_OBJECT_0 != dwWait ) {
        ErrorTrace(0,"Wait failed - error is %d", GetLastError() );
        _ASSERT( FALSE );
    }

    BOOL fDoFileScan = FALSE;
    CheckExpire( fDoFileScan );
    if( fDoFileScan ) {
        m_cNumExpireByTimes = 1;
    } else {
        m_cNumExpireByTimes++;
    }
}

void    
CNewsTree::CheckExpire( BOOL& fDoFileScan )
{
    fDoFileScan = FALSE;
}

BOOL
CNewsTree::DeleteGroupFile()	{
/*++

Routine Description : 

	This function deletes the group.lst file (The file that
	we save the newstree to.)
	
Arguments : 

	None.

Return Value : 

	TRUE if successfull.
	FALSE otherwise.  We will preserver GetLastError() from the DeleteFile() call.

--*/

	
	return	DeleteFile( m_pInstance->QueryGroupListFile() ) ;

}

BOOL
CNewsTree::VerifyGroupFile( )	{
/*++

Routine Description : 

	This function checks that the group.lst file is intact and 
	appears to be valid.  We do this by merely confirming some check sum
	bytes that should be the last 4 bytes at the end of the file.

Arguments : 

	None.

Return Value : 

	TRUE if the Group.lst file is good.
	FALSE if corrupt or non-existant.

--*/

	CMapFile	map(	m_pInstance->QueryGroupListFile(), FALSE, 0 ) ;
	if( map.fGood() ) {

		DWORD	cb ;
		char*	pchBegin = (char*)map.pvAddress( &cb ) ;

		DWORD	UNALIGNED*	pdwCheckSum = (DWORD UNALIGNED *)(pchBegin + cb - 4);
		
		if( *pdwCheckSum != INNHash( (BYTE*)pchBegin, cb-4 ) ) {
			return	FALSE ;
		}	else	{
			return	TRUE ;
		}
	}
	return	FALSE ;
}

DWORD	__stdcall	
CNewsTree::NewsTreeCrawler(	void* )	{
/*++

Routine Description : 

	This function does all background manipulation of newsgroups
	required by the server.
	There are 4 main functions that need to be accomplished : 

		1) Periodically save an updated file of group information
		if the news tree has been updated.

		2) Expire articles.

		3) Process the rmgroup queue

Arguments : 

	None.

Return Value : 

	None.

--*/

	DWORD	dwWait = WAIT_TIMEOUT;
	PNNTP_SERVER_INSTANCE pInstance = NULL ;

	TraceFunctEnter( "CNewsTree::NewsTreeCrawler" );

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		dwWait = WaitForSingleObject( 
								CNewsTree::m_hTermEvent, 
								2 *60 * 1000		// wait for all instances to boot
								);
	}

	if( WAIT_OBJECT_0 == dwWait ) {
		return 0 ;
	}

	//
	//	The crawler thread will periodically iterate over all instances
	//	to expire articles and process its rmgroup queue
	//

	while( g_pInetSvc->QueryCurrentServiceState() != SERVICE_STOP_PENDING )
    {
              
		// dwWait == WAIT_TIMEOUT only when this thread wakes up per schedule
		if( WAIT_TIMEOUT == dwWait && (g_pInetSvc->QueryCurrentServiceState() == SERVICE_RUNNING) )
		{
			//	Get the min and max instance ids
			DWORD dwMinInstanceId = 0;
			DWORD dwMaxInstanceId = 0;

			if( FindIISInstanceRange( g_pNntpSvc, &dwMinInstanceId, &dwMaxInstanceId ) ) 
			{
				//
				//	Iterate over all instances 
				//
				for( DWORD dwCurrInstance = dwMinInstanceId; 
						dwCurrInstance <= dwMaxInstanceId; dwCurrInstance++)
				{
					pInstance = FindIISInstance( g_pNntpSvc, dwCurrInstance );
					if( pInstance == NULL ) {
						ErrorTrace(0,"Expire thread: FindIISInstance returned NULL: instance %d", dwCurrInstance);
						continue;
					}

					//
					//	Call method to expire articles in an instance
					//

					CShareLockNH* pLockInstance = pInstance->GetInstanceLock();

					pLockInstance->ShareLock();
					if( !ExpireInstance( pInstance ) ) {
						ErrorTrace(0,"ExpireInstance %d failed", dwCurrInstance );
					} else {
						DebugTrace(0, "ExpireInstance %d returned success", dwCurrInstance );
					}
					pLockInstance->ShareUnlock();

					//	Release the ref added by FindIISInstance()
					pInstance->Dereference();

					//	No use continuing the iteration if service is stopping !
					if ( g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING ) break;
				}
			} else {
				ErrorTrace(0, "FindIISInstanceRange failed" );
			}
		}

		dwWait = WaitForSingleObject( 
								CNewsTree::m_hTermEvent, 
								dwNewsCrawlerTime
								);

        if ( WAIT_OBJECT_0 == dwWait )
        {
			//	Time to die !!
			break ;
		}
	}	// end while

	return	0 ;
}

//
//	Expire articles in a given virtual server instance
//

BOOL
CNewsTree::ExpireInstance(
				PNNTP_SERVER_INSTANCE	pInstance
				)
{
	BOOL fRet = TRUE ;
	TraceFunctEnter("CNewsTree::ExpireInstance");

	// bail if service is stopping or expire is not ready for this instance
	if( (pInstance->QueryServerState() != MD_SERVER_STATE_STARTED)	||
		pInstance->m_BootOptions									||
		!pInstance->ExpireObject()									||
		!pInstance->ExpireObject()->m_FExpireRunning				|| 
		(pInstance->QueryServerState() == MD_SERVER_STATE_STOPPING)	||
		(g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) 
	{
		ErrorTrace(0, "Instance %d not ready for expire", pInstance->QueryInstanceId() );
		TraceFunctLeave();
		return FALSE ;
	}

    CNewsTree*  pTree = pInstance->GetTree() ;

	//
	// Process any pending rmgroups
	//
	(pInstance->ExpireObject())->ProcessRmgroupQueue( pTree );

    //
    //  Expiring articles by time is fast - the work is farmed out to a thread pool
    //
    (pInstance->ExpireObject())->ExpireArticlesByTime( pTree );

    //
    //  Expiring articles by size is slow - a single thread scans the groups
    //  NOTE: Expire policies that are by both time and size get processed here
    //
    //(pInstance->ExpireObject())->ExpireArticlesBySize( pTree );

	TraceFunctLeave();
	return fRet ;
}

BOOL
CNewsTree::RemoveGroup( CGRPPTR     pGroup )
{
    TraceFunctEnter("CNewsTree::RemoveGroup");

    // remove group from internal hash tables and lists
    return CNewsTreeCore::RemoveGroup(pGroup );
}


		

CGroupIterator*
CNewsTree::ActiveGroups(
					BOOL	fIncludeSecureGroups,
					CSecurityCtx* pClientLogon,
					BOOL	IsClientSecure,
					CEncryptCtx* pClientSslLogon,
                    BOOL    fReverse
					) {
/*++

Routine Description : 

	Build an iterator that can be used to walk all of the 
	client visible newsgroups.

Arguments : 
	
	fIncludeSecureGroups - 
		IF TRUE then the iterator we return will visit the
		SSL only newsgroups.

Return Value : 

	An iterator, NULL if an error occurs

--*/

	m_LockTables.ShareLock() ;
	CGRPCOREPTR	pStart;
    if( !fReverse ) {
		CNewsGroupCore *p = m_pFirst;
		while (p && p->IsDeleted()) p = p->m_pNext;
		pStart = p;
    } else {
		CNewsGroupCore *p = m_pLast;
		while (p && p->IsDeleted()) p = p->m_pPrev;
		pStart = p;
    }	
	m_LockTables.ShareUnlock() ;

	CGroupIterator*	pReturn = new	CGroupIterator( 
												this,
												pStart,
												fIncludeSecureGroups,
												pClientLogon,
												IsClientSecure,
												pClientSslLogon
												) ;
	return	pReturn ;
}

CGroupIterator*
CNewsTree::GetIterator( 
					LPMULTISZ	lpstrPattern, 
					BOOL		fIncludeSecureGroups,
					BOOL		fIncludeSpecialGroups,
					CSecurityCtx* pClientLogon,
					BOOL	IsClientSecure,
					CEncryptCtx* pClientSslLogon
					) {
/*++

Routine Description : 

	Build an iterator that 	will list newsgroups meeting
	all of the specified requirements.

Arguments : 

	lpstrPattern - wildmat patterns the newsgroup must match
	fIncludeSecureGroups - if TRUE then include secure (SSL only) newsgroups
	fIncludeSpecialGroups - if TRUE then include reserved newsgroups

Return Value : 

	An iterator, NULL on error

--*/

	CGRPCOREPTR pFirst;

	m_LockTables.ShareLock();
	CNewsGroupCore *p = m_pFirst;
	while (p != NULL && p->IsDeleted()) p = p->m_pNext;
	pFirst = p;
	m_LockTables.ShareUnlock();

	CGroupIterator*	pIterator = XNEW CGroupIterator(
												this,
												lpstrPattern, 
												pFirst,
												fIncludeSecureGroups,
												fIncludeSpecialGroups,
												pClientLogon,
												IsClientSecure,
												pClientSslLogon
												) ;

    return  pIterator ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\nntpdata.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nntpdata.cpp

Abstract:

    This module contains routines to initialize any global data

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include	"tigris.hxx"
#include    "smtpdll.h"

//
//	Vars to track global Init()'s
//
#define     FINIT_VAR( arg )    fSuccessfullInit ## arg

BOOL	FINIT_VAR( FileHandleCache ) = FALSE ;
BOOL    FINIT_VAR( CBuffer ) = FALSE ;
BOOL    FINIT_VAR( CPacket ) = FALSE ;
BOOL    FINIT_VAR( CIO ) = FALSE ;
BOOL    FINIT_VAR( CSessionSocket ) = FALSE ;
BOOL    FINIT_VAR( CChannel ) = FALSE ;
BOOL    FINIT_VAR( CIODriver ) = FALSE ;
BOOL    FINIT_VAR( CArticle ) = FALSE ;
BOOL    FINIT_VAR( CInFeed ) = FALSE ;
BOOL    FINIT_VAR( CSessionState ) = FALSE ;
BOOL	FINIT_VAR( CXoverIndex ) = FALSE ;
BOOL    FINIT_VAR( InitEncryption ) = FALSE ;
BOOL    FINIT_VAR( InitSecurity ) = FALSE ;
BOOL    FINIT_VAR( InitModeratedProvider ) = FALSE ;
BOOL    FINIT_VAR( XoverCacheLibrary ) = FALSE ;
BOOL    FINIT_VAR( NNTPHashLibrary ) = FALSE ;
BOOL    FINIT_VAR( IDirectoryNotification ) = FALSE ;
BOOL	FINIT_VAR( CNNTPVRootTable ) = FALSE;
BOOL    FINIT_VAR( InitAdminBase ) = FALSE ;

// globals
char	g_szSpecialExpireGroup[1024];

//
// Notification object used for watching changes in CAPI store
//
STORE_CHANGE_NOTIFIER *g_pCAPIStoreChangeNotifier;

//
// Function prototypes
//

BOOL
GetRegistrySettings(
            VOID
            );

APIERR
InitializeCPools();

VOID
TerminateCPools();

HRESULT
InitAdminBase();

VOID
UninitAdminBase();

void
TerminateSecurityGlobals();

BOOL
InitializeSecurityGlobals();

//
// Controls the level of debugging
//

DWORD DebugLevel = NNTP_DEBUG_FEEDMGR |
                    NNTP_DEBUG_REGISTRY |
                    NNTP_DEBUG_FEEDBLOCK;

DWORD NntpDebug;

//
//	Boolean controlling whether the server will generate the .err files !
//
BOOL	fGenerateErrFiles = TRUE ;

//
//	Global config of hash table use of PageEntry's -
//	The more RAM a box has, the more PageEntry's the
//	better the caching of frequently used hash table pages !
//
//	Number of PageEntry objects for the Xover table
//
DWORD	XoverNumPageEntry = 512 ;

//
//	Number of PageEntry objects for the Article table
//
DWORD	ArticleNumPageEntry = 256 ;

//
//	Number of PageEntry objects for the History table
//
DWORD	HistoryNumPageEntry = 128 ;

//
//	Number of Locks to use in various arrays of locks !
//
DWORD	gNumLocks = 64 ;

//
//	Used to determine how frequency of .xix sorting is related to
//	number of clients !
//
DWORD	gdwSortFactor = 5 ;

#if 0
//
//	Control what size buffers the server uses
//
DWORD	cbLargeBufferSize = 33 * 1024 ;
DWORD	cbMediumBufferSize = 4 * 1024 ;
DWORD	cbSmallBufferSize =  512 ;
#endif


DWORD	HistoryExpirationSeconds = DEF_EXPIRE_INTERVAL ;
DWORD	ArticleTimeLimitSeconds = DEF_EXPIRE_INTERVAL + SEC_PER_WEEK ;

//
//	Service version string
//
CHAR	szVersionString[128] ;

//
//	Time the newstree crawler threads before iterations over
//	the newstree - default - 30 minutes
//
DWORD	dwNewsCrawlerTime = 30 * 60 * 1000 ;

//
//	This is an upper bound on the time spent by the server in
//	cleaning up on net stop - default - 1 minute !
//
DWORD	dwShutdownLatency = 2 * 60 * 1000 ;

//
//	This is an upper bound on the time the server will wait
//	for an instance to start !
//
DWORD	dwStartupLatency = 2 * 60 * 1000 ;

//
//  Number of threads in expire thread pool
//
DWORD	dwNumExpireThreads = 4 ;

//
//  Number of special case expire threads
//
DWORD	gNumSpecialCaseExpireThreads = 4;

//
//  Article count threshold to trigger special case expire
//
DWORD	gSpecialExpireArtCount = 100 * 1000;

//
//  Amount of RAM to use for hash page-cache -
//  Passing in 0 to InitHashLib() lets hashmap
//  calculate a good default !
//
DWORD	dwPageCacheSize = 0 ;

//
//  Limit on file handle cache - default is 0
//  so we set sane limits !!
//
DWORD   dwFileHandleCacheSize = 0 ;

//
//  Limit on xix handles per table - default is 0
//  so we set sane limits !!
//
DWORD   dwXixHandlesPerTable = 0 ;

//
//	Do we allow NT to buffer our hash table files ??
//
BOOL	HashTableNoBuffering = FALSE ;

//
//  Rate at which expire by time does File scans
//
DWORD	gNewsTreeFileScanRate = 20 ;

//
//	Type of From: header to use in mail messages
//	mfNone		-	empty from header (default)
//	mfAdmin		-	AdminEmail name
//	mfArticle	-	Article From header
//
MAIL_FROM_SWITCH	mfMailFromHeader = mfNone;

//
// !!! Temporary
//

BOOL RejectGenomeGroups = FALSE;

//
//	Bool to determine whether we will honor a message-id in an article
//	posted by a client !
//
BOOL	gHonorClientMessageIDs = TRUE ;

//
//	Bool used to determine whether we will use a Date: a client puts
//	in his post !
//
BOOL	gHonorClientDateHeader = TRUE;

//
//	BOOL used to determine whether we will generate the NNTP-Posting-Host
//	header on client Posts. Default is to not generate this.
//
BOOL		gEnableNntpPostingHost = TRUE ;

//
//	Rate at which we poll vroot information to update CNewsGroup objects
//	(in minutes)
//
DWORD	gNewsgroupUpdateRate = 5 ;	// default - 5 minutes

//
//	Bool used to determine whether the server enforces Approved: header
//	matching on moderated posts !
//
BOOL	gHonorApprovedHeaders = TRUE ;

//
//  Shall we back fill the lines header during client post ?
//
BOOL    g_fBackFillLines = TRUE;

//
// DLL Module instance handles
//
HINSTANCE g_hLonsiNT = NULL;   // for lonsint.dll
BOOL    g_bLoadLonsiNT = FALSE;

//
// Coinit done
//
BOOL    g_fCoInited = FALSE;

//
// DLL Function pointers
//
// For lonsint.dll

GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName = NULL;

//
// Global impersonation token for process
//
HANDLE g_hProcessImpersonationToken = NULL;

//
// For debugging
//

DWORD numField = 0;
DWORD numArticle = 0;
DWORD numPCParse = 0;
DWORD numPCString = 0;
DWORD numDateField = 0;
DWORD numCmd = 0;
DWORD numFromPeerArt = 0;
DWORD numMapFile = 0;

//#define HEAP_INIT_SIZE  (KB * KB)

//
// Global heap handle
//
//HANDLE  g_hHeap;

APIERR
InitializeGlobals()
{

    //
    // CoInitialize here
    //
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if ( FAILED( hr ) && hr != CO_E_ALREADYINITIALIZED ) {
	    _ASSERT( 0 );
	    g_fCoInited = FALSE;
	    return ERROR_STATIC_INIT;
	}

    g_fCoInited = TRUE;

    APIERR error;
	MB mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    PCHAR args [1];

	MEMORYSTATUS	memStatus ;
	memStatus.dwLength = sizeof( MEMORYSTATUS ) ;
	GlobalMemoryStatus( &memStatus ) ;

	TraceFunctEnter("InitializeGlobals");

	//
	//	Initialize the file handle cache !
	//
	if( !InitializeCache() ) {
		return	ERROR_NOT_READY ;
	}
	FINIT_VAR( FileHandleCache ) = TRUE ;

	//
	// do global SEO initialization
	//
	hr = SEOGetServiceHandle(&(g_pNntpSvc->m_punkSEOHandle));
	if (FAILED(hr)) {
		_ASSERT(FALSE);
		// we're in trouble here.  we'll try and continue on, but server events
		// probably won't work right
		g_pNntpSvc->m_punkSEOHandle = NULL;
		NntpLogEvent(	SEO_INIT_FAILED,
						0,
						(const char **)NULL,
						hr
						);
	} else {
		//
		//  do any global server events registration that needs to exist
		//
		HRESULT hr = RegisterSEOService();
		if (FAILED(hr)) {
			ErrorTrace(0, "RegisterSEOService returned %x", hr);
			NntpLogEvent(	SEO_INIT_FAILED,
							0,
							(const char **)NULL,
							hr
							);
		} else {
			//
			// clean up any orphaned SEO sources related to NNTP
			//
			hr = UnregisterOrphanedSources();
			if (FAILED(hr)) {
				ErrorTrace(0, "UnregisterOrphanedSources returned %x", hr);
				NntpLogEvent(	SEO_INIT_FAILED,
								0,
								(const char **)NULL,
								hr
								);
			}
		}
	}

	//
	//	Initialize all global CPools
	//
	if( !InitializeCPools() ) {
        args[0] = "CPool init failed";
        goto error_exit;
	}

	//
	//	Get global reg settings
	//
    if (!GetRegistrySettings()){
        goto error_exit;
    }

    //
    //  Initialize global XOVER Cache
    //
    if( !XoverCacheLibraryInit( dwXixHandlesPerTable ) ) {
        args[0] = "Xover cache init failed";
        goto error_exit;
    }   else    {
        FINIT_VAR( XoverCacheLibrary ) = TRUE ;
    }

    if( !InitializeNNTPHashLibrary(dwPageCacheSize) )  {
        args[0] = "NNTP Hash init failed";
        goto error_exit;
    }   else    {
        FINIT_VAR( NNTPHashLibrary ) = TRUE ;
    }

    //
    // Initialize all the security related contexts
    //
    if ( !InitializeSecurityGlobals() ) {
        ErrorTrace( 0, "Initialize security globals failed %d",
                        GetLastError() );
        goto error_exit;
    }

    //
	//  Initialize SMTP provider interface for moderated newsgroups
    //
    if(!InitModeratedProvider())
    {
		ErrorTrace(0,"Failed to initialize moderated newsgroups provider");
		NntpLogEvent(	NNTP_INIT_MODERATED_PROVIDER,
						0,
						(const char **)NULL,
						0
						);
        // NOTE: failure to init moderated provider should not prevent service start
    }
    else
		FINIT_VAR( InitModeratedProvider ) = TRUE;

	hr = IDirectoryNotification::GlobalInitialize(DIRNOT_TIMEOUT,
		DIRNOT_MAX_INSTANCES, DIRNOT_INSTANCE_SIZE, StopHintFunction );
	if (FAILED(hr)) {
		ErrorTrace(0, "Failed to initialize directory notification");
		NntpLogEvent(	NNTP_INIT_DIRNOT_FAILED,
						0,
						(const char **)NULL,
						hr
						);
	} else {
		FINIT_VAR( IDirectoryNotification ) = TRUE;
	}

	// initialize exvroot.lib
	hr = CVRootTable::GlobalInitialize();
	if (FAILED(hr)) {
		ErrorTrace(0, "Failed to initialize vroot table");
		goto error_exit;
	} else {
		FINIT_VAR(CNNTPVRootTable) = TRUE;
	}

    //
    //  Initialize the IMSAdminBase object for MB access checks
    //
    hr = InitAdminBase();
	if (FAILED(hr)) {
		ErrorTrace(0, "Failed to initialize IMSAdminBaseW");
	} else {
		FINIT_VAR( InitAdminBase ) = TRUE;
	}

    return NO_ERROR;

error_exit:

	SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    error = GetLastError();
    NntpLogEvent(	NNTP_EVENT_OUT_OF_MEMORY,
					1,
                    (const char**)args,
					error
				   );

    return(error);

} // InitializeGlobals

VOID
TerminateGlobals()
{
	TraceFunctEnter("TerminateGlobals");

    StopHintFunction() ;

	//
	// do global SEO cleanup
	//
	if (g_pNntpSvc->m_punkSEOHandle != NULL) {
		g_pNntpSvc->m_punkSEOHandle->Release();
	}

	//
	//	Wait for global CPool alloc count on session socket objects
	//	to go to zero !
	//
	//	need to check Pool.GetAllocCount instead of InUseList.Empty
	//	because alloc goes to zero during the delete operator
	//	instead of during the destructor - this closes the window
	//	between the count going to zero and the destructor completing.
	//
	//

	DWORD   cSessions = CSessionSocket::gSocketAllocator.GetAllocCount() ;
	DWORD   j = 0;

	if( cSessions ) {
		Sleep( 1000 );
		StopHintFunction() ;
	}

	cSessions = CSessionSocket::gSocketAllocator.GetAllocCount() ;

	for( int i=0; cSessions && i<120; i++, j++ )
	{
		Sleep( 1000 );
		DebugTrace(0, "Shutdown sleep %d seconds. Count: %d", i,
					CSessionSocket::gSocketAllocator.GetAllocCount() );

		if( (j%10) == 0 ) {
			StopHintFunction() ;
		}

		//
		//  If we make progress, then reset i.  This will mean that the server
		//  wont stop until 2 minutes after we stop making progress.
		//
		DWORD   cSessionsNew = CSessionSocket::gSocketAllocator.GetAllocCount() ;
		if( cSessions != cSessionsNew ) {
			i = 0 ;
		}
		cSessions = cSessionsNew ;
	}

	_ASSERT( i<1200 );

    if( FINIT_VAR( XoverCacheLibrary ) ) {
        XoverCacheLibraryTerm() ;
    }


    if( FINIT_VAR( NNTPHashLibrary ) ) {
        TermNNTPHashLibrary() ;
    }

    //
    // Terminate all security stuff
    //
    TerminateSecurityGlobals();

    //
    // Terminate CPools
    //
	TerminateCPools();

    //
    // Terminate moderated newsgroups provider
    //
    if( FINIT_VAR( InitModeratedProvider ))
        TerminateModeratedProvider();

    StopHintFunction() ;

	// unload exvroot.lib
	if (FINIT_VAR(CNNTPVRootTable)) {
		CVRootTable::GlobalShutdown();
	}

    //
    //  Cleanup IMSAdminBaseW object
    //
    if( FINIT_VAR( InitAdminBase ) ) {
        UninitAdminBase();
    }

	if( FINIT_VAR( FileHandleCache ) ) {
		_VERIFY( TerminateCache() ) ;
	}

	//
	// If we have done co-init, de-init it
	//
	if ( g_fCoInited ) CoUninitialize();

    return;

} // TerminateGlobals

BOOL
GetRegistrySettings(
            VOID
            )
{
    DWORD error;
    HKEY key = NULL;
    DWORD i = 0;
    CHAR data[1024];
    DWORD valueType;
    DWORD dataSize;
	DWORD	dwNewsCrawler = 0 ;
	DWORD	cbBufferSize = 0 ;
	DWORD	dwLatency = 0 ;
	DWORD	dwData = 0 ;
	DWORD	Honor = 0 ;
	DWORD	dwExpire = 0 ;
    //DWORD	dwType ;
    //DWORD	dw ;

    ENTER("GetRegistrySettings")

    //
    // Open root key
    //

    error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                StrParmKey,
                NULL,
                KEY_QUERY_VALUE,
                &key
                );

    if ( error != NO_ERROR ) {
        ErrorTrace(0,"Error %d opening %s\n",error,StrParmKey);
        goto error_exit;
    }

	dataSize = sizeof( dwNewsCrawler ) ;
	error = RegQueryValueEx(
						key,
						StrNewsCrawlerTime,
						NULL,
						&valueType,
						(LPBYTE)&dwNewsCrawler,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	The registry entry is in minutes - convert to milliseconds
		//
		dwNewsCrawlerTime = dwNewsCrawler * 60 * 1000 ;

	}	else	{

		dwNewsCrawlerTime = 30 * 60 * 1000 ;

	}

	dataSize = sizeof( DWORD ) ;
	error = RegQueryValueEx(
						key,
						StrMailFromHeader,
						NULL,
						&valueType,
						(LPBYTE)&mfMailFromHeader,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Should be a valid switch
		//
		if( (mfMailFromHeader != mfNone) &&
				(mfMailFromHeader != mfAdmin) && (mfMailFromHeader != mfArticle)
				) {
			mfMailFromHeader = mfNone;
		}

	}	else	{

		mfMailFromHeader = mfNone;

	}

	dataSize = sizeof( dwLatency ) ;
	error = RegQueryValueEx(
						key,
						StrShutdownLatency,
						NULL,
						&valueType,
						(LPBYTE)&dwLatency,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	The registry entry is in minutes - convert to milliseconds
		//
		dwShutdownLatency = dwLatency * 60 * 1000 ;

	}	else	{

		dwShutdownLatency = 2 * 60 * 1000 ;

	}

	dataSize = sizeof( dwLatency ) ;
	error = RegQueryValueEx(
						key,
						StrStartupLatency,
						NULL,
						&valueType,
						(LPBYTE)&dwLatency,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	The registry entry is in minutes - convert to milliseconds
		//
		dwStartupLatency = dwLatency * 60 * 1000 ;

	}	else	{

		dwStartupLatency = 2 * 60 * 1000 ;

	}

	dataSize = sizeof( dwNumExpireThreads ) ;
	error = RegQueryValueEx(
						key,
						StrNumExpireThreads,
						NULL,
						&valueType,
						(LPBYTE)&dwNumExpireThreads,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Ensure that this does not exceed MAX_EXPIRE_THREADS
		//

	}	else	{

		dwNumExpireThreads = 4 ;
	}

	dataSize = sizeof( gNumSpecialCaseExpireThreads ) ;
	error = RegQueryValueEx(
						key,
						StrNumSpecialCaseExpireThreads,
						NULL,
						&valueType,
						(LPBYTE)&gNumSpecialCaseExpireThreads,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Cap the max at 16 !
		//
        if( gNumSpecialCaseExpireThreads > 16 ) {
            gNumSpecialCaseExpireThreads = 16;
        }

	}	else	{

        //  default !
		gNumSpecialCaseExpireThreads = 4 ;
	}

	dataSize = sizeof( gSpecialExpireArtCount ) ;
	error = RegQueryValueEx(
						key,
						StrSpecialExpireArtCount,
						NULL,
						&valueType,
						(LPBYTE)&gSpecialExpireArtCount,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	This should not be less than 100,000
		//
#if 0
        if( gSpecialExpireArtCount < 100*1000 ) {
            gSpecialExpireArtCount = 100*1000;
        }
#endif
	}	else	{

		gSpecialExpireArtCount = 100*1000;
	}

	dataSize = sizeof( data ) ;
	error = RegQueryValueEx(
						key,
						StrSpecialExpireGroup,
						NULL,
						&valueType,
						(LPBYTE)data,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_SZ) ) {

		//
		//	This should be the group native name
		//
        lstrcpy( g_szSpecialExpireGroup, data );
        _strlwr( g_szSpecialExpireGroup );

	}	else	{

		//
        //  default is control.cancel !
        //
        lstrcpy( g_szSpecialExpireGroup, "control.cancel" );
	}

	dataSize = sizeof( dwPageCacheSize ) ;
	error = RegQueryValueEx(
						key,
						StrPageCacheSize,
						NULL,
						&valueType,
						(LPBYTE)&dwPageCacheSize,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Units are in MB
		//
        dwPageCacheSize *= 1024*1024;

	}	else	{

		_ASSERT( dwPageCacheSize == 0 );
	}

	dataSize = sizeof( dwFileHandleCacheSize ) ;
	error = RegQueryValueEx(
						key,
						StrFileHandleCacheSize,
						NULL,
						&valueType,
						(LPBYTE)&dwFileHandleCacheSize,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {


	}	else	{

		_ASSERT( dwFileHandleCacheSize == 0 );
	}

	dataSize = sizeof( dwXixHandlesPerTable ) ;
	error = RegQueryValueEx(
						key,
						StrXixHandlesPerTable,
						NULL,
						&valueType,
						(LPBYTE)&dwXixHandlesPerTable,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {


	}	else	{

		_ASSERT( dwXixHandlesPerTable == 0 );
	}

#if 0		// X5:178268 (note that it's init to FALSE above)
	dataSize = sizeof( HashTableNoBuffering ) ;
	error = RegQueryValueEx(
						key,
						StrHashTableNoBuffering,
						NULL,
						&valueType,
						(LPBYTE)&HashTableNoBuffering,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

	}	else	{

		HashTableNoBuffering = FALSE ;

	}
#endif

	dataSize = sizeof( gNewsTreeFileScanRate ) ;
	error = RegQueryValueEx(
						key,
						StrNewsTreeFileScanRate,
						NULL,
						&valueType,
						(LPBYTE)&gNewsTreeFileScanRate,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

	}	else	{

		gNewsTreeFileScanRate = 20 ;
	}

	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,
						StrNewsVrootUpdateRate,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		gNewsgroupUpdateRate = dwData ;

	}	else	{

		gNewsgroupUpdateRate = 2 ;	// 2 minutes -

	}
	//
	//	Convert minutes to milliseconds
	//
	gNewsgroupUpdateRate *= 60 * 1000 ;

    //
    // reject genome?
    //

    dataSize = sizeof(RejectGenomeGroups);
    error = RegQueryValueEx(
                        key,
                        StrRejectGenome,
                        NULL,
                        &valueType,
                        (LPBYTE)data,
                        &dataSize
                        );

    if ( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
        RejectGenomeGroups = *((PDWORD)data);
    }

	cbBufferSize = 0 ;
	dataSize = sizeof( cbBufferSize ) ;
	error = RegQueryValueEx(
						key,
						StrSmallBufferSize,
						NULL,
						&valueType,
						(LPBYTE)&cbBufferSize,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		cbSmallBufferSize = cbBufferSize;
	}	else	{
		//	Default should already be set !
	}

	cbBufferSize = 0 ;
	dataSize = sizeof( cbBufferSize ) ;
	error = RegQueryValueEx(
						key,
						StrMediumBufferSize,
						NULL,
						&valueType,
						(LPBYTE)&cbBufferSize,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		cbMediumBufferSize = cbBufferSize;
	}	else	{
		//	Default should already be set !
	}

	cbBufferSize = 0 ;
	dataSize = sizeof( cbBufferSize ) ;
	error = RegQueryValueEx(
						key,
						StrLargeBufferSize,
						NULL,
						&valueType,
						(LPBYTE)&cbBufferSize,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		cbLargeBufferSize = cbBufferSize;
	}	else	{
		//	Default should already be set !
	}

	dataSize = sizeof( dwExpire ) ;
	error = RegQueryValueEx(
						key,
						StrHistoryExpiration,
						NULL,
						&valueType,
						(LPBYTE)&dwExpire,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		dwExpire *= SEC_PER_DAY ;
		HistoryExpirationSeconds = dwExpire ;

	}	else	{

		HistoryExpirationSeconds = DEF_EXPIRE_INTERVAL ;

	}


	dwExpire = 0 ;
	dataSize = sizeof( dwExpire ) ;
	error = RegQueryValueEx(
						key,
						StrArticleTimeLimit,
						NULL,
						&valueType,
						(LPBYTE)&dwExpire,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		ArticleTimeLimitSeconds = dwExpire *= SEC_PER_DAY ;

	}	else	{

		ArticleTimeLimitSeconds = HistoryExpirationSeconds + SEC_PER_WEEK ;

	}


	Honor = 0 ;
	dataSize = sizeof( Honor ) ;
	error = RegQueryValueEx(
						key,
						StrHonorClientMessageIDs,
						NULL,
						&valueType,
						(LPBYTE)&Honor,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		gHonorClientMessageIDs = (!!Honor) ;
	}	else	{
		//	Default should already be set !
	}

	dwData = TRUE;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,
						StrHonorClientDateHeader,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		gHonorClientDateHeader = !!dwData ;
	}	else	{
		//	Default should already be set !
	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,
						StrEnableNntpPostingHost,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	Since the string is called 'Enable' - a non-zero
		//	value in the registry will enable this header
		//
		gEnableNntpPostingHost = !(!dwData) ;
	}	else	{
		//	Default should already be set !
	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,
						StrGenerateErrFiles,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	Since the string is called 'Disable' - a non-zero
		//	value in the registry will disable newnews commands,
		//	but a 0 will allow them !
		//
		fGenerateErrFiles = !(!dwData) ;
	}	else	{
		//	Default should already be set !
	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,
						StrHonorApprovedHeader,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	Since the string is called 'Disable' - a non-zero
		//	value in the registry will disable newnews commands,
		//	but a 0 will allow them !
		//
		gHonorApprovedHeaders = BOOL(dwData) ;
	}	else	{
		//	Default should already be set !
	}

	//
	//	Compute defaults for the number of PageEntry objects we should use in the hash tables !
	//

	MEMORYSTATUS	memStatus ;
	memStatus.dwLength = sizeof( memStatus ) ;

	GlobalMemoryStatus( &memStatus ) ;

	//
	//	Now we know how much physical RAM the system has, so base PageEntry sizes on this !
	//	Note that each PageEntry will have a 4K page !
	//
	//

	if( memStatus.dwTotalPhys >= (30 * 1024 * 1024) ) {

		gNumLocks = 32 ;

		XoverNumPageEntry = 6 * 256 ;	// Uses 6MB ram
		ArticleNumPageEntry = 4 * 256 ;	// Uses 4 MB ram
		HistoryNumPageEntry = 1 * 256 ; // Uses 1 MB ram

	}

	if( memStatus.dwTotalPhys >= (60 * 1024 * 1024) ) {

		gNumLocks = 64 ;

		XoverNumPageEntry = 12 * 256 ;	// Uses 12 MB ram
		ArticleNumPageEntry = 8 * 256 ;	// Uses 8 MB ram
		HistoryNumPageEntry = 1 * 256 ; // Uses 1MB ram

	}

	if( memStatus.dwTotalPhys >= (120 * 1024 * 1024) ) {

		gdwSortFactor = 10 ;

		gNumLocks = 96 ;

		XoverNumPageEntry = 24 * 256 ; // Uses 24 MB ram
		ArticleNumPageEntry = 16 * 256 ; // Uses 16 MB ram
		HistoryNumPageEntry = 4 * 256 ;		// Uses 4 MB ram

	}

	if( memStatus.dwTotalPhys >= (250 * 1024 * 1024) ) {

		gdwSortFactor = 25 ;

		gNumLocks = 128 ;

		XoverNumPageEntry = 36 * 256 ; // Uses 36 MB ram
		ArticleNumPageEntry = 24 * 256 ; // Uses 24 MB ram
		HistoryNumPageEntry = 4 * 256 ; // Uses 4 MB ram

	}

	if( memStatus.dwTotalPhys >= (500 * 1024 * 1024) ) {

		gdwSortFactor = 40 ;

		gNumLocks = 256 ;

	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,
						StrArticlePageEntry,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	User specifies the size in MegaBytes ! so we do some math for them
		//	to generate the appropriate constant !
		//	Don't let them specify more than the physical RAM on the box !
		//
		if( dwData != 0 && (dwData * 256 < memStatus.dwTotalPhys) )
			ArticleNumPageEntry = dwData * 256 ;
	}	else	{
		//	Default should already be set !
	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,
						StrHistoryPageEntry,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	User specifies the size in MegaBytes ! so we do some math for them
		//	to generate the appropriate constant !
		//	Don't let them specify more than the physical RAM on the box !
		//
		if( dwData != 0 && (dwData * 256 < memStatus.dwTotalPhys) )
			HistoryNumPageEntry = dwData * 256 ;
	}	else	{
		//	Default should already be set !
	}

	dwData = 1 ;
	dataSize = sizeof( dwData ) ;
	error = RegQueryValueEx(
						key,
						StrXoverPageEntry,
						NULL,
						&valueType,
						(LPBYTE)&dwData,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	User specifies the size in MegaBytes ! so we do some math for them
		//	to generate the appropriate constant !
		//	Don't let them specify more than the physical RAM on the box !
		//
		if( dwData != 0 && (dwData * 256 < memStatus.dwTotalPhys) )
			XoverNumPageEntry = dwData * 256 ;
	}	else	{
		//	Default should already be set !
	}

    dwData = 1;
    dataSize = sizeof(dwData);
	error = RegQueryValueEx(    key,
	                            StrPostBackFillLines,
                                NULL,
                                &valueType,
                                (LPBYTE)&dwData,
                                &dataSize );
    if ( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) && dwData == 0) {
        //
        // User specifies not to back fill the lines header
        //
        g_fBackFillLines = FALSE;
    } else {
        //
        // when the value is set to 1 or wrongly set or not set, we'll back fill
        //
        g_fBackFillLines = TRUE;
    }

    RegCloseKey( key );

    LEAVE
    return(TRUE);

error_exit:

    if ( key != NULL) {
        RegCloseKey( key );
    }
    LEAVE
    return(FALSE);
}

APIERR
InitializeCPools()
{
	//
	//	Before we create and boot all instances, setup global cpools etc !
    //

    if( !CArticle::InitClass() )
        return  FALSE ;

    FINIT_VAR( CArticle ) = TRUE ;

    if( !CBuffer::InitClass() )
        return  FALSE ;

    FINIT_VAR( CBuffer ) = TRUE ;

    if( !CPacket::InitClass() )
        return  FALSE ;

    FINIT_VAR( CPacket ) = TRUE ;

    if( !CIO::InitClass() )
        return  FALSE ;

    FINIT_VAR( CIO ) = TRUE ;

    StartHintFunction() ;

    if( !CSessionSocket::InitClass() )
        return  FALSE ;

    FINIT_VAR( CSessionSocket ) = TRUE ;

    if( !CChannel::InitClass() )
        return  FALSE ;

    FINIT_VAR( CChannel ) = TRUE ;

    if( !CIODriver::InitClass() )
        return  FALSE ;

    FINIT_VAR( CIODriver ) = TRUE ;

    if( !CInFeed::InitClass() )
        return  FALSE ;

    FINIT_VAR( CInFeed ) = TRUE ;

    if( !CSessionState::InitClass() )
        return  FALSE ;

    FINIT_VAR( CSessionState ) = TRUE ;

	return TRUE;
}

VOID
TerminateCPools()
{
	//
	//	Shutdown global cpools !
	//
    if( FINIT_VAR( CSessionSocket ) ) {
        CSessionSocket::TermClass() ;
		FINIT_VAR( CSessionSocket ) = FALSE ;
	}

    if( FINIT_VAR( CIODriver ) ) {
        CIODriver::TermClass() ;
		FINIT_VAR( CIODriver ) = FALSE ;
	}

    if( FINIT_VAR( CChannel ) ) {
        CChannel::TermClass() ;
		FINIT_VAR( CChannel ) = FALSE ;
	}

    if( FINIT_VAR( CIO ) ) {
        CIO::TermClass() ;
		FINIT_VAR( CIO ) = FALSE ;
	}

    if( FINIT_VAR( CPacket ) ) {
        CPacket::TermClass() ;
		FINIT_VAR( CPacket ) = FALSE ;
	}

    if( FINIT_VAR( CBuffer ) ) {
        CBuffer::TermClass() ;
		FINIT_VAR( CBuffer ) = FALSE ;
	}

    if( FINIT_VAR( CArticle ) ) {
        CArticle::TermClass() ;
		FINIT_VAR( CArticle ) = FALSE ;
	}

    if( FINIT_VAR( CInFeed ) ) {
        CInFeed::TermClass() ;
		FINIT_VAR( CInFeed ) = FALSE ;
	}

    if( FINIT_VAR( CSessionState ) ) {
        CSessionState::TermClass() ;
		FINIT_VAR( CSessionState ) = FALSE ;
	}

}

BOOL
InitializeSecurityGlobals()
{
    TraceFunctEnter( "GetDLLEntryPoints" );
    HANDLE  hAccToken = NULL;

    // Initialize CEncryptCtx class
    if( !CEncryptCtx::Initialize( "NntpSvc",
    							  (struct IMDCOM*) g_pInetSvc->QueryMDObject(),
    							  (PVOID)&(g_pNntpSvc->m_smcMapContext ) ) ) {
        return  FALSE ;
	} else {
        FINIT_VAR( InitEncryption ) = TRUE ;
    }

    // Initialize CSecurityCtx class
    if( !CSecurityCtx::Initialize() ) {
        ErrorTrace( 0, "security init failed %d", GetLastError() );
        return FALSE;
    } else {
        FINIT_VAR( InitSecurity ) = TRUE;
    }

    // Load lonsint and get entry points to its funcs
    // Only when the image is not mapped do we explicitely
    // load it
    g_hLonsiNT = LoadLibrary( "lonsint.dll" );

    if ( g_hLonsiNT ) {
        g_bLoadLonsiNT = TRUE;
        pfnGetDefaultDomainName = (GET_DEFAULT_DOMAIN_NAME_FN)
            GetProcAddress( g_hLonsiNT, "IISGetDefaultDomainName" );
        if ( NULL == pfnGetDefaultDomainName ) {
            ErrorTrace( 0, "Get Proc IISGetDefaultDomainName Address failed %d",
                        GetLastError() );
            return FALSE;
        }
    } else {
        ErrorTrace( 0, "Load library lonsint.dll failed" );
        g_bLoadLonsiNT = FALSE;
        return FALSE;
    }

    // Get the process access token for system operations
    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
                            &hAccToken ) ) {
        ErrorTrace( 0, "Open Process token failed %d", GetLastError() );
        return FALSE;
    } else {
        // Dup the token to get an impersonation token
        _ASSERT( hAccToken );
        if ( !DuplicateTokenEx(   hAccToken,
                                  0,
                                   NULL,
                                  SecurityImpersonation,
                                  TokenImpersonation,
                                  &g_hProcessImpersonationToken ) ) {
            ErrorTrace( 0, "Duplicate token failed %d", GetLastError() );
            CloseHandle( hAccToken );
            return FALSE;
        }

        // Here we have got the right token
        CloseHandle( hAccToken );
     }

    //
    // Create the CAPI store notification object
    //
    g_pCAPIStoreChangeNotifier = XNEW STORE_CHANGE_NOTIFIER();
    if ( !g_pCAPIStoreChangeNotifier ) {
        ErrorTrace( 0, "Failed to create CAPIStoreChange notifier err: %u", GetLastError() );
        if ( GetLastError() == NO_ERROR )
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    return TRUE;
}

void
TerminateSecurityGlobals()
{
    // Terminate CEncryptCtx class
    if( FINIT_VAR( InitEncryption ) ) {
        CEncryptCtx::Terminate() ;
		FINIT_VAR( InitEncryption ) = FALSE ;
	}

    // Terminate CSecurity class
    if( FINIT_VAR( InitSecurity ) ) {
        CSecurityCtx::Terminate() ;
        FINIT_VAR( InitSecurity ) = FALSE;
    }

    // Unload lonsint.dll, if necessary
    if ( g_bLoadLonsiNT ) {
        _ASSERT( g_hLonsiNT );
        FreeLibrary( g_hLonsiNT );
        g_bLoadLonsiNT = FALSE;
    }

    // Close the process token
    if ( g_hProcessImpersonationToken ) {
        CloseHandle( g_hProcessImpersonationToken );
        g_hProcessImpersonationToken = NULL;
    }

    // Terminate CAPIStore notification object
    if ( g_pCAPIStoreChangeNotifier ) {
        XDELETE g_pCAPIStoreChangeNotifier;
        g_pCAPIStoreChangeNotifier = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\nntpsrvi.cpp ===
//
//  Copyright    (c)    1998        Microsoft Corporation
//
//  Module Name:
//
//       nntpsrv.cpp
//
//  Abstract:
//
//		This module implements the INntpServer interface
//
//  Author:
//
//      Alex Wetmore
//
//  Revision History:

#include "tigris.hxx"

DWORD
CNntpServer::QueryServerMode()
/*++
Routine description:

    Get the server mode, whether it's in normal state, or rebuild
    state.  If it's in rebuild state, in what rebuild type ?

Arguments:

    None.

Return value:

    NNTP_SERVER_NORMAL/NNTP_SERVER_STANDARD_REBUILD/NNTP_SERVER_
--*/
{
    TraceFunctEnter( "CNntpServer::QueryServerMode" );
    DWORD   dwMode;

    if ( m_pInstance->m_BootOptions ) {

        if ( NNTPBLD_DEGREE_STANDARD == m_pInstance->m_BootOptions->ReuseIndexFiles )
            dwMode = NNTP_SERVER_STANDARD_REBUILD;
        else 
            dwMode = NNTP_SERVER_CLEAN_REBUILD;
    } else 
        dwMode = NNTP_SERVER_NORMAL;

    TraceFunctLeave();
    return dwMode;
}

BOOL
CNntpServer::SkipNonLeafDirWhenRebuild()
/*++
Routine description:

    Tells the client whether should skip non-leaf dir during rebuild

Arguments:

    None.

Return value:

    TRUE, should skip, FALSE otherwise
--*/
{
    return m_pInstance->m_BootOptions->OmitNonleafDirs;
}

BOOL
CNntpServer::ShouldContinueRebuild()
/*++
Routine description:

    Tells if anybody has cancelled the rebuild ?

Arguments:

    None.

Return value:

    TRUE, yes you should continue; FALSE otherwise
--*/
{
    return ( m_pInstance->m_BootOptions->m_dwCancelState != NNTPBLD_CMD_CANCEL_PENDING 
            && g_pInetSvc->QueryCurrentServiceState() != SERVICE_STOP_PENDING);
}

BOOL
CNntpServer::MessageIdExist( LPSTR szMessageId )
/*++
Routine description:

    Does this message id exist in the server article table ?

Arguments:

    LPSTR szMessageId - Message id to check

Return value:

    TRUE if exists, FALSE otherwise
--*/
{
    return m_pInstance->ArticleTable()->SearchMapEntry( szMessageId );
}

void
CNntpServer::SetRebuildLastError( DWORD err )
/*++
Routine description:

    Set the last error happened during rebuild

Arguments:

    DWORD dw - Last error

Return value:

    None.
--*/
{
    m_pInstance->SetRebuildLastError( err );
}

//
// find the primary groupid/articleid for an article given the secondary
// groupid/articleid
//
// arguments:
//  pgroupSecondary - the property bag for the secondary crosspost
//  artidSecondary - the article ID for the secondary crosspost
//  ppgroupPrimary - gets filled in with the property bag for the primary
//                   crosspost.  the caller should Release() this when
//                   they are done with it.
//  partidPrimary - the article id for the primary crosspost
//
// returns:
//  S_OK - found primary
//  S_FALSE - the values given were the primary
//  or an error code
//
void CNntpServer::FindPrimaryArticle(INNTPPropertyBag *pgroupSecondary,
                           			 DWORD   		  artidSecondary,
                           			 INNTPPropertyBag **ppgroupPrimary,
                           			 DWORD   		  *partidPrimary,
									 BOOL			  fStorePrimary,
									 INntpComplete    *pComplete,
									 INntpComplete    *pProtocolComplete )
{
	_ASSERT(m_pInstance != NULL);
	_ASSERT(ppgroupPrimary != NULL);
	_ASSERT(pgroupSecondary != NULL);
	_ASSERT(partidPrimary != NULL);
	if (pgroupSecondary == NULL || 
		ppgroupPrimary == NULL || 
		partidPrimary == NULL) 
	{
		pComplete->SetResult(E_INVALIDARG);
		pComplete->Release();
		return;
	}

	CXoverMap *pMap = m_pInstance->XoverTable();
	_ASSERT(pMap != NULL);
	if (pMap == NULL) {
		pComplete->SetResult(E_UNEXPECTED);
		pComplete->Release();
		return;
	}

	// get the secondary group id from the property bag
	DWORD groupidSecondary;
	HRESULT hr;
	hr = pgroupSecondary->GetDWord(NEWSGRP_PROP_GROUPID,
							       &groupidSecondary);
	if (FAILED(hr)) {
		pComplete->SetResult(hr);
		pComplete->Release();
		return;
	}

	// do the lookup
	DWORD groupidPrimary, artidPrimary;
	GROUP_ENTRY rgCrossposts[MAX_NNTPHASH_CROSSPOSTS];
	BYTE rgcStoreCrossposts[MAX_NNTPHASH_CROSSPOSTS];
	DWORD cGrouplistSize = sizeof(GROUP_ENTRY) * MAX_NNTPHASH_CROSSPOSTS;
	DWORD cGroups;

	if (!pMap->GetArticleXPosts(groupidSecondary,
								artidSecondary,
								FALSE,
								rgCrossposts,
								cGrouplistSize,
								cGroups,
								rgcStoreCrossposts))
	{
		pComplete->SetResult(HRESULT_FROM_WIN32(GetLastError()));
		pComplete->Release();
		return;
	}

	if (fStorePrimary) {
		// find the primary article for the store containing groupidSecondary.
		// we do this by scanning the crosspost list and keeping track of the
		// current store primary at any point in the list.  when we find
		// groupidSecondary in the list we will also know where its primary
		// is and can return that.
		DWORD i;				// current position in rgCrossposts
		DWORD iStorePrimaryPos = 0;	// position of current primary in rgCrossposts
		DWORD iStore;			// position in rgcStoreCrossposts
		DWORD cCrossposts;		// total of rgcStoreCrossposts to index iStore

		iStore = 0;
		cCrossposts = rgcStoreCrossposts[iStore];

		artidPrimary = -1;

		for (i = 0; artidPrimary == -1 && i < cGroups; i++) {
			if (i == cCrossposts) {
				iStore++;
				iStorePrimaryPos = i;
				cCrossposts += rgcStoreCrossposts[iStore];
			}
			if (rgCrossposts[i].GroupId == groupidSecondary) {
				_ASSERT(rgCrossposts[i].ArticleId == artidSecondary);
				groupidPrimary = rgCrossposts[iStorePrimaryPos].GroupId;
				artidPrimary = rgCrossposts[iStorePrimaryPos].ArticleId;
				break;
			}
		}
		_ASSERT(artidPrimary != -1);
		if (artidPrimary == -1) {
			// we aren't int he list of crossposts.  return the primary
			groupidPrimary = rgCrossposts[0].GroupId;
			artidPrimary = rgCrossposts[0].ArticleId;
		}
	} else {
		groupidPrimary = rgCrossposts[0].GroupId;
		artidPrimary = rgCrossposts[0].ArticleId;
	}

	// get the group property bag for the primary group
	CGRPPTR pGroup = m_pInstance->GetTree()->GetGroupById(groupidPrimary);
	if (pGroup == NULL) {
		// this should never happen with properly in-sync hash tables.  
		// BUGBUG - should we remove this entry from the hashtable?
		//_ASSERT(FALSE);
		pComplete->SetResult(HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
		pComplete->Release();
		return;
	}

	*ppgroupPrimary = pGroup->GetPropertyBag();
#ifdef DEBUG
	if ( pProtocolComplete ) ((CNntpComplete*)pProtocolComplete)->BumpGroupCounter();
#endif
	*partidPrimary = artidPrimary;

	_ASSERT((groupidPrimary == groupidSecondary && artidPrimary == artidSecondary) ||
			(groupidPrimary != groupidSecondary));

	pComplete->SetResult((groupidPrimary == groupidSecondary) ? S_OK : S_FALSE);
	pComplete->Release();
}

//
// Create the entries in the hash tables for a new article.
//
void CNntpServer::CreatePostEntries(char				*pszMessageId,
					   			    DWORD				cHeaderLength,
					   			    STOREID				*pStoreId,
					   			    BYTE				cGroups,
					   			    INNTPPropertyBag	**rgpGroups,
					   			    DWORD				*rgArticleIds,
					   			    BOOL                fAllocArtId,
					   			    INntpComplete		*pCompletion)
{

	TraceQuietEnter("CNntpServer::CreatePostEntries");

	_ASSERT(pszMessageId != NULL);
	_ASSERT(pStoreId != NULL);
	_ASSERT(cGroups > 0);
	_ASSERT(rgpGroups != NULL);
	_ASSERT(rgArticleIds != NULL);
	_ASSERT(pCompletion != NULL);


    CArticleRef articleRef;

	if (pszMessageId == NULL || pStoreId == NULL ||
		cGroups == 0 || rgpGroups == NULL || rgArticleIds == NULL ||
		pCompletion == NULL)
	{
		pCompletion->SetResult(E_INVALIDARG);
		pCompletion->Release();
		return;
	}

	char rgchBuffer[4096];
	CAllocator allocator(rgchBuffer, 4096);
	CNEWSGROUPLIST grouplist;
	CNAMEREFLIST namereflist;

	if (!grouplist.fInit(cGroups, &allocator) || !namereflist.fInit(cGroups, &allocator)) {
		pCompletion->SetResult(E_OUTOFMEMORY);
		pCompletion->Release();
		return;
	}

	// allocate article ids for each of the groups
	DWORD i = 0;
	for (i = 0; i < cGroups; i++) {
		CNewsGroupCore *pGroup = ((CNNTPPropertyBag *) rgpGroups[i])->GetGroup();
		CPostGroupPtr PostGroupPtr(pGroup);
		grouplist.AddTail(PostGroupPtr);

		NAME_AND_ARTREF Nameref;
		(Nameref.artref).m_groupId = pGroup->GetGroupId();
		if ( fAllocArtId ) 
		    (Nameref.artref).m_articleId = pGroup->AllocateArticleId();
		else (Nameref.artref).m_articleId = rgArticleIds[i];
		(Nameref.pcName).vInsert(pGroup->GetNativeName());
		namereflist.AddTail(Nameref);

		if ( fAllocArtId ) rgArticleIds[i] = (Nameref.artref).m_articleId;

        // Save off the first group/article ID for use by AddArticleToPushFeeds
		if (i == 0) {
		    articleRef.m_groupId = (Nameref.artref).m_groupId;
		    articleRef.m_articleId = (Nameref.artref).m_articleId;
		}
	}

	CPCString pcXOver;

	CNntpReturn ret2;
	BOOL f = m_pInstance->ArticleTable()->InsertMapEntry(pszMessageId);
	if (!f) {
		ErrorTrace((DWORD_PTR)this, "InsertMapEntry failed, %x", GetLastError());
	} else {
		f = gFeedManfPost(m_pInstance->GetInstanceWrapper(),
						  grouplist,
						  namereflist,
						  NULL,
						  FALSE,
						  NULL,
						  (CStoreId *) pStoreId,
						  &cGroups,
						  1,
						  pcXOver,
						  ret2,
						  -3,
						  pszMessageId,
						  (WORD) cHeaderLength);
		if (f) {
            // We only want to add articles to the push feed if we're not
            // doing a rebuild.
            if (QueryServerMode() == NNTP_SERVER_NORMAL) {
		        if (!m_pInstance->GetInstanceWrapper()->AddArticleToPushFeeds(
				    grouplist,
					articleRef,
					NULL,
					ret2))
			    {
			    	ErrorTrace((DWORD_PTR)this, "AddArticleToPushFeeds failed, %x", GetLastError());
			    }
			}
        } else {
			ErrorTrace((DWORD_PTR)this, "gFeedManfPost failed, %x", GetLastError());
		}
	}

	if (!f) {
	    if (GetLastError() == ERROR_ALREADY_EXISTS)
	        pCompletion->SetResult(S_FALSE);
        else
		    pCompletion->SetResult(E_OUTOFMEMORY);
	} else {
		pCompletion->SetResult(S_OK);
	}

	pCompletion->Release();
	return;
}

void CNntpServer::AllocArticleNumber(BYTE				cGroups,
					   			    INNTPPropertyBag	**rgpGroups,
					   			    DWORD				*rgArticleIds,
					   			    INntpComplete		*pCompletion)
{
	_ASSERT(cGroups > 0);
	_ASSERT(rgpGroups != NULL);
	_ASSERT(rgArticleIds != NULL);
	_ASSERT(pCompletion != NULL);

	if (cGroups == 0 || rgpGroups == NULL || rgArticleIds == NULL ||
		pCompletion == NULL)
	{
		pCompletion->SetResult(E_INVALIDARG);
		pCompletion->Release();
		return;
	}

	// allocate article ids for each of the groups
	DWORD i = 0;
	for (i = 0; i < cGroups; i++) {
		CNewsGroupCore *pGroup = ((CNNTPPropertyBag *) rgpGroups[i])->GetGroup();
		if (pGroup == NULL) {
			pCompletion->SetResult(E_INVALIDARG);
			pCompletion->Release();
			return;
		}
		rgArticleIds[i] = pGroup->AllocateArticleId();
	}

	pCompletion->SetResult(S_OK);
	pCompletion->Release();
	return;
}

void
CNntpServer::DeleteArticle(
    char            *pszMessageId,
    INntpComplete   *pCompletion
    )
//
// Delete Article entries from hash table
//
{
    _ASSERT(m_pInstance != NULL);

    //
    // Confirm that the article is not in the table
    //

    WORD	HeaderOffset ;
    WORD	HeaderLength ;
    ARTICLEID ArticleNo;
    GROUPID GroupId;
    CStoreId storeid;

    //
    // Look for the article. It is OK if there is none.
    //
    if (!(m_pInstance->ArticleTable())->GetEntryArticleId( pszMessageId, 
                                                           HeaderOffset,
                                                           HeaderLength,
                                                           ArticleNo, 
                                                           GroupId,
                                                           storeid) )
    {
        if (ERROR_FILE_NOT_FOUND == GetLastError())
        {
		    pCompletion->SetResult(ERROR_FILE_NOT_FOUND);
        } else {
		    pCompletion->SetResult(E_INVALIDARG);
        }
		pCompletion->Release();
        return;
    }

    CNntpReturn ret2;
    //  Delete article out of hash table
    if ( ! (m_pInstance->ExpireObject()->ExpireArticle( m_pInstance->GetTree(), 
                                                        GroupId, 
                                                        ArticleNo, 
                                                        &storeid, 
                                                        ret2, 
                                                        NULL, 
                                                        TRUE,   //fMustDelete
                                                        FALSE, 
                                                        FALSE )))
    {
        pCompletion->SetResult(GetLastError());
    } else {
        pCompletion->SetResult(S_OK);
    }

    pCompletion->Release();
    return;
}

BOOL CNntpServer::IsSlaveServer(
    WCHAR*              pwszPickupDir,
    LPVOID              lpvContext
    )
{
    if (pwszPickupDir) {
        LPWSTR  pwsz = m_pInstance->QueryPickupDirectory();
        if (pwsz) {
            wcscpy(pwszPickupDir, pwsz);
        }
    }

    return (m_pInstance->m_ConfiguredMasterFeeds > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\nntpinst.inl ===
#if 0
inline
BOOL NNTP_IIS_SERVICE::AcquireEnumLock()
{
	InterlockedIncrement( &m_lEnumLock );
	if( QueryServiceState() == SERVICE_STOP_PENDING ) {
		InterlockedDecrement( &m_lEnumLock );
		return FALSE ;
	}

	return TRUE ;
}

inline 
VOID NNTP_IIS_SERVICE::ReleaseEnumLock()
{
	InterlockedDecrement( &m_lEnumLock );
}

inline
BOOL NNTP_IIS_SERVICE::AcquireEnumLockExclusive()
{
	if( InterlockedIncrement( &m_lEnumLock ) == 0 ) {
		return TRUE ;
	}

	InterlockedDecrement( &m_lEnumLock );
	return FALSE ;
}

inline 
VOID NNTP_IIS_SERVICE::ReleaseEnumLockExclusive()
{
	InterlockedDecrement( &m_lEnumLock );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\nntpsrvi.h ===
//
//  Copyright    (c)    1998        Microsoft Corporation
//
//  Module Name:
//
//      nntpsrvi.h
//
//  Abstract:
//
//		Defines CNntpServer, which implements the INntpServer interface
//
//  Author:
//
//      Alex Wetmore
//
//  

class NNTP_SERVER_INSTANCE;

class CNntpServer : public INntpServer {
	private:
	    //
	    // Pointer to the newsgroup object
	    //
	    NNTP_SERVER_INSTANCE *m_pInstance;
	
	    //
	    // Reference counting
	    //
	    LONG   m_cRef;

	public:
	    //
	    // Constructors
	    //
	    CNntpServer(NNTP_SERVER_INSTANCE *pInstance) {
	        m_pInstance = pInstance;
	        m_cRef = 1;
	    }

	public:
		//
		// INntpServer ----------------------------------------------------
		//

		//
		// find the primary groupid/articleid for an article given the secondary
		// groupid/articleid
		//
		// returns:
		//  S_OK - found primary
		//  S_FALSE - the values given were the primary
		//  otherwise error
		//
		void __stdcall FindPrimaryArticle(INNTPPropertyBag *pgroupSecondary,
		                   				  DWORD   		  artidSecondary,
		                   				  INNTPPropertyBag **pgroupPrimary,
		                   				  DWORD   		  *partidPrimary,
		                   				  BOOL              fInStore,
										  INntpComplete    *pComplete,
										  INntpComplete    *pProtocolComplete = NULL );

		//
		// Create the entries in the hash tables for a new article.
		//
		void __stdcall CreatePostEntries(char				*pszMessageId,
							   			 DWORD				iHeaderLength,
							   			 STOREID			*pStoreId,
							   			 BYTE				cGroups,
							   			 INNTPPropertyBag	**rgpGroups,
							   			 DWORD				*rgArticleIds,
							   			 BOOL               fAllocArtId,
							   			 INntpComplete		*pCompletion);	


        //
        // Delete article out of the hash table
        //
        void __stdcall DeleteArticle( char            *pszMessageId,
                                      INntpComplete   *pCompletion );

        //
        // This tells the driver what rebuild mode the server is in
        // The returned value should be NNTP_SERVER_NORMAL, NNTP_SERVER
        // _STANDARD_REBUILD or NNTP_SERVER_CLEAN_REBUILD
        //
        DWORD __stdcall QueryServerMode();

        //
        // Tells whether should skip non-leaf dir during rebuild
        //
        BOOL __stdcall SkipNonLeafDirWhenRebuild();

        //
        // Has anybody cancelled the rebuild ?
        //
        BOOL __stdcall ShouldContinueRebuild();

        //
        // Does this message id exist in article table ?
        //
        BOOL __stdcall MessageIdExist( LPSTR szMessageId );

        //
        // Set the rebuild last error to server
        //
        void __stdcall SetRebuildLastError( DWORD err );
        

        //
        // Obtain article number for each newsgroups.
        //
        void __stdcall AllocArticleNumber(  BYTE                cGroups,
                                            INNTPPropertyBag    **rgpGroups,
                                            DWORD               *rgArticleIds,
                                            INntpComplete       *pCompletion);

        //
        // Return whether this is a Slave server, and the pickup dir
        //
        BOOL __stdcall IsSlaveServer( WCHAR*          pwszPickupDir,
                                      LPVOID          lpvContext );

		//
	    // IUnknown ------------------------------------------------------
		//
	    HRESULT __stdcall QueryInterface(const IID& iid, VOID** ppv) {
	        if (iid == IID_IUnknown) {
	            *ppv = static_cast<IUnknown*>(this);
	        } else if (iid == IID_INntpServer) {
	            *ppv = static_cast<INntpServer*>(this);
	        } else {
	            *ppv = NULL;
	            return E_NOINTERFACE;
	        }
	        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	        return S_OK;
	    }

	    ULONG __stdcall AddRef() {
			return InterlockedIncrement(&m_cRef);
	    }
	
	    ULONG __stdcall Release() {
	        if ( InterlockedDecrement(&m_cRef) == 0 ) {
				// we should never hit zero because the instance creates 
				// us and should always have one reference
	            _ASSERT( 0 );
	        }
	
	        return m_cRef;
	    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\outfeed.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    outfeed.cpp

Abstract:

    This module contains definition for the COutFeed base class
	and related functions

Author:

    Carl Kadie (CarlK)     23-Jan-1996

Revision History:

--*/

#include	<stdlib.h>
#include "tigris.hxx"

BOOL
IsServerInPath(	LPSTR	lpstrServer,	LPMULTISZ	multiszPath ) {

	LPSTR	lpstrCurrent = multiszPath ;
	while( *lpstrCurrent != '\0' ) {
		if( lstrcmpi( lpstrServer, lpstrCurrent ) == 0 ) {
			return	TRUE ;
		}
		lpstrCurrent += lstrlen( lpstrCurrent ) + 1 ;
	}
	return	FALSE ;
}


BOOL
fAddArticleToPushFeeds(
					   PNNTP_SERVER_INSTANCE pInstance,
					   CNEWSGROUPLIST& newsgroups,
					   CArticleRef artrefFirst,
					   char * multiszPath,
					   CNntpReturn & nntpReturn
    )
{

	NRC	nrc = nrcOK ;

	TraceFunctEnter( "fAddArticleToPushFeeds" ) ;

	StateTrace( DWORD(0), "Matching Article GRP %d ART %d path %s", 
		artrefFirst.m_groupId, artrefFirst.m_articleId,	multiszPath ) ;

	for( PFEED_BLOCK	feedBlock = pInstance->m_pActiveFeeds->StartEnumerate();
			feedBlock != 0; 
			feedBlock = pInstance->m_pActiveFeeds->NextEnumerate( feedBlock ) ) {

		if( feedBlock->pFeedQueue != 0 ) {
			char * multiszPattern = *(feedBlock->Newsgroups);

			if (MatchGroupList(multiszPattern, newsgroups))	 {

				_ASSERT( feedBlock->UucpName != 0 ) ;

				if( FEED_IS_SLAVE(feedBlock->FeedType) || 
					multiszPath == 0 || 
					!MultiSzIntersect( feedBlock->UucpName, multiszPath ) ) {

					StateTrace( DWORD(0), "Attempting to add GRP %d ART %d to feed %s %x", 
						artrefFirst.m_groupId, artrefFirst.m_articleId, 
						feedBlock->KeyName, feedBlock ) ;

					if (!feedBlock->pFeedQueue->Append(artrefFirst.m_groupId, artrefFirst.m_articleId))	{
						nrc = nrcCantAddToQueue ;
						pInstance->m_pActiveFeeds->FinishEnumerate( feedBlock ) ;

						// bug bug ... if an error occurs we should probably remove
						// the feedBlock from the list and continue processing !				
						break ;
					}
				}
			}
		}

    }

    return nntpReturn.fSet( nrc );

}

/*++
	
	MatchGroupList -
		
	True if at least one group matches the pattern

--*/
BOOL
MatchGroupList(
			   char * multiszPatterns,
			   CNEWSGROUPLIST& newsgroups
			   )
{

	TraceFunctEnter( "MatchGroupList" ) ;

		//
		// For each newsgroup ...
		//

		POSITION	pos = newsgroups.GetHeadPosition() ;
		while( pos  )
		{
			CPostGroupPtr *pPostGroupPtr = newsgroups.GetNext(pos);
			CGRPCOREPTR * ppGroup = &(pPostGroupPtr->m_pGroup);

			//
			//  See if this newsgroup matches the pattern
			//

			if (MatchGroup(multiszPatterns, (* ppGroup)->GetName()))	{

				StateTrace( DWORD(0), "Pattern %s matches group %s", multiszPatterns, (*ppGroup)->GetName() ) ;

				return TRUE;
			}

		}

	StateTrace( DWORD(0), "No match for article" ) ;

	return FALSE;
}

BOOL
COutFeed::fInit(	PVOID			feedCompletionContext ) {

	_ASSERT(	ifsUninitialized == m_feedState ) ;
	m_feedState = ifsUninitialized ;
	m_feedCompletionContext = feedCompletionContext ;

	return	TRUE ;
}	

BOOL
COutToSlaveFeed::RetryPost(	NRC	nrcCode ) {

	if( nrcCode != nrcArticleTransferredOK && nrcCode != nrcArticlePostedOK )	{
		if( nrcCode == nrcTransferFailedTryAgain ) {
			return	TRUE ;
		}	else if( nrcCode == nrcTransferFailedGiveUp ) {
			return	FALSE ;
		}	else	{

			//
			//	Some other kind of wierd error occurred - give up !
			//
			return	FALSE ;
		}


	}					

	return	FALSE ;
}

int
COutToSlaveFeed::FormatCommand(	
							BYTE*		lpb,	
							DWORD		cb,	
							DWORD&		ibStart,
							GROUPID		groupid,
							ARTICLEID	articleid,
							CTOCLIENTPTR&	pArticle 
							)	{


	static	char	szXReplic[] = "xreplic " ;
	ibStart = 0 ;

	//
	//	We need to get a hold of the groupid's and articleid's for this article.
	//	We will use the end of the buffer in which we are to generate our string
	//	as scratch space.  We start by assuming that there aren't more than 10 entires
	//	if that fails we will use a larger portion of our buffer as scrach space !
	//


	DWORD			cGroups = 10 ;
	DWORD			cbGroupList = sizeof( GROUP_ENTRY ) * cGroups ;
	DWORD			cbAvailable = cb - cbGroupList ;

	PGROUP_ENTRY	pEntries = (PGROUP_ENTRY)(lpb + cbAvailable) ;
	
	if( !m_pInstance->XoverTable()->GetArticleXPosts(	
										groupid, 
										articleid,
										FALSE,
										pEntries, 
										cbGroupList,
										cGroups ) )		{

		if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

			_ASSERT( cbGroupList > 10 * sizeof( GROUP_ENTRY ) ) ;
		
			if( cbGroupList > cb ) {

				return 0 ;
			
			}	else	{

				cbAvailable = cb - cbGroupList ;
				pEntries = (PGROUP_ENTRY)(lpb + cbAvailable) ;

				if( !m_pInstance->XoverTable()->GetArticleXPosts(	
													groupid,	
													articleid,
													FALSE,
													pEntries, 
													cbGroupList,
													cGroups ) )	{
					return	0 ;
				
				}	

			}
		}	else	{

			return	0 ;

		}
	}

	//
	//	If we reach here we are ready to produce the command line !
	//

	if( cbAvailable > sizeof( szXReplic ) )	{

		CopyMemory(	lpb,	szXReplic, sizeof( szXReplic ) - 1 ) ;
		cbAvailable -= (sizeof( szXReplic ) - 1) ;
		DWORD	ibCopy = sizeof( szXReplic ) - 1 ;
		CGRPPTR	pGroup ;
		CNewsTree*	ptree = m_pInstance->GetTree() ;

		for( DWORD i=0; i < cGroups; i++ ) {

			pGroup = ptree->GetGroupById( pEntries[i].GroupId ) ;

			//
			//	Separate arguments with comma's
			//
			if( i != 0 ) {
				lpb[ibCopy++] = ',' ;
				cbAvailable -- ;
			}

			if( pGroup == 0 ) {

				return 0 ;

			}	else	{
				
				LPSTR	lpstrName = pGroup->GetNativeName() ;
				DWORD	cbName = lstrlen( lpstrName ) ;
				//
				//	Test for room for newsgroup name and digits and CRLF !!!
				//
				if( ibCopy+cbName+19 > cbAvailable )	{
					SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
					return	0 ;
				}

				CopyMemory( lpb+ibCopy, lpstrName, cbName ) ;
				ibCopy += cbName ;
				lpb[ibCopy++] = '/' ;
				_itoa( pEntries[i].ArticleId, (char*)lpb+ibCopy, 10 ) ;
				ibCopy += lstrlen( (char*)lpb+ibCopy ) ;
			}
		}

		if( ibCopy+2 < cbAvailable ) {
			lpb[ibCopy++] = '\r' ;
			lpb[ibCopy++] = '\n' ;

			CNewsTree*	ptree = m_pInstance->GetTree() ;
			pGroup = ptree->GetGroupById( groupid ) ;	
			if( pGroup != 0 ) {
				CStoreId	storeid ;
				FILETIME	ft ;
				BOOL		fPrimary ;
				WORD		HeaderOffset ;
				WORD		HeaderLength ;
				DWORD cStoreIds = 1;
				DWORD	DataLen = 0 ;
				if( m_pInstance->XoverTable()->ExtractNovEntryInfo(
										groupid, 
										articleid, 
										fPrimary, 
										HeaderOffset, 
										HeaderLength, 
										&ft, 
										DataLen, 
										0,
										cStoreIds,
										&storeid,
										NULL))	{
					_ASSERT( fPrimary ) ;
					pArticle = pGroup->GetArticle(	
										articleid, 
										storeid,
										0, 
										0, 
										TRUE
										) ;
				}

			}

			if( pArticle != 0 )	{
				return	ibCopy ;
			}
			SetLastError( ERROR_FILE_NOT_FOUND ) ;
		}

	}	else	{

		SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;

	}

	return	0 ;
}

BOOL
COutToMasterFeed::RetryPost(	NRC		nrcCode )	{

	if(	nrcCode != nrcArticleTransferredOK && nrcCode != nrcArticlePostedOK ) {
		if( nrcCode == nrcPostingNotAllowed ) {
			return	TRUE ;
		}
	}

	return	FALSE ;
}

int
COutToMasterFeed::FormatCommand(	
							BYTE*		lpb,
							DWORD		cb,
							DWORD&		ibStart,
							GROUPID		groupid,
							ARTICLEID	articleid,
							CTOCLIENTPTR&	pArticle 
							)	{

#if 0 
	static	char	szPost[] = "post\r\n" ;

	CopyMemory( lpb, szPost, sizeof( szPost ) -1 ) ;
	ibStart = 0 ;
	return	sizeof( szPost ) - 1 ;
#endif
	ibStart = 0 ;

	DWORD	ibData = 0 ;
	CNewsTree*	ptree = m_pInstance->GetTree() ;

	CGRPPTR		pGroup = ptree->GetGroupById( groupid ) ;	
	if( pGroup != 0 ) {

		//
		//	bugbug ... last parameter to GetArticle should be based on whether
		//	we're using an SSL session - however at the time of writing SSL
		//	feeds weren't supported, so TRUE is safe !
		//
#ifndef	BUGBUG
		pArticle = 0 ;
#else
		pArticle = pGroup->GetArticle(	
								articleid, 
								storeid,
								0, 
								0, 
								TRUE
								) ;
#endif

		if( pArticle != 0 ) {

			static	char	szIHave[] = "ihave " ;
			CopyMemory( lpb, szIHave, sizeof( szIHave ) - 1 ) ;
			cb -= sizeof( szIHave ) - 1 ;
			ibData += sizeof( szIHave ) - 1 ;
			DWORD	cbMessageId = 0 ;
			
			if( pArticle->fGetHeader(	"Message-ID", 
										lpb + ibData,
										cb,
										cbMessageId ) ) {
				cb -= cbMessageId ;
				ibData += cbMessageId ;
				return	ibData ;
			}
		}	else	{

			SetLastError( ERROR_FILE_NOT_FOUND ) ;

		}
	}	else	{

		PCHAR	args[2] ;
		char	szArticleId[20] ;
		_itoa( articleid, szArticleId, 10 ) ;
		args[0] = szArticleId ;
		args[1] = "_slavegroup._slavegroup" ;

		NntpLogEventEx( NNTP_QUEUED_ARTICLE_FAILURE,
				2,
				(const char **)args, 
				GetLastError(),
				m_pInstance->QueryInstanceId()
				) ;

		SetLastError(	ERROR_DIRECTORY ) ;

	}	
	pArticle = 0 ;

	return	 0 ;
}

BOOL
COutToPeerFeed::RetryPost(	NRC		nrcCode )	{

	if(	nrcCode != nrcArticleTransferredOK && nrcCode != nrcArticlePostedOK ) {
		if( nrcCode == nrcPostingNotAllowed || nrcCode == nrcTransferFailedTryAgain ) {
			return	TRUE ;
		}
	}

	return	FALSE ;
}

int
COutToPeerFeed::FormatCommand(	BYTE*		lpb,
								DWORD		cb,
								DWORD&		ibStart,
								GROUPID		groupid,
								ARTICLEID	articleid,
								CTOCLIENTPTR&	pArticle 
								)	{


	static	char	szIHave[] = "ihave " ;
	CopyMemory(	lpb, szIHave, sizeof( szIHave ) - 1 ) ;

	DWORD	cbMessageIdSize = cb - sizeof( szIHave ) - 2 ;
	FILETIME	filetime ;
	BOOL		fPrimary ;
	WORD		HeaderOffset ;
	WORD		HeaderLength ;
	DWORD		cStoreIds = 1;
	CStoreId	storeid ;

	if(	m_pInstance->XoverTable()->ExtractNovEntryInfo(
                                    groupid,
                                    articleid,
									fPrimary,
									HeaderOffset,
									HeaderLength,
									&filetime,
									cbMessageIdSize,
									(char*)lpb + sizeof( szIHave ) - 1,
									cStoreIds,
									&storeid,
									NULL) ) {

		_ASSERT( fPrimary ) ;

		ibStart = 0 ;
		int	cbOut = cbMessageIdSize + sizeof( szIHave ) - 1 ;
		lpb[cbOut++] = '\r' ;
		lpb[cbOut++] = '\n' ;		


		CNewsTree*	ptree = m_pInstance->GetTree() ;
		CGRPPTR	pGroup = ptree->GetGroupById( groupid ) ;	
		if( pGroup != 0 ) {
			pArticle = pGroup->GetArticle(	
									articleid, 
									storeid,
									0, 
									0, 
									TRUE
									) ;
		}
		
		if( pArticle != 0 ) {
			return	cbOut ;
		}
	}	

	SetLastError( ERROR_FILE_NOT_FOUND ) ;

	return	0 ;
}

BOOL
COutToMasterFeed::SupportsStreaming()	{
	return	TRUE ;
}

BOOL
COutToSlaveFeed::SupportsStreaming()	{
	return	FALSE ;
}

BOOL
COutToPeerFeed::SupportsStreaming()	{
	return	TRUE ;
}

char	COutFeed::szCheck[]	= "check " ;

char	COutFeed::szTakethis[] = "takethis " ;

DWORD
COutFeed::FormatCheckCommand(
				BYTE*		lpb, 
				DWORD		cb, 
				GROUPID		groupid, 
				ARTICLEID	articleid
				) {
/*++

Routine Description : 

	Build the command when we are using streaming feeds !

Arguments : 

	lpb - Buffer to place command in !
	cb - size of the buffer
	groupid	 - Group containing article we wish to send
	articleid - Id of the article within the group !

Return Value : 

	Number of bytes in buffer consumed !
	0 if failure !

--*/

	_ASSERT( SupportsStreaming() ) ;
	_ASSERT( lpb != 0 ) ;
	_ASSERT( cb != 0 ) ;
	_ASSERT( groupid != INVALID_GROUPID ) ;
	_ASSERT( articleid != INVALID_ARTICLEID ) ;

	if( cb <= (sizeof( szCheck )+2) ) {
		SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
		return	 0 ;
	}

	CopyMemory(	lpb, szCheck, sizeof( szCheck ) ) ;

	FILETIME	ft ;
	BOOL		fPrimary ;
	WORD		HeaderOffset ;
	WORD		HeaderLength ;

	//
	//	NOTE : subtract 2 additional for CRLF !!
	//
	DWORD		cbSize = cb - sizeof( szCheck ) - 2 ;	
	
	DWORD cStoreIds = 0;

	if( m_pInstance->XoverTable()->ExtractNovEntryInfo(
							groupid, 
							articleid, 
							fPrimary, 
							HeaderOffset, 
							HeaderLength, 
							&ft, 
							cbSize, 
							(char*)lpb + sizeof( szCheck ) - 1 ,
							cStoreIds,
							NULL,
							NULL))	{

		//
		//	We should always be dealing with the primary article !
		//
		_ASSERT( fPrimary ) ;

		DWORD	cbOut = cbSize + sizeof( szCheck ) - 1 ;
		
		lpb[cbOut++] = '\r' ;
		lpb[cbOut++] = '\n' ;
		return	cbOut ;
	}
							
	return	0 ;
}

DWORD
COutToMasterFeed::FormatCheckCommand(	
							BYTE*		lpb,
							DWORD		cb,
							GROUPID		groupid,
							ARTICLEID	articleid
							)	{

	DWORD	ibData = 0 ;
	CNewsTree*	ptree = m_pInstance->GetTree() ;

	CGRPPTR		pGroup = ptree->GetGroupById( groupid ) ;	
	if( pGroup != 0 ) {

		CTOCLIENTPTR	pArticle ;
		//
		//	bugbug ... last parameter to GetArticle should be based on whether
		//	we're using an SSL session - however at the time of writing SSL
		//	feeds weren't supported, so TRUE is safe !
		//
		//
		//	If we don't have an m_pCurrentArticle, we need to go to the
		//	hashtables and get a storeid to use with the driver !
		//
		CStoreId	storeid ;

		pArticle = pGroup->GetArticle(	
									articleid, 
									storeid,
									0, 
									0, 
									TRUE
									) ;
		if( pArticle != 0 ) {

			CopyMemory( lpb, szCheck, sizeof( szCheck ) - 1 ) ;
			cb -= sizeof( szCheck ) - 1 ;
			ibData += sizeof( szCheck ) - 1 ;
			DWORD	cbMessageId = 0 ;
			
			if( pArticle->fGetHeader(	"Message-ID", 
										lpb + ibData,
										cb,
										cbMessageId ) ) {
				cb -= cbMessageId ;
				ibData += cbMessageId ;
				return ibData ;
			}
		}	else	{
			SetLastError( ERROR_FILE_NOT_FOUND ) ;
		}
	}	else	{

		PCHAR	args[2] ;
		char	szArticleId[20] ;
		_itoa( articleid, szArticleId, 10 ) ;
		args[0] = szArticleId ;
		args[1] = "_slavegroup._slavegroup" ;

		NntpLogEventEx( NNTP_QUEUED_ARTICLE_FAILURE,
				2,
				(const char **)args, 
				GetLastError(),
				m_pInstance->QueryInstanceId()
				) ;

		SetLastError(	ERROR_DIRECTORY ) ;
	}	
	return	 0 ;
}

DWORD
COutFeed::CheckCommandLength()	{

	return	sizeof( szCheck ) - 1 ;

}

DWORD
COutFeed::FormatTakethisCommand(	
							BYTE*		lpb,
							DWORD		cb,
							GROUPID		groupid,
							ARTICLEID	articleid,
							CTOCLIENTPTR&	pArticle
							)	{

	_ASSERT( 1==0 ) ;

	return	0 ;
}

DWORD
COutToMasterFeed::FormatTakethisCommand(	
							BYTE*		lpb,
							DWORD		cb,
							GROUPID		groupid,
							ARTICLEID	articleid,
							CTOCLIENTPTR&	pArticle
							)	{

	DWORD	ibData = 0 ;
	CNewsTree*	ptree = m_pInstance->GetTree() ;

	CGRPPTR	pGroup = ptree->GetGroupById( groupid ) ;	
	if( pGroup != 0 ) {

		//
		//	bugbug ... last parameter to GetArticle should be based on whether
		//	we're using an SSL session - however at the time of writing SSL
		//	feeds weren't supported, so TRUE is safe !
		//
		//
		//
		//	If we don't have an m_pCurrentArticle, we need to go to the
		//	hashtables and get a storeid to use with the driver !
		//
		CStoreId	storeid ;

		pArticle = pGroup->GetArticle(	
									articleid, 
									storeid,
									0, 
									0, 
									TRUE
									) ;
		if( pArticle != 0 ) {

			CopyMemory( lpb, szTakethis, sizeof( szTakethis ) - 1 ) ;
			cb -= sizeof( szTakethis ) - 1 ;
			ibData += sizeof( szTakethis ) - 1 ;
			DWORD	cbMessageId = 0 ;
			
			if( pArticle->fGetHeader(	"Message-ID", 
										lpb + ibData,
										cb,
										cbMessageId ) ) {
				cb -= cbMessageId ;
				ibData += cbMessageId ;
				return	ibData ;
			}
		}	else	{

			SetLastError( ERROR_FILE_NOT_FOUND ) ;

		}
	}	else	{

		PCHAR	args[2] ;
		char	szArticleId[20] ;
		_itoa( articleid, szArticleId, 10 ) ;
		args[0] = szArticleId ;
		args[1] = "_slavegroup._slavegroup" ;

		NntpLogEventEx( NNTP_QUEUED_ARTICLE_FAILURE,
				2,
				(const char **)args, 
				GetLastError(),
				m_pInstance->QueryInstanceId()
				) ;

		SetLastError(	ERROR_DIRECTORY ) ;

	}	
	pArticle = 0 ;

	return	 0 ;
}

DWORD
COutToPeerFeed::FormatTakethisCommand(
				BYTE*		lpb,
				DWORD		cb, 
				GROUPID		groupid, 
				ARTICLEID	articleid, 
				CTOCLIENTPTR&	pArticle
				)	{


	CStoreId	storeid ;


	_ASSERT( SupportsStreaming() ) ;
	_ASSERT(	lpb != 0 ) ;
	_ASSERT(	cb != 0 ) ;
	_ASSERT(	groupid != INVALID_GROUPID ) ;
	_ASSERT(	articleid != INVALID_ARTICLEID ) ;
	
	if( cb < sizeof( szTakethis ) + 2 ) {
		SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
		return 0 ;
	}	

	CopyMemory(	lpb, szTakethis, sizeof( szTakethis ) ) ;

	FILETIME	ft ;
	BOOL		fPrimary ;
	WORD		HeaderOffset ;
	WORD		HeaderLength ;

	//
	//	NOTE : subtract 2 additional for CRLF !!
	//
	DWORD		cbSize = cb - sizeof( szTakethis ) - 2 ;	
	DWORD		cStoreIds = 1;

	if( m_pInstance->XoverTable()->ExtractNovEntryInfo(
							groupid, 
							articleid, 
							fPrimary, 
							HeaderOffset, 
							HeaderLength, 
							&ft, 
							cbSize, 
							(char*)lpb + sizeof( szTakethis ) - 1 ,
							cStoreIds,
							&storeid,
							NULL))	{

		//
		//	We should always be dealing with the primary article !
		//
		_ASSERT( fPrimary ) ;

		DWORD	cbOut = cbSize + sizeof( szTakethis ) - 1 ;
		
		lpb[cbOut++] = '\r' ;
		lpb[cbOut++] = '\n' ;

		if( !fPrimary ) {
			if( !m_pInstance->ArticleTable()->GetEntryArticleId(
							(char*)lpb + sizeof( szTakethis ) - 1,
							HeaderOffset, 
							HeaderLength, 
							articleid, 
							groupid,
							storeid) ) {

				return	0 ;
			}
		}
		
		CGRPPTR	pGroup = m_pInstance->GetTree()->GetGroupById( groupid ) ;
		if( pGroup != 0 && (pArticle = pGroup->GetArticle(
										articleid, 
										storeid,
										0,
										0, 
										FALSE
										)) != 0  ) {

			
			return	cbOut ;
		}
	}
	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\packet.h ===
/*++

	packet.h

	This file contains the class definitions for buffers and packets, the two type hierarchies
	which describe basic IO operations.

	A CBuffer is a reference counted buffer which is variable sized.
	CBuffer's will be created in one of several standard sizes, the size stored in the m_cbTotal field.


	We have the following inheritance hierarchy : 


							CPacket 
				
					/			|		\
				/				|			 \
			
		CTransmitPacket		CRWPacket		CControlPacket

							/		\
						   /		 \
					CReadPacket		CWritePacket


	CTransmitPacket - 
		represents TransmitFile operations

	CReadPacket - 
		represents an async read from a socket or file

	CWritePacket - 
		represents an async write to a socket or file

	CControlPacket - 
		does not represent any real IO - used by CIODrivers to 
		control simultaneous operations 


--*/

#ifndef	_PACKET_H_
#define	_PACKET_H_

#include	"cbuffer.h"
#include	"gcache.h"
#include	"io.h"


//
// CPool Signature
//

#define PACKET_SIGNATURE (DWORD)'1191'

#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC(	CBuffer ) 

#endif


//
//	CPacket - 
//	the classes derived from this will describe the most basic read's and write's (and TransmitFile's)
//	that are done against socket's and file handles.
//
//	The basic CPacket object describes the following : 
//
//		m_fRequest -  This is TRUE until an the IOs associated with this packet have completed.
//			ie.	if this is a read m_fRequest will be set to FALSE when the read completes.
//
//		m_fRead - Does this represent a 'read' or a 'write'
//
//		m_sequenceno - This is used to order how packets are processing.  sequence numbers are 
//			issued in a strictly increasing order as the packets are issued.
//			The sequenceno is set when the packet is issued (ie AtqReadFile is called) not when 
//			the packet is created.
//
//		m_iStream - for completed packets this is the number of logical bytes since the stream
//			was opened that preceded this packet.
//
//		m_pOwner - the CIODriver object responsible for processing this packet when it completes.
//
//		m_cbBytes - the number of bytes that were transfered by this IO operation !
//
//
class	CPacket : public CQElement	{
private : 
	static	CPacketAllocator	gAllocator ;
protected : 
	inline	CPacket(	CIODriver&, BOOL, BOOL fSkipQueue = FALSE ) ;
	inline	CPacket(	CIODriver&,	CPacket& ) ;
	virtual	~CPacket() ;
public : 
	ExtendedOverlap	m_ovl ;		// Overlap Structure
	BOOL		m_fRequest ;	// TRUE if this is a request packet, FALSE if this is a completion packet.

	//
	//	Is this packet a Read or a Writes (CTransmitPacket and CWritePacket are both 'Writes')
	//
	BOOL		m_fRead ;		// Which Queue to process on !? Reads or Writes !?

	//
	//	This flag indicates that we do not need to do any queueing in how this packet is handled !
	//
	BOOL		m_fSkipQueue ;
	
	//
	//	Packet Sequence Number
	//
	SEQUENCENO	m_sequenceno ;	// The sequenceno of this IOPacket

	//
	//	Number of bytes into the logical stream the data carried by this packet begins !
	//
	STRMPOSITION	m_iStream ;		// The beginning stream position of the data within this packet
	
	//
	//	Number of legit bytes moved by this packet.  Set when the IO completes 
	//
	unsigned	m_cbBytes ;		// Number of bytes transferred

	//
	//	The CIODriver to which this packet should be completed (ie call is ProcessPacket())
	//
	CDRIVERPTR	m_pOwner ;		// The Owning CIODriver derived object !

	//
	//	This is used only with CIODriverSource's.  When the packet is 
	//	issued we figure out what CIOPassThru object to process the packet with
	//	and store it here.
	//
	DWORD		m_dwPassThruIndex ;
	
	//
	//	The following two fields are 'extra' DWORD's that we provide
	//	to be used by CIO classes as they please.
	//
	DWORD		m_dwExtra1 ;
	DWORD		m_dwExtra2 ;

	//
	//	Pointer to the CIODriver which originated the request - 
	//	this is set if we are using a filter
	//
	CDRIVERPTR	m_pSource ;

	//
	//	For File IO only - pointer to the CFileChannel object which
	//	issues the IO's - because we can't use the ATQ completion contexts 
	//	with file handles for various reasons !
	//
	CFileChannel*	m_pFileChannel ;

	//
	// Both m_fRequest and m_sequenceno must be set if this is a valid request packet !!
	//	If this is a CWritePacket it must also have a pBuffer
	//	If this is a CTransmiPacket it must also have a hFile
	//	If this is a Read Request then whether the packet has a BUFFER depends on the 
	//	Channel the request was issued to.
	//
	virtual	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;	
	//
	// A completed request must have cbBytes set, and if it 
	//	is a read or Write request, it must have a BUFFER!
	//
	virtual	BOOL		IsValidCompletion() ;
	//
	// Before a packet is destroyed it should be validly completed !
	//
	virtual	BOOL		IsCompleted() = 0 ;

	inline	BOOL	IsValid() ;

	//
	//	For use with CIODriverSource objects - give a CIOPassThru derived object a 
	//	chance at massaging the packet.
	//
	virtual	BOOL	InitRequest( class	CIODriverSource&,	class	CSessionSocket*,	class	CIOPassThru	*pio,	BOOL& ) ;

	//
	//	Two variations on completing packets - one for use with CIODriverSource, the other with CIODriverSink objects 
	//
	virtual	unsigned	Complete( IN	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) = 0 ;
	virtual	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) = 0 ;
	inline	void	ForwardRequest(	CSessionSocket*	pSocket ) ;

	//
	//	Compare packet sequence numbers 
	//
	inline	BOOL	operator > ( CPacket &rhs ) ;
	inline	BOOL	operator < ( CPacket &lhs ) ;

	//
	//	Legality checking functions
	//
	virtual	BOOL	FConsumable() ;
	virtual	BOOL	FLegal( BOOL	fRead ) = 0 ;

	//
	//	Functions for determining the derived class.
	//	Maybe we should use the new C++ Dynamic Cast ?
	//	These are mostly used for debugging
	//	
	//
	inline	virtual	CReadPacket*	ReadPointer() ;
	inline	virtual	CWritePacket*	WritePointer() ;
	inline	virtual	CTransmitPacket*	TransmitPointer() ;
	inline	virtual	CControlPacket*	ControlPointer() ;

	//
	//	Initialize CPool so memory allocations work 
	//
	static	BOOL	InitClass() ;

	//
	//	Discard all CPool stuff !
	//
	static	BOOL	TermClass() ;


	//
	//	Memory manage of CPacket's - 
	//	operator new can take a CPacketCache - which is used to cache packets and 
	//	avoid contention on critical sections.
	//	ReleaseBuffers - a virtual function that should be called when ready to destroy 
	//	a packet to release all of its buffers.
	//	Destroy - All the destructors are protected so that people that wish to 
	//	get rid of CPacket's must call 'Destroy'.	Destroy calls the destructor for the packet
	//	however it does not release the memory associated with a packet - this must be handled
	//	explicitly after calling destroy. (This approach allows the caller to 'cache' CPacket's).
	//
	//

	void*	operator	new(	
								size_t	size,	
								CPacketCache*	pCache = 0 
								) ;

	//
	//	This function will release any buffers the packet is pointing at 
	//
	virtual	void	ReleaseBuffers(	
								CSmallBufferCache*	pBufferCache,
								CMediumBufferCache*	pMediumCache
								) ;

	//
	//	This function will call the destructor for the packet but will not release the memory
	//
	static	inline	void*	Destroy(	
								CPacket*	pPacket 
								)	
								{	delete	pPacket ;	return (void*)pPacket ;	}

	//
	//	This function will call the destructor AND release the memory !
	//	
	static	inline	void	DestroyAndDelete(	CPacket*	pPacket )	{	delete	pPacket ;	gAllocator.Release( (void*)pPacket ) ;	}

	//
	//	The delete operator will do nothing but call the destructor - callers should use
	//	DestroyAndDelete to release the memory as well
	//
	void	operator	delete(	void*	pv ) ;
} ;

//
//	The CRWPacket class contains all information common to both
//	Read and Write IO operations.
//
class	CRWPacket : public	CPacket	{
protected :
	//inline	CRWPacket() ; 
	//inline	CRWPacket(	BOOL	) ;
	inline	CRWPacket(	CIODriver&, 
						BOOL fRead = FALSE 
						) ;

	inline	CRWPacket(	CIODriver&,	
						CBuffer&,	
						unsigned	size, 
						unsigned	cbTrailer,
						BOOL fRead = FALSE	
						) ;

	inline	CRWPacket(	CIODriver&,	
						CBuffer&	pbuffer,	
						unsigned	ibStartData,	
						unsigned	ibEndData, 
						unsigned	ibStart, 
						unsigned	ibEnd, 
						unsigned	cbTrailer,
						BOOL fRead = FALSE 
						) ;

	inline	CRWPacket(	CIODriver&,	
						CRWPacket& 
						) ;

	inline	~CRWPacket( ) ;
public : 
	CBUFPTR		m_pbuffer ;		// The buffer in which this data resides
	unsigned	m_ibStart ;		// The start of the region within buffer reserved for the Packet
	unsigned	m_ibEnd ;		// The end of the region within buffer reserved for the Packet
	unsigned	m_ibStartData ;	// The start of the actual data within the buffer
	unsigned	m_ibEndData ;	// The end of the actual data within the buffer
	unsigned	m_cbTrailer ;	// number of bytes beyond the end of the packet reserved for 
								// use by lower levels for encryption data etc...

	BOOL		IsValid() ;
	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;
	BOOL		IsValidCompletion( ) ;
	BOOL		IsCompleted() ;
	void		InitRequest(	CBUFPTR	pBufPtr, int ibStart, int ibEnd, 
					int ibStartData, CDRIVERPTR pDriver ) ;

	//
	//	Utility functions for getting at various parts of the data in the packet.
	//	People must never touch bytes beyond End() or before Start().  Nor 
	//	can anybody assume that they are the only ones using the buffer pointed
	//	to by this packet.
	//
	char*		StartData( void ) ;
	char*		EndData( void ) ;
	char*		Start( void ) ;
	char*		End( void ) ;

	void	ReleaseBuffers(	CSmallBufferCache*	pBufferCache, CMediumBufferCache* pMediumCache ) ;
} ;

//
//	The CReadPacket class represents read operations. All data
//	is contained in the CRWPacket class.  This class enables us to use 
//	function overloading to process Read Packets only.
//	NOTE that the ExtendedOverlap structure contains enough information
//	to determine whether something is a CReadPacket.
//
class	CReadPacket	: public	CRWPacket	{
private : 
	CReadPacket() ;
protected : 
	~CReadPacket( ) ;
public : 
	CReadPacket(	CIODriver&	driver, 
					unsigned	size,
					unsigned	m_cbFront,	
					unsigned	m_cbTail,	
					CBuffer&	pbuffer
					) ;

	CReadPacket(	CIODriver&	driver ) ;

	inline		CReadPacket(	CIODriver&	driver,	
								CReadPacket&	read 
								) ;

	BOOL		FConsumable() ;
	BOOL		FLegal( BOOL	fRead ) ;
	BOOL		IsValid() ;
	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;
	BOOL		InitRequest( class	CIODriverSource&,	class	CSessionSocket*,	class	CIOPassThru	*pio,	BOOL& ) ;
	unsigned	Complete( INOUT	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) ;
	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) ;
	inline		CReadPacket*	ReadPointer() ;
} ;

//
//	The CWritePacket class represents write operations.
//
class	CWritePacket	: public	CRWPacket	{
private : 
	CWritePacket() ;	
protected : 
	~CWritePacket( ) ;
public : 
	CWritePacket(	CIODriver&	driver,	
					CBuffer&	pbuffer,	
					unsigned	ibStartData,	
					unsigned	ibEndData,	
					unsigned	ibStart,	
					unsigned	ibEnd,
					unsigned	cbTrailer
					) ;

	inline		CWritePacket(	
					CIODriver&	driver,	
					CWritePacket&	write 
					) ;

	BOOL		FLegal( BOOL	fRead ) ;
	BOOL		IsValid() ;
	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;
	BOOL		InitRequest( class	CIODriverSource&,	class	CSessionSocket*,	class	CIOPassThru	*pio,	BOOL& ) ;
	unsigned	Complete( INOUT	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) ;
	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) ;
	inline		CWritePacket*	WritePointer() ;
} ;

//
//	This class represents TransmitFile() operations.
//
class	CTransmitPacket	: public	CPacket	{
private : 
	CTransmitPacket() ;
protected : 
	~CTransmitPacket( ) ;
public : 
	FIO_CONTEXT*	m_pFIOContext ;	// The file from the cache we are to send !
	unsigned	m_cbOffset ;		// Starting offset within file
	unsigned	m_cbLength ;

	TRANSMIT_FILE_BUFFERS	m_buffers ;	
	
	inline		
	CTransmitPacket(	CIODriver&, 
						FIO_CONTEXT*,  
						unsigned	ibOffset,	
						unsigned	cbLength 
						) ;
						
	inline		CTransmitPacket(	
						CIODriver&	driver,	
						CTransmitPacket&	transmit 
						) ;

	BOOL		FLegal( BOOL	fRead ) ;
	BOOL		IsValid() ;
	BOOL		IsValidRequest( BOOL	fReadsRequireBuffers ) ;
	BOOL		IsValidCompletion( ) ;
	BOOL		IsCompleted() ;
	//BOOL		InitRequest( HANDLE	hFile, int cbOffset ) ;

	BOOL		InitRequest( class	CIODriverSource&,	class	CSessionSocket*,	class	CIOPassThru	*pio,	BOOL& ) ;
	unsigned	Complete( INOUT	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) ;
	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) ;
	inline		CTransmitPacket*	TransmitPointer() ;
} ;

class	CExecutePacket	:	public	CPacket	{
protected : 
	//
	//	Data captured from the Execution !
	//
	DWORD	m_cbTransfer ;
	//
	//	Did the operation complete !
	//
	BOOL	m_fComplete ;
	//
	//	Do we need a larger buffer to perform the operation !
	//
	BOOL	m_fLargerBuffer ;
	//
	//	The write packet containing the clients data !
	//
	CWritePacket*	m_pWrite ;
	//
	//	Special CIO class that is our friend
	//
	friend	class	CIOWriteAsyncComplete ;
	friend	class	CIOWriteAsyncCMD ;
	friend	class	CIOShutdown ;
public :
	inline	
	CExecutePacket(	CIODriver&	driver	) ;

	#ifdef	DEBUG
	~CExecutePacket()	{
		//
		//	Somebody must ensure this is released before we're destroyed !
		//
		_ASSERT( m_pWrite == 0 ) ;
	}
	#endif
	

	BOOL
	FLegal(	BOOL	fRead ) 	{
		return	TRUE ;
	}

	BOOL
	IsValidRequest(	BOOL	fReadsRequireBuffers ) {
		return	TRUE ;
	}

	BOOL
	IsCompleted()	{
		return	TRUE ;
	}
	
	unsigned	
	Complete(	INOUT	CIOPassThru*	pIn, 
				IN CSessionSocket*, 
				CPacket* pRequest, 
				OUT BOOL& 
				) 	{
		DebugBreak() ;
		return	0 ;
	}
	
	unsigned	
	Complete(	INOUT	CIO*&	pIn, 
				IN CSessionSocket* pSocket
				) ;
} ;




class	CControlPacket	:	public	CPacket	{
protected : 
	~CControlPacket()	{}
public : 

	ControlInfo	m_control ;
	
	CControlPacket(	CIODriver&	driver ) ;	
	
	void	StartIO(	CIO&	pio,	BOOL	fStart ) ;
	void	StartIO(	CIOPassThru&	pio,	BOOL	fStart ) ;
	void	Shutdown(	BOOL	fCloseSource = TRUE ) ;
	void	Reset( ) ;

	BOOL	FLegal(		BOOL	fRead ) ;
	BOOL	IsValidRequest(	BOOL	fReadsRequireBuffers ) ;
	BOOL		IsCompleted() ;
	unsigned	Complete( INOUT	CIOPassThru*	pIn, IN CSessionSocket*, CPacket* pRequest, OUT BOOL& ) ;
	unsigned	Complete( INOUT	CIO*&	pIn, IN CSessionSocket* ) ;

	CControlPacket*	ControlPointer() ;
} ;


#define	MAX_PACKET_SIZE	max(	sizeof( CReadPacket ),	\
							max(	sizeof( CWritePacket ),	\
								max(	sizeof( CControlPacket ),  sizeof( CTransmitPacket ) ) ) ) 


#endif	//	_PACKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\packet.cpp ===
/*++

	packet.cpp

	This file contains the code which implements the CPacket derived classes.
	A CPacket derived object describes the most basic IO operation that is performed.


--*/




#include	"tigris.hxx"

#ifdef	CIO_DEBUG
#include	<stdlib.h>		// For Rand() function
#endif

#ifdef	_NO_TEMPLATES_

DECLARE_ORDEREDLISTFUNC( CPacket )

#endif


//
//	CPool for allocating all packets
//
CPool	CPacketAllocator::PacketPool ;

CPacketAllocator::CPacketAllocator()	{
}

BOOL
CPacketAllocator::InitClass() {
/*++

Routine Description :

	Initialize the CPacketAllocator class.
	This class wraps all calls to CPool, basically so we can
	easily use CCache to cache allocations of packets.

	This function will have the CPool reserver the necessary memory.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE  otherwise

--*/
	return	PacketPool.ReserveMemory( MAX_PACKETS, MAX_PACKET_SIZE ) ;
}

BOOL
CPacketAllocator::TermClass()	{
/*++

Routine Description :

	Release all of the memory associated with Packets.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/
	_ASSERT( PacketPool.GetAllocCount() == 0 ) ;
	return	PacketPool.ReleaseMemory() ;
}

#ifdef	DEBUG
//
//	The following debug functions are called
//	from CCache in order to emulate some of the debug
//	checking that is done in CPool when packet allocations
//	are cached.
//
//
void
CPacketAllocator::Erase(
					void*	lpv
					) {
/*++

Routine Description :

	File a block of memory to make it easy to spot in the debugger

Arguments :

	lpv - memory allocated for a CPacket derived object.

Return Value :

	None

--*/

	FillMemory( (BYTE*)lpv, MAX_PACKET_SIZE, 0xCC ) ;

}

BOOL
CPacketAllocator::EraseCheck(
					void*	lpv
					)	{
/*++

Routine Description :

	Check that a block of memory was cleared by
	CPacketAllocator::Erase()

Arguments :

	lpv - block of memory

Return Value :

	TRUE if Erase()'d
	FALSE otherwise

--*/

	BYTE*	lpb = (BYTE*)lpv ;
	for( int i=0; i<MAX_PACKET_SIZE; i++ ) {
		if( lpb[i] != 0xCC ) {
			return	FALSE ;
		}
	}
	return	TRUE ;
}

BOOL
CPacketAllocator::RangeCheck(
					void*	lpv
					)	{
/*++

Routine Description :

	Check that a block of memory is in a range
	we would allocate.
	Cpool doesn't have enough support for this.

Arguments :

	lpv - address to check

Returns :

	Always TRUE

--*/
	return	TRUE ;
}

BOOL
CPacketAllocator::SizeCheck(
					DWORD	cb
					)	{
/*++

Routine Description :

	Check that a requested size is legitimate

Arguments :

	cb - requested size

Return Value :

	TRUE if the size is good !

--*/

	if( cb <= MAX_PACKET_SIZE )
		return	TRUE ;

	return	FALSE ;
}
#endif

//
//	Global allocator used by CPacket
//
CPacketAllocator	CPacket::gAllocator ;

//
//	Pointer to the same global allocator that
//	CCache needs to use
//
CPacketAllocator	*CPacketCache::PacketAllocator ;

BOOL
CPacket::InitClass( )	{
/*++

Routine Description :

	Initialize the CPacket class

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	if( CPacketAllocator::InitClass() )	{
		CPacketCache::InitClass( &gAllocator ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CPacket::TermClass()	{
/*++

Routine Description :

	Terminate everything regarding CPacket's

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	return	CPacketAllocator::TermClass() ;

}

void
CPacket::ReleaseBuffers(
					CSmallBufferCache*	pBufferCache,
					CMediumBufferCache*	pMediumCache
					) {
/*++

Routine Description :

	This function is supposed to release any buffers
	that the CPacket may contain.  This is a virtual
	function that should be overridden by CPackets which
	contain buffers.

Arguments :

	pBufferCache - Cache to hold small buffers
	pMediumCache - Cache to hold medium size buffers

Return Value :

	None.

--*/
}

void
CRWPacket::ReleaseBuffers(
				CSmallBufferCache*	pBufferCache,
				CMediumBufferCache*	pMediumCache
				) {
/*++

Routine Description :

	This function is supposed to release any buffers
	that the CRWPacket may contain.

Arguments :

	pBufferCache - Cache to hold small buffers
	pMediumCache - Cache to hold medium size buffers

Return Value :

	None.

--*/

	if( pBufferCache ) {
		CBuffer*	pbuffer = m_pbuffer.Release() ;
		if( pbuffer )	{
			if( pbuffer->m_cbTotal < CBufferAllocator::rgPoolSizes[0] ) {
				pBufferCache->Free( (void*)pbuffer ) ;
			}	else	{
				pMediumCache->Free( (void*)pbuffer ) ;
			}
		}
	}	else	{
		m_pbuffer = 0 ;
	}
}

BOOL	CPacket::InitRequest(
					class	CIODriverSource&,
					CSessionSocket	*,
					CIOPassThru*	pio,
					BOOL	&fAcceptRequests ) {
	fAcceptRequests = FALSE ;
	Assert( 1==0 ) ;
	return	FALSE ;
}


BOOL	CPacket::IsValidRequest(
					BOOL	fReadsRequireBuffers
					) {
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/

	if( !m_fRequest ) {
		return	FALSE ;
	}
	//if(	m_sequenceno == INVALID_SEQUENCENO )	{
	//	return	FALSE ;
	//}
	//if( m_iStream == INVALID_STRMPOSITION )	{
	//	return	FALSE ;
	//}
	//if( (m_sequenceno == INVALID_SEQUENCENO && m_iStream != INVALID_STRMPOSITION) ||
	//	(m_sequenceno != INVALID_SEQUENCENO && m_iStream == INVALID_STRMPOSITION) ) {
	//	return	FALSE ;
	//}

#if 0
	if( m_cbBytes != UINT_MAX )	{
		return	FALSE ;
	}
#endif
	if( m_ovl.m_pHome != this )		{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL	CRWPacket::IsValidRequest(
				BOOL	fReadsRequireBuffers
				)	{
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/


	if( !CPacket::IsValidRequest( fReadsRequireBuffers ) ) {
		return	FALSE ;
	}
	if( m_ibStartData < m_ibStart ) {
		return	FALSE ;
	}
	if( m_ibEnd < m_ibStart )	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CReadPacket::IsValidRequest(
					BOOL	fReadsRequireBuffers
					)	{
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/


	if( m_cbBytes != 0 )	{
		return	FALSE ;
	}
	if( !m_fRead )	{
		return	FALSE ;
	}
	if( !CRWPacket::IsValidRequest( fReadsRequireBuffers ) ) {
		return	FALSE ;
	}
	if(	m_ibEndData != 0 )		{	// m_ibEndData is not set until we have completed
									// must be zero on all requests
		return	FALSE ;
	}
	if( fReadsRequireBuffers )	{
		if( m_pbuffer == 0 )	{
			return	FALSE ;
		}
		if( m_ibEnd == m_ibStart )	{	// End must not equal Start - no zero length
										// Reads Allowed !!!!
			return	FALSE ;
		}
		if( m_ibEnd == 0 ) {
			return	FALSE ;
		}
	}	else	{
		if( m_pbuffer != 0 )	{
			return	FALSE ;
		}
		// All fields must be 0 if there is no buffer !!
		if( m_ibStart != 0 )	{
			return	FALSE ;
		}
		if( m_ibEnd != 0 )	{
			return	FALSE ;
		}
		if( m_ibStartData != 0 )	{
			return	FALSE ;
		}
		if(	m_ibEndData != 0 )	{
			return	FALSE ;
		}
	}
	return	TRUE ;
}

BOOL
CWritePacket::IsValidRequest(
							BOOL	fReadsRequireBuffers
							)	{
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/


	if( !((int)m_cbBytes >= 0 && m_cbBytes <= (m_ibEndData - m_ibStartData)) )	{
		return	FALSE ;
	}
	if( m_fRead )	{
		return	FALSE ;
	}
	if( !CRWPacket::IsValidRequest(	fReadsRequireBuffers ) )	{
		return	FALSE ;
	}
	if( m_pbuffer == 0 )	{	// WRITES MUST HAVE BUFFERS
		return	FALSE ;
	}
	if( m_ibEnd == m_ibStart )	{	// NO ZERO LENGTH WRITES !
		return	FALSE ;
	}
	if( m_ibEndData < m_ibStartData )	{
		return	FALSE ;
	}
	if( m_ibEndData == m_ibStartData )	{
		return	FALSE ;
	}
	if( m_ibEndData == 0 ) {	// WRITES MUST SPECIFY BOTH STARTDATA and ENDDATA
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CTransmitPacket::IsValidRequest(
							BOOL	fReadsRequireBuffers
							)	{
/*++

Routine Description :

	Check whether this packet is in valid state, given that
	it has not yet been issued.

Arguments :

	fReadsRequireBuffers - if TRUE and this is a read we should
		have a buffer

Return Value :

	TRUE if good
	FALSE otherwise


--*/

	if( m_cbBytes != 0 )	{
		return	FALSE ;
	}
	if( m_fRead )	{
		return	FALSE ;
	}
	if( !CPacket::IsValidRequest( fReadsRequireBuffers ) )	{
		return	FALSE ;
	}
	if( m_pFIOContext == 0 )	{
		return	FALSE ;
	}
	if( m_pFIOContext->m_hFile == INVALID_HANDLE_VALUE ) 	{
		return	FALSE ;
	}
	if( m_cbOffset == UINT_MAX )	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CPacket::IsValidCompletion(	  )	{
/*++

Routine Description :

	Given that the IO for this has completed successfully,
	check that the packet is in a valid state.

Arguments :

	None.

Return Value :

	TRUE if good
	FALSE otherwise

--*/
	if( m_fRequest ) {
		return	FALSE ;
	}
	if( m_cbBytes == UINT_MAX )		{		// We can complete 0 bytes, although we can't request it !
		return	FALSE ;
	}
	if(	EQUALSI( m_sequenceno, (DWORD)INVALID_SEQUENCENO ) )	{
		return	FALSE ;
	}
	if(	EQUALSI( m_iStream, (DWORD)INVALID_STRMPOSITION )	)	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CRWPacket::IsValidCompletion( )		{
/*++

Routine Description :

	Given that the IO for this has completed successfully,
	check that the packet is in a valid state.

Arguments :

	None.

Return Value :

	TRUE if good
	FALSE otherwise

--*/


	if( !CPacket::IsValidCompletion()	)	{
		return	FALSE ;
	}
	if( m_ibStartData < m_ibStart )	{
		return	FALSE ;
	}
	if( m_ibEnd < m_ibStart )	{
		return	FALSE ;
	}
//	Not valid for write packets !!
//	if( (m_ibStartData + m_cbBytes != m_ibEndData) && m_cbBytes != 0 )	{
//		return	FALSE ;
//	}
#ifdef	RETIRED
    //
    // This check works most of the time except when writing to a file
    // and the machine runs out of disk space.  Retired untill we can
    // figure out how to not _ASSERT in that case !
    //

	//
	//	This check ensures that if we are issuing packets against a file
	//  that the file offsets are being properly synchronized !!
	//
	if(	m_ovl.m_ovl.Offset != 0 && m_ovl.m_ovl.Offset != (1+LOW(m_iStream)) && m_cbBytes != 0 )	{
		return	FALSE ;
	}
#endif	// CIO_DEBUG
	return	TRUE ;
}

BOOL
CTransmitPacket::IsValidCompletion( )	{
/*++

Routine Description :

	Given that the IO for this has completed successfully,
	check that the packet is in a valid state.

Arguments :

	None.

Return Value :

	TRUE if good
	FALSE otherwise

--*/

	if( !CPacket::IsValidCompletion() )		{
		return	FALSE ;
	}
	if( m_pFIOContext == 0 )	{
		return	FALSE ;
	}
	if( m_pFIOContext->m_hFile == INVALID_HANDLE_VALUE ) 	{
		return	FALSE ;
	}
	if( m_cbOffset == UINT_MAX	)	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CRWPacket::IsCompleted()	{

	if( !IsValidCompletion() )	{
		return	FALSE ;
	}
	if( m_cbBytes != m_ibStartData - m_ibEndData )	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL	CTransmitPacket::IsCompleted()	{
	if( m_fRead )	{
		return	FALSE ;
	}
	if(	!IsValidCompletion() )	{
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL	CControlPacket::IsCompleted( )	{

	if( m_control.m_pio )
		return	FALSE ;
	return	TRUE ;
}



/*++

Routine description -

	Determine whether the packet is consumable - ie.
	can the data in the packet be only partly consumed
	by the CIO completion function.

	This is only TRUE of read packets, where we
	may use only a portion of the data in any IO completion.

Return Value :

	CReadPacket::FConsumable returns TRUE

	all others return FALSE.

--*/
BOOL
CReadPacket::FConsumable()	{
	return	TRUE ;
}

BOOL
CPacket::FConsumable()	{
	return	FALSE ;
}


/*++

Routine Description :

	Determine whether a packet can be used
	for Reads.
	This function is used to make sure that packets
	are delivered to the correct CStreams within CIODriver's.
	ie. we want to make sure that reads are processed
	by objects meant to process reads, etc...

Arguments :

	fRead - if TRUE then this packet is assumed to be a read

Return Value :

	TRUE if the packet is being used correctly.

--*/
BOOL	CReadPacket::FLegal( BOOL	fRead )	{
	return	fRead ;
}

BOOL	CWritePacket::FLegal(	BOOL	fRead )		{
	return	!fRead ;
}

BOOL	CTransmitPacket::FLegal(	BOOL	fRead )		{
	return	!fRead ;
}


BOOL	CReadPacket::InitRequest(	class	CIODriverSource&	driver,	CSessionSocket	*pSocket,	CIOPassThru*	pio, BOOL	&fAcceptRequests ) {
	return	pio->InitRequest( driver, pSocket, this, fAcceptRequests ) ;
}

unsigned
CReadPacket::Complete(	CIOPassThru*		pio,
						CSessionSocket*	pSocket,
						CPacket*	pPacket,
						BOOL&		fCompleteRequest
						)	{
/*++

Routine Description :

	This function is called by CIODriverSource's when an IO has
	completed.  Our job is to bump the member variables
	(ie. m_ibEndData) to indicate the number of bytes transferred
	and the call the CIO's completion function.

Arguments :

	pio - Reference to a pointer to the CIO object processing this data
	pSocket - Socket associated with the IO
	pPacket - The packet representing the request which started this
	fCompleteRequest - out parameter - set to TRUE when the pPacket
		has been completed and should be processed

Return Value :

	Number of bytes in the CReadPacket consumed.

--*/

	TraceFunctEnter( "CReadPacket::Complete" ) ;

	Assert( m_ibEndData == 0 || m_ibEndData == (m_ibStartData + m_cbBytes) || m_cbBytes == 0 ) ;
	m_ibEndData = m_ibStartData + m_cbBytes ;

	DebugTrace( (DWORD_PTR)this, "pbuffer %x ibStart %d ibEnd %d StartData %d EndData %d",
		(CBuffer*)m_pbuffer, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

	Assert( IsValidCompletion() ) ;

	unsigned	cbConsumed = pio->Complete(	pSocket,	this,	pPacket,	fCompleteRequest ) ;
	m_ibStartData += cbConsumed ;

	DebugTrace( (DWORD_PTR)this, "CONSUMED %d ibStart %d ibEnd %d StartData %d EndData %d",
		cbConsumed, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;


#ifdef	CIO_DEBUG
	if( m_ovl.m_ovl.Offset != 0 )	{
		m_ovl.m_ovl.Offset += cbConsumed ;
	}
#endif
	return	cbConsumed ;
}

unsigned
CReadPacket::Complete(
					CIO*		&pio,
					CSessionSocket*	pSocket
					) {
/*++

Routine Description :

	Called by a CIODriver object when a read has completed, we bump
	m_ibEndData to match the number of bytes read, and the call the
	correct CIO completion function.

Arguments :

	pio - an OUT parameter passed to CIO::Complete, which the CIO object
		can use to set the next CIO object.

	pSocket - socket associated with this stuff

Return Value :

	Number of bytes in the packet consumed.

--*/

	TraceFunctEnter( "CReadPacket::Complete" ) ;

	Assert( m_ibEndData == 0 || m_ibEndData == (m_ibStartData + m_cbBytes) || m_cbBytes == 0 ) ;
	m_ibEndData = m_ibStartData + m_cbBytes ;
	Assert( IsValidCompletion() ) ;

	DebugTrace( (DWORD_PTR)this, "pbuffer %x ibStart %d ibEnd %d StartData %d EndData %d",
		(CBuffer*)m_pbuffer, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

	unsigned	cbConsumed = pio->Complete( pSocket, this, pio ) ;
	m_ibStartData += cbConsumed ;

	DebugTrace( (DWORD_PTR)this, "CONSUMED %d ibStart %d ibEnd %d StartData %d EndData %d",
		cbConsumed, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

#ifdef	CIO_DEBUG
	if( m_ovl.m_ovl.Offset != 0 )	{
		m_ovl.m_ovl.Offset += cbConsumed ;
	}
#endif
	return	cbConsumed ;
}

BOOL	CWritePacket::InitRequest(	class	CIODriverSource&	driver,	CSessionSocket	*pSocket,	CIOPassThru*	pio, BOOL	&fAcceptRequests ) {
	return	pio->InitRequest( driver, pSocket, this, fAcceptRequests ) ;
}


unsigned
CWritePacket::Complete(
					CIOPassThru*		pio,
					CSessionSocket*	pSocket,
					CPacket*	pPacket,
					BOOL&		fCompleteRequest
					)	{
/*++

Routine Description :

	This function is called by CIODriverSource's when an IO has
	completed.  Our job is to bump the member variables
	(ie. m_ibEndData) to indicate the number of bytes transferred
	and the call the CIO's completion function.

Arguments :

	pio - Reference to a pointer to the CIO object processing this data
	pSocket - Socket associated with the IO
	pPacket - The packet representing the request which started this
	fCompleteRequest - out parameter - set to TRUE when the pPacket
		has been completed and should be processed

Return Value :

	Number of bytes in the CReadPacket consumed.

--*/



	TraceFunctEnter( "CWritePacket::Complete" ) ;

	//Assert( m_ibEndData == m_ibStartData + m_cbBytes || m_cbBytes == 0 ) ;
	Assert( IsValidCompletion() ) ;

	DebugTrace( (DWORD_PTR)this, "pbuffer %x ibStart %d ibEnd %d StartData %d EndData %d",
		(CBuffer*)m_pbuffer, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

	unsigned	cbConsumed = pio->Complete( pSocket,	this,	pPacket, fCompleteRequest ) ;
	m_ibStartData += cbConsumed ;

	DebugTrace( (DWORD_PTR)this, "CONSUMED %d ibStart %d ibEnd %d StartData %d EndData %d",
		cbConsumed, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

#ifdef	CIO_DEBUG
	if( m_ovl.m_ovl.Offset != 0 )	{
		m_ovl.m_ovl.Offset += cbConsumed ;
	}
#endif
	return	cbConsumed ;
}

unsigned
CWritePacket::Complete(
				CIO*		&pio,
				CSessionSocket*	pSocket
				)	{
/*++

Routine Description :

	Called by a CIODriver object when a write has completed, we bump
	m_ibEndData to match the number of bytes read, and the call the
	correct CIO completion function.

Arguments :

	pio - an OUT parameter passed to CIO::Complete, which the CIO object
		can use to set the next CIO object.

	pSocket - socket associated with this stuff

Return Value :

	Number of bytes in the packet consumed.

--*/

	TraceFunctEnter( "CWritePacket::Complete" ) ;

	//Assert( m_ibEndData == m_ibStartData + m_cbBytes || m_cbBytes == 0 ) ;
	Assert( IsValidCompletion() ) ;

	DebugTrace( (DWORD_PTR)this, "pbuffer %x ibStart %d ibEnd %d StartData %d EndData %d",
		(CBuffer*)m_pbuffer, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

	unsigned	cbConsumed = pio->Complete( pSocket,	this,	pio	) ;

	m_ibStartData += cbConsumed ;

	DebugTrace( (DWORD_PTR)this, "CONSUMED %d ibStart %d ibEnd %d StartData %d EndData %d",
		cbConsumed, m_ibStart, m_ibEnd, m_ibStartData, m_ibEndData ) ;

#ifdef	CIO_DEBUG
	if( m_ovl.m_ovl.Offset != 0 )	{
		m_ovl.m_ovl.Offset += cbConsumed ;
	}
#endif
	return	cbConsumed ;
}

BOOL	CTransmitPacket::InitRequest(	class	CIODriverSource&	driver,	CSessionSocket	*pSocket,	CIOPassThru*	pio, BOOL	&fAcceptRequests ) {
	return	pio->InitRequest( driver, pSocket, this, fAcceptRequests ) ;
}

unsigned	CTransmitPacket::Complete(	CIOPassThru*		pio,
									CSessionSocket*	pSocket,
									CPacket*	pPacket,
									BOOL&		fCompleteRequest )	{
	Assert( IsValidCompletion() ) ;

	pio->Complete(	pSocket, this, pPacket, fCompleteRequest ) ;
	return	m_cbBytes ;
}


unsigned
CTransmitPacket::Complete(
						CIO*		&pio,
						CSessionSocket*	pSocket
						)	{
/*++

Routine Description :

	Called by a CIODriver object when a TransmitFile has completed.
	We call the CIO objects completion function to do the main work.

Arguments :

	pio - an OUT parameter passed to CIO::Complete, which the CIO object
		can use to set the next CIO object.

	pSocket - socket associated with this stuff

Return Value :

	Number of bytes in the packet consumed.
	TransmitFile's cannot be partially consumed so the return value is
	always the same number of bytes as those sent.

--*/

	Assert( IsValidCompletion() ) ;
	pio->Complete( pSocket,	this,	pio	) ;
	return	m_cbBytes ;
}


unsigned
CControlPacket::Complete(
					CIOPassThru*		pio,
					CSessionSocket*	pSocket,
					CPacket*	pPacket,
					BOOL&		fCompleteRequest )	{

	Assert( 1==0 ) ;
	// Do NOT complete these
	//pio = m_pio ;
	return	m_cbBytes ;
}

unsigned
CControlPacket::Complete(
					CIO*&	pio,
					CSessionSocket*
					)	{
	Assert( 1==0 ) ;
	pio = m_control.m_pio ;
	return	m_cbBytes ;
}

void
CControlPacket::StartIO(
					CIO&	pio,
					BOOL	fStart
					)	{
/*++

Routine Description :

	This function is called when we want to setup a control
	packet to pass a CIO object into a CIODriver for processing.
	To ensure that only 1 thread is accessing CIODriver member
	variables etc... at a time, when we want to start a new
	CIO operation, we set up a packet and then process it as if
	it were a completed IO.  T

Arguments :

	pio - The CIO derived object we want to start
	fStart - Whether to call the CIO objects Start() function

Return Value :

	None.

--*/

	Assert( m_control.m_type == ILLEGAL );
	Assert( m_control.m_pio == 0 ) ;
	Assert(	m_control.m_fStart == FALSE ) ;

	m_control.m_type  = START_IO ;
	m_control.m_pio = &pio ;
	m_control.m_fStart = fStart ;
}

void
CControlPacket::StartIO(
				CIOPassThru&	pio,
				BOOL	fStart
				)	{
/*++

Routine Description :

	This function is called when we want to setup a control
	packet to pass a CIO object into a CIODriver for processing.
	To ensure that only 1 thread is accessing CIODriver member
	variables etc... at a time, when we want to start a new
	CIO operation, we set up a packet and then process it as if
	it were a completed IO.  T

Arguments :

	pio - The CIOPassThru derived object we want to start
	fStart - Whether to call the CIO objects Start() function

Return Value :

	None.

--*/


	Assert( m_control.m_type == ILLEGAL );
	Assert( m_control.m_pioPassThru == 0 ) ;
	Assert(	m_control.m_fStart == FALSE ) ;

	m_control.m_type = START_IO ;
	m_control.m_pioPassThru = &pio ;
	m_control.m_fStart = fStart ;
}

void
CControlPacket::Shutdown(
				BOOL	fCloseSource
				)	{
/*++

Routine Description :

	Set up a control packet so that when processed by a CIODriver
	the CIODriver will terminate all IO and shutdown.
	This is used whenever we want to drop a session.

Arguments :

	fCloseSource - if TRUE then we want the underlying socket or handle
		to be closed as well

Return Value :

	None.

--*/

	Assert( m_control.m_type == ILLEGAL );
	Assert( m_control.m_fCloseSource == FALSE ) ;

	m_control.m_type = SHUTDOWN ;
	m_control.m_fCloseSource = fCloseSource ;
}


unsigned
CExecutePacket::Complete(
			INOUT	CIO*&	pIn,
			IN CSessionSocket* pSocket
			) 	{
	pIn->Complete(	pSocket, this, pIn ) ;
	return	0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\packet.inl ===
inline	ExtendedOverlap::ExtendedOverlap() : 
/*++

Routine Description : 

	Build an extended overlap structure.
	Zero initialize.

Arguments : 

	None.

Return Value : 

	None.

--*/
	m_pHome( 0 ) {
	ZeroMemory( &m_ovl, sizeof( m_ovl ) ) ;
} 

inline	void*
CPacket::operator	new(	
					size_t	size,	
					CPacketCache*	pCache 
					) {
/*++

Routine Description : 

	Allocate memory for a CPacket object. If we can do so, 
	get the memory from the cache.

Arguments : 

	size - size of packet object
	pCache - optionally present pointer to a Cache to use

Return Value  : 

	Memory allocated for the CPacket object.

--*/

	if( pCache ) {
		return	pCache->Alloc( size ) ;
	}
	return	gAllocator.Allocate( size ) ;
}

inline	void
CPacket::operator	delete(	
						void	*pv 
						)	{
/*++

Routine Description : 

	Usually in C++ operator delete releases the memory for an object, 
	however since we want to do fancy memory management we 
	want to control how the memory is released more directly.
	SO, delete does NOTHING.  this means a delete of a CPacket
	will call the desctructor, however the caller still gets 
	to free the memory.

	Note : You can call desctructors directly in C++, however
	since there are several derived classes of CPacket, there
	is no good way to know which desctructor to call other than
	to let the compiler handle it.

	So after the caller uses delete on a CPacket to invoke
	the correct desctructor, they must then release the memory
	however they wish to do so.

Arguments : 

	pv - address of object we wont release

Return Value  :

	None.

--*/

}

inline	CPacket::CPacket(	CIODriver&	driver, BOOL fRead, BOOL fSkipQueue ) : 
/*++

Routine Desctiption : 

	Build a base CPacket object.
	We always start out knowing who our 'owner' is - 
	this is the CIODriver which will handle our completion 
	processing.

Arguments : 

	driver - CIOdriver which will handle IO completion processing 
		of this packet
	fRead - is this a read or write packet ?

Return Value : 

	None.

--*/
	m_pOwner( &driver ), 
	m_fRequest( TRUE ), 
	m_fSkipQueue( fSkipQueue ),
	m_cbBytes( 0 ),
	m_fRead( fRead ),
	m_dwExtra1( 0 ),
	m_dwExtra2( 0 ),
	m_pFileChannel( 0 )
{
	ASSIGNI( m_sequenceno, (DWORD)INVALID_SEQUENCENO ) ;
	ASSIGNI( m_iStream, (DWORD)INVALID_STRMPOSITION  ) ; 
}

inline	CPacket::CPacket(	CIODriver&	driver,	CPacket&	packet ) : 
/*++

Routine description : 

	Build a CPacket object which is a clone of another,
	however we may have a different owner.

Arguments : 

	driver - our owner
	packet - the packet we are to otherwise clone.

Return Value : 

	None.

--*/
	m_pOwner( &driver ), 
	m_fRequest( TRUE ),	
	m_cbBytes( packet.m_cbBytes ),
	m_fRead( packet.m_fRead ),
	m_dwExtra1( 0 ),
	m_dwExtra2( 0 ),
	m_pFileChannel( 0 )	{

	ASSIGNI( m_sequenceno, (DWORD)INVALID_SEQUENCENO );
	ASSIGNI( m_iStream, (DWORD)INVALID_STRMPOSITION );

	_ASSERT( EQUALSI( packet.m_iStream, (DWORD)INVALID_STRMPOSITION ) );
	_ASSERT( packet.m_fRequest == TRUE ) ;
	_ASSERT( !EQUALSI( packet.m_sequenceno, (DWORD)INVALID_SEQUENCENO ) );
}

inline	CPacket::~CPacket(	)	{
/*++

Routine Description : 

	Destroy a CPacket.

Arguments : 

	None.

Return Value : 

	NOne.

--*/
}

inline	BOOL	CPacket::operator>(	
						CPacket&	rhs 
						)	{
/*++

Routine Description : 

	Determine which if the Left Hand Side packet
	has a larger sequence number

Arguments : 

	rhs - packet on the Right Hand Side of a 'b>c' expression

Return Value : 

	TRUE if this packet has a larger sequenceno

--*/
	return	GREATER( m_sequenceno, rhs.m_sequenceno ) ;
}

inline	BOOL	CPacket::operator<( 
						CPacket&	rhs 
						)	{
/*++

Routine Description : 

	Does this packet have a smaller sequence number ?

Arguments : 

	rhs - Right hand side of b<c expression

Returns : 

	TRUE if this has a smaller sequence number

--*/
	return	LESSER( m_sequenceno, rhs.m_sequenceno ) ;
}

inline	CReadPacket*	CPacket::ReadPointer()	{
/*++

Routine Description : 

	Occassionally we are dealing with a packet through
	a pointer to a derived class, and we want to know 
	which of the derived classes the pointer is.
	In CReadPacket this will be overridden to return 
	the CReadPacket pointer.

Arguments : 

	NOne.

Return Value : 

	Always NULL.

--*/
	return	0 ;
}

inline	CWritePacket*	CPacket::WritePointer()	{
/*++

Routine Description : 

	Occassionally we are dealing with a packet through
	a pointer to a derived class, and we want to know 
	which of the derived classes the pointer is.
	In CWritePacket this will be overridden to return 
	the CWritePacket pointer.

Arguments : 

	NOne.

Return Value : 

	Always NULL.

--*/

	return	0 ;
}

inline	CTransmitPacket*	CPacket::TransmitPointer()	{
/*++

Routine Description : 

	Occassionally we are dealing with a packet through
	a pointer to a derived class, and we want to know 
	which of the derived classes the pointer is.
	In CTransmitPacket this will be overridden to return 
	the CTransmitPacket pointer.

Arguments : 

	NOne.

Return Value : 

	Always NULL.

--*/

	return	0 ;
}

inline	CControlPacket*		CPacket::ControlPointer()	{
/*++

Routine Description : 

	Occassionally we are dealing with a packet through
	a pointer to a derived class, and we want to know 
	which of the derived classes the pointer is.
	In CCOntrolPacket this will be overridden to return 
	the CControlPacket pointer.

Arguments : 

	NOne.

Return Value : 

	Always NULL.

--*/

	return	0 ;
}

inline	CRWPacket::CRWPacket(	
					CIODriver&	driver, 
					BOOL fRead 
					)	: 
/*++

Routine Description : 

	Create a default Read/Write packet.

Arguments : 

	driver - owning driver
	fRead - TRUE if this is a Read Packet

Return Value : 

	None.

--*/
	CPacket( driver, fRead ),	
	m_pbuffer( 0 ),	
	m_ibStart( 0 ),	
	m_ibEnd( 0 ),
	m_ibStartData( 0 ),	
	m_ibEndData( 0 )	{
}

inline	CRWPacket::CRWPacket(	
					CIODriver&	driver,	
					CBuffer&	pbuffer,	
					unsigned	size, 
					unsigned	cbTrailer, 
					BOOL fRead ) : 
/*++

Routine Description : 

	Create a default read/write packet with a provided buffer

Arguments : 

	driver - owning CIODriver
	pbuffer - buffer we will use
	size - size of our buffer
	fRead - TRUE if this is a read

Return Value : 

	None.

--*/
	CPacket( driver, fRead ),	
	m_pbuffer(	&pbuffer ),	
	m_ibStart( 0 ),
	m_ibEnd( size - cbTrailer ),	
	m_ibStartData( 0 ),	
	m_ibEndData( 0 ),
	m_cbTrailer( cbTrailer )	{
}

inline	CRWPacket::CRWPacket(	
						CIODriver&	driver,
						CBuffer&	pbuffer,	
						unsigned	ibStartData,	
						unsigned	ibEndData, 
						unsigned	ibStart, 
						unsigned	ibEnd, 
						unsigned	cbTrailer,
						BOOL fRead ) : 
/*++

Routine description : 

	Create a CRWPacket with all the fields full initiazlied

Arguments : 

	driver - owning driver
	pbuffer - buffer this packet is using
	ibStartData - start of data within buffer
	ibEndData - end of data within buffer
	ibStart - start offset within buffer we can use
	ibEnd - end offset within buffer we can use
	fRead - TRUE if this will be a read packet

Return Value : 

	None.

--*/
	CPacket( driver, fRead ) , 
	m_pbuffer( &pbuffer ), 
	m_ibStartData( ibStartData ), 
	m_ibEndData( ibEndData ),
	m_ibStart( ibStart ),	
	m_ibEnd( ibEnd ),
	m_cbTrailer( cbTrailer ) {

	_ASSERT( m_ibStart <= m_ibStartData ) ;
	_ASSERT(	m_ibEnd >= m_ibEndData ) ;
	_ASSERT(	m_ibStart <= m_ibEnd ) ;
	_ASSERT(	m_ibStartData <= m_ibEndData ) ;
	_ASSERT(	m_ibEnd + m_cbTrailer <= pbuffer.m_cbTotal ) ;
}

inline	CRWPacket::CRWPacket(	
					CIODriver&	driver,	
					CRWPacket&	packet 
					) : 
/*++

Routine Description : 

	Build a packet that is a clone of another except for 
	who the owning driver is

Arguments : 

	driver - owning driver
	packet - packet to be cloned

Return Value : 

	None.

--*/
	CPacket( driver, packet ), 
	m_pbuffer( packet.m_pbuffer ), 
	m_ibStartData( packet.m_ibStartData ),
	m_ibEndData( packet.m_ibEndData ), 
	m_ibStart( packet.m_ibStart ), 
	m_ibEnd( packet.m_ibEnd )	{
}
	

inline	CRWPacket::~CRWPacket()		{
}

inline	char*	CRWPacket::StartData(	
							void 
							)	{
/*++

Routine Description : 

	Get the address of the first byte with data in it.

Arguments : 

	None.

Return Value : 

	pointer to First usefull byte.

--*/
	
	_ASSERT( m_pbuffer != 0 ) ;
	return	&m_pbuffer->m_rgBuff[ m_ibStartData ] ;	
}

inline	char*	CRWPacket::EndData(	void )	{
/*++

Routine Description : 

	Get the address of the byte following the last byte with data in it.

Arguments : 

	None.

Return Value : 

	pointer to one beyond last byte with data

--*/

	_ASSERT(	m_pbuffer != 0 ) ;
	return	&m_pbuffer->m_rgBuff[ m_ibEndData ] ;
}

inline	char*	CRWPacket::Start( void )	{
/*++

Routine Description : 

	Get the address of the first byte we may mess with

Arguments : 

	None.

Return Value : 

	pointer to First usable byte

--*/

	_ASSERT(	m_pbuffer != 0 ) ;
	return	&m_pbuffer->m_rgBuff[ m_ibStart ] ;
}

inline	char*	CRWPacket::End( void )	{
/*++

Routine Description : 

	Get the address of the byte following the last byte we can use

Arguments : 

	None.

Return Value : 

	pointer to one beyond last usefull byte

--*/

	_ASSERT(	m_pbuffer != 0 ) ;
	return	&m_pbuffer->m_rgBuff[ m_ibEnd ] ;
}

inline	CReadPacket::CReadPacket(	
						CIODriver&	driver 
						) : 
/*++

Routine Description :

	Build a CReadPacket with the specified owner

Arguments : 

	driver - owning CIODriver, will do completion processing of packet

Return Value :

	None.

--*/
	CRWPacket( driver, TRUE )	{
	m_ovl.m_pHome = this ;
}

inline	CReadPacket::CReadPacket(	
					CIODriver& driver,	
					unsigned	size,
					unsigned	cbFront,	
					unsigned	cbTrailer,	
					CBuffer& pbuffer
					) : 
/*++

Routine Description : 

	Build a CReadPacket with the specified buffer and
	with the usefull area of the buffer restricted

Arguments : 

	driver - ownding CIODriver
	size - size of the buffer
	cbFront - padding space at front of buffer
	cbTail - padding space at tail of buffer
	pbuffer - buffer to use

Return Value : 

	None.
		
--*/
	CRWPacket( driver, pbuffer, size, cbTrailer, TRUE )	{
	m_ovl.m_pHome = this ;
	//	pbuffer should be initialized by CRWPacket() constructor !
	_ASSERT( cbFront < size ) ;
	_ASSERT( cbFront < m_pbuffer->m_cbTotal ) ;
	if( m_pbuffer != 0 )	{
		m_ibStartData += cbFront ;
	}
}

inline	CReadPacket::CReadPacket(	
					CIODriver&	driver,	
					CReadPacket&	packet 
					) : 
/*++

Routine description : 

	Build a CReadPacket that clones another CReadPacket

Arguments : 

	driver - owning driver object
	packet - packet to be cloned

Return Value : 

	None.

--*/
	CRWPacket( driver, packet ) {
	m_ovl.m_pHome = this ;
}

inline	CReadPacket::~CReadPacket()		{
}

inline	CReadPacket*	CReadPacket::ReadPointer()	{
	return	this ;
}

inline	CWritePacket::CWritePacket(	
				CIODriver	&driver,	
				CBuffer&	pbuffer,	
				unsigned	ibStartData, 
				unsigned ibEndData, 
				unsigned	ibStart,	
				unsigned	ibEnd,
				unsigned	cbTrailer
				) : 
/*++

Routine Description : 

	Build a CWritePacket.

Arguments : 

	driver - owning driver
	pbuffer - buffer to be used
	ibStartData - offset of data to be sent within buffer
	ibEndData - offset of last byte of data
	ibStart - Start of usable portion of buffer
	ibEnd - End of usable portion of buffer

Returns : 

	Nothing

--*/
	CRWPacket( driver, pbuffer, ibStartData, ibEndData, ibStart, ibEnd, cbTrailer )	{
	m_ibEndData = ibEndData ;
	m_ovl.m_pHome = this ;
}

inline	CWritePacket::CWritePacket(	
						CIODriver	&driver,	
						CWritePacket&	packet 
						) : 
/*++

Routine Description : 

	Build a CWritePacket cloned from another

Arguments : 

	driver - owning CIODriver
	packet - CWritePacket to clone

Returns : 

	Nothing

--*/
	CRWPacket( driver, packet ) {
	m_ovl.m_pHome = this ;
}

inline	CWritePacket::~CWritePacket()	{
}

inline	CWritePacket*	CWritePacket::WritePointer()	{
	return	this ;
}

inline	CTransmitPacket::CTransmitPacket(	
		CIODriver&	driver,	
		FIO_CONTEXT*	pFIOContext,
		unsigned	ibOffset, 
		unsigned	cbLength 
		) : 
/*++

Routine Description ; 

	Build a CTransmitPacket

Arguments : 

	driver - owning driver
	hFile - file to transmit
	ibOffset - first byte of file to send
	cbLength - number of bytes in file to send

Return Value : 

	None.

--*/
	CPacket( driver, FALSE ), 
	m_pFIOContext( pFIOContext ), 
	m_cbOffset( ibOffset ),
	m_cbLength( cbLength )  {
	m_ovl.m_pHome = this ;
	ZeroMemory( &m_buffers, sizeof( m_buffers ) ) ;
}

inline	CTransmitPacket::CTransmitPacket(	
			CIODriver&	driver,	
			CTransmitPacket&	packet 
			) : 
/*++

Routine Description : 

	Build a CTransmitPacket which clones another

Arguments : 

	driver - owning CIODriver
	packet - packet to clone

Return Value : 

	None.

--*/
	CPacket( driver, packet ), 
	m_pFIOContext( packet.m_pFIOContext ), 
	m_cbOffset( packet.m_cbOffset ), 
	m_cbLength( packet.m_cbLength ), 
	m_buffers( packet.m_buffers ) {
	m_ovl.m_pHome = this ;
}

inline	CTransmitPacket::~CTransmitPacket()	{
}

inline	CTransmitPacket*	CTransmitPacket::TransmitPointer()	{
	return	this ;
}

inline	CControlPacket::CControlPacket( 
		CIODriver&	driver 
		)	: 
/*++

Routine Description : 

	Build a CControlPacket

Arguments : 

	driver - owning driver, will do completion processing of this packet

Return Value : 

	None.

--*/
	CPacket( driver, FALSE )	{

	m_fRequest = FALSE ;

}

inline	BOOL	
CControlPacket::FLegal( 
					BOOL	fRead 
					)	{
	return	TRUE ;
}

inline	BOOL	
CControlPacket::IsValidRequest(	
				BOOL	fReadsRequireBuffers 
				)	{
/*++

Routine Description : 

	Check that the control packet is legally setup

Arguments : 

	fReadsRequireBuffers - TRUE indicates this CIODriver does not require
		that buffers be pre-allocated for reads
		we can ignore this.

Return Value : 

	TRUE if setup

--*/


	if( m_control.m_type != START_IO &&
		m_control.m_type != SHUTDOWN ) {
		return	FALSE ;
	}
	if( m_control.m_type == START_IO ) {
		if( m_control.m_pio == 0 &&
			m_control.m_pioPassThru == 0 ) 
			return	FALSE ;
		if( m_control.m_pio != 0 &&
			m_control.m_pioPassThru != 0 ) 
			return	FALSE ;
	}
	return	TRUE ;
}

inline	void	
CControlPacket::Reset(	)	{
/*++

Routine description : 

	Put a control packet back into a just created state

Arguments : 
	
	none.

Return Value : 

	none.

--*/

	_ASSERT( IsValidRequest( TRUE ) ) ;

	m_control.m_type = ILLEGAL ;
	m_control.m_pio = 0 ;
	m_control.m_pioPassThru = 0 ;
	m_control.m_fStart = FALSE ;

}

inline	CControlPacket*	CControlPacket::ControlPointer()	{
	return	this ;
}	

inline	BOOL	CPacket::IsValid() {
	if( m_ovl.m_pHome != this )		{
		return	FALSE ;
	}
	return	TRUE ;
}

	

inline	void
CPacket::ForwardRequest( 
				CSessionSocket*	pSocket 
				)	{
/*++

Routine description : 

	THis function will get the packet processed as if it has
	just completed.

Arguments : 

	pSocket - the CSessionSocket which this IO is associated with.

Return Value : 

	None.

--*/
	_ASSERT( !m_fRequest ) ;
	_ASSERT( pSocket != 0 ) ;

	if( m_fRead ) 
		m_pOwner->m_pReadStream->ProcessPacket( this, pSocket ) ;
	else
		m_pOwner->m_pWriteStream->ProcessPacket( this, pSocket ) ;
}



inline	BOOL	CReadPacket::IsValid() {
	return	TRUE ;
}

inline	BOOL	CWritePacket::IsValid()		{
	return	TRUE ;
}

inline	BOOL	CTransmitPacket::IsValid()	{
	return	TRUE ;
}

inline	
CExecutePacket::CExecutePacket(	CIODriver&	driver )	: 
	CPacket( driver, FALSE, TRUE ),
	m_cbTransfer( 0 ),
	m_fComplete( FALSE ),
	m_fLargerBuffer( FALSE ),
	m_pWrite( 0 )	{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\nscphack.cpp ===
#include	"tigris.hxx"
//#include	<windows.h>

DWORD
NetscapeHackFunction(
		LPBYTE		lpbBuffer,
		DWORD		cbBuffer,
		DWORD		cbBufferMax,
		DWORD&		cbNewHeader,
		LPBYTE		szHackString,
		BYTE		szRepairString[2]
		)	{

	
	if( cbBuffer == cbBufferMax ) {
		return	0 ;
	}

	//
	//	Find the end of the header !
	//
	BYTE	*lpbState = szHackString ;
	BYTE	*lpbEndBuffer = lpbBuffer + cbBuffer ;
	DWORD	cNewlines = 0 ;

	for( LPBYTE	lpbCurrent = lpbBuffer;
			lpbCurrent < lpbEndBuffer;
			lpbCurrent ++ ) {

		if( *lpbCurrent == '\n' ) {
			cNewlines ++ ;
		}

		if( *lpbCurrent == *lpbState ) {
			lpbState ++ ;
			if( *lpbState == '\0' ) {
				break ;
			}
		}	else	{
			if( *lpbCurrent == szHackString[0] ) {
				lpbState = &szHackString[1] ;
			}	else	{
				lpbState = &szHackString[0] ;
			}
		}
	}

	//
	//	Did we find the end of the header ??
	//
	if( lpbCurrent == lpbEndBuffer )
		return	0 ;
	
	if( cNewlines + cbBuffer > cbBufferMax ) {
		//
		//	No room to do buffer manipulation to make
		//	it into a good article !
		//
		return	0 ;
	}

	MoveMemory( lpbBuffer+cNewlines, lpbBuffer, cbBuffer ) ;
	LPBYTE	lpbBegin = lpbBuffer ;

	for( LPBYTE	lpbStart = lpbBuffer+cNewlines;
				lpbStart <= lpbCurrent+cNewlines ;
				lpbStart ++, lpbBuffer++ ) {

		*lpbBuffer = *lpbStart ;
		if( *lpbBuffer == szHackString[0] ) {
			*lpbBuffer++ = szRepairString[0] ;
			*lpbBuffer = szRepairString[1] ;
		}
	}
	cbNewHeader = (DWORD)(lpbBuffer - lpbBegin) ;
	
	return	cNewlines + cbBuffer ;
}

#ifdef	UNIT_TEST

int	
main(	int	argc, char**	argv ) {

	char	szTestString[] =
				"Subject: control message \n"
				"control: cancel <fjdklsfjlsd@fjdksl>\n"
				"approved: test\n"
				"from:  test \n"
				"\n\n"
				"body"
				"\r\n.\r\n" ;

	BYTE	rgb[4000] ;

	FillMemory( rgb, sizeof( rgb ), 0xcc ) ;

	CopyMemory( rgb, szTestString, sizeof( szTestString )-1 ) ;

	DWORD	cbHeader ;

	DWORD	cb =
	NetscapeHackFunction(
					rgb,
					sizeof( szTestString )-1,
					sizeof( rgb ),
					cbHeader,
					(BYTE*)"\n\n",
					(BYTE*)"\r\n"
					) ;

	if( memcmp( rgb+cb-5, "\r\n.\r\n", 5 ) != 0 )
		DebugBreak() ;
					
	FillMemory( rgb, sizeof( rgb ), 0xcc ) ;

	CopyMemory( rgb, szTestString, sizeof( szTestString )-1 ) ;

	DWORD	cbBuffer = sizeof( szTestString ) -1 + 5 ;
	rgb[cbBuffer] = 0xff ;

	cb =
	NetscapeHackFunction(
					rgb,
					sizeof( szTestString )-1,
					cbBuffer,
					cbHeader,
					(BYTE*)"\n\n",
					(BYTE*)"\r\n"
					) ;

	if( memcmp( rgb+cb-5, "\r\n.\r\n", 5 ) != 0 )
		DebugBreak() ;
						
	if( rgb[cbBuffer] != 0xff )
		DebugBreak() ;				
				
	FillMemory( rgb, sizeof( rgb ), 0xcc ) ;

	CopyMemory( rgb, szTestString, sizeof( szTestString )-1 ) ;

	cbBuffer = sizeof( szTestString ) -1 + 5 - 1;
	rgb[cbBuffer] = 0xff ;

	cb =
	NetscapeHackFunction(
					rgb,
					sizeof( szTestString )-1,
					cbBuffer,
					cbHeader,
					(BYTE*)"\n\n",
					(BYTE*)"\r\n"
					) ;

	if( cb != 0 )
		DebugBreak() ;
						
	if( rgb[cbBuffer] != 0xff )
		DebugBreak() ;				

	if( memcmp( rgb, szTestString, sizeof( szTestString ) - 1 ) != 0 ) {
		DebugBreak() ;
	}

	char	szIllegalString[] =
					"from: test \n"
					"subject: what \n"
					"howsthat: fjdskl \n"
					"no empty line\n"
					"again no emtpy line\n"
					"\r\n.\r\n" ;

	FillMemory( rgb, sizeof( rgb ), 0xcc ) ;

	CopyMemory( rgb, szIllegalString, sizeof( szIllegalString )-1 ) ;

	cbBuffer = sizeof( rgb ) - 1;
	rgb[cbBuffer] = 0xff ;

	cb =
	NetscapeHackFunction(
					rgb,
					sizeof( szTestString )-1,
					cbBuffer,
					cbHeader,
					(BYTE*)"\n\n",
					(BYTE*)"\r\n"
					) ;

	if( cb != 0 )
		DebugBreak() ;
						
	if( rgb[cbBuffer] != 0xff )
		DebugBreak() ;	
	
	if( memcmp( rgb, szIllegalString, sizeof( szIllegalString ) - 1 ) != 0 ) {
		DebugBreak() ;
	}
			
	return 0 ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\outfeed.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    outfeed.h

Abstract:

    This module contains class declarations/definitions for

		COutFeed

    **** Overview ****

	A COutFeed object accepts articles to be pushed to a peer, master,
	or slave.


Author:

    Carl Kadie (CarlK)     23-Jan-1995

Revision History:

!!! Pull "ToClient.h" to here because all outfeeds use the same client
--*/


#ifndef	_OUTFEED_H_
#define	_OUTFEED_H_

#include	"infeed.h"

//
//
//
// COutFeed - pure virtual base class for processing outgoing articles.
//			article.
//

class	COutFeed:	public CFeed 	{
private : 

	//
	//	The Queue which tracks all of the GROUPID/ARTICLEID's of the
	//	outbound articles !!
	//
	class	CFeedQ*			m_pFeedQueue ;

	//
	// No construction without a FeedQ provided !!
	//
	COutFeed(void) {};	


protected : 

	//
	//	String which is prepended to basic check commands !
	//
	static	char	szCheck[] ;

	//
	//
	//
	static	char	szTakethis[] ;

	//
	// Constructor is protected - you can only have derived types !
	//
	COutFeed(	
			class	CFeedQ*	pFeedQueue, 
			PNNTP_SERVER_INSTANCE pInstance
			) 	: m_pFeedQueue( pFeedQueue ), 
				m_pInstance( pInstance )
				{
	}

	//
	// virtual server instance for this feed
	//
	PNNTP_SERVER_INSTANCE	m_pInstance ;	


//
// Public Members
//

public : 

	//
	// Destructor
	//
	virtual ~COutFeed(void) {};

	BOOL	fInit(	
			PVOID	feedCompletionContext ) ;
			

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Outbound" ;
				}

	//
	//	Add an article to the queue of outbound messages 
	//
	inline	BOOL	
	Append(	GROUPID	groupid,	
			ARTICLEID	articleid 
			) ;

	//
	//	Get an article from the queue of outbound messages 
	//
	inline	BOOL	
	Remove(	GROUPID&	groupid,	
			ARTICLEID&	articleid 
			) ;		
	
	//
	//	Build the command string we will send to the remote site !
	//
	virtual	int		
	FormatCommand(	
			BYTE*	lpb,	
			DWORD	cb,	
			DWORD&	ibStart,	
			GROUPID	groupid,	
			ARTICLEID	articleid, 
			CTOCLIENTPTR&	pArticle 
			) = 0 ;

	//
	//	Does the remote site want us to retry the posting !
	//
	virtual	BOOL	
	RetryPost(	NRC	nrcCode ) = 0 ;

	//
	//	Does this type of feed support a 'streaming' mode ? 
	//
	virtual	BOOL
	SupportsStreaming() = 0 ;


	//
	//	How many bytes does CheckCommandLength() stick before the 
	//	message-id in a 'check' command ? ? 
	//
	virtual	DWORD	
	CheckCommandLength() ;

	//
	//	Puts a check command in the buffer - if the call 
	//	fails because there is not enough room then return
	//	value is 0 and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//
	virtual	DWORD
	FormatCheckCommand(	
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid	
			) ;

	//
	//	Puts a 'takethis' command into the buffer - if the call
	//	fails because there is not enough room return value is 0 
	//	and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//	If it fails because the article no longer exists GetLastError() == ERROR_FILE_NOT_FOUND
	//
	virtual	DWORD
	FormatTakethisCommand(
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid, 
			CTOCLIENTPTR&	pArticle
			) ;

	virtual void IncrementFeedCounter(DWORD nrc) {
		::IncrementFeedCounter((struct _FEED_BLOCK *) m_feedCompletionContext, nrc);
	}
};

class	COutToMasterFeed :	public	COutFeed	{
public : 

	COutToMasterFeed(	class	CFeedQ*	pFeedQueue, 
						PNNTP_SERVER_INSTANCE pInstance)
		: COutFeed( pFeedQueue, pInstance) {}

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Out To Master" ;
				}


	//
	//	Build the command string we will send to the remote site !
	//
	int		
	FormatCommand(	
			BYTE*	lpb,	
			DWORD	cb,	
			DWORD&	ibStart,	
			GROUPID	groupid,	
			ARTICLEID	articleid, 
			CTOCLIENTPTR& pArticle 
			) ;

	BOOL	
	RetryPost(	
			NRC	nrcCode 
			) ;

	//
	//	Does this feed type support a mode-streaming version? (No)
	//
	BOOL
	SupportsStreaming() ;

	//
	//	Puts a check command in the buffer - if the call 
	//	fails because there is not enough room then return
	//	value is 0 and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//
	DWORD
	FormatCheckCommand(	
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid	
			) ;
	//
	//	Puts a 'takethis' command into the buffer - if the call
	//	fails because there is not enough room return value is 0 
	//	and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//	If it fails because the article no longer exists GetLastError() == ERROR_FILE_NOT_FOUND
	//
	DWORD
	FormatTakethisCommand(
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid, 
			CTOCLIENTPTR&	pArticle
			) ;
} ;


class	COutToSlaveFeed :	public	COutFeed	{
public : 

	COutToSlaveFeed(	class	CFeedQ*	pFeedQueue, PNNTP_SERVER_INSTANCE pInstance) 
		: COutFeed( pFeedQueue, pInstance) {}
	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Out To Slave" ;
				}

	//
	//	Build the command string we will send to the remote site !
	//
	int		
	FormatCommand(	
			BYTE*	lpb,	
			DWORD	cb,	
			DWORD&	ibStart,	
			GROUPID	groupid,	
			ARTICLEID	articleid, 
			CTOCLIENTPTR& pArticle 
			) ;

	BOOL	
	RetryPost(	
			NRC	nrcCode 
			) ;

	//
	//	Does this feed type support a mode-streaming version? (No)
	//
	BOOL
	SupportsStreaming() ;


} ;

class	COutToPeerFeed :	public	COutFeed	{
public : 

	COutToPeerFeed(	class	CFeedQ*	pFeedQueue, PNNTP_SERVER_INSTANCE pInstance) 
		: COutFeed( pFeedQueue, pInstance ) {}

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Out To Peer" ;
				}

	//
	//	Build the command string we will send to the remote site !
	//
	int		
	FormatCommand(	
			BYTE*	lpb,	
			DWORD	cb,	
			DWORD&	ibStart,	
			GROUPID	groupid,	
			ARTICLEID	articleid, 
			CTOCLIENTPTR& pArticle 
			) ;

	BOOL	
	RetryPost(	
			NRC	nrcCode 
			) ;

	//
	//	Does this feed type support a mode-streaming version? (Yes)
	//
	BOOL
	SupportsStreaming() ;

	//
	//	Puts a 'takethis' command into the buffer - if the call
	//	fails because there is not enough room return value is 0 
	//	and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//	If it fails because the article no longer exists GetLastError() == ERROR_FILE_NOT_FOUND
	//
	DWORD
	FormatTakethisCommand(
			BYTE*		lpb, 
			DWORD		cb, 
			GROUPID		groupid, 
			ARTICLEID	articleid, 
			CTOCLIENTPTR&	pArticle
			) ;

} ;


//
// Other functions
//

BOOL fAddArticleToPushFeeds(
						PNNTP_SERVER_INSTANCE pInstance,
						CNEWSGROUPLIST& newsgroups,
						CArticleRef artrefFirst,
						char * multiszPath,
						CNntpReturn & nntpReturn
						);

BOOL MatchGroupList(
			   char * multiszPatterns,
			   CNEWSGROUPLIST& newsgroups
			   );


inline	BOOL
COutFeed::Append(	GROUPID	groupid,	
					ARTICLEID	articleid ) {

	if( m_pFeedQueue != 0 ) 
		return	m_pFeedQueue->Append( groupid, articleid ) ;
	return	FALSE ;
}

inline	BOOL
COutFeed::Remove(	GROUPID&	groupid,	
					ARTICLEID&	articleid )	{

	if( m_pFeedQueue != 0 ) 
		return	m_pFeedQueue->Remove( groupid, articleid ) ;
	return	FALSE ;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\passthru.cpp ===
#define	SECURITY_WIN32
#include	<buffer.hxx>

#define	INCL_INETSRV_INCS
#include	"tigris.hxx"

/*
extern	"C"	{
#include <rpc.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <ntlmsp.h>
#include <sslsp.h>
}

#include	"sslmsgs.h"
*/

CIOPassThru::CIOPassThru() : CIO( 0 ) {
}

BOOL
CIOPassThru::InitRequest(	CIODriverSource&	driver,	CSessionSocket*	pSocket, CReadPacket*	pPacket,	BOOL	&fAcceptRequests ) {

	fAcceptRequests = TRUE ;
	CReadPacket*	pRead = driver.Clone( pPacket ) ;

	if( pRead != 0 ) {
		BOOL	eof ;
		driver.IssuePacket( pRead, pSocket, eof ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIOPassThru::InitRequest(	CIODriverSource&	driver,	CSessionSocket*	pSocket, CWritePacket*	pWritePacket,	BOOL	&fAcceptRequests ) {
	fAcceptRequests = TRUE ;

	CWritePacket*	pWrite = driver.Clone( pWritePacket ) ;
	if( pWrite != 0 ) {
		BOOL	eof ;
		driver.IssuePacket( pWrite, pSocket, eof ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIOPassThru::InitRequest(	CIODriverSource&	driver,	CSessionSocket*	pSocket, CTransmitPacket*	pTransmitPacket,	BOOL	&fAcceptRequests ) {
	fAcceptRequests = TRUE ;

	CTransmitPacket*	pTransmit = driver.Clone( pTransmitPacket ) ;
	if( pTransmit != 0 ) {
		BOOL	eof ;
		driver.IssuePacket( pTransmit, pSocket, eof ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIOPassThru::Start(	CIODriverSource&	driver,	CSessionSocket*	pSocket,	
						BOOL&	fAcceptRequest,	BOOL&	fRequireRequests,	unsigned	cAhead  ) {

	fAcceptRequest = TRUE ;
	fRequireRequests = TRUE ;

	return	TRUE ;
}

BOOL
CIOPassThru::Start( CIODriver&	driver,	CSessionSocket*	pSocket, unsigned	cAhead ) {
	_ASSERT( 1==0 ) ;
	return	FALSE ;
}

int
CIOPassThru::Complete(	
				CSessionSocket*	pSocket,	
				CReadPacket*	pPacket,	
				CPacket*	pRequest,	
				BOOL	&fComplete
				) {

	fComplete = TRUE ;
	
	pRequest->m_cbBytes = pPacket->m_cbBytes ;

	return	pPacket->m_cbBytes ;
}	
		

int	
CIOPassThru::Complete(	
				CSessionSocket*	pSocket,	
				CWritePacket*	pPacket,	
				CPacket*	pRequest,	
				BOOL&	fComplete
				) {

	fComplete = TRUE ;

	pRequest->m_cbBytes = pPacket->m_cbBytes ;

	return	pPacket->m_cbBytes ;
}

void
CIOPassThru::Complete(	
				CSessionSocket*	pSocket,	
				CTransmitPacket*	pPacket,	
				CPacket*	pRequest,	
				BOOL&	fComplete
				)		{

	fComplete = TRUE ;

	pRequest->m_cbBytes = pPacket->m_cbBytes ;
	pRequest->m_ovl.m_ovl = pPacket->m_ovl.m_ovl ;

}

CIOSealMessages::CIOSealMessages( CEncryptCtx& encrypt ) :
	m_encrypt( encrypt )
{
}

void
CIOSealMessages::Shutdown(
			CSessionSocket*	pSocket,
			CIODriver&		driver,
			enum	SHUTDOWN_CAUSE	cause,
			DWORD			dw
			) {

}

BOOL
CIOSealMessages::InitRequest(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,
						CWritePacket*	pWritePacket,	
						BOOL	&fAcceptRequests
						) {

	fAcceptRequests = TRUE ;

	CWritePacket*	pWrite = driver.Clone( pWritePacket ) ;
	if( pWrite != 0 ) {
		BOOL	eof ;

		if( !SealMessage(	pWrite ) )		{

			_ASSERT( 1==0 ) ;

		}	else	{
			pWrite->m_pSource = pWritePacket->m_pOwner ;
			driver.IssuePacket( pWrite, pSocket, eof ) ;
			return	TRUE ;
		}
	}
	if( pWrite ) {
		//delete	pWrite ;
		CPacket::DestroyAndDelete( pWrite ) ;
	}
	return	FALSE ;
}

BOOL
CIOSealMessages::Start(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						BOOL&	fAcceptRequest,	
						BOOL&	fRequireRequests,	
						unsigned	cAhead
						) {

	fAcceptRequest = TRUE ;
	fRequireRequests = TRUE ;

	return	TRUE ;
}

int	
CIOSealMessages::Complete(	
					CSessionSocket*	pSocket,	
					CWritePacket*	pPacket,	
					CPacket*	pRequest,	
					BOOL&	fComplete
					) {

	fComplete = TRUE ;

	// As far as the requestor is concerned there are no additional bytes !
	CWritePacket*	pWritePacket = pRequest->WritePointer() ;
	if( pWritePacket )	{
		pWritePacket->m_cbBytes = pWritePacket->m_ibEndData - pWritePacket->m_ibStartData ;
	}	else	{
		_ASSERT( 1==0 ) ;
		// May eventually handle TransmitPackets here !!
	}
	return	pPacket->m_cbBytes ;
}

CIOUnsealMessages::CIOUnsealMessages( CEncryptCtx&	encrypt ) :
	m_encrypt( encrypt ),
	m_pbuffer( 0 ),
	m_ibStart( 0 ),
	m_ibStartData( 0 ),
	m_ibEnd( 0 ),
	m_ibEndData( 0 ) ,
	m_cbRequired( 0 )
{
}

void
CIOUnsealMessages::Shutdown(
			CSessionSocket*	pSocket,
			CIODriver&		driver,
			enum	SHUTDOWN_CAUSE	cause,
			DWORD			dw
			) {

}

BOOL
CIOUnsealMessages::InitRequest(	
					CIODriverSource&	driver,	
					CSessionSocket*	pSocket,
					CReadPacket*	pReadPacket,	
					BOOL	&fAcceptRequests
					) {

	fAcceptRequests = TRUE ;

	CReadPacket*	pRead = driver.Clone( pReadPacket ) ;
	if( pRead != 0 ) {
		BOOL	eof ;
		pRead->m_pSource = pReadPacket->m_pOwner ;
		driver.IssuePacket( pRead, pSocket, eof ) ;
		return	TRUE ;
	}
	if( pRead ) {
		//delete	pRead;
		CPacket::DestroyAndDelete( pRead ) ;
	}				
	return	FALSE ;
}

BOOL
CIOUnsealMessages::Start(	CIODriverSource&	driver,	CSessionSocket*	pSocket,	
						BOOL&	fAcceptRequest,	BOOL&	fRequireRequests,	unsigned	cAhead  ) {
	fAcceptRequest = TRUE ;
	fRequireRequests = TRUE ;


	//driver.SetChannelDebug( 3 ) ;

	return	TRUE ;
}


BOOL	
CIOUnsealMessages::DecryptInputBuffer(	
					IN	LPBYTE	pBuffer,
					IN	DWORD	cbInBuffer,
					OUT	DWORD&	cbLead,
					OUT	DWORD&	cbConsumed,
					OUT	DWORD&	cbParsable,
					OUT	DWORD&	cbRequired,
					OUT	BOOL&	fComplete
					)	{

	LPBYTE	lpDecrypted;
	LPBYTE	lpRemaining = pBuffer ;
	LPBYTE	lpEnd = pBuffer + cbInBuffer ;
	DWORD	cbDecrypted;
	DWORD	cbOriginal = cbInBuffer ;
	LPBYTE	pNextSeal = 0 ;
	BOOL	fRet ;
	//DWORD	cbParsable = 0;
	

	//
	// initialize to zero so app does not inadvertently post large read
	//
	cbLead = 0 ;
	cbParsable = 0 ;
	cbRequired = 0 ;
	fComplete = FALSE ;
	cbConsumed = 0 ;
	

	TraceFunctEnterEx( (LPARAM)this, "CIOUnsealMessagse::DecryptInputBuffer" );

	while( cbInBuffer &&
			(fRet = m_encrypt.UnsealMessage(	lpRemaining,
										cbInBuffer,
										&lpDecrypted,
										&cbDecrypted,
										&cbRequired,
										&pNextSeal )) )
	{
	    _ASSERT( cbRequired < 32768 );
		DebugTrace( (LPARAM)this,
					"Decrypted %d bytes at offset %d",
					cbDecrypted,
					lpDecrypted - pBuffer );

		fComplete = TRUE ;

		if( cbLead == 0 ) {
			cbLead = (DWORD)(lpDecrypted - pBuffer) ;
		}	else	{

			//
			// overwrite the encryption header -
			//	NOTE - only move the decrypted bytes !!
			//
			MoveMemory( pBuffer + cbLead + cbParsable,
						lpDecrypted,
						cbDecrypted );
		}

		//
		// increment where the next parsing should take place
		//
		cbParsable += cbDecrypted;

		//
		//	move to the next potential seal buffer
		//
		if( pNextSeal != NULL ) {

			_ASSERT( pNextSeal > lpRemaining );
			_ASSERT( pNextSeal <= lpRemaining + cbInBuffer );
			//
			// remove header, body and trailer from input buffer length
			//
			cbInBuffer -= (DWORD)(pNextSeal - lpRemaining);
			lpRemaining = pNextSeal ;

		}	else	{
			//
			// in this case we received a seal message at the boundary
			// of the IO buffer
			//
			cbInBuffer = 0;
			lpRemaining = lpEnd ;
		}
	}

	DebugTrace( (LPARAM)this,
				"UnsealMessage returned: 0x%08X",
				GetLastError() );

	cbConsumed = (DWORD)(lpRemaining - pBuffer) ;

	if( fRet == FALSE ) {

		DWORD	dwError = GetLastError();

		DebugTrace( (LPARAM)this,
					"UnsealMessage returned: 0x%08X",
					GetLastError() );

		//
		// deal with seal fragments at the end of the IO buffer
		//
		if ( dwError == SEC_E_INCOMPLETE_MESSAGE )	{
			_ASSERT( cbInBuffer != 0 );

			//
			// move the remaining memory forward
			//
			DebugTrace( (LPARAM)this,
						"Seal fragment remaining: %d bytes",
						cbInBuffer );
		}	else	if( dwError != NO_ERROR ) 	{
			return	FALSE;
		}
	}
	return	TRUE ;
}



int	
CIOUnsealMessages::Complete(	
					CSessionSocket*	pSocket,	
					CReadPacket*	pPacket,
					CPacket*	pRequest,	
					BOOL&	fComplete
					) {
/*++

Routine Description :

	A read has completed, and we wish to figure out if we can unseal the data.
	This function will attempt to unseal the data when it has accumulated
	enough bytes to build one SSL packet.

Arguments :

	pSocket - The socket the IO is happening on
	pPacket - The packet which completed
	pRequest - The packet where we will put the unseal'd data for further
		processing
	fComplete - OUT parameter, we set this to true when we have
		been able to unseal the data and put this in pRequest

Return Value :

	Number of bytes of the completed read packet which we consumed

--*/

	DWORD	cbReturn = 0 ;
	
	if( m_pbuffer != 0 ) {
	
		DWORD	cbToCopy = 0 ;		
		if( m_cbRequired == 0 ) {
			cbToCopy = min( min( 32, pPacket->m_cbBytes ), (m_ibEnd - m_ibEndData) ) ;
		}	else	{

			cbToCopy = min( m_cbRequired, pPacket->m_cbBytes ) ;

			_ASSERT( m_ibEnd <= m_pbuffer->m_cbTotal ) ;
			_ASSERT( cbToCopy < (m_ibEnd - m_ibEndData) ) ;

			m_cbRequired -= cbToCopy ;
		}
		_ASSERT( cbToCopy <= m_ibEnd - m_ibEndData ) ;
		_ASSERT( m_ibEnd >= m_pbuffer->m_cbTotal ) ;
		CopyMemory( &m_pbuffer->m_rgBuff[ m_ibEndData ], pPacket->StartData(), cbToCopy ) ;
		m_ibEndData += cbToCopy ;		
		cbReturn = cbToCopy ;
	}	else	{
		m_pbuffer = pPacket->m_pbuffer ;
		_ASSERT( m_cbRequired == 0 ) ;
		m_ibStart = pPacket->m_ibStart ;
		m_ibEnd = pPacket->m_ibEnd ;
		m_ibStartData = pPacket->m_ibStartData ;
		m_ibEndData = pPacket->m_ibEndData ;
		_ASSERT( m_cbRequired == 0 ) ;	// Set to 0 on last packet we succesfully unsealed !
	}

	if( m_cbRequired == 0 ) {
		DWORD	cbConsumed = 0 ;
		DWORD	ibStartData = 0 ;
		DWORD	ibEndData = 0 ;
		DWORD	cbData = 0 ;
		fComplete = FALSE ;


		BOOL	fSuccess = DecryptInputBuffer(
										(LPBYTE)&m_pbuffer->m_rgBuff[m_ibStartData],
										m_ibEndData - m_ibStartData,
										ibStartData,
										cbConsumed,
										cbData,
										m_cbRequired,
										fComplete
										) ;
        _ASSERT( m_cbRequired < 32768 );
		ibStartData += m_ibStartData ;
		ibEndData = ibStartData + cbData ;
		DWORD	ibEnd = m_ibStartData + cbConsumed ;

		_ASSERT( ibEndData <= ibEnd ) ;
		_ASSERT( ibStartData <= ibEndData ) ;

		if( !fSuccess )	{
			DWORD	dw = GetLastError() ;
	
			//
			//	Fatal error - blow off the session.
			//
			
			pPacket->m_pOwner->UnsafeClose( pSocket,	
											CAUSE_ENCRYPTION_FAILURE,
											dw ) ;											
			return	pPacket->m_cbBytes ;

		}	else	{

			//
			//	If we haven't figured out how many bytes we've used already
			//	than we'll use all of the bytes in the packet, we either
			//	decrypted some or will set aside the bytes we couldn't
			//	decrypt for the next try.
			//
			
			if( cbReturn == 0 ) {
				cbReturn = pPacket->m_cbBytes ;
			}


			if( fComplete ) {

				//
				//	We have successfully unsealed a bunch of data
				//	Mark the pRequest packet with the data we unsealed,
				//	and update our internal state.
				//
		
				_ASSERT( pRequest->ReadPointer() != 0 ) ;

				CReadPacket*	pReadRequest = (CReadPacket *)pRequest ;

				pReadRequest->m_pbuffer = m_pbuffer ;
				pReadRequest->m_ibStart = m_ibStart ;
				pReadRequest->m_ibStartData = ibStartData ;
				//pReadRequest->m_ibEndData = ibEndData ; Not needed !
				pReadRequest->m_ibEnd = ibEndData ;
				pReadRequest->m_cbBytes = ibEndData - ibStartData ;
				_ASSERT( cbData == pReadRequest->m_cbBytes ) ;

				if( ibEnd == m_ibEndData ) {
					m_pbuffer = 0 ;
					m_ibStart = m_ibStartData = m_ibEnd = m_ibEndData = 0 ;
				}	else	{
					m_ibStartData = ibEnd ;
					m_ibStart = ibEnd ;

				}

			}
			if( m_cbRequired != 0 ) {
				if( m_cbRequired > m_ibEnd - m_ibEndData ) {	
					//
					// Need to allocate a larger buffer and move the data there !!
					//

					DWORD	cbOldBytes = m_ibEndData - m_ibStartData ;
					DWORD	cbTotal = cbOldBytes + m_cbRequired ;					
					DWORD	cbOut = 0 ;

					CBuffer*	pbufferNew = new( cbTotal, cbOut )	CBuffer( cbOut ) ;

					_ASSERT( cbOldBytes < pbufferNew->m_cbTotal ) ;
					_ASSERT( cbTotal <= pbufferNew->m_cbTotal ) ;

					if( pbufferNew == 0 ) {
						//
						//	Fatal error - blow off the session !
						//
						pPacket->m_pOwner->UnsafeClose( pSocket,
														CAUSE_OOM,
														0 ) ;
						return	pPacket->m_cbBytes ;

					}	else	{
						//
						//	We have a buffer large enough to hold the entire
						//	Seal'd message, so copy the fraction we have into
						//	the buffer, and set things up so that future read
						//	completions will append to this buffer.
						//
						CopyMemory( &pbufferNew->m_rgBuff[0],
									&m_pbuffer->m_rgBuff[m_ibStartData],
									cbOldBytes ) ;
						m_pbuffer = pbufferNew ;
						m_ibStart = 0 ;
						m_ibStartData = 0 ;
						m_ibEnd = pbufferNew->m_cbTotal ;
						m_ibEndData = cbOldBytes ;
					}
				}
			}
		}
	}

	//
	//	If we did not complete the request, issue another read
	//
	if( !fComplete ) {
		CReadPacket*	pRead = pPacket->m_pOwner->CreateDefaultRead( m_cbRequired ) ;

		if( pRead != 0 ) {
			pRead->m_pSource = pRequest->m_pOwner ;
			BOOL	eof ;
			pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
		}	else	{

			//
			//	Fatal error, blow off the session.
			//
			pPacket->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_OOM,
											0 ) ;
		}
	}


	_ASSERT( cbReturn != 0 ) ;
	return	cbReturn ;
}

DWORD	CIOTransmitSSL::MAX_OUTSTANDING_WRITES = 4 ;
DWORD	CIOTransmitSSL::RESTORE_FLOW = 1 ;

CIOTransmitSSL::CIOTransmitSSL(	
							CEncryptCtx&	encrypt,
							CIODriver&		sink
							) :
/*++

Routine Description :

	Construct a CIOTransmitSSL object.
	We will initialize ourselves into a neutral state,
	InitRequest must be called before we start transferring a file.

Arguments :

	encryp - The encryption context we should use
	sink -	The CIODriver managing our socket IO's

Return Value :

	none.

--*/
		m_encryptCtx( encrypt ),
		m_pSocketSink( &sink ),
		m_pbuffers( 0 ),
		m_cReads( 0 ),
		m_cWrites( 0 ),
		m_cWritesCompleted( 0 ),
		m_ibCurrent( 0 ),
		m_ibEnd( 0 ),
		m_cbTailConsumed( 0 ),
		m_fFlowControlled( FALSE ),
		m_cFlowControlled( LONG_MIN ),
		m_fCompleted( FALSE )	{

}

BOOL
CIOTransmitSSL::Start(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						BOOL&	fAcceptRequest,	
						BOOL&	fRequireRequests,	
						unsigned	cAhead
						) {

	fAcceptRequest = TRUE ;
	fRequireRequests = TRUE ;

	return	TRUE ;
}

void
CIOTransmitSSL::Shutdown(
			CSessionSocket*	pSocket,
			CIODriver&		driver,
			enum	SHUTDOWN_CAUSE	cause,
			DWORD			dw
			) {
/*++

Routine Description :

	This function is called to notify us of any IO errors that
	occurred.  If the error is serious, we will make sure everything
	gets torn down.  (IO's could fail on the file or socket, but not
	both.  If a failure of either occurs, tear down both.)

Arguments :

	pSOcket - Socket IO is associated with
	driver - The driver that is notifying us
	cause -	The reason we're being notified
	dw -	Optional DWORD, we ignore it

Return Value :
	
	None.

--*/

	if( cause != CAUSE_NORMAL_CIO_TERMINATION ) {

		Term( pSocket, cause, dw ) ;

	}

}

void
CIOTransmitSSL::ShutdownFunc(
			void*	pv,
			SHUTDOWN_CAUSE	cause,
			DWORD	dwError
			)	{

}	
			

void
CIOTransmitSSL::Reset()	{

	if( m_pFileChannel != 0 )	{
		m_pFileChannel->ReleaseSource() ;
	}

	m_pDriverSource = 0 ;

	m_pFileChannel = 0 ;
	m_pFileDriver = 0 ;
	m_pbuffers = 0 ;
	m_cReads = 0 ;
	m_cWrites = 0 ;
	m_cWritesCompleted = 0 ;
	m_ibCurrent = 0 ;
	m_ibEnd = 0 ;
	m_cbTailConsumed = 0 ;
	m_fFlowControlled = FALSE ;
	m_cFlowControlled = LONG_MIN ;
	m_fCompleted = FALSE ;	

}

void
CIOTransmitSSL::Term(
					CSessionSocket*	pSocket,	
					enum	SHUTDOWN_CAUSE	cause,
					DWORD	dwError
					)	{
/*++

Routine Description :

	Call the necessary UnsafeClose() functions to tear down sessions
	and CIODrivers.

Arguments :

	pSocket - Socket IO is associate with
	cause -		The reason for termination, if this is CAUSE_NORMAL_CIO_TERMINATION
				we don't tear down the socket, just the file IO
	dwError - optional DWORD

Returns

	Nothing

--*/


	if( m_pFileDriver ) {
		m_pFileChannel->ReleaseSource() ;
		m_pFileDriver->UnsafeClose(
							pSocket,
							cause,	
							dwError
							) ;
	}

	if( cause != CAUSE_NORMAL_CIO_TERMINATION ) {

		if( m_pSocketSink ) {
			m_pSocketSink->UnsafeClose(
								pSocket,
								cause,
								dwError
								) ;
		}
	}	
}



BOOL
CIOTransmitSSL::InitRequest(
						CIODriverSource&	driver,
						CSessionSocket*		pSocket,
						CTransmitPacket*	pTransmitPacket,
						BOOL&				fAcceptRequests
						) {
/*++

Routine Description :

	We have received a Transmit File request - all the necessary
	CIODriver's etc... to manage async IO for the file.

Arguments :

	driver - CIODriverSource which received the request
	pSocket - socket we are doing the IO on
	pTransmitPacket - the request
	fAcceptRequests - OUT parameter indicating whether we
		can accept additional requests while a first is
		in progress.  We always set this to FALSE>

Return Value :
	
	TRUE if Successfull, FALSE otherwise.

--*/

	m_pbuffers = &pTransmitPacket->m_buffers ;

	fAcceptRequests = FALSE ;

	_ASSERT( m_pFileChannel == 0 ) ;
	_ASSERT( m_pFileDriver == 0 ) ;
	_ASSERT( m_cWrites == 0 ) ;
	_ASSERT( m_cWritesCompleted == 0 ) ;
	_ASSERT( m_ibCurrent == 0 ) ;
	_ASSERT( m_ibEnd == 0 ) ;
	_ASSERT( m_fCompleted == FALSE ) ;

	m_pSocketSink = &driver ;
	m_pDriverSource = pTransmitPacket->m_pOwner ;

	m_pFileChannel = new	CFileChannel( ) ;

	if( m_pFileChannel &&
		m_pFileChannel->Init(	pTransmitPacket->m_pFIOContext,
								pSocket,
								pTransmitPacket->m_cbOffset,
								TRUE,	
								pTransmitPacket->m_cbLength
								) )	{

		m_pFileDriver = new	CIODriverSink( driver.GetMediumCache() ) ;
		if( m_pFileDriver &&
			m_pFileDriver->Init(	m_pFileChannel,
									pSocket,
									CIOTransmitSSL::ShutdownFunc,
									(void*)this,
									m_encryptCtx.GetSealHeaderSize(),
									0,
									m_encryptCtx.GetSealTrailerSize()
									) )	{

			m_cWrites = 0 ;	
			m_cWritesCompleted = 0 ;
			m_ibCurrent = 0 ;
			m_ibEnd = pTransmitPacket->m_cbLength ;
			m_cbTailConsumed = 0 ;
			m_fCompleted = FALSE ;

			//
			//	All of our IO Drivers are ready to go -
			//	now we need to compute our initial member variables
			//	and start the transfer going.
			//

			if( m_pFileDriver->SendReadIO( pSocket, *this, TRUE ) ) {
				return	TRUE ;
			}
		}
	}

	m_pbuffers = 0 ;
	m_pFileChannel = 0 ;
	m_pFileDriver = 0 ;
	m_pSocketSink = 0 ;

	return	FALSE ;
}

BOOL	
CIOTransmitSSL::Start(	
				CIODriver&	driver,	
				CSessionSocket*	pSocket,
				unsigned cAhead
				)	{
/*++

Routine Description :

	This function is called when we're ready to start issuing async
	reads against the file.  We will issue a bunch to get us going.

Arguments :

	driver - the CIODriver letting us know we're ready
	pSocket - Socket the IO is associated with
	cAhead - how many reads are already outstanding against the file
		should always be zero

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	//
	//	FIRST - determine what we are going to do with transmit buffers !
	//

	BOOL	eof = FALSE ;
	CReadPacket*	pRead = 0 ;
	BOOL	fCompleted = FALSE ;

	DWORD	cbConsume = 0 ;

	m_cReads = -2 ;

	while( !m_fCompleted &&
			cAhead < 2 &&
			m_ibCurrent < m_ibEnd  )	{
		pRead = driver.CreateDefaultRead( cbMediumRequest ) ;

		if( pRead !=  0 ) {
			pRead->m_pSource = m_pDriverSource ;
			ComputeNextRead( pRead ) ;
			cAhead ++ ;
			m_cWrites ++ ;
			InterlockedIncrement( &m_cReads ) ;
			driver.IssuePacket( pRead, pSocket, eof ) ;
		}
	}	

	return	TRUE ;
}


void
CIOTransmitSSL::ComputeNextRead(	
						CReadPacket*	pRead
						) {
/*++

Routine Description :

	Figure out what the offsets of the next read will be.
	Since we know that File reads always fill their buffers, we
	can anticipate how many bytes we'll get, and advance
	m_ibCurrent to help figure out when we've issued enough reads.

Arguments :

	pRead - The read packet we'll be issuing

Return Value :

	None.

--*/

	if( m_cWrites == 0 ) {

		if( m_pbuffers->Head ) {
			
			CopyMemory( pRead->StartData(), m_pbuffers->Head, m_pbuffers->HeadLength ) ;
			pRead->m_ibStartData += m_pbuffers->HeadLength ;
			pRead->m_dwExtra1 = m_pbuffers->HeadLength ;

		}
	}

	DWORD	cbWillRead = min(	pRead->m_ibEnd - pRead->m_ibStartData,
								m_ibEnd - m_ibCurrent ) ;

	m_ibCurrent += cbWillRead ;

	pRead->m_dwExtra2 = m_ibCurrent ;

}

BOOL
CIOTransmitSSL::CompleteRead(
						CReadPacket*	pRead,
						CWritePacket*	pWrite
						)	{
/*++

Routine Description :

	Given a completed Read, adjust a Write Packet to account for
	any leading text in the packet, also figure out whether this
	was the last read issued.

Arguments :

	pRead - The read packet
	pWrite - The write we will be issuing

Return Value :

	TRUE if this was the last read

--*/

	if( pRead->m_dwExtra1 != 0 ) {
		_ASSERT( pRead->m_dwExtra1 <= pRead->m_ibStartData ) ;
		pWrite->m_ibStartData -= pRead->m_dwExtra1 ;
	}

	if( pRead->m_dwExtra2 == m_ibEnd )
		return	TRUE ;

	return	FALSE ;
}

int
CIOTransmitSSL::Complete(
					CSessionSocket*	pSocket,
					CReadPacket*	pRead,
					CIO*&			pio )	{
/*++

Routine Description :

	Process an async read that just completed from a file.

Arguments :

	pSocket - the socket we will be sending our data out on
	pRead - the read packet that just completed.
	pio - an out parameter allowing us to set the next CIO operation

Return Value :

	number of bytes consumed.

--*/

	BOOL	eof ;
	
	CWritePacket*	pExtraWrite = 0 ;

	InterlockedDecrement( &m_cReads ) ;
	
	//
	//	Check if we should do another read
	//
	if( !m_fCompleted &&
		m_ibCurrent < m_ibEnd ) {

		long sign = InterlockedIncrement( &m_cFlowControlled ) ;

		if( sign < 0 ) {

			do	{
				
				CReadPacket*	pNewRead = pRead->m_pOwner->CreateDefaultRead( cbMediumRequest ) ;
				
				if( pNewRead ) {
					pNewRead->m_pSource = m_pDriverSource ;
					ComputeNextRead( pNewRead ) ;
					pNewRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;
					m_cWrites ++ ;
				}	else	{

					//	fatal error - blwo things off
					Term( pSocket, CAUSE_OOM, 0 ) ;
					pio = 0 ;
					return	pRead->m_cbBytes ;
	
				}
			}	while(
						InterlockedIncrement( &m_cReads ) < 0 &&
						!m_fCompleted &&
						m_ibCurrent < m_ibEnd ) ;
		}
	}

	//
	//	Build the write packet we will use to send the data
	//	out to the socket.
	//
	CWritePacket*	pWrite = m_pSocketSink->CreateDefaultWrite( pRead ) ;
	if( pWrite == 0 ) {

		//	fatal error
		Term( pSocket, CAUSE_OOM, 0 ) ;
		pio = 0 ;
		return	pRead->m_cbBytes ;	
	}

	pWrite->m_pSource = pRead->m_pSource ;

	//
	//	Adjust the write packet for lead text, figure out
	//	whether we have issued the last read
	//
	BOOL	fComplete = CompleteRead( pRead, pWrite ) ;

	//
	//	We have completed the final read - send the trailer text
	//	if necessary
	//
	if( fComplete ) {

		//
		//	Is there any trailer text ?
		//
		if( m_pbuffers && m_pbuffers->Tail ) {

			LPVOID	lpvTail = m_pbuffers->Tail ;
			DWORD	cbTail = m_pbuffers->TailLength ;

			DWORD	cbAvailable = pWrite->m_ibEnd - pWrite->m_ibEndData ;

			cbAvailable = min( cbAvailable, cbTail ) ;

			//	
			//	Put as much trailer text as we can into the
			//	WritePacket we have available.
			//
			if( cbAvailable != 0 ) {

				CopyMemory( pWrite->EndData(), lpvTail, cbAvailable ) ;
				pWrite->m_ibEndData += cbAvailable ;
				cbTail -= cbAvailable ;

			}

			
			//
			//	Do we need another packet for the remaining trailer text ?
			//
			if( cbTail != 0 ) {

				pExtraWrite = m_pSocketSink->CreateDefaultWrite( m_pbuffers->TailLength ) ;
				if( !pExtraWrite ) {

					CPacket::DestroyAndDelete( pWrite ) ;		
					Term( pSocket, CAUSE_OOM, 0 ) ;
					pio = 0 ;
					return	pRead->m_cbBytes ;
				}	else	{
					pExtraWrite->m_pSource = pRead->m_pSource ;
					CopyMemory( pExtraWrite->StartData(), m_pbuffers->Tail, m_pbuffers->TailLength ) ;
					pExtraWrite->m_ibEndData = pExtraWrite->m_ibStartData + m_pbuffers->TailLength ;

				}
			}
		}	
	}

	//
	//	Encrypt our data
	//
	if( !SealMessage( pWrite ) ) {
		
		CPacket::DestroyAndDelete( pWrite ) ;
		if( pExtraWrite )
			CPacket::DestroyAndDelete( pExtraWrite ) ;
		Term( pSocket, CAUSE_ENCRYPTION_FAILURE, 0 ) ;
		pio = 0 ;
		return	pRead->m_cbBytes ;
	}


	pWrite->m_pSource = pRead->m_pSource ;

	//
	//	Figure out whether we need to apply any flow control !
	//	Always do this before writing data to the client,
	//	to ensure that the Write completion function will be called
	//	after any monkey business we do here.
	//
	if( m_cWrites - m_cWritesCompleted > MAX_OUTSTANDING_WRITES ) {

		if( !m_fFlowControlled ) {
			m_cFlowControlled = -1 ;
			m_fFlowControlled = TRUE ;
		}

	}	else	{

		if( !m_fFlowControlled ) {
			m_cFlowControlled = LONG_MIN ;
		}

	}

	//
	//	Mark that we are now completed before we issue our writes	
	//	but after we have bumped m_cWrites !
	//
	if( fComplete )
		m_fCompleted = TRUE ;

	//
	//	Send the data to the client.
	//
	pWrite->m_pOwner->IssuePacket( pWrite, pSocket, eof ) ;

	//
	//	If there's an extra blob of text, send it
	//
	if( pExtraWrite ) {
	
		if( !SealMessage( pExtraWrite ) ) {

			CPacket::DestroyAndDelete( pExtraWrite ) ;
			Term( pSocket, CAUSE_ENCRYPTION_FAILURE, 0 ) ;
			pio = 0 ;
			return	pRead->m_cbBytes ;

		}	else	{

			pExtraWrite->m_pSource = pRead->m_pSource ;
			pExtraWrite->m_pOwner->IssuePacket( pExtraWrite, pSocket, eof ) ;

		}
	}

	//
	//	If we're finished, reset the Current CIO pointer for this driver.
	//
	if( fComplete )	{
		pio = 0 ;
	}

	return	pRead->m_cbBytes ;
}

int	
CIOTransmitSSL::Complete(	
					CSessionSocket*	pSocket,	
					CWritePacket*	pPacket,	
					CPacket*	pRequest,	
					BOOL&	fComplete
					) {
/*++

Routine Description :

	Process Write completions to the remote end
	of the socket.

Arguments :

	pSocket - Socket we are sending data out on
	pPacket - the Write that completed
	pRequest - the Packet that started things going in InitRequest()
	fComplete - OUT parameter - set this to TRUE when
			we have transferred the whole file.

Return Value :

	number of bytes of the packet consumed - always consume all the bytes


--*/

	m_cWritesCompleted ++ ;

	long	cFlowControlled = 0 ;

	if( m_fCompleted && m_cWritesCompleted == m_cWrites ) {

		//	everything is done - mark the request with the
		//	number of bytes transferred, and then
		//	indicate to the caller that it should be completed.

		pRequest->m_cbBytes =	m_pbuffers->HeadLength +
								m_pbuffers->TailLength +
								m_ibEnd ;
		fComplete = TRUE ;

		//
		//	This should only tear down the CIODriver managing the files
		//	async IO.  NOTE - Term() should call ReleaseSource() on the
		//	file channel and ensure the handle doesn't get accidentally closed.
		//	
		Term( pSocket, CAUSE_NORMAL_CIO_TERMINATION, 0 ) ;

		//
		//	We can safely do a reset here, because we only reach
		//	this point if the last read completed, so we are the only
		//	thread touching these member variables.
		//
		Reset() ;


	}	else	if( m_fFlowControlled ) 	{

		BOOL	eof ;

		if( m_cWrites - m_cWritesCompleted <= RESTORE_FLOW &&
			m_pSocketSink != 0 ) {


			cFlowControlled = m_cFlowControlled + 1 ;
			
			while( cFlowControlled >= 0
					&& !m_fCompleted
					&&	m_ibCurrent < m_ibEnd ) {

				CReadPacket*	pRead = m_pFileDriver->CreateDefaultRead( cbMediumRequest ) ;
				
				if( pRead == 0 ) {

					// fatal error - blow off session !

				}	else	{
					pRead->m_pSource = m_pDriverSource ;
					InterlockedIncrement( &m_cReads ) ;
					m_cWrites ++ ;
					ComputeNextRead( pRead ) ;
					pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
				}
				cFlowControlled -- ;
			}
			InterlockedExchange( &m_cFlowControlled, LONG_MIN ) ;
			m_fFlowControlled = FALSE ;
		}
	}
	return	pPacket->m_cbBytes ;
}






CIOServerSSL::CIOServerSSL(
			CSessionState* pstate,
			CEncryptCtx& encrypt
			) :
/*++

Routine Description :

	Create a default CIOServerSSL object that is ready to start Conversing with
	a client.

Arguments :

	pstate - The state that should start off the state machine when we've
		successfully SSL exchanged with the remote end
	encrypt - The CEncryptCtx managing our SSL keys etc...

Return Value :

	None.

--*/
	CIO(pstate ),
	m_encrypt( encrypt ),
	m_pWrite( 0 ),
	m_fAuthenticated( FALSE ),
	m_cPending( 1 ),
	m_fStarted( FALSE ),
	m_ibStartData( 0 ),
	m_ibEndData( 0 ),
	m_ibEnd( 0 )
{
}

CIOServerSSL::~CIOServerSSL()	{

	if( m_pWrite != 0 )
		CPacket::DestroyAndDelete( m_pWrite ) ;
	m_pWrite = 0 ;
	
}

BOOL
CIOServerSSL::Start(
				CIODriver&	driver,	
				CSessionSocket*	pSocket,	
				unsigned cAhead
				) {
/*++

Routine Description :

	Issue the first IO required when a client is trying to
	negogtiate with us.
	We want to read the first SSL blob.

Arguments :

	driver - CIODriver through which we issue IO's
	pSocket - socket associated with this IO
	cAhead - number of completed reads ahead in the queue (should be 0)

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/


	CReadPacket*	pRead = 0 ;
	if( !m_fStarted )	{
		pRead = driver.CreateDefaultRead( cbMediumRequest ) ;
		if( pRead != 0 ) {
			BOOL	eof ;
			driver.IssuePacket(  pRead, pSocket, eof ) ;
			m_fStarted = TRUE ;
			return	TRUE ;
		}
	}	else	{
		return	TRUE ;
	}
	//
	//	Error Fall Through !!
	//
	if( pRead != 0 ) {
		//delete	pRead ;
		CPacket::DestroyAndDelete( pRead ) ;
	}
	return	FALSE ;
}


BOOL
CIOServerSSL::SetupSource(	
					CIODriver&	driver,
					CSessionSocket*	pSocket
					) {
/*++

Routine Description :

	After successfully doing a SSL logon, setup a CIODriverSource
	to filter and encrypt all of the IO from here on.

Arguments :

	driver - the CIODriver which is controlling the top level of IO
	pSocket - socket associated with all IO !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/


	CIOPASSPTR	pIOReads = new( driver )	CIOUnsealMessages( m_encrypt ) ;
	CIOPASSPTR	pIOWrites = new( driver )	CIOSealMessages( m_encrypt ) ;
	CIOPASSPTR	pIOTransmits = new( driver )	CIOTransmitSSL( m_encrypt, driver ) ;

	//
	//	Ensure that allocations succeeded !
	//
	if( pIOReads == 0 ||
		pIOWrites == 0 ||
		pIOTransmits == 0 )	{

		return	FALSE ;

	}

	CIODriverSource*	pSource = new	CIODriverSource(
													driver.GetMediumCache()
													) ;

	if( pSource ) {
		CIOPASSPTR	pTemp = 0 ;
		if(	driver.InsertSource( 	*pSource,	
									pSocket,
									0,
									m_encrypt.GetSealHeaderSize(),
									0,
									m_encrypt.GetSealTrailerSize(),
									*pIOReads,
									*pIOWrites,
									*pIOTransmits,
									pTemp,
									pTemp
									) )	{
			pSource->SetRequestSequenceno( m_sequencenoNextRead, m_sequencenoNextWrite ) ;
			return	TRUE ;
		}
	}	

	if( pSource )
		delete	pSource ;
	return	FALSE ;
}



int
CIOServerSSL::Complete(	CSessionSocket*	pSocket,	
						CReadPacket*	pRead,	
						CIO*&	pio
						) {
/*++

Routine Description :

	we are in the midst of an SSL negogtiation - accumulate reads in a buffer
	in case the SSL negogtiation blobs are split across reads, and then let
	the CEncryptCtx do the meat of the negogtiation.
	
Arguments :

	pSocket - Socket this IO is associated with
	pRead -		Packet containing the completed data
	pio	-		The current CIO pointer

Return Value :

	number of bytes we use from the read
	
--*/

	TraceFunctEnter( "CIOServerSSL::Complete - CReadPacket" ) ;

	// Save the sequenceno from the packets for initializing the new Source Stream
	ASSIGN( m_sequencenoNextRead, pRead->m_sequenceno );
	INC(m_sequencenoNextRead);

	if( !m_fAuthenticated ) {

		BYTE*		lpbOut = 0 ;
		DWORD		cbBuffOut;
		BOOL		fMore ;
		long		sign = 0 ;
		IN_ADDR		addr;


		//
		//	In most cases we'll need to send something back immediately -
		//	so pre-allocate it !!
		//

		if( m_pWrite == 0 )
			m_pWrite = pRead->m_pOwner->CreateDefaultWrite( cbMediumRequest ) ;
		if( m_pWrite == 0 ) {
			//
			//	Fatal error - blow off session !
			//
			pRead->m_pOwner->UnsafeClose(
										pSocket,	
										CAUSE_OOM,
										0
										) ;
			pio = 0 ;
			return	pRead->m_cbBytes ;
		}	else	{

			//
			//	Save buffers and offsets, because we may not have a complete blob
			//	of data, and if we don't, we want to accumulate reads into a
			//	complete blob.
			//

			if( m_pbuffer == 0 ) {

				m_pbuffer = pRead->m_pbuffer ;
				m_ibStartData = pRead->m_ibStartData ;
				m_ibEndData = pRead->m_ibEndData ;
				m_ibEnd = pRead->m_ibEnd ;

			}	else	{

				//
				//	Append this read to what we have room for in the buffer !!
				//
				DWORD	cbAvailable = m_ibEnd - m_ibEndData ;
				DWORD	cbRequired = pRead->m_ibEndData - pRead->m_ibStartData ;
				if( cbRequired > cbAvailable ) {

					//
					//	Blob is too big for us - blow off the session !
					//

					pRead->m_pOwner->UnsafeClose(
												pSocket,	
												CAUSE_OOM,
												0
												) ;
					CPacket::DestroyAndDelete( m_pWrite ) ;
					m_pWrite = 0 ;
					pio = 0 ;
					return	pRead->m_cbBytes ;

				}	else	{
					//
					//	Catenate this latest read together with our other data !
					//
					CopyMemory( &m_pbuffer->m_rgBuff[m_ibEndData], pRead->StartData(), cbRequired ) ;
					m_ibEndData += cbRequired ;
				}
			}

			//
			// need to set cbBuffOut to the maximum sizeof the output buffer
			//
			cbBuffOut = (DWORD)((DWORD_PTR)m_pWrite->End() - (DWORD_PTR)m_pWrite->StartData());

			//
			// need to get a stringized instance of our local IP addr
			//
			addr.s_addr = pSocket->m_localIpAddress;

    		char	szPort[16] ;
    		ULONG   cbExtra = 0; // Number of bytes in tail not processed by successful handshake

			_itoa( pSocket->m_nntpPort, szPort, 10 ) ;

			DWORD	dw = m_encrypt.Converse(
								&m_pbuffer->m_rgBuff[m_ibStartData],
								m_ibEndData - m_ibStartData,
								(BYTE*)m_pWrite->StartData(),
								&cbBuffOut,
								&fMore,
								inet_ntoa( addr ),
								szPort,
								pSocket->m_context.m_pInstance,
								pSocket->m_context.m_pInstance->QueryInstanceId(),
								&cbExtra
								) ;

			if( dw == SEC_E_INCOMPLETE_MESSAGE ) {

				//	indicate that we still need more data - following code will issue
				//	read !
				fMore = TRUE ;

				//
				//	Should be no outgoing data !!
				//	
				_ASSERT( cbBuffOut == 0 ) ;


			}	else if( dw != NO_ERROR ) {

				//
				//	Fatal error - tear down session !!
				//
				pRead->m_pOwner->UnsafeClose( pSocket,	
											CAUSE_ENCRYPTION_FAILURE,
											dw
											) ;
				pio = 0 ;
				return	pRead->m_cbBytes ;

			}	else	{

				//
				//	Reset member variables - we processed a complete blob,
				//	and we may process more
				//

				m_pbuffer = 0 ;
				m_ibStartData = 0 ;
				m_ibEndData = 0 ;
				m_ibEnd = 0 ;

				//
				//	If we got the last blob, then authentication is complete !
				//

				if( !fMore )
					m_fAuthenticated = TRUE ;

				//
				//	Any bytes to send to the client ?
				//
				if( cbBuffOut != 0 ) {

					//
					//	Take care that there is no way our destructor
					//	could destroy a packet we've issued !!
					//

					CWritePacket*	pWrite = m_pWrite ;
					m_pWrite = 0 ;

					//
					//	Okay - now send the data !
					//

					pWrite->m_ibEndData = pWrite->m_ibStartData + cbBuffOut ;
					BOOL	eof= FALSE ;
					InterlockedIncrement( &m_cPending ) ;
					pWrite->m_pOwner->IssuePacket( pWrite, pSocket, eof ) ;
				}
			}
		}

		//
		//	Are we done yet ??
		//
		if( !fMore ) {

			_ASSERT( m_fAuthenticated == TRUE ) ;

			if( cbBuffOut != 0 )
				sign = InterlockedDecrement( &m_cPending ) ;

			if( sign == 0 ) {
				// Write has completed !!	
				//
				//	Prepare the next state in the state machine - and then check to see whether
				//	we should do the initialization !!
				//

				if( SetupSource( *pRead->m_pOwner, pSocket ) ) {
					_ASSERT( m_pState != 0 ) ;
					CIORead*	pReadIO = 0 ;
					CIOWrite*	pWriteIO = 0 ;
					if( m_pState->Start( pSocket, pRead->m_pOwner, pReadIO, pWriteIO ) ) {

						if( pWriteIO != 0 ) {
							if( !pRead->m_pOwner->SendWriteIO( pSocket, *pWriteIO ) )	{
								pWriteIO->DestroySelf() ;
								if( pReadIO ) {
									pReadIO->DestroySelf() ;
									pReadIO = 0 ;
								}
							}
						}
						pio = pReadIO ;

					}	else	{
						ErrorTrace( (DWORD_PTR)this, "Failed state machine" ) ;

						pRead->m_pOwner->UnsafeClose(
													pSocket,	
													CAUSE_IODRIVER_FAILURE,
													0
													) ;
						pio = 0 ;

					}
				}
			}	else	{

				pio = 0 ;

			}

		}	else	{
			//
			//	Not finished convers'ing - issue more reads !
			//

			CReadPacket*	pReadPacket = pRead->m_pOwner->CreateDefaultRead( cbMediumRequest ) ;
			if( pReadPacket  != 0 ) {
				BOOL	eof ;
				pReadPacket->m_pOwner->IssuePacket( pReadPacket, pSocket, eof ) ;
			}	else	{
				pRead->m_pOwner->UnsafeClose(
											pSocket,	
											CAUSE_OOM,
											0
											) ;
				pio = 0 ;
				//
				//	We will fall through and return the right thing !!
				//
			}
		}
	}	else	{
		//
		//	If we are authenticated we should no longer be in this state !
		//
		_ASSERT( 1==0 ) ;
	}
	return	pRead->m_cbBytes ;
}	

int	
CIOServerSSL::Complete(	
				CSessionSocket*	pSocket,	
				CWritePacket*	pWrite,	
				CIO*& pio
				) {

	TraceFunctEnter( "CIOServerSSL::Complete - CWritePacket" ) ;

	// Save the sequenceno from the packets for initializing the new Source Stream
	ASSIGN( m_sequencenoNextWrite, pWrite->m_sequenceno );
	INC(m_sequencenoNextWrite);

	long	sign = InterlockedDecrement( &m_cPending ) ;

	if( sign == 0 ) {
		if( m_fAuthenticated ) {
			// Write has completed !!	
			//
			//	Prepare the next state in the state machine - and then check to see whether
			//	we should do the initialization !!
			//
			if( SetupSource( *pWrite->m_pOwner, pSocket ) ) {
				_ASSERT( m_pState != 0 ) ;
				CIORead*	pReadIO = 0 ;
				CIOWrite*	pWriteIO = 0 ;
				if( m_pState->Start( pSocket, pWrite->m_pOwner, pReadIO, pWriteIO ) ) {

					if( pReadIO != 0 ) {
						if( !pWrite->m_pOwner->SendReadIO( pSocket, *pReadIO ) )
							pReadIO->DestroySelf() ;
					}
					pio = pWriteIO ;

				}	else	{
					ErrorTrace( (DWORD_PTR)this, "Failed state machine" ) ;

					// bugbug ... should do UnsafeClose(), but how do we clean up security 1?
					_ASSERT( 1==0 ) ;

				}
			}
		}
	}	else	if( m_fAuthenticated ) {
		pio = 0 ;
	}
	return pWrite->m_cbBytes ;
}

void
CIOServerSSL::Complete(	CSessionSocket*	pSocket,	CTransmitPacket*	pTransmit,	CIO*& pio/*CIOPassThru*&	pio,
					CPacket*	pRequest,	BOOL	&fComplete */) {

	_ASSERT( 1==0 ) ;
	return ;
}

void
CIOServerSSL::Shutdown(
			CSessionSocket*	pSocket,
			CIODriver&	driver,
			SHUTDOWN_CAUSE	cause,
			DWORD	dwError
			)	{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\pcache.h ===
/*++

	PCACHE.H

	This file defines several classes which manage the allocation of 
	packets, buffers and other object.
	
	Most of this is build upon a general Cache mechanism defined in gcache.h
	which uses InterlockedExchange to allocate object.
	This caching is done to avoid excessive use of Critical Sections which
	protect the underlying CPool objects which actually allocate the RAW 
	memory.

	This file declares pairs of classes - 
	for each 'Cache'ing' allocator, there is a CClassAllocator derived
	object which manages cache misses.  This object is derived from CClassAllocator
	so that the 'cache'ing objects can derive from CCache.

--*/

#ifndef	_PCACHE_H_
#define	_PCACHE_H_

#include 	"cbuffer.h"
#include	"gcache.h"





//--------------------------------------------------------
//
//	@class	The CPacket class represents IO operations.  These are queueable
//	operations and are therefore derived from CQElement.
//


class	CPacketAllocator : public	CClassAllocator	{
//
//	This class caches all sorts of packets.
//
private : 
	//
	//	CPacket knows about us
	//
	friend	class	CPacket ;
	//
	//	PacketPool is the underlying CPool object which manages the raw memory
	//
	static	CPool	PacketPool ;
	//
	//	A private constructor - there should only be one CPacketAllocator object ever.
	//
	CPacketAllocator() ;
public : 
	//
	//	Initialize the class - mostly just initializes our CPool
	//
	static	BOOL	InitClass() ;

	//
	//	Release everything allocated by InitClass()
	//
	static	BOOL	TermClass() ;


	//
	//	Allocate memory for a packet
	//
	LPVOID	Allocate(	DWORD	cb, DWORD	&cbOut = CClassAllocator::cbJunk )	{	cbOut = cb ; return	PacketPool.Alloc() ;	}
	
	//
	//	Release a packets memory
	//
	void	Release( void *lpv )		{	PacketPool.Free( lpv ) ;	}

#ifdef	DEBUG
	void	Erase(	void*	lpv ) ;
	BOOL	EraseCheck(	void*	lpv ) ;
	BOOL	RangeCheck( void*	lpv ) ;
	BOOL	SizeCheck(	DWORD	cb ) ;
#endif
} ;

class	CPacketCache : public	CCache	{
//
//	This class actually cache's the CPacket objects
//
private : 
	//
	//	Pointer to the underlying PacketAllocator we use
	//
	static	CPacketAllocator*	PacketAllocator ;
	//
	//	space to hold cache'd pointers
	//
	void*	lpv[4] ;
public : 
	//
	//	Set static pointer - can not fail
	//
	static	void	InitClass(	CPacketAllocator*	Allocator )	{	PacketAllocator = Allocator ; }

	//
	//	Create a cache - we just let CCache initialize our buffer
	//
	inline	CPacketCache(	) :		CCache( lpv, 4 )	{} ;
	//
	//	Release everything in the cache back to the allocator
	//
	inline	~CPacketCache( ) {		Empty( PacketAllocator ) ;	}
	
	//
	//	Free a packet's memory to cache if possible
	//
	inline	void	Free(	void*	lpv )  	{	CCache::Free( lpv, PacketAllocator ) ;	}
	
	//
	//	Allocate memory from the cache if possible.
	//
	inline	void*	Alloc(	DWORD	size,	DWORD&	cbOut=CCache::cbJunk )  	{	return	CCache::Alloc( size, PacketAllocator, cbOut ) ; }
} ;



#endif	// _PCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\queue.h ===
//
// Queue.h
// 
// This file defines two templates, one each for a standard
// stack and queue.  These templates take two classes parameters,
// one which specifies the base element type of the stack or
// queue (ie. a queue of Struct Junk{}) and another which 
// specifies an implementation class.   
// 
// It is intended that the base element type is always derived
// from CQElement.
//
// The net result is that the Templates provide a type safe 
// way to try out various methods of implementing stacks 
// and queues.
//
// 




#ifndef	_QUEUE_H_
#define	_QUEUE_H_

#ifdef	DEBUG
#define	QUEUE_DEBUG
#endif

#include	<windows.h>
#ifndef	UNIT_TEST
#include	<dbgtrace.h>
#endif

#include	"qbase.h"


class	COrderedList	{
private : 
	CQElement*	m_pHead ;
	CQElement*	m_pTail ;
public : 
	COrderedList() ;
	~COrderedList() ;

	void	Insert( CQElement *, BOOL (* pfnCompare)( CQElement *, CQElement *) ) ;
	void	Append(	CQElement *, BOOL (* pfnCompare)( CQElement *, CQElement *) ) ;
	BOOL	IsEmpty() ;
	CQElement*	GetHead( ) ;
	CQElement*	RemoveHead( ) ;
} ;


#ifndef	_NO_TEMPLATES_

template< class Element > 
class	TOrderedList : private COrderedList	{
private : 
	static	BOOL	Compare( CQElement *, CQElement * ) ;
public : 
	TOrderedList();
	void	Insert( Element * ) ;
	void	Append( Element * ) ;
	Element*	GetHead() ;
	Element*	RemoveHead() ;
	BOOL	IsEmpty() ;
} ;

#else


#define	DECLARE_ORDEREDLIST( Element )	\
class	TOrderedList ## Element : private COrderedList	{	\
private :	\
	static	BOOL	Compare( CQElement *, CQElement * ) ;	\
public :	\
	void	Insert( Element * ) ;	\
	void	Append( Element * ) ;	\
	Element*	GetHead() ;	\
	Element*	RemoveHead() ;	\
	BOOL	IsEmpty() ;	\
} ;

#define	INVOKE_ORDEREDLIST( Element )	TOrderedList ## Element


#endif

#include	"queue.inl"


#endif	// _QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\queue.cpp ===
//
// Queue.cpp
//
// This file contains several classes which implement various
// flavors of Queues and Stacks.  The intention is to develop
// stacks and queues which are Thread safe and DO NOT USE blocking
// primitives.
//
// Since it has taken several iterations to arrive at partially
// succesfull results, each class is used in a template defined
// in queue.h.  This template (CQueue) is designed to allow
// specification of an Implementation class and a base type
// for elements in the queue, which is always CQElement in this code.
//
// The most succesfull classes below are :
// CQAppendSafe - this class is MT safe for Appending elements,
//  Removal of elements would require a Critical Section to
//  become thread safe.
//

#include "tigris.hxx"

#define Assert  _ASSERT

#include	"queue.h"

#if 0 
CQAppendSafe::CQAppendSafe( ) {

	//
	// The Queue always contains at least one element
	// which is never removed.  This ensures that the
	// Head and Tail pointers ALWAYS point at different things.
	//
	m_pHead = m_pTail = &m_special ;
	m_special.m_pNext = 0 ;

}

CQAppendSafe::~CQAppendSafe( ) {

	Assert( m_pHead == m_pTail ) ;
	Assert( m_pTail->m_pNext == 0 ) ;
	Assert( m_pHead == &m_special ) ;

}

CQElement*
CQAppendSafe::Remove( void ) {
	CQElement	*pTemp = 0 ;
#ifdef	QUEUE_DEBUG
	int	loopcount = 0 ;
#endif	QUEUE_DEBUG

	do	{
		//
		// If the Head Elements NEXT pointer is NULL then we
		// can't remove because we won't know what to set it to.
		// (QUEUE NEVER IS EMPTY - m_pHead MUST ALWAYS BE NON NULL !)
		//
		if( m_pHead->m_pNext != 0 ) {
			pTemp = m_pHead ;
			m_pHead = pTemp->m_pNext ;
			Assert( pTemp != m_pHead ) ;	// Can't have circular lists!
		}	else 	{
			return	0 ;
		}

		//
		// The m_special Element must always remain in the list.
		// NOTE : after appending, we MAY not be able to get another
		// element if the other threads haven't finished with their NEXT pointers.
		//
		if( pTemp == &m_special )
			Append( pTemp ) ;

#ifdef	QUEUE_DEBUG
		//
		// Should never require more than 2 loop iterations !
		//
		Assert( loopcount++ < 2 ) ;
#endif
	}	while( pTemp == &m_special ) ;

	return	pTemp ;
}

CQElement*
CQAppendSafe::Front( void ) {
	return	m_pHead ;
}

void
CQAppendSafe::Append( CQElement*	pAppend ) {
	pAppend->m_pNext = 0 ;
	CQElement*	pTemp = (CQElement*)InterlockedExchangePointer( (void**)&m_pTail, pAppend ) ;
	Assert( pTemp != 0 ) ;
	pTemp->m_pNext = pAppend ;
}

BOOL
CQAppendSafe::IsEmpty( ) {

	return	m_pHead->m_pNext == 0 ;
}

		
CQSafe::CQSafe()	{
	InitializeCriticalSection( &m_critRemove ) ;
}

CQSafe::~CQSafe()	{
	DeleteCriticalSection(	&m_critRemove ) ;
}

CQElement*
CQSafe::Remove( void )	{

	EnterCriticalSection(	&m_critRemove ) ;
	CQElement*	pRtn = CQAppendSafe::Remove() ;
	LeaveCriticalSection(	&m_critRemove ) ;
	return	pRtn ;
}

CQElement*
CQSafe::Front( void ) {
	EnterCriticalSection(	&m_critRemove ) ;
	CQElement*	pRtn = CQAppendSafe::Front() ;
	LeaveCriticalSection( &m_critRemove ) ;
	return	pRtn ;
}

BOOL
CQSafe::IsEmpty( void ) {
	EnterCriticalSection(	&m_critRemove ) ;
	BOOL	fRtn = CQAppendSafe::IsEmpty() ;
	LeaveCriticalSection(	&m_critRemove ) ;
	return	fRtn ;
}

CQUnsafe::CQUnsafe() : m_pHead( 0 ), m_pTail( 0 ) {}

CQUnsafe::~CQUnsafe( ) {
	Assert( m_pHead == 0 ) ;
	Assert( m_pTail == 0 ) ;
}

CQElement*
CQUnsafe::Remove( ) {
	CQElement *pRtn = m_pHead ;
	if( pRtn ) {
		m_pHead = pRtn->m_pNext ;
		if( m_pHead == 0 ) {
			m_pTail = 0 ;
		}
	}
	return	pRtn ;
}

CQElement*
CQUnsafe::Front( ) {
	return	m_pHead ;
}

void
CQUnsafe::Append( CQElement *p ) {

	Assert( p->m_pNext == 0 ) ;

	if( m_pTail ) {
		m_pTail->m_pNext = p ;
		m_pTail = p ;
	}	else	{
		m_pHead = m_pTail = p ;
	}
}
#endif

	
COrderedList::COrderedList() : m_pHead( 0 ), m_pTail( 0 )  { }

COrderedList::~COrderedList()	{
	m_pHead = 0 ;
	m_pTail = 0 ;
}

void
COrderedList::Insert( CQElement *p, BOOL (*pfn)(CQElement*, CQElement*) ) {

	Assert( p->m_pNext == 0 ) ;
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;

	if( !m_pHead )	{
		m_pHead = p ;
		m_pTail = p ;
	}	else	{

		CQElement**	pp = &m_pHead ;
		while( *pp && pfn( *pp, p ) ) {
			pp = & (*pp)->m_pNext ;
		}
		Assert( pp != 0 ) ;
		p->m_pNext = *pp ;
		*pp = p ;
		if( p->m_pNext == 0 )	{
			m_pTail = p ;
		}
	}

	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;
}

void
COrderedList::Append( CQElement	*p,	BOOL	(*pfn)(CQElement *, CQElement *) )	{

	Assert( p->m_pNext == 0 ) ;
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;

	if( !m_pHead )	{
		m_pHead = p ;
		m_pTail = p ;
	}	else	{
		if( pfn( m_pTail, p ) )		{
			m_pTail->m_pNext = p ;
			p->m_pNext = 0 ;
			m_pTail = p ;
		}	else	{
			Insert( p, pfn ) ;
		}
	}
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;
}

CQElement*
COrderedList::GetHead( ) {
	return	m_pHead ;
}

CQElement*
COrderedList::RemoveHead( ) {
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;
	CQElement*	p = 0 ;
	if( m_pHead ) {
		p = m_pHead ;
		m_pHead = p->m_pNext ;
		p->m_pNext = 0 ;
		if( p == m_pTail )
			m_pTail = 0 ;
	}
	Assert( (m_pHead==0 && m_pTail==0) || (m_pHead!=0 && m_pTail!=0) ) ;
	return	p ;
}

BOOL
COrderedList::IsEmpty(	)	{
	return	m_pHead == 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\persistc.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    persistc.cpp

Abstract:

    This module contains the implementation for a persistent connection class.
	A persistent connection object handles all TCP/IP stream connection
	issues and is persistent in the sense that re-connects are handled
	transparently during the lifetime of the object.

Author:

    Rajeev Rajan (RajeevR)     17-May-1996

Revision History:

--*/

//
//	K2_TODO: move this into an independent lib
//
#define _TIGRIS_H_
#include "tigris.hxx"

#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

// system includes
#include <windows.h>
#include <stdio.h>
#include <winsock.h>

// user includes
#include <dbgtrace.h>
#include "persistc.h"

//
//  Constructor, Destructor
//
CPersistentConnection::CPersistentConnection()
{
	// zero out members
	m_Socket = INVALID_SOCKET;
	ZeroMemory (&m_RemoteIpAddress, sizeof (m_RemoteIpAddress));
	m_PortNumber = 0;
    m_fInitialized = FALSE;
    m_dwRecvTimeout = BLOCKING_RECV_TIMEOUT_IN_MSECS;
}

CPersistentConnection::~CPersistentConnection()
{

}

BOOL
CPersistentConnection::Init(
		IN LPSTR lpServer,
		int PortNumber
		)
/*++

Routine Description :

	If the lpServer param is not in IP address format (A.B.C.D), do
	a gethostbyname and store the IP address.

Arguemnts :

	IN LPSTR lpServer	-	Name or IP address of server
	int PortNumber		-	Port number of server

Return Value :
	TRUE if successful - FALSE otherwise !

--*/
{
	PHOSTENT pHost;

	TraceFunctEnter("CPersistentConnection::Init");

	//
	//	Do server name resolution if needed
	//	Assume host is specified by name
	//
	_ASSERT(lpServer);
    pHost = gethostbyname(lpServer);
    if (pHost == NULL)
    {
	    //
        // See if the host is specified in "dot address" form
        //
        m_RemoteIpAddress.s_addr = inet_addr (lpServer);
        if (m_RemoteIpAddress.s_addr == -1)
        {
           FatalTrace( (LPARAM)this, "Unknown remote host: %s", lpServer);
           return FALSE;
        }
    }
    else
    {
       CopyMemory ((char *) &m_RemoteIpAddress, pHost->h_addr, pHost->h_length);
    }

	// Note the port number for future re-connects
	m_PortNumber = PortNumber;

	// connect() to server
	BOOL fRet = fConnect();

    // mark as initialized
    if(fRet) m_fInitialized = TRUE;

    return fRet;
}

BOOL
CPersistentConnection::fConnect()
/*++

Routine Description :

	Establish a connection to the server at the specified port

Arguments :


Return Value :
	TRUE if successful - FALSE otherwise !

--*/
{
	SOCKADDR_IN remoteAddr;

	TraceFunctEnter("CPersistentConnection::fConnect");

	// get a socket descriptor
	m_Socket = socket(AF_INET, SOCK_STREAM, 0);
	if(INVALID_SOCKET == m_Socket)
	{
		FatalTrace( (LPARAM)this,"Failed to get socket descriptor: Error is %d",WSAGetLastError());
		return FALSE;
	}

    //
    // Set the recv() timeout on this socket
    //
    int err = setsockopt(m_Socket, SOL_SOCKET, SO_RCVTIMEO,
    				    (char *) &m_dwRecvTimeout, sizeof(m_dwRecvTimeout));

    if (err == SOCKET_ERROR)
    {
	    FatalTrace((LPARAM) this, "setsockopt(SO_RCVTIMEO) returns %d", err);
        closesocket(m_Socket);
        return FALSE;
    }

    //
	// Connect to an agreed upon port on the host.
	//
	ZeroMemory (&remoteAddr, sizeof (remoteAddr));

	remoteAddr.sin_family = AF_INET;
	remoteAddr.sin_port = htons ((WORD)m_PortNumber);
	remoteAddr.sin_addr = m_RemoteIpAddress;

	err = connect (m_Socket, (PSOCKADDR) & remoteAddr, sizeof (remoteAddr));
	if (err == SOCKET_ERROR)
	{
        DWORD dwError = WSAGetLastError();
		FatalTrace( (LPARAM)this, "connect failed: %ld\n", dwError);

		closesocket (m_Socket);
		return FALSE;
	}

	return TRUE;
}

VOID
CPersistentConnection::Terminate(BOOL bGraceful)
/*++

Routine Description :

	Close the connection; cleanup

Arguments :

	BOOL	bGraceful	: FALSE for hard disconnect	

Return Value :
	VOID
--*/
{
    LINGER lingerStruct;

    _ASSERT(m_fInitialized);

	if ( !bGraceful )
    {
		// hard disconnect
		lingerStruct.l_onoff = 1;
        lingerStruct.l_linger = 0;
		setsockopt( m_Socket, SOL_SOCKET, SO_LINGER,
                    (char *)&lingerStruct, sizeof(lingerStruct) );
	}

    closesocket( m_Socket );
    m_fInitialized = FALSE;
}

BOOL
CPersistentConnection::IsConnected()
/*++

Routine Description :

    Check if socket is connected. Uses select() on a read set to determine this.
    NOTE: assumption is that we have no outstanding reads.

Arguemnts :


Return Value :
	TRUE if socket is connected - FALSE if not

--*/
{
    fd_set  ReadSet;
    const struct timeval timeout = {0,0};   // select() should not block
    char szBuf [10];    // arbitrary size
    int flags = 0;

    TraceFunctEnter("CPersistentConnection::IsConnected");

    _ASSERT(m_fInitialized);

    FD_ZERO(&ReadSet);
    FD_SET(m_Socket, &ReadSet);

    // check if socket has been closed
    if(select(NULL, &ReadSet, NULL, NULL, &timeout) == SOCKET_ERROR)
    {
        DWORD dwError = WSAGetLastError();
        ErrorTrace( (LPARAM)this, "select failed: Last error is %d", dwError);
        return FALSE;
    }

    // If socket is in read set, recv() is guaranteed to return immediately
    if(FD_ISSET(m_Socket, &ReadSet))
    {
    	int nRecv = recv(m_Socket, szBuf, 10, flags);
        //_ASSERT(nRecv <= 0);  data unexpected at this time - disconnect
        closesocket(m_Socket);
        return FALSE;
    }
    else
        return TRUE;
}

BOOL
CPersistentConnection::IsReadable()
/*++

Routine Description :

    Check if socket has data to read. Uses select() on a read set to determine this.
    This can be used to avoid a potentially blocking read call.

    NOTE: this is not used. recv()'s are blocking with timeout

Arguments :


Return Value :
	TRUE if socket has data to read - FALSE if not

--*/
{
    fd_set  ReadSet;
    const struct timeval timeout = {0,0};   // select() should not block
    int flags = 0;

    TraceFunctEnter("CPersistentConnection::IsReadable");

    _ASSERT(m_fInitialized);

    FD_ZERO(&ReadSet);
    FD_SET(m_Socket, &ReadSet);

    // check socket for readability
    if(select(NULL, &ReadSet, NULL, NULL, &timeout) == SOCKET_ERROR)
    {
        DWORD dwError = WSAGetLastError();
        ErrorTrace( (LPARAM)this, "select failed: Last error is %d", dwError);
        return FALSE;
    }

    // If socket is in read set, recv() is guaranteed to return immediately
    return FD_ISSET(m_Socket, &ReadSet);
}

DWORD
CPersistentConnection::fSend(
		IN LPCTSTR lpBuffer,
		int len
		)
/*++

Routine Description :

	Send a buffer of given len

Arguemnts :

	IN LPCTSTR lpBuffer		: buffer to send
	int		   len			: length of buffer

Return Value :
	Number of actual bytes sent

--*/
{
	int		cbBytesSent = 0;
	int     cbTotalBytesSent = 0;
	int		flags = 0;

    _ASSERT(lpBuffer);
    _ASSERT(m_fInitialized);

	TraceFunctEnter("CPersistentConnection::fSend");

	// send the buffer till all data has been sent
	while(cbTotalBytesSent < len)
	{
		cbBytesSent = send(	m_Socket,
							(const char*)(lpBuffer+cbTotalBytesSent),
							len - cbTotalBytesSent,
							flags);

		if(SOCKET_ERROR == cbBytesSent)
		{
			// error sending data
			ErrorTrace( (LPARAM)this, "Error sending %d bytesto %s", len, inet_ntoa(m_RemoteIpAddress));
			ErrorTrace( (LPARAM)this, "WSAGetLastError is %d", WSAGetLastError());
			break;
		}

		cbTotalBytesSent += cbBytesSent;
	}

	return cbTotalBytesSent;
}

BOOL
CPersistentConnection::fTransmitFile(
		HANDLE hFile,
		DWORD dwOffset,
		DWORD dwLength
		)
/*++

Routine Description :

	TransmitFile over this connection

Arguemnts :

	HANDLE hFile		: handle to memory-mapped file
	DWORD dwOffset		: offset within file to transmit from
	DWORD dwLength		: number of bytes to transmit

Return Value :
	TRUE if successful - FALSE otherwise !

--*/
{
	BOOL fRet = TRUE;
	OVERLAPPED Overlapped;
	DWORD dwError;

    _ASSERT(m_fInitialized);

	TraceFunctEnter("CPersistentConnection::fTransmitFile");

	Overlapped.Internal = 0;
	Overlapped.InternalHigh = 0;
	Overlapped.Offset = dwOffset;		// offset within file
    Overlapped.OffsetHigh = 0;		
    Overlapped.hEvent = NULL;			// sync operation

	// else consecutive calls to TransmitFile fails!
	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	fRet = TransmitFile(	m_Socket,		// handle to a connected socket
							hFile,			// handle to an open file
							dwLength,		// number of bytes to transmit
							0,				// let winsock decide a default
							&Overlapped,	// pointer to overlapped I/O data structure
							NULL,			// pointer to data to send before and after file data
							0				// reserved; must be zero
						);

	dwError = GetLastError();

	if(!fRet)
	{
		if(ERROR_IO_PENDING == dwError)
		{
			// wait for socket to be signalled
			// TODO: make timeout configurable!!
			DWORD dwWait = WaitForSingleObject((HANDLE)m_Socket, INFINITE);
			if(WAIT_OBJECT_0 != dwWait)
			{
                ErrorTrace( (LPARAM)this,"Wait failed after TransmitFile: dwWait is %d", dwWait);
			    ErrorTrace( (LPARAM)this, "GetLastError is %d", GetLastError());

                return FALSE;
			}
		}
		else
		{
			ErrorTrace( (LPARAM)this, "TransmitFile error sending to %s", inet_ntoa(m_RemoteIpAddress));
			ErrorTrace( (LPARAM)this, "GetLastError is %d", dwError);

			return FALSE;
		}
	}

	return TRUE;
}

BOOL
CPersistentConnection::fRecv(
		IN OUT LPSTR  lpBuffer,
		IN OUT DWORD& cbBytes
		)
/*++

Routine Description :

	Receive data from remote

Arguemnts :

	IN OUT LPSTR  lpBuffer	:	buffer is allocated by caller
								data received is returned in lpBuffer
	IN OUT DWORD& cbBytes	:	IN - size of lpBuffer in bytes
								OUT - size of data returned in lpBuffer
								(what you get may be less than what you
								asked for)

Return Value :
	TRUE if successful - FALSE otherwise !

--*/
{
	int nRecv = 0;
	int flags = 0;
    DWORD dwError;

	TraceFunctEnter("CPersistentConnection::fRecv");

	_ASSERT(lpBuffer);
    _ASSERT(m_fInitialized);

    // blocking recv() with timeout
	nRecv = recv(m_Socket, lpBuffer, (int)cbBytes, flags);
	if(nRecv <= 0)
	{
        dwError = WSAGetLastError();
		ErrorTrace( (LPARAM)this, "Error receiving %d bytes from %s", cbBytes, inet_ntoa(m_RemoteIpAddress));
		ErrorTrace( (LPARAM)this, "WSAGetLastError is %d", dwError);
		cbBytes = 0;
		return FALSE;
	}

	// set the number of bytes actually received
	cbBytes = (DWORD)nRecv;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\rebuild.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rebuild.cpp

Abstract:

    This module contains the rebuilding code for the chkhash

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

    Kangrong Yan ( KangYan )    22-Oct-1998
        Move them into rebuild object

--*/

#include "tigris.hxx"
#include <stdlib.h>
#include "chkhash.h"

#define MAX_KEY_LEN		32
#define MAX_GROUPNAME   1024
#define MAX_BUILD_THREADS 64

static char mszStarNullNull[3] = "*\0";

DWORD	__stdcall	RebuildThread( void	*lpv ) ;
DWORD	__stdcall	RebuildThreadEx( void	*lpv ) ;

void
CRebuild::StopServer()
/*++
Routine description:

    Stop the server, in case rebuild failed somewhere after the server is started, 
    we should set the server back to stopped state
    
Arguments:

    None.

Return value:

    None.
--*/
{
    TraceFunctEnter( "CRebuild::StopServer" );
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    DWORD   cSecs = 0;

    m_pInstance->m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL;
    if( mb.Open( m_pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
	    DebugTrace(0,"Stopping instance %d: Rebuild cancelled", m_pInstance->QueryInstanceId());
	    if(	!mb.SetDword( "", MD_SERVER_COMMAND, IIS_MD_UT_SERVER, MD_SERVER_COMMAND_STOP) )
	    {
    	    //
		    //	failed to set server state to stopped
		    //
		    _ASSERT( FALSE );
	    }
	    mb.Close();

        //
	    //	wait for instance to stop (timeout default is 2 min - reg config)
	    //

        cSecs = 0;
        while( m_pInstance->QueryServerState() != MD_SERVER_STATE_STOPPED ) {
		    Sleep( 1000 );
		    if( (((cSecs++)*1000) > dwStartupLatency) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) )
                return;		    
	    }
	} else {
	    _ASSERT( FALSE && "Open mb to stop server failed" );
	}

	TraceFunctLeave();
}
    
BOOL
CRebuild::StartServer()
/*++
Routine description:

    Start the server

Arguments:

    None.

Return value:

    TRUE on success, FALSE otherwise
--*/
{
    TraceFunctEnter( "CCompleteRebuild::StartServer" );
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    DWORD   cSecs = 0;

    if( mb.Open( m_pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
        DebugTrace(0,"Starting instance %d before rebuild", m_pInstance->QueryInstanceId());
        if( !mb.SetDword(   "", 
                            MD_SERVER_COMMAND, 
                            IIS_MD_UT_SERVER, 
                            MD_SERVER_COMMAND_START) ) {
            //
            //  failed to set server state to started
            //
            _ASSERT( FALSE );
            ErrorTrace( 0, "Set start command in mb failed %d", GetLastError() );
            NntpLogEventEx( NNTP_REBUILD_FAILED,
                            0,
                            NULL,
                            GetLastError(),
                            m_pInstance->QueryInstanceId() ) ;

            TraceFunctLeave();
            return FALSE;
        }
        
        mb.Close();
    } else {
        ErrorTrace( 0, "Open mb for starting server failed %d", GetLastError() );
        TraceFunctLeave();
        return FALSE;
    }

    //
    // We should wait for the server to start: we'll time out in two minutes, since
    // starting the server without having to load group.lst should be fast, given 
    // that all the driver connections are asynchronous.
    //
    while( m_pInstance->QueryServerState() != MD_SERVER_STATE_STARTED ) {
        Sleep( 1000 );
        if( (((cSecs++)*1000) > dwStartupLatency ) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) {
            ErrorTrace( 0, "Server can not be started" );   
            NntpLogEventEx( NNTP_REBUILD_FAILED,
                            0,
                            NULL,
                            GetLastError(),
                            m_pInstance->QueryInstanceId() ) ;

            SetLastError( ERROR_SERVICE_START_HANG );
            return FALSE;
	    }
	}

    //
    // Now we should wait until all the vroots get into stable state
    //
    if ( !m_pInstance->BlockUntilStable() ) {
        ErrorTrace( 0, "Block until stable failed %d", GetLastError() );
        TraceFunctLeave();
        StopServer();
        return FALSE;
    }

    //
    // If we care about all the vroots to be connected, we 'll check this
    //
    if ( !m_pInstance->m_BootOptions->SkipCorruptVRoot && 
            !m_pInstance->AllConnected() ) {
        ErrorTrace( 0, "Rebuild failed due to some vroots not connected" );
        NntpLogEventEx( NNTP_REBUILD_FAILED,
                        0,
                        NULL,
                        GetLastError(),
                        m_pInstance->QueryInstanceId() ) ;
        StopServer();
        TraceFunctLeave();
        return FALSE;
    }

    //
    // If we are cancelled, should return FALSE
    //
    if ( m_pBootOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING ||
        g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
        DebugTrace( 0, "Rebuild cancelled" );
        NntpLogEventEx( NNTP_REBUILD_FAILED,
                        0,
                        NULL,
                        GetLastError(),
                        m_pInstance->QueryInstanceId() ) ;

        SetLastError( ERROR_OPERATION_ABORTED );
        StopServer();
        TraceFunctLeave();
        return FALSE;
    }

    //
    // OK, we are sure that server is properly started as far as we are concerned
    //
    TraceFunctLeave();
    return TRUE;
}
   
BOOL
CRebuild::DeletePatternFiles(
	LPSTR			lpstrPath,
	LPSTR			lpstrPattern
	)
/*++

Routine Description : 

	This function deletes all files matching a pattern in the <nntpfile> directory.
	This should be used by nntpbld to clean up old feed queues, hdr files etc !

Arguments : 
	lpstrPath		- Path to a file in the <nntpfile> directory eg. article.hsh
	lpstrPattern	- Pattern to delete eg: *.fdq

Return Value : 
	TRUE if successfull, FALSE otherwise.

--*/
{
    char szFile [ MAX_PATH ];
	char szPath [ MAX_PATH ];
	WIN32_FIND_DATA FileStats;
	HANDLE hFind;
	BOOL fRet = TRUE;
	szFile[0] = '\0' ;

	if( lpstrPath == 0 || lpstrPath[0] == '\0'  )
		return FALSE;

	//
	//	Build the pattern search path
	//
	lstrcpyn( szFile, lpstrPath, sizeof(szFile) );

	// strip the path of trailing filename
	char* pch = szFile+lstrlen(lpstrPath)-1;
	while( pch >= szFile && (*pch-- != '\\') );	// skip till we see a \
	if( pch == szFile ) return FALSE;
	*(pch+2) = '\0';		// null-terminate the path

	// tag on the pattern wildcard and save the path
	lstrcpyn( szPath, szFile, sizeof(szPath) );
	if (strlen(szFile) + strlen(lpstrPattern) + 1 > MAX_PATH) {
		return FALSE;
	}
		
	lstrcat( szFile, lpstrPattern );

	//
	//	Do a FindFirst/FindNext on this wildcard and delete any files found !
	//
	if( szFile[0] != '\0' ) 
    {
		hFind = FindFirstFile( szFile, &FileStats );

        if ( INVALID_HANDLE_VALUE == hFind )
		{
			// TODO: Check GetLastError()
			fRet = TRUE;
		}
		else
		{
    		do
			{
				// build the full filename
				_snprintf( szFile, sizeof(szFile),  "%s%s", szPath, FileStats.cFileName );
				szFile[sizeof(szFile)-1] = '\0';
				if(!DeleteFile( szFile ))
				{
					m_pBootOptions->ReportPrint("Error deleting file %s: Error is %d\n", FileStats.cFileName, GetLastError());
					fRet = FALSE;
				}
				else
				{
					m_pBootOptions->ReportPrint("Deleted file %s \n", szFile);
				}
			
			} while ( FindNextFile( hFind, &FileStats ) );

			_ASSERT(GetLastError() == ERROR_NO_MORE_FILES);

			FindClose( hFind );
		}
	}

	return fRet;
}

VOID
CRebuild::DeleteSpecialFiles()
/*++
Routine description:

    Delete the message files in special directory ( slave ).
    They should have no nov-entries / map entries in hash 
    tables to be cleaned up

Arguments:

    None.

Return value:

    None.  Failure in deleting slave files are not fatal error for rebuild.
--*/
{
    TraceFunctEnter( "CRebuild::DeleteSpecialFiles" );

    CNNTPVRootTable  *pVRTable  = NULL;
    NNTPVROOTPTR    pVRoot      = NULL;
    HRESULT         hr          = S_OK;
    LPCWSTR         pwszVRConfig= NULL;
    DWORD           dwLen       = 0;
    CHAR            szVRPath[MAX_PATH+1+sizeof("_slavegroup\\")];

    //
    // Get the vroot table and search for the slave vroot
    //

    _ASSERT( m_pInstance );
    pVRTable = m_pInstance->GetVRTable();
    
    hr = pVRTable->FindVRoot( "_slavegroup._slavegroup", &pVRoot );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "VRTable has no slave root: %x", hr );
        return;
    };

    //
    // Get MD config path from the vroot
    //

    lstrcpyn( szVRPath, pVRoot->GetDirectory(), MAX_PATH);

    //
    // Just to make DeletePatternFiles happy, if szVRPath is not "\\" 
    // terminated, we'll add it
    //

    dwLen = strlen( szVRPath );
    _ASSERT( dwLen < MAX_PATH );
    if ( dwLen == 0 || *(szVRPath + dwLen - 1) != '\\' ) {
        *(szVRPath + dwLen ) = '\\';
        *(szVRPath + dwLen + 1 ) = '\0';
    }

    strcat( szVRPath, "_slavegroup\\" );
    //
    // Now delete all files under the vrpath
    //
        
    DeletePatternFiles( szVRPath, "*.nws" );

    TraceFunctLeave();
}

BOOL
CCompleteRebuild::DeleteServerFiles()
/*++
Routine description:

    Delete all the server files.

Arguments:

    None.

Reurn value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CCompleteRebuild::DeleteServerFiles" );
	CHAR szArticleTableFile [MAX_PATH+1];
	CHAR szFile [MAX_PATH+1];
	CHAR szVarFile[MAX_PATH+1];
	LPSTR   pch;
	BOOL fRet = TRUE ;
	MB   mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	//
	//	Open the metabase to read file paths
	//
	if( !mb.Open( m_pInstance->QueryMDPath() ) ) {
		m_pBootOptions->ReportPrint(    "Failed to open mb path %s\n", 
			                            m_pInstance->QueryMDPath());
        TraceFunctLeave();
		return FALSE ;
	}

	DWORD dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_ARTICLE_TABLE_FILE,
						IIS_MD_UT_SERVER,
						szArticleTableFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get article table file from mb: %d \n", 
			                        GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

	//
	//	delete all *.hdr files in the <database> folder
	//

	if (!DeletePatternFiles( szArticleTableFile, "*.hdr" ) )
	{
		m_pBootOptions->ReportPrint("Failed to delete hash table hdr files.\n");
		m_pBootOptions->ReportPrint("Please delete all *.hdr files before running nntpbld\n");
		fRet = FALSE ;
		goto Exit;
	}

	//
	//	delete the article table file
	//

    if (!DeleteFile(szArticleTableFile)) {
        if ( GetLastError()!=ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete %s. Error %d\n",
                szArticleTableFile, GetLastError());
			fRet = FALSE ;
			goto Exit;
        }
    }

	//
	//	Get and delete the xover table file
	//

	dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_XOVER_TABLE_FILE,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get xover table file from mb: %d \n", 
			GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

    if (!DeleteFile(szFile)) {
        if ( GetLastError()!=ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete %s. Error %d\n",
                szFile, GetLastError());
			fRet = FALSE ;
			goto Exit;
        }
    }

	//
	//	Get and delete the history table file
	//

	dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_HISTORY_TABLE_FILE,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get history table file from mb: %d \n", 
			GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

    if ( !m_pBootOptions->NoHistoryDelete && !DeleteFile(szFile)) {
        if ( GetLastError()!=ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete %s. Error %d\n",
                szFile, GetLastError());
			fRet = FALSE ;
			goto Exit;
        }
    }

	//
	//	Get and delete the group.lst file
	//

	dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_GROUP_LIST_FILE,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get group.lst file from mb: %d \n", 
			GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

	if( !DeleteFile( szFile ) ) {
		if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete group file. Error %d\n", 
				GetLastError());
			fRet = FALSE ;
			goto Exit;
		}
	}

	//
	// Also delete group.lst.ord, if any
	//
	if (strlen(szFile)+sizeof(".ord") > sizeof(szFile))
	{
		m_pBootOptions->ReportPrint("can not delete group.lst.ord. file name too long.");
	}
	else
	{
		strcat( szFile, ".ord" );
		_ASSERT( strlen( szFile ) <= MAX_PATH );
		if( !DeleteFile( szFile ) ) {
		    if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
		        m_pBootOptions->ReportPrint("can not delete group.lst.ord. Error %d\n", 
		            GetLastError());
	       	 fRet = FALSE;
		        goto Exit;
		    }
		}
	}
	//
	// Delete groupvar.lst
	//
	dwSize = MAX_PATH ;
	*szVarFile = 0;
	if( !mb.GetString(	"",
						MD_GROUPVAR_LIST_FILE,
						IIS_MD_UT_SERVER,
						szVarFile,
						&dwSize  ) || *szVarFile == 0 )
	{
		//
		// We know that it's at the same spot as group.lst
		//
		strcpy( szVarFile, szFile );
		pch = szVarFile + strlen( szFile ) - 8;    // get to "group"
		strcpy( pch, "var.lst" );               // now we get "groupvar.lst
		_ASSERT( strlen( szVarFile ) < MAX_PATH + 1 );
	}

	if( !DeleteFile( szVarFile ) ) {
		if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete group file. Error %d\n", 
				GetLastError());
			fRet = FALSE ;
			goto Exit;
		}
	}

	//
	//	delete old feedq files lying around
	//	These files contain <groupid, articleid> pairs that are made obsolete by nntpbld !
	//

	if (!DeletePatternFiles( szArticleTableFile, "*.fdq" ) )
	{
		m_pBootOptions->ReportPrint("Failed to delete Feed Queue files.\n");
		m_pBootOptions->ReportPrint("Please delete all *.fdq files before running nntpbld\n");
		fRet = FALSE ;
		goto Exit;
	}

Exit:

	_VERIFY( mb.Close() );
	return fRet ;
}

BOOL
CCompleteRebuild::PrepareToStartServer()
/*++
Routine description:

    All the work done here should make the server bootable and readable.  
    Though the server will keep in non-posting mode

Arguments:

    None.

Return value:

    TRUE, if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CCompleteRebuild::PrepareToStartServer" );

    //
    // For complete rebuild ( clean rebuild ), we need to delete all the server
    // files, after which we are sure that the server will boot.  We should
    // still ask for the opinion of DoClean though
    //
    if ( m_pBootOptions->DoClean ) {

        if ( !DeleteServerFiles() ) {
            ErrorTrace( 0, "Delete server files failed with %d", GetLastError() );
            NntpLogEventEx( NNTP_REBUILD_FAILED,
                            0,
                            NULL,
                            GetLastError(),
                            m_pInstance->QueryInstanceId() ) ;

            TraceFunctLeave();
            return FALSE;
        }
    }

    //
    // OK, tell others that we are ready
    //
    m_pBootOptions->IsReady = TRUE;

    TraceFunctLeave();
    return TRUE;
}

DWORD WINAPI
CCompleteRebuild::RebuildThread( void	*lpv ) 
{

    TraceQuietEnter("CCompleteRebuild::RebuildThread");

    BOOL fRet = TRUE;

	PNNTP_SERVER_INSTANCE pInstance = (PNNTP_SERVER_INSTANCE)lpv;
	CBootOptions*	pOptions = pInstance->m_BootOptions;
	CGroupIterator* pIterator = pOptions->m_pIterator;

	_ASSERT( pInstance );
	_ASSERT( pOptions  );
	_ASSERT( pIterator );

	if( pOptions->m_fInitFailed ) {
		// initialization error - bail !
		return 0;
	}

	CNewsTree* ptree = pInstance->GetTree();
	CGRPPTR	pGroup;

	//
	//	All the worker threads share a global iterator; all threads are done
	//	when together they have iterated over the newstree. 
	//	NOTE: the lock ensures that no two threads will process the same group !
	//

	while( !ptree->m_bStoppingTree )	{

	    //
	    // If I am cancelled, should not continue
	    //
	    if ( pOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING ||
	         g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING)  {
	        SetLastError( ERROR_OPERATION_ABORTED );
	        pOptions->m_fInitFailed = TRUE;     // Should tell everybody else to stop
	        fRet = FALSE;
	        break;
	    }

		EnterCriticalSection( &pOptions->m_csIterLock );

		if( pIterator->IsEnd() ) {
			LeaveCriticalSection( &pOptions->m_csIterLock );
			break;
		} else {
			pGroup = pIterator->Current() ;	
			pIterator->Next() ;
		}

		LeaveCriticalSection( &pOptions->m_csIterLock );

        //
		// Delete any .XIX files that might be present for this group.
		//
		char szPath[MAX_PATH*2];
		char szFile[MAX_PATH];
		BOOL fFlatDir;
		if (pGroup->ComputeXoverCacheDir(szPath, fFlatDir)) {

		    // Make sure path has \ at the end, then append *.xix
		    DWORD dwLen = strlen( szPath );
            _ASSERT( dwLen < MAX_PATH );
            if ( dwLen == 0 || *(szPath + dwLen - 1) != '\\' ) {
                *(szPath + dwLen ) = '\\';
                *(szPath + dwLen + 1 ) = '\0';
            }

    	    WIN32_FIND_DATA FileStats;
	        HANDLE hFind;

            _snprintf(szFile, sizeof(szFile), "%s%s", szPath, "*.xix");
            szFile[sizeof(szFile)-1] = '\0';
	     hFind = FindFirstFile( szFile, &FileStats );

            if ( INVALID_HANDLE_VALUE == hFind ) {
                if (GetLastError() != ERROR_FILE_NOT_FOUND) {
		            ErrorTrace(0, "FindFirstFile failed on %s, error %d",
		                szFile, GetLastError());
		        }
		    } else {
    		    do {
				    // build the full filename
    				_snprintf( szFile, sizeof(szFile), "%s%s", szPath, FileStats.cFileName );
				szFile[sizeof(szFile)-1] = '\0';
	    			if(!DeleteFile( szFile ) && GetLastError() != ERROR_FILE_NOT_FOUND) {
		    			pOptions->ReportPrint("Error deleting file %s: Error is %d\n", szFile, GetLastError());
				    }
	    		} while ( FindNextFile( hFind, &FileStats ) );

		    	_ASSERT(GetLastError() == ERROR_NO_MORE_FILES);

			    FindClose( hFind );
		    }
		}

		// scan articles on disk and process them
		fRet = pGroup->RebuildGroup( NULL ) ;

		// bail out - CNewsgroup::ProcessGroup fails only on catastrophic errors
		// if this error is truly catastrophic, other threads will bail too !
		if(!fRet) {
		    ErrorTrace(0, "RebuildGroup failed, %x", GetLastError());
		    pOptions->m_fInitFailed = TRUE;
		    pOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING;
		    break;
		}
	}

	return	fRet ;
} // RebuildThread

BOOL
CCompleteRebuild::RebuildGroupObjects()
/*++
Routine description:

    Create a pool of rebuild threads, each thread enumerates
    on the newstree and does RebuildGroup into driver.  This
    function is equivalent to "ProcessGroupFile" in MCIS2.0
    
Arguments:

    None.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CCompleteRebuild::RebuildGroupObjects" );

	HANDLE rgBuildThreads [MAX_BUILD_THREADS];
	DWORD dwThreadId, cThreads;
	BOOL  fRet = TRUE;
	CNewsTree* ptree = NULL;

	CBootOptions* pOptions = m_pInstance->m_BootOptions ;
	ptree = m_pInstance->GetTree() ;
	_ASSERT( pOptions );

	pOptions->m_fInitFailed = FALSE;
	pOptions->m_pIterator = NULL;

	//
	//	Get the shared group iterator - this is used by all rebuild threads
	//
	if( !(pOptions->m_pIterator = ptree->GetIterator( mszStarNullNull, TRUE )) ) {
	    ErrorTrace(0, "GetIterator failed, %d", GetLastError());
		return FALSE;
	}

	//
	//	Lock to synchronize access to global iterator
	//
	InitializeCriticalSection( &pOptions->m_csIterLock );

	// validate num threads
	if( !pOptions->cNumThreads ||  pOptions->cNumThreads > MAX_BUILD_THREADS ) {
		SYSTEM_INFO si;
		GetSystemInfo( &si );
		pOptions->cNumThreads = si.dwNumberOfProcessors * 4;	// 4 threads per proc
	}

	for( cThreads = 0; cThreads < pOptions->cNumThreads; cThreads++ ) {
		rgBuildThreads [cThreads] = NULL;
	}

	//
	//	Multi-threaded nntpbld - spawn worker threads to scan the newstree
	//	Each worker thread picks a group and rebuilds it
	//
	for( cThreads = 0; cThreads < pOptions->cNumThreads; cThreads++ ) 
	{
		rgBuildThreads [cThreads] = CreateThread(
										NULL,				// pointer to thread security attributes
										0,					// initial thread stack size, in bytes
										RebuildThread,		// pointer to thread function
										(LPVOID)m_pInstance,// argument for new thread
										CREATE_SUSPENDED,	// creation flags
										&dwThreadId			// pointer to returned thread identifier
										) ;

		if( rgBuildThreads [cThreads] == NULL ) {
		    ErrorTrace(0, "CreateThread failed, %d", GetLastError());
			pOptions->ReportPrint("Failed to create rebuild thread %d: error is %d", cThreads+1, GetLastError() );
			pOptions->m_fInitFailed = TRUE;
			break;
		}
	}

	//
	//	Resume all threads and wait for threads to terminate
	//
	for( DWORD i=0; i<cThreads; i++ ) {
		_ASSERT( rgBuildThreads[i] );
		DWORD dwRet = ResumeThread( rgBuildThreads[i] );
		_ASSERT( 0xFFFFFFFF != dwRet );
	}

	//
	//	Wait for all rebuild threads to finish
	//
	DWORD dwWait = WaitForMultipleObjects( cThreads, rgBuildThreads, TRUE, INFINITE );

	if( WAIT_FAILED == dwWait ) {
	    ErrorTrace(0, "WaitForMultipleObjects failed: error is %d", GetLastError());
		pOptions->ReportPrint("WaitForMultipleObjects failed: error is %d", GetLastError());
		pOptions->m_fInitFailed = TRUE;
	}

	//
	//	Cleanup
	//
	for( i=0; i<cThreads; i++ ) {
		_VERIFY( CloseHandle( rgBuildThreads[i] ) );
		rgBuildThreads [i] = NULL;
	}
	XDELETE pOptions->m_pIterator;
	pOptions->m_pIterator = NULL;
	DeleteCriticalSection( &pOptions->m_csIterLock );

	//
    // None of the groups have been saved to group.lst or groupvar.lst yet
    // We'll call Savetree to save them
    //
    if ( pOptions->m_fInitFailed == FALSE ) {
        if ( !ptree->SaveTree( FALSE ) ) {
            ErrorTrace( 0, "Save tree failed during rebuild %d", GetLastError() );
            TraceFunctLeave();
            return FALSE;
        }
    }

	return !pOptions->m_fInitFailed;
}

BOOL
CStandardRebuild::PrepareToStartServer()
/*++
Routine description:

    All the work done here should make the server bootable and
    readable.  Though the server will keep in non-posting mode.

Arguments:

    None.

Return value:

    TRUE, if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CStandardRebuild::PrepareToStartServer" );

    CHAR szGroupListFile [MAX_PATH+1];
	CHAR szVarFile[MAX_PATH+1];
	BOOL fRet = TRUE ;
	MB   mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
	LPSTR   pch;

	//
	//	Open the metabase to read file paths
	//
	if( !mb.Open( m_pInstance->QueryMDPath() ) ) {
		m_pBootOptions->ReportPrint(    "Failed to open mb path %s\n", 
			                            m_pInstance->QueryMDPath());
        TraceFunctLeave();
		return FALSE ;
	}

	DWORD dwSize = MAX_PATH ;
	if( !mb.GetString(	"",
						MD_GROUP_LIST_FILE,
						IIS_MD_UT_SERVER,
						szGroupListFile,
						&dwSize  ) )
	{
		m_pBootOptions->ReportPrint("Failed to get article table file from mb: %d \n", 
			                        GetLastError());
		fRet = FALSE ;
		goto Exit;
	}

	//
	//	delete group.lst and group.lst.ord
	//
    if( !DeleteFile( szGroupListFile ) ) {
		if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete group file. Error %d\n", 
				GetLastError());
			fRet = FALSE ;
			goto Exit;
		}
	}

	if (strlen(szGroupListFile)+sizeof(".ord") > sizeof(szGroupListFile))
	{
		m_pBootOptions->ReportPrint("can not delete group.lst.ord. file name too long.");
	}
	else
	{
		strcat( szGroupListFile, ".ord" );
		_ASSERT( strlen( szGroupListFile ) <= MAX_PATH );
		if( !DeleteFile( szGroupListFile ) ) {
		    if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
	       	 m_pBootOptions->ReportPrint("can not delete group.lst.ord. Error %d\n", 
		            GetLastError());
		        fRet = FALSE;
	       	 goto Exit;
		    }
		}
	}
	//
	// Delete groupvar.lst
	//
	dwSize = MAX_PATH ;
	*szVarFile = 0;
	if( !mb.GetString(	"",
						MD_GROUPVAR_LIST_FILE,
						IIS_MD_UT_SERVER,
						szVarFile,
						&dwSize  ) || *szVarFile == 0 )
	{
		//
		// We know that it's at the same spot as group.lst
		//
		strcpy( szVarFile, szGroupListFile );
		pch = szVarFile + strlen( szGroupListFile ) - 8;    // get to "group"
		strcpy( pch, "var.lst" );               // now we get "groupvar.lst
		_ASSERT( strlen( szVarFile ) < MAX_PATH + 1 );

	}

	if( !DeleteFile( szVarFile ) ) {
		if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            m_pBootOptions->ReportPrint("cannot delete group file. Error %d\n", 
				GetLastError());
			fRet = FALSE ;
			goto Exit;
		}
	}

Exit:
	_VERIFY( mb.Close() );

	//
	// OK, tell others that we are ready
	//
	m_pBootOptions->IsReady = TRUE;
	
	return fRet;
}

BOOL
CStandardRebuild::RebuildGroupObjects()
/*++
Routine description:

    Rebuild group objects, adjust watermarks/article counts based on xover
    table.  We assume that each group is empty, since rebuild's 
    DecorateNewsTree should not have set article count / watermarks

Arguments:

    None.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CStandardRebuild::RebuildGroupObjects" );

    //
    // Get the xover table pointer, we are sure that the server ( hence hash
    // table ) was properly started up, since we waited for the server to
    // start somewhere before
    //
    CXoverMap* pXoverTable = m_pInstance->XoverTable();
    _ASSERT( pXoverTable );

    //
    // Get the newstree, which is what we'll work against during the rest
    // of time
    //
    CNewsTree* pTree = m_pInstance->GetTree();
    _ASSERT( pTree );

    //
    // Now we'll enumerate the xover table
    //
    CXoverMapIterator*  pIterator = NULL;
    BOOL                f = FALSE;
    GROUPID             groupid;
    ARTICLEID           articleid;
    BOOL                fIsPrimary;
    CStoreId            storeid;
    DWORD               cGroups;
    CGRPPTR	            pGroup = NULL;
    DWORD               cMessages;

    //
    // We should not have to worry about the buffer size passed in because
    // the only thing we need is groupid/articleid, which are of fixed size
    //
	f = pXoverTable->GetFirstNovEntry(  pIterator,
	                                    groupid,
	                                    articleid,
	                                    fIsPrimary,
	                                    0,
	                                    NULL,
	                                    storeid,
	                                    0,
	                                    NULL,
	                                    cGroups );
    while( f ) {

        //
        // If I am told to cancel, I should not continue
        //
        if ( m_pBootOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING ||
             g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) {
            DebugTrace( 0, "Rebuild aborted" );
            XDELETE pIterator;
            SetLastError( ERROR_OPERATION_ABORTED );
            m_pInstance->SetRebuildLastError( ERROR_OPERATION_ABORTED );
            return FALSE;
        }

        //
        // Find the group from tree
        //
        pGroup = pTree->GetGroupById( groupid );
        if ( !pGroup ) {

            //
            // xover table is insonsistent with newstree, which is built from
            // store.  We'll have to fail the standard rebuild
            //
            ErrorTrace( 0, "xover table is inconsistent with newstree" );
            XDELETE pIterator;
            SetLastError( ERROR_FILE_CORRUPT );
            m_pInstance->SetRebuildLastError( ERROR_FILE_CORRUPT );
            return FALSE;
        }

        //
        // Adjust high watermark
        //
        if ( articleid > pGroup->GetHighWatermark() )
            pGroup->SetHighWatermark( articleid );

        //
        // Adjust low watermark: we should be careful with the first article
        //
        if ( pGroup->GetMessageCount() == 0 ) {

            //
            // We set us to be low watermark, others will update it if they
            // are unhappy with this
            //
            pGroup->SetLowWatermark( articleid );
        } else {
            if ( articleid < pGroup->GetLowWatermark() ) 
                pGroup->SetLowWatermark( articleid );
        }

        //
        // Adjust article count
        //
        cMessages = pGroup->GetMessageCount();
        pGroup->SetMessageCount( ++cMessages );
        _ASSERT(    pGroup->GetMessageCount() <= 
                    pGroup->GetHighWatermark() - pGroup->GetLowWatermark() + 1 );

        //
        // OK, find the next entry from xover table
        //
        f = pXoverTable->GetNextNovEntry(   pIterator,
                                            groupid,
                                            articleid,
                                            fIsPrimary,
                                            0,
                                            NULL,
                                            storeid,
                                            0,
                                            NULL,
                                            cGroups );
    }

    //
    // We are done with the iterator
    //
    XDELETE pIterator;

    //
    // None of the groups have been saved to group.lst or groupvar.lst yet
    // We'll call Savetree to save them
    //
    if ( !pTree->SaveTree( FALSE ) ) {
        ErrorTrace( 0, "Save tree failed during rebuild %d", GetLastError() );
        SetLastError( GetLastError() );
        m_pInstance->SetRebuildLastError( GetLastError() );
        TraceFunctLeave();
        return FALSE;
    }

    //
    // Ok, we are completely done
    //
    TraceFunctLeave();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\queue.inl ===
//
// Queue.inl
//
//	This file contains Inline functions for the classes defined in queue.h
//

#ifndef	Assert
#define	Assert	_ASSERT
#endif

#ifndef _NO_TEMPLATES_

template< class	Element > 
TOrderedList< Element >::TOrderedList( ) {}

template< class	Element >
BOOL	TOrderedList< Element >::Compare( CQElement *pLHS, CQElement *pRHS ) {
	return	(*((Element*)pLHS)) < (*((Element*)pRHS)) ;
}

template< class Element > 
void	TOrderedList< Element >::Insert( Element *pElement ) {
	COrderedList::Insert( pElement,  TOrderedList< Element >::Compare ) ;
}

template< class Element > 
Element*	TOrderedList< Element >::GetHead( ) {
	return	(Element*)COrderedList::GetHead() ;
}

template< class Element > 
Element*	TOrderedList< Element >::RemoveHead( ) {
	return	(Element*)COrderedList::RemoveHead() ;
}

template< class	Element >
BOOL	TOrderedList< Element >::IsEmpty()	{
	return	COrderedList::IsEmpty() ;
}

template< class	Element >
void	TOrderedList< Element >::Append(	Element*	pElement	)	{
	COrderedList::Append( pElement, TOrderedList< Element >::Compare ) ;
}


#else

#define	DECLARE_ORDEREDLISTFUNC( Element )	\
BOOL	TOrderedList ## Element ::Compare( CQElement *pLHS, CQElement *pRHS ) {	\
	return	(*((Element*)pLHS)) < (*((Element*)pRHS)) ;	\
}	\
void	TOrderedList ## Element ::Insert( Element *pElement ) {	\
	COrderedList::Insert( pElement,  TOrderedList ## Element ::Compare ) ;	\
}	\
Element*	TOrderedList ## Element ::GetHead( ) {	\
	return	(Element*)COrderedList::GetHead() ;	\
}	\
Element*	TOrderedList ## Element ::RemoveHead( ) {	\
	return	(Element*)COrderedList::RemoveHead() ;	\
}	\
BOOL	TOrderedList ## Element ::IsEmpty()	{	\
	return	COrderedList::IsEmpty() ;	\
}	\
void	TOrderedList ## Element ::Append(	Element*	pElement	)	{	\
	COrderedList::Append( pElement, TOrderedList ## Element ::Compare ) ;	\
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\persistc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    persistc.h

Abstract:

    This module contains definitions for a persistent connection class.
	A persistent connection object handles all TCP/IP stream connection
	issues and is persistent in the sense that re-connects are handled
	transparently during the lifetime of the object.

Author:

    Rajeev Rajan (RajeevR)     17-May-1996

Revision History:

--*/

#ifndef _PERSISTC_H_
#define _PERSISTC_H_

#define MINUTES_TO_SECS                60
#define SECS_TO_MSECS                  1000
#define BLOCKING_RECV_TIMEOUT_IN_MSECS 1 * MINUTES_TO_SECS * SECS_TO_MSECS

class	CPersistentConnection	{
private : 

	//
	//	socket used by this object
	//
	SOCKET	m_Socket;

	//
	//	remote IP address
	//
	IN_ADDR m_RemoteIpAddress;

	//
	//	server port number
	//
	int		m_PortNumber;

    //
    //  initialized or not
    //
    BOOL    m_fInitialized;

    //
    //  recv timeout
    //
    DWORD   m_dwRecvTimeout;

protected:
	//
	//	connect() to server
	//
	BOOL	fConnect();

    //
    //  check to see if socket is connected to server
    //
    BOOL    IsConnected();

    //
    //  check to see if socket is readable
    //
    BOOL    IsReadable();

public : 
	CPersistentConnection();
	virtual ~CPersistentConnection(VOID);

	//
	//	Does a gethostbyname resolution and 
	//  establishes a connection
	//
	BOOL Init(IN LPSTR lpServer, int PortNumber);

	//
	//	Close the connection; cleanup
	//
	VOID Terminate(BOOL bGraceful);

    //
    //  check to see if object is initialized
    //
    BOOL    IsInitialized(){return m_fInitialized;}

	//
	//	Send a buffer of given len
	//
	DWORD fSend(IN LPCTSTR lpBuffer, int len);

	//
	//	TransmitFile
	//
	BOOL fTransmitFile(IN HANDLE hFile, DWORD dwOffset, DWORD dwLength);

	//
	//	Receive data from remote
	//
	BOOL fRecv(IN OUT LPSTR lpBuffer, DWORD& cbBytes);

	//
    // override new and delete to use HeapAlloc/Free
	//
    void *operator new( size_t cSize )
	{ return HeapAlloc( GetProcessHeap(), 0, cSize ); }
    void operator delete (void *pInstance)
	{ HeapFree( GetProcessHeap(), 0, pInstance ); }
};

#endif // _PERSISTC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\rebuild.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        rebuild.h
//
//  Contents:    definitions of CRebuildThread class
//
//  Functions:  
//
//  History:     03/15/97     Rajeev Rajan (rajeevr)  Created
//               10/21/98     Kangrong Yan ( kangyan ) Added rebuild objects
//
//-----------------------------------------------------------------------------


//
//	CRebuildThread derives from CWorkerThread for work-thread semantics
//	The base class handles the details of creating the thread and queueing
//	work requests to the derived class
//
//	CRebuildThread just needs to implement a virtual member - WorkCompletion()
//	that is called when a virtual server instance needs to be rebuilt. Rebuild
//	requests are queued in on RPCs.
//
//	Note that multiple rebuild threads may be active at any time. A particular
//	rebuild thread's WorkCompletion() routine gets a virtual server instance
//	and a group iterator object. The group iterator object is shared between
//	all the rebuild threads, so access to it needs to be synchronized. Each
//	rebuild thread will pick a group using the group iterator and rebuild the
//	group. No two threads will rebuild the same group. The virtual server
//	instance is rebuilt when any one thread finishes with the iterator. If 
//	there are more instances to be rebuilt, these will have been queued by the
//	base class and will be picked up. else, the rebuild threads will block
//	on GetQueuedCompletionStatus().
//
//	NOTE: The server will not normally create any rebuild threads - the first
//	time it gets an RPC to rebuild an instance it will create N CRebuildThread
//	objects - these will hang off the NNTP_IIS_SERVICE object. The number of
//	such threads will be configurable and good values should be selected based
//	on performance tests. Also, with virtual servers, rebuild activity on one
//	instance can go on in parallel with normal NNTP activity on other instances
//	that are functional.
//

#ifndef _REBUILD_H_
#define _REBUILD_H_

//
//	clients of CRebuildThread will queue LPREBUILD_CONTEXTs
//
typedef struct _REBUILD_CONTEXT
{
	NNTP_SERVER_INSTANCE  pInstance;	// the virtual server instance being rebuilt
	CGroupIterator*		  pIterator;	// group iterator shared by rebuild thread
	CRITICAL_SECTION	  csGrpIterator;// crit sect for sync access to iterator
} REBUILD_CONTEXT, *LPREBUILD_CONTEXT;

class CRebuildThread : public CWorkerThread
{
public:
	CRebuildThread()  {}
	~CRebuildThread() {}

protected:
	virtual VOID WorkCompletion( PVOID pvRebuildContext );
};

//
// KangYan:
// The change defines rebuild classes in an attempt to have two types of rebuild
// share common code.  CRebuild is the base class that defines common data
// and operations; CStandardRebuild is the actual implementation for standard
// rebuild; CCompleteRebuild is the actual implementation for complete clean 
// rebuild.  Each virtual instance has pointer to a rebuild object, whose type
// is determined at run time based on rpc requirement.  One virtual instance can not
// have two rebuilds in progress at the same time.  When rebuild is completed,
// the rebuild object should be destroyed.
//
class CRebuild {

public:

    //
    // Constructors, destructors
    //
    CRebuild(   PNNTP_SERVER_INSTANCE pInstance,
                CBootOptions *pBootOptions ) :
        m_pInstance( pInstance ),
        m_pBootOptions( pBootOptions )
    {}

    //
    // Start the server
    //
    BOOL StartServer();

    //
    // Stop the server
    //
    void StopServer();

    //
    // Preparation for building a tree
    //
    virtual BOOL PrepareToStartServer() = 0;

    //
    // Rebuild group objects and hash tables if necessary
    //
    virtual BOOL RebuildGroupObjects() = 0;

    //
    // Delete slave files
    //
    VOID DeleteSpecialFiles();


protected:

    ///////////////////////////////////////////////////////////////
    // Member variables
    ///////////////////////////////////////////////////////////////

    //
    // Back pointer to the virtual server
    //
    PNNTP_SERVER_INSTANCE   m_pInstance;

    //
    // Boot options
    //
    CBootOptions*    m_pBootOptions;

    ////////////////////////////////////////////////////////////////
    // Methods
    ////////////////////////////////////////////////////////////////
    //
    // Never allow to be constructed in this way by others
    //
    CRebuild() {}
    
    //
    // Delete server files with certain pattern
    //
    BOOL DeletePatternFiles(    LPSTR			lpstrPath,
                        	    LPSTR			lpstrPattern );

private:
    
};

class CStandardRebuild : public CRebuild {

public:

    ////////////////////////////////////////////////////////////////
    // Member variables
    ////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////
    // Methods
    ////////////////////////////////////////////////////////////////
    
    //
    // Constructors, destructors
    //
    CStandardRebuild(   PNNTP_SERVER_INSTANCE pInstance,
                        CBootOptions *pBootOptions ) :
        CRebuild( pInstance, pBootOptions )
    {}
    
    virtual BOOL PrepareToStartServer();

    virtual BOOL RebuildGroupObjects();

private:

    //
    // Never allow to be constructed in this way
    //
    CStandardRebuild() {}
};

class CCompleteRebuild : public CRebuild {

public:

    /////////////////////////////////////////////////////////////////
    // Member variables
    /////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    // Methods
    /////////////////////////////////////////////////////////////////

    //
    // Constructors, destructors
    //
    CCompleteRebuild(   PNNTP_SERVER_INSTANCE pInstance,
                        CBootOptions *pBootOptions ) :
        CRebuild( pInstance, pBootOptions )
    {}

    virtual BOOL PrepareToStartServer();

    virtual BOOL RebuildGroupObjects();

    static DWORD WINAPI RebuildThread( void	*lpv );

private:

    /////////////////////////////////////////////////////////////////
    // Methods
    /////////////////////////////////////////////////////////////////

    //
    // Never allow to be constructed in this way
    //
    CCompleteRebuild() {}

    //
    // Delete all the server files
    //
    BOOL DeleteServerFiles();
};

#endif // _REBUILD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\rpcex.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        rpcex.cxx

   Abstract:

        This module defines K2 rpc support.
		These functions are NYI for now. Need to migrate service RPCs
		to this.

   Author:

        Johnson Apacible    (JohnsonA)      June-19-1996

--*/


#include "tigris.hxx"
#include <timer.h>
#include <time.h>

#include "iiscnfg.h"
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::StartInstance
//
//  Synopsis:   Called to start an instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::StartInstance()
{
	DWORD err = NO_ERROR ;
	BOOL  fFatal = FALSE ;
	CHAR	szDebugStr [MAX_PATH+1];
	MB mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	TraceFunctEnter("NNTP_SERVER_INSTANCE::StartInstance");
	EnterCriticalSection( &m_critRebuildRpc ) ;

	if( m_BootOptions && !m_BootOptions->IsReady ) {
		//
		//	non-null m_BootOptions indicates a pending rebuild
		//	we will disable Start() till the nntpbld thread sets
		//	IsReady to TRUE. This is done after it
		//	has cleared the hash tables, so it is safe to start.
		//
		err = ERROR_INVALID_SERVICE_CONTROL ;
		ErrorTrace((LPARAM)this,"Attempting to start instance %d during rebuild",QueryInstanceId());
		LeaveCriticalSection( &m_critRebuildRpc ) ;
		return err ;
	}

	if( !Start( fFatal ) ) {
		ErrorTrace((LPARAM)this,"Failed to start instance %d Error is %s", QueryInstanceId(), fFatal ? "fatal" : "non-fatal" );
		err = ERROR_SERVICE_DISABLED ;
		goto Exit ;
	}

	//
	//	If a rebuild is pending, start the instance in no-posting mode
	//	when the rebuild is done, we will auto-revert to posting mode
	//

	if( m_BootOptions ) {
		SetPostingModes( mb, FALSE, FALSE, FALSE );
	}

	//
	//	Let the base class do its work !
	//

	err = IIS_SERVER_INSTANCE::StartInstance();

Exit:

	if( err != NO_ERROR ) {
		ErrorTrace((LPARAM)this,"StartInstance failed: err is %d", err );
		Stop();
		wsprintf( szDebugStr, "Instance %d(%p) Start() failed: rebuild needed \n", QueryInstanceId(), (DWORD_PTR)this );
		OutputDebugString( szDebugStr );
	} else {
		wsprintf( szDebugStr, "Instance %d(%p) boot success\n", QueryInstanceId(), (DWORD_PTR)this );
		OutputDebugString( szDebugStr );
	}

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	TraceFunctLeave();

	return err ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::StopInstance
//
//  Synopsis:   Called to stop an instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::StopInstance()
{
	DWORD err ;
	CNewsTree* pTree = NULL ;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::StopInstance");
	EnterCriticalSection( &m_critRebuildRpc ) ;

	if( m_BootOptions && (m_BootOptions->m_dwCancelState != NNTPBLD_CMD_CANCEL ) ) {
		//
		//	non-null m_BootOptions indicates a pending rebuild
		//	we will handle Stop() by pending a cancel
		//
		
		m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING;
		err = ERROR_INVALID_SERVICE_CONTROL ;
		goto Exit ;
	}

	//	Stop the newstree - this allows long-winded loops to bail
	pTree = GetTree() ;
	if( pTree ) {
		pTree->StopTree();
	}

	err = IIS_SERVER_INSTANCE::StopInstance();

	if( err == NO_ERROR )
	{
		if( !Stop() ) {
			ErrorTrace((LPARAM)this,"Failed to stop instance %d", QueryInstanceId());
			err = ERROR_SERVICE_DISABLED ;
			goto Exit ;
		}
	}

Exit:

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	TraceFunctLeave();

	return err ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::PauseInstance
//
//  Synopsis:   Called to pause an instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::PauseInstance()
{
	DWORD err = NO_ERROR ;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::PauseInstance");
	EnterCriticalSection( &m_critRebuildRpc ) ;

	//
	//	pause is always valid
	//

	err = IIS_SERVER_INSTANCE::PauseInstance() ;

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	TraceFunctLeave();

	return err ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::ContinueInstance
//
//  Synopsis:   Called to continue instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

DWORD
NNTP_SERVER_INSTANCE::ContinueInstance()
{
	DWORD err = NO_ERROR ;

	TraceFunctEnter("NNTP_SERVER_INSTANCE::ContinueInstance");
	EnterCriticalSection( &m_critRebuildRpc ) ;

	//
	//	continue is always valid
	//

	err = IIS_SERVER_INSTANCE::ContinueInstance() ;

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	TraceFunctLeave();

	return err ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_SERVER_INSTANCE::CloseInstance
//
//  Synopsis:   Called when an instance is deleted
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_SERVER_INSTANCE::CloseInstance()
{
	BOOL fRet ;
	TraceFunctEnter("NNTP_SERVER_INSTANCE::CloseInstance");
	
	EnterCriticalSection( &m_critRebuildRpc ) ;

	if( m_BootOptions ) {
		//
		//	non-null m_BootOptions indicates a pending rebuild
		//	we need to cancel the rebuild - this will cause the rebuild
		//  thread to bail..
		//
		m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING;
	}

	fRet = IIS_SERVER_INSTANCE::CloseInstance();

	LeaveCriticalSection( &m_critRebuildRpc ) ;
	
	TraceFunctLeave();
	return fRet ;
}

BOOL
NNTP_SERVER_INSTANCE::SetServiceConfig(
    IN PCHAR pBuffer
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pConfig - Admin information to set

   Note:

--*/
{

    return TRUE;

} // NNTP_SERVER_INSTANCE::SetServiceConfig


BOOL
NNTP_SERVER_INSTANCE::GetServiceConfig(
    IN  PCHAR   pBuffer,
    IN  DWORD   dwLevel
    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pBuffer - Buffer to fill up.
       dwLevel - info level of information to return.

   Note:

--*/
{

	return TRUE ;

} // NNTP_SERVER_INSTANCE::GetServiceConfig



BOOL
NNTP_SERVER_INSTANCE::EnumerateUsers(
    OUT PCHAR * pBuffer,
    OUT PDWORD  nRead
    )
/*++

   Description

       Enumerates the connected users.

   Arguments:

       pBuffer - Buffer to fill up.

--*/
{
    BOOL fRet = TRUE;

    return fRet;

} // EnumerateUsers

BOOL
NNTP_SERVER_INSTANCE::DisconnectUser(
                        IN DWORD dwIdUser
                        )
/*++

   Description

       Disconnect the user

   Arguments:

       dwIdUser - Identifies the user to disconnect.  If 0,
           then disconnect ALL users.

--*/
{
    BOOL fRet = TRUE;

    //
    //  Do it.
    //

    return fRet;

} // DisconnectUser

BOOL
NNTP_SERVER_INSTANCE::GetStatistics(
                        IN DWORD dwLevel,
                        OUT PCHAR* pBuffer
                        )
/*++

   Description

       Disconnect Queries the server statistics

   Arguments:

       dwLevel - Info level.  Currently only level 0 is
           supported.

       pBuffer - Will receive a pointer to the statistics
           structure.

--*/
{
    APIERR err = NO_ERROR;


	return TRUE ;

} // QueryStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\resource.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    reslock.c   (resource.c)

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Mark Lucovsky       (markl)     04-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode.  They make use of Nt system
    services.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "resource.h"

BOOL
InitializeResource(
    IN PRESOURCE_LOCK Resource
    )

/*++

Routine Description:

    This routine initializes the input resource variable

Arguments:

    Resource - Supplies the resource variable being initialized

Return Value:

    None

--*/

{
    ASSERT( sizeof(RESOURCE_LOCK) == sizeof(RTL_RESOURCE) );

    try {
    	RtlInitializeResource((PRTL_RESOURCE)Resource);
    } except (EXCEPTION_EXECUTE_HANDLER) {
    	return FALSE;
    }

    return TRUE;

} // InitializeResourceLock

BOOL
AcquireResourceShared(
    IN PRESOURCE_LOCK Resource,
    IN BOOL Wait
    )

/*++

Routine Description:

    The routine acquires the resource for shared access.  Upon return from
    the procedure the resource is acquired for shared access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{

    return((BOOL)RtlAcquireResourceShared((PRTL_RESOURCE)Resource,(BYTE)Wait));

} // AcquireResourceLockShared

BOOL
AcquireResourceExclusive(
    IN PRESOURCE_LOCK Resource,
    IN BOOL Wait
    )

/*++

Routine Description:

    The routine acquires the resource for exclusive access.  Upon return from
    the procedure the resource is acquired for exclusive access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    return((BOOL)RtlAcquireResourceExclusive((PRTL_RESOURCE)Resource,(BYTE)Wait));
} // AcquireResourceLockExclusive


VOID
ReleaseResource(
    IN PRESOURCE_LOCK Resource
    )

/*++

Routine Description:

    This routine release the input resource.  The resource can have been
    acquired for either shared or exclusive access.

Arguments:

    Resource - Supplies the resource to release

Return Value:

    None.

--*/

{
    RtlReleaseResource((PRTL_RESOURCE)Resource);

} // ReleaseResource

VOID
DeleteResource (
    IN PRESOURCE_LOCK Resource
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input resource variable


Arguments:

    Resource - Supplies the resource variable being deleted

Return Value:

    None

--*/

{
    RtlDeleteResource((PRTL_RESOURCE)Resource);
    return;

} // DeleteResource


VOID
NTAPI
MyRtlAssert(
	PVOID	FailedAssertion,
	PVOID	FileName,
	ULONG	LineNumber, 
	PCHAR	Message
)	{

	DebugBreak() ;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\smtpcli.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smtpcli.cpp

Abstract:

	This module contains the implementation of the CSmtpClient class.
	This class encapsulates the functionality of an SMTP client. It
	inherits from the CPersistentConnection class for winsock/connection
	functionality.

Author:

    Rajeev Rajan (RajeevR)     19-May-1996

Revision History:

--*/

//
//	K2_TODO: move this into an independent lib
//
#define _TIGRIS_H_
#include "tigris.hxx"

#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

// system includes
#include <windows.h>
#include <stdio.h>
#include <winsock.h>

// user includes
#include <dbgtrace.h>
#include "smtpcli.h"

// SMTP command strings
static char* HeloCommand = "HELO ";
static char* MailFromCommand = "MAIL FROM:";
static char* RcptToCommand = "RCPT TO: ";
static char* DataCommand = "DATA\r\n";
static char* CRLF = "\r\n";

// constructor
CSmtpClient::CSmtpClient(LPSTR lpComputerName)
{
	m_pRecvBuffer [0] = 0;
	m_lpComputerName = lpComputerName;
    m_fDirty = FALSE;
}

// destructor
CSmtpClient::~CSmtpClient()
{

}

int
CSmtpClient::fReceiveFullResponse()
/*++

Routine Description : 

	Receive a full response from the SMTP server. This involves 
	possibly issuing multiple recvs till the server sends a CRLF.

	NULL terminate the recv buffer

Arguments : 

Return Value : 
	Returns number of bytes received; -1 for error

--*/
{
	TraceFunctEnter("CSmtpClient::fReceiveFullResponse");

	_ASSERT(m_CliState != sError);

	DWORD dwOffset = 0;
	DWORD cbSize = MAX_RECV_BUFFER_LEN - dwOffset;
	BOOL  fSawCRLF = FALSE;

	// till we get a CRLF or our recv buffer is not enough
	while(!fSawCRLF)
	{
		BOOL fRet = fRecv(m_pRecvBuffer+dwOffset, cbSize);
		if(!fRet)
		{
			ErrorTrace( (LPARAM)this, "Error receiving data");
			return -1;
		}

		DebugTrace( (LPARAM)this,"Received %d bytes", cbSize);

		// adjust offset for next recv
		dwOffset += cbSize;
		cbSize = MAX_RECV_BUFFER_LEN - dwOffset;

		// search the recv buffer for CRLF
		// BUGBUG: should do this repeatedly till we dont find a CR!
		char* pch = (char*)memchr((LPVOID)m_pRecvBuffer, CR, dwOffset);
		if(pch)
		{
			if( (pch - m_pRecvBuffer) < (int)dwOffset)
			{
				// CR is not the last byte
				if(*pch == CR && *(pch+1) == LF)
				{
					// CRLF found
					fSawCRLF = TRUE;
					m_pRecvBuffer[dwOffset] = '\0';		// Only need one line
				}
			}
		}

		// No CRLF
		if(dwOffset >= MAX_RECV_BUFFER_LEN)
		{
			ErrorTrace( (LPARAM)this, "Buffer size too small for server response");
			return -1;
		}
	}	// end while

	return dwOffset;
}

int
CSmtpClient::GetThreeDigitCode(
			IN LPSTR lpBuffer, 
			DWORD cbBytes
			)
/*++

Routine Description : 

	Get the three digit return code in the receive buffer

Arguments : 

	IN LPSTR lpBuffer	-	Receive buffer
	DWORD cbBytes		-   size of buffer

Return Value : 
	3-digit code in receive buffer

--*/
{
	_ASSERT(cbBytes >= 3);
	_ASSERT(lpBuffer);

	int Num = 0;
	int iDig;
	
	for (iDig = 0; iDig < 3; iDig++)
	{
		if (lpBuffer[iDig] < '0' || lpBuffer[iDig] > '9')
			return -1;
		Num *= 10;
		Num += (lpBuffer[iDig] - '0');
	}
	
	return Num;
}

BOOL	
CSmtpClient::fReceiveGreeting()
/*++

Routine Description : 

	Receive greeting from server. Success if server 
	returns the 220 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	TraceFunctEnter("CSmtpClient::fReceiveGreeting");

	// receive first line
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving greeting");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 220 code
	if(nCode != 220)
	{
		ErrorTrace( (LPARAM)this,"greeting line: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fDoHeloCommand()
/*++

Routine Description : 

	Send HELO to the server. Receive response. Success if server 
	returns the 250 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	_ASSERT(m_CliState == sInitialized);

	TraceFunctEnter("CSmtpClient::fDoHeloCommand");

    if(!IsConnected())
    {
		// the connection may have timed-out, try and re-connect
		// NOTE: this attempt is made only when the HELO command is
		// sent, because this is the first command of the series
		if(!fConnect())
		{
			ErrorTrace( (LPARAM)this, "Failed to connect");
			return FALSE;
		}

		// receive the greeting
		if(!fReceiveGreeting())
		{
			ErrorTrace( (LPARAM)this,"Failed to receive greeting");
			return FALSE;
		}
    }

	// send HELO command
    DWORD cbBytesToSend = lstrlen(HeloCommand);
	DWORD cbBytesSent = fSend(HeloCommand, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		// no excuse here - we just re-connected!!
		ErrorTrace( (LPARAM)this,"Error sending HELO command");
		return FALSE;
    }

	// send local computer name
    cbBytesToSend = lstrlen(m_lpComputerName);
	cbBytesSent = fSend(m_lpComputerName, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending local computer name");
		return FALSE;
	}

	// send CRLF
    cbBytesToSend = lstrlen(CRLF);
	cbBytesSent = fSend(CRLF, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending CRLF");
		return FALSE;
	}

	// receive response
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving response to HELO command");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 250 code
	if(nCode != 250)
	{
		ErrorTrace( (LPARAM)this,"HELO command: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fDoMailFromCommand( LPSTR lpFrom, DWORD cbFrom )
/*++

Routine Description : 

	Send MAIL FROM:<lpFrom> to the server. Receive response. Success 
	if server returns the 250 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	char szMailFromLine [MAX_PATH+1];
	char* lpBuffer = szMailFromLine;
	DWORD cbBytesToSend = 0;

	_ASSERT(m_CliState == sHeloDone);

	TraceFunctEnter("CSmtpClient::fDoMailFromCommand");

	//
	// construct MAIL FROM line
	//

	// check size of from header 
	if( cbFrom && cbFrom > MAX_PATH-16) {
		// From header too large - use a <> from line
		lpFrom = NULL;
		cbFrom = 0;
	}

	if( !lpFrom ) {
		// NULL from header
		cbBytesToSend = wsprintf( lpBuffer, "%s<>\r\n", MailFromCommand );
	} else {
		// Format from header
		cbBytesToSend = wsprintf( lpBuffer, "%s<", MailFromCommand );
		CopyMemory( lpBuffer+cbBytesToSend, lpFrom, cbFrom);
		cbBytesToSend += cbFrom;
		*(lpBuffer+cbBytesToSend) = '\0';
		cbBytesToSend += wsprintf( lpBuffer+cbBytesToSend, ">\r\n");
	} 

	// send MAIL FROM command
	DWORD cbBytesSent = fSend(lpBuffer, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending MAIL FROM command");
		return FALSE;
	}

	// receive response
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving response to MAIL FROM command");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 250 code
	if(nCode != 250)
	{
		ErrorTrace( (LPARAM)this,"MAIL FROM command: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fMailArticle(	
			IN HANDLE	hFile,
			IN DWORD	dwOffset,
			IN DWORD	dwLength,
			IN char*	pchHead,
			IN DWORD	cbHead,
			IN char*	pchBody,
			IN DWORD	cbBody
			)
/*++

Routine Description : 

	If hFile != NULL, use TransmitFile to send the data else use send()

Arguments : 

	IN HANDLE	hFile			:	handle of file	
	IN DWORD	dwOffset		:	offset of article within file
	IN DWORD	dwLength		:	length of article
	IN char*	pchHead			:	pointer to article headers
	IN DWORD	cbHead			:	number of header bytes
	IN char*	pchBody			:	pointer to article body
	IN DWORD	cbBody			:	number of bytes in body

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	TraceFunctEnter("CSmtpClient::fMailArticle");

	if ( hFile != INVALID_HANDLE_VALUE )	// Article is in file
	{
		_ASSERT( pchHead == NULL );
		_ASSERT( cbHead  == 0    );
		_ASSERT( pchBody == NULL );
		_ASSERT( cbBody  == 0    );

		DebugTrace((LPARAM)this,"Sending article via TransmitFile()");

		if(!this->fTransmitFile(hFile, dwOffset, dwLength))
		{
			ErrorTrace((LPARAM)this,"Error sending article via TransmitFile()");
			return FALSE;
		}
	}
	else			// Article is in memory buffer
	{
		_ASSERT( hFile == INVALID_HANDLE_VALUE );
		_ASSERT( pchHead );
		_ASSERT( cbHead  );

		DWORD cbBytesSent = this->fSend( (LPCTSTR)pchHead, (int)cbHead );
		if(cbBytesSent != cbHead)
		{
			ErrorTrace((LPARAM)this,"Error sending article header via send()");
			return FALSE;
		}

		if( cbBody )
		{
			_ASSERT( pchBody );

			cbBytesSent = this->fSend( (LPCTSTR)pchBody, (int)cbBody );
			if(cbBytesSent != cbBody)
			{
				ErrorTrace((LPARAM)this,"Error sending article body via send()");
				return FALSE;
			}
		}
	}

	TraceFunctLeave();
	return TRUE;
}

BOOL	
CSmtpClient::fDoRcptToCommand(LPSTR lpRcpt)
/*++

Routine Description : 

	Send RCPT TO to the server. Receive response. Success if server 
	returns the 250 code, else failure.

Arguments : 

	LPSTR lpRcpt		-	Recipient email addr

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	_ASSERT(m_CliState == sMailFromSent);

	TraceFunctEnter("CSmtpClient::fDoRcptToCommand");

	// send RCPT TO command
    DWORD cbBytesToSend = lstrlen(RcptToCommand);
	DWORD cbBytesSent = fSend(RcptToCommand, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending RCPT TO command");
		return FALSE;
	}

	// send recipient
    cbBytesToSend = lstrlen(lpRcpt);
	cbBytesSent = fSend(lpRcpt, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending recipient");
		return FALSE;
	}

	// send CRLF
    cbBytesToSend = lstrlen(CRLF);
	cbBytesSent = fSend(CRLF, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending CRLF");
		return FALSE;
	}

	// receive response
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving response to RCPT TO command");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 250 or 251 code
	if(nCode != 250 && nCode != 251)
	{
		ErrorTrace( (LPARAM)this,"RCPT TO command: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fDoDataCommand()
/*++

Routine Description : 

	Send DATA to the server. Receive response. Success if server 
	returns the 354 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	_ASSERT(m_CliState == sRcptTo);

	TraceFunctEnter("CSmtpClient::fDoDataCommand");

	// send DATA command
    DWORD cbBytesToSend = lstrlen(DataCommand);
	DWORD cbBytesSent = fSend(DataCommand, cbBytesToSend);
	if(cbBytesSent < cbBytesToSend)
	{
		ErrorTrace( (LPARAM)this,"Error sending DATA command");
		return FALSE;
	}

	// receive response
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving response to DATA command");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 354 code
	if(nCode != 354)
	{
		ErrorTrace( (LPARAM)this,"DATA command: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

BOOL	
CSmtpClient::fReceiveDataResponse()
/*++

Routine Description : 

	Receive response to data transmission. Success if server 
	returns the 250 code, else failure.

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	TraceFunctEnter("CSmtpClient::fReceiveDataResponse");

	// receive first line
	int nRet = fReceiveFullResponse();
	if(nRet == -1)
	{
		ErrorTrace( (LPARAM)this, "Error receiving data response");
		return FALSE;
	}

	// validate response code
	int nCode = GetThreeDigitCode(m_pRecvBuffer, (DWORD)nRet);

	// server should return a 250 code
	if(nCode != 250)
	{
		ErrorTrace( (LPARAM)this,"data response: unexpected server code");
		return FALSE;
	}

	return TRUE;
}

//
//	Constructor, Destructor
//
CSmtpClientPool::CSmtpClientPool()
{
	m_rgpSCList = NULL;
	m_cSlots = 0;
	m_rgAvailList = NULL;
	InitializeCriticalSection(&m_CritSect);	
}

CSmtpClientPool::~CSmtpClientPool()
{
	DeleteCriticalSection(&m_CritSect);
}

BOOL 
CSmtpClientPool::AllocPool(
		DWORD cNumInstances
		)
/*++

Routine Description : 

	Allocate X objects and initialize them. Set all to avail status

Arguments : 

	DWORD cNumInstances		-	Number of objects needed in pool

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	DWORD cbSize = MAX_COMPUTERNAME_LENGTH+1;

	TraceFunctEnter("CSmtpClientPool::AllocPool");

	_ASSERT(!m_rgpSCList);
	_ASSERT(!m_rgAvailList);
	_ASSERT(!m_cSlots);

	m_rgpSCList = (CSmtpClient**)HeapAlloc(GetProcessHeap(), 0, sizeof(CSmtpClient*)*cNumInstances);
	if(!m_rgpSCList)
	{
		FatalTrace( (LPARAM)this,"Memory allocation failed");
		return FALSE;
	}

	// NULL all object pointers
	for(DWORD i=0; i<cNumInstances; i++)
	{
		m_rgpSCList [i] = NULL;
	}

	m_rgAvailList = (BOOL*) HeapAlloc(GetProcessHeap(), 0, sizeof(BOOL)*cNumInstances);
	if(!m_rgAvailList)
	{
		FatalTrace( (LPARAM)this,"Memory allocation failed");
		goto Pool_Cleanup;
	}

	// no object is available by default
	for(i=0; i<cNumInstances; i++)
	{
		m_rgAvailList [i] = FALSE;
	}

	// set total number of slots
	m_cSlots = cNumInstances;
	
    // needed for HELO command
	GetComputerName(m_szComputerName, &cbSize);

	for(i=0; i<cNumInstances; i++)
	{
		CSmtpClient* pSC = new CSmtpClient(m_szComputerName);
		if(!pSC)
		{
			ErrorTrace( (LPARAM)this,"Memory allocation failed");
			goto Pool_Cleanup;
		}

		// store in pool array and mark as available
		m_rgpSCList	  [i] = pSC;
		m_rgAvailList [i] = TRUE;
		pSC->SetClientState(sInitialized);
	}

	// Pool initialized successfully
	return TRUE;

Pool_Cleanup:

	// abnormal exit; cleanup
	for(i=0; i<cNumInstances; i++)
	{
		if(m_rgpSCList[i])
		{
			delete m_rgpSCList [i];
			m_rgpSCList [i] = NULL;
		}
	}

	if(m_rgpSCList)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)m_rgpSCList);
		m_rgpSCList = NULL;
	}

	if(m_rgAvailList)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)m_rgAvailList);
		m_rgAvailList = NULL;
	}

	return FALSE;
}

VOID 
CSmtpClientPool::FreePool()
/*++

Routine Description : 

	Free all objects

Arguments : 


Return Value : 
	VOID

--*/
{
	CSmtpClient* pSC;

	// terminate and delete all CSmtpClient objects in the pool
	for(DWORD i=0; i<m_cSlots; i++)
	{
		pSC = m_rgpSCList[i];
		if(pSC)
		{
            // terminate only if initialized
            if(pSC->IsInitialized())
			    pSC->Terminate(TRUE);
			delete pSC;
			m_rgpSCList [i] = NULL;
		}
	}

	// Now there are no objects in the pool
	m_cSlots = 0;

	// free the object array
	if(m_rgpSCList)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)m_rgpSCList);
		m_rgpSCList = NULL;
	}

	// free the avail bool array
	if(m_rgAvailList)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID)m_rgAvailList);
		m_rgAvailList = NULL;
	}
}

CSmtpClient* 
CSmtpClientPool::AcquireSmtpClient(DWORD& dwIndex)
/*++

Routine Description : 

	Get an object from the pool

Arguments : 

	DWORD& dwIndex		-		Index of client is returned if
								a client object is available

Return Value : 
	Pointer to object if one is available, else NULL

--*/
{
	_ASSERT(m_rgpSCList);
	_ASSERT(m_rgAvailList);
	_ASSERT(m_cSlots);

	CSmtpClient* pSC = NULL;

	LockPool();

	for(DWORD i=0; i<m_cSlots; i++)
	{
		// if avail is TRUE, return this object
		if(m_rgAvailList[i])
		{
			pSC = m_rgpSCList[i];
			m_rgAvailList [i] = FALSE;	// mark as not avail
			dwIndex = i;				// return this index
			break;
		}
	}

	UnLockPool();

	return pSC;
}

VOID
CSmtpClientPool::ReleaseSmtpClient(DWORD dwIndex)
/*++

Routine Description : 

	Return an object to the pool; Index should be 
	same as that returned by GetSmtpClient

Arguments : 

	DWORD	dwIndex		-		Index of client to release

Return Value : 
	VOID

--*/
{
	_ASSERT(m_rgpSCList);
	_ASSERT(m_rgAvailList);
	_ASSERT(m_cSlots);

	LockPool();

	// mark as avail
	m_rgAvailList [dwIndex] = TRUE;

	UnLockPool();
}

VOID
CSmtpClientPool::MarkDirty()
/*++

Routine Description : 

	Mark pool objects dirty

Arguments : 

Return Value : 
	VOID

--*/
{
	CSmtpClient* pSC = NULL;

	LockPool();

	for(DWORD i=0; i<m_cSlots; i++)
	{
		pSC = m_rgpSCList[i];
        if(pSC->IsInitialized())
        {
            // this object has a persistent connection to an SMTP server
            // mark as dirty - this ensures a re-connect to the new SMTP server
            pSC->MarkDirty();
        }
	}

	UnLockPool();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\smtpcli.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smtpcli.h

Abstract:

	This module contains the definition of the CSmtpClient class.
	This class encapsulates the functionality of an SMTP client. It
	inherits from the CPersistentConnection class for winsock/connection
	functionality.

	Also contains the definition of the CSmtpClientPool class. This
	represents a pool of CSmtpClient objects. Only one instance of this
	class will be created.

Author:

    Rajeev Rajan (RajeevR)     19-May-1996

Revision History:

--*/

#ifndef _SMTPCLI_H_
#define _SMTPCLI_H_

#define MAX_RECV_BUFFER_LEN		256
#define CR						0x0D
#define LF						0x0A
#define SMTP_SERVER_PORT		25

#include "persistc.h"

//
// Represents the states of a SMTP client
//

typedef enum _SMTP_STATE {
	sInitialized,				// Init state
	sHeloDone,					// HELO sent and 250 received
	sMailFromSent,				// MAIL FROM sent and 250 received
	sRcptTo,					// One or more RCPT TO sent
	sDataDone,					// DATA sent and 354 received
	sError,						// Error state
} SMTP_STATE;


class CSmtpClient : public CPersistentConnection {

private:
	//
	//	Local computer name - needed for HELO command
	//
	LPSTR	m_lpComputerName;

	//
	//	This clients state
	//
	SMTP_STATE	m_CliState;

    //
    //  dirty flag - set if the SMTP server changes
    //
    BOOL    m_fDirty;

	//
	//	Receive buffer
	//
	TCHAR	m_pRecvBuffer	[MAX_RECV_BUFFER_LEN+1];

	//
	//	Receive a full response from the SMTP server
	//  This involves possibly issuing multiple recvs
	//	till the server sends a CRLF
	//
	int 	fReceiveFullResponse();

	//
	//	Get 3-digit code from response buffer
	//
	int		GetThreeDigitCode(LPSTR lpBuffer, DWORD cbBytes);
	
public:
	//
	//	Construtor
	//
	CSmtpClient(LPSTR lpComputerName);

	//
	//	Destructor
	//
	~CSmtpClient();

	//
	//	get/set this clients state
	//
	SMTP_STATE	GetClientState(){ return m_CliState;}
	VOID		SetClientState(SMTP_STATE CliState){ m_CliState = CliState;}

    //
    //  IsDirty() returns TRUE if SMTP server has changed
    //  MarkDirty() marks this object as dirty ie. SMTP server has changed
    //  MarkClean() marks this object as current
    //
    BOOL    IsDirty(){ return m_fDirty;}
    VOID    MarkDirty(){ m_fDirty = TRUE;}
    VOID    MarkClean(){ m_fDirty = FALSE;}

	//
	//	receive SMTP server greeting
	//
	BOOL	fReceiveGreeting();

	//
	//	send HELO and check response for 250 code
	//
	BOOL	fDoHeloCommand();

	//
	//	send MAIL FROM and check response for 250 code
	//
	BOOL	fDoMailFromCommand( LPSTR lpFrom, DWORD cbFrom );

	//
	//	send RCPT TO and check response for 250 code
	//
	BOOL	fDoRcptToCommand(LPSTR lpRcpt);

	//
	//	send the article data either via socket send() or TransmitFile()
	//
	BOOL	fMailArticle(	
				IN HANDLE	hFile,
				IN DWORD	dwOffset,
				IN DWORD	dwLength,
				IN char*	pchHead,
				IN DWORD	cbHead,
				IN char*	pchBody,
				IN DWORD	cbBody
				);

	//
	//	send DATA and check response for 354 code
	//
	BOOL	fDoDataCommand();

	//
	//	receive and validate response to data transmission
	//
	BOOL	fReceiveDataResponse();
};

class CSmtpClientPool {

private:
	//
	//	Array of pointers to CSmtpClient objects
	//
	CSmtpClient**	m_rgpSCList;

	//
	//	Number of slots in pool
	//
	DWORD			m_cSlots;

	//
	//	Array of BOOLs indicating avail status
	//  TRUE means the object in this slot is available.
	//
	BOOL*			m_rgAvailList;

	//
	//	critical section to ensure that two threads 
	//  dont get the same object or mark the same object as avail
	//
	CRITICAL_SECTION	m_CritSect;	

	//
	//	Needed by each CSmtpClient object for the HELO command
	//
	TCHAR			m_szComputerName [MAX_COMPUTERNAME_LENGTH+1];

	//
	//	Synchronize access to pool
	//
	VOID LockPool() { EnterCriticalSection(&m_CritSect);}
	VOID UnLockPool(){ LeaveCriticalSection(&m_CritSect);}

	friend VOID DbgDumpPool( CSmtpClientPool* pSCPool );

public:

	//
	//	Constructor, Destructor
	//
	CSmtpClientPool();
	~CSmtpClientPool();

	//
	//	Allocate X objects and initialize them
	//  Set all to avail status
	//
	BOOL AllocPool(DWORD cNumInstances);

	//
	//	Free all objects
	//
	VOID FreePool();

	//
	//	Get an object from the pool
	//
	CSmtpClient* AcquireSmtpClient(DWORD& dwIndex);

	//
	//	Return an object to the pool; Index should be 
	//  same as that returned by GetSmtpClient
	//
	VOID ReleaseSmtpClient(DWORD dwIndex);

    //
    //  Mark all persistent objects as dirty
    //
    VOID MarkDirty();

    //
    //  Get computer name
    //
    LPSTR GetCachedComputerName(){return m_szComputerName;}
};

#endif	// _SMTPCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\session.inl ===
inline	void*
CSessionSocket::operator	new(	
							size_t	size 
							) {
/*++

Routine Description : 

	Allocate a new CSessionSocket object using a CPool object 
	reserved for that use.

Arguments : 

	size - size of CSessionSocket object.

Return Value : 

	Allocated memory.

--*/

	Assert( size <= sizeof( CSessionSocket ) ) ;
	void*	pv = gSocketAllocator.Alloc() ;
	return	pv ;
}

inline	void
CSessionSocket::operator	delete(	
							void*	pv 
							)	{
/*++

Routine Description : 

	Release the memory used by a CSessionSocket object back to the CPool

Arguments : 

	pv - memory to be released

Return Value : 

	None.

--*/
	gSocketAllocator.Free( pv ) ;
}

#if 0
inline	DWORD	
CSessionSocket::GetCurrentSessionCount()	{	
/*++

Routine Description : 

	Report the number of CSessionSockets which are handling live sessions
	right now.

Arguments : 

	None.

Return Value : 

	None.


--*/

	return	((m_context.m_pInstance)->m_pInUseList)->GetListCount() ;	
}
#endif


//+---------------------------------------------------------------
//
//  Function:   InsertUser
//
//  Synopsis:   Adds CSessionSocket instances to the InUse list
//
//  Arguments:  pUser:   ptr to CSessionSocket instance
//
//  Returns:    void
//
//  History:    gord        Created         10 Jul 1995
//
//----------------------------------------------------------------
inline void CSocketList::InsertSocket( CSessionSocket* pUser )
{
    pUser->m_pPrev = NULL;

    EnterCriticalSection( &m_critSec );

    if ( m_pListHead )
    {
        m_pListHead->m_pPrev = pUser;
    }
    pUser->m_pNext = m_pListHead;
    m_pListHead = pUser;

    m_cCount++;

    LeaveCriticalSection( &m_critSec );
}


//+---------------------------------------------------------------
//
//  Function:   RemoveUser
//
//  Synopsis:   Removes CSessionSocket instances to the InUse list
//
//  Arguments:  pUser:   ptr to CSessionSocket instance or NULL for m_pHeadList
//
//  Returns:    pUser:   ptr to the removed CSessionSocket instance
//
//  History:    gord        Created         10 Jul 1995
//
//----------------------------------------------------------------
inline void CSocketList::RemoveSocket( CSessionSocket* pUser )
{

    _ASSERT( pUser != NULL );

    EnterCriticalSection( &m_critSec );

    //
    // if we're not at the end set the next element's prev
    // pointer to our prev; including if our prev is NULL
    //
    if ( pUser->m_pNext )
    {
        pUser->m_pNext->m_pPrev = pUser->m_pPrev;
    }

    //
    // if we're not at the head set the prev element's next
    // pointer to our next; including if our next is NULL
    //
    if ( pUser->m_pPrev )
    {
        _ASSERT( m_pListHead != pUser );
        pUser->m_pPrev->m_pNext = pUser->m_pNext;
    }
    //
    // if we're at the head set the head pointer to our next;
    // including if our next is NULL
    //
    else
    {
        _ASSERT( m_pListHead == pUser );
        _ASSERT( pUser->m_pNext != NULL || m_cCount == 1 );

        m_pListHead = pUser->m_pNext;
    }

    m_cCount--;

    LeaveCriticalSection( &m_critSec );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\resource.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    resource.h  (nturtl.h)

Abstract:

    Include file for NT runtime routines that are callable by only
    user mode code in various.

Author:

    Steve Wood (stevewo) 10-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode.  They make use of Nt system
    services.

Revision History:

    Johnson Apacible (johnsona)     25-Sep-1995
        ported to Win32

--*/

#ifndef _RESOURCE_
#define _RESOURCE_

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _JTL_CRITICAL_SECTION_DEBUG {
    USHORT Type;
    USHORT CreatorBackTraceIndex;
    struct _JTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    ULONG EntryCount;
    ULONG ContentionCount;
    ULONG Spare[ 2 ];
} JTL_CRITICAL_SECTION_DEBUG, *PJTL_CRITICAL_SECTION_DEBUG;

typedef struct _JTL_CRITICAL_SECTION {
    PJTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    ULONG Reserved;
} JTL_CRITICAL_SECTION, *PJTL_CRITICAL_SECTION;

//
//  Shared resource function definitions
//

typedef struct _JTL_RESOURCE_DEBUG {
    ULONG Reserved[ 5 ];    // Make it the same length as JTL_CRITICAL_SECTION_DEBUG

    ULONG ContentionCount;
    ULONG Spare[ 2 ];
} JTL_RESOURCE_DEBUG, *PJTL_RESOURCE_DEBUG;

typedef struct _RESOURCE_LOCK {

    //
    //  The following field controls entering and exiting the critical
    //  section for the resource
    //

    JTL_CRITICAL_SECTION CriticalSection;

    //
    //  The following four fields indicate the number of both shared or
    //  exclusive waiters
    //

    HANDLE SharedSemaphore;
    ULONG NumberOfWaitingShared;
    HANDLE ExclusiveSemaphore;
    ULONG NumberOfWaitingExclusive;

    //
    //  The following indicates the current state of the resource
    //
    //      <0 the resource is acquired for exclusive access with the
    //         absolute value indicating the number of recursive accesses
    //         to the resource
    //
    //       0 the resource is available
    //
    //      >0 the resource is acquired for shared access with the
    //         value indicating the number of shared accesses to the resource
    //

    LONG NumberOfActive;
    HANDLE ExclusiveOwnerThread;

    ULONG Flags;        // See JTL_RESOURCE_FLAG_ equates below.

    PJTL_RESOURCE_DEBUG DebugInfo;
} RESOURCE_LOCK, *PRESOURCE_LOCK;


BOOL
InitializeResource(
    PRESOURCE_LOCK Resource
    );

BOOL
AcquireResourceShared(
    PRESOURCE_LOCK Resource,
    BOOL Wait
    );

BOOL
AcquireResourceExclusive(
    PRESOURCE_LOCK Resource,
    BOOL Wait
    );

VOID
ReleaseResource(
    PRESOURCE_LOCK Resource
    );

VOID
DeleteResource (
    PRESOURCE_LOCK Resource
    );


#ifdef __cplusplus
}
#endif

#endif  // _RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\session.h ===
//
//	@doc	INTERNAL
//
//	@module	SESSION.H - Session Related Objects |
//
// This module defines those classes which encapsulate session information and
// state information for sessions.
//
//  The Classes which are defined in here are :
//
//      CSessionState
//      CLogon
//      CAcceptNNRPD
//      CExtendedCMD
//      CTransmitArticle
//      CAcceptArticle
//      CCollectNewnews
//      CCollectArticles
//      COfferArticles
//      CSocket
//      CSessionSocket
//      CSocketList
//
//	Each Active session to the server is represented by one CSessionSocket object.
//	The CSessionSocket object will have a pointer to an object derived from CSessionState
//	which will represent the current state of the object.  The CSessionState object
//	will be responsible for issuing IO's appropriate to the state.  In general the CSessionState
//	derived object is responsible for all synchronization issues if it has multiple IO's
//	outstanding at a time.
//
//	The CAcceptNNRPD state receives commands and issues the response for simple commands (ie. 'next').
//	This state generally has one async read outstanding always and will do synchronous sends to respond to commands.
//
//	The CExtendedCMD state can only be entered when the CAcceptNNRPD state receives any kind of
//	command that does not have a small response.  (ie.  newnews, list comp.*, etc....)
//	The CExtendedCMD state will generally have 1 async writes pending.  When processing an
//	extended command the CExtendedCMD computes the response untill it has filled a buffer, it then
//	issues an Async Write for this buffer.  Each time an async write completes, we will compute a
//	some more of the response and then send it.
//
//	The CTransmitArticle state will either issue a single TransmitFile IO or do multiple
//	writes depending on the security settings of the session.  No Reads are issued in this state.
//	CTransmitArticle state is enterred from the CAcceptNNRPD and COfferArticles states.
//
//	The CAcceptArticle state is used whenever an article is being transmitted to the server
//	and we wish to spool up the results.  The CAcceptArticle will always have 1 pending Read.
//	As each read completes this state will examine the buffer to determine whether we have
//	completed the article transfer.  Once the article is completely transferred, we will pass
//	the HFILE of the resulting file to the CInFeed object for the session.
//	(A session in CAcceptArticle state will go either to CCollectArticles or CAcceptNNRPD.
//	CCollectArticles if this is a feed we're pulling from another server, CAcceptNNRPD for any other session.)
//	
//	The CCollectNewnews state issues a single write of the appropriate newnews command and then
//	keeps 1 read pending until it has collect all responses.  As each read completes we will start
//	processing Message-Id's to determine which to accept/reject.	This will require a critical section
//	and if the other side sends Message-Id's faster then we can process them there may not be a read pending.
//
//	The CCollectArticles state issues single 'article <Msg-Id> commands and is entered after the CCollectNewnews
//	state.  This state uses a CInFeed object and will repeatedly change the state to the CAcceptArticle state
//	untill we have collected all the articles on the feed.
//
//	The COfferArticles issues 'Ihave' or 'xreplic' commands using a COutFeed object to generate each command.
//	Whenever we get a response asking for the article, we will enter the CTransmitArticle state and send the article.
//
//
//	Each IO operation is represented by a CIO object.  CIO objects will contain reference counting pointers
//	to the
//
//
//  Implementation Schedule for the classes :
//
//      CSessionSocket, CSocketList, CSocket, CAcceptArticle    1.5wk
//
//          CSessionSocket and CSocketList can be largely re-used from
//          code in the shuttle project.  CAcceptArticle will have to be
//          written from scratch.
//
//      Unit Testing  -
//          The above four classes will be unit tested as a whole -
//          The unit test will consist of accepting a socket,
//          placing it in the CAcceptArticle state and spooling up
//          one article and then closing the socket.            0.5wk
//
//      CCollectNewnews, CCollectArticles -                     1 wk.
//          These classes can be pulled from Exchange code.
//
//      Unit Testing -
//          The above two classes will be unit tested with the
//          previous four.  We will pull articles down from
//          an INN server using these classes.                  1 wk.
//
//
//      CAcceptNNRPD, CExtendedCMD, CTransmitArticle            1 wk.
//          These classes will need to be written from scratch.
//
//      Unit Testing -
//          These classes will be Unit Tested using Telnet,     1 wk.
//          and typing commands at the telnet prompt.
//
//
//      COfferArticles                                          1 wk.
//          This class issues IHave commands and must be implemented from
//          scratch.  This class depends on having a single working COutFeed object.
//
//      Unit Testing -                                          1 wk.
//          This class will be unit tested against another server which
//          has a working CAcceptNNRPD state engine going.
//
//
//



#ifndef	_SESSION_H_
#define	_SESSION_H_

#include	<winsock.h>
#include	"smartptr.h"
#include	"queue.h"
#include	"lockq.h"

#include	"io.h"

//
// CPool Signature
//

#define SESSION_SOCKET_SIGNATURE (DWORD)'1023'
#define SESSION_STATE_SIGNATURE (DWORD)'1516'

typedef	enum	LOG_DATA	{
	LOG_OPERATION,
	LOG_TARGET,
	LOG_PARAMETERS
} ;


class	CLogCollector	{
public : 
	char*		m_Logs[3] ;
	DWORD		m_LogSizes[3] ;

	DWORD		m_cbOptionalConsumed ;
	BYTE		m_szOptionalBuffer[256] ;
#ifdef	DEBUG
	//
	//	For debug - m_dwSignature follows the buffer immediately to detect overwrites !
	//
	DWORD		m_dwSignature ;
	DWORD		m_cAllocations ;
	DWORD		m_cCalls ;
#endif

	//
	//	Number of Bytes Sent/Recvd
	//
	STRMPOSITION	m_cbBytesSent ;
	DWORD			m_cbBytesRecvd ;

	//
	//	This function will copy data into the CLogCollector objects
	//	m_szOptionalBuffer and truncate the data if necessary.
	//	
	void	FillLogData(	LOG_DATA,	BYTE*	lpb,	DWORD cb ) ;

	//
	//	This function will place a pointer to log data into the 
	//	array (we assume it is NULL terminated).
	//
	void	ReferenceLogData(	LOG_DATA,	BYTE*	lpb ) ;

	//
	//	This function will reservce space in either the m_szOptionalBuffer
	//	or in the buffer pointer to in m_pBuffer for use to store log data.
	//	It is expected that hte call will later call ReferenceLogData with
	//	this address.
	//
	BYTE*	AllocateLogSpace( DWORD	cb ) ;

	//
	//	Return TRUE if we have recorded data for a transaction log !
	//
	BOOL	FLogRecorded()	{
		return	m_Logs[0] != 0 ; 
	}
	
	//
	//	Reset everything !
	//
	void	Reset()	{
#ifdef	DEBUG
		_ASSERT( m_dwSignature == 0xABCDEF12 ) ;
		m_cAllocations = 0 ;
		m_cCalls = 0 ;
#endif
		m_cbOptionalConsumed = 0 ;
		ASSIGNI( m_cbBytesSent, 0 );
		m_cbBytesRecvd = 0;

		ZeroMemory( m_Logs, sizeof( m_Logs ) ) ;
		ZeroMemory( m_LogSizes, sizeof( m_LogSizes ) ) ;
	}

	CLogCollector()	{	
#ifdef	DEBUG
		m_dwSignature = 0xABCDEF12 ;
#endif
		Reset() ;	
	}
} ;


//
//	Utility functions
//

//	Create a temp file name
BOOL	NNTPCreateTempFile( LPSTR	lpstrDir, LPSTR lpstrFile ) ;

//-------- Socket State Classes ----------------------------------------------
//
// All of the following classes represent a state a socket session can be in
// AFTER the session has been established (ie. this doesn't cover listening).
//
// CSessionState represents the state a session is in.  This is the base class
// from which various classes representing the particular states will derive from.
// This class defines a complete interface for Completing the IO operations that
// are performed while in this state.
//
// State objects should only override those virtual functions for which they will
// issue IO's.   (For instance the CAcceptArticle state should only override the
// Complete( CIORead*, .... ) function.)  The base implementation of these functions
// will do a DebugBreak().
//
//  In general CSessionState objects operate in this fashion :
//   1   The State is initialized and issues a first IO operation.
//   2   The IO operation (represented by a CIO object) executes until the IO is complete.
//      (For instance, a CIOReadLine will re-issue reads until it has received and EOL character.)
//   3   Once the IO completes, it call the appropriate Complete function on the
//      CSessionState object.  The CSessionState object processes the completed IO.
//   4   The State object issues another IO.
//
class	CSessionState : public CRefCount	{
protected :

    //
    // We should have a CPool object here for allocating CSessionState objects.
    //

	static	CPool	gStatePool ;

public :

    //
    //  operators new and delete will actually go to a CPool object to get the memory
    //  for state objects.
    //
    void    *operator   new( size_t size ) ;
    void    operator    delete( void * ) ;

	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;


    //
    //  Check that a CSessionState Object is valid.
    //

    // Virtual destructor as we are inherited from a lot.
	virtual	~CSessionState() ;

    //
	// This function should issue the first IO operation for this state.
	// Once the IO is issued, state objects will issue additional IO's on
	// each call of a Complete() function
    //
	virtual	BOOL	Start(	CSessionSocket*,	
							CDRIVERPTR&,	
							CIORead*&,	
							CIOWrite*&	
							) = 0 ;	// bugbug - get rid of CDRIVERPTR& !!

	//
    // Destroy everything we might be holding and move onto the Terminating State
	//	After calling this function no further IO operations will be issued.  The
	//	state object should destroy all of its internal structures in a thread safe
	//	way and then move onto the Terminating State.  The Terminating State will
	//	collect all outstanding IO's as they complete and destroy them.
    //
//    virtual void Shutdown( ) ;

    //
    //  Specify all possible IO Completions we may need to process.
    //  This base class will DebugBreak() on all of these, as all derived states
    //  should have a completion function for the IO's that they issue.
    //  NOTE :
    //  A derived class need not override a completion function for an IO it won't
    //  issue - it would be appropriate to DebugBreak() to find bugs.
    //
    //  NOTE :
    //  If the Complete function returns TRUE, the calling CIO object should
    //  call the sockets ReleaseState function with the pointer to the CSessionState object.
    //  (returning TRUE means the state has complete and will be destroyed by the CSessionSocket object.)
    //


	//
	//	When we have read a complete line, this will be called, 
	//	The line will be broken into an array of pointers to the 
	//	white space separated elements on the line.
	//	If there are too many arguments, then the last pointer 
	//	in the array of pszArgs will point at the last arguments, 
	//	and there will be no pointers for intermediate arguments.
	//	pchBegin points to the start of the usable buffer space
	//	that the called function can overwrite.
	//
	virtual	class CIO*	
	Complete( 
				class	CIOReadLine*, 
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver, 
				int	cArgs,	
				char	**pszArgs, 
				char* pchBegin 
				) ;

	//
	//	We have completed writing a line of text to the socket !
	//
	virtual	class CIO*	
	Complete( 
				class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

	//
	//	We have completed executing a CExecute derived command object,
	//	and all the bytes have been sent to the client !
	//
	virtual	class CIO*	
	Complete( 
				class CIOWriteCMD*, 
				class CSessionSocket*, 
				CDRIVERPTR&	pdriver,	
				class	CExecute*	pCmd, 
				class CLogCollector* pCollector 
				) ;


	//
	//	Signal completion of an asynchronous command - this is called
	//	when the final send to the client finishes !
	//
	virtual	class	CIO*	
	Complete(
				class	CIOWriteAsyncCMD*,
				class	CSessionSocket*,
				CDRIVERPTR&	pdriver, 
				class	CAsyncExecute*	pCmd,
				class	CLogCollector*	pCollector
				) ;

	//
	//
	//

	virtual	class CIO*	
	Complete(	class CIOMLWrite*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;



	//
	//	We have completed reading an article
	//
	virtual	void	
	Complete( 
				class CIOReadArticle*, 
				class CSessionSocket *,	
				CDRIVERPTR&,	
				CFileChannel&	pFileChannel, 
				DWORD	cbTransfer 
				) ;

	//
	//	We have completed transmitting an article to a client
	//
	virtual class CIO*	
	Complete( 
				class	CIOTransmit*,	
				class	CSessionSocket*, 
				CDRIVERPTR&,	
				TRANSMIT_FILE_BUFFERS*,
				unsigned cbBytes = 0
				) ;

	//
	//	We have read an entire article.
	//	nrcResult is an NNTP return code which indicates whether we successfully
	//	got the entire article. if nrcResult == nrcOK, then
	//	pchHeader will point to the head of the article.
	//	cbHeader will be the length of the article's header
	//	if cbArticle is not zero then it the entire article is in the 
	//	buffer we have been passed and hArticle will be iNVALID_HANDLE_VALUE
	//	if cbArticle is 0 then hArticle will be the handle to the file where
	//	the article has been saved.
	//	If a file handle is passed to the state, then the state is responsible
	//	for closing the handle in all circumstances.  The caller has relinquished
	//	the handle !!
	//
	virtual	void	
	Complete(
				class	CIOGetArticle*,
				class	CSessionSocket*,
				NRC		nrcResult,
				char*	pchHeader, 
				DWORD	cbHeader, 
				DWORD	cbArticle,
				DWORD	cbTotalBuffer,
				HANDLE	hArticle,
				DWORD	cbGap,
				DWORD	cbTotalTransfer
				) ;

	//
	//	This is the signature for a read that completes
	//	entirely in memory !
	//
	virtual	class	CIO*
	Complete(
				class		CIOGetArticleEx*,
				class		CSessionSocket*,
				//
				//	If fGoodMatch is TRUE then we matched the
				//	string we wanted to match - otherwise we 
				//	matched the error string !
				//
				BOOL		fGoodMatch,
				CBUFPTR&	pBuffer,
				DWORD		ibStart, 
				DWORD		cb
				) ;

	//
	//	This is the signature for a slurpy read where
	//	we just consume all the bytes off the socket !
	//
	virtual	class	CIO*
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*
				) ;

	//
	//	This is the completion that is called when we've 
	//	completed transferring an article to a file !
	//
	virtual	void
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) ;

				
	virtual	void	
	Shutdown(	CIODriver&	driver,	
				CSessionSocket*	pSocket,	
				SHUTDOWN_CAUSE	cause,	
				DWORD	dw 
				) ;
} ;


#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CSessionState ) 

#endif



/*++
	@class	Representing Socket which is issuing a Newnews command.

	@base public | CSessionState

	the CCollectNewnews represents a session in which we will isssue a newnews command to a
	NNTP Server.  We will use this state when pulling a feed from the other server.

--*/
class CCollectNewnews : public CSessionState {
private :
	CFILEPTR		m_pFileChannel ;
	CDRIVERPTR		m_pSessionDriver ;
	long			m_cCompletes ;
#if 0 
	long			m_cCommandCompletes ;
#endif

	BOOL	InternalComplete(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver ) ;

//	@access	Public	Members	
public :
	CCollectNewnews() ;
	~CCollectNewnews() ;

#if 0 
	BOOL	ModeReaderComplete( CSessionSocket*,	CDRIVERPTR&,	class	CIORead*&, class CIOWrite*& ) ;
#endif
	
	BOOL	Start(	CSessionSocket*,	CDRIVERPTR&,	class	CIORead*&,	class	CIOWrite*&	) ;

	class CIO*	Complete( class	CIOReadLine*, class	CSessionSocket *, CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs,	char	*pchBegin ) ;
	class CIO*	Complete( class CIOWriteLine*,	class	CSessionSocket *, CDRIVERPTR&	pdriver ) ;
	void	Complete( class CIOReadArticle*, class CSessionSocket *,	CDRIVERPTR&	pdriver,	CFileChannel&	pFileChannel, DWORD cbTransfer ) ;
	void	Shutdown(	CIODriver&	driver,	CSessionSocket*	pSocket,	SHUTDOWN_CAUSE	cause,	DWORD	dw ) ;
} ;


/*++
	@class	State which should perform logons to remote servers for outbound sessions

	@base public | CSessionState

	the CCollectNewnews represents a session in which we will isssue a newnews command to a
	NNTP Server.  We will use this state when pulling a feed from the other server.

--*/
class	CNNTPLogonToRemote	:	public	CSessionState	{
private :
	CSTATEPTR	m_pNext ;		// After successfull logon the next state we should enter !
	class	CAuthenticator*	m_pAuthenticator ;
	BOOL	m_fComplete ;
	BOOL	m_fLoggedOn ;
	long	m_cReadCompletes ;

	class	CIO*	FirstReadComplete(	class	CIOReadLine*,	class	CSessionSocket*,	CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs, char* pchBegin ) ;

	class	CIO*	StartAuthentication(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver	) ;

public :
	CNNTPLogonToRemote(	CSessionState*	pNext, class	CAuthenticator*	pAuthenticator ) ;
	~CNNTPLogonToRemote( ) ;

	BOOL	Start(	CSessionSocket*,	CDRIVERPTR&,	CIORead*&,	CIOWrite*& ) ;

	class	CIO*	Complete(	class	CIOReadLine*,	class	CSessionSocket*,	CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs, char* pchBegin ) ;
	class	CIO*	Complete( class CIOWriteLine*,	class	CSessionSocket *, CDRIVERPTR&	pdriver ) ;
} ;


/*++
	@class	Representing Socket which is issuing a Newnews command.

	@base public | CSessionState

	the CCollectNewnews represents a session in which we will isssue a newnews command to a
	NNTP Server.  We will use this state when pulling a feed from the other server.

--*/
class	CSetupPullFeed	: public	CSessionState	{
private:
	CSTATEPTR		m_pNext ;		// State to follow after collecting all groups

	//
	//	States must use consecutive integers !
	//
	enum	ESetupStates	{
		eModeReader	= 0,
		eDate,
		eFinal
	}	;

	ESetupStates	m_state ;

	CIOWriteLine*
	BuildNextWrite(	CSessionSocket*	pSocket,
					CDRIVERPTR&		pdriver
					) ;

public :

	//
	//	We must be initialized with the pointer to the following state !
	//	
	CSetupPullFeed(	
				CSessionState*	pNext 
				)	;

	//
	//	Start setup operations - issue mode reader and then date commands !
	//	
	BOOL	
	Start(		CSessionSocket*,	
				CDRIVERPTR&	pdriver,	
				CIORead*&,	
				CIOWrite*& 
				) ;

	//
	//	Complete the write of a line to the remote end !
	//
	class	CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

	//
	//	Complete the read of the response to the last command !
	//
	class	CIO*	
	Complete(	class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;
} ;




/*++
	@class	Representing Socket which is issuing a Newnews command.

	@base public | CSessionState

	the CCollectNewnews represents a session in which we will isssue a newnews command to a
	NNTP Server.  We will use this state when pulling a feed from the other server.

--*/
class	CCollectGroups : public	CSessionState	{
private:
	CSTATEPTR		m_pNext ;		// State to follow after collecting all groups
	BOOL			m_fReturnCode ;
	long			m_cCompletions ;
public :
	CCollectGroups(	CSessionState*	pNext )	;
	~CCollectGroups() ;
	
	BOOL	Start(	CSessionSocket*,	CDRIVERPTR&	pdriver,	CIORead*&,	CIOWrite*& ) ;
	class CIO*	Complete( class CIOWriteLine*,	class	CSessionSocket *, CDRIVERPTR&	pdriver ) ;
	class	CIO*	Complete(	class	CIOReadLine*,	class	CSessionSocket*,	CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs,	char*	pchBegin ) ;
} ;




class	CCollectComplete : 	public	CNntpComplete	{
private : 
	class	CCollectArticles*	GetContainer() ;
public : 
	//
	//	This function is called when we start our work !
	//
	void
	StartPost(	) ;
	//
	//	This function gets called when the post completes !
	//
	void
	Destroy() ;
} ;



//	@class	- Class representing a session in which we are issuing successive article <Msg-Id> commands
//
//	@base public | CSessionState
//
// The CBatchDownload state represents a session in which we are pulling articles
// from another server based on the results previously acquired through CCollectNewnews.
//
class   CCollectArticles : public CSessionState  {
private :

	//
	//	This completion class is our friend !
	//
	friend	class	CCollectComplete ;

	BOOL				m_fFinished ;		//	Set to TRUE when we pull the last article we're gonna pull !
	SHUTDOWN_CAUSE		m_FinishCause ;		//	Why we are finished - pass this to UnsafeClose() !!

	long				m_cResets ;			// Counter used to prevent multiple calls to Reset() during
											// termination of this state due to error... whatever.

	CSessionSocket*		m_pSocket ;			// There are some shutdown situations where we
											// get notified and don't know who our owning socket
											// is through the call chain.  Hence we save a reference here !


	CFILEPTR			m_pFileChannel ;	// A channel to read our temp file from.
	CDRIVERPTR			m_inputId ;			// A channel identifier
	CDRIVERPTR			m_pSessionDriver ;
	BOOL				m_fReadArticleIdSent ;	// Tell's us whether we've issued the
											// m_pReadArticleId we're holding on to.
											// If we have, then we shouldn't destroy it, cause
											// it will get destroyed by the CIODriver we issued it to !
	CIOReadLine*		m_pReadArticleId ;	// The Readline we issued to get the next article-id

	//
	//	The feed context that we exchange with PostEarly() and PostCommit()
	//
	LPVOID				m_lpvFeedContext ;

	CIOGetArticleEx*	m_pReadArticle ;
	BOOL				m_fReadArticleInit ;	// TRUE if m_pReadArticle's Init function has successfully been called !
	// (Once a CIOReadArticle has been inited successfully it is responsible for destroying itelf !!)

	HANDLE				m_hArticleFile ;

	long				m_cAhead ;
	char*				m_pchNextArticleId ;
	char*				m_pchEndNextArticleId ;

	int					m_cArticlesCollected ;

	long				m_cCompletes ;

	//
	//	The structure we use to keep track of async post operations into our store drivers !
	//
	CCollectComplete	m_PostComplete ;

	static	const	char	szArticle[] ;

	static	void	ShutdownNotification(	void	*pv,	SHUTDOWN_CAUSE	cause,	DWORD	dw ) ;
	void				Reset() ;			// Get rid of everything pointed to by members !
public :

	CCollectArticles(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,	
						CFileChannel&	pFileChannel 
						) ;
	~CCollectArticles() ;
	
	BOOL	Init(	CSessionSocket*	pSocket	) ;
	BOOL	GetNextArticle(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver ) ;

	//
	//	Do what it takes to get another article on its way to us !
	//
	BOOL	StartTransfer(	CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver, 
							CIOWriteLine* pWriteNextArticleId 
							) ;

	//
	//	Initiate all the IO's appropriate for this state !
	//
	BOOL	Start(	CSessionSocket*,	
					CDRIVERPTR&,	
					CIORead*&,	
					CIOWrite*& 
					) ;
	
	class	CIO*	
	Complete(	class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;
				
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;
	
//	void	Complete( class CIOReadArticle*, class CSessionSocket *,	CDRIVERPTR&	pdriver,	CFileChannel&	pFileChannel, DWORD cbTransfer ) ;

	//
	//	Handles the common cases for our CIOGetArticleEx completions !
	//
	void
	InternalComplete(	CSessionSocket*	pSocket,
						CDRIVERPTR&	pdriver
						) ;

	//
	//	This is the signature for a read that completes
	//	entirely in memory !
	//
	class	CIO*
	Complete(
				class		CIOGetArticleEx*,
				class		CSessionSocket*,
				//
				//	If fGoodMatch is TRUE then we matched the
				//	string we wanted to match - otherwise we 
				//	matched the error string !
				//
				BOOL		fGoodMatch,
				CBUFPTR&	pBuffer,
				DWORD		ibStart, 
				DWORD		cb
				) ;

	//
	//	This is the signature for a slurpy read where
	//	we just consume all the bytes off the socket !
	//
	class	CIO*
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*
				) ;

	//
	//	This is the completion that is called when we've 
	//	completed transferring an article to a file !
	//
	void
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) ;

	
	void	Shutdown(	CIODriver&	driver,	CSessionSocket*	pSocket,	SHUTDOWN_CAUSE	cause,	DWORD	dw ) ;
} ;


//	@class	CSessionState derived class which represents the state where we are waiting for
//	client issued commands.
//
//	@base public | CSessionState
//
// the CAceptNNRPD represents a session awaiting a clients NNRPD command.
// In this state we read a line of information from a client and parse
// the line to determine what command the client has issued.
// Depennding on the command issued we may handle the command directly while in this
// state, or put the session into a new state (ie. CAcceptArticle if the client posts)
// Whether we go into another state will depend on how difficult it will be to process
// the request.
//
class CAcceptNNRPD : public CSessionState {
private :

	//
	//	Counts the IO's that have completed - we always issue pairs of IO's 
	//
	long	m_cCompletes ;

	//
	//	Buffer containing the command line !
	//
	CBUFPTR	m_pbuffer ;			// A reference we keep to the buffer containing the command arguments !

	//
	//	Do we wish to generate a transaction log for the current command ?
	//
	BOOL	m_fDoTransactionLog ;

	//
	//
	//
	LPSTR	m_lpstrLogString ;

public :

	CAcceptNNRPD() ;

	//	
	//	This function will issue a CIOReadLine IO operation.  When this read completes
	//	we will attempt to parse the NNTP command the user has sent us.
	//
	BOOL	
	Start(	CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;

	//
	//	The only read's issued in this state are CIOReadLine's, in which we expect to get
	//	a buffer containing a single <CR><LF> terminated line containing an NNTP command.
	//
	class	CIO*	
	Complete(	class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;


	//
	//	Both CAsyncExecute and CAsync command objects will eventually
	//	be handled by this function upon their completion !
	//
	class CIO*	
	InternalComplete(	
				class CSessionSocket*, 
				CDRIVERPTR&	pdriver,	
				class	CExecutableCommand*	pCmd, 
				class CLogCollector* pCollector 
				) ;

	//
	//	Each CExecute derived command we execute is controlled by 
	//	a CIOWriteCMD object which calls this completion function
	//	when the entire command is completed !
	//
	class CIO*	
	Complete(	class CIOWriteCMD*, 
				class CSessionSocket*, 
				CDRIVERPTR&	pdriver,	
				class	CExecute*	pCmd, 
				class CLogCollector* pCollector 
				) ;

	//
	//	Each CAsyncExecute derived command we execute is controlled by 
	//	a CIOWriteAsyncCMD object which calls this completion function
	//	when the entire command is completed !
	//
	class CIO*	
	Complete(	class CIOWriteAsyncCMD*, 
				class CSessionSocket*, 
				CDRIVERPTR&	pdriver,	
				class	CAsyncExecute*	pCmd, 
				class CLogCollector* pCollector 
				) ;



	//
	//	The only write's issued will be short responses to commands.  If a command would require
	//	a large response, we would be in a different state (CExtendedCMD).
	//	We only have 1 write pending ever.
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

} ;



//-----------------------
//  Outgoing States - The following states occur only on sessions initiated by
//  this server.
//



class	CNegotiateStreaming	:	public	CSessionState	{
private :

	//
	//	Count the IO's we issue !	
	//
	long		m_cCompletions ;

	//
	//	When the read of the response completes we will set
	//	this to TRUE if streaming was negotiated !
	//
	BOOL		m_fStreaming ;

	//
	//	Start up the next state in a peer push feed !!!
	//
	BOOL		NextState(	
					CSessionSocket*	pSocket, 
					CDRIVERPTR&	pdriver, 
					CIORead*&	pRead, 
					CIOWrite*&	pWrite 
					) ;

public : 

	//
	//	Initialize ourselves - m_cCompletions must be -2 as we 
	//	will need to complete 2 IO's before we can move to the 
	//	next state !
	//
	CNegotiateStreaming( )	: 
		m_cCompletions( -2 ), m_fStreaming( FALSE ) {}

	//
	//	Issue our initial IO's !
	//
	BOOL	
	
	Start(	CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;

	//
	//	Complete reading a line - did the other side have 
	//	streaming support ? ? 
	//
	//
	class CIO*	
	Complete(	
				class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;

	//
	//	We write a line contianing 'mode stream' to find out 
	//	if the remote side supports streaming !
	//
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;



} ;


class	CStreamBase :	public	CSessionState	{
protected : 

	//
	//	Only derived classes should be able to create us 
	//
	CStreamBase() ;

	//
	//	ID of the article we've tried to send once already anyhow !
	//
	GROUPID		m_GroupIdRepeat ;
	ARTICLEID	m_ArticleIdRepeat ;

	//
	//	If this is true than all subsequent Remove requests will fail 
	//	as we have looped the queue.
	//
	BOOL		m_fDrain ;

	//
	//	Get an article from the queue.
	//	NOTE : this handles terminating feed loops
	//
	BOOL		
	Remove(	CNewsTree*	pTree,
			COutFeed*	pOutFeed,
			GROUPID&	groupId, 
			ARTICLEID&	articleId
			) ;

	//
	//	This queues an article to be sent again !
	//
	void
	ReSend(	COutFeed*	pOutFeed, 
			GROUPID		groupId, 
			ARTICLEID	articleId
			) ;

	//
	//
	//
	class	CIOWriteLine*
	BuildQuit(	CDRIVERPTR&	pdriver ) ;

	//
	//	Build the CIOTransmit object which sends the next article in the queue - 
	//	and handle the requeue issues if any failures occur !
	//
	CIOTransmit*
	NextTransmit(	GROUPID			GroupId, 
					ARTICLEID		ArticleId,
					CSessionSocket*	pSocket, 
					CDRIVERPTR&		pdriver,
					CTOCLIENTPTR&		pArticle
					) ;


} ;



//
//	This class manages the session when we are offering articles.
//	If at any point the remote end indicates it wants all of the
//	articles in a batch of 16 that we offer, we will send the
//	16 articles and then invoke the CStreamArticles state !
//
class	CCheckArticles :	public	CStreamBase	{
private : 


	//
	//	Are we completing Check commands !?
	//
	BOOL		m_fDoingChecks ;
	
	//
	//	List of articles we are checking if the remote site wants
	//
	CArticleRef	m_artrefCheck[16] ;

	//
	//	Number of check commands we fired off !
	//
	int			m_cChecks ;
	
	//
	//	Number of Check articles we have completed processing
	//
	int			m_iCurrentCheck ;

	//
	//	Article Refs of guys we are sending or about to send !
	//
	CArticleRef	m_artrefSend[16] ;

	//
	//	Number of articles we have sent !
	//
	int			m_cSends ;

	//
	//	The next slot we have for putting in a send request !
	//	
	int			m_iCurrentSend ;

	//
	//	The structure which represents all the check commands we have sent !
	//
	MultiLine	m_mlCheckCommands ;

	//
	//	The article we are currently transmitting !
	//
	CTOCLIENTPTR	m_pArticle ;

	BOOL
	FillCheckBuffer(	
						CNewsTree*	pTree,
						COutFeed*	pOutFeed, 
						BYTE*		lpb,
						DWORD		cb
						) ;

#if 0 
	CIOTransmit*
	NextTransmit(	GROUPID			groupId, 
					ARTICLEID		articleId,
					CSessionSocket*	pSocket, 
					CDRIVERPTR&		pdriver
					) ;
#endif

	int
	Match(	char*	szMessageId, 
			DWORD	cb 
			) ;

	CIOWrite*
	InternalStart(	CSessionSocket*	pSocket, 
					CDRIVERPTR&		pdriver
					) ;

	BOOL
	NextState(		CSessionSocket*	pSocket, 
					CDRIVERPTR&		pdriver, 
					CIORead*&		pRead, 
					CIOWrite*&		pWrite
					) ;

public : 

	//
	//	This constructor puts us into a state where 
	//	we will issue a bunch of check commands first !
	//
	CCheckArticles() ;

	//
	//	This constructor puts us into a state where 
	//	we will pick up a specified number of takethis 
	//	command responses !
	//
	CCheckArticles(	CArticleRef*	pArticleRefs, 
					DWORD			cSent ) ;
	

	//
	//	Issue our initial IO's 
	//
	BOOL	
	Start(	CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;

	//
	//	Start sending those articles the remote 
	//	site decided it wanted to get !
	//
	BOOL	
	StartTransfer(	
			CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;


	//
	//	collect up all of the 'check' responses
	//
	class CIO*	
	Complete(	
				class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;

	//
	//	Complete the sending of a whole bunch of check commands !
	//
	class CIO*	
	Complete(	class CIOMLWrite*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

	//
	//	Completes the sending of a 'quit' command !
	//
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;

	//
	//	Completes the transfer of an article to the remote server 
	//
	class CIO*	
	Complete(	CIOTransmit*	ptransmit,	
				CSessionSocket*	pSocket,	
				CDRIVERPTR&	pdriver,
				TRANSMIT_FILE_BUFFERS*	pbuffers, 
				unsigned cbBytes = 0 
				) ;

	//
	//	Cleans up any state we may have when our session is terminated
	//
	void	
	Shutdown(	CIODriver&	driver,	
				CSessionSocket*	pSocket,	
				SHUTDOWN_CAUSE	cause,	
				DWORD	dw 
				) ;

} ;



class	CStreamArticles :	public	CStreamBase	{
private : 

	//
	//	This constructor is private cause we don't want anybody
	//	using it !
	//
	CStreamArticles() ;

	//
	//	Article Refs of guys we are sending or about to send !
	//
	CArticleRef	m_artrefSend[16] ;

	//
	//	Number of articles we have sent !
	//
	int			m_cSends ;

	//
	//	Count the number of times the remote side failed 
	//	a 'takethis' command - if it becomes excessive 
	//	we will go back to the CCheckArticles state !
	//
	int			m_cFailedTransfers ;

	//
	//	Number of Consecutive failures
	//
	int			m_cConsecutiveFails ;

	//
	//	Total number of articles sent !
	//	
	int			m_TotalSends ;

	//
	//	The article currently being transmitted !
	//
	CTOCLIENTPTR	m_pArticle ;

	//
	//	Get the next article to transmit 
	//
	CIOTransmit*
	CStreamArticles::Next(	CSessionSocket*	pSocket, 
							CDRIVERPTR&		pdriver
							)  ;

	//
	//	Get next file to transmit 
	//
	CIOTransmit*
	CStreamArticles::NextTransmit(	GROUPID	groupid, 
									ARTICLEID	articleid, 
									CSessionSocket*	pSocket, 
									CDRIVERPTR&		pdriver
									) ;

public : 

	CStreamArticles(	CArticleRef*	pSent, 
						DWORD			nSent	) ;

	//
	//	Issue our initial IO's 
	//
	BOOL	
	Start(	CSessionSocket*,	
			CDRIVERPTR&,	
			CIORead*&,	
			CIOWrite*& 
			) ;


	//
	//	Read the response to a 'takethis' command 
	//
	class CIO*	
	Complete(	
				class	CIOReadLine*,	
				class	CSessionSocket*,	
				CDRIVERPTR&	pdriver,
				int	cArgs,	
				char	**pszArgs,	
				char*	pchBegin 
				) ;

	//
	//	Transmit a file to the remote side !
	//
	class CIO*	
	Complete(	CIOTransmit*	ptransmit,	
				CSessionSocket*	pSocket,	
				CDRIVERPTR&	pdriver,
				TRANSMIT_FILE_BUFFERS*	pbuffers, 
				unsigned cbBytes = 0 
				) ;

	//
	//	Completes the sending of a 'quit' command !
	//
	class CIO*	
	Complete(	class CIOWriteLine*,	
				class	CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;



	void
	Shutdown(	CIODriver&	driver,
				CSessionSocket*	pSocket,
				SHUTDOWN_CAUSE	cause,
				DWORD	dw 
				) ;

} ;


	


//	@class	The COfferArticles class is used when we have a COutFeed object and we
//	wish to send articles to another server.
//
//	@base public | CSessionState
//
//	In this state, we may issue, Post, IHave or XREPLIC commands depending on the
//	outgoing Feed Object.
//
class   COfferArticles : public CSessionState   {
private :
	static	char		szQuit[] ;

	//
	//	We usually have 2 IO's pending - when they're both complete
	//	its time to cycle to the next article in the queue
	//
	long				m_cCompletions ;

	//
	//	Are we ready to send the next command !
	//
	long				m_cTransmitCompletions ;

	//
	//	Are we terminating because we have nothing more to send ? 
	//
	BOOL				m_fTerminating ;

	//
	//	The next read that completes - is it the response to a 'post' command
	//	or the result of a 'post' command ?
	//
	BOOL				m_fReadPostResult ;

	//
	//	Set to TRUE if we should send the next article in our queue.
	//
	BOOL				m_fDoTransmit ;

	//
	//	Identify the guy that we want to send ntext !
	//
	GROUPID				m_GroupidNext ;
	ARTICLEID			m_ArticleidNext ;
	CTOCLIENTPTR		m_pArticleNext ;

	CTOCLIENTPTR		m_pCurrentArticle ;

	//
	//	Identify the first guy that the other end tolds us to 
	//	retransmit.  We will kill the session when we pull this 
	//	off the queue so that we do retransmits on a new session !
	//
	GROUPID				m_GroupidTriedOnce ;
	ARTICLEID			m_ArticleidTriedOnce ;

	//
	//	Identify the guy who is currently being sent to the remote end
	//	so if the session drops while we're sending, we can retransmit !
	//
	GROUPID				m_GroupidInProgress ;
	ARTICLEID			m_ArticleidInProgress ;

	int				GetNextCommand(	
						CNewsTree*	pTree,
						COutFeed*	pOutFeed,	
						BYTE*	pb,	
						DWORD	cb,	
						DWORD&	ibOffset 
						) ;

	CIOTransmit*	BuildTransmit(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver,	GROUPID	groupid,	ARTICLEID	artid ) ;
	CIOWriteLine*	BuildWriteLine(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver,	GROUPID	groupid,	ARTICLEID	artid ) ;
	CIO*			Complete(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver ) ;

public :

	COfferArticles(	) ;

	BOOL	Start(	CSessionSocket*,	CDRIVERPTR&,	CIORead*&,	CIOWrite*& ) ;
	class	CIO*	Complete(	class	CIOReadLine*,	class	CSessionSocket*,	CDRIVERPTR&	pdriver,
						int	cArgs,	char	**pszArgs,	char*	pchBegin ) ;
	class	CIO*	Complete( class CIOWriteLine*,	class	CSessionSocket *, CDRIVERPTR&	pdriver ) ;
	class	CIO*	Complete( CIOTransmit*	ptransmit,	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver,
						TRANSMIT_FILE_BUFFERS*	pbuffers, unsigned cbBytes = 0 ) ;
	void	Shutdown(	CIODriver&	driver,	CSessionSocket*	pSocket,	SHUTDOWN_CAUSE	cause,	DWORD	dw ) ;
} ;



//
// MAX_STATE_SIZE constant -
//
// This constant represents the maximum size of all of the CSessionState derived classes.
// This will be used with the CPool allocator to allocate CSessionState objects.
//
#define MAX_STATE_SIZE  max( sizeof( CSessionState ),	\
                        max( sizeof( CNNTPLogonToRemote ),	\
                        max( sizeof( CAcceptNNRPD ),	\
                        max( sizeof( CCollectGroups ),	\
                        max( sizeof( CCollectArticles ),	\
                        max( sizeof( COfferArticles ) ,	\
                        max( sizeof( CCheckArticles ) ,	\
                        max( sizeof( CStreamArticles ) ,	\
							 sizeof( CCollectNewnews ) ) ) ) ) ) ) ) )

extern	const	unsigned	cbMAX_STATE_SIZE ;



//--------- Socket Session Classes ---------------------------------------------

//
// The following classes represent a session that we control over a socket.
// There is a base class which contains static data which is generated during
// initialization.  There are two derived classes - one representing live sessions
// and another representing listens on a particular port.
//


//
// The ClientContext structure holds everything that we need to pass between states
// regarding a session.
//
struct  ClientContext   {

	//
	//	ptr to owning virtual server instance
	//
	PNNTP_SERVER_INSTANCE	m_pInstance ;

	//
	//	Did the client connect on a secure (SSL) port ?
	//
	BOOL				m_IsSecureConnection ;

	//
	//	The CInFeed derived objects for processing incoming articles - 
	//	This may be NULL if this is used with an outbound feed
	//
	CInFeed*			m_pInFeed ;

	//
	//	The outgoing feed object - this object will maintain a queue
	//	of articles which we are sending to the remote server
	//
	COutFeed*			m_pOutFeed ;

	//
	//	The currently selected group for the session - 
	//	this is set through the GROUP command
	//
	CGRPPTR             m_pCurrentGroup ; 
	
	//
	//	The 'Current Article pointer' this is advanced 
	//	and set through commands like next and last.
	//
	ARTICLEID			m_idCurrentArticle ;

	//
	//	The logong context of the current user
	//
    CSecurityCtx        m_securityCtx;
	
	//
	//	If we are doing any SSL/PCT stuff the CEncryptCtx
	//	maintains all of the sessions encryption key and SSPI stuff.
	//
	CEncryptCtx			m_encryptCtx;

	//
	//	This is where we will stuff return strings that we 
	//	send to clients when doing command processing.
	//
	CNntpReturn			m_return ;

	//
	//	The results of the last command !
	//
	NRC					m_nrcLast ;

	//
	//	The Win32 error code from the last command !
	//
	DWORD				m_dwLast ;

	//
	//	This is a buffer we use to build CCmd objects in place.
	//	Since there can only be one command in progress at a time
	//	we build them in place here to avoid memory alloc/frees
	//
	BYTE				m_rgbCommandBuff[348] ;	

	ClientContext( PNNTP_SERVER_INSTANCE pInstance, BOOL IsClient = FALSE, BOOL	IsSecurePort = FALSE ) ;
	~ClientContext() ;

	//
	// called when a user is authenticated to increment the relevant
	// perfmon and snmp statistic counters
	//
	void	IncrementUserStats( void );

	//
	// called when a user disconnects or starts an authentication session
	// to decrement the relevant perfmon and snmp statistic counters
	//
	void	DecrementUserStats( void );
} ;




//	Forward Declarations
class   CSocketList ;
class	CSessionSocket ;



//
//	CSessionSocket objects represent a live session to another server
//	or with a client.
//
class CSessionSocket : public CRefCount {
//
// CSessionSocket represents a live session to a client or server.
//	We keep these in a doubly linked list managed by a static CSocketList object.
//
private :

    //
    //  We will keep all CSessionSocket objects in a linked list
    //  so that we can easily enumerate all sessions.
    //
	static	CPool	gSocketAllocator ;

	//
	//	CSocketList is a friend so it can use our m_pNext and m_pPrev pointers
	//
	friend	class	CSocketList ;

	//
	//	TerminateGlobals() is a friend so it can look into our CPool during shutdown etc..
	//
	friend	VOID    TerminateGlobals();	

	//
	//	Next and Prev pointers - all CSessionSockets are in a doubly linked
	//	list while active.
	//
    CSessionSocket* m_pPrev ;
    CSessionSocket* m_pNext ;

	friend class	CIO ;

	//
	//	The following set of variables is used when forcing off sessions
	//	We want to allow only one call to Disconnect(), and then to 
	//	save the arguments so that we can figure out later why we disconnect'd
	//
	long			m_cCallDisconnect ;
	long			m_cTryDisconnect ;
	SHUTDOWN_CAUSE	m_causeDisconnect ;
	DWORD			m_dwErrorDisconnect ;

public :

	//
	//	The m_pHandleChannel points to the object which actually issues
	//	the reads and writes to Atq
	//
#ifdef	FILEIO
	CIOFileChannel	*m_pHandleChannel ;
#else
	CSocketChannel	*m_pHandleChannel ;
#endif

	//
	//	The m_pSink is the object which maintains the current state and
	//	manages all of our async IO.
	//
	CIODriverSink	*m_pSink ;

	//
	//	This function is called when every IO etc... associated with
	//	a socket has been destroyed - at this point we can release the
	//	CSessionSocket object.
	//
	static	void	ShutdownNotification( void*	pv,	SHUTDOWN_CAUSE	cause,	DWORD	dwOptional ) ;	

    //
    // time connection made
    //

    FILETIME   m_startTime;

    //
    // ip address of remote host
    //

    DWORD m_remoteIpAddress;

    //
    // IP address of the local host (us)
    //

    DWORD m_localIpAddress;

    //
    // NNTP Port used
    //
    DWORD m_nntpPort;

	//
	//	If the session timeouts, should we send a 502 Timeout message ? 
	//
	BOOL	m_fSendTimeout ;

	//
	//	All the clients 'state' info - current group article etc...
	//
	ClientContext	m_context ;

	//
	//	IP access check
	//

	METADATA_REF_HANDLER	m_rfAccessCheck; 
    ADDRESS_CHECK   		m_acAccessCheck;

	//
	//	The following functions are wrapped by Accept(), and 2 forms of ConnectSocket().
	//
	//	AcceptInternal() starts the state machine into the client processing state machine. (CAcceptNNRPD)
	//
	BOOL	AcceptInternal( HANDLE h, CInFeed*	pFeed, sockaddr_in *paddr, void* patqContext, BOOL	fSSL,	CSINKPTR&	pSink ) ;	
	//
	//	This ConnectSocketInternal() starts the state machine into the correct state for
	//	pull feeds.  This can be either CNNTPLogonToRemote, CCollectNewnews or CCollectGroups
	//	depedning on Feed settings.
	//
	BOOL	ConnectSocketInternal( sockaddr_in    *premote, CInFeed *infeed, CDRIVERPTR&	pSink, class	CAuthenticator*	pAuthenticator ) ;
	//
	//	This ConnectSocketInternal() starts the state machine into the correct state for 
	//	push feeds.  This can be either CNNTPLogonToRemote or COfferArticles depending on feed settings.
	//
	BOOL	ConnectSocketInternal( sockaddr_in    *premote, COutFeed *outfeed, CDRIVERPTR&	pSink, class	CAuthenticator*	pAuthenticator ) ;
	
	//
	//	Adjust perfmon counters.
	//
	void	BumpCountersUp() ;
	void	BumpCountersDown() ;
	void    BumpSSLConnectionCounter();

public :

	//
	//	This object is used to build up strings for Transaction Logging.
	//	Because for some commands we want all the arguments, whereas others we want a 
	//	mix of commands and response codes or even other stuff, Transaction Logging
	//	is not straight forward.	The m_Collector object holds an internal buffer
	//	we will use to catenate the transaction log strings.
	//
	CLogCollector	m_Collector ;


    //
    //  Class Initializer must be called absolutely first !
    //  Class Initializer will set up ATQ,
    //
    static  BOOL    InitClass( ) ;
	static	BOOL	TermClass( ) ;

	//
	//	Allocate and Free using are CPool.
	//
	inline	void*	operator	new( size_t	size ) ;
	inline	void	operator	delete( void*	pv ) ;

    //
    // Constructor/Destructor
    //

	CSessionSocket( PNNTP_SERVER_INSTANCE pInstance, DWORD LocalIP, DWORD Port, BOOL IsClient = FALSE ) ;
	~CSessionSocket() ;

    //--------------------------------------------------
    //  There are two mechanisms for creating a socket :
    //  Either accept an incoming call - in which case we will
    //  have to log the user on and then determine all the relevant
    //  state information - or initiate a socket for an outgoing feed.
    //
    //  Initialize a socket which on which we have recently completed an accept().
    //
	BOOL	Accept( HANDLE h, CInFeed*	pFeed, sockaddr_in *paddr, void* patqContext, BOOL	fSSL ) ;	

    //
    //  Start a socket connecting to a remote site to do some kind of feed.
	//	We will set the correct initial state (C
    //
    BOOL    ConnectSocket( sockaddr_in    *premote, class  COutFeed*,	class	CAuthenticator*	pAuthenticator = 0 ) ;

	//
	//	This version of ConnectSocket is used when we want start a socket for a PULL feed.
	//
	BOOL	ConnectSocket( sockaddr_in    *premote, CInFeed *inFeed, class	CAuthenticator*	pAuthenticator = 0  ) ;

    //
    // Write into transaction log
    //

    BOOL TransactionLog(	CLogCollector*	pCollector,	
							DWORD			dwProtocol = 0, 
							DWORD			dwWin32 = 0,
							BOOL fInBound = TRUE
							);

	//
	//	Another variation of TransactionLogging 
	//
	BOOL TransactionLog(	LPSTR	lpstrOperation,
							LPSTR	lpstrTarget,
							LPSTR	lpstrParameters,
							STRMPOSITION cbBytesSent,
							DWORD	cbBytesRecvd,
							DWORD	dwProtocol = 0, 
							DWORD	dwWin32 = 0,
							BOOL	fInBound = TRUE
							) ;

	//
	//	Variation of TransactionLogging without BytesSent/Recvd
	//
	BOOL TransactionLog(	LPSTR	lpstrOperation,
							LPSTR	lpstrTarget,
							LPSTR	lpstrParameters 
							);

    //
    // Check that the CSessionSocket object is Valid
    //
    BOOL    IsValid( ) ;

    //
    //  Blow off this session for whatever reason (we don't like user, or time out etc...)
    //
    void    Disconnect( SHUTDOWN_CAUSE = CAUSE_LEGIT_CLOSE,	DWORD	dwError = 0 ) ;

    //
    //  Get rid of Socket during server shutdown.
    //
    void    Terminate( void ) ;

    //
    // Get user name
    //

    LPSTR GetUserName( ) { return m_context.m_securityCtx.QueryUserName(); };

    //
    // get client ip address
    //

    DWORD GetClientIP( ) { return m_remoteIpAddress; };

    //
    // get port connected to
    //

    DWORD GetIncomingPort( ) { return m_nntpPort; };

    //
    // Get session start time
    //

    VOID GetStartTime( PFILETIME ft ) { *ft = m_startTime; };

	//
	//	Get a name for the remote end of the connection that we can use for event logs !
	//

	LPSTR	GetRemoteNameString() ;

	//
	//	Get a string we can use for event logs to specify the type of the session
	//

	LPSTR	GetRemoteTypeString() ;

    //
    // Enumerate Sessions
    //

    static DWORD EnumerateSessions( IN  PNNTP_SERVER_INSTANCE pInstance, LPNNTP_SESS_ENUM_STRUCT Buffer );

    //
    // Terminate Session
    //

    static DWORD TerminateSession(
						IN  PNNTP_SERVER_INSTANCE pInstance,
                        IN LPSTR UserName,
                        IN LPSTR IPAddress
                        );

    ADDRESS_CHECK*  QueryAccessCheck() { return &m_acAccessCheck; }
	BOOL  BindInstanceAccessCheck();
	VOID  UnbindInstanceAccessCheck();
} ;

#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CSessionSocket ) 

#endif

typedef BOOL
(*ENUMSOCKET)(
    CSessionSocket* pSocket,
    DWORD dwParam,
    PVOID pParam
    );

//+---------------------------------------------------------------
//
//  Class:      CUserList
//
//  Synopsis:   Doubly linked list of currently active users
//
//  History:    gordm       Created         10 May 1995
//
//----------------------------------------------------------------
class CSocketList
{
    public:
        CSocketList() : m_pListHead( NULL ), m_cCount( 0 )
        {
            InitializeCriticalSection( &m_critSec );
        }

        ~CSocketList()
        {
            DeleteCriticalSection( &m_critSec );
        }

        inline void InsertSocket( CSessionSocket* pSocket );
        inline void RemoveSocket( CSessionSocket* pSocket );
        BOOL EnumClientSess(
                ENUMSOCKET pEnumSessFunc,
                DWORD dwParam1,
                PVOID pParam
                );
        BOOL EnumAllSess(
                ENUMSOCKET pEnumSessFunc,
                DWORD dwParam1,
                PVOID pParam
                );


    private:
        CRITICAL_SECTION    m_critSec;
        CSessionSocket*     m_pListHead;
        int                 m_cCount;

    public:
        DWORD   GetContentionCount()
                { return    m_critSec.DebugInfo->ContentionCount; }

        DWORD   GetEntryCount()
                { return    m_critSec.DebugInfo->EntryCount; }

        BOOL    IsEmpty()
                { return    m_pListHead == NULL; }

        //
        // debug only - cannot use to enum or check status of list
        //
        DWORD   GetListCount()
                { return    m_cCount; }

        friend class CSessionSocket ;
};

#include	"session.inl"

#endif	// _SESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\sslmsgs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sslmsgs.h

Abstract:

    Contains declarations from the ssl package

Author:

    Johnson Apacible (JohnsonA)     12-Sept-1995

Revision History:

--*/

#ifndef	_SSLMSGS_H_
#define	_SSLMSGS_H_

#define SSL_MAC_LENGTH              16

typedef struct _Ssl_Record_Header {
    UCHAR   Byte0;
    UCHAR   Byte1;
} Ssl_Record_Header, * PSsl_Record_Header;

typedef struct _Ssl_Record_Header_Ex {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} Ssl_Record_Header_Ex, * PSsl_Record_Header_Ex;

typedef struct _Ssl_Message_Header {
    Ssl_Record_Header   Header;
    UCHAR               MacData[ SSL_MAC_LENGTH ];
} Ssl_Message_Header, * PSsl_Message_Header;

typedef struct _Ssl_Message_Header_Ex {
    Ssl_Record_Header_Ex    Header;
    UCHAR                   MacData[ SSL_MAC_LENGTH ];
} Ssl_Message_Header_Ex, * PSsl_Message_Header_Ex;

//
// SSL macros
//

#define COMBINEBYTES(Msb, Lsb)  \
            ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))

#define SIZEOF_MSG(pMessage)    \
            (SslRecordSize((PSsl_Record_Header) pMessage ) )


DWORD
SslRecordSize(
    PSsl_Record_Header  pHeader
    );

//
// PCT stuff
//

typedef struct _Pct_Record_Header {
    UCHAR   Byte0;
    UCHAR   Byte1;
} Pct_Record_Header, * PPct_Record_Header;

typedef struct _Pct_Record_Header_Ex {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} Pct_Record_Header_Ex, * PPct_Record_Header_Ex;

#endif  // _SSLMSGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\smtpdll.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smtpdll.cpp

Abstract:

	Implementation of the fPost interface

Author:

    Rajeev Rajan (RajeevR)     17-May-1996

Revision History:

--*/

#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

// local includes
#include "tigris.hxx"

#include <windows.h>
#include <stdio.h>
#include "smtpdll.h"
#include "smtpcli.h"

#define MAX_CLIENTPOOL_SIZE		5

// globals
CSmtpClientPool		g_SCPool;                       // pool of persistent connections
BOOL                g_fInitialized;                 // TRUE if provider layer is initialized
LONG				g_dwPickupFileId;				// starting id of pickup file
CRITICAL_SECTION	g_csIdLock;						// sync access to global id

#define LOCK_ID()	EnterCriticalSection(&g_csIdLock);
#define UNLOCK_ID()	LeaveCriticalSection(&g_csIdLock);

BOOL InitModeratedProvider()
/*++

Routine Description : 

	Initialize the mail interface for article posted to a moderated
	newsgroup. Initialize a pool of CSmtpClient objects. Each such 
	object has a persistent connection to the SMTP server. Requests
	to mail articles are made to the fPostArticle entry-point. When
	such a request is made, an object is taken from this pool and used
	to mail out the article. (If a connection is lost, it is
	re-established while sending the HELO command).

Arguments : 


Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
	TraceFunctEnter("Init");

	if(!g_SCPool.AllocPool(MAX_CLIENTPOOL_SIZE))
	{
		ErrorTrace(0, "Failed to allocate client pool");
        g_fInitialized = FALSE;
		return FALSE;
	}

    g_fInitialized = TRUE;
	g_dwPickupFileId = 0;

	InitializeCriticalSection(&g_csIdLock);

	return TRUE;
}

BOOL TerminateModeratedProvider()
/*++

Routine Description : 

	Cleanup the mail interface for moderated newsgroups

Arguments : 

	None

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
    if(g_fInitialized)
    {
	    // release all the pool objects
	    g_SCPool.FreePool();
    }

	DeleteCriticalSection(&g_csIdLock);

	return TRUE;
}

VOID SignalSmtpServerChange()
/*++

Routine Description : 

	Signal a change in the Smtp server

Arguments : 

	None

Return Value : 
	VOID

--*/
{
    g_SCPool.MarkDirty();
}

// Post an article to the moderator
BOOL fPostArticleEx(
		IN HANDLE	hFile,
        IN LPSTR	lpFileName,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpTempDirectory,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		)
/*++

Routine Description : 

	Send the article to an SMTP server via mail interface OR
	Create a file in the SMTP pickup directory

Arguments : 

	IN HANDLE	hFile			:	handle of file	
	IN LPSTR    lpFileName		:	file name
	IN DWORD	dwOffset		:	offset of article within file
	IN DWORD	dwLength		:	length of article
	IN char*	pchHead			:	pointer to article headers
	IN DWORD	cbHead			:	number of header bytes
	IN char*	pchBody			:	pointer to article body
	IN DWORD	cbBody			:	number of bytes in body
	IN LPSTR	lpModerator		:	moderator 
	IN LPSTR	lpSmtpAddress	:	SMTP server
	IN DWORD	cbAddressSize	:	sizeof server
	IN LPSTR	lpTempDirectory	:	temp dir for smtp pickup
	IN LPSTR	lpFrom			:	from header for mail envelope
	IN DWORD	cbFrom			:	length of from header

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/

{
	BOOL  fUseSmtpPickup = FALSE;
	LPSTR lpSmtpPickupPath;             // UNC name of SMTP pickup path
	DWORD dwTrailLen = 3;

	TraceFunctEnter( "fPostArticle" ) ;

	_ASSERT( lpSmtpAddress && cbAddressSize > 0 );
	_ASSERT( lpTempDirectory );
	_ASSERT( lpModerator );

	// If there exists a '\' in szSmtpAddress this is a pickup dir
    if( strchr((LPCTSTR)lpSmtpAddress, '\\') )
    {
        // This is the UNC path of an SMTP server pickup directory
        fUseSmtpPickup = TRUE;
        lpSmtpPickupPath = lpSmtpAddress;
	}

	//
	//	SMTP pickup - drop a file in a dir and ISBUs SMTP server will pick it up
	//
	if( fUseSmtpPickup )
	{
		// get a unique id to construct a filename
		LOCK_ID();
		LONG dwPickupFileId = ++g_dwPickupFileId;
		UNLOCK_ID();

		// create a file to be picked up; generate a filename based on unique id, thread id etc
		char	szFile[ MAX_PATH+1 ] ;
		char	szPickupFile[ MAX_PATH+1 ] ;

		// we will copy later. check length here.
		if (strlen(lpModerator) > MAX_MODERATOR_NAME)
		{
			ErrorTrace(NULL,"Invalid moderator name");
			return FALSE;			
		}

		// temp file - this will be moved to the pickup dir eventually
		int cbCopied = _snprintf(szFile, sizeof(szFile)-1, "%s\\%dP%dT%dC%d.mod", lpTempDirectory, dwPickupFileId, GetCurrentProcessId(), GetCurrentThreadId(), GetTickCount() ) ; 
		szFile[sizeof(szFile)-1] = '\0';
		if (cbCopied < 0)
		{
			//Overflow
			ErrorTrace(NULL,"Invalid filename");
			return FALSE;
		}

		// final pickup filename
		cbCopied = _snprintf(szPickupFile, sizeof(szPickupFile)-1, "%s%s", lpSmtpPickupPath, szFile + lstrlen( lpTempDirectory ));
		szPickupFile[sizeof(szPickupFile)-1] = '\0';

		if (cbCopied < 0)
		{
			//Overflow
			ErrorTrace(NULL,"Invalid filename");
			return FALSE;
		}


		DWORD	dwError = ERROR_SUCCESS ;
		BOOL	fSuccess = FALSE ;

		// Create a new temp file
		HANDLE	hPickupFile = CreateFile(	szFile, 
											GENERIC_READ | GENERIC_WRITE,
											0,	// No sharing of the file !!
											0, 	
											CREATE_NEW, 
											FILE_ATTRIBUTE_NORMAL,
											INVALID_HANDLE_VALUE
											) ;

		if(INVALID_HANDLE_VALUE == hPickupFile)
		{
			ErrorTrace(NULL,"Could not create file %s: GetLastError is %d", szFile, GetLastError());
			return FALSE;
		}

		//  WriteFile() the To: header
		DWORD	cbWritten = 0 ;	
		fSuccess = TRUE ;
			
		char szToHeader [MAX_MODERATOR_NAME+6+1];
		int cbBytes = wsprintf(szToHeader, "To: %s\r\n", lpModerator);
		fSuccess &= WriteFile(	hPickupFile, szToHeader, cbBytes, &cbWritten, 0 ) ;

		if( !fSuccess ) {
			_VERIFY( CloseHandle( hPickupFile ) );
			DeleteFile( szFile ) ;
			return FALSE;
		}

		// The article is either in a file or in a memory buffer
		if( hFile != INVALID_HANDLE_VALUE )
		{
			// Article data is in file - create file mapping and WriteFile() to pickup file
			CMapFile* pMapFile = XNEW CMapFile(lpFileName, hFile, FALSE, 0 );

			// map the file
			if (!pMapFile || !pMapFile->fGood())
			{
				_VERIFY( CloseHandle( hPickupFile ) );
				DeleteFile( szFile ) ;
				
				if( pMapFile ) {
					XDELETE pMapFile;
					pMapFile = NULL;
				}
				
				ErrorTrace(NULL,"Error mapping file %s GetLastError is %d", lpFileName, GetLastError());
				return FALSE;
			}

			DWORD cbArticle = 0;
			char* pchArticle = (char*)pMapFile->pvAddress( &cbArticle );
			pchArticle += dwOffset;

			// total file size should be equal to sum of initial gap + article length
			_ASSERT( cbArticle == (dwOffset + dwLength));

			// WriteFile() from the file mapping
			// Strip the trailing .CRLF so POP3 likes this message
			if( pchArticle != 0 ) {
				_ASSERT( pchArticle != 0 ) ;
				fSuccess &= WriteFile(	hPickupFile, pchArticle, dwLength-dwTrailLen, &cbWritten, 0 ) ;
			}

			if( !fSuccess ) {
				dwError = GetLastError() ;
				ErrorTrace(NULL,"Error writing to smtp pickup file: GetLastError is %d", dwError);
			}

			_VERIFY( CloseHandle( hPickupFile ) );
			
			if( pMapFile ) {
				XDELETE pMapFile;
				pMapFile = NULL;
			}

			if( !fSuccess ) {
				DeleteFile( szFile ) ;
				return FALSE;
			}
		}
		else
		{
			_ASSERT( hFile == INVALID_HANDLE_VALUE );

			// Article data is in memory buffers - just WriteFile() to the pickup file
			if( pchHead != 0 ) {
				_ASSERT( cbHead != 0 ) ;
				if( pchBody != 0 ) {
					dwTrailLen = 0;
				}
				fSuccess &= WriteFile(	hPickupFile, pchHead, cbHead-dwTrailLen, &cbWritten, 0 ) ;
			}
			if( fSuccess && pchBody != 0 ) {
				_ASSERT( cbBody != 0 ) ;
				fSuccess &= WriteFile(	hPickupFile, pchBody, cbBody-3, &cbWritten, 0 ) ;
			}

			if( !fSuccess ) {
				dwError = GetLastError() ;
				ErrorTrace(NULL,"Error writing to smtp pickup file: GetLastError is %d", dwError);
			}

			_VERIFY( CloseHandle( hPickupFile ) );

			if( !fSuccess ) {
				DeleteFile( szFile ) ;
				return FALSE;
			}
		}

		// Now move the file from the temp dir to the smtp pickup dir
		// NOTE: For the SMTP pickup feature to work, we need to create the file in a temp
		// directory and then do an atomic MoveFile to the pickup directory
		if(!MoveFile( szFile, szPickupFile ))
		{
			ErrorTrace(NULL,"SMTP pickup: Error moving file %s to %s: GetLastError is %d", szFile, szPickupFile, GetLastError() );
			return FALSE;
		}

		//if( pSecurity )	{
		//	pSecurity->RevertToSelf() ;
		//}
	}
	else
	{
		// send over persistent connection interface
		return fPostArticle(
					hFile,
					dwOffset,
					dwLength,
					pchHead,
					cbHead,
					pchBody,
					cbBody,
					lpModerator,
					lpSmtpAddress,
					cbAddressSize,
					lpFrom,
					cbFrom
					);
	}

	return TRUE;
}


BOOL fPostArticle(
		IN HANDLE	hFile,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		)
/*++

Routine Description : 

	Send the article to an SMTP server to be delivered to the moderator.

	Obtain a CSmtpClient object from the global pool. In the best case,
	this object already has a connection to the SMTP server. Use this to
	mail the article. If the connection is broken, re-establish the 
	connection while doing the HELO command.

	NOTE: The article contents are either in a memory buffer or in a file
	If hFile != NULL, use TransmitFile to send it else use regular sends()

Arguments : 

	IN HANDLE	hFile			:	handle of file	
	IN DWORD	dwOffset		:	offset of article within file
	IN DWORD	dwLength		:	length of article
	IN char*	pchHead			:	pointer to article headers
	IN DWORD	cbHead			:	number of header bytes
	IN char*	pchBody			:	pointer to article body
	IN DWORD	cbBody			:	number of bytes in body
	IN LPSTR	lpModerator		:	moderator 
	IN LPSTR	lpSmtpAddress	:	SMTP server
	IN DWORD	cbAddressSize	:	sizeof server
	IN LPSTR	lpFrom			:	from header of mail envelope
	IN DWORD	cbFrom			:	length of from header

Return Value : 
	TRUE if successful - FALSE otherwise !

--*/
{
    // used only if the pool is used up
    CSmtpClient SCNew(g_SCPool.GetCachedComputerName());
    CSmtpClient* pSC;
    BOOL fRet = TRUE;
    BOOL fDone = FALSE;

	TraceFunctEnter("fPostArticle");

    // check to see that the provider is initialized
    if(!g_fInitialized)
    {
        ErrorTrace(0,"Provider not initialized");
        return FALSE;
    }

    _ASSERT(lpModerator);

	// get a client object from pool; allocate a new one if none is 
	// available in the pool.
	DWORD dwIndex;
	CSmtpClient* pSCpool = g_SCPool.AcquireSmtpClient(dwIndex);
	if(!pSCpool)
	{
        // use the local object on the stack
        // NOTE: this is used only if we run out of pool objects
	    SCNew.SetClientState(sInitialized);
        pSC = &SCNew;
	}
    else
    {
        // Use the pool object
        // NOTE: using a pool object is FAST because it is pre-connected
        // If the rate of requests to mail an article is high, we may run
        // out of pool objects. In this case, a local object is used.
        pSC = pSCpool;
    }

    //
    // If this object is not initialized, init it ie. connect() to server
    // and receive greeting. Once connected, the object will maintain the
    // connection, so the next time we avoid having to connect().
    //
    // If the SMTP server changes, we have to re-connect to the new server
    // pSC is checked to see if it is dirty ie. SMTP server has changed
    //
    if(!pSC->IsInitialized() || pSC->IsDirty())
    {
        // If dirty, close the connection and re-connect
        if(pSC->IsDirty())
        {
            if(pSC->IsInitialized())
                pSC->Terminate(TRUE);

            pSC->MarkClean();
        }

		// connect to SMTP server
		if(!pSC->Init(lpSmtpAddress, SMTP_SERVER_PORT))
		{
			ErrorTrace(0,"Failed to init CSmtpClient object");
			fRet = FALSE;
            goto fPostArticle_Exit;
		}

        // this may be in an sError state from a previous transaction
		pSC->SetClientState(sInitialized);

		// receive greeting from server
		if(!pSC->fReceiveGreeting())
		{
            pSC->Terminate(TRUE);
			ErrorTrace( 0,"Failed to receive greeting");
			fRet = FALSE;
            goto fPostArticle_Exit;
		}
    }

	// The client object should be in an initialized state
	_ASSERT(pSC->GetClientState() == sInitialized);

    //
    // At this point pSC points to either a pool object or a local object
	// SMTP client state machine
    //
	fDone = FALSE;
	while(!fDone)
	{
		SMTP_STATE state = pSC->GetClientState();

		switch(state)
		{
			case sInitialized:

				// send HELO
				if(!pSC->fDoHeloCommand())
					pSC->SetClientState(sError);
				else
					pSC->SetClientState(sHeloDone);

				break;

			case sHeloDone:

				// send MAIL FROM
				if(!pSC->fDoMailFromCommand(lpFrom, cbFrom))
					pSC->SetClientState(sError);
				else
					pSC->SetClientState(sMailFromSent);

				break;

			case sMailFromSent:

				// send RCPT TO
				if(!pSC->fDoRcptToCommand(lpModerator))
					pSC->SetClientState(sError);
				else
					pSC->SetClientState(sRcptTo);

				break;

			case sRcptTo:

				// send DATA
				if(!pSC->fDoDataCommand())
					pSC->SetClientState(sError);
				else
					pSC->SetClientState(sDataDone);

				break;

			case sDataDone:

				// mail the article
				if(!pSC->fMailArticle(hFile, dwOffset, dwLength, pchHead, cbHead, pchBody, cbBody))
					pSC->SetClientState(sError);
				else
				{
					if(!pSC->fReceiveDataResponse())
						pSC->SetClientState(sError);
					else
					{
						// ready for next article send
						pSC->SetClientState(sHeloDone);
						fDone = TRUE;
					}
				}

				break;

			case sError:

				ErrorTrace(0,"SmtpClient: invalid state");

                // error - close the connection if it is persistent
                // NOTE: if pSC is a stack object, it is terminated always
                //       if pSC is a pool object, it is terminated only on errors
                if(pSC != &SCNew)
                    pSC->Terminate(TRUE);   

                fDone = TRUE;           // exit while loop
                fRet  = FALSE;          // return failure

                break;

		}	// end switch
	}	// end while

    // if this is a local object, close the connection
    if(pSC == &SCNew)
        pSC->Terminate(TRUE);

fPostArticle_Exit:

	// release this object only if it is from the pool
    if(pSC != &SCNew)
	    g_SCPool.ReleaseSmtpClient(dwIndex);

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\svcadm.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcadm.cpp

Abstract:

    This module contains code for doing admin stuff

Author:

    Johnson Apacible (JohnsonA)     12-Jan-1995

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"

void
LogAdminEvent(	
		IN PNNTP_SERVER_INSTANCE pInstance,
		IN LPI_NNTP_CONFIG_INFO pConfig
		)	;


NET_API_STATUS
NET_API_FUNCTION
NntprSetAdminInformation(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPI_NNTP_CONFIG_INFO pConfig,
    OUT LPDWORD pParmError OPTIONAL
    )
{
    APIERR err = NERR_Success;

	BOOL	fRtn = TRUE ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ENTER("NntprSetAdminInformation")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    if ( !mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
		ErrorTrace(0,"Failed to open metabase key %s", pInstance->QueryMDPath());
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_OPEN_FAILED;
	}

	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_POSTINGMODES ) ) {

		LogAdminEvent( pInstance, pConfig );

		if( !pInstance->SetPostingModes(	mb,
											pConfig->AllowClientPosting,
											pConfig->AllowFeedPosting ) )	{
			err = GetLastError() ;
		}

	}

	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_POSTLIMITS ) ) {

		if( !pInstance->SetPostingLimits(	mb,
											pConfig->ServerPostHardLimit,
											pConfig->ServerPostSoftLimit ) ) {
			if( err == NERR_Success ) {
				err = GetLastError() ;
			}
		}
	}

	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_FEEDLIMITS ) )	{

		if( !pInstance->SetFeedLimits(	mb,
										pConfig->ServerFeedHardLimit, 
										pConfig->ServerFeedSoftLimit ) )	{

			if( err == NERR_Success ) {
				err = GetLastError() ;
			}
		}
	}
		
	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_CONTROLSMSGS ) ) {

		if( !pInstance->SetControlMessages( mb, pConfig->AllowControlMessages ) )
		{
			if( err == NERR_Success ) {
				err = GetLastError() ;
			}
		}
	}

	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_SMTPADDRESS ) )	{

		if( !pInstance->SetSmtpAddress( mb, pConfig->SmtpServerAddress ) )
		{
			if( err == NERR_Success )
			{
				err = GetLastError() ;
			}
		}
	}
	
	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_UUCPNAME ) )	{

		if( !pInstance->SetUucpName( mb, pConfig->UucpServerName ) )
		{
			if( err == NERR_Success )
			{
				err = GetLastError() ;
			}
		}
	}
	
	if( IsFieldSet( pConfig->FieldControl, FC_NNTP_DEFAULTMODERATOR ) )	{

		if( !pInstance->SetDefaultModerator( mb, pConfig->DefaultModerator ) )
		{
			if( err == NERR_Success )
			{
				err = GetLastError() ;
			}
		}
	}

	mb.Close();
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprSetAdminInformation

NET_API_STATUS
NET_API_FUNCTION
NntprGetAdminInformation(
    IN  LPWSTR pszServer OPTIONAL,
    IN	DWORD  InstanceId,
    OUT LPI_NNTP_CONFIG_INFO * pConfig
    )
{
    APIERR err = NERR_Success;

    ENTER("NntprGetAdminInformation")

	*pConfig = NULL ;
	DWORD	cb;
	DWORD	cbAddress;
	DWORD	cbUucpName;
	DWORD	cbDefaultModerator;
	LPBYTE	pAlloc;

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	cbAddress = (lstrlenW( pInstance->GetRawSmtpAddress() ) + 1) * sizeof(WCHAR);
	cbUucpName= (lstrlenW( pInstance->GetRawUucpName() ) + 1) * sizeof(WCHAR);
	cbDefaultModerator = (lstrlenW( pInstance->GetRawDefaultModerator() ) +1) * sizeof(WCHAR);

	cb = sizeof( I_NNTP_CONFIG_INFO ) + cbAddress + cbUucpName + cbDefaultModerator;
				
	pAlloc = (LPBYTE)MIDL_user_allocate( cb ) ;
	if( pAlloc ) {

		LPI_NNTP_CONFIG_INFO pLocal = *pConfig = (LPI_NNTP_CONFIG_INFO)pAlloc;
		LPWSTR pszAddress = (LPWSTR)(pAlloc + sizeof(I_NNTP_CONFIG_INFO));
		LPWSTR pszUucpName = (LPWSTR)(pAlloc + sizeof(I_NNTP_CONFIG_INFO) + cbAddress );
		LPWSTR pszDefaultModerator = (LPWSTR)(pAlloc + sizeof(I_NNTP_CONFIG_INFO) + cbAddress + cbUucpName );


		pLocal->FieldControl =	FC_NNTP_POSTINGMODES | 
								FC_NNTP_ORGANIZATION | 
								FC_NNTP_POSTLIMITS   |
								FC_NNTP_ENCRYPTCAPS  |
								FC_NNTP_SMTPADDRESS  |
								FC_NNTP_UUCPNAME     |
								FC_NNTP_CONTROLSMSGS |
								FC_NNTP_DEFAULTMODERATOR ;

		pLocal->AllowClientPosting =  pInstance->FAllowClientPosts() ;
		pLocal->AllowFeedPosting =	  pInstance->FAllowFeedPosts() ;
		pLocal->ServerPostHardLimit = pInstance->ServerHardLimit() ;
		pLocal->ServerPostSoftLimit = pInstance->ServerSoftLimit() ;
		pLocal->ServerFeedHardLimit = pInstance->FeedHardLimit() ;
		pLocal->ServerFeedSoftLimit = pInstance->FeedSoftLimit() ;
		pLocal->Organization = NULL ;

		CEncryptCtx::GetAdminInfoEncryptCaps( &pLocal->dwEncCaps );

		pLocal->SmtpServerAddress = pszAddress;
		CopyMemory( pszAddress, pInstance->GetRawSmtpAddress(), cbAddress );

		pLocal->UucpServerName = pszUucpName;
		CopyMemory( pszUucpName, pInstance->GetRawUucpName(), cbUucpName );

		pLocal->DefaultModerator = pszDefaultModerator;
		CopyMemory( pszDefaultModerator, pInstance->GetRawDefaultModerator(), cbDefaultModerator );

		pLocal->AllowControlMessages = pInstance->FAllowControlMessages();

	}	else	{

		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_OUTOFMEMORY ;

	}

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprGetAdminInformation

void
LogAdminEvent(	
		IN PNNTP_SERVER_INSTANCE pInstance,
		IN LPI_NNTP_CONFIG_INFO pConfig
		)
{
	DWORD event = 0;
	PCHAR args[1];
	CHAR  szId[20];

	_itoa( pInstance->QueryInstanceId(), szId, 10 );
	args [0] = szId;

	// log an event if client/feed posting changes from enabled to disabled or vice versa
	if( pInstance->FAllowClientPosts() != pConfig->AllowClientPosting )
	{
		if( pConfig->AllowClientPosting )
			event = NNTP_EVENT_CLIENTPOSTING_ENABLED;
		else
			event = NNTP_EVENT_CLIENTPOSTING_DISABLED;
	}

	if( pInstance->FAllowFeedPosts() != pConfig->AllowFeedPosting )
	{
		if( pConfig->AllowFeedPosting )
			event = NNTP_EVENT_FEEDPOSTING_ENABLED;
		else
			event = NNTP_EVENT_FEEDPOSTING_DISABLED;
	}

	if( event )
	{
		NntpLogEvent(
				event,
				1,
				(const char**)args, 
				0 
				) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\svcgroup.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

	svcgroup.cpp

Abstract :

	This module contains the server side support for newsgroup rpcs.

Author :

	Neil Kaethler

Revision History :

--*/

#define	INCL_INETSRV_INCS
#include	"tigris.hxx"
#include	"nntpsvc.h"

static BOOL
IsValidUnicodeString(LPCWSTR wszString, DWORD dwByteLen, DWORD dwMinLen, DWORD dwMaxLen) {

	DWORD dwCharLen = dwByteLen / sizeof(WCHAR);

	// Must be an even number of bytes
	if (dwByteLen & 1)
		return FALSE;

	if (dwMinLen != 0 && wszString == NULL)
		return FALSE;

	if (dwCharLen < dwMinLen || dwCharLen > dwMaxLen)
		return FALSE;

	// Make sure it's NULL terminated
	if (wszString != NULL && wszString[dwCharLen-1] != L'\0')
		return FALSE;

	return TRUE;
}



NET_API_STATUS
NET_API_FUNCTION
NntprGetNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN OUT	LPI_NEWSGROUP_INFO	*pNewsgroupInfo
	)
{

	TraceFunctEnter( "NntprGetNewsgroup" ) ;

	APIERR	ss = STATUS_SUCCESS ;

	LPI_NEWSGROUP_INFO	NewsgroupInfo = *pNewsgroupInfo ;
	*pNewsgroupInfo = 0 ;

	if( NewsgroupInfo == 0 )	{
		return	ERROR_INVALID_PARAMETER ;
	}

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	unsigned	char	szGroup[MAX_PATH*2] ;
	unsigned	char	szDescription[MAX_DESCRIPTIVE_TEXT+1] ;
	unsigned	char	szModerator[MAX_MODERATOR_NAME+1] ;
	unsigned	char	szPrettyname[MAX_PRETTYNAME_TEXT+1] ;
	DWORD	cbDescription = 0 ;
	DWORD	cbModerator = 0 ;
	DWORD	cbPrettyname = 0 ;

	if( NewsgroupInfo->Newsgroup == 0  ||
		NewsgroupInfo->cbNewsgroup > (sizeof( szGroup ) / sizeof( szGroup[0] )) ) {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_INVALID_PARAMETER ;
	}

	CopyNUnicodeStringIntoAscii( (char*)szGroup, (LPWSTR)NewsgroupInfo->Newsgroup,
	    -1, MAX_PATH) ;

	CNewsTree*	ptree = pInstance->GetTree() ;

	EnterCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;

	CGRPPTR	pGroup = ptree->GetGroup( (char*)szGroup, lstrlen( (char*)szGroup )+1 ) ;

	if( pGroup != 0 ) {

		cbDescription = pGroup->CopyHelpTextForRPC( (char*)szDescription, sizeof( szDescription )-1) ;
		cbModerator = pGroup->CopyModerator( (char*)szModerator, sizeof( szModerator )-1 ) ;
		cbPrettyname = pGroup->CopyPrettynameForRPC( (char*)szPrettyname, sizeof( szPrettyname )-1) ;
		szDescription[cbDescription++] = '\0' ;
		szModerator[cbModerator++] = '\0' ;
		szPrettyname[cbPrettyname++] = '\0' ;

		DWORD	cbAllocate =	sizeof( NNTP_NEWSGROUP_INFO ) +
										(cbDescription * sizeof(WCHAR)) +
										(cbModerator * sizeof(WCHAR)) +
										(cbPrettyname * sizeof(CHAR)) +
										NewsgroupInfo->cbNewsgroup ;

		PUCHAR	bufStart = (PUCHAR)MIDL_user_allocate(	cbAllocate ) ;

		if( bufStart == NULL ) {
			ss = ERROR_NOT_ENOUGH_MEMORY ;
		}	else	{

			PUCHAR	bufEnd = (bufStart + cbAllocate) ;
			LPI_NEWSGROUP_INFO	NewsgroupInfoOut = (LPI_NEWSGROUP_INFO)bufStart ;

			bufEnd -= NewsgroupInfo->cbNewsgroup ;
			CopyMemory( bufEnd, NewsgroupInfo->Newsgroup, NewsgroupInfo->cbNewsgroup ) ;
			NewsgroupInfoOut->Newsgroup = bufEnd ;
			NewsgroupInfoOut->cbNewsgroup = NewsgroupInfo->cbNewsgroup ;

			if( cbDescription != 0 ) {

				bufEnd -= (cbDescription * sizeof(WCHAR)) ;
				WCHAR*	dest = (WCHAR*)bufEnd ;

				WCHAR wcTemp[MAX_DESCRIPTIVE_TEXT+1];
				for( DWORD i=0; i < min(cbDescription, sizeof(wcTemp)/sizeof(wcTemp[0])) ; i++ ) {
					wcTemp[i] = (WCHAR)szDescription[i] ;
				}
				memcpy(dest,wcTemp,cbDescription*2);
				dest += cbDescription;

				NewsgroupInfoOut->cbDescription = cbDescription * sizeof(WCHAR) ;
				NewsgroupInfoOut->Description = bufEnd ;

			}

			if( cbModerator != 0 ) {

				bufEnd -= (cbModerator * sizeof(WCHAR)) ;
				WCHAR*	dest = (WCHAR*)bufEnd ;

				WCHAR wcTemp[MAX_MODERATOR_NAME];
				for( DWORD i=0; i<cbModerator; i++ ) {
					wcTemp[i] = (WCHAR)szModerator[i] ;
				}
				memcpy(dest,wcTemp,cbModerator*2);
				dest += cbModerator;

				NewsgroupInfoOut->cbModerator = cbModerator * sizeof( WCHAR ) ;
				NewsgroupInfoOut->Moderator = bufEnd ;
				if ( *(NewsgroupInfoOut->Moderator) != 0 )
				    NewsgroupInfoOut->fIsModerated = TRUE;
				else NewsgroupInfoOut->fIsModerated = FALSE;
			} else NewsgroupInfoOut->fIsModerated = FALSE;

			if( cbPrettyname != 0 ) {

				bufEnd -= (cbPrettyname * sizeof(CHAR)) ;
				CHAR*	dest = (CHAR*)bufEnd ;
				for( DWORD i=0; i<cbPrettyname; i++ ) {
					*dest++ = (CHAR)szPrettyname[i] ;
				}
				NewsgroupInfoOut->cbPrettyname = cbPrettyname * sizeof(CHAR) ;
				NewsgroupInfoOut->Prettyname = bufEnd ;
			}

			NewsgroupInfoOut->ReadOnly = pGroup->IsReadOnly() ;
			NewsgroupInfoOut->ftCreationDate = pGroup->GetGroupTime();

			*pNewsgroupInfo = NewsgroupInfoOut ;

			ss = STATUS_SUCCESS ;

		}
	}	else	{

		ss = NERR_ResourceNotFound ;

	}

	LeaveCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return	ss ;

}	//	NntpGetNewsgroup

NET_API_STATUS
NET_API_FUNCTION
NntprSetNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN	LPI_NEWSGROUP_INFO	NewsgroupInfo
	)
{

	TraceFunctEnter( "NntprSetNewsgroup" ) ;

	APIERR	ss = STATUS_SUCCESS ;
	DWORD   cProperties = 0;
	DWORD   rgidProperties[MAX_GROUP_PROPERTIES];

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	//
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	//
	//	First validate the parameters
	//
	if(	!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Newsgroup, NewsgroupInfo->cbNewsgroup,
			1, MAX_NEWSGROUP_NAME-1) ||
		!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Description, NewsgroupInfo->cbDescription,
			0, MAX_DESCRIPTIVE_TEXT-1) ||
		!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Moderator, NewsgroupInfo->cbModerator,
			0, MAX_MODERATOR_NAME-1) ||
		NewsgroupInfo->cbPrettyname >= MAX_PRETTYNAME_TEXT ) {

		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_INVALID_PARAMETER ;

	}

	char	szNewsgroup[MAX_NEWSGROUP_NAME] ;
	char	szModerator[MAX_MODERATOR_NAME] ;
	char	szDescription[MAX_DESCRIPTIVE_TEXT] ;
	char	szPrettyname[MAX_PRETTYNAME_TEXT] ;

	szNewsgroup[0] = '\0' ;
	szModerator[0] = '\0' ;
	szDescription[0] = '\0' ;
	szPrettyname[0] = '\0' ;

	CopyNUnicodeStringIntoAscii(szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup,
		-1, MAX_NEWSGROUP_NAME);
	//CopyUnicodeStringIntoAscii( szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup ) ;

	if( NewsgroupInfo->Moderator != 0 ) {
		CopyNUnicodeStringIntoAscii(szModerator, (LPWSTR)NewsgroupInfo->Moderator,
			-1, MAX_MODERATOR_NAME);
		//CopyUnicodeStringIntoAscii( szModerator, (LPWSTR)NewsgroupInfo->Moderator ) ;
	} else if( NewsgroupInfo->fIsModerated ) {
	    //
	    //  Newsgroup is moderated but no name supplied - use default !
	    //
		DWORD cbModeratorLen = MAX_MODERATOR_NAME;
		szModerator [0] = '\0';
		if( pInstance->GetDefaultModerator( szNewsgroup, szModerator, &cbModeratorLen ) ) {
			_ASSERT( !cbModeratorLen || (cbModeratorLen == (DWORD)lstrlen( szModerator )+1) );
		} else {
			ErrorTrace(0,"Error %d GetDefaultModerator", GetLastError());
			szModerator[0] = '\0';
			cbModeratorLen = 0;
		}
    }

	if( NewsgroupInfo->Description != 0 ) {
		CopyNUnicodeStringIntoAscii(szDescription, (LPWSTR)NewsgroupInfo->Description,
			-1, MAX_DESCRIPTIVE_TEXT);
		//CopyUnicodeStringIntoAscii( szDescription, (LPWSTR)NewsgroupInfo->Description ) ;
	}

	if( NewsgroupInfo->Prettyname != 0 ) {
		lstrcpyn( szPrettyname, (const char*)NewsgroupInfo->Prettyname, MAX_PRETTYNAME_TEXT);
	}

	EnterCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;

	CNewsTree*	ptree = pInstance->GetTree() ;

	CGRPPTR	pGroup = ptree->GetGroup( szNewsgroup, lstrlen( szNewsgroup ) + 1 ) ;
	if( pGroup != 0 ) {
	    INNTPPropertyBag *pPropBag = pGroup->GetPropertyBag();
	    HRESULT hr = S_OK;
	    DWORD  dwLen = 0;
        dwLen = strlen( szModerator ) + 1 ;
        hr = pPropBag->PutBLOB( NEWSGRP_PROP_MODERATOR,
                                dwLen,
                                PBYTE( szModerator ));
        rgidProperties[cProperties++] = NEWSGRP_PROP_MODERATOR;

        if ( SUCCEEDED( hr ) ) {
            dwLen = strlen( szDescription ) + 1 ;
            hr = pPropBag->PutBLOB(  NEWSGRP_PROP_DESC,
                                     dwLen,
                                     PBYTE( szDescription ));
            rgidProperties[cProperties++] = NEWSGRP_PROP_DESC;
        }

        if ( SUCCEEDED( hr ) ) {
            dwLen = strlen( szPrettyname ) + 1;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_PRETTYNAME,
                                    dwLen,
                                    PBYTE( szPrettyname ));
            rgidProperties[cProperties++] = NEWSGRP_PROP_PRETTYNAME;
        }

        if ( SUCCEEDED( hr ) ) {
            hr = pPropBag->PutBool( NEWSGRP_PROP_READONLY, NewsgroupInfo->ReadOnly );
            rgidProperties[cProperties++] = NEWSGRP_PROP_READONLY;
        }

        if ( SUCCEEDED( hr ) ) {
            hr = pPropBag->PutDWord( NEWSGRP_PROP_DATELOW, NewsgroupInfo->ftCreationDate.dwLowDateTime );
        }

        if ( SUCCEEDED( hr ) ) {
            hr = pPropBag->PutDWord( NEWSGRP_PROP_DATEHIGH, NewsgroupInfo->ftCreationDate.dwHighDateTime );
        }

        if ( FAILED( hr ) ) {
            // what should I tell the client ?  Does he ever
            // know HRESULT ?
            ss = ERROR_INVALID_PARAMETER;
        }

        // Now set it to driver
      	if ( !pGroup->SetDriverStringProperty( cProperties, rgidProperties ) ) {
		    // BUGBUG: do I just return fail or roll back all changes
		    // to the newsgroup object ?
    	}

   		pPropBag->Release();
	}	else	{

		ss = ERROR_NOT_FOUND ;

	}

	LeaveCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return	 ss ;

}	//	NntpSetNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntprCreateNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN	LPI_NEWSGROUP_INFO	NewsgroupInfo
	)
{

	TraceFunctEnter( "NntprCreateNewsgroup" ) ;

	APIERR	ss = STATUS_SUCCESS ;
	DWORD   cProperties = 0;
	DWORD   rgidProperties[MAX_GROUP_PROPERTIES];

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	//
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	//
	//	First validate the parameters
	//
	if(	!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Newsgroup, NewsgroupInfo->cbNewsgroup,
			1, MAX_NEWSGROUP_NAME-1) ||
		!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Description, NewsgroupInfo->cbDescription,
			0, MAX_DESCRIPTIVE_TEXT-1) ||
		!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Moderator, NewsgroupInfo->cbModerator,
			0, MAX_MODERATOR_NAME-1) ||
		NewsgroupInfo->cbPrettyname >= MAX_PRETTYNAME_TEXT ) {

		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_INVALID_PARAMETER ;

	}

	char	szNewsgroup[MAX_NEWSGROUP_NAME] ;
	char	szModerator[MAX_MODERATOR_NAME] ;
	char	szDescription[MAX_DESCRIPTIVE_TEXT] ;
	char	szPrettyname[MAX_PRETTYNAME_TEXT] ;

	szNewsgroup[0] = '\0' ;
	szModerator[0] = '\0' ;
	szDescription[0] = '\0' ;
	szPrettyname[0] = '\0' ;

	CopyNUnicodeStringIntoAscii(szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup,
		-1, MAX_NEWSGROUP_NAME);
	// CopyUnicodeStringIntoAscii( szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup ) ;
	//_strlwr( szNewsgroup ) ;

	if( NewsgroupInfo->Moderator != 0 ) {
		//CopyUnicodeStringIntoAscii( szModerator, (LPWSTR)NewsgroupInfo->Moderator ) ;
		CopyNUnicodeStringIntoAscii(szModerator, (LPWSTR)NewsgroupInfo->Moderator,
			-1, MAX_MODERATOR_NAME);
	} else if( NewsgroupInfo->fIsModerated ) {
	    //
	    //  Newsgroup is moderated but no name supplied - use default !
	    //
		DWORD cbModeratorLen = MAX_MODERATOR_NAME;
		szModerator [0] = '\0';
		if( pInstance->GetDefaultModerator( szNewsgroup, szModerator, &cbModeratorLen ) ) {
			_ASSERT( !cbModeratorLen || (cbModeratorLen == (DWORD)lstrlen( szModerator )+1) );
		} else {
			ErrorTrace(0,"Error %d GetDefaultModerator", GetLastError());
			szModerator[0] = '\0';
			cbModeratorLen = 0;
		}
    }

	if( NewsgroupInfo->Description != 0 ) {
		//CopyUnicodeStringIntoAscii( szDescription, (LPWSTR)NewsgroupInfo->Description ) ;
		CopyNUnicodeStringIntoAscii(szDescription, (LPWSTR)NewsgroupInfo->Description,
			-1, MAX_DESCRIPTIVE_TEXT);
	}

	if( NewsgroupInfo->Prettyname != 0 ) {
		lstrcpyn( szPrettyname, (LPCSTR)NewsgroupInfo->Prettyname, MAX_PRETTYNAME_TEXT);
	}

	BOOL fReadOnly = NewsgroupInfo->ReadOnly ;
	_ASSERT( (fReadOnly == TRUE) || (fReadOnly == FALSE) );

	CNewsTree*	ptree = pInstance->GetTree() ;
	CGRPPTR	pGroup;

	EnterCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;

	if( !ptree->CreateGroup( szNewsgroup, FALSE, NULL, FALSE ) ) {

		ss = GetLastError();

	}	else	{

		pGroup = ptree->GetGroup( szNewsgroup, lstrlen( szNewsgroup ) ) ;
		if( pGroup == 0 ) {

			ss = ERROR_INTERNAL_ERROR ;

		}	else	{

		    INNTPPropertyBag *pPropBag = pGroup->GetPropertyBag();
		    HRESULT hr = S_OK;
		    DWORD  dwLen = 0;
		    if ( NULL != pPropBag ) {
		        if ( *szModerator != 0 ) {
		            dwLen = strlen( szModerator ) + 1;
                    hr = pPropBag->PutBLOB( NEWSGRP_PROP_MODERATOR,
                                            dwLen,
                                            PBYTE( szModerator ));
                    rgidProperties[cProperties++] = NEWSGRP_PROP_MODERATOR;
                }

                if ( SUCCEEDED( hr ) && *szDescription != 0 ) {
                    dwLen = strlen( szDescription ) + 1;
                    hr = pPropBag->PutBLOB(  NEWSGRP_PROP_DESC,
                                            dwLen,
                                            PBYTE( szDescription ));
                    rgidProperties[cProperties++] = NEWSGRP_PROP_DESC;
                }

                if ( SUCCEEDED( hr ) && *szPrettyname != 0 ) {
                    dwLen = strlen( szPrettyname ) + 1;
                    hr = pPropBag->PutBLOB( NEWSGRP_PROP_PRETTYNAME,
                                            dwLen,
                                            PBYTE( szPrettyname ));
                    rgidProperties[cProperties++] = NEWSGRP_PROP_PRETTYNAME;
                }

                if ( SUCCEEDED( hr ) ) {
                    hr = pPropBag->PutBool( NEWSGRP_PROP_READONLY, fReadOnly );
                    rgidProperties[cProperties++] = NEWSGRP_PROP_READONLY;
                }

                if ( FAILED( hr ) ) {
                    // what should I tell the client ?  Does he ever
                    // know HRESULT ?
                    ss = ERROR_INTERNAL_ERROR;
                }

                // Now set it to driver
      	        if ( !pGroup->SetDriverStringProperty( cProperties, rgidProperties ) ) {
		            // BUGBUG: do I just return fail or roll back all changes
		            // to the newsgroup object ?
    	        }

                pPropBag->Release();
           } else ss = ERROR_INTERNAL_ERROR;
       }
	}

	if( STATUS_SUCCESS == ss )
	{
		PCHAR	args[2] ;
		CHAR    szId[20];
		_itoa( pInstance->QueryInstanceId(), szId, 10 );
		args[0] = szId;
		args[1] = pGroup->GetNativeName() ;

		NntpLogEvent(
				NNTP_EVENT_NEWGROUP_RPC_APPLIED,
				2,
				(const CHAR **)args,
				0 ) ;
	}

	LeaveCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return ss  ;
}	//	NntpCreateNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntprDeleteNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN	LPI_NEWSGROUP_INFO	NewsgroupInfo
	)
{

	TraceFunctEnter( "NntprDeleteNewsgroup" ) ;

	APIERR	ss = STATUS_SUCCESS ;

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	//
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	//
	//	First validate the parameters
	//

	if (!IsValidUnicodeString((LPCWSTR)NewsgroupInfo->Newsgroup, NewsgroupInfo->cbNewsgroup,
			1, MAX_NEWSGROUP_NAME-1))
    {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	ERROR_INVALID_PARAMETER ;
	}

	char	szNewsgroup[MAX_NEWSGROUP_NAME] ;
	szNewsgroup[0] = '\0' ;

	CopyNUnicodeStringIntoAscii(szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup,
		-1, MAX_NEWSGROUP_NAME);

	// CopyUnicodeStringIntoAscii( szNewsgroup, (LPWSTR)NewsgroupInfo->Newsgroup ) ;
	_strlwr( szNewsgroup ) ;

	CNewsTree*	ptree = pInstance->GetTree() ;

	EnterCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;

	CGRPPTR	pGroup = ptree->GetGroup( szNewsgroup, lstrlen( szNewsgroup ) ) ;
	if( pGroup == 0 )
    {
		ss = ERROR_INTERNAL_ERROR ;
	}
	else
    {
        if( !ptree->RemoveGroup( pGroup ) )
    		ss = ERROR_INVALID_NAME ;
	}

	if( STATUS_SUCCESS == ss )
	{
		PCHAR	args[2] ;
		CHAR    szId[20];
		_itoa( pInstance->QueryInstanceId(), szId, 10 );
		args[0] = szId;
		args[1] = pGroup->GetNativeName() ;

		NntpLogEvent(
				NNTP_EVENT_RMGROUP_RPC_APPLIED,
				2,
				(const CHAR **)args,
				0 ) ;
	}

	LeaveCriticalSection( &pInstance->m_critNewsgroupRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return ss;
}	//	NntprDeleteNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntprFindNewsgroup(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	NNTP_HANDLE			NewsgroupPrefix,
	IN	DWORD				MaxResults,
	OUT	LPDWORD				pdwResultsFound,
	OUT	LPNNTP_FIND_LIST	*ppFindList
	)

{
	LPNNTP_FIND_LIST	pFindList;
	APIERR	ss = STATUS_SUCCESS ;
	char szGroup [(MAX_PATH*2)+2];
	DWORD cbGroup;
	DWORD cbAlloc;
	DWORD	err ;

	TraceFunctEnter( "NntprFindNewsgroup" ) ;

	if (NewsgroupPrefix == 0)
	{
		ErrorTrace(0,"Newsgroup prefix: invalid pointer: NewsgroupPrefix" );
		return (NET_API_STATUS)ERROR_INVALID_PARAMETER;
	}
        
	*ppFindList = NULL;

	//
	//	Check service state
	//

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	// validate newsgroup length
	DWORD cbPrefix = wcslen( (LPWSTR)NewsgroupPrefix );
	if(cbPrefix > (MAX_PATH*2) || cbPrefix == 0)
	{
        ErrorTrace(0,"Newsgroup prefix: invalid length: cbPrefix is %d", cbPrefix );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_BUFFER_OVERFLOW;
	}

	DebugTrace(NULL, "Find string is %ls", NewsgroupPrefix);
	CopyUnicodeStringIntoAscii( szGroup, (LPWSTR)NewsgroupPrefix ) ;

	// szGroup should be a multisz for the group iterator
	cbGroup = lstrlen( szGroup );
	_ASSERT(cbGroup <= (MAX_PATH*2));

	szGroup [cbGroup  ] = '\0';
	szGroup [cbGroup+1] = '\0';

	// Get the newstree object
	CNewsTree*  pTree = pInstance->GetTree() ;

	// allocate upto MaxResults entries
	// ensure that cbAlloc is within DWORD range (should restrict Max to a lower value than this)
	DWORD MaxPossibleResults = (DWORD)(ULONG_MAX-sizeof(NNTP_FIND_LIST))/sizeof(NNTP_FIND_ENTRY);
	if(MaxResults > MaxPossibleResults)
		MaxResults = MaxPossibleResults;

	cbAlloc = sizeof(NNTP_FIND_LIST) + MaxResults * sizeof(NNTP_FIND_ENTRY);
	pFindList = (LPNNTP_FIND_LIST)MIDL_user_allocate(cbAlloc);

	if( pFindList == NULL ) {
		ss = ERROR_NOT_ENOUGH_MEMORY ;
		ErrorTrace(NULL, "MIDL_user_allocate failed: GetLastError is %d", GetLastError());
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		TraceFunctLeave();
		return ss;
	}

	ZeroMemory(pFindList, cbAlloc);
	pFindList->cEntries = MaxResults;
	*pdwResultsFound = 0;

	if(!MaxResults)
	{
		// No hits
		*ppFindList = pFindList;
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		TraceFunctLeave();
		return ss;
	}

	CGroupIterator* pIterator = 0;

	// get the group names that match; *pdwResultsFound == number of hits
	for ( pIterator = pTree->GetIterator( (LPMULTISZ)szGroup, TRUE, FALSE );
		  pIterator && !pIterator->IsEnd() && !pTree->m_bStoppingTree;
		  pIterator->Next()
		)
    {
		if(*pdwResultsFound > (MaxResults-1))	// ie ResultsFound == MaxResults
			break;

		CGRPPTR  pGroup = pIterator->Current();

		if(pGroup == 0)
			continue;

		LPSTR lpGroupName = pGroup->GetNativeName();

		if (!ConvertStringToRpc(&(pFindList->aFindEntry[(*pdwResultsFound)++].lpszName), lpGroupName))
		{
			err = GetLastError();
			MIDL_user_free(pFindList);
			if( pIterator ) {
				XDELETE pIterator;
			}
			ErrorTrace(NULL, "Unable to convert %s to RPC string: %u", lpGroupName, err);
			pInstance->Dereference();
            RELEASE_SERVICE_LOCK_SHARED();
			return err;
		}
    }

	if( pIterator ) {
		XDELETE pIterator;
	}

	_ASSERT(*pdwResultsFound <= MaxResults);

	// return find list
	*ppFindList = pFindList;

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	TraceFunctLeave();
	return	ss ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\svcbuild.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcbuild.cpp

Abstract:

    This module contains implementation of RPCs for nntpbld

Author:

    Rajeev Rajan (rajeevr)     08-Mar-1997

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"

CBootOptions*
CreateBootOptions(
		LPI_NNTPBLD_INFO pBuildInfo,
		DWORD InstanceId
		);

NET_API_STATUS
NET_API_FUNCTION
NntprStartRebuild(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPI_NNTPBLD_INFO pBuildInfo,
    OUT LPDWORD pParmError OPTIONAL
	)
{
    APIERR err = NERR_Success;
	CRebuildThread* pRebuildThread = NULL ;
	BOOL	fRtn = TRUE ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ENTER("NntpStartRebuild")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId, FALSE );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
    	pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	// rebuild rpc crit sect
	EnterCriticalSection( &pInstance->m_critRebuildRpc ) ;

	//
	//	Verify that the instance is in the stopped state.
	//	Also, check to see if the instance is being rebuilt !
	//
	if( pInstance->m_BootOptions )
	{
		// instance has a rebuild pending
		ErrorTrace(0,"Instance %d rebuild pending: cannot rebuild", InstanceId );
		err = (NET_API_STATUS)ERROR_SERVICE_DISABLED;
		goto Exit ;
	}

	if( pInstance->QueryServerState() != MD_SERVER_STATE_STOPPED )
	{
		// instance needs to be stopped for rebuild
		ErrorTrace(0,"Instance %d invalid state %d: cannot rebuild", InstanceId, pInstance->QueryServerState() );
		err = (NET_API_STATUS)ERROR_SERVICE_ALREADY_RUNNING;
		goto Exit ;
	}

	//
	//	create boot options for this instance - this will be deleted
	//	at the end of the rebuild. As long as the m_BootOptions is
	//	non-NULL, the instance is being rebuilt.
	//

	if ( !(pInstance->m_BootOptions = CreateBootOptions( pBuildInfo, InstanceId )) ) {
		ErrorTrace(0,"Failed to create boot options for instance %d", InstanceId );
		err = (NET_API_STATUS)ERROR_INVALID_PARAMETER;
		goto Exit ;
	}

	//
	//	Create a rebuild thread if one does not exist
	//

	if( !(pRebuildThread = g_pNntpSvc->m_pRebuildThread) ) {
		g_pNntpSvc->m_pRebuildThread = XNEW CRebuildThread ;
		pRebuildThread = g_pNntpSvc->m_pRebuildThread ;

		if( pRebuildThread == NULL ) {
			err = GetLastError();
			goto Exit;
		}
	}

    //
    //  Bump a ref count since we are adding the instance to
    //  the rebuild thread queue. This will be deref'd when the
    //  rebuild thread is done with this instance.
    //
    
	pInstance->Reference();
	pRebuildThread->PostWork( (PVOID) pInstance );

Exit:

	LeaveCriticalSection( &pInstance->m_critRebuildRpc ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprStartRebuild

NET_API_STATUS
NET_API_FUNCTION
NntprGetBuildStatus(
    IN  LPWSTR	pszServer OPTIONAL,
    IN  DWORD	InstanceId,
	IN	BOOL	fCancel,
    OUT LPDWORD pdwProgress
    )
{
    APIERR err = NERR_Success;
	*pdwProgress = 0 ;

    ENTER("NntpGetBuildStatus")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId, FALSE );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
    	pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	EnterCriticalSection( &pInstance->m_critRebuildRpc ) ;

	if( pInstance->QueryServerState() != MD_SERVER_STATE_STARTED &&
		pInstance->QueryServerState() != MD_SERVER_STATE_STOPPED &&
		pInstance->QueryServerState() != MD_SERVER_STATE_PAUSED ) 
	{
		// invalid state for this RPC
		ErrorTrace(0,"Instance %d invalid state %d", InstanceId, pInstance->QueryServerState() );
		err = (NET_API_STATUS)ERROR_INVALID_PARAMETER;
		goto Exit;
	}

	if( !pInstance->m_BootOptions )
	{
		*pdwProgress = pInstance->GetRebuildProgress();
		if( *pdwProgress != 100 )
		{
			ErrorTrace(0,"Rebuild failed or not started - percent %d",*pdwProgress);
			/*
			if( (err = pInstance->GetRebuildLastError()) == 0) {
			    err = ERROR_OPERATION_ABORTED;
		    }*/
		    err = ERROR_OPERATION_ABORTED;
		}
	} else {
		*pdwProgress = min( pInstance->GetRebuildProgress(), 95 ) ;
		if( fCancel ) {
			DebugTrace(0,"Instance %d Setting cancel rebuild flag", InstanceId );
			pInstance->m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING ;
		}
	}

	DebugTrace(0,"Progress percent is %d", *pdwProgress );

Exit:

	LeaveCriticalSection( &pInstance->m_critRebuildRpc ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprGetBuildStatus

CBootOptions*
CreateBootOptions(
		LPI_NNTPBLD_INFO pBuildInfo,
		DWORD dwInstanceId
		)
{
	CBootOptions* pBootOptions = NULL ;
	char szReportFile [MAX_PATH];

	if( pBuildInfo->cbReportFile == 0 ) {
		// TODO: generate a default name
		return NULL ;
	}

	pBootOptions = XNEW CBootOptions() ;
	if( pBootOptions == 0 )	{
		return	NULL ;
	}

	pBootOptions->DoClean = pBuildInfo->DoClean;
	pBootOptions->NoHistoryDelete = pBuildInfo->NoHistoryDelete;
	pBootOptions->ReuseIndexFiles = pBuildInfo->ReuseIndexFiles & 0x00000011;
	pBootOptions->OmitNonleafDirs = pBuildInfo->OmitNonleafDirs;
	pBootOptions->cNumThreads = pBuildInfo->NumThreads;
	pBootOptions->fVerbose = pBuildInfo->Verbose;
	pBootOptions->SkipCorruptGroup = pBuildInfo->ReuseIndexFiles & 0x00000100;

	
	pBootOptions->m_hOutputFile =
		CreateFileW(	pBuildInfo->szReportFile,
						GENERIC_READ | GENERIC_WRITE,
						FILE_SHARE_READ, 
						NULL, 
						OPEN_ALWAYS, 
						FILE_FLAG_SEQUENTIAL_SCAN, 
						NULL ) ;

	if( pBootOptions->m_hOutputFile == INVALID_HANDLE_VALUE ) {

		PCHAR	args[1] ;
		CopyUnicodeStringIntoAscii( szReportFile, pBuildInfo->szReportFile );
		args[0]  = szReportFile ;
		
		NntpLogEventEx(	NNTP_BAD_RECOVERY_PARAMETER, 
						1, 
						(const char **)args, 
						GetLastError(),
						dwInstanceId
					) ;

		goto Error ;
	}

	//
	//	If IsActiveFile, szGroupFile is an INN style active file, else
	//	either this is the filename to use for storing the groups while scanning
	//	the virtual roots !
	//

	if( pBuildInfo->cbGroupFile && pBuildInfo->szGroupFile && (wcslen(pBuildInfo->szGroupFile)+1 <= MAX_PATH) ) 
	{
		CopyUnicodeStringIntoAscii(	pBootOptions->szGroupFile, pBuildInfo->szGroupFile ) ;
	} else {
		pBootOptions->szGroupFile [0] = '\0';
	}

	pBootOptions->IsActiveFile = pBuildInfo->IsActiveFile ;

	return pBootOptions;

Error:

	if( pBootOptions ) {
		XDELETE pBootOptions;
		pBootOptions = NULL;
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\svcfeeds.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcfeeds.cpp

Abstract:

    This module contains code for doing feed rpcs.

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

    Kangrong Yan ( KangYan ) 28-Feb-1998
        Take out feed config rpcs by returning "not supported" error code.

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"
#include <time.h>

VOID
FillFeedInfoBuffer (
    IN PFEED_BLOCK FeedBlock,
    IN OUT LPSTR *FixedStructure,
    IN OUT LPWSTR *EndOfVariableData
    );

VOID
EnumerateFeeds(
		IN PNNTP_SERVER_INSTANCE pInstance,
        IN PCHAR Buffer,
        IN OUT PDWORD BuffSize,
        OUT PDWORD EntriesRead
        );


LPSTR
GetFeedTypeDescription(	
		IN	FEED_TYPE	feedType
		) ;

void
LogFeedAdminEvent(	
			DWORD		event,
			PFEED_BLOCK	feedBlock,
			DWORD       dwInstanceId
			)	;



NET_API_STATUS
NET_API_FUNCTION
NntprEnumerateFeeds(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    OUT LPNNTP_FEED_ENUM_STRUCT Buffer
    )
{
    APIERR err = NERR_Success;
    //PLIST_ENTRY listEntry;
    DWORD nbytes = 0;
    DWORD nRead;

    ENTER("NntprEnumerateFeeds")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //
    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

	EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;

	(pInstance->m_pPassiveFeeds)->ShareLock() ;
	(pInstance->m_pActiveFeeds)->ShareLock() ;

    //
    // Get the size needed
    //

    nbytes = 0;
    EnumerateFeeds( pInstance, NULL, &nbytes, &nRead );

    //
    //  Determine the necessary buffer size.
    //

    Buffer->EntriesRead = 0;
    Buffer->Buffer      = NULL;

    if( nbytes == 0 ) {
        goto exit;
    }

    //
    //  Allocate the buffer.
    //

    Buffer->Buffer =
        (LPI_FEED_INFO) MIDL_user_allocate( (unsigned int)nbytes );

    if ( Buffer->Buffer == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // ok, do the right thing
    //

    EnumerateFeeds( pInstance, (PCHAR)Buffer->Buffer, &nbytes, &nRead );
    Buffer->EntriesRead = nRead;

exit:

	LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;

	(pInstance->m_pActiveFeeds)->ShareUnlock() ;
	(pInstance->m_pPassiveFeeds)->ShareUnlock() ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    LEAVE
    return (NET_API_STATUS)err;

} // NntprEnumerateFeeds

NET_API_STATUS
NET_API_FUNCTION
NntprGetFeedInformation(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	DWORD FeedId,
    OUT LPI_FEED_INFO *Buffer
    )
{
    APIERR err = NERR_Success;
    //PLIST_ENTRY listEntry;
    DWORD nbytes = 0;
    //DWORD nRead;
    PCHAR bufStart;
    PWCHAR bufEnd;
    PFEED_BLOCK feedBlock;

    ENTER("NntprGetFeedInformation")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    //
    // FeedId == 0 is invalid
    //

    *Buffer = NULL;
    if ( FeedId == 0 ) {
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(ERROR_INVALID_PARAMETER);
    }

	EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;


	CFeedList*	pList = pInstance->m_pPassiveFeeds ;
	feedBlock = pList->Search( FeedId ) ;
	if( feedBlock != NULL ) {
		goto	Found ;
	}

	pList = pInstance->m_pActiveFeeds ;
	feedBlock = pList->Search( FeedId ) ;
	if( feedBlock != NULL ) {
		goto	Found ;
	}

	LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(NERR_ResourceNotFound);

Found:

    //
    // Get the size needed
    //

    nbytes = FEEDBLOCK_SIZE( feedBlock );

    //
    //  Allocate the buffer.
    //

    bufStart = (PCHAR)MIDL_user_allocate( (unsigned int)nbytes );

    if ( bufStart == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }	else	{

		//
		// ok, do the right thing
		//

		*Buffer = (LPI_FEED_INFO)bufStart;
		bufEnd = (PWCHAR)(bufStart + nbytes);

		FillFeedInfoBuffer( feedBlock, &bufStart, &bufEnd );
	}

	pList->FinishWith( pInstance, feedBlock ) ;

	LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

//exit:

    LEAVE
    return (NET_API_STATUS)err;

} // NntprGetFeedInformation

NET_API_STATUS
NET_API_FUNCTION
NntprSetFeedInformation(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	LPI_FEED_INFO FeedInfo,
    OUT PDWORD ParmErr OPTIONAL
    )
{
    APIERR err = ERROR_NOT_SUPPORTED; // not supported anymore

    return err;

} // NntprSetFeedInformation

NET_API_STATUS
NET_API_FUNCTION
NntprAddFeed(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	LPI_FEED_INFO FeedInfo,
    OUT PDWORD ParmErr OPTIONAL,
	OUT LPDWORD pdwFeedId
    )
{
    APIERR err = ERROR_NOT_SUPPORTED;  // not supported anymore

    return err;

} // NntprAddFeed

NET_API_STATUS
NET_API_FUNCTION
NntprDeleteFeed(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	DWORD FeedId
    )
{
    APIERR err = ERROR_NOT_SUPPORTED;  // not supported anymore

    return err;

} // NntprDeleteFeed

NET_API_STATUS
NET_API_FUNCTION
NntprEnableFeed(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	DWORD FeedId,
	IN	BOOL	 Enable,
	IN	BOOL  Refill,
	IN	FILETIME	RefillTime
    )
{
    APIERR err = ERROR_NOT_SUPPORTED;  // not supported anymore

    return err;
}	// NntprEnableFeed

VOID
FillFeedInfoBuffer (
    IN PFEED_BLOCK FeedBlock,
    IN OUT LPSTR *FixedStructure,
    IN OUT LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed file structure and associated
    variable data, into a buffer.  Fixed data goes at the beginning of
    the buffer, variable data at the end.

    *** This routine assumes that ALL the data, both fixed and variable,
        will fit.

Arguments:

    FeedBlock - the FeedBlock from which to get information.

    FixedStructure - where the in the buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    DWORD i;
    PCHAR src;
    DWORD length;
    LPWSTR dest;
    LPNNTP_FEED_INFO feedInfo = (LPNNTP_FEED_INFO)(*FixedStructure);

    //
    // Update FixedStructure to point to the next structure location.
    //

    *FixedStructure = (PCHAR)*FixedStructure + sizeof(NNTP_FEED_INFO);
    _ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // Fill up the structure
    //

    feedInfo->FeedType = FeedBlock->FeedType;
    feedInfo->FeedId = FeedBlock->FeedId;
    feedInfo->FeedInterval = FeedBlock->FeedIntervalMinutes;
	feedInfo->Enabled = FeedBlock->fEnabled ;
	feedInfo->MaxConnectAttempts = FeedBlock->MaxConnectAttempts ;
	feedInfo->ConcurrentSessions = FeedBlock->ConcurrentSessions ;
	feedInfo->SessionSecurityType = FeedBlock->SessionSecurityType ;
	feedInfo->AuthenticationSecurityType = FeedBlock->AuthenticationSecurity ;
	feedInfo->cbUucpName = 0 ;
	feedInfo->UucpName = 0 ;
	feedInfo->cbFeedTempDirectory = 0 ;
	feedInfo->FeedTempDirectory = 0 ;
	feedInfo->cbAccountName = 0 ;
	feedInfo->NntpAccountName = 0 ;
	feedInfo->cbPassword = 0 ;
	feedInfo->NntpPassword = 0 ;
	feedInfo->AutoCreate = FeedBlock->AutoCreate;
	feedInfo->fAllowControlMessages = FeedBlock->fAllowControlMessages;
	feedInfo->OutgoingPort = FeedBlock->OutgoingPort;
	feedInfo->FeedPairId = FeedBlock->FeedPairId;

    FILETIME_FROM_LI(
        &feedInfo->NextActiveTime,
        &FeedBlock->NextActiveTime
        );

    FILETIME_FROM_LI(
        &feedInfo->StartTime,
        &FeedBlock->StartTime
        );

	if( FEED_IS_PULL( FeedBlock->FeedType ) )
	{
		feedInfo->PullRequestTime = FeedBlock->PullRequestTime;
	}

    //
    // Copy the server name to the output buffer.
    //

    CopyStringToBuffer(
        FeedBlock->ServerName,
        *FixedStructure,
        EndOfVariableData,
        &feedInfo->ServerName
        );

    //
    // go through the Newsgroups list
    //

    length = MultiListSize( FeedBlock->Newsgroups );
    *EndOfVariableData -= length;
    feedInfo->Newsgroups = *EndOfVariableData;
    feedInfo->cbNewsgroups = length * sizeof(WCHAR);

    dest = *EndOfVariableData;
    if ( length > 1 ) {

        src = FeedBlock->Newsgroups[0];
        for ( i = 0; i < length; i++ ) {
            *dest++ = (WCHAR)*((BYTE*)src++);
        }
    } else {

        *dest = L'\0';
    }

    //
    // go through the distribution list
    //

    length = MultiListSize( FeedBlock->Distribution );
    *EndOfVariableData -= length;
    feedInfo->Distribution = *EndOfVariableData;
    feedInfo->cbDistribution = length * sizeof(WCHAR);

    dest = *EndOfVariableData;
    if ( length > 1 ) {

        src = FeedBlock->Distribution[0];
        for ( i = 0; i < length; i++ ) {
            *dest++ = (WCHAR)*((BYTE*)src++);
        }
    } else {
        *dest = L'\0';
    }

	if( FeedBlock->NntpPassword != 0 ) {
		length = lstrlen( FeedBlock->NntpPassword ) + 1 ;
		*EndOfVariableData -= length ;
		feedInfo->NntpPassword = *EndOfVariableData ;
		feedInfo->cbPassword = length * sizeof(WCHAR) ;
		dest = *EndOfVariableData ;

		if( length > 1 ) {
			src = FeedBlock->NntpPassword ;
			for( i=0; i<length; i++ ) {
				*dest++ = (WCHAR)*((BYTE*)src++) ;
			}
		}	else	{
			*dest = L'\0' ;
		}
	}

	if( FeedBlock->NntpAccount!= 0 ) {
		length = lstrlen( FeedBlock->NntpAccount ) + 1 ;
		*EndOfVariableData -= length ;
		feedInfo->NntpAccountName = *EndOfVariableData ;
		feedInfo->cbAccountName = length * sizeof(WCHAR) ;
		dest = *EndOfVariableData ;

		if( length > 1 ) {
			src = FeedBlock->NntpAccount ;
			for( i=0; i<length; i++ ) {
				*dest++ = (WCHAR)*((BYTE*)src++) ;
			}
		}	else	{
			*dest = L'\0' ;
		}
	}

	if( FeedBlock->UucpName != 0 ) {

		length = MultiListSize( FeedBlock->UucpName ) ;
		*EndOfVariableData -= length ;
		feedInfo->UucpName = *EndOfVariableData ;
		feedInfo->cbUucpName = length * sizeof(WCHAR) ;
		dest = *EndOfVariableData ;
		FillLpwstrFromMultiSzTable( FeedBlock->UucpName, dest ) ;
	}

	if( FeedBlock->FeedTempDirectory != 0 ) {
		length = lstrlen( FeedBlock->FeedTempDirectory ) + 1 ;
		*EndOfVariableData -= length ;
		feedInfo->FeedTempDirectory= *EndOfVariableData ;
		feedInfo->cbFeedTempDirectory = length * sizeof(WCHAR) ;
		dest = *EndOfVariableData ;

		if( length > 1 ) {
			src = FeedBlock->FeedTempDirectory ;
			for( i=0; i<length; i++ ) {
				*dest++ = (WCHAR)*((BYTE*)src++) ;
			}
		}	else	{
			*dest = L'\0' ;
		}
	}



    return;

} // FillFeedInfoBuffer

VOID
EnumerateFeeds(
		IN PNNTP_SERVER_INSTANCE pInstance,
        IN PCHAR Buffer OPTIONAL,
        IN OUT PDWORD BuffSize,
        OUT PDWORD EntriesRead
        )
{
    BOOL sizeOnly;
    DWORD nbytes = 0;
    PCHAR bufStart;
    PWCHAR bufEnd;
    PFEED_BLOCK feedBlock;

    *EntriesRead = 0;
    if ( Buffer == NULL ) {

        sizeOnly = TRUE;
    } else {

        _ASSERT(BuffSize != NULL);
        _ASSERT(*BuffSize != 0);

        sizeOnly = FALSE;
        bufStart = Buffer;
        bufEnd = (PWCHAR)(bufStart + *BuffSize);
    }


	CFeedList*	rgLists[2] ;
	rgLists[0] = pInstance->m_pActiveFeeds ;
	rgLists[1] = pInstance->m_pPassiveFeeds ;

	(pInstance->m_pActiveFeeds)->ShareLock() ;
	(pInstance->m_pPassiveFeeds)->ShareLock() ;

	for( int i=0; i<2; i++ ) {

		feedBlock = rgLists[i]->StartEnumerate() ;
		while( feedBlock != 0 ) {
			//
			// Compute the space needed
			//

			if ( sizeOnly ) {

				nbytes += FEEDBLOCK_SIZE(feedBlock);

			} else {

				FillFeedInfoBuffer(
							feedBlock,
							&bufStart,
							&bufEnd
							);
			}
			(*EntriesRead)++;
			feedBlock = rgLists[i]->NextEnumerate( feedBlock ) ;
        }
	}

	(pInstance->m_pActiveFeeds)->ShareUnlock() ;
	(pInstance->m_pPassiveFeeds)->ShareUnlock() ;

    //
    // return the size to the caller
    //

    if ( sizeOnly ) {
        *BuffSize = nbytes;
    }

} // EnumerateFeeds


BOOL
UpdateFeedMetabaseValues(
			IN PNNTP_SERVER_INSTANCE pInstance,
            IN PFEED_BLOCK FeedBlock,
            IN DWORD Mask
            )
{
    PCHAR regstr;
    //DWORD error;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ENTER("UpdateFeedMetabaseValues")

    //
    // Open the metabase key
    //

    if ( !mb.Open( pInstance->QueryMDFeedPath(), METADATA_PERMISSION_WRITE ) )
	{
		ErrorTrace(0,"Error opening %s\n",FeedBlock->KeyName);
        return(FALSE);
	}

	//
	// Set the KeyType.
	//

	if( !mb.SetString(	FeedBlock->KeyName,
    					MD_KEY_TYPE,
						IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_FEED,
    					METADATA_NO_ATTRIBUTES
						) )
	{
        regstr = "KeyType";
        goto error_exit;
	}

    //
    // set the type
    //

    if ( (Mask & FEED_PARM_FEEDTYPE) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_TYPE,
							IIS_MD_UT_SERVER,
							FeedBlock->FeedType
							) )
		{
            regstr = StrFeedType;
            goto error_exit;
		}
    }


    //
    // set the auto create option
    //

    if ( (Mask & FEED_PARM_AUTOCREATE) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_CREATE_AUTOMATICALLY,
							IIS_MD_UT_SERVER,
							FeedBlock->AutoCreate
							) )
		{
            regstr = StrFeedAutoCreate;
            goto error_exit;
		}
    }

    //
    // if this is not an active feed, interval and start time
    // are na
    //

    if ( !FEED_IS_PASSIVE(FeedBlock->FeedType) ) {

        //
        // set the Feed interval
        //

        if ( (Mask & FEED_PARM_FEEDINTERVAL) != 0 ) {
			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_INTERVAL,
								IIS_MD_UT_SERVER,
								FeedBlock->FeedIntervalMinutes
								) )
			{
				regstr = StrFeedInterval;
				goto error_exit;
			}
        }

        //
        // set the interval time
        //

        if ( (Mask & FEED_PARM_STARTTIME) != 0 ) {
			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_START_TIME_HIGH,
								IIS_MD_UT_SERVER,
								FeedBlock->StartTime.HighPart
								) )
			{
				regstr = StrFeedStartHigh;
				goto error_exit;
			}

			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_START_TIME_LOW,
								IIS_MD_UT_SERVER,
								FeedBlock->StartTime.LowPart
								) )
			{
				regstr = StrFeedStartLow;
				goto error_exit;
			}
        }

        //
        // set the pull request  time
        //

        if ( (Mask & FEED_PARM_PULLREQUESTTIME) != 0 ) {
			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_NEXT_PULL_HIGH,
								IIS_MD_UT_SERVER,
								FeedBlock->PullRequestTime.dwHighDateTime
								) )
			{
				regstr = StrFeedNextPullHigh;
				goto error_exit;
			}

			if( !mb.SetDword(	FeedBlock->KeyName,
								MD_FEED_NEXT_PULL_LOW,
								IIS_MD_UT_SERVER,
								FeedBlock->PullRequestTime.dwLowDateTime
								) )
			{
				regstr = StrFeedNextPullLow;
				goto error_exit;
			}
        }
    }

    //
    // set the server name
    //

    if ( (Mask & FEED_PARM_SERVERNAME) != 0 ) {
		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_SERVER_NAME,
							IIS_MD_UT_SERVER,
							FeedBlock->ServerName
							) )
		{
			regstr = StrServerName;
			goto error_exit;
		}
    }

    //
    //	set the newsgroups
	//	bug in metabase - need to calculate multisz size !
    //

    if ( (Mask & FEED_PARM_NEWSGROUPS) != 0 ) {
		if( !mb.SetData(	FeedBlock->KeyName,
							MD_FEED_NEWSGROUPS,
							IIS_MD_UT_SERVER,
							MULTISZ_METADATA,
							FeedBlock->Newsgroups[0],
							MultiListSize( FeedBlock->Newsgroups )
							) )
		{
			regstr = StrFeedNewsgroups;
			goto error_exit;
		}
    }

    //
    // set the distribution
    //

    if ( (Mask & FEED_PARM_DISTRIBUTION) != 0 ) {
		if( !mb.SetData(	FeedBlock->KeyName,
							MD_FEED_DISTRIBUTION,
							IIS_MD_UT_SERVER,
							MULTISZ_METADATA,
							FeedBlock->Distribution[0],
							MultiListSize( FeedBlock->Distribution )
							) )
		{
			regstr = StrFeedDistribution;
			goto error_exit;
		}
    }

	if( (Mask & FEED_PARM_ENABLED) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_DISABLED,
							IIS_MD_UT_SERVER,
							FeedBlock->fEnabled
							) )
		{
			regstr = StrFeedDisabled;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_UUCPNAME) != 0 && FeedBlock->UucpName != 0 ) {
	
		char	szTemp[4096] ;
		if (MultiListSize(FeedBlock->UucpName) > sizeof(szTemp))
		{
			regstr = StrFeedUucpName;
			goto error_exit;
		}
		FillLpstrFromMultiSzTable( FeedBlock->UucpName,&szTemp[0] ) ;

		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_UUCP_NAME,
							IIS_MD_UT_SERVER,
							szTemp
							) )
		{
			regstr = StrFeedUucpName;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_TEMPDIR) != 0 && FeedBlock->FeedTempDirectory != 0 ) {
		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_TEMP_DIRECTORY,
							IIS_MD_UT_SERVER,
							FeedBlock->FeedTempDirectory
							) )
		{
			regstr = StrFeedTempDir;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_MAXCONNECT) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_MAX_CONNECTION_ATTEMPTS,
							IIS_MD_UT_SERVER,
							FeedBlock->MaxConnectAttempts
							) )
		{
			regstr = StrFeedMaxConnectAttempts;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_SESSIONSECURITY) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_SECURITY_TYPE,
							IIS_MD_UT_SERVER,
							FeedBlock->SessionSecurityType
							) )
		{
			regstr = StrFeedSecurityType;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_CONCURRENTSESSION) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_CONCURRENT_SESSIONS,
							IIS_MD_UT_SERVER,
							FeedBlock->ConcurrentSessions
							) )
		{
			regstr = StrFeedConcurrentSessions;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_AUTHTYPE) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_AUTHENTICATION_TYPE,
							IIS_MD_UT_SERVER,
							FeedBlock->AuthenticationSecurity
							) )
		{
			regstr = StrFeedAuthType;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_ACCOUNTNAME) != 0 && FeedBlock->NntpAccount != 0 ) {
		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_ACCOUNT_NAME,
							IIS_MD_UT_SERVER,
							FeedBlock->NntpAccount
							) )
		{
			regstr = StrFeedAuthAccount;
			goto error_exit;
		}
	}

	if( (Mask & FEED_PARM_PASSWORD) != 0 && FeedBlock->NntpPassword != 0 ) {
		if( !mb.SetString(	FeedBlock->KeyName,
							MD_FEED_PASSWORD,
							IIS_MD_UT_SERVER,
							FeedBlock->NntpPassword,
							METADATA_SECURE
							) )
		{
			regstr = StrFeedAuthPassword;
			goto error_exit;
		}
	}

    //
    // set the allow control message flag
    //

    if ( (Mask & FEED_PARM_ALLOW_CONTROL) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_ALLOW_CONTROL_MSGS,
							IIS_MD_UT_SERVER,
							FeedBlock->fAllowControlMessages
							) )
		{
			regstr = StrFeedAllowControl;
			goto error_exit;
		}
    }

    //
    // set the outgoing port
    //

    if ( (Mask & FEED_PARM_OUTGOING_PORT) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_OUTGOING_PORT,
							IIS_MD_UT_SERVER,
							FeedBlock->OutgoingPort
							) )
		{
			regstr = StrFeedOutgoingPort;
			goto error_exit;
		}
    }

    //
    // set the feed pair id
    //

    if ( (Mask & FEED_PARM_FEEDPAIR_ID) != 0 ) {
		if( !mb.SetDword(	FeedBlock->KeyName,
							MD_FEED_FEEDPAIR_ID,
							IIS_MD_UT_SERVER,
							FeedBlock->FeedPairId
							) )
		{
			regstr = StrFeedPairId;
			goto error_exit;
		}
    }

	_VERIFY( mb.Close() );
	_VERIFY( mb.Save()  );

    return(TRUE);

error_exit:

    mb.Close();
    ErrorTrace(0,"Error %d setting %s for %s\n", GetLastError(), regstr, FeedBlock->KeyName);

    return(FALSE);

} // UpdateFeedRegistryValue


LPSTR
GetFeedTypeDescription(	
		IN	FEED_TYPE	feedType
		)
{

	LPSTR	lpstrReturn = "<Bad Feed Type>" ;

	if(	FEED_IS_PULL( feedType ) ) {

		lpstrReturn = "Pull" ;

	}	else	if( FEED_IS_PEER( feedType ) ) {

		if( FEED_IS_PUSH( feedType ) ) {

			lpstrReturn = "Push To Peer" ;
	
		}	else	if( FEED_IS_PASSIVE( feedType ) ) {

			lpstrReturn = "Incoming Peer" ;

		}

	}	else	if( FEED_IS_MASTER( feedType ) ) {

		if( FEED_IS_PUSH( feedType ) ) {

			lpstrReturn = "Push To Master" ;
	
		}	else	if( FEED_IS_PASSIVE( feedType ) ) {

			lpstrReturn = "Incoming Master" ;

		}

	}	else	if( FEED_IS_SLAVE( feedType ) ) {

		if( FEED_IS_PUSH( feedType ) ) {

			lpstrReturn = "Push To Slave" ;
	
		}	else	if( FEED_IS_PASSIVE( feedType ) ) {

			lpstrReturn = "Incoming Slave" ;

		}
	}

	return	lpstrReturn ;

}	//	GetFeedTypeDescription

void
LogFeedAdminEvent(	DWORD		event,
					PFEED_BLOCK	feedBlock,
					DWORD       dwInstanceId
					)	
{

	PCHAR	args[3] ;
	CHAR    szId[20];

	_itoa( dwInstanceId, szId, 10 );
	args[0] = szId ;
	args[1] = GetFeedTypeDescription( feedBlock->FeedType ) ;
	args[2] = feedBlock->ServerName ;

	NntpLogEvent(
			event,
			3,
			(const char**)args,
			0 ) ;

}	//	LogFeedAdminEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\socket.cpp ===
/*++

	socket.cpp

	This file contains the implementation of the CSessionSocket class.
	Each CSessionSocket object represents a live TCP/IP session with another client or server.


--*/


#define	INCL_INETSRV_INCS
#include	"tigris.hxx"
#include    <lmerr.h>

BOOL
EnumSessInfo(
    IN CSessionSocket * pSess,
    IN DWORD dwParam,
    IN LPNNTP_SESS_ENUM_STRUCT Buffer
    );


// MOVED TO CService => CSocketList	CSessionSocket::InUseList ;
CPool	CSessionSocket::gSocketAllocator(SESSION_SOCKET_SIGNATURE) ;

BOOL
CSessionSocket::InitClass()		{
/*++

Routine Description :

	This function initializes the CSessionSocket pool.

Arguments :

	None.

Return Value :

	None.

--*/
	return	gSocketAllocator.ReserveMemory(	MAX_SESSIONS, sizeof( CSessionSocket ) ) ;
}	//	InitClass

BOOL
CSessionSocket::TermClass()	{
/*++

Routine Description :

	This function frees up the CSessionSocket Pool.

Arguments :

	None.

Return Value :

	None.

--*/
	Assert( gSocketAllocator.GetAllocCount() == 0 ) ;
	return	gSocketAllocator.ReleaseMemory( ) ;
}


ClientContext::ClientContext(
						PNNTP_SERVER_INSTANCE pInstance,
						BOOL	IsClient,
						BOOL	IsSecure
						) :
/*++

Routine Description :

	Initialize a ClientContext object.

Arguments :
	
	None.

Return Value :

	None.

--*/
	//
	//	ClientContext holds most of a clients state - ie the article they have
	//	currently selected, etc... Initialize stuff to be invalid.
	//
	m_idCurrentArticle( INVALID_ARTICLEID ),
	m_pInFeed( 0 ),
	m_encryptCtx( IsClient, pInstance->GetSslAccessPerms() ),
	m_pInstance( pInstance ),
	m_securityCtx(	pInstance,
					IsClient ?
					TCPAUTH_CLIENT|TCPAUTH_UUENCODE :
					TCPAUTH_SERVER|TCPAUTH_UUENCODE,
					pInstance->m_dwAuthorization,
					pInstance->QueryAuthentInfo() ),
	m_IsSecureConnection( IsSecure ),
	m_pOutFeed( 0 )
{
	if ( m_securityCtx.IsAuthenticated() )
	{
		IncrementUserStats();
	}

	pInstance->LockConfigRead();
	
	//
	//	Set SSPI package names for this sec context
	//
	
	m_securityCtx.SetInstanceAuthPackageNames(
					pInstance->GetProviderPackagesCount(),
					pInstance->GetProviderNames(),
					pInstance->GetProviderPackages());

	//
	// We want to set up the Cleartext authentication package
	// for this connection based on the instance configuration.
	// To enable MBS CTA,
	// MD_NNTP_CLEARTEXT_AUTH_PROVIDER must be set to the package name.
	// To disable it, the md value must be set to "".
	//
	
	m_securityCtx.SetCleartextPackageName(
		pInstance->GetCleartextAuthPackage(), pInstance->GetMembershipBroker());

#if 0		
	if (*pInstance->GetCleartextAuthPackage() == '\0' ||
		*pInstance->GetMembershipBroker() == '\0') {
		m_fUseMbsCta = FALSE;
	}
	else {
		m_fUseMbsCta = TRUE;
	}
#endif
	pInstance->UnLockConfigRead();

#ifdef	DEBUG
	FillMemory( m_rgbCommandBuff, sizeof( m_rgbCommandBuff ), 0xCC ) ;
#endif

}	//	ClientContext::ClientContext

ClientContext::~ClientContext()
{
	if ( m_securityCtx.IsAuthenticated() )
	{
		DecrementUserStats();
	}

	//
	//	Deref instance ref count - this was bumped up by IIS or
	//	in session socket constructor.
	//
	m_pInstance->DecrementCurrentConnections();
	m_pInstance->Dereference();

#ifdef	DEBUG
	//
	//	Ensure that the last command object was destroyed !
	//
	for( int i=0; i<sizeof(m_rgbCommandBuff) / sizeof( m_rgbCommandBuff[0]); i++ ) 	{
		_ASSERT( m_rgbCommandBuff[i] == 0xCC ) ;
	}
#endif

}	//	ClientContext::~ClientContext



VOID
ClientContext::IncrementUserStats(
						VOID
						)
/*++

Routine Description :

	Increment Perfmon/SNMP Stats once a user is authenticated

Arguments :
	
	None.

Return Value :

	None.

--*/
{
	if ( m_securityCtx.IsAnonymous() )
	{
		LockStatistics( m_pInstance );

		IncrementStat( m_pInstance, CurrentAnonymousUsers);
		IncrementStat( m_pInstance, TotalAnonymousUsers);
		if ( (m_pInstance->m_NntpStats).CurrentAnonymousUsers > (m_pInstance->m_NntpStats).MaxAnonymousUsers )
		{
			(m_pInstance->m_NntpStats).MaxAnonymousUsers = (m_pInstance->m_NntpStats).CurrentAnonymousUsers;
		}

		UnlockStatistics( m_pInstance );
	}
	else
	{
		LockStatistics( m_pInstance );

		IncrementStat( m_pInstance, CurrentNonAnonymousUsers);
		IncrementStat( m_pInstance, TotalNonAnonymousUsers);
		if ( (m_pInstance->m_NntpStats).CurrentNonAnonymousUsers > (m_pInstance->m_NntpStats).MaxNonAnonymousUsers )
		{
			(m_pInstance->m_NntpStats).MaxNonAnonymousUsers = (m_pInstance->m_NntpStats).CurrentNonAnonymousUsers;
		}

		UnlockStatistics( m_pInstance );
	}
}


VOID
ClientContext::DecrementUserStats(
						VOID
						)
/*++

Routine Description :

	Decrement Perfmon/SNMP Stats once a user disconnects or reauths

Arguments :
	
	None.

Return Value :

	None.

--*/
{
	if ( m_securityCtx.IsAnonymous() )
	{
		DecrementStat( m_pInstance, CurrentAnonymousUsers );
	}
	else
	{
		DecrementStat( m_pInstance, CurrentNonAnonymousUsers );
	}
}


CSessionSocket::CSessionSocket(
/*++

Routine Description :

	Initialize a CSessionSocket object.
	Place the CSessionSocket object into the InUseList.
	Because the socket is available in the InUseList before all of the necessary
	Init functions are called (either Accept() or ConnectSocket()) it is
	necessary to take some precautions with Disconnect().
	Consequently, we have a couple of counters we interlockIncrement to
	synchronize an Accept()'ing or Connect()'ing thread with anybody trying
	to disconnect.

Arguements :

	The local IP address, Port and a flag specifying whether this is a client session.

Return Value :

	None.

--*/
	IN PNNTP_SERVER_INSTANCE	pInstance,
    IN DWORD LocalIP,
    IN DWORD Port,
    IN BOOL IsClient
    ) :
	m_pPrev( 0 ),
	m_pNext( 0 ),
	m_pHandleChannel( 0 ),	
	m_pSink( 0 ),
	m_context( pInstance ),	//	set the owning virtual server instance in the client context
	m_cCallDisconnect( -1 ),
	m_cTryDisconnect( -2 ),
	m_causeDisconnect( CAUSE_UNKNOWN ),
	m_dwErrorDisconnect( 0 ),
	m_fSendTimeout( TRUE ) {

	TraceFunctEnter( "CSessionSocket::CSessionSocket" ) ;

	DebugTrace( (DWORD_PTR)this, "Insert self into list" ) ;

	//
	// If outbound connection, we need to bump a ref count on the instance
	// and bump current connections. Both are decremented by the client context destructor.
	//

	if( IsClient ) {
		pInstance->Reference();
		pInstance->IncrementCurrentConnections();
	}

	BumpCountersUp();

    //
    // init time
    //

    GetSystemTimeAsFileTime( &m_startTime );

    //
    // init members
    //

    m_remoteIpAddress = INADDR_NONE;
    m_localIpAddress = LocalIP;
    m_nntpPort = Port;

	(pInstance->m_pInUseList)->InsertSocket( this ) ;

}	//	CSessionSocket::CSessionSocket

CSessionSocket::~CSessionSocket()	{
	//
	//	Not much to do but remove ourselves from the list of active sockets.
	//
	TraceFunctEnter( "CSessionSocket::~CSessionSocket" ) ;
	((m_context.m_pInstance)->m_pInUseList)->RemoveSocket( this ) ;

	BumpCountersDown();

	DebugTrace( (DWORD_PTR)this, "Just removed self from list" ) ;

    //
    // We're done.  Log transaction
    //

    TransactionLog( 0 );

} //CSessionSocket::~CSessionSocket



void
CSessionSocket::BumpCountersUp()	{


	PNNTP_SERVER_INSTANCE pInst = m_context.m_pInstance ;
	LockStatistics( pInst ) ;

	IncrementStat( pInst, TotalConnections ) ;
	IncrementStat( pInst, CurrentConnections ) ;

	if( (pInst->m_NntpStats).MaxConnections < (pInst->m_NntpStats).CurrentConnections ) {
		(pInst->m_NntpStats).MaxConnections = (pInst->m_NntpStats).CurrentConnections ;	
	}

	UnlockStatistics( pInst ) ;

}

void
CSessionSocket::BumpSSLConnectionCounter() {

    PNNTP_SERVER_INSTANCE pInst = m_context.m_pInstance;
    LockStatistics( pInst );

    IncrementStat( pInst, TotalSSLConnections );

    UnlockStatistics( pInst );
}

void
CSessionSocket::BumpCountersDown()	{

	PNNTP_SERVER_INSTANCE pInst = m_context.m_pInstance ;

	LockStatistics( pInst ) ;

	DecrementStat(	pInst, CurrentConnections ) ;

	UnlockStatistics( pInst ) ;
}


LPSTR
CSessionSocket::GetRemoteTypeString( void )	{

	if( m_context.m_pInFeed != 0 ) {
		return	m_context.m_pInFeed->FeedType() ;
	}	else if( m_context.m_pOutFeed != 0 ) {
		return	m_context.m_pOutFeed->FeedType() ;
	}
	return	"DUMMY" ;
}

LPSTR
CSessionSocket::GetRemoteNameString( void ) {
	
	struct	in_addr	remoteAddr ;
	
	remoteAddr.s_addr = m_remoteIpAddress ;

	return	inet_ntoa( remoteAddr ) ;	


}

BOOL
CSessionSocket::Accept( HANDLE h,
						CInFeed*	pFeed,	
						sockaddr_in *paddr,
						void* patqContext,
						BOOL fSSL )	{
/*++

Routine Description :

	Initialize a socket into the appropriate state for an incoming call.
	AcceptInternal will do the brunt of the work - we will mainly check that
	somebody didn't try to Disconnect() us while we were setting up our
	state machine etc...

	WARNING :
	IO Errors while accepting the socket may cause the CSessionSocket to be
	destoyed before this function returns.
	Callers should not reference their pSocket again until they have safely
	lock the InUseList critical section which will guarantee them that things
	will not be destroyed from under their feet.


Arguments :

	h - Handle of the incoming socket
	pFeed - the Feed object appropriate for the incoming call.
	paddr - Address of the incoming call
	patqContext - optional Atq context if the connection was accepted through AcceptEx()
	fSSL - TRUE implies this is a SSL session.

Return Value :
	
	TRUE if successfull - if TRUE is returned callers must destroy us with a call
	to Disconnect().

	FALSE - unsuccessfull - callers must delete us.

--*/
	//
	//	We pass a refcounting pointer to AcceptInternal by reference.
	//	This will be used by AcceptInternal and essentially guarantees that
	//	if an error occurs on the very first IO and it happens to complete
	//	before this code is finished that the CSessionSocket etc... will not
	//	be destroyed from under us !!!
	//	In fact - the destructor of pSink may destroy the socket when we
	//	exit this function so callers should not reference the socket
	//	after calling us.
	//

	CSINKPTR	pSink ;

	if( AcceptInternal(	h,
						pFeed,
						paddr,
						patqContext,
						fSSL,
						pSink ) ) {

		if( InterlockedIncrement( &m_cTryDisconnect ) == 0 )	{

			m_pSink->UnsafeClose( this, m_causeDisconnect, m_dwErrorDisconnect ) ;

		}
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CSessionSocket::AcceptInternal( HANDLE h,
						CInFeed*	pFeed,	
						sockaddr_in *paddr,
						void* patqContext,
						BOOL fSSL,
						CSINKPTR&	pSink )	{
/*++

Routine Description :

	Initialize a socket into the appropriate state for an incoming call.
	We need to create the appropriate state objects etc... and start the
	initial IO operations.

Arguments :

	h - Handle of the incoming socket
	pFeed - the Feed object appropriate for the incoming call.
	paddr - Address of the incoming call
	patqContext - optional Atq context if the connection was accepted through AcceptEx()
	fSSL - TRUE implies this is a SSL session.
	pSink - a reference to a smart pointer which we will use to hold the
		CIODriver objects we may create.   This will guarantee the caller
		that nothing will be blown away from underneath them untill pSink
		is destroyed by the caller.

Return Value :
	
	TRUE if successfull - if TRUE is returned callers must destroy us with a call
	to Disconnect().

	FALSE - unsuccessfull - callers must delete us.

--*/


	//
	//	Somebody has connected to the server.
	//	We create this CSessionSocket for them, now we have to set it up
	//	to do stuff.
	//

	TraceFunctEnter( "CSessionSocket::AcceptInternal" ) ;


	//
	//	NOTE - once CIODriver::Init is called we should let sockets be destroyed
	//	through the regular shutdown process instead of having the caller destroy
	//	them - so in some failure cases we will return TRUE.  Initialize to FALSE
	//	for now.
	//

	BOOL	fFailureReturn = FALSE ;


    //
    // Get the source ip address
    //

    m_remoteIpAddress = paddr->sin_addr.s_addr;
    ErrorTrace(0,"Client IP is %s\n", inet_ntoa( paddr->sin_addr ));

	m_context.m_pInFeed = pFeed ;

	CSocketChannel*	pHandleChannel = new CSocketChannel() ;

	if (pHandleChannel == NULL) {
	    ErrorTrace((DWORD_PTR)this, "Out of memory");
	    return FALSE;
	}

	CIOPTR		pSSL = 0 ;
	CSTATEPTR	pStart = new CAcceptNNRPD() ;

	if (pStart == NULL) {
	    ErrorTrace((DWORD_PTR)this, "Out of memory");
	    goto Exit;
	}

	//
	//	Use reference counting temp pointer so that if the socket tears down while
	//	we're still trying to set it up we don't have to worry that our CIODriverSink()
	//	will destroy itself on another thread.
	//	
	m_pSink = pSink = new CIODriverSink( 0 ) ;

	if (pSink == NULL) {
	    ErrorTrace((DWORD_PTR)this, "Out of memory");
	    goto Exit;
	}

	if( fSSL ) {
		pSSL = new( *pSink ) CIOServerSSL( pStart, m_context.m_encryptCtx ) ;
		m_context.m_IsSecureConnection = TRUE ;
		if( pSSL == 0 )		{
	        ErrorTrace((DWORD_PTR)this, "Out of memory");
			goto Exit;
		}
		BumpSSLConnectionCounter();
	}	

	DebugTrace( (DWORD_PTR)this, "Accepted socket Sink %x HandleChannel %x", pSink, pHandleChannel ) ;

	if( pHandleChannel && pSink && pStart ) {
		DebugTrace( (DWORD_PTR)this, "All objects succesfully created !!" ) ;
		pHandleChannel->Init( h, this, patqContext ) ;

		if( pSink->Init( pHandleChannel, this, ShutdownNotification, this ) )	{
			fFailureReturn = TRUE ;
			m_pHandleChannel = pHandleChannel ;
			pHandleChannel = 0 ;
			if( pSSL == 0 ) {

				CIORead*	pRead = 0 ;
				CIOWrite*	pWrite = 0 ;
				if( pStart->Start( this, CDRIVERPTR( pSink ), pRead, pWrite ) ) {

					//
					//	When we call pSink->Start() errors can cause these
					//	CIO objects to have references even though the function failed.
					//	So we will make smart pointers of our own for these objects
					//	so that they get properly destroyed in error cases.
					//

					CIOPTR	pReadPtr = pRead ;
					CIOPTR	pWritePtr = pWrite ;

					if( pSink->Start( pReadPtr, pWritePtr, this ) ) {
						return	TRUE ;
					}	
				}	else	{
					ErrorTrace( (DWORD_PTR)this, "Failed to start state machine !" ) ;
					// Close down Sink and Channel
				}
			}	else	{
				if( pSink->Start( pSSL, pSSL, this ) )	{
					return	TRUE ;
				}
			}
		}
	}

Exit:
	if( pHandleChannel ) {
	    pHandleChannel->CloseSource(0);
		delete	pHandleChannel ;
	}
	return	fFailureReturn ;
}	//	CSessionSocket::Accept

BOOL
CSessionSocket::ConnectSocket(	sockaddr_in	*premote,	
								CInFeed* infeed,
								CAuthenticator*	pAuthenticator ) {
/*++

Routine Description :

	Connect to a remote server.
	This function will call ConnectSocketInternal to do the brunt of the work.
	We will ensure that if somebody tried to disconnect us before we were ready
	that we will actually eventually die.

Arguments :

	premote - The address to connect to
	peer -	The feed object to be used

Return Value :

	TRUE if successfully connected - caller must use Disconnect() to close us.
	FALSE otherwise - destroy this socket with delete().

--*/

	
	CDRIVERPTR	pSink ;

	if( ConnectSocketInternal( premote, infeed, pSink, pAuthenticator ) ) {

		if( InterlockedIncrement( &m_cTryDisconnect ) == 0 )	{

			_ASSERT( m_pSink != 0 ) ;

			m_pSink->UnsafeClose( this, m_causeDisconnect, m_dwErrorDisconnect ) ;

		}
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CSessionSocket::ConnectSocketInternal(
        sockaddr_in	*premote,
        CInFeed *infeed,
		CDRIVERPTR&	pSink,
		CAuthenticator*	pAuthenticator
        )	{
/*++

Routine Description :

	This function sets up the necessary state machines etc... to pull a feed from
	the remote server.

Arguments :

	premote - Address of the remote server.
	peer -	Feed object.
	pSInk - Reference to a smart pointer to the sink we create - this is done
		so that the caller can keep a reference and ensure that the CIODriverSink is
		not destroyed before the caller is ready
	pAuthenticator - object to handle authentication with remote server -
		WE ARE RESPONSIBLE FOR DESTRUCTION - whether we succeed or not we must
		ensure that this object gets destroyed. The caller is hands off !

Return Value :

	TRUE if succesfull, FALSE otherwise.


--*/

	//
	//	This function exists to initiate connections to other server.
	//	First, create a CSessionSocket, and then call us with the
	//	address and feed of the remote server.
	//

    ENTER("ConnectSocket")

	BOOL	fFailureReturn = FALSE ;
	m_context.m_pInFeed = infeed;

	m_remoteIpAddress = premote->sin_addr.s_addr ;

	//
	//	Do not send out timeout commands on these sessions !
	//
	m_fSendTimeout = FALSE ;

	//
	//	Try to create a socket
	//
	SOCKET	hSocket = 0 ;
	hSocket = socket( AF_INET, SOCK_STREAM, 0 ) ;
	if( hSocket == INVALID_SOCKET ) {
		DWORD dw = GetLastError() ;
		Assert( 1==0 ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	//
	//	Try to connect to the remote site
	//
	if( connect( hSocket, (struct sockaddr*)premote, sizeof( struct sockaddr ) ) != 0 ) {
		DWORD	dw = GetLastError() ;
		DWORD	dw2 = WSAGetLastError() ;
        ErrorTrace(0,"Error %d in connect\n",WSAGetLastError());
		closesocket( hSocket ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	//
	//	Get the name of the socket for our own use !
	//
	struct	sockaddr_in	sockName ;
	int		sockLength = sizeof( sockName ) ;
	if( !getsockname( hSocket, (sockaddr*)&sockName, &sockLength ) ) {
		m_localIpAddress = sockName.sin_addr.s_addr ;
	}
	

	//
	//	Allocate the objects we need to manage the session !
	//
	m_pHandleChannel = new CSocketChannel() ;

	if( m_pHandleChannel == 0 ) {
		closesocket( hSocket ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	m_pHandleChannel->Init( (HANDLE)hSocket, this ) ;


	pSink = m_pSink = new	CIODriverSink( 0 ) ;
	CCollectNewnews*	pNewnews = new CCollectNewnews( ) ;
	CSessionState*	pState = pNewnews ;
	if( m_context.m_pInFeed->fCreateAutomatically() )	{
		CCollectGroups*		pGroups = new CCollectGroups( pNewnews ) ;
		if( pGroups == 0 ) {
			delete	pNewnews ;
			if( pAuthenticator != 0 )
				delete	pAuthenticator ;
			return	FALSE ;
		}
		pState = pGroups ;
	}

	CSTATEPTR	ppull = new	CSetupPullFeed( pState ) ;
	if( ppull == 0 ) {
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}
	pState = ppull ;

	//
	//	NOW - plogon is a reference counting pointer - so any failure after
	//	this point will automatically destroy the CNNTPLogonToRemote object.
	//
	//	Additionally, all the state objects we have created so far are now
	//	pointed to by smart pointers in other state objects.  So we have no
	//	delete calls to make after this point regardless of failure conditions
	//	as the smart pointers will clean everything up automagically.
	//
	//	After passing pAuthenticator to the constructor of CNNTPLogonToRemote
	//	we are no longer responsible for its destruction - CNNTPLogonToRemote
	//	handles this in all cases, error or otherwise
	//


	CSTATEPTR	plogon = new CNNTPLogonToRemote( pState, pAuthenticator ) ;

	if( plogon == 0 ) {
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
	}

	if( pSink!= 0 && pNewnews != 0 && pState != 0 && plogon != 0 ) {
		if( m_pSink->Init( m_pHandleChannel, this, ShutdownNotification, this ) )	{
			fFailureReturn = TRUE ;

			CIORead*	pReadTemp = 0 ;
			CIOWrite*	pWriteTemp = 0 ;

			if( plogon->Start( this, pSink, pReadTemp, pWriteTemp ) )	{
	
				CIOPTR	pRead = pReadTemp ;
				CIOPTR	pWrite = pWriteTemp ;
			
				if( m_pSink->Start( pRead, pWrite, this) )	{
					return	TRUE ;
				}
			}
		}
	}

    LEAVE
	return	fFailureReturn ;
}	//	CSessionSocket::ConnectSocket


BOOL
CSessionSocket::ConnectSocket(	sockaddr_in	*premote,	
								COutFeed* pOutFeed,
								CAuthenticator*	pAuthenticator ) {
/*++

Routine Description :

	Connect to a remote server.
	This function will call ConnectSocketInternal to do the brunt of the work.
	We will ensure that if somebody tried to disconnect us before we were ready
	that we will actually eventually die.

Arguments :

	premote - The address to connect to
	peer -	The feed object to be used

Return Value :

	TRUE if successfully connected - caller must use Disconnect() to close us.
	FALSE otherwise - destroy this socket with delete().

--*/

	
	CDRIVERPTR	pSink ;

	if( ConnectSocketInternal( premote, pOutFeed, pSink, pAuthenticator ) ) {

		if( InterlockedIncrement( &m_cTryDisconnect ) == 0 )	{

			_ASSERT( m_pSink != 0 ) ;

			m_pSink->UnsafeClose( this, m_causeDisconnect, m_dwErrorDisconnect ) ;

		}
		return	TRUE ;
	}
	return	FALSE ;
}


BOOL
CSessionSocket::ConnectSocketInternal(
        sockaddr_in	*premote,
        COutFeed*	pOutFeed,
		CDRIVERPTR&	pSink,
		CAuthenticator*	pAuthenticator
        )	{
/*++

Routine Description :

	This function sets up the necessary state machines etc... to pull a feed from
	the remote server.

Arguments :

	premote - Address of the remote server.
	peer -	Feed object.
	pSInk - Reference to a smart pointer to the sink we create - this is done
		so that the caller can keep a reference and ensure that the CIODriverSink is
		not destroyed before the caller is ready
	pAuthenticator - object to handle authentication with remote server -
		WE ARE RESPONSIBLE FOR DESTRUCTION - whether we succeed or not we must
		ensure that this object gets destroyed. The caller is hands off !

Return Value :

	TRUE if succesfull, FALSE otherwise.


--*/

	//
	//	This function exists to initiate connections to other server.
	//	First, create a CSessionSocket, and then call us with the
	//	address and feed of the remote server.
	//

    ENTER("ConnectSocket")

	BOOL	fFailureReturn = FALSE ;

	m_remoteIpAddress = premote->sin_addr.s_addr ;

	//
	//	Do not send out timeout commands on these sessions !
	//
	m_fSendTimeout = FALSE ;

	//
	//	Try to create a socket
	//
	SOCKET	hSocket = 0 ;
	hSocket = socket( AF_INET, SOCK_STREAM, 0 ) ;
	if( hSocket == INVALID_SOCKET ) {
		DWORD dw = GetLastError() ;
		Assert( 1==0 ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	//
	//	Bind the socket so this virtual server's IP is found by remote end
	//
	DWORD localIpAddress = (m_context.m_pInstance)->QueryServerIP();
	if( localIpAddress ) {
    	SOCKADDR_IN localAddr;
	    localAddr.sin_family = AF_INET;
	    localAddr.sin_addr.s_addr = localIpAddress;
	    localAddr.sin_port = 0;

	    if( bind( hSocket, (const struct sockaddr FAR*) &localAddr, sizeof(sockaddr) )) {
		    DWORD	dw = GetLastError() ;
		    DWORD	dw2 = WSAGetLastError() ;
            ErrorTrace(0,"Error %d in connect WSA is %d \n",dw, dw2);
		    closesocket( hSocket ) ;
		    if( pAuthenticator != 0 )
			    delete	pAuthenticator ;
		    return	FALSE ;
        }

        PCHAR args [2];
        CHAR  szId [20];

        _itoa( (m_context.m_pInstance)->QueryInstanceId(), szId, 10 );
        args [0] = szId;
        args [1] = inet_ntoa( localAddr.sin_addr );
        NntpLogEvent( NNTP_OUTBOUND_CONNECT_BIND, 2, (const CHAR**) args, 0 );
	}
	
	//
	//	Try to connect to the remote site
	//
	if( connect( hSocket, (struct sockaddr*)premote, sizeof( struct sockaddr ) ) != 0 ) {
		DWORD	dw = GetLastError() ;
		DWORD	dw2 = WSAGetLastError() ;
        ErrorTrace(0,"Error %d in connect\n",WSAGetLastError());
		closesocket( hSocket ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	//
	//	Get the name of the socket for our own use !
	//
	struct	sockaddr_in	sockName ;
	int		sockLength = sizeof( sockName ) ;
	if( !getsockname( hSocket, (sockaddr*)&sockName, &sockLength ) ) {
		m_localIpAddress = sockName.sin_addr.s_addr ;
	}	else	{
		DWORD	dw = WSAGetLastError() ;
	}
	
	//
	//	Create the objects we need to manage the session !
	//
	m_pHandleChannel = new CSocketChannel() ;
	if( m_pHandleChannel == 0 ) {
		closesocket( hSocket ) ;
		if( pAuthenticator != 0 )
			delete	pAuthenticator ;
		return	FALSE ;
	}

	m_pHandleChannel->Init( (HANDLE)hSocket, this ) ;

	pSink = m_pSink = new	CIODriverSink( 0 ) ;
	m_context.m_pOutFeed = pOutFeed ;

	CSTATEPTR	pState ;
	if( pOutFeed->SupportsStreaming() ) {

		pState = new	CNegotiateStreaming() ;	
		
	}	else	{

		pState = new	COfferArticles(	) ;

	}
	
	//
	//	After passing pAuthenticator to the constructor of CNNTPLogonToRemote
	//	we are no longer responsible for its destruction - CNNTPLogonToRemote
	//	handles this in all cases, error or otherwise
	//
	CSTATEPTR	plogon = new CNNTPLogonToRemote( pState, pAuthenticator ) ;

	if( plogon == 0 ) {
		if( pAuthenticator == 0 )
			delete	pAuthenticator ;
	}

	if( pSink!= 0 && pState != 0 && plogon != 0 ) {
		if( m_pSink->Init( m_pHandleChannel, this, ShutdownNotification, this ) )	{
			fFailureReturn = TRUE ;

			CIORead*	pReadTemp = 0 ;
			CIOWrite*	pWriteTemp = 0 ;

			if( plogon->Start( this, pSink, pReadTemp, pWriteTemp ) )	{

				CIOPTR	pRead = pReadTemp ;	
				CIOPTR	pWrite = pWriteTemp ;

				if( m_pSink->Start( pRead, pWrite, this) )	{
					return	TRUE ;
				}
			}
			pState = 0 ;
			plogon = 0 ;
		}
	}

    LEAVE
	return	fFailureReturn ;
}	//	CSessionSocket::ConnectSocket



void
CSessionSocket::Disconnect( SHUTDOWN_CAUSE	cause,	
							DWORD	dwError )	{
	//
	//	This function should terminate a session !
	//
	//m_pHandleChannel->Close( ) ;

	if( cause == CAUSE_TIMEOUT &&
		!m_fSendTimeout ) {
		cause = CAUSE_SERVER_TIMEOUT ;
	}

	m_causeDisconnect = cause ;
	m_dwErrorDisconnect = dwError ;

	if( InterlockedIncrement( &m_cCallDisconnect ) == 0 ) {

		if( InterlockedIncrement( &m_cTryDisconnect ) == 0 )	{
			_ASSERT( m_pSink != 0 ) ;
			if( m_pSink != 0 )
				m_pSink->UnsafeClose( this, cause, dwError ) ;
		}
	}
}

BOOL
CSessionSocket::BindInstanceAccessCheck()
/*++

Routine Description:

    Bind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
    if ( m_rfAccessCheck.CopyFrom( (m_context.m_pInstance)->QueryMetaDataRefHandler() ) )
    {
        m_acAccessCheck.BindCheckList( (LPBYTE)m_rfAccessCheck.GetPtr(), m_rfAccessCheck.GetSize() );
        return TRUE;
    }
    return FALSE;
}

VOID
CSessionSocket::UnbindInstanceAccessCheck()
/*++

Routine Description:

    Unbind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_acAccessCheck.UnbindCheckList();
    m_rfAccessCheck.Reset( (IMDCOM*) g_pInetSvc->QueryMDObject() );
}

#ifdef	PROFILE
static	int count = 0 ;
#endif

void
CSessionSocket::ShutdownNotification(
        void    *pv,
        SHUTDOWN_CAUSE  cause,
        DWORD   dw
        )
{

	//
	//	This function is registered with all CIODriver's which control
	//	Socket IO completion.  This will be called when all activity
	//	related to a socket has completed and it can be safely destoyed !
	//

    CInFeed *peer;

    ENTER("ShutdownNotification")

    Assert( pv != 0 ) ;

    CSessionSocket*	pSocket = (CSessionSocket*)pv ;

    //
    // Call feed manager completion
    //

    peer = pSocket->m_context.m_pInFeed;

	if( peer != 0 ) {
		CompleteFeedRequest(
			(pSocket->m_context).m_pInstance,
			peer->feedCompletionContext(),
			peer->GetSubmittedFileTime(),
			(cause == CAUSE_LEGIT_CLOSE) ||
			(cause == CAUSE_USERTERM),
			cause == CAUSE_NODATA
			);
		delete peer;
	}

	if( pSocket->m_context.m_pOutFeed != 0 ) {

		FILETIME	ft ;
		ZeroMemory( &ft, sizeof( ft ) ) ;
	
		CompleteFeedRequest(	
			(pSocket->m_context).m_pInstance,
			pSocket->m_context.m_pOutFeed->feedCompletionContext(),
			ft,
			(cause == CAUSE_NODATA) ||
			(cause == CAUSE_LEGIT_CLOSE) ||
			(cause == CAUSE_USERTERM),
			cause == CAUSE_NODATA
			);
		delete	pSocket->m_context.m_pOutFeed ;
	}

			


    delete pSocket ;
}

DWORD
CSessionSocket::EnumerateSessions(
					IN  PNNTP_SERVER_INSTANCE pInstance,
                    OUT LPNNTP_SESS_ENUM_STRUCT Buffer
                    )
{
    DWORD err = NO_ERROR;
    LPNNTP_SESSION_INFO sessInfo;
    DWORD nEntries;

    ENTER("EnumerateSessions")

    //
    // grab the critsec so the number does not change
    //

    Buffer->EntriesRead = 0;
    Buffer->Buffer = NULL;

    ACQUIRE_LOCK( &(pInstance->m_pInUseList)->m_critSec );

    nEntries = (pInstance->m_pInUseList)->GetListCount();

    if ( nEntries > 0 ) {

        sessInfo = (LPNNTP_SESSION_INFO)
            MIDL_user_allocate(nEntries * sizeof(NNTP_SESSION_INFO));

        if ( sessInfo == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        ZeroMemory(sessInfo, nEntries * sizeof(NNTP_SESSION_INFO));

    } else {

        //
        // No sessions, exit
        //

        goto cleanup;
    }

    //
    //  dwEntriesRead must be set to 0 and it will be updated to the
    //  correct final value by EnumUsers call below
    //

    Buffer->Buffer = sessInfo;

    (VOID)(pInstance->m_pInUseList)->EnumClientSess((ENUMSOCKET)EnumSessInfo, 0, (PVOID)Buffer);
    _ASSERT(Buffer->EntriesRead <= nEntries);

cleanup:

    RELEASE_LOCK( &(pInstance->m_pInUseList)->m_critSec );
    LEAVE
    return  err;

} // EnumerateSessions

BOOL
EnumSessInfo(
    IN CSessionSocket * pSess,
    IN DWORD dwParam,
    IN LPNNTP_SESS_ENUM_STRUCT Buffer
    )
{
    LPNNTP_SESSION_INFO sessInfo;

    ENTER("EnumSessInfo");

    //
    // Point to correct location
    //

    sessInfo = Buffer->Buffer + Buffer->EntriesRead;

    //
    // Copy info to the buffer
    //

	LPSTR	lpstrUser = pSess->GetUserName() ;
	if( lpstrUser )
	    lstrcpy( sessInfo->UserName, lpstrUser );
	else
		sessInfo->UserName[0] = '\0' ;

    pSess->GetStartTime( &sessInfo->SessionStartTime );
    sessInfo->IPAddress = pSess->GetClientIP( );
    sessInfo->PortConnected = pSess->GetIncomingPort( );
    sessInfo->fAnonymous = ((pSess->m_context).m_securityCtx).IsAnonymous();

    Buffer->EntriesRead++;

    return(TRUE);

} // EnumSessInfo

BOOL
CSocketList::EnumClientSess(
    ENUMSOCKET pfnSess,
    DWORD dwParam,
    PVOID pParam
    )
{
    BOOL    bContinue = TRUE;

    ENTER("EnumSess");
    ACQUIRE_LOCK( &m_critSec );
    for ( CSessionSocket* pSess = m_pListHead;
          bContinue && pSess != (CSessionSocket*)NULL;
          ) {

        CSessionSocket*  pNext = pSess->m_pNext;

        //
        // Don't send outgoing connections
        //

        if ( pSess->GetClientIP( ) != INADDR_NONE ) {
            bContinue = (*pfnSess)( pSess, dwParam, pParam );
        }

        pSess = pNext;
    }

    RELEASE_LOCK( &m_critSec );

    return  bContinue;

} // EnumClientSess

BOOL
CSocketList::EnumAllSess(
    ENUMSOCKET pfnSess,
    DWORD dwParam,
    PVOID pParam
    )
{
    BOOL    bContinue = TRUE;

    ENTER("EnumSess");
    ACQUIRE_LOCK( &m_critSec );
    for ( CSessionSocket* pSess = m_pListHead;
          bContinue && pSess != (CSessionSocket*)NULL;
          ) {

        CSessionSocket*  pNext = pSess->m_pNext;

        bContinue = (*pfnSess)( pSess, dwParam, pParam );
        pSess = pNext;
    }

    RELEASE_LOCK( &m_critSec );

    return  bContinue;

} // EnumAllSess

BOOL
CloseSession(
    IN CSessionSocket * pSess,
    IN DWORD IPAddress,
    IN LPSTR UserName
    )
{
    ENTER("CloseSession");

    //
    // Do the ip addresses match?
    //

    if ( (IPAddress == INADDR_ANY) ||
         (IPAddress == pSess->GetClientIP()) ) {

        //
        // ip addresses match, check user name
        //
		LPSTR	lpstrUser = pSess->GetUserName() ;

        if ( (UserName == NULL) ||
             (lpstrUser != NULL && !lstrcmpi(UserName,lpstrUser)) ) {

            IN_ADDR addr;

            //
            // Terminate!
            //

            addr.s_addr = pSess->GetClientIP( );
            DebugTrace(0,"Closed session (user %s[%s])\n",
                pSess->GetUserName(), inet_ntoa(addr) );

            pSess->Disconnect(
                CAUSE_FORCEOFF,
                ERROR_VC_DISCONNECTED   // we might want to change this to
                );                      // something else.
        }
    }

    return(TRUE);

} // CloseSession

DWORD
CSessionSocket::TerminateSession(
					IN PNNTP_SERVER_INSTANCE pInstance,
                    IN LPSTR UserName,
                    IN LPSTR IPAddress
                    )
{
    DWORD ip;
    DWORD err = ERROR_SUCCESS;

    ENTER("TerminateSession")

	if( UserName != 0  &&
		*UserName == '\0' ) {
		UserName = 0 ;
	}

    //
    // Get IP Address
    //

    if ( IPAddress != NULL ) {

        ip = inet_addr(IPAddress);

        //
        // if this is not an ip address, then maybe this is a host name
        //

        if ( ip == INADDR_NONE ) {

            PHOSTENT hp;
            IN_ADDR addr;

            //
            // Ask the dns for the address
            //

            hp = gethostbyname( IPAddress );
            if ( hp == NULL ) {
                err = WSAGetLastError();
                ErrorTrace(0,"Error %d in gethostbyname(%s)\n",err,IPAddress);
                return(NERR_ClientNameNotFound);
            }

            addr = *((PIN_ADDR)*hp->h_addr_list);
            ip = addr.s_addr;
        }

    } else {

        //
        // delete on all ip
        //

        ip = INADDR_ANY;
    }

    (VOID)(pInstance->m_pInUseList)->EnumClientSess((ENUMSOCKET)CloseSession, ip, (PVOID)UserName);
    return(err);

} // TerminateSession

void
CLogCollector::FillLogData(	LOG_DATA	ld,	
							BYTE*		lpb,	
							DWORD		cb ) {

	_ASSERT( ld >= LOG_OPERATION && ld <= LOG_PARAMETERS ) ;
	_ASSERT( lpb != 0 ) ;
	_ASSERT( cb != 0 ) ;

	DWORD	cbAvailable = sizeof( m_szOptionalBuffer ) - m_cbOptionalConsumed ;
	DWORD	cbToCopy = min( cbAvailable, cb ) ;

	if( cbToCopy != 0 ) {

		m_Logs[ld] = (char*) m_szOptionalBuffer + m_cbOptionalConsumed ;
		m_LogSizes[ld] = cbToCopy ;

		//
		//	Do Some arithmetic to leave space for terminating NULL char
		//
		if( cbToCopy == cbAvailable ) {
			cbToCopy -- ;
		}

		CopyMemory( m_szOptionalBuffer + m_cbOptionalConsumed, lpb, cbToCopy ) ;
		m_cbOptionalConsumed += cbToCopy ;

		//
		//	Append a NULL char - space must have been reserved !
		//
		m_szOptionalBuffer[m_cbOptionalConsumed++] = '\0' ;
	}
}

void
CLogCollector::ReferenceLogData(	LOG_DATA	ld,
									BYTE*		lpb ) {

	_ASSERT( ld >= LOG_OPERATION && ld <= LOG_PARAMETERS ) ;
	_ASSERT( lpb != 0 ) ;

	m_Logs[ld]  = (char*) lpb ;

}

BYTE*
CLogCollector::AllocateLogSpace(	DWORD	cb )	{

	BYTE*	lpb = 0 ;

	if( cb < (sizeof( m_szOptionalBuffer ) - m_cbOptionalConsumed) )	{
    	_ASSERT( m_cAllocations ++ < 3 ) ;
		lpb = &m_szOptionalBuffer[m_cbOptionalConsumed] ;
		m_cbOptionalConsumed += cb ;
	}
	return	lpb ;
}

//
// Maximum length of an error msg (copied from w3)
//

#define     MAX_ERROR_MESSAGE_LEN   (500)
BOOL
CSessionSocket::TransactionLog(
                    CLogCollector*	pCollector,
					DWORD			dwProtocol,
					DWORD			dwWin32,
					BOOL			fInBound
                    )
{
	if( !pCollector ) {

		return	TransactionLog( NULL, (LPSTR)NULL, NULL ) ;

	}	else	{

		BOOL	fRtn = TransactionLog( pCollector->m_Logs[LOG_OPERATION],
						pCollector->m_Logs[LOG_TARGET],
						pCollector->m_Logs[LOG_PARAMETERS],
						pCollector->m_cbBytesSent,
						pCollector->m_cbBytesRecvd,
						dwProtocol,
						dwWin32,
						fInBound ) ;
		pCollector->Reset() ;
		return	fRtn ;

	}
} // TransactionLog

BOOL
CSessionSocket::TransactionLog(
					LPSTR	lpstrOperation,	
					LPSTR	lpstrTarget,
					LPSTR	lpstrParameters
					)
{
	STRMPOSITION cbJunk1;
	DWORD cbJunk2 = 0;
	ASSIGNI( cbJunk1, 0 );

	return TransactionLog( lpstrOperation, lpstrTarget, lpstrParameters, cbJunk1, cbJunk2 );
}

BOOL
CSessionSocket::TransactionLog(
					LPSTR	lpstrOperation,	
					LPSTR	lpstrTarget,
					LPSTR	lpstrParameters,
					STRMPOSITION	cbBytesSent,
					DWORD	cbBytesRecvd,
					DWORD	dwProtocol,
					DWORD	dwWin32,
					BOOL	fInBound
                    )
{
    INETLOG_INFORMATION request;
    CHAR ourIP[32];
    CHAR theirIP[32];
    CHAR pszError[MAX_ERROR_MESSAGE_LEN] = "";
    DWORD cchError= MAX_ERROR_MESSAGE_LEN;
	LPSTR lpUserName;
	LPSTR lpNull = "";
    static char szNntpVersion[]="NNTP";
    DWORD err;
    IN_ADDR addr;
    FILETIME now;
    ULARGE_INTEGER liStart;
    ULARGE_INTEGER liNow;

    ENTER("TransactionLog")

	//
	// see if we are only logging errors.
	//
	if (m_context.m_pInstance->GetCommandLogMask() & eErrorsOnly) {
		// make sure that this is an error (dwProtocol >= 400 and < 600)
		if (!(NNTPRET_IS_ERROR(dwProtocol))) return TRUE;
	}

    //
    // Fill out client information
    //

	ZeroMemory( &request, sizeof(request));
	
    addr.s_addr = m_remoteIpAddress;
    lstrcpy(theirIP, inet_ntoa( addr ));
    request.pszClientHostName = theirIP;
    request.cbClientHostName = strlen(theirIP);


    //
    // user logged on as?
    //

	if( fInBound ) {
		if( lpUserName = GetUserName() ) {
			request.pszClientUserName = lpUserName;
		} else {
			request.pszClientUserName = "<user>";
		}
	}	else	{
		request.pszClientUserName = "<feed>" ;
	}

    //
    // Who are we ?
    //

    addr.s_addr = m_localIpAddress;
    lstrcpy(ourIP,inet_ntoa( addr ));
    request.pszServerAddress = ourIP;

    //
    // How long were we processing this?
    //

    GetSystemTimeAsFileTime( &now );
    LI_FROM_FILETIME( &liNow, &now );
    LI_FROM_FILETIME( &liStart, &m_startTime );

    //
    // Get the difference of start and now.  This will give
    // us total 100 ns elapsed since the start.  Convert to ms.
    //

    liNow.QuadPart -= liStart.QuadPart;
    liNow.QuadPart /= (ULONGLONG)( 10 * 1000 );
    request.msTimeForProcessing = liNow.LowPart;

    //
    // Bytes sent/received
    //
	//CopyMemory( &request.liBytesSent, &cbBytesSent, sizeof(cbBytesSent) );
	request.dwBytesSent  = (DWORD)(LOW(cbBytesSent));
    request.dwBytesRecvd = cbBytesRecvd ;

    //
    // status
    //

    request.dwWin32Status = dwWin32;
	request.dwProtocolStatus = dwProtocol ;

	if( lpstrOperation ) {
		request.pszOperation = lpstrOperation ;
		request.cbOperation  = strlen(lpstrOperation);
	} else {
		request.pszOperation = lpNull;
		request.cbOperation  = 0;
	}

	if( lpstrTarget ) {
		request.pszTarget = lpstrTarget ;
		request.cbTarget = strlen(lpstrTarget) ;
	} else {
		request.pszTarget = lpNull;
		request.cbTarget  = 0;
	}

	if( lpstrParameters ) {
		request.pszParameters = lpstrParameters ;
	} else {
		request.pszParameters = lpNull;
	}

	request.cbHTTPHeaderSize = 0 ;
	request.pszHTTPHeader = NULL ;

	request.dwPort = m_nntpPort;
    request.pszVersion = szNntpVersion;

    //
    // Do the actual logging
    //

    err = ((m_context.m_pInstance)->m_Logging).LogInformation( &request );

    if ( err != NO_ERROR ) {
        ErrorTrace(0,"Error %d Logging information!\n",GetLastError());
        return(FALSE);
    }

    return(TRUE);

} // TransactionLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\state.cpp ===
/*++

	state.cpp

	This file contains all the source code for mosts states that we run in our state
	machines.

	Each state has a number of completion functions (one for each different kind of IO
	operation it may issue) and a Start function.

	The Start function is called when the state is entered in order to get the initial
	IO operation rolling.  After that, the Completion functions are called as each IO
	operation completes.  It is up to the state to handle transitions to other states
	and to know what the next state should be.

--*/



#include	<stdlib.h>
#include	"tigris.hxx"
#include	"commands.h"


const	unsigned	cbMAX_STATE_SIZE = MAX_STATE_SIZE ;

//
//	ALL CSessionState derived objects allocated from this Pool !!!!
//
CPool	CSessionState::gStatePool(SESSION_STATE_SIGNATURE) ;

BOOL
NNTPCreateTempFile(	LPSTR	lpstrDir,	LPSTR	lpstrFile ) {
	//
	//	This is a utility function used whereever we are creating temp files to save
	//	articles into.  if adds a couple more digits of randomness to the file name
	//	then ordinary GetTempFileName seems to provide.
	//
	char	szPrefix[12] ;
	
	wsprintf( szPrefix, "a%02d", GetTickCount() & 0x0000ffff ) ;
	szPrefix[3] = '\0' ;

	return	GetTempFileName( lpstrDir, szPrefix, 0, lpstrFile ) != 0 ;
}

BOOL
FGenerateErrorFile(	NRC	nrcCode ) {

	switch( nrcCode ) {
		case	nrcOpenFile :
		case	nrcPathLoop :
		case	nrcErrorReadingReg :
		case	nrcArticleInitFailed :
		case	nrcHashSetArtNumSetFailed :
		case	nrcHashSetXrefFailed :
		case	nrcArticleXoverTooBig :
		case	nrcCreateNovEntryFailed :
		case	nrcHashSetFailed :
		case	nrcArticleTableCantDel :
		case	nrcArticleTableError :
		case	nrcCantAddToQueue :
		case	nrcNotYetImplemented :
		case	nrcNewsgroupDescriptionTooLong :
		case	nrcGetGroupFailed : 		
			return	TRUE ;
			break ;
	}
	return	FALSE ;
}

void
BuildCommandLogString(	int	cArgs, char **pszArgs, char	*szBuff, DWORD	cbBuff ) {

	for( int i=0; i<cArgs && cbBuff != 0;  i++ ) {

		DWORD	cb = lstrlen( pszArgs[i] ) ;
		DWORD	cbToCopy = min( cb, cbBuff-1 ) ;
		
		CopyMemory( szBuff, pszArgs[i], cbToCopy ) ;
		szBuff += cbToCopy ;
		*szBuff++ = ' ' ;
		cbBuff -= cbToCopy + 1 ;
	}
	if ( i != 0 ) szBuff[-1] = '\0' ;
}

void
OutboundLogFill(	CSessionSocket*	pSocket,
					LPBYTE	pb,
					DWORD	cb	
					)	{
/*++

Routine Description :

	Fill the transaction logging buffer in perparation for issuing a commmand !

Arguments :

	pSocket - Socket we are logging !
	pb - The Data to be written !
	cb - Length of Data, including CRLF.

Return Value :

	None

--*/

	//
	//	Exclude the CRLF !
	//
	cb -= 2 ;

	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush )	{
		
		//
		//	Find a white space character to separate the command from its arguments !
		//
		_ASSERT( !isspace( (UCHAR)pb[0] ) ) ;
		for( DWORD i=0; i<cb; i++ )	{
			if( isspace( (UCHAR)pb[i] ) ) {
				pSocket->m_Collector.FillLogData( LOG_OPERATION, pb, i ) ;
				break ;
			}
		}

		if( i==cb ) {
			pSocket->m_Collector.FillLogData( LOG_OPERATION, pb, min( cb, 200 ) ) ;
		}	else	{
			pSocket->m_Collector.FillLogData( LOG_PARAMETERS, pb+i, min( cb-i, 200 ) ) ;	// -2 to exclude CRLF
		}
		ADDI( pSocket->m_Collector.m_cbBytesSent, cb );	
	}
}

void
OutboundLogResults(	CSessionSocket*	pSocket,
				    BOOL			fValidNRC,
				    NRC				nrc,
					int				cArgs,
					char**			pszArgs,
                    NRC             nrcWin32 = (NRC)0
					)	{

	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush )	{
		char	szBuff[200] ;
		if( fValidNRC ) {
			_ASSERT( pszArgs != 0 ) ;
			// If args following nrc are missing, use nrc
			if( cArgs > 1 ) {
				cArgs -- ;
				pszArgs++ ;
			}
		}
        if( pszArgs ) {
		    BuildCommandLogString( cArgs, pszArgs, szBuff, sizeof( szBuff ) ) ;
		    pSocket->m_Collector.ReferenceLogData( LOG_TARGET, (LPBYTE)szBuff ) ;
        }
		pSocket->TransactionLog( &pSocket->m_Collector, nrc, nrcWin32, FALSE ) ;
	}
}

void
OutboundLogAll(	CSessionSocket*	pSocket,
				    BOOL			fValidNRC,
				    NRC				nrc,
					int				cArgs,
					char**			pszArgs,
					char*			lpstrCommand
					)	{

	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush )	{

		pSocket->m_Collector.ReferenceLogData( LOG_OPERATION, (LPBYTE)lpstrCommand ) ;

		char	szBuff[200] ;
		szBuff[0] = '\0' ;
		if( fValidNRC ) {
			_ASSERT( cArgs >1 ) ;
			_ASSERT( pszArgs != 0 ) ;
			cArgs -- ;
			pszArgs++ ;
		}
		BuildCommandLogString( cArgs, pszArgs, szBuff, sizeof( szBuff ) ) ;
		pSocket->m_Collector.ReferenceLogData( LOG_TARGET, (LPBYTE)szBuff ) ;
		pSocket->TransactionLog( &pSocket->m_Collector, nrc, 0, FALSE ) ;
	}
}

static
BOOL
DeleteArticleById(CNewsTreeCore* pTree, GROUPID groupId, ARTICLEID articleId) {

    TraceQuietEnter("DeleteArticleById");

    CNntpSyncComplete scComplete;
    CNNTPVRoot* pVRoot = NULL;
    INNTPPropertyBag *pPropBag = NULL;
    BOOL fOK = FALSE;
    HRESULT hr;

    if (pTree == NULL || groupId == INVALID_GROUPID || articleId == INVALID_ARTICLEID) {
        ErrorTrace(0, "Invalid arguments");
        return FALSE;
    }

    CGRPCOREPTR pGroup = pTree->GetGroupById(groupId);
    if (pGroup == NULL) {
        ErrorTrace(0, "Could not GetGroupById");
        goto Exit;
    }

    pVRoot = pGroup->GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        goto Exit;
    }

    //
    // Set vroot to completion object
    //
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = pGroup->GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        goto Exit;
    }

    pVRoot->DeleteArticle(
	    pPropBag,           // Group property bag
	    1,                  // Number of articles
	    &articleId,
	    NULL,               // Store ID
	    NULL,               // Client Token
	    NULL,               // piFailed
	    &scComplete,
	    FALSE);             // anonymous

    // Wait for it to complete
    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();

    // Property bag should have already been released
    pPropBag = NULL;

    if (SUCCEEDED(hr)) {
        fOK = TRUE;
    }

Exit:
    if (pVRoot) {
        pVRoot->Release();
    }
    if (pPropBag) {
        pPropBag->Release();
    }

    return fOK;

}

BOOL
CSessionState::InitClass()	{

	return	gStatePool.ReserveMemory( MAX_STATES, max( cbMAX_STATE_SIZE, cbMAX_CIOEXECUTE_SIZE ) ) ; 	

}

BOOL
CSessionState::TermClass()	{

	TraceFunctEnter( "CSessionState::TermClass()" ) ;
	DebugTrace( 0, "CSessionState - GetAllocCount %d", gStatePool.GetAllocCount() ) ;

	_ASSERT( gStatePool.GetAllocCount() == 0 ) ;
	return	gStatePool.ReleaseMemory() ;

}


CSessionState::~CSessionState()	{
	TraceFunctEnter( "CSessionState::~CSessionState" ) ;
	DebugTrace( (DWORD_PTR)this, "destroying myself" ) ;
}

CIO*	
CSessionState::Complete(	CIOReadLine*,		// The CIOReadLine object which completed
							CSessionSocket*,	// The socket on which the operation completed
							CDRIVERPTR&,		// The CIODriver object on which the operation completed
							int,				// The number of arguments on the line
							char **,			// Array of pointers to NULL separated arguments
							char* )	{			// Pointer to the beginning of the buffer we can use

	//
	//	ReadLine completion function.
	//
	//  Every state which issues a CIOReadLine operation will have a function
	//	identical to this one.
	//
	//	Every Completion function will have similar first 3 arguments -
	//	These are - The CIO derived object which completed its operation
	//	The Socket associated with the operation.
	//	The CIOdriver derived object through which all the IO happened.
	//	(Every Socket has a CIODriver, sometimes there are more then one CIODriver
	//	objects such as in states where we are copying from a socket to a file.)
	//	
	//	The completion functiosn in the base CIO function MUST BE OVERRIDDEN
	//	by any state which issues an IO of that type !!
	//
	//	With one exception all such Completion functions return a new CIO object
	//	which is to take the place of the just completed CIO object.
	//


	_ASSERT( 1==0 ) ;
	return	0 ;
}

CIO*
CSessionState::Complete(	CIOWriteLine*,	
							CSessionSocket*,	
							CDRIVERPTR& )	{

	//
	//	Completion function for writing a line of text.
	//	Nobody cares too much what was sent, just that it completed !
	//
	
	_ASSERT( 1==0 ) ;
	return	0 ;
}

CIO*
CSessionState::Complete(	CIOWriteCMD*,
							CSessionSocket*,
							CDRIVERPTR&,
							class	CExecute*,
							class	CLogCollector* ) {

	_ASSERT( 1==0 ) ;
	return	0 ;
}

CIO*
CSessionState::Complete(	CIOWriteAsyncCMD*,
							CSessionSocket*,
							CDRIVERPTR&,
							class	CAsyncExecute*,
							class	CLogCollector*
							)	{
	_ASSERT( 1==0 ) ;
	return	0 ;
}

void
CSessionState::Complete(	CIOReadArticle*,	
							CSessionSocket*,
							CDRIVERPTR&,	
							CFileChannel&,
							DWORD	)	{
	//
	//	Completion function for CIOReadArticle objects
	//	CIOReadArticle objects copy an entire file from a socket into a file handle.
	//
	//	THIS function does not return a new CIO object as we are called when the
	//	final WRITE to the file completes, instead of when the last socket read occurs.
	//	
	//
	_ASSERT( 1==0 ) ;
}

CIO*
CSessionState::Complete(	CIOTransmit*,	
							CSessionSocket *,
							CDRIVERPTR&,
							TRANSMIT_FILE_BUFFERS*,
							unsigned ) {
	//
	//	Completion function for CIOTransmit - which sends an entire file to a client.
	//
	_ASSERT( 1==0 ) ;
	return 0 ;
}

void
CSessionState::Complete(	CIOGetArticle*,
							CSessionSocket*,
							NRC	code,
							char*	header,
							DWORD	cbHeader,
							DWORD	cbArticle,
							DWORD	cbTotalBuffer,
							HANDLE	hFile,
							DWORD	cbGap,
							DWORD	cbTotalTransfer )	{

	_ASSERT( 1==0 ) ;
}

CIO*
CSessionState::Complete(	CIOGetArticleEx*,
							CSessionSocket*
							)	{
	_ASSERT( 1==0 ) ;
	return	0 ;
}

void
CSessionState::Complete(	CIOGetArticleEx*,
							CSessionSocket*,
							FIO_CONTEXT*	pFIOContext,
							DWORD	cbTransfer
							)	{
	_ASSERT( 1==0 ) ;
}


CIO*
CSessionState::Complete(	CIOGetArticleEx*,
							CSessionSocket*,
							BOOL		fGoodMatch,
							CBUFPTR&	pBuffer,
							DWORD		ibStart,
							DWORD		cb
							)	{
	_ASSERT( 1==0 ) ;
	return	0 ;
}






CIO*
CSessionState::Complete(	CIOMLWrite*,
							CSessionSocket*,
							CDRIVERPTR&	
							)	{

	_ASSERT( 1==0 ) ;
	return	0 ;
}

void
CSessionState::Shutdown(	CIODriver&	driver,	
							CSessionSocket*	pSocket,	
							SHUTDOWN_CAUSE	cause,
							DWORD		dwError ) {

	//
	//	States which have stuff that needs to be killed when a session dies
	//	should do so now.  It is important to kill anything which may
	//	have a circular reference to something or other.
	//
	//	This function can be called simultaneously as the completion functions
	//	so it is best not to zap member variables unless the state is designed
	//	explicitly to support that.  Instead start closing all objects.
	//	(ie. if you have a CIODriver call its UnsafeClose() method.
	//
}
	

CNNTPLogonToRemote::CNNTPLogonToRemote(	CSessionState*	pNext,
										class CAuthenticator* pAuthenticator ) :
	m_pNext( pNext ),
	m_pAuthenticator( pAuthenticator ),
	m_fComplete( FALSE ),
	m_fLoggedOn( FALSE ),
	m_cReadCompletes( 0 )	{
	
	//
	//	This state handles all logon stuff required to connect to a remote server
	//	Currently the only thing we hold is a pointer to the next state to execute.
	//

	TraceFunctEnter( "CNNTPLogonToRemote::CNNTPLogonToRemote" ) ;
	DebugTrace( (DWORD_PTR)this, "new CNNTPLogoToRemote" ) ;

	_ASSERT( m_pNext != 0 ) ;
}

CNNTPLogonToRemote::~CNNTPLogonToRemote()	{
	//
	//	Blow away the subsequent state - if we had wanted to transition to that
	//	state the m_pNext pointer would be NULL when we reached here.
	//

	TraceFunctEnter(	"CNNTPLogonToRemote::~CNNTPLogonToRemote" ) ;

	DebugTrace( (DWORD_PTR)this, "destroying CNNTPLogonToRemote object - m_pNext %x", m_pNext ) ;

	if( m_pAuthenticator ) {
		delete	m_pAuthenticator ;
	}
}

BOOL
CNNTPLogonToRemote::Start(	CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,
							CIORead*&	pIORead,	
							CIOWrite*&	pIOWrite )	{

	//
	//	Create the initial CIO objects for the new connection.
	//	In our case, we want to read the remote servers welcome message first thing.
	//

	_ASSERT( pIORead == 0 ) ;
	_ASSERT( pIOWrite == 0 ) ;
	pIORead = 0 ;
	pIOWrite = 0 ;

	CIOReadLine*	pIOReadLine = new( *pdriver ) CIOReadLine( this ) ;

	if( pIOReadLine )	{
		pIORead = pIOReadLine ;
		return	TRUE ;
	}
	return	FALSE ;
}

CIO*
CNNTPLogonToRemote::FirstReadComplete(	CIOReadLine*	pReadLine,	
								CSessionSocket*	pSocket,	
								CDRIVERPTR&	pdriver,
								int	cArgs,	
								char	**pszArgs,	
								char	*pchBegin ) {

	//
	//	For now, only check that we got an OK message from the remote server,
	//	if we did, then start up the next state.
	//
	//

	_ASSERT( cArgs > 0 ) ;
	_ASSERT( pszArgs != 0 ) ;
	_ASSERT( pReadLine != 0 ) ;
	_ASSERT( pSocket != 0 ) ;

	CIORead*	pRead = 0 ;
	NRC			code ;

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD			dwOptional = 0 ;

	if( ResultCode( pszArgs[0], code ) )
		if(	code == nrcServerReady || code == nrcServerReadyNoPosts )	{
			_ASSERT( m_pNext != 0 ) ;

			if( m_pAuthenticator == 0 ) {

				//
				//	If we aren't going to log on we can advance to the next state !
				//


				CIOWrite*	pWrite = 0 ;
				if( m_pNext->Start( pSocket,  pdriver,	pRead, pWrite ) ) {
					if( pWrite )	{
						if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
							pWrite->DestroySelf() ;
							if( pRead != 0 ) {
								pRead->DestroySelf() ;
								pRead = 0 ;
							}
						}
					}	
					m_pNext = 0 ;	// Do this so destructor does not blow away next state !
					return	pRead ;
				}
				// If the function fails it should not return stuff !!
				_ASSERT( pWrite == 0 ) ;
				_ASSERT( pRead == 0 ) ;

			}	else	{

				return	StartAuthentication(	pSocket,	pdriver ) ;
			
			}
		}	else	{
			cause = CAUSE_PROTOCOL_ERROR ;
			dwOptional = (DWORD)code ;
	}	else	{
		cause = CAUSE_ILLEGALINPUT ;
	}

	PCHAR	args[2] ;
	args[0] = pSocket->GetRemoteNameString() ;
	args[1] = pSocket->GetRemoteTypeString();

	NntpLogEventEx(
			NNTP_CONNECTION_PROTOCOL_ERROR,
			2,
			(const char **)args,
			GetLastError(),
			((pSocket->m_context).m_pInstance)->QueryInstanceId()
			) ;

	pdriver->UnsafeClose( pSocket, cause, dwOptional ) ;
	_ASSERT( pRead == 0 ) ;
	return	0 ;
}

class	CIO*
CNNTPLogonToRemote::StartAuthentication(	CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver ) {

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD			dwOptional = 0 ;

	//
	//	We need to advance start our logon protocol before advancing to the
	//	next state !
	//

	//
	//	Allocate a CIOWriteLine object so we can get the initial send to the
	//	remote server going !
	//
	CIOWriteLine*	pWriteLine = new( *pdriver ) CIOWriteLine( this ) ;
	if( pWriteLine && pWriteLine->InitBuffers( pdriver ) ) {
		
		unsigned	cbOut = 0 ;
		unsigned	cb = 0 ;
		BYTE*	pb = (BYTE*)pWriteLine->GetBuff( cb ) ;

		if( m_pAuthenticator->StartAuthentication( pb, cb, cbOut ) ) {
			
			_ASSERT( cbOut != 0 ) ;

			pWriteLine->AddText( cbOut ) ;

			if( pdriver->SendWriteIO( pSocket, *pWriteLine, TRUE ) )	{
				return	0 ;
			}
		}
	}	

	PCHAR	args[2] ;
	args[0] = pSocket->GetRemoteNameString() ;
	args[1] = pSocket->GetRemoteTypeString() ;

	NntpLogEventEx(	
			NNTP_INTERNAL_LOGON_FAILURE,
			2,
			(const char **)args,
			GetLastError(),
			((pSocket->m_context).m_pInstance)->QueryInstanceId()
			) ;

	if( pWriteLine != 0 )
		CIO::Destroy( pWriteLine, *pdriver ) ;
	cause = CAUSE_OOM ;
	dwOptional = 0 ;
	//
	//	exit here so we don't log an extra event !
	//
	pdriver->UnsafeClose( pSocket, cause, dwOptional ) ;
	return	0 ;
}


CIO*
CNNTPLogonToRemote::Complete(	CIOReadLine*	pReadLine,	
								CSessionSocket*	pSocket,	
								CDRIVERPTR&	pdriver,
								int	cArgs,	
								char	**pszArgs,	
								char	*pchBegin ) {

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD			dwOptional = 0 ;

	m_cReadCompletes ++ ;
	if( m_cReadCompletes == 1 ) {
	
		return	FirstReadComplete(	pReadLine,	
									pSocket,
									pdriver,
									cArgs,
									pszArgs,
									pchBegin ) ;

	}	else	{

		//
		//	subsequent read completiongs are always the result of an attempt
		//	to logon to the remote server - and need to be processed !!
		//

		_ASSERT( m_pAuthenticator != 0 ) ;

		if( m_pAuthenticator != 0 ) {
			
			CIOWriteLine*	pWriteLine = new( *pdriver )	CIOWriteLine( this ) ;
			if( pWriteLine && pWriteLine->InitBuffers( pdriver ) ) {
				
				unsigned	cbOut = 0 ;
				unsigned	cb = 0 ;
				BYTE*	pb = (BYTE*)pWriteLine->GetBuff( cb ) ;

				//
				//	Make sure the arguemnts are nicely formatted MULTI SZ's
				//

				LPSTR	lpstr = ConditionArgs( cArgs, pszArgs ) ;
				if( m_pAuthenticator->NextAuthentication( lpstr, pb, cb, cbOut, m_fComplete, m_fLoggedOn ) ) {
					
					if( m_fComplete ) {
						
						// In this case we dont need to send another string !
						CIO::Destroy( pWriteLine, *pdriver ) ;
						pWriteLine = 0 ;

						if( m_fLoggedOn ) {

							// We can now advance to the next state !!
							_ASSERT( m_pNext != 0 ) ;

							CIORead*	pRead = 0 ;
							CIOWrite*	pWrite = 0 ;
							if( m_pNext->Start( pSocket,  pdriver,	pRead, pWrite ) ) {
								if( pWrite )	{
									if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
										pWrite->DestroySelf() ;
										if( pRead != 0 ) {
											pRead->DestroySelf() ;
											pRead = 0 ;
										}
									}
								}	
								m_pNext = 0 ;	// Do this so destructor does not blow away next state !
								return	pRead ;
							}
							// If the function fails it should not return stuff !!
							_ASSERT( pWrite == 0 ) ;
							_ASSERT( pRead == 0 ) ;

						}	else	{
							PCHAR	args[2] ;
							args[0] = pSocket->GetRemoteNameString() ;
							args[1] = pSocket->GetRemoteTypeString() ;

							NntpLogEventEx(
									NNTP_FAILED_TO_LOGON,
									2,
									(const char **)args,
									GetLastError(),
									((pSocket->m_context).m_pInstance)->QueryInstanceId()
									) ;
							cause = CAUSE_LOGON_ERROR ;
						}

					}	else	{
						_ASSERT( cbOut != 0 ) ;
						pWriteLine->AddText( cbOut ) ;
						if( pdriver->SendWriteIO( pSocket, *pWriteLine, TRUE ) )	{
							return	0 ;
						}
					}
				}	
			}
			if( pWriteLine != 0 )
				CIO::Destroy( pWriteLine, *pdriver ) ;
		}
	}
	//
	//	In case of error we will fall through to here !!
	//
	pdriver->UnsafeClose( pSocket, cause, GetLastError() ) ;
	return	0 ;
}


CIO*
CNNTPLogonToRemote::Complete(	CIOWriteLine*	pWriteLine,
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver ) {

	//
	//	If we issued a write in this state then we must have a
	//	logon transaction going - the write completed so issue another read !
	//

	CIOReadLine*	pIOReadLine = new( *pdriver ) CIOReadLine( this ) ;

	if( pIOReadLine )	{
		if( pdriver->SendReadIO( pSocket, *pIOReadLine, TRUE ) ) {
			return	0 ;
		}	else	{
			CIO::Destroy( pIOReadLine, *pdriver ) ;
		}
	}

	pdriver->UnsafeClose(	pSocket,	CAUSE_OOM, 0 ) ;
	return	 0 ;
}

CSetupPullFeed::CSetupPullFeed(
	CSessionState*	pNext
	)	:
	m_pNext( pNext ),
	m_state( eModeReader )	{

	_ASSERT( m_pNext != 0 ) ;

}

CIOWriteLine*
CSetupPullFeed::BuildNextWrite(
		CSessionSocket*	pSocket,
		CDRIVERPTR&		pdriver
		)	{


	char*	szCommand = 0 ;

	switch( m_state ) {
	case	eModeReader :
		szCommand = "mode reader\r\n" ;
		break ;
	case	eDate :
		szCommand = "date\r\n" ;
		break ;
	default :
		_ASSERT( 1==0 ) ;
		return 0;
	}

	_ASSERT( szCommand != 0 ) ;

	DWORD	cb = lstrlen( szCommand ) ;

	OutboundLogFill( pSocket, (LPBYTE)szCommand, cb ) ;

	CIOWriteLine*		pIOWriteLine = new( *pdriver ) CIOWriteLine( this ) ;
	if( pIOWriteLine )	{
		
		if( pIOWriteLine->InitBuffers( pdriver, cb ) ) {
			CopyMemory( pIOWriteLine->GetBuff(), szCommand, cb ) ;
			pIOWriteLine->AddText(	cb ) ;
			return	pIOWriteLine ;
		}
	}
	return	0 ;
}


BOOL
CSetupPullFeed::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,	
						CIORead*&	pRead,	
						CIOWrite*&	pWrite ) {

	pRead = 0 ;
	pWrite = 0 ;

	pWrite = BuildNextWrite( pSocket, pdriver ) ;

	return	pWrite != 0 ;
}



CIO*
CSetupPullFeed::Complete(	class	CIOWriteLine*	pWriteLine,
							class	CSessionSocket*	pSocket,
							CDRIVERPTR&	pdriver
					)	{
/*++

Routine Description :

	Complete the processing of a write - we just need to turn over
	a new read as all the work is done on the read completions !

Arguments :

	Standard for a CIOWriteLine completion

Return Value :

	NULL Always !

--*/

	CIOReadLine*	pReadLine = new( *pdriver ) CIOReadLine( this ) ;
	if( pReadLine )		{
		if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
			return	0 ;
		}	else	{
			CIO::Destroy( pReadLine, *pdriver ) ;
		}
	}	

	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
	return	0 ;
}


CIO*
CSetupPullFeed::Complete(	CIOReadLine*	pReadLine,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,
							int	cArgs,	
							char	**pszArgs,	
							char*	pchBegin
							) {

	NRC	code ;
	BOOL	fLegal = ResultCode( pszArgs[0], code ) ;

	OutboundLogResults(	pSocket,
						fLegal,
						code,
						cArgs,
						pszArgs
						) ;

	if( fLegal ) {

		CIORead*	pRead = 0 ;
		CIOWrite*	pWrite = 0 ;

		switch( m_state ) {
		case	eModeReader :

			//
			//	Don't really care what happened - keep on moving !
			//

			m_state = eDate ;

			break ;
		case	eDate :

			//
			//	Got the date from the remote end - save for later use !
			//

			if( code == nrcDateFollows ) {

				SYSTEMTIME  systime ;
				int cScanned = 0 ;
				if( cArgs >= 2 && lstrlen( pszArgs[1] ) == 14) {
					cScanned = sscanf( pszArgs[1], "%4hd%2hd%2hd%2hd%2hd%2hd",
											&systime.wYear,
											&systime.wMonth,
											&systime.wDay,
											&systime.wHour,
											&systime.wMinute,
											&systime.wSecond
											) ;
				}

				FILETIME    localtime ;
				if( cScanned != 6 ||
					!SystemTimeToFileTime( &systime, &localtime)
					)  {

					GetSystemTimeAsFileTime( &localtime );

				}
				_ASSERT( pSocket->m_context.m_pInFeed != 0 ) ;
				pSocket->m_context.m_pInFeed->SubmitFileTime( localtime ) ;

			}	else	{
				fLegal = FALSE ;
			}

			m_state = eFinal ;

			break ;

		case	eFinal :
		default :
			_ASSERT( 1==0 ) ;
			break ;
		}
		
		//
		//	Get the next write to issue !
		//
		if( m_state != eFinal ) {
			pWrite	= BuildNextWrite(	pSocket, pdriver ) ;
			if( pWrite ) {
				if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
					pWrite->DestroySelf() ;
				}	else	{
					return	0 ;
				}
			}
		}	else	{

			//
			//	Need to advance to the next state !!
			//

			if( m_pNext->Start( pSocket, pdriver, pRead, pWrite ) ) {
				if( pWrite )	{
					if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
						pWrite->DestroySelf() ;
						if( pRead != 0 ) {
							pRead->DestroySelf() ;
							pRead = 0 ;
						}
						pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
						return 0 ;
					}
				}
				m_pNext = 0 ;	// Do this so our destructor doesn't blow him away !!
				return	pRead;
			}	
		}
	}

	//
	//	If we fall through to here an error occurred - drop the session !
	//
	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
	return	0 ;
}

	

CCollectGroups::CCollectGroups(	CSessionState*	pNext )	:	
	m_pNext( pNext ),
	m_fReturnCode( TRUE ),
	m_cCompletions( 0 )	{

	//
	//	CCollectGroups initializer - record what the next state should be !
	//

	_ASSERT( pNext != 0 ) ;

	TraceFunctEnter( "CCollectGroups::CCollectGroups" ) ;
	DebugTrace( (DWORD_PTR)this, "New CCollectGroups" ) ;

}

CCollectGroups::~CCollectGroups() {
}

BOOL
CCollectGroups::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,	
						CIORead*&	pRead,	
						CIOWrite*&	pWrite ) {

	//	
	//	We want to build up our list of newsgroups -
	//	send a command to the remote server to list all newsgroups !
	//	Then issue a CIOReadLine to get the response !
	//

	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pdriver != 0 ) ;
	_ASSERT(	pRead == 0 ) ;
	_ASSERT(	pWrite == 0 ) ;
	_ASSERT(	m_fReturnCode ) ;
	_ASSERT(	m_pNext != 0 ) ;

	pRead = 0 ;
	pWrite = 0 ;

	CIOReadLine*	pIOReadLine = new( *pdriver ) CIOReadLine( this ) ;
	CIOWriteLine*		pIOWriteLine = new( *pdriver ) CIOWriteLine( this ) ;

	if( pIOReadLine && pIOWriteLine )	{
		static	char	szListString[] = "list\r\n" ;
		if( pIOWriteLine->InitBuffers( pdriver, sizeof( szListString)  ) ) {
			CopyMemory( pIOWriteLine->GetBuff(), szListString, sizeof( szListString ) ) ;
			pIOWriteLine->AddText(	sizeof( szListString )-1 ) ;
			pWrite = pIOWriteLine ;
			pRead = pIOReadLine ;
			m_cCompletions = -2 ;

			OutboundLogFill( pSocket, (LPBYTE)szListString, sizeof( szListString ) -1 ) ;

			return	TRUE ;
		}
	}	

	_ASSERT( 1==0 ) ;

	if( pIOReadLine )
		CIO::Destroy( pIOReadLine, *pdriver ) ;

	if( pIOWriteLine )
		CIO::Destroy( pIOWriteLine, *pdriver ) ;	
	
	// Start functions down do much error handling - other than to report the problem!
	return	FALSE ;
}

CIO*
CCollectGroups::Complete(	CIOWriteLine*	pWrite,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver )	{
	//
	//	We don't care how how our WriteLine completes !
	//
	//

	if( InterlockedIncrement( &m_cCompletions ) == 0 ) {
		CIORead*	pRead = 0 ;
		CIOWrite*	pWrite = 0 ;
		if( m_pNext->Start( pSocket, pdriver, pRead, pWrite ) ) {
			if( pRead )	{
				if( !pdriver->SendReadIO( pSocket, *pRead, TRUE ) )	{
					pRead->DestroySelf() ;
					if( pWrite != 0 ) {
						pWrite->DestroySelf() ;
						pWrite = 0 ;
					}
					pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
					return 0 ;
				}
			}
			m_pNext = 0 ;	// Do this so our destructor doesn't blow him away !!
			return	pWrite;
		}
	}	

	_ASSERT( pWrite != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	return	0 ;
}

CIO*
CCollectGroups::Complete(	CIOReadLine*	pReadLine,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,
							int	cArgs,	
							char	**pszArgs,	
							char*	pchBegin ) {

	//
	//	The first readline we complete is the response to the command we issued.
	//	Subsequent readline's are the newsgroups we are being sent.
	//	If the first succeeds the rest will follow !!!
	//

	TraceFunctEnter( "CCollectGroups::Complete" ) ;

	_ASSERT( m_pNext != 0 ) ;
	_ASSERT( pReadLine != 0 ) ;
	_ASSERT(	pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( cArgs != 0 ) ;
	_ASSERT( pszArgs != 0 ) ;
	_ASSERT( pszArgs[0] != 0 ) ;
	_ASSERT( pchBegin != 0 ) ;
	_ASSERT( pszArgs[0] >= pchBegin ) ;

	SHUTDOWN_CAUSE cause	= CAUSE_UNKNOWN ;
	DWORD	dwOptional = 0 ;

	if( m_fReturnCode )		{
		m_fReturnCode = FALSE ;
		NRC	code ;
		BOOL	fLegal = ResultCode( pszArgs[0], code ) ;

		OutboundLogResults(	pSocket,
							fLegal,
							code,
							cArgs,
							pszArgs
							) ;

		if( fLegal && code == nrcListGroupsFollows )	{
			//	Keep Reading Lines !!!
			return	pReadLine ;
		}	else	if( fLegal )	{
			//
			//	Command Failed !! - Bail Out
			//
			cause = CAUSE_PROTOCOL_ERROR ;
			dwOptional = (DWORD)code ;			
			//_ASSERT( 1==0 ) ;
		}	else	{
			cause = CAUSE_ILLEGALINPUT ;
			//
			//	Got JUNK  - Bail Out !
			//
			//_ASSERT(	1==0 ) ;
		}
	}	else	{
		if(	pszArgs[0][0] == '.' && pszArgs[0][1] == '\0' && cArgs == 1 )	{
			//
			//	Terminator - Move onto the next state !!
			//

			DebugTrace( (DWORD_PTR)this, "state complete - starting next one which is %x", m_pNext ) ;

			if( InterlockedIncrement( &m_cCompletions ) == 0 ) {
				CIORead*	pRead = 0 ;
				CIOWrite*	pWrite = 0 ;
				if( m_pNext->Start( pSocket, pdriver, pRead, pWrite ) ) {
					if( pWrite )	{
						if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
							pWrite->DestroySelf() ;
							if( pRead != 0 ) {
								pRead->DestroySelf() ;
								pRead = 0 ;
							}
							pdriver->UnsafeClose( pSocket, cause, dwOptional ) ;
							return 0 ;
						}
					}
					m_pNext = 0 ;	// Do this so our destructor doesn't blow him away !!
					return	pRead ;
				}
				// if m_pNext->Start fails - these had better be NULL !!
				_ASSERT( pRead == 0 ) ;
				_ASSERT( pWrite == 0 ) ;

			}	else	{
				return	0 ;
			}
	
			// Don't know why we failed - try for error code
			dwOptional = GetLastError() ;

		}	else	{
			//
			//	Should have valid newsgroups here !
			//
			if( cArgs != 4 )	{
				// Illegally formatted line !
				// _ASSERT( 1==0 ) ;	
				cause = CAUSE_ILLEGALINPUT ;
			}	else	{

				DebugTrace( (DWORD_PTR)this, "Creating Group %s", pszArgs[0] ) ;

				LPMULTISZ	multisz = pSocket->m_context.m_pInFeed->multiszNewnewsPattern() ;
				CNewsTree* pTree = ((pSocket->m_context).m_pInstance)->GetTree() ;

				if( MatchGroup( multisz, pszArgs[0] ) ) {
					//_strlwr( pszArgs[0] ) ;
    				if( pTree->CreateGroup( pszArgs[0], FALSE, NULL, FALSE ) )	{
#if 0
						CGRPPTR p = pTree->GetGroup( pszArgs[0], lstrlen( pszArgs[0] ) + 1 );
						_ASSERT(p != NULL);
#endif

		    		}
				}

				if( pTree->m_bStoppingTree ) {
					// Instance is stopping - bail early
					cause = CAUSE_FORCEOFF ;
					pdriver->UnsafeClose( pSocket, cause, dwOptional );
					return 0 ;
				}
				
			    return	pReadLine ;
			}
		}
	}
	pdriver->UnsafeClose( pSocket, cause, dwOptional ) ;
	return	0 ;
}


CCollectNewnews::CCollectNewnews() :
	m_cCompletes( -2 )
#if 0
	,m_cCommandCompletes( -2 )
#endif
	{

	//
	//	We try to initialize some stuff here - everything we will be
	//	checked for legality in our Start() code !
	//

	TraceFunctEnter( "CCollectNewnews::CCollectNewnews" ) ;
	DebugTrace( (DWORD_PTR)this, "New CCollectNewnews" ) ;
}

CCollectNewnews::~CCollectNewnews()		{
	m_pSessionDriver = 0 ;
	if( m_pFileChannel != 0 )
		m_pFileChannel->CloseSource( 0 ) ;
}

void
CCollectNewnews::Shutdown(	CIODriver&	driver,
							CSessionSocket*	pSocket,
							SHUTDOWN_CAUSE	cause,
							DWORD			dwError ) {

	TraceFunctEnter( "CCollectNewnews::Shutdown" ) ;

	if( cause != CAUSE_NORMAL_CIO_TERMINATION && m_pFileChannel != 0 ) {
		m_pFileChannel->CloseSource( pSocket ) ;
		m_pFileChannel = 0 ;
		pSocket->Disconnect(	cause,	dwError ) ;
	}
}

BOOL
CCollectNewnews::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,
						CIORead*&	pIORead,	
						CIOWrite*&	pIOWrite	)	{

	//
	//	Issue the newnews command to the remote server !
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( pIORead == 0 ) ;
	_ASSERT( pIOWrite == 0 ) ;
	pIORead = 0 ;
	pIOWrite = 0 ;
	unsigned cbCmdLen = 0;
	unsigned cbBuffer = 0;

	CFromPeerFeed*	pFromPeer = (CFromPeerFeed*)pSocket->m_context.m_pInFeed ;
	LPSTR	lpstr	=	pFromPeer->GetCurrentGroupString() ;
	_ASSERT( lpstr != 0 ) ;
	_ASSERT( *lpstr != '\0' ) ;
	_ASSERT( *lpstr != '!' ) ;	

	if (strlen(lpstr)  > MAX_NEWSGROUP_NAME) return FALSE;
	cbCmdLen =  strlen("newnews ") + strlen(lpstr) + 
			1 + strlen(pSocket->m_context.m_pInFeed->newNewsDate()) +
			1 + strlen(pSocket->m_context.m_pInFeed->newNewsTime()) + strlen(" GMT\r\n")+1;



	//
	//	The first things we want to issue are a Write which
	//	sends the newnews command to the remote server
	//	and a read which gets the response.
	//

	CIOWriteLine*	pIOWriteLine = new( *pdriver )	CIOWriteLine(	this ) ;
	CIOReadLine*	pIOReadLine = new( *pdriver ) CIOReadLine( this ) ;	

	m_pSessionDriver = pdriver ;

	if( pIOWriteLine && pIOReadLine )	{
		if( pIOWriteLine->InitBuffers( pdriver, cbCmdLen) )	{

			LPSTR	lpstrBuff = pIOWriteLine->GetBuff(cbBuffer) ;
			_ASSERT(cbBuffer >= cbCmdLen);


            DWORD	cb = wsprintf(
							lpstrBuff,
							"newnews %s %s %s GMT\r\n",
							 lpstr,
							 pSocket->m_context.m_pInFeed->newNewsDate(),
							 pSocket->m_context.m_pInFeed->newNewsTime()
							 ) ;


			pIOWriteLine->AddText( cb ) ;

			OutboundLogFill( pSocket, (LPBYTE)lpstrBuff, cb ) ;

			char	szTempFile[ MAX_PATH ] ;
			unsigned	id = GetTempFileName( pSocket->m_context.m_pInFeed->szTempDirectory(), "new", 0, szTempFile ) ;
			HANDLE	hTempFile = CreateFile(	szTempFile,
										GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ,
										0,
										CREATE_ALWAYS,
										FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,
										INVALID_HANDLE_VALUE
										) ;
			DWORD dw = GetLastError() ;
			if( hTempFile != INVALID_HANDLE_VALUE )	{

				//
				//	Now make an FIO_CONTEXT to deal with this file !
				//
				FIO_CONTEXT*	pFIOContext = AssociateFile( hTempFile ) ;
				if( pFIOContext ) 	{
					m_pFileChannel = new CFileChannel( ) ;
					if( m_pFileChannel->Init( pFIOContext, pSocket,	0,	FALSE ) )	{
						ReleaseContext( pFIOContext ) ;
						pIORead = pIOReadLine ;
						pIOWrite = pIOWriteLine ;
						return	TRUE ;
					}
					//
					//	In case of an error we fall through to here where we
					//	do our cleanup !
					//
					ReleaseContext( pFIOContext ) ;
				}
				//
				//	This dumps the handle in case of an error !
				//
				_VERIFY( CloseHandle( hTempFile ) ) ;
			}
		}
	}	
	//
	//	Some sort of failure occurred - clean up and return FALSE.
	//
	if( pIOWriteLine )	
		CIO::Destroy( pIOWriteLine, *pdriver ) ;
	if( pIOReadLine )
		CIO::Destroy( pIOReadLine, *pdriver ) ;
	pIOWrite = 0 ;
	pIORead = 0 ;
	if( m_pFileChannel != 0 ) {
		m_pFileChannel = 0 ;
	}
	
	pIOWrite = 0 ;
	pIORead = 0 ;
	return	FALSE ;
}

CIO*
CCollectNewnews::Complete(	CIOReadLine*	pReadLine,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,	
							int	cArgs,	
							char	**pszArgs,
							char*	pchBegin )		{

	//
	//	We examine the reply to our newnews command - if things look good
	//	we issue a CIOReadArticle operation to get the list of message-ids into a file !
	//

	_ASSERT( pdriver == m_pSessionDriver ) ;
	_ASSERT(	pReadLine != 0 ) ;
	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pdriver != 0 ) ;
	_ASSERT(	cArgs != 0 ) ;
	_ASSERT(	pszArgs != 0 ) ;
	_ASSERT(	pszArgs[0] != 0 ) ;
	
	//
	//	We only care about the first string !!
	//

	NRC	code ;
	SHUTDOWN_CAUSE	cause = CAUSE_PROTOCOL_ERROR ;

	//
	//	Only fall through to here if we have completed all processing of the
	//	mode reader command
	//
	BOOL	fResult = ResultCode( pszArgs[0], code ) ;

	OutboundLogResults( pSocket, fResult, code, cArgs, pszArgs ) ;

	if(	fResult && code == nrcNewnewsFollows )	{
		//
		//	We won't do any limit checking on the size of the temp file we create !
		//
		CIOReadArticle*	pread = new( *pdriver ) CIOReadArticle( this, pSocket, pdriver, m_pFileChannel, 0, TRUE ) ;
		if( pread &&  pread->Init( pSocket ) )	{
			return	pread ;
		}	else	{
			cause = CAUSE_IODRIVER_FAILURE ;
		}
	}
	// Only arive here if some kind of error occurred !!
	// We will close the IO Driver down and kill ourselves !!
	pdriver->UnsafeClose( pSocket, cause, (DWORD)code ) ;
	return	0 ;
}

BOOL
CCollectNewnews::InternalComplete(	CSessionSocket*	pSocket,	
									CDRIVERPTR&	pdriver ) {

	if( InterlockedIncrement( &m_cCompletes ) < 0 ) {
		return	TRUE ;
	}	else	{

		CCollectArticles	*pNext = new	CCollectArticles( pSocket, m_pSessionDriver, *m_pFileChannel ) ;
		m_pFileChannel = 0 ;
		if( pNext )	{
			if( pNext->Init( pSocket ) )	{
				CIORead*	pRead = 0 ;
				CIOWrite*	pWrite = 0 ;
				if( pNext->Start(	pSocket,	m_pSessionDriver,	pRead,	pWrite ) )	{
					// We happen to know that this start function shouldn't return any Read or Writes !
					_ASSERT( pRead == 0 ) ;
					_ASSERT( pWrite == 0 ) ;
					return TRUE	;	// Succesfully completion !!
				}
				_ASSERT( pRead == 0 ) ;
				_ASSERT( pWrite == 0 ) ;
			}
		}
	}
	return	FALSE ;	
}

CIO*
CCollectNewnews::Complete(	CIOWriteLine*,	
							class	CSessionSocket*	pSocket,
							CDRIVERPTR&	pdriver	)	{

	//
	//	Only fall through to here when completed processing of the mode reader command.
	//

	//
	//	Don't care how or when the newnews write completes !
	//

	if( !InternalComplete(	pSocket,	pdriver ) )		{
		pdriver->UnsafeClose(	pSocket,	CAUSE_UNKNOWN,	GetLastError() ) ;
	}	

	return	0 ;
}

void
CCollectNewnews::Complete(	CIOReadArticle*	pArticle,	
							class	CSessionSocket*	pSocket,	
							CDRIVERPTR&		pdriver,	
							CFileChannel&	pFileChannel,
							DWORD			cbTransfer	)	{

	//
	//	Completed reading all of the message-ids into a temp file -
	//	time to start the CCollectArticles state and start pulling those
	//	messages over !!
	//

	_ASSERT( pdriver != m_pSessionDriver ) ;
	_ASSERT(	pArticle != 0 ) ;
	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pdriver != 0 ) ;
	_ASSERT(	&pFileChannel != 0 ) ;
	_ASSERT(	&pFileChannel == m_pFileChannel ) ;
		
	SHUTDOWN_CAUSE cause = CAUSE_UNKNOWN ;
	DWORD	dwOptional = 0 ;

	if( InternalComplete(	pSocket,	pdriver ) ) {
		return;
	}

	dwOptional = GetLastError() ;
	m_pSessionDriver->Close( pSocket, cause, dwOptional ) ;
}

const	char	CCollectArticles::szArticle[] = "article " ;

CCollectArticles::CCollectArticles(
									CSessionSocket*	pSocket,
									CDRIVERPTR&	pDriver,	
									CFileChannel&	pFileChannel
									) :	
	m_fFinished( FALSE ),
	m_FinishCause( CAUSE_UNKNOWN ),
	m_cResets( -1 ),
	m_pSocket( pSocket ),
	m_pFileChannel( &pFileChannel ),
	m_inputId(	new	CIODriverSink( 0 ) ),
	m_pSessionDriver( pDriver ),
	m_pReadArticle( 0 ),
	m_fReadArticleInit( FALSE ),
	m_pReadArticleId( 0 ),
	m_fReadArticleIdSent( FALSE ),
	m_cAhead( -1 ),
	m_pchNextArticleId( 0 ),
	m_pchEndNextArticleId( 0 ),
	m_hArticleFile( INVALID_HANDLE_VALUE ),
	m_cArticlesCollected( 0 ),
	m_cCompletes( -2 ),
	m_lpvFeedContext( 0 )
{
	TraceFunctEnter( "CCollectArticles::CCollectArticles" ) ;
	_ASSERT(	&pFileChannel != 0 ) ;
	_ASSERT( pDriver != 0 ) ;

	DebugTrace( (DWORD_PTR)this, "New CCollectArticles" ) ;

	m_pFileChannel->Reset( TRUE ) ;
}

void
CCollectArticles::Reset( )	{

	TraceFunctEnter( "CCollectArticles::Reset" ) ;

	//
	//	This function exists to get rid of all the references to anything we
	//	may be holding.  We can be called recursively so we must take extra care !!
	//

	//
	//	Only do Reset() once !
	//
	if( InterlockedIncrement( &m_cResets ) == 0 )	{


		DebugTrace( (DWORD_PTR)this, "m_pFileChannel %x m_inpuId %x m_pSessionDriver %x"
								" m_pchNextArticleId %x m_pchEndNextArticleId %x",
				m_pFileChannel, m_inputId, m_pSessionDriver, m_pchNextArticleId,
				m_pchEndNextArticleId ) ;

        //  12/23/98 : BINLIN - fix AV in PostCancel - Before we do "m_pSessionDriver = 0" below,
        //  need to do our PostCancel if needed.
        //  It's ok if we go through another PostCancel() code path in CCollectArticles::Complete()
        //  'cause we call InternalComplete() after that, which will set m_lpvFeedContext to NULL!
	    if( m_lpvFeedContext != 0 ) {
		    _ASSERT( m_pSocket != 0 ) ;
		    DWORD	dwReturn ;
		    CNntpReturn	nntpReturn ;
		    m_pSocket->m_context.m_pInFeed->PostCancel(	
					    m_lpvFeedContext,
					    dwReturn,
					    nntpReturn
					    ) ;
		    m_lpvFeedContext = 0;
	    }

		if( m_pFileChannel != 0 ) {
			m_pFileChannel = 0 ;
		}

		m_inputId = 0 ;
		m_pSessionDriver = 0 ;
		m_pchNextArticleId = 0 ;
		m_pchEndNextArticleId = 0 ;

		DebugTrace( (DWORD_PTR)this, "m_pReadArticleId %x", m_pReadArticleId ) ;
		if( m_pReadArticleId != 0 ) {
			CIOReadLine*	pTemp = m_pReadArticleId ;
			m_pReadArticleId = 0 ;
			if( !m_fReadArticleIdSent )
				pTemp->DestroySelf() ;
		}

		DebugTrace( (DWORD_PTR)this, "m_pReadArticle %x and m_fReadArticleInit %x", m_pReadArticle,
			m_fReadArticleInit ) ;

		if( m_pReadArticle != 0 )	{
			CIOGetArticleEx	*pReadArticleTemp = m_pReadArticle ;
			m_pReadArticle = 0 ;
			if( !m_fReadArticleInit ) {
				pReadArticleTemp->DestroySelf() ;
			}	else	{
				_ASSERT( m_pSocket != 0 ) ;
				pReadArticleTemp->Term( m_pSocket ) ;
			}
		}
	}
}

CCollectArticles::~CCollectArticles() {

	TraceFunctEnter( "CCollectArticles::~CCollectArticles" ) ;

	Reset() ;

}

BOOL
CCollectArticles::Init(	CSessionSocket*	pSocket )	{

	//
	//	If we can init the CIODriverSink for the message-id file we're ready to go !!
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT( m_pReadArticleId == 0 ) ;
	_ASSERT(	m_cAhead == -1  ) ;
	_ASSERT(	m_pchNextArticleId == 0 ) ;

	BOOL	fRtn = FALSE ;
	CIODriverSink*	pInputSink = (CIODriverSink*) ((CIODriver*)m_inputId) ;
	if( m_inputId != 0 && pInputSink->Init( m_pFileChannel, pSocket,
			ShutdownNotification, this, sizeof( szArticle )*2 ) )	{
		fRtn = TRUE ;
	}		
	return	fRtn ;
}

void
CCollectArticles::Shutdown(	CIODriver&	driver,	
							CSessionSocket*	pSocket,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dw )	{

	TraceFunctEnter( "CCollectArticles::Shutdown" ) ;

	if( cause != CAUSE_NORMAL_CIO_TERMINATION ) {
		if( m_pSessionDriver != 0 )
			m_pSessionDriver->UnsafeClose( m_pSocket, cause, dw, TRUE ) ;
		if( m_inputId != 0 )
			m_inputId->UnsafeClose( (CSessionSocket*)this, cause, dw, TRUE ) ;
		Reset() ;
	}
}

void
CCollectArticles::ShutdownNotification( void	*pv,	
										SHUTDOWN_CAUSE	cause,	
										DWORD dw ) {

	//
	//	This functio will be called if there is a problem issuing IO's to any of our
	//	files !
	//

	_ASSERT( pv != 0 ) ;

}


BOOL
CCollectArticles::Start(	CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver,	
							CIORead*&	pRead,	
							CIOWrite*&	pWrite )	{

	//
	//	Start collecting articles from the remote server !
	//	First thing : read from the temp file to get a Message-Id !
	//	When that completes and we want the message, send a request
	//	to the remote server !
	//

	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( m_pReadArticleId == 0 ) ;
	_ASSERT(	m_cAhead == -1  ) ;
	_ASSERT(	m_pchNextArticleId == 0 ) ;


	TraceFunctEnter( "CCollectArticles::Start" ) ;

	pRead = 0 ;
	pWrite = 0 ;
	
	CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this, TRUE ) ;

	//
	//	Start things off by reading a line from our temp file.
	//	Should get a single Message-Id from this read !
	//

	DebugTrace( (DWORD_PTR)this, "Issing CIOReadLine %x", pReadLine ) ;

	if( pReadLine )	{
		m_pReadArticleId = pReadLine ;
		m_fReadArticleIdSent = TRUE ;
		if( !m_inputId->SendReadIO(	pSocket,	*pReadLine, TRUE ) ) {	

			ErrorTrace( (DWORD_PTR)this, "Error issuing CIOReadLine %x", pReadLine ) ;

			m_fReadArticleIdSent = FALSE ;
			m_pReadArticleId = 0 ;
			CIO::Destroy( pReadLine, *pdriver ) ;
			return	FALSE ;
		}
		return	TRUE ;
	}
	return	FALSE ;
}

CIO*
CCollectArticles::Complete(	CIOReadLine*	pReadLine,	
							CSessionSocket*	pSocket,
							CDRIVERPTR&	pdriver,	
							int	cArgs,	
							char	**pszArgs,	
							char	*pchBegin )	{

	//
	//	We read a line of text from somewhere - but where ?
	//	We need to check whether we got text from the network or from our temp
	//	file of message-ids.  If its from the temp file, process the message-id
	//	so we can send it to the remote server.
	//	If its from the network, its a response to an article command - so figure out
	//	whether we're going to get the article and issue a CIOReadArticle if so !
	//

	TraceFunctEnter( "CCollectArticles::Complete" ) ;

	_ASSERT( pReadLine != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( cArgs != 0 ) ;
	_ASSERT( pszArgs[0] != 0 ) ;
	_ASSERT( pchBegin != 0 ) ;

	_ASSERT( pchBegin <= pszArgs[0] ) ;
	_ASSERT( pReadLine != m_pReadArticleId || (pszArgs[0] - pchBegin) >= sizeof( szArticle ) ) ;

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD	dwOptional = 0 ;

	if( pReadLine == m_pReadArticleId )	{
		_ASSERT( pdriver != m_pSessionDriver ) ;
		unsigned	cb= lstrlen( pszArgs[0] ) ;

		DebugTrace( (DWORD_PTR)this, "checking for Message Id len %d string %s", cb, pszArgs[0] ) ;

		if( cArgs == 1 &&
			pszArgs[0][0] == '<' &&
			pszArgs[0][ cb-1 ] == '>' )	{

			//
			//	This appears to be a valid Message-Id !!! Send an article command !
			//


			ARTICLEID	artid ;
			GROUPID		groupid ;
			WORD		HeaderOffset ;
			WORD		HeaderLength ;
			CStoreId	storeid;

			PNNTP_SERVER_INSTANCE pInstance = (pSocket->m_context).m_pInstance ;
			if( pInstance->ArticleTable()->GetEntryArticleId(	pszArgs[0],
															HeaderOffset,
															HeaderLength,
															artid,
															groupid,
															storeid) ||
				pInstance->HistoryTable()->SearchMapEntry( pszArgs[0] ) ) {
				
				return	pReadLine ;

			}

			// Save away in case another thread will use it

			_ASSERT( m_pchNextArticleId == 0 ) ;

			DebugTrace( (DWORD_PTR)this, "Is A MessageId" ) ;

			m_pchNextArticleId = pszArgs[0] ;
			m_pchEndNextArticleId = m_pchNextArticleId + cb ;
			CIOWriteLine*	pWriteNextArticleId = new( *pdriver )	CIOWriteLine( this ) ;
			if( pWriteNextArticleId == 0 )	{
				//	FATAL Error - shut down session !
				cause = CAUSE_OOM ;
				dwOptional = GetLastError() ;
				_ASSERT( 1==0 ) ;
			}	else	{
				pWriteNextArticleId->InitBuffers( m_pSessionDriver, pReadLine ) ;

				//
				//	There is no other processing going on - we must initiate everything
				//

				DebugTrace( (DWORD_PTR)this, "Starting Transfer !!" ) ;

				if( !StartTransfer(	pSocket,	pdriver, pWriteNextArticleId	) )	{
					//	Fatal Error - shut down session !
					//	We will fall through to correct shutdown code !
					CIO::Destroy( pWriteNextArticleId, *pdriver ) ;
				}	else	{

					DebugTrace( (DWORD_PTR)this, "Call to StartTransfer failed" ) ;

					// Start Transfer must clean these up !!
					_ASSERT( m_pchNextArticleId == 0 ) ;
					_ASSERT( m_pchEndNextArticleId == 0 ) ;
					//	We will try to find the next Article ID to send
					//return	pReadLine ;
					return 0 ;
				}
			}
		}	else	if( cArgs == 1 && pszArgs[0][0] == '.' && pszArgs[0][1] == '\0' )	{


				DebugTrace( (DWORD_PTR)this, "At end of newnews list" ) ;

				// End of the list !!!
				//
				//	we can teminate this now !!
				//
				m_fFinished = TRUE ;


				m_pchNextArticleId = 0 ;
				m_pReadArticleId = 0 ;
				m_fReadArticleIdSent = FALSE ;

				m_pFileChannel->CloseSource( pSocket ) ;
				if( m_cArticlesCollected > 0 ) {
					cause = m_FinishCause = CAUSE_LEGIT_CLOSE ;
				}	else	{
					cause = m_FinishCause = CAUSE_NODATA ;
				}

				DebugTrace( (DWORD_PTR)this, "Closing Input driver %x", m_inputId ) ;


				//
				//	Send the quit command !!!
				//
				static	char	szQuit[] = "quit\r\n" ;

				CIOWriteLine*	pWrite = new( *pdriver ) CIOWriteLine( this ) ;

				DebugTrace( (DWORD_PTR)this, "built CIOWriteLine %x to send quit command", pWrite ) ;

				if( pWrite && pWrite->InitBuffers( m_pSessionDriver, sizeof( szQuit ) ) ) {
					CopyMemory( pWrite->GetBuff(), szQuit, sizeof( szQuit ) -1  ) ;
					pWrite->AddText(	sizeof( szQuit ) - 1) ;

					if( m_pSessionDriver->SendWriteIO( pSocket, *pWrite ) )	{
						DebugTrace( (DWORD_PTR)this, "Successfully sent pWrite %x", pWrite ) ;
						return	0 ;
					}
				}	

				//
				//	Some kind of error occurred - so close our input driver !
				//
				if( m_inputId != 0 )
					m_inputId->UnsafeClose( pSocket, cause, 0 ) ;


				//
				//	In case of problems, clean up here by terminating the session hard !
				//

				ErrorTrace( (DWORD_PTR)this, "some kind of error - will call UnsafeClose() pWrite %x", pWrite ) ;

				if( pWrite != 0 )
					CIO::Destroy( pWrite, *pdriver ) ;
				if( m_pSessionDriver != 0 )
					m_pSessionDriver->UnsafeClose( pSocket, cause, 0 ) ;
				return	0 ;	// No more reads here !!
				
		}	else	{

			ErrorTrace( (DWORD_PTR)this, "Junk in input stream" ) ;

			// WE GOT SENT garbage !!!!! What is this stuff -
			// blow off the session !
			//_ASSERT( 1==0 ) ;
			cause = CAUSE_ILLEGALINPUT ;
		}
	}	else	{
		//
		//	This is a readline from the network - in which case we must
		//  be looking for the response from an article command !!
		//

		DebugTrace( (DWORD_PTR)this, "received : %s", pszArgs[0] ) ;

		_ASSERT( pdriver == m_pSessionDriver ) ;
		NRC	code ;
		_ASSERT( m_pReadArticle != 0 ) ;

		BOOL fResult = ResultCode( pszArgs[0], code ) ;

		if( fResult )	{
			if( code == nrcArticleFollows )	{
				//
				// Fantastic - now read the whole article !!!!
				//
				DebugTrace( (DWORD_PTR)this, "Start reading article - %x", m_pReadArticle ) ;
				_ASSERT( m_pReadArticle != 0 ) ;
				m_fReadArticleInit = TRUE ;
				return	m_pReadArticle ;

			}	else	{

				DebugTrace( (DWORD_PTR)this, "Error - discard %x", m_pReadArticle ) ;
		        OutboundLogResults( pSocket, fResult, code, cArgs, pszArgs ) ;

				if( m_pReadArticle )	{
					if( m_fReadArticleInit )	{
						m_pReadArticle->Term( pSocket, FALSE ) ;
					}	else	{
						CIO::Destroy( m_pReadArticle, *pdriver ) ;
					}
					m_fReadArticleInit = FALSE ;
				}
				m_pReadArticle = 0 ;

				//
				//	Synchronize with the thread which completed the write of our
				//	command to the remote server - only one of us should call GetNextArticle() !
				//
				//	NOTE : in error cases we should fall through - in Success cases return 0 !
				//
				if( InterlockedIncrement( &m_cCompletes ) == 0 ) {
					m_cCompletes = -2 ;
					if( GetNextArticle( pSocket,	pdriver ) ) {
						return	0 ;
					}
				}	else	{
					return	0 ;
				}
			}
		}	else	{
			//
			//	Not a legal result code - blow off session !
			//

		    OutboundLogResults( pSocket, fResult, code, cArgs, pszArgs ) ;
			ErrorTrace( (DWORD_PTR)this, "bad error code - blow off session" ) ;

			_ASSERT( 1==0 ) ;
			cause = CAUSE_ILLEGALINPUT ;
		}
	}
	//
	//	If we were called by the m_pReadArticleId object we don't
	//	want it blown away by Reset - it can handle that itself !
	//
	if( pReadLine == m_pReadArticleId )	{
		m_pReadArticleId = 0 ;
		m_fReadArticleIdSent = FALSE ;
	}

	//
	//	Note - m_inputid can be Zero
	//
	Shutdown( *pdriver, pSocket, cause, dwOptional ) ;

	Reset() ;
	return	0 ;
}


BOOL
CCollectArticles::StartTransfer(	CSessionSocket*	pSocket,	
									CDRIVERPTR&	pdriver,
									CIOWriteLine*	pWriteNextArticleId
									)	{
/*++

Routine Description :

	This function issues a command to the remote server to ask for an article.
	Additionally, it issues the necessary IO's to get the response to the command.
	

Arguemtns :
	
	pSocket - Pointer to the CSessionSocket representing the session
	pdriver - The CIODriver which controls all IO for the session
	pWriteNextArticleId - a CIOWriteLine object which contains the text of the article Command.
		IMPORTANT NOTE - If the function fails the caller must delete pWriteNextArticleId on its own.
		If the function succeeds the caller is no longer responsible for freeing pWriteNextArticleID

Return Value :

	TRUE if successfull
	FALSE if otherwise.


--*/

	//
	//	Once we've figured out that we want a given message-id we call
	//	this function to create temp files etc... and issue a CIOreadArticle to
	//	receive the article into.
	//

	extern	char	szBodySeparator[] ;
	extern	char	szEndArticle[] ;
	extern	char	*szInitial ;

	TraceFunctEnter( "CCollectArticles::StartTransfer" ) ;

	DebugTrace( (DWORD_PTR)this, "m_pchNextArticleId %20s m_pchEndNextAritcleId %x", m_pchNextArticleId,
			m_pchEndNextArticleId ) ;

	_ASSERT( m_pchNextArticleId != 0 ) ;
	_ASSERT(	m_pchEndNextArticleId != 0 ) ;
	_ASSERT(	m_pchEndNextArticleId > m_pchNextArticleId ) ;
	_ASSERT(	m_pchNextArticleId + lstrlen( m_pchNextArticleId ) == m_pchEndNextArticleId ) ;
	_ASSERT(	pWriteNextArticleId != 0 ) ;
	_ASSERT(	pWriteNextArticleId->GetBuff() != 0 ) ;
	_ASSERT(	pWriteNextArticleId->GetBuff() < m_pchNextArticleId ) ;
	_ASSERT(	pWriteNextArticleId->GetTail() > m_pchNextArticleId ) ;
	_ASSERT(	m_pReadArticle == 0 ) ;

	DebugTrace( (DWORD_PTR)this, "pWriteNextArticleId %x m_pReadArticle %x", pWriteNextArticleId, m_pReadArticle ) ;

	char	*pchArticle = m_pchNextArticleId - sizeof( szArticle ) + 1 ;

	CopyMemory( pchArticle, szArticle, sizeof( szArticle ) - 1 ) ;
	*m_pchEndNextArticleId++ = '\r' ;
	*m_pchEndNextArticleId++ = '\n' ;

	OutboundLogFill(	pSocket,
						(LPBYTE)pchArticle,
						(DWORD)(m_pchEndNextArticleId - pchArticle)
						) ;

	pWriteNextArticleId->SetLimits( pchArticle, m_pchEndNextArticleId ) ;	

	CIOReadLine*	pNextReadLine = new( *pdriver )	CIOReadLine( this ) ;
	if( pNextReadLine == 0 )	{

		DebugTrace( (DWORD_PTR)this, "Memory Allocation Failure" ) ;
		// FATAL Error - shut down session !!
		CIO::Destroy( pWriteNextArticleId, *pdriver ) ;
		return	FALSE ;
	}

	PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
	m_pReadArticle = new( *pdriver )	CIOGetArticleEx(
											this,
											pSocket,
											m_pSessionDriver,
											pSocket->m_context.m_pInFeed->cbHardLimit( pInst->GetInstanceWrapper() ),
											szBodySeparator,
											szBodySeparator,
											szEndArticle,
											szInitial
											) ;
	if( m_pReadArticle )	{
		DebugTrace( (DWORD_PTR)this, "pNextReadLine %x m_pWriteNextAritcleId %x",
			pNextReadLine, pWriteNextArticleId ) ;

		if( !m_pSessionDriver->SendReadIO( pSocket, *pNextReadLine, TRUE ) )	{
			;
		}	else	{
			// if SendReadIO succeeds we are not responsible for deleting pNextReadLine
			// under any error circumstances !
			pNextReadLine = 0 ;
			if(	!m_pSessionDriver->SendWriteIO(	pSocket, *pWriteNextArticleId, TRUE ) )	{
				;	// caller should delete pWriteNextArticleId in error cases
			}	else	{
				pWriteNextArticleId = 0 ;	
				m_pchNextArticleId = 0 ;
				m_pchEndNextArticleId = 0 ;
				return	TRUE ;
			}
		}
	}

	DWORD	dw = GetLastError() ;
	//
	//	Some sort of error occurred - cleanup
	//
	if(	pNextReadLine != 0 )	{
		CIO::Destroy( pNextReadLine, *pdriver ) ;
	}
	return	FALSE ;
}



CCollectArticles*
CCollectComplete::GetContainer()	{
	return	CONTAINING_RECORD( this, CCollectArticles, m_PostComplete ) ;
}

void
CCollectComplete::StartPost(	)	{
	CCollectArticles*	pContainer = GetContainer() ;
	pContainer->AddRef() ;
}

void
CCollectComplete::Destroy()	{
	Reset() ;
	CCollectArticles*	pContainer = GetContainer() ;
	pContainer->InternalComplete( pContainer->m_pSocket, pContainer->m_inputId ) ;
	if( pContainer->RemoveRef() < 0 ) 	{
		delete	pContainer ;
	}
}




void
CCollectArticles::InternalComplete(	CSessionSocket*	pSocket,
									CDRIVERPTR&	pdriver
									)	{
/*++

Routine Description :

	This function contains all the common code for the various completions
	that CIOGetArticleEx can invoke.
	Basically, we ensure that we advance to the next stage of the state
	machine - retrieving the next article.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter("CCollectArticles::InternalComplete" ) ;

	m_lpvFeedContext = 0 ;

	m_pReadArticle = 0 ;
	m_fReadArticleInit = FALSE ;

	m_cArticlesCollected ++ ;

	//
	//	Now we come to the logic where we issue our next write.
	//

	if( InterlockedIncrement( &m_cCompletes ) == 0 ) {
		m_cCompletes = -2 ;
		if( !GetNextArticle( pSocket,	pdriver ) ) {
			DebugTrace( (DWORD_PTR)this, "CLOSING Driver %x", m_pSessionDriver ) ;
			m_pSessionDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
			m_pSessionDriver = 0 ;
		}
	}
}

CIO*
CCollectArticles::Complete(
			CIOGetArticleEx*	pGetArticle,
			CSessionSocket*		pSocket,
			BOOL				fGoodMatch,
			CBUFPTR&			pBuffer,
			DWORD				ibStart,
			DWORD				cb
			)	{
/*++

Routine Description :

	This function exists to process the results of receiving and
	article header during a pull feed.
	We give the incoming header to the CInFeed derived object to
	process then continue the reception of the article.

Arguments :
	pGetArticle - the CIOGetArticle operation that was issued !
	pSocket - the socket that we are doing the pull feed on !
	fGoodMatch - did we successfully match the header of the article
	pBuffer - the buffer containing the articles header
	ibStart - the offset to where the header bytes begin !
	cb -	the number of bytes in the header

Return Value :

	The next CIO operation - usually we just continue the current one !

--*/

	//
	//	If we get a bad match, then its just as if the article
	//	was totally tossed, and we can continue with our Internal
	//	Completion routines !
	//
	if( fGoodMatch ) 	{

		//
		//	The strings that we use to match the termination string of an article !
		//
		extern	char	szEndArticle[] ;
		extern	char	*szInitial ;
		//
		//	Keep track of how we use bytes in the output buffer of PostEarly !
		//
		DWORD	ibOut = 0 ;
		DWORD	cbOut = 0 ;
		//
		//	Stuff we need for PostEarly() to figure out how to handle the posting !
		//
		PNNTP_SERVER_INSTANCE pInstance = pSocket->m_context.m_pInstance;
		ClientContext*  pContext = &pSocket->m_context ;
		BOOL	fAnon = pSocket->m_context.m_pInFeed->fDoSecurityChecks() ;
		FIO_CONTEXT*	pFIOContext;

		//
		//	Now check some assumptions about our state !
		//
		//	Shouldn't have one of these things dangling around !
		//
		_ASSERT( m_lpvFeedContext == 0 ) ;

	    //
    	// Allocate room in the log buffer for the list of newsgroups
    	// (Max is 256 characters -- we'll grab 200 of them if we can)
    	// If we fail, we just pass NULL to PostEarly
    	//

        DWORD cbNewsgroups;
        BYTE* pszNewsgroups;
        for (cbNewsgroups=200; cbNewsgroups>0; cbNewsgroups--) {
            pszNewsgroups = pSocket->m_Collector.AllocateLogSpace(cbNewsgroups);
            if (pszNewsgroups) {
                break;
            }
   	    }

		//
		//	Let's see if we like the headers !
		//
		BOOL
		fSuccess = pSocket->m_context.m_pInFeed->PostEarly(
							pInstance->GetInstanceWrapper(),
							&pContext->m_securityCtx,
							&pContext->m_encryptCtx,
							pContext->m_securityCtx.IsAnonymous(),
							0,	//	No command provided !
							pBuffer,
							ibStart,
							cb,
							&ibOut,
							&cbOut,
							&pFIOContext,
							&m_lpvFeedContext,
							pSocket->m_context.m_dwLast,
							pSocket->GetClientIP(),
							pSocket->m_context.m_return,
							(char*)pszNewsgroups,
							cbNewsgroups
							) ;
        //
        // Add the list of newsgroups to the log structure
        //
        if (pszNewsgroups) {
            pSocket->m_Collector.ReferenceLogData(LOG_TARGET, pszNewsgroups);
        }

		//
		//	If it succeeded, then we should have a pFIOContext for retrieving the article !
		//
		_ASSERT( pFIOContext != NULL || !fSuccess ) ;
		pGetArticle->StartFileIO(
						pSocket,
						pFIOContext,
						pBuffer,
						ibOut,
						cbOut+ibOut,
						szEndArticle,
						szInitial
						) ;
		return	pGetArticle ;
	}
	//
	//	Fall through means article was bad -
	//	do the processing as if we'd done the entire transfer without
	//	posting the article !
	//
	InternalComplete(	pSocket,
						m_inputId
						) ;
	return	0 ;
}

CIO*
CCollectArticles::Complete(	
			CIOGetArticleEx*	pCIOGetArticle,
			CSessionSocket*		pSocket
			) 	{
/*++

Routine Description :

	Handle a complete when we've finished transferring the article
	but we had decided not to post it into our store.

Arguments :

	pCIOGetArticle - the CIOGetArticleEx operation that completed !
	pSocket - The socket we are transferring the article on !

Return Value :

	NULL - we will always go off and do other operations !

--*/
	InternalComplete( pSocket, m_inputId ) ;
	return	 0 ;
}

void
CCollectArticles::Complete(	
				CIOGetArticleEx*,
				CSessionSocket*	pSocket,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) 	{
/*++

Routine Description :

	This function handles the successfull transfer of an article
	that we want to commit into our stores.

Arguments :

	pSocket - the socket we are transferring articles on
	pContext - the FIO_CONTEXT that we spooled the article into !
	cbTransfer - the number of bytes we transferred !

Return Value :

	None.

--*/

	PNNTP_SERVER_INSTANCE pInstance = (pSocket->m_context).m_pInstance ;
	BOOL    fAnonymous = FALSE;
	
	if( cbTransfer < pSocket->m_context.m_pInFeed->cbSoftLimit( pInstance->GetInstanceWrapper() ) ||
		pSocket->m_context.m_pInFeed->cbSoftLimit( pInstance->GetInstanceWrapper() ) == 0  ) {
		ClientContext*  pContext = &pSocket->m_context ;
		HANDLE  hToken;
		// Due to some header file problems, I can only pass in
		// a hToken handle here.  Since the post component doens't have
		// type information for client context stuff.
		if ( pContext->m_encryptCtx.QueryCertificateToken() ) {
		    hToken = pContext->m_encryptCtx.QueryCertificateToken();
		} else {
		    hToken = pContext->m_securityCtx.QueryImpersonationToken();
		    fAnonymous = pContext->m_securityCtx.IsAnonymous();
		}
	
		m_PostComplete.StartPost() ;

		BOOL	fSuccess = pSocket->m_context.m_pInFeed->PostCommit(
		                        pSocket->m_context.m_pInstance->GetInstanceWrapper(),
								m_lpvFeedContext,
								hToken,
								pSocket->m_context.m_dwLast,
								pSocket->m_context.m_return,
								fAnonymous,
								&m_PostComplete
								) ;

		if( !fSuccess ) 	{
			m_PostComplete.Release() ;
		}	

	}	else	{
		BOOL	fSuccess = pSocket->m_context.m_pInFeed->PostCancel(	
								m_lpvFeedContext,
								pSocket->m_context.m_dwLast,
								pSocket->m_context.m_return
								) ;
		InternalComplete(	pSocket, m_inputId ) ;
	}
}

CIO*	
CCollectArticles::Complete(	CIOWriteLine*	pWrite,	
							CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver )	{

	//
	//	Just completed sending a 'article' command to the remote server !!
	//

	TraceFunctEnter( "CCollectArticles::Complete - CIOWriteLine" ) ;

	_ASSERT( pWrite != 0 ) ;
	_ASSERT(	pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;

	DebugTrace( (DWORD_PTR)this, "Processing CIOWriteLine %x - m_fFinished %x m_pSessionDriver %x",
			pWrite, m_fFinished, m_pSessionDriver ) ;

	if( m_fFinished ) {

		//
		//	All done - drop session !
		//

		OutboundLogAll(	pSocket,
				FALSE,
				NRC(0),
				0,
				0,
				"quit"
				) ;

		if( m_pSessionDriver )
			m_pSessionDriver->UnsafeClose( pSocket, m_FinishCause, 0 ) ;
		m_pSessionDriver = 0 ;
	
		if( m_inputId )
			m_inputId->UnsafeClose( pSocket, m_FinishCause, 0 ) ;

		return	0 ;
	}

	if( InterlockedIncrement( &m_cCompletes ) == 0 ) {
		m_cCompletes = -2 ;
		if( !GetNextArticle( pSocket,	pdriver ) ) {

			DebugTrace( (DWORD_PTR)this, "CLOSING Driver %x", m_pSessionDriver ) ;

			m_pSessionDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
			m_pSessionDriver = 0 ;
		}
	}

	return	0 ;
}

BOOL
CCollectArticles::GetNextArticle(	CSessionSocket*	pSocket,	
									CDRIVERPTR&	pdriver	)	{

	//
	//	Issue the necessary IO's to get the next message-id we want to send !
	//
	//

	TraceFunctEnter( "CCollectArticles::GetNextArticle" ) ;
	//
	//	The thread reading from the temp file has got ahead of US !
	//
	CIOReadLine*	pTemp = m_pReadArticleId = new( *pdriver )	CIOReadLine( this, TRUE ) ;
	DebugTrace( (DWORD_PTR)this, "sending ReadArticleId %x", m_pReadArticleId ) ;
	m_fReadArticleIdSent = TRUE ;

	//
	//	Calling SendReadIO can result in our shutdown function being
	//	called, which may reset m_pReadArticleId to NULL.
	//	Hold onto pTemp so if this fails we can insure that the
	//	CIOReadLine is deleted !
	//

	if( !m_inputId->SendReadIO( pSocket, *m_pReadArticleId, TRUE ) ) {
		m_fReadArticleIdSent = FALSE ;
		CIO::Destroy( pTemp, *pdriver ) ;
		m_pReadArticleId = 0 ;
	}	
	DebugTrace( (DWORD_PTR)this, "Note sending a command m_pReadAritcleId %x", m_pReadArticleId ) ;
	return	TRUE ;
}

CAcceptNNRPD::CAcceptNNRPD() :
	m_cCompletes( -2 ),
	m_pbuffer( 0 )	{
}


BOOL
CAcceptNNRPD::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,
						CIORead*&	pRead,	
						CIOWrite*&	pWrite )	{

	//
	//	This starts the Accept NNRPD state - the state from which we process all
	//	incoming commands !  we want to issue an 'ok' string to the client,
	//	and then start getting incoming commands !
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 );
	
	CIOWriteLine*	pWriteLine = new( *pdriver ) CIOWriteLine( this ) ;
	if( pWriteLine ) {

		static	char	szConnectString[] = "200 Good Enough\r\n" ;
		DWORD	cb = 0 ;
		char*	szConnect = 0;


		//
		//	Figure out whether we are accepting posts right now.
		//
		PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
		if( pSocket->m_context.m_pInFeed->fAcceptPosts( pInst->GetInstanceWrapper() ) ) {

			szConnect = pInst->GetPostsAllowed( cb ) ;

		}	else	{

			szConnect = pInst->GetPostsNotAllowed( cb ) ;
			
		}
		
		if( !szConnect )	{
			szConnect = szConnectString ;
			cb = sizeof( szConnectString ) - 1 ;
		}

		if( pWriteLine->InitBuffers( pdriver, cb ) ) {
			CopyMemory( pWriteLine->GetBuff(), szConnect, cb ) ;
			pWriteLine->AddText(	cb) ;
			pWrite = pWriteLine ;
			return	TRUE ;
		}
	}
	if( pWriteLine )
		CIO::Destroy( pWriteLine, *pdriver ) ;
	return	FALSE ;
}

CIO*
CAcceptNNRPD::Complete( CIOReadLine*	pReadLine,	
						CSessionSocket*	pSocket,
						CDRIVERPTR&	pdriver,	
						int	cArgs,	
						char	**pszArgs,	
						char*	pchBegin
						)	{
	//
	//	Just completed a complete line of something from the client.
	//	Parse it into a command object which will be derived from one of
	//	two type - CExecute of CIOExecute.
	//	In the case of CExecute derived objects, we will build buffers
	//	in which we send the response to the client.
	//	CIOExecute derived objects are full blown states in them selves,
	//	and will have their own Start and Complete() functions. So we just
	//	record our state so that eventually we end up back here again.
	//

	TraceFunctEnter( "CAcceptNNRPD::Complete" ) ;

	_ASSERT( pReadLine != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT(	cArgs != 0 ) ;
	_ASSERT( pszArgs != 0 ) ;
	_ASSERT( pchBegin != 0 ) ;
	_ASSERT( pchBegin <= pszArgs[0] ) ;

	//
	//	Initialize these to report an error in case something goes wrong !
	//
	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD	dwOptional = 0 ;
	//
	//	If m_pbuffer is not NULL then we were holding a buffer for the sake of a CIOExecute
	//	object.  Now that we have been called from a read completion however, it is obvious
	//	that the CIOExecute object has completed whatever it was doing - in which case
	//	the reference m_pbuffer holds is not needed.  NOTE : Odds are good that most of the
	//	time m_pbuffer is 0 already !
	//
	m_pbuffer = 0 ;

	CExecutableCommand*	pExecute = 0 ;
	ECMD		ecmd ;
	BOOL		fIsLargeResponse = FALSE ;
	LPSTR		lpstrOperation = 0 ;
	char		szArgsBuffer[80] ;
	szArgsBuffer[0] = '\0' ;
	BuildCommandLogString( cArgs-1, pszArgs+1, szArgsBuffer, 80 ) ;

	//
	//	Set these to 0, they get set at some point while executing the command !
	//
	pSocket->m_context.m_nrcLast = (NRC)0 ;
	pSocket->m_context.m_dwLast = 0 ;

	//
	//	Build a command object which will process the client command !
	//

	CIOExecute*	pIOExecute = make(	cArgs,
									pszArgs,
									ecmd,
									pExecute,
									pSocket->m_context,
									fIsLargeResponse,
									*pdriver,
									lpstrOperation
									) ;

	CLogCollector*	pCollector = 0 ;
	if( ecmd & ((pSocket->m_context).m_pInstance)->GetCommandLogMask() ) {
		pCollector = &pSocket->m_Collector ;
		if( pCollector ) {
			_ASSERT( pCollector->m_cbBytesRecvd == 0 );
			_ASSERT( EQUALSI( pCollector->m_cbBytesSent, 0 ) );
			pCollector->m_cbBytesRecvd = pReadLine->GetBufferLen();
		}
	}

	//
	//	Get a hold of the buffer in which the command was sent !
	//  We keep a reference to this buffer untill we return to this state
	//	after executeing the CIOExecute derived state.
	//	We do this so that the buffer will not be discarded so that the
	//	CIOExecute object can keep pointers into the buffer's data if it needs to!
	//
	m_pbuffer = pReadLine->GetBuffer() ;

	//
	//	If we are collecting logging information use lpstrOperation if available -
	//	it is the canonicalized version of the command string and will always be the
	//	same case etc.... !
	//
	if( pCollector ) {
		if( lpstrOperation != 0 ) {
			pCollector->ReferenceLogData( LOG_OPERATION, (LPBYTE)lpstrOperation ) ;

			//
			//	The post commands set the LOG_PARAMETERS field themselves -
			//	don't do any allocations !
			//
			if( !(ecmd & (ePost | eIHave | eXReplic)) ) {
				char*	lpstr = (char*)pCollector->AllocateLogSpace( 80 ) ;
				*lpstr = '\0' ;
				CopyMemory( lpstr, szArgsBuffer, 80 ) ;
				pCollector->ReferenceLogData( LOG_PARAMETERS, (BYTE*)lpstr ) ;
			} else if( ecmd & eIHave && cArgs > 1 )	{
				pCollector->ReferenceLogData( LOG_PARAMETERS, (BYTE*)pszArgs[1] ) ;
			}

		}	else	{
			char*	lpstr = (char*)pCollector->AllocateLogSpace( 64 ) ;
			if (lpstr) {
    			*lpstr = '\0' ;
	    		BuildCommandLogString( cArgs, pszArgs, lpstr, 64 ) ;
		    	pCollector->ReferenceLogData( LOG_OPERATION, (BYTE*)lpstr ) ;
		    }
		}
	}

	if( pExecute != 0 || pIOExecute != 0 )	{
		if( pExecute )	{
			_ASSERT( pIOExecute == 0 ) ;

			m_cCompletes = -2 ;
			BOOL	f = pExecute->StartCommand(	this,
												fIsLargeResponse,
												pCollector,
												pSocket,
												*pdriver
												) ;

			//
			//	If this fails - we assume that StartCommand() makes the
			//	necessary calls to UnsafeClose() etc... to tear down the session !
			//	If this succeeds - then we check to see whether everythign has completed !
			//
			if( f ) {
				if( InterlockedIncrement( &m_cCompletes ) == 0 ) {
					return	pReadLine ;
				}	else	{
					return	0 ;
				}
			}

			return	0 ;
								
		}	else	{
			_ASSERT( pExecute == 0 ) ;
			_ASSERT( pIOExecute != 0 ) ;

			CIORead*	pRead = 0 ;
			CIOWrite*	pWrite = 0 ;

			if( pCollector ) {
				pIOExecute->DoTransactionLog( pCollector ) ;
			}

			CIOReadLine*	pReadLine = new( *pdriver ) CIOReadLine( this ) ;
			if( pReadLine )		{
				pIOExecute->SaveNextIO( pReadLine ) ;
				if( pIOExecute->StartExecute( pSocket, pdriver, pRead, pWrite ) )	{
					return	pRead ;
				}
			}
		}
	}	else	{

		cause = CAUSE_OOM ;
		dwOptional = GetLastError() ;

        // Don't block randfail testing
        //
		//_ASSERT( 1==0 ) ;
		// FATAL ERROR !! - Unable to create a command object !!

	}
	//
	//	Only reach here if some error has occurred !
	//
	pdriver->UnsafeClose( pSocket, cause,  dwOptional ) ;
	return	0 ;
}

CIO*
CAcceptNNRPD::InternalComplete(	
						CSessionSocket*			pSocket,
						CDRIVERPTR&				pdriver,
						CExecutableCommand*		pExecute,
						CLogCollector*			pCollector
						) {

	BOOL	fRead =  pExecute->CompleteCommand( pSocket, pSocket->m_context ) ;

	//
	//	Before destroying the CCmd object generate the transaction log - if requried
	//	This is because CCmd objects are allowed to put in references to their temp data
	//	etc... into the log data instead of copying all the strings around !
	//
	if( pCollector ) {
		pSocket->TransactionLog( pCollector, pSocket->m_context.m_nrcLast, pSocket->m_context.m_dwLast ) ;
	}

	//	Do it now before we try to another read or anything !!
	//	Because of the way these are allocated we must make sure
	//	this is destroyed before there's any potential of us wanting
	//	to use the memory this is allocated in when a read completes !!
	delete	pExecute ;

	if(	fRead ) {
		//
		//	Check whether this is the last thing to complete !!
		//
		if( InterlockedIncrement( &m_cCompletes ) == 0 ) {

			CIOReadLine*	pReadLine = new( *pdriver ) CIOReadLine( this ) ;
			if( !(pReadLine && pdriver->SendReadIO( pSocket, *pReadLine, TRUE )) )	{
				if( pReadLine )
					CIO::Destroy( pReadLine, *pdriver ) ;
				pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
			}								
		}
	}
	//
	//	Note : because we do not increment m_cCompletes when another Read is
	//	not requested there is NO chance that the CIOReadLine completion routing
	//	will mistakenly issue a read.
	//
	return 0 ;
}


CIO*
CAcceptNNRPD::Complete(	CIOWriteCMD*	pWriteCMD,
						CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver,
						CExecute*		pExecute,
						CLogCollector*	pCollector
						) {


	return	InternalComplete( pSocket, pdriver, pExecute, pCollector ) ;
}


CIO*
CAcceptNNRPD::Complete(	CIOWriteAsyncCMD*	pWriteCMD,
						CSessionSocket*		pSocket,
						CDRIVERPTR&			pdriver,
						CAsyncExecute*		pExecute,
						CLogCollector*		pCollector
						) {


	return	InternalComplete( pSocket, pdriver, pExecute, pCollector ) ;
}
						

						

CIO*
CAcceptNNRPD::Complete(	CIOWriteLine*	pioWriteLine,	
						CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver ) {

	//
	//	Wrote a line of text to the remote server -
	//	This could be our very first write (the 200 ok string) or a write
	//	generated bu a CExecute derived object.
	//	If its from a CExecute derived object, we need to see whether we can
	//	generate more text to send.
	//

	TraceFunctEnter( "CAcceptNNRPD::Complete CIOWriteLine" ) ;

	_ASSERT( pioWriteLine != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;

	CIOReadLine*	pReadLine = new( *pdriver ) CIOReadLine( this ) ;
	if( pReadLine )		{
		if( !pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
			pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
			CIO::Destroy( pReadLine, *pdriver ) ;
		}
	}	else	{
		ErrorTrace((DWORD_PTR)this, "Could not allocate CIOReadLine");
		pdriver->UnsafeClose(pSocket, CAUSE_OOM, 0, TRUE);
	}

	return	0 ;
}

COfferArticles::COfferArticles(	) :
	m_cCompletions( -2 ),
	m_cTransmitCompletions( -2 ),
	m_fTerminating( FALSE ),
	m_fDoTransmit( FALSE ),
	m_GroupidNext( INVALID_ARTICLEID ),
	m_ArticleidNext( INVALID_ARTICLEID ),
	m_GroupidTriedOnce( INVALID_ARTICLEID ),
	m_ArticleidTriedOnce( INVALID_ARTICLEID ),
	m_GroupidInProgress( INVALID_ARTICLEID ),
	m_ArticleidInProgress( INVALID_ARTICLEID ),
	m_fReadPostResult( FALSE )	{
}

char	COfferArticles::szQuit[] = "quit\r\n" ;

void
COfferArticles::Shutdown(	CIODriver&	driver,
							CSessionSocket*	pSocket,
							SHUTDOWN_CAUSE	cause,
							DWORD	dw )	{
/*++

Routine Description :

	This function is called when a session on which we are sending articles is terminated.
	If there is a transfer in progress, we will assume it failed and place the ID's of the
	article in transit back onto the end of the queue for the remote site.

Arguments :

	driver - the CIODriver	object running the session
	pSocket -	The CSessionSocket object associated with the session
	cause -	the reason for the termination of the session
	dw -	optional DWORD explaining the cause of termination

Return Value :

	None.

--*/

	TraceFunctEnter( "COfferArticles::Shutdown" ) ;


	DebugTrace( (DWORD_PTR)this, "m_GroupidInProgress %x m_ArticleIdInProgress %x",
		m_GroupidInProgress, m_ArticleidInProgress ) ;

	if( m_GroupidInProgress != INVALID_ARTICLEID && m_ArticleidInProgress != INVALID_ARTICLEID ) {
		if( pSocket != 0 && pSocket->m_context.m_pOutFeed != 0 ) {
			pSocket->m_context.m_pOutFeed->Append( m_GroupidInProgress, m_ArticleidInProgress) ;
		}
	}
}

int
COfferArticles::GetNextCommand(	
								CNewsTree*	pTree,
								COutFeed*	pOutFeed,
								BYTE*	lpb,	
								DWORD	cb,	
								DWORD&	ibOffset )	{
/*++

Routine Description :

	This function fills a buffer with the text of the next command we want to send to the
	remote server.  We keep pulling articles off a queue until we get a valid command to send.
	WE have to be carefull about how we terminate the session - if the remote server
	tells us to retry a send we will put a GROUPID ARTICLEID back in the queue.
	If we hit that retry pair again we will end the session - be carefull that that pair remainds
	on the queue.

Arguments :
	pTree -		The NewsTree for this virtual server - use to check for termination !
	pOutFeed -	The COutFeed derived object used to build commands
	lpb	-		Buffer in which to put command
	cb	-		number of bytes available in buffer
	ibOffset -	Offset in the buffer at which command was palced by us

Return Value :
	
	Number of bytes in buffer - 0 if failure

--*/

	TraceFunctEnter( "COfferArticles::GetNextCommand" ) ;


	ibOffset = 0 ;
	unsigned	cbOut = 0 ;
	do	{


		if( pTree->m_bStoppingTree ) {
			// Instance is stopping - bail early
			m_fTerminating = TRUE ;			
			ibOffset = 0 ;
			CopyMemory( lpb, szQuit, sizeof( szQuit ) - 1 ) ;
			cbOut = sizeof( szQuit ) - 1 ;
			return	cbOut ;
		}

		DebugTrace( (DWORD_PTR)this,
			"Top of loop - m_GroupidNext %x m_ArticleidNext %x m_GroupidTriedOnce %x m_ArticleidTriedOnce %x",
			m_GroupidNext, m_ArticleidNext, m_GroupidTriedOnce, m_ArticleidTriedOnce ) ;
		
		if(	!pOutFeed->Remove( m_GroupidNext, m_ArticleidNext ) ) {
			m_GroupidNext = INVALID_ARTICLEID ;
			m_ArticleidNext = INVALID_ARTICLEID ;
		}

		DebugTrace( (DWORD_PTR)this,
			"After Remove - m_GroupidNext %x m_ArticleidNext %x", m_GroupidNext, m_ArticleidNext ) ;
		
		if( m_GroupidNext != INVALID_ARTICLEID && m_ArticleidNext != INVALID_ARTICLEID &&
			!(m_GroupidNext == m_GroupidTriedOnce && m_ArticleidNext == m_ArticleidTriedOnce) )
			cbOut = pOutFeed->FormatCommand( lpb, cb, ibOffset, m_GroupidNext, m_ArticleidNext, m_pArticleNext ) ;
		else	{
			if( m_GroupidNext == m_GroupidTriedOnce && m_ArticleidNext == m_ArticleidTriedOnce )	{
				if( m_GroupidNext != INVALID_ARTICLEID && m_ArticleidNext != INVALID_ARTICLEID )	{
	
					DebugTrace( (DWORD_PTR)this, "Appending m_GroupidNext %x m_ArticleidNext %x",
						m_GroupidNext, m_ArticleidNext ) ;

					pOutFeed->Append( m_GroupidNext, m_ArticleidNext ) ;
				}
			}

			m_fTerminating = TRUE ;			
			ibOffset = 0 ;
			CopyMemory( lpb, szQuit, sizeof( szQuit ) - 1 ) ;
			cbOut = sizeof( szQuit ) - 1 ;
		}

	}	while( cbOut == 0 ) ;

	DebugTrace( (DWORD_PTR)this, "Returning cbOut %x bytes to caller", cbOut ) ;

	return	cbOut ;
}


CIOWriteLine*
COfferArticles::BuildWriteLine(	CSessionSocket*	pSocket,	
								CDRIVERPTR&	pdriver,	
								GROUPID	groupid,	
								ARTICLEID	artid ) {
/*++

Routine Description :

	This function builds the write we will send to the remote server containing the next command
	we wish to issue.

Arguments :

	pSocket - The socket on which the command will be sent
	pdriver	- The CIODriver managing IO for the socket

Return Value :

	A CIOWriteLine object to send to the remote server, NULL if failure.

--*/

	TraceFunctEnter( "COfferArticles::BuildWriteLing" ) ;

	CNewsTree* pTree = ((pSocket->m_context).m_pInstance)->GetTree() ;

	//
	//	Each time we prepare to issue a new command we check if we have recorded
	//	the information for the logging of a previous command - and if so we do it !
	//
	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush ) {
		if( pSocket->m_Collector.FLogRecorded() ) {
			pSocket->TransactionLog( &pSocket->m_Collector, pSocket->m_context.m_nrcLast, 0, FALSE ) ;
		}
	}

	CIOWriteLine*	pWriteLine = new( *pdriver )	CIOWriteLine( this ) ;

	DebugTrace( (DWORD_PTR)this, "Built CIOWriteLine %x", pWriteLine ) ;

	if( pWriteLine && pWriteLine->InitBuffers( pdriver ) ) {

		DWORD		ibTextOffset = 0 ;
		unsigned	cb = 0 ;
		BYTE*	pb = (BYTE*)pWriteLine->GetBuff( cb ) ;

		cb = GetNextCommand(	pTree, pSocket->m_context.m_pOutFeed, pb, cb, ibTextOffset ) ;
		if( cb != 0 ) {

#if 0
			if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush )	{

				pSocket->m_Collector.FillLogData( LOG_OPERATION, pb, min( cb-2, 200 ) ) ;	// -2 to exclude CRLF
				ADDI( pSocket->m_Collector.m_cbBytesSent, cb );	

			}
#endif
			OutboundLogFill( pSocket, pb, cb ) ;

			pWriteLine->SetLimits( (char*)pb+ibTextOffset, (char*)pb+ibTextOffset+cb ) ;

			DebugTrace( (DWORD_PTR)this, "Successfully built CIOWriteLine %x", pWriteLine ) ;

			return	pWriteLine ;
		}
	}

	DebugTrace( (DWORD_PTR)this, "Error building command - delete pWriteLine %x", pWriteLine ) ;

	if( pWriteLine != 0 )
		CIO::Destroy( pWriteLine, *pdriver ) ;

	return	0 ;
}

CIOTransmit*
COfferArticles::BuildTransmit(	CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver,
								GROUPID			groupid,	
								ARTICLEID		articleid	
								)	{
/*++

Routine Description :

	This function builds a TransmitFile operation which will send the requested article to the
	remote server as well as the subsequent command.

Arguments :

	pSocket - The CSessionSocket object on which we will do the send
	pdriver - The CIODriver object managing IO completions for the socket
	groupid	- The groupid for the article being sent
	articleid -		The articleid for the article being sent.

Return Value :

	A CIOTransmit object if successfull, NULL otherwise.

--*/


	TraceFunctEnter( "COfferArticles::BuildTransmit" ) ;

	DWORD		cbOut = 0 ;
	CBUFPTR		pbuffer = 0 ;
	CIOTransmit*	pTransmit = 0 ;
	DWORD		ibTextOffset = 0 ;

	pTransmit = new( *pdriver ) CIOTransmit( this ) ;
	if( pTransmit != 0 ) {

		CGRPPTR	pGroup = ((pSocket->m_context).m_pInstance)->GetTree()->GetGroupById( groupid ) ;
		if(		pGroup != 0 )	{
			DebugTrace( (DWORD_PTR)this, "Got pTransmit %x and pGroup %x", pTransmit, pGroup ) ;

			if( m_pCurrentArticle == 0 )	{
				//
				//	If we don't have an m_pCurrentArticle, we need to go to the
				//	hashtables and get a storeid to use with the driver !
				//
				CStoreId	storeid ;

				FILETIME	ft ;
				BOOL		fPrimary ;
				WORD		HeaderOffset ;
				WORD		HeaderLength ;
				DWORD cStoreIds = 0;
				DWORD	DataLen = 0 ;

				if( ((pSocket->m_context).m_pInstance)->XoverTable()->ExtractNovEntryInfo(
						groupid,
						articleid,
						fPrimary,
						HeaderOffset,
						HeaderLength,
						&ft,
						DataLen,
						0,
						cStoreIds,
						&storeid,
						NULL))	{
					m_pCurrentArticle = pGroup->GetArticle(	
											articleid,
											storeid,
											0,
											0,
											!pSocket->m_context.m_IsSecureConnection
											) ;
				}
			}
					
			if( m_pCurrentArticle == 0 ) {

				ErrorTrace( (DWORD_PTR)this, "Unable to get Article" ) ;

				PCHAR	args[2] ;
				char	szArticleId[20] ;
				_itoa( articleid, szArticleId, 10 ) ;
				args[0] = szArticleId ;
				args[1] = pGroup->GetNativeName() ;

				NntpLogEventEx( NNTP_QUEUED_ARTICLE_FAILURE,
						2,
						(const char **)args,
						GetLastError(),
						((pSocket->m_context).m_pInstance)->QueryInstanceId()
						) ;

			}	else	{

				FIO_CONTEXT*	pFIOContext = 0 ;
				DWORD	ibOffset ;
				DWORD	cbLength ;

				if( (pFIOContext = m_pCurrentArticle->fWholeArticle( ibOffset, cbLength )) != 0 ) {
					if( pTransmit->Init( pdriver, pFIOContext, ibOffset, cbLength ) )	{
						m_GroupidInProgress = groupid ;
						m_ArticleidInProgress = articleid ;

						DebugTrace( (DWORD_PTR)this,
							"Ready to send article m_GroupidInProgress %x m_ArticleidInProgress %x",
							m_GroupidInProgress, m_ArticleidInProgress ) ;

						IncrementStat( ((pSocket->m_context).m_pInstance), ArticlesSent );

						return	pTransmit ;
					}
				}
			}
		}
	}

	ErrorTrace( (DWORD_PTR)this, "An error occurred - delete pTransmit %x", pTransmit ) ;

	if( pTransmit != 0 )
		CIO::Destroy( pTransmit, *pdriver ) ;
	return	0 ;
}


BOOL
COfferArticles::Start(	CSessionSocket*	pSocket,	
						CDRIVERPTR&	pdriver,
						CIORead*&	pRead,
						CIOWrite*&	pWrite	)	{
/*++

Routine Description :

	Start the COfferArticles State - we need to issue our first IO to the remote
	server which will be to write a command to the port.

Arguments :
	
	pSocket -	The data associated with this socket
	pdriver -	The CIODriver managing IO Completions for this socket
	pRead -		The pointer through which we return our first Read IO
	pWrite -	The pointer through which we return our first Write IO

Return Value :

	TRUE if successfull - FALSE otherwise

--*/

	pSocket->m_context.m_nrcLast = NRC(0);

	CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this ) ;

	if( pReadLine == 0 ) {
		return	FALSE ;
	}	else	{
		
		CIOWriteLine*	pWriteLine = BuildWriteLine(	pSocket,
														pdriver,
														m_GroupidNext,
														m_ArticleidNext ) ;
		if( pWriteLine != 0 ) {
			pRead = pReadLine ;
			pWrite = pWriteLine ;
			return	TRUE ;
		}
	}
	if( pReadLine != 0 )
		CIO::Destroy( pReadLine, *pdriver ) ;

	return	FALSE ;
}

CIO*
COfferArticles::Complete(	CSessionSocket*	pSocket,	
							CDRIVERPTR&	pdriver
							)	{
/*++

Routine Description :

	For every article we wish to transfer we complete two IO's - a read which tells
	us whether the remote site wants the article and a write of the command which would
	send the article to the remote site.
	So we use InterlockedIncrement to make sure when the final of these IO's complete,
	we issue the next batch of IO's to do the next transfer.

Arguments :

	pSocket -	The socket on which we are sending
	pdriver -	The CIODriver managing IO completions

Return Value :
	
	The CIO object to execute next.	This is always a write.

--*/

	TraceFunctEnter( "COfferArticles::Complete" ) ;

	CIO*	pioNext ;

	SHUTDOWN_CAUSE	cause	= CAUSE_UNKNOWN ;
	DWORD	dwError = 0 ;
	
	if( InterlockedIncrement( &m_cCompletions ) < 0 ) {
		return	0 ;
	}	else	{

		DebugTrace( (DWORD_PTR)this, "GrpInProgress %x ArtInProg %x GrpNext %x ArtNext %x",
				m_GroupidInProgress, m_ArticleidInProgress, m_GroupidNext, m_ArticleidNext ) ;

		//	
		//	We know everything about how the last transfer completed - so NIL these out !
		//
		m_GroupidInProgress = INVALID_ARTICLEID ;
		m_ArticleidInProgress = INVALID_ARTICLEID ;

		//
		//	Free any Article objects we may have been holding !
		//
		m_pCurrentArticle = m_pArticleNext ;
		m_pArticleNext = 0 ;

		if( m_GroupidNext != INVALID_ARTICLEID && m_ArticleidNext != INVALID_ARTICLEID ) {

			GROUPID	groupid = m_GroupidNext ;
			ARTICLEID	articleid = m_ArticleidNext ;

			if(	m_fDoTransmit )	{
				pioNext = BuildTransmit( pSocket,	pdriver,	groupid, articleid ) ;		
			}	else	{
				pioNext = BuildWriteLine( pSocket,	pdriver,	m_GroupidNext,	m_ArticleidNext ) ;
			}

			DebugTrace( (DWORD_PTR)this, "Have build pioNext %x m_fDoTransmit %x", pioNext, m_fDoTransmit ) ;
		
			if( pioNext != 0 ) {
				if( m_fDoTransmit ) {
					m_fReadPostResult = TRUE ;
				}	else	{
					m_fReadPostResult = FALSE ;
				}
				m_cCompletions = -2 ;
				return	pioNext ;
			}	else	{
				cause = CAUSE_OOM ;
				dwError = GetLastError() ;
			}

		}	else	{
			// finished sending articles
			cause = CAUSE_NODATA ;
		}
	}	

	ErrorTrace( (DWORD_PTR)this, "Error Occurred m_GroupidNext %x m_ArticleidNext %x",
			m_GroupidNext, m_ArticleidNext ) ;

	if( m_GroupidNext != INVALID_ARTICLEID && m_ArticleidNext != INVALID_ARTICLEID )
		pSocket->m_context.m_pOutFeed->Append( m_GroupidNext, m_ArticleidNext ) ;
	pdriver->UnsafeClose( pSocket, cause, dwError ) ;
	return	0 ;
}

CIO*
COfferArticles::Complete(	CIOReadLine*	pReadLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							int				cArgs,
							char**			pszArgs,
							char*			pchBegin ) {
/*++

Routine Description :

	This function handles read completions when we are in the COfferArticles state.
	We use m_fReadPostResult to determine whether we are expecting to see the result of
	a post or the result of a command we issued.
	When looking at the result of a transfer - check if the transfer failed and needs to
	be requeued.
	When looking at the result of a command - check whether we want to go ahead and
	send the next article.

Arguments :

	pReadLine -		The CIOReadLine object which is completing the read
	pSocket -		The CSessionSocket object associated with the socket.
	pdriver -		The CIODriver managing IO completions for this socket.
	cArgs -			Number of arguments in the response
	pszArgs -		Array of pointers to the response strings
	pchBegin -		first byte of the response that we can destructively
					use if we desire (we dont)

Return Value ;

	Always the same CIOReadLine that called us, unless an error occurred and
	we're tearing down the session - in which case we'll return NULL.

--*/


	TraceFunctEnter( "COfferArticles::Complete - CIOReadline" ) ;

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	DWORD	dwError = 0 ;

	NRC	code ;
	if(	ResultCode( pszArgs[0], code ) )	{

		pSocket->m_context.m_nrcLast = code ;

		DebugTrace( (DWORD_PTR)this, "Result - %d m_fReadPostResult %x",
			code, m_fReadPostResult ) ;

		// if the code is from posting a article on the remote server then
		// increment the appropriate feed counter for this article
		if (m_fReadPostResult) {
			pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);
		}

		if( m_fReadPostResult || m_fTerminating ) {

			//
			//	Have completed the final read of an article transfer, or we're terminating -
			//	issue a transaction log if appropriate !
			//
			if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush ) {

				pSocket->m_Collector.m_cbBytesRecvd += pReadLine->GetBufferLen();

				char*	lpstr = (char*)pSocket->m_Collector.AllocateLogSpace( 64 ) ;
				if( lpstr ) {
					BuildCommandLogString( cArgs-1, pszArgs+1, lpstr, 64 ) ;
					pSocket->m_Collector.ReferenceLogData( LOG_TARGET, (BYTE*)lpstr ) ;
				}	else	{
					pSocket->m_Collector.FillLogData( LOG_TARGET, (BYTE*)pszArgs[0], 4 ) ;
				}

			}

			//
			//	We don't really care about the result of the post command !!!
			//
			m_fReadPostResult = FALSE ;


			//
			//	Figure out whether we were to retry this post later !
			//
			if( pSocket->m_context.m_pOutFeed->RetryPost( code ) ) {

				DebugTrace( (DWORD_PTR)this, "Retry post later - grpInProg %x ArtInProg %x",
					m_GroupidInProgress, m_ArticleidInProgress ) ;

				if( m_GroupidInProgress != INVALID_ARTICLEID && m_ArticleidInProgress != INVALID_ARTICLEID ) {
					pSocket->m_context.m_pOutFeed->Append( m_GroupidInProgress, m_ArticleidInProgress ) ;
					if( m_GroupidTriedOnce == INVALID_ARTICLEID && m_ArticleidTriedOnce == INVALID_ARTICLEID ) {
						m_GroupidTriedOnce = m_GroupidInProgress ;
						m_ArticleidTriedOnce = m_ArticleidInProgress ;

						DebugTrace( (DWORD_PTR)this, "TriedOnce Group %x Art %x", m_GroupidTriedOnce,
							m_ArticleidTriedOnce ) ;

					}
				}
			}
	
			//
			//	No article is being transferred right now !
			//
			m_GroupidInProgress = INVALID_ARTICLEID ;
			m_ArticleidInProgress = INVALID_ARTICLEID ;

			if( InterlockedIncrement( &m_cTransmitCompletions ) < 0 ) {

				return	0 ;

			}	else	{

				m_cTransmitCompletions = -2 ;

				if( m_fTerminating ) {

					cause = CAUSE_USERTERM ;

					//
					//	Check if we need to do this here ??
					//
					if( (pSocket->m_context.m_pInstance)->GetCommandLogMask() & eOutPush ) {
						pSocket->TransactionLog( &pSocket->m_Collector, FALSE ) ;
					}

				}	else	{

					CIOWriteLine*	pWriteLine = BuildWriteLine(	pSocket,
																	pdriver,
																	m_GroupidNext,
																	m_ArticleidNext ) ;
					if( pWriteLine != 0 ) {
						if( pdriver->SendWriteIO( pSocket,	*pWriteLine, TRUE ) ) {
			
							DebugTrace( (DWORD_PTR)this, "SendWriteIO succeeded" ) ;

							//
							//	Successfully issued IO log it to the transaction log
							//
							

							//
							//	Successfully issued the command - read the response !
							//

							return	pReadLine ;
						}	else	{

							//
							//	Session is dropping - blow off anything we allocated !
							//

							ErrorTrace( (DWORD_PTR)this, "SendWriteIO failed" ) ;

							CIO::Destroy( pWriteLine, *pdriver ) ;
						}
					}
				}
			}
			//
			//	fall through into error code which blows off session !
			//

		}	else	{


			if( code == 340 || code == 341 || code == 342 || code == 335 ) {
				m_fDoTransmit = TRUE ;
			}	else	{
				m_fDoTransmit = FALSE ;
				pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);
			}

			//
			//	Do we wish to log the first response to our command ?
			//
			if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush ) {

				pSocket->m_Collector.m_cbBytesRecvd += pReadLine->GetBufferLen();

				char*	lpstr = (char*)pSocket->m_Collector.AllocateLogSpace( 64 ) ;
				if( lpstr ) {
					BuildCommandLogString( cArgs-1, pszArgs+1, lpstr, 64 ) ;
					pSocket->m_Collector.ReferenceLogData( LOG_TARGET, (BYTE*)lpstr ) ;
				}	else	{
					pSocket->m_Collector.FillLogData( LOG_TARGET, (BYTE*)pszArgs[0], 4 ) ;
				}
			}

			//
			//	Build the appropriate response to transmit back to remote site !
			//
			CIO*	pio = Complete(	pSocket,	pdriver	) ;

			DebugTrace( (DWORD_PTR)this, "About to send pio %x", pio ) ;

			if( pio != 0 ) {
				if( pdriver->SendWriteIO( pSocket,	*pio, TRUE ) ) {
	
					DebugTrace( (DWORD_PTR)this, "SendWriteIO succeeded" ) ;

					return	pReadLine ;
				}	else	{

					ErrorTrace( (DWORD_PTR)this, "SendWriteIO failed" ) ;

					CIO::Destroy( pio, *pdriver ) ;
				}
			}	else	{
				return	0 ;
			}
		}
	}	else	{
		cause = CAUSE_ILLEGALINPUT ;
	}

	ErrorTrace( (DWORD_PTR)this, "Closing session - unusual termination" ) ;

	pdriver->UnsafeClose( pSocket, cause, dwError ) ;
	return	0 ;
}

CIO*
COfferArticles::Complete(	CIOWriteLine*	pWriteLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver )	{


	CIO*	pio = Complete( pSocket, pdriver ) ;

	if( pio == 0 ) {
		return	pio ;
	}	else	{
		CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this ) ;
		if( pReadLine != 0 ) {
			if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) )	{
				return	pio ;
			}	else	{
				CIO::Destroy( pReadLine, *pdriver ) ;
			}
		}
	}
	if( pio != 0 ) {
		CIO::Destroy( pio, *pdriver ) ;
	}
	pdriver->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
	return	0 ;
}

CIO*
COfferArticles::Complete(	CIOTransmit*	pTransmit,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							TRANSMIT_FILE_BUFFERS*	ptrans,
							unsigned cbBytes )	{

	//
	//	Do we wish to log the first response to our command ?
	//
	if( ((pSocket->m_context).m_pInstance)->GetCommandLogMask() & eOutPush ) {

		ADDI( pSocket->m_Collector.m_cbBytesSent, cbBytes );

	}

	SHUTDOWN_CAUSE	cause = CAUSE_OOM ;

	CIOWriteLine*	pWriteLine = 0 ;

	if( InterlockedIncrement( &m_cTransmitCompletions ) == 0 ) {

		m_cTransmitCompletions = -2 ;

		if( m_fTerminating ) {

			cause = CAUSE_USERTERM ;

		}	else	{

			//
			//	Read completed first - we should not be waiting to read
			//	the response to the posted article any longer !
			//
			_ASSERT( !m_fReadPostResult ) ;

			pWriteLine = BuildWriteLine(	pSocket,
											pdriver,
											m_GroupidNext,
											m_ArticleidNext
											) ;
			if( pWriteLine != 0 ) {

				CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this ) ;
				if( pReadLine != 0 ) {
					if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) )	{
						return	pWriteLine ;
					}	else	{
						CIO::Destroy( pReadLine, *pdriver ) ;
					}
				}
			}
		}

	}	else	{

		return	0 ;
	}

	//
	//	In case of error fall through to here !
	//

	if( pWriteLine != 0 )
		CIO::Destroy( pWriteLine, *pdriver ) ;

	pdriver->UnsafeClose( pSocket, cause, 0 ) ;
	return	0 ;

}

BOOL
CNegotiateStreaming::Start(	CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							CIORead*&		pRead,
							CIOWrite*&		pWrite
							)	{

	CIOWriteLine*	pWriteLine = new( *pdriver ) CIOWriteLine( this ) ;
	CIOReadLine*	pReadLine = new( *pdriver )	CIOReadLine( this ) ;
	if( pWriteLine && pReadLine ) {

		static	char	szModeStream[] = "mode stream\r\n" ;
		DWORD	cb = sizeof( szModeStream ) - 1 ;

		if( pWriteLine->InitBuffers( pdriver, cb ) ) {
			CopyMemory( pWriteLine->GetBuff(), szModeStream, cb ) ;
			pWriteLine->AddText(	cb) ;
			pWrite = pWriteLine ;
			pRead = pReadLine ;

			OutboundLogFill( pSocket, (LPBYTE)szModeStream, sizeof( szModeStream ) - 1 ) ;

			return	TRUE ;
		}
	}


	if( pWriteLine )
		CIO::Destroy( pWriteLine, *pdriver ) ;

	if( pReadLine )
		CIO::Destroy( pReadLine, *pdriver ) ;

	return	FALSE ;
}

CIO*
CNegotiateStreaming::Complete(	CIOReadLine*	pReadLine,
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver,
								int				cArgs,
								char**			pszArgs,
								char*			pchBegin	
								)	{

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;
	NRC	code ;

	BOOL	fResult = ResultCode( pszArgs[0], code ) ;

	OutboundLogResults( pSocket,
						fResult,
						code,
						cArgs,
						pszArgs
						) ;

	if( fResult )	{

		if( code == nrcModeStreamSupported )	{

			m_fStreaming = TRUE ;

		}	else	{

			m_fStreaming = FALSE ;
		}

		if( InterlockedIncrement( &m_cCompletions ) < 0 ) {
	
			return	0 ;

		}	else	{

			CIORead*	pRead = 0 ;
			CIOWrite*	pWrite = 0 ;

			if( NextState( pSocket, pdriver, pRead, pWrite ) ) {
				if( pWrite != 0 ) {
					if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
						return	pRead ;
					}	else	{
						CIO::Destroy( pWrite, *pdriver ) ;
						if( pRead )
							CIO::Destroy( pRead, *pdriver ) ;
					}
				}	else	{
					return	pRead ;
				}
			}
		}

	}	else	{

		cause	= CAUSE_ILLEGALINPUT ;

	}

	pdriver->UnsafeClose( pSocket, cause, 0	) ;
	return	0 ;
}

CIO*
CNegotiateStreaming::Complete(	CIOWriteLine*	pWriteLine,
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver
								)	{

	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;


	if( InterlockedIncrement( &m_cCompletions ) < 0 ) {

		return	0 ;

	}	else	{

		CIORead*	pRead = 0 ;
		CIOWrite*	pWrite = 0 ;

		if( NextState( pSocket, pdriver, pRead, pWrite ) ) {
			if( pRead != 0 ) {
				if( pdriver->SendReadIO( pSocket, *pRead, TRUE ) )	{
					return	pWrite ;
				}	else	{
					CIO::Destroy( pRead, *pdriver ) ;
					if( pWrite )
						CIO::Destroy( pWrite, *pdriver ) ;
				}
			}	else	{
				return	pWrite ;
			}
		}
	}

	pdriver->UnsafeClose( pSocket, cause, 0	) ;
	return	0 ;
}

BOOL
CNegotiateStreaming::NextState(
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver,
								CIORead*&	pRead,
								CIOWrite*&	pWrite
								) {

	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 ) ;

	CSTATEPTR	pState ;
	if( m_fStreaming ) {
		pState = new	CCheckArticles() ;		
	}	else	{
		pState = new	COfferArticles() ;
	}

	if( pState ) {

		if( pState->Start(	pSocket,
							pdriver,
							pRead,
							pWrite ) ) {
			return	TRUE ;
		}
	}
	return	FALSE ;
}

CStreamBase::CStreamBase()	:
	m_GroupIdRepeat( INVALID_GROUPID ),
	m_ArticleIdRepeat( INVALID_ARTICLEID ),
	m_fDrain( FALSE )	{
}

BOOL
CStreamBase::Remove(	CNewsTree*	pTree,
						COutFeed*	pOutFeed,
						GROUPID&	groupId,
						ARTICLEID&	articleId	
						) {

	_ASSERT( pOutFeed != 0 ) ;

	if( pTree->m_bStoppingTree )
		m_fDrain = TRUE ;

	if( !m_fDrain ) {

		if( pOutFeed->Remove(	groupId,
								articleId ) )	{

			if( groupId == INVALID_GROUPID ||
				articleId == INVALID_ARTICLEID ) {

				m_fDrain = TRUE ;

			}	else	{

				if( groupId == m_GroupIdRepeat &&
					articleId == m_ArticleIdRepeat ) {
					
					m_fDrain = TRUE ;
					pOutFeed->Append( groupId, articleId ) ;
				}	else	{
					return	TRUE ;
				}
			}
		}	else	{

			m_fDrain = TRUE ;

		}
	}

	groupId = INVALID_GROUPID ;
	articleId = INVALID_ARTICLEID ;
	return	FALSE ;
}	



CIOWriteLine*
CStreamBase::BuildQuit(	CDRIVERPTR&	pdriver	)	{

	//
	//	Send the quit command !!!
	//
	static	char	szQuit[] = "quit\r\n" ;

	CIOWriteLine*	pWrite = new( *pdriver ) CIOWriteLine( this ) ;

	if( pWrite && pWrite->InitBuffers( pdriver, sizeof( szQuit ) ) ) {
		CopyMemory( pWrite->GetBuff(), szQuit, sizeof( szQuit ) -1  ) ;
		pWrite->AddText(	sizeof( szQuit ) - 1) ;

		return	pWrite ;
	}
	if( pWrite != 0 )
		CIO::Destroy( pWrite, *pdriver ) ;

	return	0 ;	
}

void
CStreamBase::ReSend(	COutFeed*	pOutFeed,
						GROUPID		groupId,
						ARTICLEID	articleId
						)	{

	_ASSERT( pOutFeed != 0 ) ;
	_ASSERT( groupId != INVALID_GROUPID ) ;
	_ASSERT( articleId != INVALID_ARTICLEID ) ;

	if( m_GroupIdRepeat == INVALID_GROUPID &&
		m_ArticleIdRepeat == INVALID_ARTICLEID ) {

		m_GroupIdRepeat = groupId ;
		m_ArticleIdRepeat = articleId ;

	}

	pOutFeed->Append( groupId, articleId ) ;
}
								

CCheckArticles::CCheckArticles()	:
	m_cChecks( 0 ),
	m_iCurrentCheck( 0 ),
	m_cSends( 0 ),
	m_iCurrentSend( 0 ),
	m_fDoingChecks( FALSE )	{

	for( int i=0; i<16; i++ ) {
		m_artrefCheck[i].m_groupId = INVALID_GROUPID ;
		m_artrefCheck[i].m_articleId = INVALID_ARTICLEID ;

		m_artrefSend[i].m_groupId = INVALID_GROUPID ;
		m_artrefSend[i].m_articleId = INVALID_ARTICLEID ;
	}
}


CCheckArticles::CCheckArticles(
		CArticleRef*	pArticleRef,
		DWORD			cSent
		) :
	m_fDoingChecks( FALSE ),
	m_cSends( cSent ),
	m_iCurrentSend( 0 ),
	m_cChecks( 0 ),
	m_iCurrentCheck( 0 )	{


	for( int i=0; i<16; i++ ) {
		m_artrefCheck[i].m_groupId = INVALID_GROUPID ;
		m_artrefCheck[i].m_articleId = INVALID_ARTICLEID ;

		m_artrefSend[i].m_groupId = INVALID_GROUPID ;
		m_artrefSend[i].m_articleId = INVALID_ARTICLEID ;
	}

	_ASSERT( cSent < 16 ) ;

	if( cSent != 0 )
		CopyMemory( &m_artrefSend[0], pArticleRef, sizeof( CArticleRef ) * min( cSent, 16 ) ) ;
}


BOOL
CCheckArticles::FillCheckBuffer(
					CNewsTree*		pTree,
					COutFeed*		pOutFeed,
					BYTE*			lpb,
					DWORD			cb
					)	{

	_ASSERT( pOutFeed != 0 ) ;
	_ASSERT( lpb !=  0 ) ;
	_ASSERT( cb != 0 ) ;

	DWORD	i = 0 ;
	m_mlCheckCommands.m_cEntries = 0 ;

	do	{	

		BOOL	fRemove = Remove(
							pTree,
							pOutFeed,
							m_artrefCheck[i].m_groupId,
							m_artrefCheck[i].m_articleId
							) ;

		if( !fRemove ||
			m_artrefCheck[i].m_groupId == INVALID_GROUPID ||
			m_artrefCheck[i].m_articleId == INVALID_ARTICLEID )	{
			break ;
		}

		DWORD	cbOut = pOutFeed->FormatCheckCommand(
								lpb + m_mlCheckCommands.m_ibOffsets[i],
								cb - m_mlCheckCommands.m_ibOffsets[i],
								m_artrefCheck[i].m_groupId,
								m_artrefCheck[i].m_articleId
								) ;

		if( cbOut == 0 ) {
			if( GetLastError() != ERROR_FILE_NOT_FOUND ) {
				ReSend(	pOutFeed,
						m_artrefCheck[i].m_groupId,
						m_artrefCheck[i].m_articleId
						) ;
				m_artrefCheck[i].m_groupId =  INVALID_GROUPID ;
				m_artrefCheck[i].m_articleId = INVALID_ARTICLEID ;
			}
		}	else	{
			m_mlCheckCommands.m_ibOffsets[i+1] =
				m_mlCheckCommands.m_ibOffsets[i]+cbOut ;
			cb -= cbOut ;
			i++ ;
			m_mlCheckCommands.m_cEntries = i ;
		}
	}	while(	cb > 20 && i < 16 ) ;

	return	i != 0 ;
}



CIOTransmit*
CStreamBase::NextTransmit(	GROUPID			GroupId,
							ARTICLEID		ArticleId,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							CTOCLIENTPTR&		pArticle
							)	{
				
	DWORD	cbOut = 0 ;
	SetLastError( NO_ERROR ) ;

	CIOTransmit*	pTransmit =		new( *pdriver )	CIOTransmit( this ) ;
	CBUFPTR	pbuffer = (pTransmit != 0) ? pdriver->AllocateBuffer( cbMediumBufferSize ) : 0 ;

	if( pbuffer != 0 ) {

		_ASSERT( pTransmit != 0 ) ;

		DWORD	ibStart = 0 ;
		DWORD	cbLength = 0 ;
		//LPTS_OPEN_FILE_INFO		pOpenFile ;

		FIO_CONTEXT*	pFIOContext = 0 ;

		cbOut =
			pSocket->m_context.m_pOutFeed->FormatTakethisCommand(
											(BYTE*)&pbuffer->m_rgBuff[0],
											pbuffer->m_cbTotal,
											GroupId,
											ArticleId,
											pArticle
											) ;

		if( cbOut != 0 ) {

			_ASSERT( pArticle != 0 ) ;

			FIO_CONTEXT*	pFIOContext = 0 ;

			if( (pFIOContext = pArticle->fWholeArticle( ibStart, cbLength )) != 0  ) {
				if( pTransmit->Init(	pdriver,
									pFIOContext,
									ibStart,
									cbLength,
									pbuffer,
									0,
									cbOut ) )	{
					return	pTransmit ;
				}
			}
		}	
	}

	//
	//	If for some reason we have not
	//	built a pTransmit Object to send then we need
	//	to requeue the article !
	//

	if( GetLastError() != ERROR_FILE_NOT_FOUND ) {

		ReSend(	pSocket->m_context.m_pOutFeed,
				GroupId,
				ArticleId
				) ;

	}

	if( pTransmit )
		CIO::Destroy( pTransmit, *pdriver ) ;
	
	return	0 ;
}



CIOWrite*
CCheckArticles::InternalStart(	
						CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver
						) {

	CIOWrite*	pWrite = 0 ;

	if( m_mlCheckCommands.m_pBuffer == 0 )	{
		m_mlCheckCommands.m_pBuffer =	
			pdriver->AllocateBuffer( cbMediumBufferSize ) ;
	}

	if( m_mlCheckCommands.m_pBuffer ) {

		CNewsTree* pTree = ((pSocket->m_context).m_pInstance)->GetTree() ;

		if( FillCheckBuffer(
						pTree,	
						pSocket->m_context.m_pOutFeed,
						(BYTE*)&m_mlCheckCommands.m_pBuffer->m_rgBuff[0],
						m_mlCheckCommands.m_pBuffer->m_cbTotal
						) ) {

			_ASSERT( m_mlCheckCommands.m_cEntries != 0 ) ;
			_ASSERT( m_mlCheckCommands.m_cEntries <= 16 ) ;

			m_cChecks = m_mlCheckCommands.m_cEntries ;

			pWrite = new( *pdriver ) CIOMLWrite(
											this,
											&m_mlCheckCommands,
											TRUE,
											0
											) ;
		}
	}
	return	pWrite ;
}


BOOL
CCheckArticles::Start(	
						CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver,
						CIORead*&		pRead,
						CIOWrite*&		pWrite
						) {

	pRead = 0 ;
	pWrite = 0 ;

	_ASSERT( m_iCurrentCheck == 0 ) ;
	_ASSERT( m_cChecks == 0 ) ;

	m_iCurrentCheck = 0 ;
	m_cChecks = 0 ;

	if( m_cSends == 0 ) {

		m_fDoingChecks = TRUE ;

	}	else	{

		m_fDoingChecks = FALSE ;

	}

	pWrite = InternalStart(	pSocket,
							pdriver
							) ;
	
	return	pWrite != 0 ;
}




int
CCheckArticles::Match(	char*	szMessageId,
						DWORD	cb ) {

	//
	//	Match up the response with the request block !
	//
	DWORD	cbMessageId = lstrlen( szMessageId ) ;
	int		iCheck = m_iCurrentCheck ;
	for( DWORD	i=0; i != 16; i++ ) {

		iCheck = (iCheck + i) % 16 ;

		BYTE*	lpbCheck = m_mlCheckCommands.Entry(iCheck) + cb ;
		DWORD	cbCheck = (DWORD)(m_mlCheckCommands.Entry(iCheck+1) - lpbCheck - 2) ;
	
		if( cbCheck == cbMessageId &&
			memcmp( lpbCheck, szMessageId, cbCheck ) == 0 ) {
			return	iCheck ;
		}
	}
	return	-1 ;
}

CIO*
CCheckArticles::Complete(	CIOWriteLine*	pWriteLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver
							)	{

	//
	//	All done - drop session !
	//

	OutboundLogAll(	pSocket,
			FALSE,
			NRC(0),
			0,
			0,
			"quit"
			) ;

	pdriver->UnsafeClose( pSocket, CAUSE_NODATA, 0	) ;
	return	0 ;
}

CIO*
CCheckArticles::Complete(	CIOReadLine*	pReadLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							int				cArgs,
							char**			pszArgs,
							char*			pchBegin
							)	{

	NRC	code ;
	BOOL	fCode = ResultCode( pszArgs[0], code ) ;
	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;

	CIO*		pReturn = pReadLine ;
	CIOTransmit*	pTransmit = 0 ;
	
	if( m_fDoingChecks ) {

		OutboundLogAll(	pSocket,
						fCode,
						code,
						cArgs,
						pszArgs,
						"check"
						) ;
		
		int	iMatch = DWORD(m_iCurrentCheck) ;
	
		if( cArgs >= 2 ) {
			iMatch = Match( pszArgs[1],
							pSocket->m_context.m_pOutFeed->CheckCommandLength() ) ;
		}	else	{
			iMatch = m_iCurrentCheck ;
		}

        // fix bug 33350: Its possible for remote to send 238 <junk-msg-id>
        // in which case Match fails and we hit this assert. However, this
        // is harmless and so it is better to not assert.
		// _ASSERT( iMatch == m_iCurrentCheck || pszArgs[1][0] != '<' ) ;
		iMatch = m_iCurrentCheck ;

		if( fCode )	{


			//
			//	Advance the counter of the check response we are waiting for for the next
			//	read to complete !
			//
			m_iCurrentCheck ++ ;

			if( m_iCurrentCheck == m_cChecks )	{
				//
				//	Reset the number of checks we are doing !
				//
				m_cChecks = 0 ;
				m_fDoingChecks = FALSE ;
				m_iCurrentCheck = 0 ;

			}

			_ASSERT( m_artrefCheck[iMatch].m_groupId != INVALID_GROUPID ) ;
			_ASSERT( m_artrefCheck[iMatch].m_articleId != INVALID_ARTICLEID ) ;

			if( code == nrcSWantArticle )	{

				pTransmit =
					NextTransmit(	m_artrefCheck[iMatch].m_groupId,
									m_artrefCheck[iMatch].m_articleId,
									pSocket,
									pdriver,
									m_pArticle
									) ;

				if( pTransmit ) {

					m_artrefSend[m_cSends].m_groupId = m_artrefCheck[iMatch].m_groupId ;
					m_artrefSend[m_cSends].m_articleId = m_artrefCheck[iMatch].m_articleId ;
					m_artrefCheck[iMatch].m_groupId = INVALID_GROUPID ;
					m_artrefCheck[iMatch].m_articleId = INVALID_ARTICLEID ;


					m_cSends ++ ;
					if( pdriver->SendWriteIO( pSocket, *pTransmit, TRUE ) ) {
						return	0 ;
					}	else	{
						m_cSends -- ;
						CIO::Destroy( pTransmit, *pdriver ) ;
						pdriver->UnsafeClose( pSocket, cause, 0 ) ;
						return	0 ;
					}

				}	else	{

					//pdriver->UnsafeClose( pSocket, cause, 0 ) ;
					//return	0 ;

					//
					//	In this case - just fall through !
					//	NOTE: NextTransmit() will requeue the article
					//	for later transmission if appropriate !
					//
				}


			}	else	if( code == nrcSTryAgainLater	)	{

				pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

				ReSend(	pSocket->m_context.m_pOutFeed,
						m_artrefCheck[iMatch].m_groupId,
						m_artrefCheck[iMatch].m_articleId
						) ;

				m_artrefCheck[iMatch].m_articleId = INVALID_ARTICLEID ;
				m_artrefCheck[iMatch].m_groupId = INVALID_GROUPID ;

			}	else	if( code == nrcSNotAccepting || code != nrcSAlreadyHaveIt ) {

				pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

				pdriver->UnsafeClose( pSocket, cause, 0 ) ;
				return	 0 ;

			}	else	{

				//
				//	This is the only other thing we should see here !
				//

				_ASSERT( code == nrcSAlreadyHaveIt ) ;

				pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

				m_artrefCheck[iMatch].m_articleId = INVALID_ARTICLEID ;
				m_artrefCheck[iMatch].m_groupId = INVALID_GROUPID ;

			}
		
			//
			//	Here we are - did we ever send something to the remote side !
			//
			_ASSERT( m_iCurrentSend == 0 ) ;
		
			
			//
			//	We arrive here iff the remote server rejected an article we had offered through
			//	a check command !
			//


			if( m_fDoingChecks ) {
				//
				//	FALL Through into error handling which terminates session !
				//	
				return	pReturn ;

			}	else	{

				//
				//	State should have benn reset already !
				//
				_ASSERT( m_cChecks == 0 ) ;
				_ASSERT( m_iCurrentCheck == 0 ) ;

				//
				//	Do we continue in this state or can we go directly into
				//	a takethis only state !?
				//	
				if( m_cSends != 16 ) {

					if( m_cSends == 0 ) {
						m_fDoingChecks = TRUE ;
					}

					//
					//	Remain in this state - Note that there are responses
					//	to m_cSends 'takethis' commands that need to be collected !
					//

					//
					//	Fire off the next bunch of check commands -
					//	then let the write completions queue the
					//	necessary reads to collect all the takethis responses !
					//

					CIOWrite*	pWrite = InternalStart(	pSocket, pdriver ) ;

					//
					//	We should transmit a file if we have one lined up !
					//
					if( pWrite ) {

						//
						//	Verify our state !
						//
						_ASSERT( m_cChecks != 0 ) ;
						_ASSERT( m_iCurrentCheck == 0 ) ;
						//_ASSERT( !m_fDoingChecks ) ;
	
						if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
							return	0 ;
						}	else	{
							CIO::Destroy( pWrite, *pdriver ) ;
						}
					}	else	{


						//
						//	If we are doing checks then not having a Write Command
						//	should fall through into our error termination
						//

						if( !m_fDoingChecks ) {
							return	pReadLine ;
						}	else	{

							//
							//	No Data left to send - send a quit command !
							//
							pWrite = BuildQuit( pdriver ) ;
							if( pWrite ) {
								if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
									return	0 ;
								}	else	{
									CIO::Destroy( pWrite, *pdriver ) ;
								}
							}
							cause = CAUSE_NODATA ;
						}
					}
				}	else	{


					//
					//	We should initialize a 'takethis' only state now
					//	with the understanding that there are 16 takethis responses
					//	that need to be collected !!
					//
					CIOWrite*	pWrite = 0 ;
					CIORead*	pRead = 0 ;
					if( NextState(	pSocket,
									pdriver,
									pRead,
									pWrite	) )	{

						if( pWrite != 0 ) {
							if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
								return	pRead ;
							}	else	{
								if( pRead != 0 )
									CIO::Destroy( pRead, *pdriver ) ;
								CIO::Destroy( pWrite, *pdriver ) ;
							}
						}	else	{
							return	pRead;
						}
					}
				}
			}
		}
	}	else	{

		OutboundLogAll(	pSocket,
				fCode,
				code,
				cArgs,
				pszArgs,
				"takethis"
				) ;



		//
		//	Do we have a legal NNTP return code ??
		//
		if( fCode ) {

			//
			// increment the appropriate counter
			//
			pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

			//
			//	Do we need to resubmit the article for any reason !
			//
			if( code == nrcSTryAgainLater ||
				(code != nrcSTransferredOK && code != nrcSArticleRejected) ) {

				ReSend(	pSocket->m_context.m_pOutFeed,
						m_artrefSend[m_iCurrentSend].m_groupId,
						m_artrefSend[m_iCurrentSend].m_articleId
						) ;

			} else {
			    // We have successfully transmitted the article.  If this
			    // came from _slavegroup, then we can delete the article.
			    CNewsTreeCore* pTree = ((pSocket->m_context).m_pInstance)->GetTree();
			    if (m_artrefSend[m_iCurrentSend].m_groupId == pTree->GetSlaveGroupid()) {
			        DeleteArticleById(pTree, 
			            m_artrefSend[m_iCurrentSend].m_groupId,
			            m_artrefSend[m_iCurrentSend].m_articleId);
			    }

			}

			//
			//	NIL this out so that Shutdown() does not unnecessarily requeue articles !
			//
			m_artrefSend[m_iCurrentSend].m_groupId = INVALID_GROUPID ;
			m_artrefSend[m_iCurrentSend].m_articleId = INVALID_ARTICLEID ;

			//
			//	Whats the next Send we're waiting for ??
			//
			m_iCurrentSend ++ ;

			if( m_iCurrentSend == m_cSends ) {

				m_iCurrentSend = 0 ;
				m_cSends = 0 ;
				m_fDoingChecks = TRUE ;

				if( m_cChecks == 0 ) {

					//
					//	No Data left to send - send a quit command !
					//
					CIOWrite*	pWrite = BuildQuit( pdriver ) ;
					if( pWrite ) {
						if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) )	{
							CIO::Destroy( pWrite, *pdriver ) ;
							pdriver->UnsafeClose( pSocket, CAUSE_NODATA, 0 ) ;
							return	0 ;
						}	else	{
							return	0 ;
						}
					}
				}
			}	

			return	pReadLine ;
		}	
		//
		//	else Case falls through and terminates session !
		//
	}
	pdriver->UnsafeClose( pSocket, cause, 0	) ;
	return	0 ;
}

CIO*
CCheckArticles::Complete(	CIOMLWrite*	pWrite,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver
							) {

	_ASSERT( m_cChecks != 0 ) ;
	_ASSERT( m_iCurrentCheck == 0 ) ;
	
	CIOReadLine*	pReadLine = new( *pdriver ) 	CIOReadLine( this ) ;

	if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
		return	0 ;
	}	else	{
		CIO::Destroy( pReadLine, *pdriver ) ;
	}
		
	//
	//	Fall through to fatal error handling code - drop the session !
	//
	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
	return	0 ;		
}

CIO*
CCheckArticles::Complete(	CIOTransmit*	pTransmit,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							TRANSMIT_FILE_BUFFERS*,
							unsigned
							) {

	_ASSERT( m_pArticle != 0 ) ;
	_ASSERT( m_cSends != 0 ) ;

	m_pArticle = 0 ;

	if( m_fDoingChecks ) {
		//
		//	FALL Through into error handling which terminates session !
		//	
		CIOReadLine*	pReadLine = new( *pdriver ) 	CIOReadLine( this ) ;
		if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
			return	0 ;
		}	else	{
			CIO::Destroy( pReadLine, *pdriver ) ;
		}

	}	else	{

		//
		//	State should have benn reset already !
		//
		_ASSERT( m_cChecks == 0 ) ;
		_ASSERT( m_iCurrentCheck == 0 ) ;

		//
		//	Do we continue in this state or can we go directly into
		//	a takethis only state !?
		//	
		if( m_cSends != 16 ) {
			//
			//	Remain in this state - Note that there are responses
			//	to m_cSends 'takethis' commands that need to be collected !
			//

			//
			//	Fire off the next bunch of check commands -
			//	then let the write completions queue the
			//	necessary reads to collect all the takethis responses !
			//

			CIOWrite*	pWrite = InternalStart(	pSocket, pdriver ) ;

			//
			//	We should transmit a file if we have one lined up !
			//
			if( pWrite ) {

				//
				//	Verify our state !
				//
				_ASSERT( m_cChecks != 0 ) ;
				_ASSERT( m_iCurrentCheck == 0 ) ;
				_ASSERT( !m_fDoingChecks ) ;
				return	pWrite ;

			}	else	{
				CIOReadLine*	pReadLine = new( *pdriver ) 	CIOReadLine( this ) ;
				if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
					return	0 ;
				}	else	{
					CIO::Destroy( pReadLine, *pdriver ) ;
				}
			}

		}	else	{


			CIOWrite*	pWrite = 0 ;
			CIORead*	pRead = 0 ;
			if( NextState(	pSocket,
							pdriver,
							pRead,
							pWrite	) )	{

				if( pRead != 0 ) {
					if( pdriver->SendReadIO( pSocket, *pRead, TRUE ) )	{
						return	pWrite ;
					}	else	{
						CIO::Destroy( pRead, *pdriver ) ;
						if( pWrite )
							CIO::Destroy( pWrite, *pdriver ) ;
					}
				}	else	{
					return	pWrite ;
				}
			}
		}
	}

		
	//
	//	Fall through to fatal error handling code - drop the session !
	//
	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
	return	0 ;		
}

void
CCheckArticles::Shutdown(	CIODriver&	driver,
							CSessionSocket*	pSocket,
							SHUTDOWN_CAUSE	cause,
							DWORD	dw )	{


	for( int i=0; i<16; i++ ) {
	
		if( m_artrefCheck[i].m_groupId != INVALID_GROUPID &&
			m_artrefCheck[i].m_articleId != INVALID_ARTICLEID ) {

			ReSend(	pSocket->m_context.m_pOutFeed,
					m_artrefCheck[i].m_groupId,
					m_artrefCheck[i].m_articleId
					) ;
		}

		if(	m_artrefSend[i].m_groupId != INVALID_GROUPID &&
			m_artrefSend[i].m_articleId != INVALID_ARTICLEID )	{

			ReSend(	pSocket->m_context.m_pOutFeed,
					m_artrefSend[i].m_groupId,
					m_artrefSend[i].m_articleId
					) ;

		}
	}
}

BOOL
CCheckArticles::NextState(	CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							CIORead*&		pRead,
							CIOWrite*&		pWrite
							)	{


	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pdriver != 0 ) ;
	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 ) ;
	_ASSERT( m_cSends != 0 ) ;
	_ASSERT( m_artrefSend[0].m_groupId != INVALID_GROUPID ) ;
	_ASSERT( m_artrefSend[0].m_articleId != INVALID_ARTICLEID ) ;

	CSTATEPTR	pState =	new	CStreamArticles(
									m_artrefSend,
									m_cSends
									) ;

	if( pState ) {

		if( pState->Start(	pSocket,
							pdriver,
							pRead,
							pWrite
							)	)	{
			return	TRUE ;

		}
	}
	return	FALSE ;
}


CStreamArticles::CStreamArticles(	CArticleRef*	pSent,
									DWORD			cSent ) :

	m_cSends( cSent ),
	m_cFailedTransfers( 0 ),
	m_cConsecutiveFails( 0 ),
	m_TotalSends( 0 )	{

	
	for( int i=0; i<16; i++ ) {

		m_artrefSend[i].m_groupId = INVALID_GROUPID ;
		m_artrefSend[i].m_articleId = INVALID_ARTICLEID ;

	}

	_ASSERT( cSent == 16 ) ;

	CopyMemory( &m_artrefSend, pSent, sizeof( CArticleRef ) * min( cSent, 16 ) ) ;
}

CIOTransmit*
CStreamArticles::Next(	CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver
						) {

	COutFeed*	pOutFeed = pSocket->m_context.m_pOutFeed ;
	CIOTransmit*	pTransmit = 0 ;

	_ASSERT( m_cSends < 16 ) ;

	do	{

		CNewsTree* pTree = ((pSocket->m_context).m_pInstance)->GetTree() ;

		BOOL	fRemove = Remove(
							pTree,
							pOutFeed,
							m_artrefSend[m_cSends].m_groupId,
							m_artrefSend[m_cSends].m_articleId
							) ;

		if( !fRemove ||
			m_artrefSend[m_cSends].m_groupId == INVALID_GROUPID ||
			m_artrefSend[m_cSends].m_articleId == INVALID_ARTICLEID )	{
			break ;
		}

		pTransmit = NextTransmit(	m_artrefSend[m_cSends].m_groupId,
									m_artrefSend[m_cSends].m_articleId,
									pSocket,
									pdriver
									) ;

	}	while( pTransmit == 0 ) ;


	//
	//	NextTransmit will requeue the article if appropriate -
	//	no need for us to do so !
	//

	if( pTransmit != 0 ) {

		m_cSends ++ ;

	}
	return	pTransmit ;
}

CIOTransmit*
CStreamArticles::NextTransmit(	GROUPID			GroupId,
								ARTICLEID		ArticleId,
								CSessionSocket*	pSocket,
								CDRIVERPTR&		pdriver
								)	{
				

	CIOTransmit*	pTransmit =		new( *pdriver )	CIOTransmit( this ) ;
	CBUFPTR	pbuffer = pdriver->AllocateBuffer( cbMediumBufferSize ) ;
	if( pTransmit == 0 || pbuffer == 0 ) {

		if( pTransmit != 0 )
			CIO::Destroy(	pTransmit, *pdriver ) ;

		return	0 ;
	}


	DWORD	ibStart = 0 ;
	DWORD	cbLength = 0 ;
	//LPTS_OPEN_FILE_INFO		pOpenFile ;


	DWORD	cbOut =
		pSocket->m_context.m_pOutFeed->FormatTakethisCommand(
										(BYTE*)&pbuffer->m_rgBuff[0],
										pbuffer->m_cbTotal,
										GroupId,
										ArticleId,
										m_pArticle
										) ;

	if( cbOut != 0 ) {

		_ASSERT( m_pArticle != 0 ) ;
		FIO_CONTEXT*	pFIOContext = 0 ;

		if( (pFIOContext = m_pArticle->fWholeArticle( ibStart, cbLength )) != 0  ) {

			if( pTransmit->Init(	pdriver,
								pFIOContext,
								ibStart,
								cbLength,
								pbuffer,
								0,
								cbOut ) )	{
				return	pTransmit ;
			}
		}
	}	

	//
	//	If for some reason we have not
	//	built a pTransmit Object to send then we need
	//	to requeue the article !
	//

	if( cbOut != 0 ||
		GetLastError() != ERROR_FILE_NOT_FOUND ) {

		ReSend(	pSocket->m_context.m_pOutFeed,
				GroupId,
				ArticleId
				) ;

	}

	if( pTransmit )
		CIO::Destroy( pTransmit, *pdriver ) ;
	
	return	0 ;
}


BOOL
CStreamArticles::Start(	CSessionSocket*	pSocket,
						CDRIVERPTR&		pdriver,
						CIORead*&		pRead,
						CIOWrite*&		pWrite )	{

	_ASSERT( pRead == 0 ) ;
	_ASSERT( pWrite == 0 ) ;

	pRead = 0 ;
	pWrite = 0 ;

	if( m_cSends < 16 ) {

		pWrite = Next( pSocket, pdriver ) ;	
	
		return	pWrite != 0 ;

	}	else	{

		pRead = new( *pdriver )	 CIOReadLine( this ) ;
		return	pRead != 0 ;

	}
}


CIO*
CStreamArticles::Complete(	CIOWriteLine*	pWriteLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver
							)	{

	//
	//	All done - drop session !
	//

	OutboundLogAll(	pSocket,
			FALSE,
			NRC(0),
			0,
			0,
			"quit"
			) ;

	pdriver->UnsafeClose( pSocket, CAUSE_NODATA, 0	) ;
	return	0 ;
}


CIO*
CStreamArticles::Complete(	CIOReadLine*	pReadLine,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							int				cArgs,
							char**			pszArgs,
							char*			pchBegin
							)	{


	NRC	code ;
	BOOL	fCode = ResultCode( pszArgs[0], code ) ;
	SHUTDOWN_CAUSE	cause = CAUSE_UNKNOWN ;

	CIO*		pReturn = pReadLine ;
	CIOTransmit*	pTransmit = 0 ;

	OutboundLogAll(	pSocket,
		fCode,
		code,
		cArgs,
		pszArgs,
		"takethis"
		) ;

	//
	//	Do we have a legal NNTP return code ??
	//
	if( fCode ) {

		//
		//
		//
		_ASSERT(	m_artrefSend[0].m_groupId != INVALID_GROUPID &&
					m_artrefSend[0].m_articleId != INVALID_ARTICLEID ) ;		


		m_TotalSends ++ ;

		//
		// increment the appropriate feed counter
		//
		pSocket->m_context.m_pOutFeed->IncrementFeedCounter(code);

		//
		//	Do we need to resubmit the article for any reason !
		//
		if( code == nrcSTryAgainLater ||
			(code != nrcSTransferredOK && code != nrcSArticleRejected) ) {

			m_cFailedTransfers ++ ;
			m_cConsecutiveFails ++ ;

			ReSend(	pSocket->m_context.m_pOutFeed,
					m_artrefSend[0].m_groupId,
					m_artrefSend[0].m_articleId
					) ;

		}	else	if( code == nrcSTransferredOK ) {

			CNewsTreeCore* pTree = ((pSocket->m_context).m_pInstance)->GetTree();
			if (m_artrefSend[0].m_groupId == pTree->GetSlaveGroupid()) {
			    DeleteArticleById(pTree, 
			        m_artrefSend[0].m_groupId,
			        m_artrefSend[0].m_articleId);
			}

			m_cConsecutiveFails = 0 ;

		}	else	{

			m_cFailedTransfers ++ ;
			m_cConsecutiveFails ++ ;

		}
			

		MoveMemory( &m_artrefSend[0], &m_artrefSend[1], sizeof( m_artrefSend[0] ) * 15 ) ;
		m_artrefSend[15].m_groupId = INVALID_GROUPID ;
		m_artrefSend[15].m_articleId = INVALID_ARTICLEID ;
		
		m_cSends -- ;

		if( m_cConsecutiveFails == 3 ||
			(((m_cFailedTransfers * 10) > m_TotalSends) && m_TotalSends > 20))	{

			//	
			//	Switch to the other state !
			//
			CSTATEPTR	pState =	new	CCheckArticles(
												m_artrefSend,
												m_cSends
												) ;

			if( pState ) {

				CIOWrite*	pWrite = 0 ;
				CIORead*	pRead = 0 ;
				if( pState->Start(	pSocket,
									pdriver,
									pRead,
									pWrite ) )	{

					if( pWrite != 0 ) {
						if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
							return	pRead ;
						}	else	{
							CIO::Destroy( pWrite, *pdriver ) ;
							if( pRead != 0 )
								CIO::Destroy( pRead, *pdriver ) ;
						}
					}	else	{
						return	pRead ;
					}
				}

			}	else	{

				if( m_cSends != 0 )	{
					return	pReadLine ;
				}
			}

		}	else	{

			pTransmit = Next(	pSocket, pdriver ) ;

			if( pTransmit ) {
				if( pdriver->SendWriteIO( pSocket, *pTransmit, TRUE ) ) {
					return	 0 ;
				}	else	{
					CIO::Destroy( pTransmit, *pdriver ) ;
				}
			}	else	{

				if( m_cSends != 0 ) {
					return	pReadLine ;
				}	else	{

					//
					//	No more data to send or receive - send quit command and
					//	drop session !
					//
					CIOWrite*	pWrite = BuildQuit( pdriver ) ;
					if( pWrite ) {
						if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
							return 0 ;
						}	else	{
							CIO::Destroy( pWrite, *pdriver ) ;
						}
					}
				}
			}
		}
	}	
	//
	//	else Case falls through and terminates session !
	//
	pdriver->UnsafeClose( pSocket, cause, 0	) ;
	return	0 ;
}

CIO*
CStreamArticles::Complete(	CIOTransmit*	pTransmit,
							CSessionSocket*	pSocket,
							CDRIVERPTR&		pdriver,
							TRANSMIT_FILE_BUFFERS*,
							unsigned
							) {

	_ASSERT( m_pArticle != 0 ) ;
	_ASSERT( m_cSends != 0 ) ;

	m_pArticle = 0 ;

	CIOReadLine*	pReadLine = new( *pdriver ) 	CIOReadLine( this ) ;
	if( pdriver->SendReadIO( pSocket, *pReadLine, TRUE ) ) {
		return	0 ;
	}	else	{
		CIO::Destroy( pReadLine, *pdriver ) ;
	}
		
	//
	//	Fall through to fatal error handling code - drop the session !
	//
	pdriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
	return	0 ;		
}


void
CStreamArticles::Shutdown(	CIODriver&	driver,
							CSessionSocket*	pSocket,
							SHUTDOWN_CAUSE	cause,
							DWORD	dw
							)	{


	for( int i=0; i<16; i++ ) {
	
		if(	m_artrefSend[i].m_groupId != INVALID_GROUPID &&
			m_artrefSend[i].m_articleId != INVALID_ARTICLEID )	{

			ReSend(	pSocket->m_context.m_pOutFeed,
					m_artrefSend[i].m_groupId,
					m_artrefSend[i].m_articleId
					) ;

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\svcsupp.cpp ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    svcsupp.cpp

Abstract:

    This module contains support routines for rpc calls

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

--*/

//#ifdef	UNIT_TEST
//#include	<windows.h>
//#include	<dbgtrace.h>
//#include	<stdio.h>
//#include	"nntpmacr.h"
//#else
#include	<buffer.hxx>
#include "tigris.hxx"
#include "nntpsvc.h"
#include <time.h>
//#endif


VOID
CopyUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPWSTR UnicodeString
        )
{

    DWORD cbW = (wcslen( UnicodeString )+1) * sizeof(WCHAR);
    DWORD cbSize = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        (LPCWSTR)UnicodeString,
                        -1,
                        AsciiString,
                        cbW,
                        NULL,
                        NULL
                    );

    if( (int)cbSize >= 0 ) {
        AsciiString[cbSize] = '\0';
    }

    _ASSERT( cbW != 0 );

} // CopyUnicodeStringIntoAscii

VOID
CopyNUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPWSTR UnicodeString,
		IN DWORD cbUnicodeLen,
		IN DWORD cbAsciiLen
        )
{
	_ASSERT(cbUnicodeLen != 0);

    DWORD cbSize = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        (LPCWSTR)UnicodeString,
                        cbUnicodeLen,
                        AsciiString,
                        cbAsciiLen,
                        NULL,
                        NULL
                    );

    _ASSERT (cbSize > 0);

    if( (int)cbSize >= 0 ) {
        AsciiString[ min(cbSize, cbAsciiLen-1)] = '\0';
    }

} // CopyNUnicodeStringIntoAscii

LPWSTR
CopyAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR AsciiString
        )
{
    DWORD cbA = strlen( AsciiString )+1;

    DWORD cbSize = MultiByteToWideChar(
        CP_ACP,         // code page
        0,              // character-type options
        AsciiString,    // address of string to map
        -1,             // number of bytes in string
        UnicodeString,  // address of wide-character buffer
        cbA        // size of buffer
        );

    if ((int)cbSize >= 0) {
        UnicodeString[cbSize] = L'\0';
    }

    return UnicodeString + wcslen(UnicodeString) + 1;

} // CopyAsciiStringIntoUnicode

VOID
CopyNAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR  AsciiString,
        IN DWORD  dwAsciiLen,
        IN DWORD  dwUnicodeLen)
{

    DWORD cbSize = MultiByteToWideChar(
        CP_ACP,         // code page
        0,              // character-type options
        AsciiString,    // address of string to map
        dwAsciiLen,     // number of bytes in string
        UnicodeString,  // address of wide-character buffer
        dwUnicodeLen    // size of buffer
        );

    _ASSERT(cbSize > 0);

    if ((int)cbSize >= 0) {
        UnicodeString[cbSize] = L'\0';
    }
}

DWORD
MultiListSize(
    LPSTR *List
    )
/*++

Routine Description:

    This routine computes the size of the multisz structure needed
    to accomodate a list.

Arguments:

    List - the list whose string lengths are to be computed

Return Value:

    Size of buffer needed to accomodate list.

--*/
{
    DWORD nBytes = 1;
    DWORD i = 0;

    if ( List != NULL ) {
        while ( List[i] != NULL ) {
            nBytes += lstrlen(List[i]) + 1;
            i++;
        }
    }
    return(nBytes);
} // MultiListSize

BOOL
VerifyMultiSzListW(
    LPBYTE List,
    DWORD cbList
    )
/*++

Routine Description:

    This routine verifies that the list is indeed a multisz

Arguments:

    List - the list to be verified
    cbList - size of the list

Return Value:

    TRUE, list is a multisz
    FALSE, otherwise

--*/
{
    PWCHAR wList = (PWCHAR)List;
    DWORD len;

    START_TRY

    //
    // null are considered no hits
    //

    if ( (List == NULL) || (*List == L'\0') ) {
        return(FALSE);
    }

    //
    // see if they are ok
    //

    for ( DWORD j = 0; j < cbList; ) {

        len = wcslen((LPWSTR)&List[j]);

        if ( len > 0 ) {

            j += ((len + 1) * sizeof(WCHAR));
        } else {

            //
            // all done
            //

            return(TRUE);
        }
    }

    TRY_EXCEPT
#ifndef	UNIT_TEST
        ErrorTraceX(0,"VerifyMultiSzListW: exception handled\n");
#endif
    END_TRY
    return(FALSE);

} // VerifyMultiSzList

VOID
CopyStringToBuffer (
    IN PCHAR String,
    IN PCHAR FixedStructure,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single  string into a
    buffer.  The string data is converted to UNICODE as it is copied.  The
    string is not written if it would overwrite the last fixed structure
    in the buffer.

Arguments:

    String - a pointer to the string to copy into the buffer.  If String
        is null (Length == 0 || Buffer == NULL) then a pointer to a
        zero terminator is inserted.

    FixedStructure - a pointer to the end of the last fixed
        structure in the buffer.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.

    VariableDataPointer - a pointer to the place in the buffer where
        a pointer to the variable data should be written.

Return Value:

    None.

--*/

{
    ULONG length;

    //
    // Determine where in the buffer the string will go, allowing for a
    // zero-terminator.  (MB2WC returns length including null)
    //

    length = MultiByteToWideChar(CP_ACP, 0, String, -1, NULL, 0);
    *EndOfVariableData -= length;

    //
    // Will the string fit?  If no, just set the pointer to NULL.
    //

    if ( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)FixedStructure && length != 0) {

        //
        // It fits.  Set up the pointer to the place in the buffer where
        // the string will go.
        //

        *VariableDataPointer = *EndOfVariableData;

        //
        // Copy the string to the buffer if it is not null.
        //

		if (MultiByteToWideChar(CP_ACP, 0, String, -1, *EndOfVariableData, length) == 0) {
			_ASSERT(!"Not enough room for string");
			*VariableDataPointer = NULL;
		}

    } else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;
        _ASSERT(FALSE);
    }

    return;

} // CopyStringToBuffer


DWORD
GetNumStringsInMultiSz(
    PCHAR Blob,
    DWORD BlobSize
    )
/*++

Routine Description:

    This routine returns the number of strings in the multisz

Arguments:

    Blob - the list to be verified
    BlobSize - size of the list

Return Value:

    number of entries in the multisz structure.

--*/
{
    DWORD entries = 0;
    DWORD len;
    DWORD j;

    for ( j = 0; j < BlobSize; ) {
        len = lstrlen(&Blob[j]);
        if ( len > 0 ) {
            entries++;
        }
        j += (len + 1);
        if( len == 0 ) {
            break;
        }
    }

    _ASSERT( j == BlobSize );
    return(entries);

} // GetNumStringsInMultiSz

LPSTR *
AllocateMultiSzTable(
            IN PCHAR List,
            IN DWORD cbList,
            IN BOOL IsUnicode
            )
{
    DWORD len;
    PCHAR buffer = NULL;
    DWORD entries = 0;
    LPSTR* table = NULL;
    PCHAR nextVar;
    PCHAR tempBuff=NULL;
    DWORD numItems;
    DWORD j = 0;

    //
    // if this is in unicode, convert to ascii
    //

    if ( IsUnicode ) {

        cbList /= sizeof(WCHAR);

        // Raid 190991 - Allocate this space. We can have data
        // bigger than 4906
        tempBuff = (PCHAR) ALLOCATE_HEAP( cbList + 1 ) ;
        if ( tempBuff == NULL ) {
        	goto fail_exit;
        }

        CopyNUnicodeStringIntoAscii(tempBuff, (PWCHAR)List,
            cbList, cbList);

        List = tempBuff;
    }

    numItems = GetNumStringsInMultiSz( List, cbList );
    if ( numItems == 0 ) {
        goto fail_exit;
    }

    buffer = (PCHAR)ALLOCATE_HEAP((numItems + 1) * sizeof(LPSTR) + cbList);
    if ( buffer == NULL ) {
        goto fail_exit;
    }

    table = (LPSTR *)buffer;
    nextVar = buffer + (numItems + 1)*sizeof(LPSTR);

    for ( j = 0; j < cbList; ) {

        len = lstrlen(&List[j]);
        if ( len > 0 ) {
            table[entries] = (LPSTR)nextVar;
            CopyMemory(nextVar,&List[j],len+1);
            (VOID)_strlwr(table[entries]);
            entries++;
            nextVar += (len+1);
        }
        j += (len + 1);
    }

    *nextVar = '\0';
    table[numItems] = NULL;

cleanup:

    if (tempBuff)
        FREE_HEAP(tempBuff);
    
    return(table);

fail_exit:

    // Raid 190991
    if (buffer)
        FREE_HEAP(buffer);

    table = NULL;

    goto cleanup;
} // AllocateMultiSzTable

LPSTR*
CopyMultiList(
			LPSTR*	List
			) {

	LPSTR*	pListOut = 0 ;

	pListOut = AllocateMultiSzTable( *List, MultiListSize( List ), FALSE ) ;

	return	pListOut ;
}


LPSTR*
MultiSzTableFromStrA(
	LPCSTR	lpstr
	)	{

	_ASSERT( lpstr != 0 ) ;

	int	cb = lstrlen( lpstr ) ;

	int	cbRequired = 0 ;
	int	cPointerRequired = 0 ;

	for( int i=0; i < cb; i++ ) {

		for( int j=i; j<cb; j++ ) {
			if( !isspace( (UCHAR)lpstr[j] ) ) break ;
		}

		if( j!=cb ) {
			cPointerRequired ++ ;
		}

		for( ; j<cb; j++ ) {
			cbRequired ++ ;
			if( isspace( (UCHAR)lpstr[j] ) ) 	break ;
		}
		i=j ;
	}

	if( cPointerRequired == 0 ) {

		_ASSERT( cbRequired == 0 ) ;

		LPSTR	buffer = (PCHAR)ALLOCATE_HEAP(2*sizeof(LPSTR) + 2);
		if ( buffer == NULL ) {
			return(NULL);
		}
		ZeroMemory( buffer, 2*sizeof( LPSTR ) + 2 ) ;
		LPSTR*	table = (LPSTR*)buffer ;
		table[0] = &buffer[sizeof(table)*2] ;
		return	table ;
	}

    LPSTR	buffer = (PCHAR)ALLOCATE_HEAP((cPointerRequired + 1) * sizeof(LPSTR) + (cbRequired+2) * sizeof( char ) );
    if ( buffer == NULL ) {
        return(NULL);
    }

    LPSTR*	table = (LPSTR *)buffer;
    LPSTR	nextVar = buffer + (cPointerRequired + 1)*sizeof(LPSTR);

	int	k=0 ;

    for ( i = 0; i < cb; i++ ) {

		for( int j=i; j<cb; j++ ) {
			if( !isspace( (UCHAR)lpstr[j] ) ) break ;
		}

		if( j!=cb ) {
			table[k++] = nextVar ;

			for( ; j<cb; j++ ) {
				if( isspace( (UCHAR)lpstr[j] )	) break ;
				*nextVar++ = lpstr[j] ;
			}
			*nextVar++ = '\0' ;
		}
		i=j ;
	}

	*nextVar++ = '\0' ;

	_ASSERT( k==cPointerRequired ) ;

    table[k] = NULL;
    return(table);
}


LPSTR*
MultiSzTableFromStrW(
	LPWSTR	lpwstr
	)	{

	char	szTemp[4096] ;

	DWORD	cb = wcslen( lpwstr )+1 ;
	if( cb > sizeof( szTemp ) ) {
		return	0 ;
	}
    CopyUnicodeStringIntoAscii(szTemp, lpwstr);

	return	MultiSzTableFromStrA( szTemp ) ;
}


LPSTR
LpstrFromMultiSzTableA(
	LPSTR*	plpstr
	)	{

	DWORD	cb = MultiListSize( plpstr ) ;

    LPSTR	buffer = (PCHAR)ALLOCATE_HEAP(cb * sizeof( char ) );
    if ( buffer == NULL ) {
        return(NULL);
    }
	buffer[0] = '\0' ;

	LPSTR	lpstr = *plpstr++ ;
	while( lpstr != 0 ) {
		lstrcat( buffer, lpstr ) ;
		lpstr = *plpstr++ ;
		if( lpstr != 0 )
			lstrcat( buffer, " " ) ;
	}

	return	buffer ;
}

LPWSTR
LpwstrFromMultiSzTableA(
	LPSTR*	plpstr
	)	{

	LPSTR	lpstr = LpstrFromMultiSzTableA( plpstr ) ;
	LPWSTR	buffer = 0 ;
	if( lpstr != 0 ) {
		DWORD	cb = lstrlen( lpstr ) + 1 ;

		buffer = (LPWSTR)ALLOCATE_HEAP( cb * sizeof( WCHAR ) ) ;

		if( buffer != 0 ) {
			CopyAsciiStringIntoUnicode( buffer, lpstr ) ;
		}
		FREE_HEAP( lpstr ) ;
	}
	return	buffer ;
}

void
FillLpwstrFromMultiSzTable(
	LPSTR*	plpstr,
	LPWSTR	lpwstr
	)	{

	LPSTR	lpstr = *plpstr++ ;
	while( lpstr != 0 ) {

		lpwstr = CopyAsciiStringIntoUnicode( lpwstr, lpstr ) ;
		lpstr = *plpstr++ ;
		if( lpstr != 0 )
			lpwstr[-1] = L' ' ;
	}
}

void
FillLpstrFromMultiSzTable(
	LPSTR*	plpstr,
	LPSTR	lpstrFill
	)	{

	lpstrFill[0] = '\0' ;
	LPSTR	lpstr = *plpstr++ ;
	while( lpstr != 0 ) {

		lstrcat( lpstrFill, lpstr ) ;
		lpstr = *plpstr++ ;
		if( lpstr != 0 )
			lstrcat( lpstrFill, " " ) ;
	}
}


BOOL
MultiSzIntersect(
	LPSTR*	plpstr,
	LPSTR	szmulti
	) {

	if( plpstr == 0 || szmulti == 0 ) {
		return	FALSE ;
	}

	BOOL	fMatch = FALSE ;

	for(	LPSTR	lpstrTest = szmulti;
					*lpstrTest != '\0';
					lpstrTest += lstrlen( lpstrTest ) + 1 ) {

		for( LPSTR*	plpstrCur = plpstr; *plpstrCur != 0; plpstrCur ++ ) {

			if( lstrcmpi( lpstrTest, *plpstrCur ) == 0 ) {
				return	TRUE ;
			}
		}
	}
	return	FALSE ;
}


LPSTR	*
ReverseMultiSzTable(
	IN	LPSTR*	plpstr
	)
{

	DWORD	cbLength = 0 ;
	DWORD	numItems = 0 ;

	while( plpstr[numItems] != 0 )
		cbLength += lstrlen( plpstr[ numItems++ ] ) + 1 ;
	cbLength ++ ;	// for double NULL terminator

	if( numItems == 0 ) {
		return	plpstr ;
	}

	PCHAR	buffer = (PCHAR)ALLOCATE_HEAP((numItems+1)*sizeof(LPSTR) + cbLength ) ;

	if( buffer == NULL ) {
		return	NULL ;
	}

	LPSTR*	table = (LPSTR*)buffer ;
	LPSTR	nextVar = buffer + (numItems+1) * sizeof(LPSTR) ;

	table[numItems] = NULL ;
	for( int i=numItems-1, index=0; i >=0; i--, index++ ) {
		table[index] = nextVar ;
		lstrcpy( table[index], plpstr[i] ) ;
		nextVar += lstrlen( table[index] ) + 1 ;
	}
	*nextVar = '\0' ;
	return	table ;
}

#ifdef	UNIT_TEST

void
main( int	argc, char**	argv ) {


	unsigned	char	szTemp[4096] ;
	WCHAR	szwTemp[4096] ;

	InitAsyncTrace();

	for( int i=0; i<argc; i++ ) {

		printf( "argv - %s\n", argv[i] ) ;

		LPSTR*	table = MultiSzTableFromStrA( argv[i] ) ;

		for( int j=0; table[j] != '\0'; j++ ) {

			printf( "%d %s\n", j, table[j] ) ;

		}

		LPSTR	szSpace = LpstrFromMultiSzTableA( table ) ;
		printf( "szSpace = =%s=\n", szSpace ) ;

		FillMemory( szTemp, sizeof( szTemp ), 0xcc ) ;
		FillLpstrFromMultiSzTable( table, (char*)szTemp ) ;
		printf( "FillLpstrFromMultiSzTable =%s=\n", szTemp ) ;
		_ASSERT( szTemp[ MultiListSize( table ) ] == 0xCC ) ;

		FillMemory( szwTemp, sizeof( szwTemp ), 0xcc ) ;
		FillLpwstrFromMultiSzTable( table, szwTemp ) ;
		printf( "FillLpstrFromMultiSzTable =%ws=\n", szwTemp ) ;
		_ASSERT( szwTemp[ MultiListSize( table ) ] == 0xCCCC ) ;

	}

	LPSTR*	table = MultiSzTableFromStrA( "  \t\n\r  " ) ;

	_ASSERT( table != 0 ) ;
	_ASSERT( table[0][0] == '\0' ) ;

	LPSTR	szSpace = LpstrFromMultiSzTableA( table ) ;
	printf( "szSpace = =%s=\n", szSpace ) ;

	FillMemory( szTemp, sizeof( szTemp ), 0xcc ) ;
	FillLpstrFromMultiSzTable( table, (char*)szTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%s=\n", szTemp ) ;
	_ASSERT( szTemp[ MultiListSize( table ) ] == 0xCC ) ;

	FillMemory( szwTemp, sizeof( szwTemp ), 0xcc ) ;
	FillLpwstrFromMultiSzTable( table, szwTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%ws=\n", szwTemp ) ;
	_ASSERT( szwTemp[ MultiListSize( table ) ] == 0xCCCC ) ;

	table = MultiSzTableFromStrA( "" ) ;

	_ASSERT( table != 0 ) ;
	_ASSERT( table[0][0] == '\0' ) ;

	szSpace = LpstrFromMultiSzTableA( table ) ;
	printf( "szSpace = =%s=\n", szSpace ) ;

	FillMemory( szTemp, sizeof( szTemp ), 0xcc ) ;
	FillLpstrFromMultiSzTable( table, (char*)szTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%s=\n", szTemp ) ;
	_ASSERT( szTemp[ MultiListSize( table ) ] == 0xCC ) ;

	FillMemory( szwTemp, sizeof( szwTemp ), 0xcc ) ;
	FillLpwstrFromMultiSzTable( table, szwTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%ws=\n", szwTemp ) ;
	_ASSERT( szwTemp[ MultiListSize( table ) ] == 0xCCCC ) ;

	table = MultiSzTableFromStrA( 0 ) ;

	_ASSERT( table != 0 ) ;
	_ASSERT( table[0][0] == '\0' ) ;

	szSpace = LpstrFromMultiSzTableA( table ) ;
	printf( "szSpace = =%s=\n", szSpace ) ;

	FillMemory( szTemp, sizeof( szTemp ), 0xcc ) ;
	FillLpstrFromMultiSzTable( table, (char*)szTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%s=\n", szTemp ) ;

	FillMemory( szwTemp, sizeof( szwTemp ), 0xcc ) ;
	FillLpwstrFromMultiSzTable( table, szwTemp ) ;
	printf( "FillLpstrFromMultiSzTable =%ws=\n", szwTemp ) ;
	_ASSERT( szwTemp[ MultiListSize( table ) ] == 0xCCCC ) ;


	char	*szTestString[]	= {	"abcd bcde bcdef fjfjj8 fjsdk sdfjks",
								"fjsdklf fjsdkl fdjs432 432j4kl 23k4jklj 23klj4",
								"fhsd f89ds8 fsd890 fmdsb s78df8 fmnsd f9f8s6 fsdh",
								"fsdk",
								"j",
								"abcd",
								"bcde fjdskl",
								"fjsdkfjkldsjf bcddef fjdskl",
								""
								} ;

	int	c = sizeof( szTestString ) / sizeof( szTestString[0] ) ;
	for( i=0; i<c; i++ ) {

		LPSTR*	table = MultiSzTableFromStrA( szTestString[i] ) ;
		for( int j=0; j<c; j++ ) {
			LPSTR*	table2 = MultiSzTableFromStrA( szTestString[j] ) ;

			if( MultiSzIntersect( table, *table2 ) ) {
				_ASSERT( MultiSzIntersect( table2, *table ) ) ;
			}	else	{
				_ASSERT( !MultiSzIntersect( table2, *table ) ) ;
			}
			FREE_HEAP( table2 ) ;
		}
		LPSTR*	copy = CopyMultiList( table ) ;


		FREE_HEAP( copy ) ;
		FREE_HEAP( table ) ;
	}
	_ASSERT( *szSpace == '\0' ) ;

	TermAsyncTrace();
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\svcvroot.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name : 

	svcvroot.cpp

Abstract : 

	This module contains the server side support for vroot rpcs.

Author : 

	Kangrong Yan	

Revision History : 

--*/

#define	INCL_INETSRV_INCS
#include	"tigris.hxx"
#include	"nntpsvc.h"

NET_API_STATUS
NET_API_FUNCTION
NntprGetVRootWin32Error(
                    IN  LPWSTR              wszServerName,
                    IN  DWORD               InstanceId,
                    IN  LPWSTR              wszVRootPath,
                    OUT PDWORD              pdwWin32Error
                        ) 
{
	TraceFunctEnter( "NntprGetVRootWin32Error" ) ;

	APIERR	ss = STATUS_SUCCESS ;

	if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
		return	NERR_ServerNotStarted ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	//
    //  Check for proper access.
    //

    DWORD	err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    ss = pInstance->GetVRootWin32Error( wszVRootPath, pdwWin32Error );

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return ss  ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\wildmat.h ===
//---[ wildmat.h ]-------------------------------------------------------------
//
//  Description:
//      Provides support for the "wildmat" wildcard matching standard. Info
//      on this standard comes from the internet draft:
//
//      draft-barber-nntp-imp-03.txt
//      S. Barber
//      April, 1996
//
//  Copyright (C) Microsoft Corp. 1996.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

#ifndef _WILDMAT_H_
#define _WILDMAT_H_

//---[ Prototypes ]------------------------------------------------------------

HRESULT HrMatchWildmat( const char *pszText, const char *pszPattern );

#endif // _WILDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\svcsess.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcsess.cpp

Abstract:

    This module contains code for doing feed rpcs.

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"


NET_API_STATUS
NET_API_FUNCTION
NntprEnumerateSessions(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    OUT LPNNTP_SESS_ENUM_STRUCT Buffer
    )
{
    APIERR err = NERR_Success;

    ENTER("NntprEnumerateSessions")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
    	pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    //
    // Enumerate
    //

    err = CSessionSocket::EnumerateSessions( pInstance, Buffer );
    if ( err != NO_ERROR ) {
        ErrorTrace(0,"EnumerateSessions failed with %lu\n",err );
    }

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprEnumerateSessions

NET_API_STATUS
NET_API_FUNCTION
NntprTerminateSession(
    IN	NNTP_HANDLE ServerName,
    IN	DWORD		InstanceId,
    IN	LPSTR UserName,
    IN	LPSTR IPAddress
    )
{
    APIERR err = NERR_Success;

    ENTER("NntprTerminateSession")

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
	    pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }

    //
    // Enumerate and find the session that meets description
    //

    err = CSessionSocket::TerminateSession( pInstance, UserName, IPAddress );
    if ( err != NO_ERROR ) {
        ErrorTrace(0,"TerminateSession failed with %lu\n",err );
    }
	else
	{
		PCHAR	args[3] ;
		CHAR    szId[20];
		_itoa( pInstance->QueryInstanceId(), szId, 10 );
		args[0] = szId;
		args[1] = UserName ;
		args[2] = IPAddress ;

		NntpLogEvent(		
				NNTP_EVENT_SESSION_TERMINATED,
				3,
				(const CHAR **)args, 
				0 ) ;
	}

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return(err);

} // NntprTerminateSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\tigris.cpp ===
#include "tigris.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\svcstat.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcstat.cpp

Abstract:

    This module contains code for doing statistics rpcs

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"
#include "nntpsvc.h"
#include <time.h>

BOOL GetStatistics(
    PVOID *pvContext1,
    PVOID *pvContext2,
    IIS_SERVER_INSTANCE *pvInstance);

NET_API_STATUS
NET_API_FUNCTION
NntprQueryStatistics(
    IN NNTP_HANDLE pszServer,
    IN DWORD Level,
    OUT LPNNTP_STATISTICS_BLOCK_ARRAY *pBuffer
    )
{
    APIERR err;
    PLIST_ENTRY pInfoList = NULL;
    LPNNTP_STATISTICS_BLOCK_ARRAY pNntpStatsBlockArray = NULL;
    DWORD dwAlloc = 0;
    DWORD dwInstancesCopied = 0;
    BOOL fRet = FALSE;

    _ASSERT( pBuffer != NULL );
    UNREFERENCED_PARAMETER(pszServer);
    ENTER("NntprQueryStatistics")

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_QUERY_STATISTICS );

    if( err != NO_ERROR ) {
        IF_DEBUG( RPC ) {
            ErrorTrace(0,"Failed access check, error %lu\n",err );
        }
        return (NET_API_STATUS)err;
    }

    if ( Level != 0 ) {
        return (NET_API_STATUS)ERROR_INVALID_LEVEL;
    }

    ACQUIRE_SERVICE_LOCK_SHARED();

    dwAlloc = sizeof(NNTP_STATISTICS_BLOCK_ARRAY) +
        g_pInetSvc->QueryInstanceCount() * sizeof(NNTP_STATISTICS_BLOCK);

    pNntpStatsBlockArray =
        (NNTP_STATISTICS_BLOCK_ARRAY *) MIDL_user_allocate( dwAlloc );

    if( pNntpStatsBlockArray == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    } 


    fRet = g_pInetSvc->EnumServiceInstances(
                (PVOID *)pNntpStatsBlockArray,
                (PVOID *)&dwInstancesCopied,
                (PFN_INSTANCE_ENUM) &GetStatistics);

    if(!fRet) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        MIDL_user_free(pNntpStatsBlockArray);
    } else {
        pNntpStatsBlockArray->cEntries = dwInstancesCopied;
        *pBuffer = pNntpStatsBlockArray;
    }

Exit:

    RELEASE_SERVICE_LOCK_SHARED();

    return (NET_API_STATUS)err;

}   // NntprQueryStatistics

//------------------------------------------------------------------------------
//  Description:
//      Helper function to NntprQueryStatistics. This is called for each NNTP
//      server instance and passed in the buffer to which the statistics data
//      must be copied.
//
//  Arguments:
//      OUT PVOID pvContext1 - pointer to the global statistics buffer. The
//          calling function (NntprQueryStatistics) has already calculated
//          the appropriate buffer size based on the number of NNTP server
//          instance objects.
//
//      IN OUT PVOID pvContext2 - pointer to DWORD that tracks how many
//          instances have already copied the statistics data to the output
//          buffer. This function uses this to determine at what offset in
//          the global statistics buffer it should start copying data. After
//          the data has been copied the DWORD is incremented to reflect the
//          copy.
//
//  Returns:
//      TRUE always.
//
//      If the instance or service is stopped, the data is not copied and
//          pvContext2 is not incremented.
//------------------------------------------------------------------------------
BOOL GetStatistics(
    PVOID *pvContext1,
    PVOID *pvContext2,
    IIS_SERVER_INSTANCE *pvInstance)
{
    NNTP_STATISTICS_BLOCK_ARRAY *pNntpStatsBlockArray = (NNTP_STATISTICS_BLOCK_ARRAY *)pvContext1;
    DWORD *pdwInstancesCopied = (DWORD *) (pvContext2);
    NNTP_SERVER_INSTANCE *pInstance = (NNTP_SERVER_INSTANCE *)pvInstance;
    NNTP_STATISTICS_0 *pstats0 = NULL;

    if((pInstance->QueryServerState() != MD_SERVER_STATE_STARTED) ||
        pInstance->m_BootOptions ||
        (g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING))
    {
        return TRUE;
    }

    pNntpStatsBlockArray->aStatsBlock[*pdwInstancesCopied].dwInstance =
        pInstance->QueryInstanceId();

    pstats0 = &(pNntpStatsBlockArray->aStatsBlock[*pdwInstancesCopied].Stats_0);

    LockStatistics(pInstance);
    CopyMemory(pstats0, &(pInstance->m_NntpStats), sizeof(NNTP_STATISTICS_0));

    //
    // Get hash table counts
    //
    _ASSERT( pInstance->ArticleTable() );
    pstats0->ArticleMapEntries = (pInstance->ArticleTable())->GetEntryCount();
    pstats0->HistoryMapEntries = (pInstance->HistoryTable())->GetEntryCount();
    pstats0->XoverEntries = (pInstance->XoverTable())->GetEntryCount();

    UnlockStatistics(pInstance);

    (*pdwInstancesCopied)++;
    return TRUE;
}


NET_API_STATUS
NET_API_FUNCTION
NntprClearStatistics(
    NNTP_HANDLE pszServer,
	IN DWORD    InstanceId
    )
{
    APIERR err;

    UNREFERENCED_PARAMETER(pszServer);
    ENTER("NntprClearStatistics")

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_CLEAR_STATISTICS );

    if( err != NO_ERROR ) {
        IF_DEBUG( RPC ) {
            ErrorTrace(0,"Failed access check, error %lu\n",err );
        }
        return (NET_API_STATUS)err;
    }

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

    //
    //  Clear the statistics.
    //

    pInstance->ClearStatistics();
	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
    return (NET_API_STATUS)err;

}   // NntprClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\svcxpire.cpp ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name :

	svcxpire.cpp

Abstract :

	This module contains the server side support for expiration rpcs.

Author :

	Neil Kaethler	

Revision History :

--*/

#define	INCL_INETSRV_INCS
#include	"tigris.hxx"
#include	"nntpsvc.h"
#include	<time.h>

NET_API_STATUS
NET_API_FUNCTION
NntprEnumerateExpires(
	IN	NNTP_HANDLE		ServerName,
    IN	DWORD			InstanceId,
	OUT	LPNNTP_EXPIRE_ENUM_STRUCT	Buffer
	)
{
	DWORD	dwError = NERR_Success ;
	DWORD	EntriesRead = 0 ;
	LPI_EXPIRE_INFO	pTemp = 0 ;

	Buffer->EntriesRead = 0 ;
	Buffer->Buffer = NULL ;

	TraceFunctEnter("NntprEnumerateExpires");

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning )	{
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
		return	NERR_ServerNotStarted ;
	}	

    //
    //  Check for proper access.
    //
    dwError = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( dwError != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",dwError );
		pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)dwError;
    }

	EnterCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

	//
	//	Make two passes through the expiration list - one to calculate the size
	//	the second to build the return buffer !
	//

	LPEXPIRE_BLOCK	expire = (pInstance->ExpireObject())->NextExpireBlock( 0 ) ;
	DWORD	cb = 0 ;
	while( expire != 0 ) {
		if( !expire->m_fMarkedForDeletion )
			cb += (pInstance->ExpireObject())->CalculateExpireBlockSize( expire ) ;
		expire = (pInstance->ExpireObject())->NextExpireBlock( expire ) ;
	}

	if( cb != 0 ) {

		PCHAR	bufStart = (PCHAR)MIDL_user_allocate( cb ) ;
		PCHAR    bufAllocated = bufStart;
		pTemp = (LPI_EXPIRE_INFO)bufStart ;

		if( bufStart ) 	{
			PWCHAR	bufEnd = (PWCHAR) (bufStart + cb) ;

			expire = (pInstance->ExpireObject())->NextExpireBlock( 0 ) ;
		
			while( expire != 0 ) {
				if( !expire->m_fMarkedForDeletion ) {
					EntriesRead ++ ;

					if( !FillExpireInfoBuffer(
										pInstance,
										expire,
										&bufStart,
										&bufEnd ) )	{

						MIDL_user_free( bufAllocated ) ;
						bufAllocated = 0;
						bufStart = 0 ;
						dwError = ERROR_NOT_ENOUGH_MEMORY ;
						break ;
					}
				}
				expire = (pInstance->ExpireObject())->NextExpireBlock( expire ) ;
			}
		}

		if( bufStart )	{
			Buffer->EntriesRead = EntriesRead ;
			Buffer->Buffer = pTemp ;
		}

	}

	LeaveCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

	return	dwError ;
}

NET_API_STATUS
NET_API_FUNCTION
NntprAddExpire(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	LPI_EXPIRE_INFO		ExpireInfo,
	OUT	LPDWORD				ParmErr	OPTIONAL,
	OUT LPDWORD				pdwExpireId
	)
{
	DWORD	error = NERR_Success;
	LPEXPIRE_BLOCK	expire = NULL ;
	BOOL fDidAlloc = FALSE;

	*pdwExpireId = 0;

	TraceFunctEnter("NntprAddExpire");

	if( ParmErr == 0 ) {
		ParmErr = &error ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning )	{
		error =	NERR_ServerNotStarted ;
		goto Exit ;
	}	

    //
    //  Check for proper access.
    //
    error = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( error != NO_ERROR ) {
        ErrorTrace(0,"Failed access check error %lu\n",error );
		goto Exit ;
    }

	if( ExpireInfo->Newsgroups == 0 ||
        ExpireInfo->cbNewsgroups == 0 ) {
		*ParmErr = 1 ;
		error = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->ExpireSizeHorizon == 0 ) {
		*ParmErr = 2 ;
		error =	ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->ExpireTime == 0 ) {
		*ParmErr = 3 ;
		error =	ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( !ExpireInfo->ExpirePolicy || *(ExpireInfo->ExpirePolicy) == L'\0' ) {
	    //
	    //  If no name is specified, use the newsgroups wildmat !
	    //

		// no expire policy was specified, so we use the newsgroups.  we copy
		// it into another buffer to verify that it is 0 terminated
		ExpireInfo->ExpirePolicy = (PWCHAR) LocalAlloc(LMEM_ZEROINIT, ExpireInfo->cbNewsgroups + 1);
		if (ExpireInfo->ExpirePolicy == NULL) {
			error = ERROR_NOT_ENOUGH_MEMORY;
			goto Exit;
		}
		fDidAlloc = TRUE;
	
		memcpy(ExpireInfo->ExpirePolicy, ExpireInfo->Newsgroups, ExpireInfo->cbNewsgroups);
	}

	expire = (pInstance->ExpireObject())->AllocateExpireBlock(	
												NULL,
												ExpireInfo->ExpireSizeHorizon,
												ExpireInfo->ExpireTime,
												(PCHAR)ExpireInfo->Newsgroups,
												ExpireInfo->cbNewsgroups,
												(PCHAR)ExpireInfo->ExpirePolicy,
												TRUE	// Is unicode !
												) ;

	if( expire == 0 ) {
		error =	GetLastError() ;
		goto Exit ;
	}

	if( !(pInstance->ExpireObject())->CreateExpireMetabase( expire ) ) {
		(pInstance->ExpireObject())->CloseExpireBlock( expire ) ;
		error =	NERR_InternalError ;		
		goto Exit ;
	}

	(pInstance->ExpireObject())->InsertExpireBlock( expire ) ;

	// grab the expire id allocated for this block
	*pdwExpireId = expire->m_ExpireId ;

	PCHAR args[1];
	CHAR  szId[20];

	_itoa( pInstance->QueryInstanceId(), szId, 10 );
	args[0] = szId;

	NntpLogEvent(		
			NNTP_EVENT_EXPIRE_ADDED,
			1,
			(const CHAR **)args,
			0 ) ;

Exit:

	if (fDidAlloc) LocalFree(ExpireInfo->ExpirePolicy);

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
	return	error ;
}

NET_API_STATUS
NET_API_FUNCTION
NntprDeleteExpire(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	DWORD				ExpireId
	)	
{
	DWORD	dwError = NERR_Success ;
	LPEXPIRE_BLOCK	expire = NULL ;

	TraceFunctEnter("NntprDeleteExpire");

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning ) {
		dwError = NERR_ServerNotStarted ;
		goto Exit ;
	}

    //
    //  Check for proper access.
    //
    dwError = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( dwError != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",dwError );
		goto Exit ;
    }

	if( ExpireId == 0 ) {
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	expire = (pInstance->ExpireObject())->SearchExpireBlock( ExpireId ) ;

	if( !expire )	{
		dwError = NERR_ResourceNotFound ;
	}	else	{

		(pInstance->ExpireObject())->MarkForDeletion( expire ) ;
		(pInstance->ExpireObject())->CloseExpireBlock( expire ) ;

		PCHAR args [2];
		char  szTemp [22];
		CHAR  szId[20];

		_itoa( pInstance->QueryInstanceId(), szId, 10 );
		args[0] = szId;

		wsprintf( szTemp, "%d", ExpireId );
		args[1] = szTemp;

		NntpLogEvent(		
				NNTP_EVENT_EXPIRE_DELETED,
				2,
				(const CHAR **)args,
				0 ) ;
	}

Exit:

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
	return	dwError ;
}

NET_API_STATUS
NET_API_FUNCTION
NntprGetExpireInformation(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	DWORD				ExpireId,
	OUT	LPNNTP_EXPIRE_ENUM_STRUCT	Buffer
	)
{
	Buffer->EntriesRead = 0 ;
	Buffer->Buffer = NULL ;
	DWORD	dwError = NERR_Success ;
	LPEXPIRE_BLOCK	expire = NULL ;

	TraceFunctEnter("NntprGetExpireInformation");

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning ) {
		dwError = NERR_ServerNotStarted ;
		goto Exit ;
	}

	if( ExpireId == 0 ) {
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

    //
    //  Check for proper access.
    //
    dwError = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_READ, TCP_QUERY_ADMIN_INFORMATION );
    if( dwError != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",dwError );
		goto Exit ;
    }

	EnterCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

	expire = (pInstance->ExpireObject())->SearchExpireBlock( ExpireId ) ;

	if( !expire )	{
		dwError = NERR_ResourceNotFound ;
	}	else	{

		DWORD	cb = (pInstance->ExpireObject())->CalculateExpireBlockSize( expire ) ;

		PCHAR	bufStart = (PCHAR)MIDL_user_allocate( cb ) ;
		PCHAR    bufAllocated = bufStart;
		LPI_EXPIRE_INFO	pTemp = (LPI_EXPIRE_INFO)bufStart ;

		if( bufStart == NULL ) {
			dwError = ERROR_NOT_ENOUGH_MEMORY ;
		}	else	{
			PWCHAR	bufEnd = (PWCHAR)(bufStart + cb) ;

			if( !FillExpireInfoBuffer(
								pInstance,
								expire,
								&bufStart,
								&bufEnd ) )	{

				MIDL_user_free( bufAllocated ) ;
				dwError = ERROR_NOT_ENOUGH_MEMORY ;
			}	else	{

				Buffer->Buffer = pTemp ;
				Buffer->EntriesRead = 1 ;
			
			}
		}

		(pInstance->ExpireObject())->CloseExpireBlock( expire ) ;
	}

	LeaveCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

Exit:

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
	return	dwError  ;
}

NET_API_STATUS
NET_API_FUNCTION
NntprSetExpireInformation(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	LPI_EXPIRE_INFO		ExpireInfo,
	OUT	LPDWORD				ParmErr	OPTIONAL
	)
{
	DWORD	dwError = NERR_Success ;
	LPEXPIRE_BLOCK	expire = NULL ;

	TraceFunctEnter("NntprSetExpireInformation");

	if( ParmErr == 0 ) {
		ParmErr = &dwError ;
	}

    ACQUIRE_SERVICE_LOCK_SHARED();

	//
	//	Locate the instance object given id
	//

	PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
	if( pInstance == NULL ) {
		ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
		return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
	}

	if( !(pInstance->ExpireObject())->m_FExpireRunning ) {
		dwError = NERR_ServerNotStarted ;
		goto Exit ;
	}

    //
    //  Check for proper access.
    //
    dwError = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( dwError != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",dwError );
		goto Exit ;
    }

	if( ExpireInfo->ExpireId == 0 ) {
		*ParmErr = 1 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->Newsgroups == 0 ||
		ExpireInfo->cbNewsgroups == 0 ) {
		*ParmErr = 2 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->ExpireSizeHorizon == 0 ) {
		*ParmErr = 3 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( ExpireInfo->ExpireTime == 0 ) {
		*ParmErr = 4 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	if( !ExpireInfo->ExpirePolicy || *(ExpireInfo->ExpirePolicy) == L'\0' ) {
		*ParmErr = 5 ;
		dwError = ERROR_INVALID_PARAMETER ;
		goto Exit ;
	}

	EnterCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

	expire = (pInstance->ExpireObject())->SearchExpireBlock( ExpireInfo->ExpireId ) ;

	if( !expire )	{
		dwError = NERR_ResourceNotFound ;
	}	else	{

		LPSTR*	lpstrNewsgroups = AllocateMultiSzTable(	
												(char*)ExpireInfo->Newsgroups,
												ExpireInfo->cbNewsgroups,
												TRUE ) ;

		DWORD cbAsciiBuffer = (wcslen( ExpireInfo->ExpirePolicy ) + 1) * 2;
		LPSTR	ExpirePolicyAscii =
			(LPSTR)ALLOCATE_HEAP( cbAsciiBuffer ) ;
		if( ExpirePolicyAscii != 0 ) {
			WideCharToMultiByte(CP_ACP, 0, ExpireInfo->ExpirePolicy, -1,
				ExpirePolicyAscii, cbAsciiBuffer, NULL, NULL);
			//CopyUnicodeStringIntoAscii( ExpirePolicyAscii, ExpireInfo->ExpirePolicy ) ;
		}

		if( lpstrNewsgroups && ExpirePolicyAscii ) {
			// allocations succeeded - do the right thing.
			if( expire->m_Newsgroups != 0 ) {
				FREE_HEAP( expire->m_Newsgroups ) ;
			}
			if( expire->m_ExpirePolicy != 0 ) {
				FREE_HEAP( expire->m_ExpirePolicy ) ;
			}
			expire->m_Newsgroups = lpstrNewsgroups ;
			expire->m_ExpireSize = ExpireInfo->ExpireSizeHorizon ;
			expire->m_ExpireHours = ExpireInfo->ExpireTime ;
			expire->m_ExpirePolicy = ExpirePolicyAscii ;
			(pInstance->ExpireObject())->SaveExpireMetabaseValues( 0, expire ) ;
		} else {
			// free any stuff allocated
			if( lpstrNewsgroups ) {
				FREE_HEAP( lpstrNewsgroups );
			}
			if( ExpirePolicyAscii ) {
				FREE_HEAP( ExpirePolicyAscii );
			}
			dwError = ERROR_NOT_ENOUGH_MEMORY ;
		}

		(pInstance->ExpireObject())->CloseExpireBlock( expire ) ;
	}

	LeaveCriticalSection( &(pInstance->ExpireObject())->m_CritExpireList ) ;

Exit:

	pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
	return	dwError ;
}


BOOL
FillExpireInfoBuffer(	IN	PNNTP_SERVER_INSTANCE pInstance,
						IN	LPEXPIRE_BLOCK	expire,
						IN OUT LPSTR*		FixedPortion,
						IN OUT LPWSTR*		EndOfVariableData )	{

	LPI_EXPIRE_INFO	expireInfo = (LPI_EXPIRE_INFO)(*FixedPortion) ;

	*FixedPortion = (*FixedPortion) + sizeof( NNTP_EXPIRE_INFO ) ;

	_ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedPortion ) ;
	_ASSERT( expire->m_ExpireId != 0 ) ;

	LPSTR	lpstrNewsgroups = 0 ;
	DWORD	cbNewsgroups = 0 ;
    BOOL    fIsRoadKill = FALSE ;

	if( (pInstance->ExpireObject())->GetExpireBlockProperties(	
												expire,
												lpstrNewsgroups,
												cbNewsgroups,
												expireInfo->ExpireTime,
												expireInfo->ExpireSizeHorizon,
                                                TRUE,
												fIsRoadKill ) )	
	{
		//
		// Copy the expire policy to the output buffer
		//

		CopyStringToBuffer(
			expire->m_ExpirePolicy,
			*FixedPortion,
			EndOfVariableData,
			&expireInfo->ExpirePolicy
			);
		
		WCHAR*	dest = *EndOfVariableData - (cbNewsgroups/2) ;
		CopyMemory( dest, lpstrNewsgroups, cbNewsgroups ) ;
		*EndOfVariableData = *EndOfVariableData - (cbNewsgroups/2) ;

		expireInfo->cbNewsgroups = cbNewsgroups ;
		expireInfo->Newsgroups = (PUCHAR)dest ;
		expireInfo->ExpireId = expire->m_ExpireId ;

		FREE_HEAP( lpstrNewsgroups ) ;

		return	TRUE ;
	}

	return	FALSE ;
}

#if 0
NET_API_STATUS
NET_API_FUNCTION
NntprGetExpireInformation(
	IN	NNTP_HANDLE			ServerName,
	IN	DWORD				ExpireId,
	OUT	LPI_EXPIRE_INFO		*ExpireInfo
	)
{


	DWORD	dwError = NERR_Success ;

	if( !FExpireRunning )
		return	NERR_ServerNotStarted ;

	*ExpireInfo = NULL ;

	if( ExpireId == 0 ) {
		return	ERROR_INVALID_PARAMETER ;
	}

	EnterCriticalSection( &gCritExpireList ) ;

	LPEXPIRE_BLOCK	expire = SearchExpireBlock( ExpireId ) ;

	if( !expire )	{
		dwError = NERR_ResourceNotFound ;
	}	else	{

		DWORD	cb = CalculateExpireBlockSize( expire ) ;

		PCHAR	bufStart = (PCHAR)MIDL_user_allocate( cb ) ;
		LPI_EXPIRE_INFO	pTemp = (LPI_EXPIRE_INFO)bufStart ;

		if( bufStart == NULL ) {
			dwError = ERROR_NOT_ENOUGH_MEMORY ;
		}	else	{
			PWCHAR	bufEnd = (PWCHAR)(bufStart + cb) ;

			if( !FillExpireInfoBuffer( expire,
										&bufStart,
										&bufEnd ) )	{

				MIDL_user_free( bufStart ) ;
				dwError = ERROR_NOT_ENOUGH_MEMORY ;
			}	else	{

				*ExpireInfo = pTemp ;
			
			}

		}

		CloseExpireBlock( expire ) ;

	}

	LeaveCriticalSection( &gCritExpireList ) ;

	return	dwError  ;
	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\tomaster.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.h

Abstract:

    This module contains class declarations/definitions for

!!!

    **** Overview ****

!!!
Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_TOMASTER_H_
#define	_TOMASTER_H_



//
//
//
// CToMasterFeed - for processing article to master (from slaves)
//

class	CToMasterFeed:	public CInFeed 	{

//
// Public Members
//

public :

	//
	// Constructor
	//

	CToMasterFeed(void){};

	//
	// Destructor
	//

	virtual ~CToMasterFeed(void) {};

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"To Master" ;
				}


protected:


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\toclient.cpp ===
/* Contains Infeed, Article, and Fields code specific to ToClient Infeeds */

#include "tigris.hxx"


BOOL
CToClientArticle::fInit(	FIO_CONTEXT*	pFIOContext,
							CNntpReturn&	nntpReturn,
							CAllocator*		pAllocator
							)	{

	m_pFIOContext = pFIOContext ;
	return	CArticleCore::fInit(	"DummyString",
									nntpReturn,
									pAllocator,
									pFIOContext->m_hFile 
									) ;
}

CToClientArticle::CToClientArticle()	: 
	m_pFIOContext( 0 ) 	{
}

CToClientArticle::~CToClientArticle()	{
	if( m_pFIOContext != 0 )	{
		m_hFile = INVALID_HANDLE_VALUE ;
		ReleaseContext( m_pFIOContext ) ;
	}
}

FIO_CONTEXT*
CToClientArticle::GetContext()	{
	return	m_pFIOContext ;
}

FIO_CONTEXT*
CToClientArticle::fWholeArticle(
						DWORD&	ibOffset, 
						DWORD&	cbLength
						)	{
	HANDLE	hTemp ;
	CArticleCore::fWholeArticle( hTemp, ibOffset, cbLength ) ;
	return	GetContext() ;
}


BOOL
CToClientArticle::fValidate(
							CPCString& pcHub,
							const char * szCommand,
							CInFeed*	pInFeed,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	No real validation is needed because this is one of
	our own articles, so just return TRUE.

Arguments:

	szCommand - IGNORED
	nntpReturn - The return value for this function call


Return Value:

	Always TRUE

--*/
{

	return nntpReturn.fSetOK();
}


BOOL
CToClientArticle::fMungeHeaders(
						CPCString& pcHub,
						CPCString& pcDNS,
						CNAMEREFLIST & grouplist,
						DWORD remoteIpAddress,
						CNntpReturn & nntpReturn,
                        PDWORD  pdwLinesOffset
			  )

/*++

Routine Description:

	No munging is needed because this article
	has already be processed.

Arguments:

	grouplist - IGNORED
	nntpReturn - The return value for this function call


Return Value:

	Always TRUE

--*/
{
    *pdwLinesOffset = INVALID_FILE_SIZE;
	return nntpReturn.fSetOK();
}



BOOL
CToClientArticle::fCheckBodyLength(
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Always return TRUE.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	Always TRUE

--*/
{

	return nntpReturn.fSetOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\xover\src\makefile.inc ===
$(O)\mailmsg.h : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\server\toclient.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    toclient.h

Abstract:

    This module contains class declarations/definitions for

		CToClientArticle

    **** Overview ****

	This derives a classe from CArticle that will be
	used to read the article from the disk and give
	it to a client (or peer).

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_TOCLIENT_H_
#define	_TOCLIENT_H_


//
//
//
// CToClientArticle - class for reading an article from disk.
//

class	CToClientArticle  : public CArticle {
public:

	CToClientArticle() ;

	//
	//	Cleanup our data structures !
	//

	~CToClientArticle() ;

	BOOL
	fInit(
		FIO_CONTEXT*	pFIOContext,
		CNntpReturn & nntpReturn,
		CAllocator * pAllocator
		) ;

	BOOL fInit(
			const char * szFilename,
			CNntpReturn & nntpReturn,
			CAllocator * pAllocator,
			CNntpServerInstanceWrapper *pInstance,
			HANDLE hFile = INVALID_HANDLE_VALUE,
			DWORD	cBytesGapSize = cchUnknownGapSize,
			BOOL    fCacheCreate = FALSE
			) {
        return CArticle::fInit( szFilename,
                                nntpReturn,
                                pAllocator,
                                pInstance,
                                hFile,
                                cBytesGapSize,
                                fCacheCreate );
     }

	FIO_CONTEXT*
	GetContext() ;

	FIO_CONTEXT*
	fWholeArticle(	
			DWORD&	ibStart,
			DWORD&	cbLength
			) ;

	//
	// Validate the article (pretty much do nothing)
	//

	BOOL fValidate(
			CPCString& pcHub,
			const char * szCommand,
			CInFeed*	pInFeed,
			CNntpReturn & nntpReturn
			);

	//
	// Munge the headers (pretty much do nothing)
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 CNAMEREFLIST & grouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpr,
             PDWORD pdwLinesOffset = NULL
			 );

	//
	// Check the command line (do nothing)
	//

	BOOL fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr)
		{
			return nntpr.fSetOK();
		}

	//
	// Asking this object for the message id is an error
	//

	const char * szMessageID(void) {
			_ASSERT(FALSE);
			return "";
			};

    // Asking this object for the control message is an error
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			_ASSERT(FALSE);
			return (CONTROL_MESSAGE_TYPE)MAX_CONTROL_MESSAGES;    // guaranteed to NOT be a control message
			};

	//
	// Asking this object for the newsgroups is an error
	//

	const char * multiszNewsgroups(void) {
			_ASSERT(FALSE);
			return "";
			};

	//
	// Asking this object fo the number of newsgroups is an error
	//

	DWORD cNewsgroups(void) {
			_ASSERT(FALSE);
			return 0;
			};


	//
	// Asking this object for the Distribution is an error
	//

	const char * multiszDistribution(void) {
			_ASSERT(FALSE);
			return "";
			};

	//
	// Asking this object fo the number of Distribution is an error
	//

	DWORD cDistribution(void) {
			_ASSERT(FALSE);
			return 0;
			};

	//
	// Asking this object for the newsgroups is an error
	//

	const char * multiszPath(void) {
			_ASSERT(FALSE);
			return "";
			};

	//
	// Asking this object fo the number of Path is an error
	//

	DWORD cPath(void) {
			_ASSERT(FALSE);
			return 0;
			};

protected : 

	//
	// Open the file READ ONLY
	//

	BOOL fReadWrite(void) {
			return FALSE;
			}

	//
	// Check the body length (really, do nothing)
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn
			);

	//
	// require that the character following "Field Name:" is a space
	// This should not be called.
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent)
		{
			return TRUE;
		}

	FIO_CONTEXT*	m_pFIOContext ;
	

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\wildmat\src\newwild.cpp ===
#include <windows.h>
#include <dbgtrace.h>
#include "wildmat.h"

//---[ Description of the Wildmat standard ]-----------------------------------
//
//  Taken from:
//
//  INTERNET-DRAFT                                               S. Barber
//  Expires: September 1, 1996                  Academ Consulting Services
//                                                              April 1996
//                           Common NNTP Extensions
//                        draft-barber-nntp-imp-03.txt
//  
//      The WILDMAT format was first developed by Rich Salz to provide
//      a uniform mechanism for matching patterns in the same manner
//      that the UNIX shell matches filenames. There are five pattern
//      matching operations other than a strict one-to-one match
//      between the pattern and the source to be checked for a match.
//      The first is an asterisk (*) to match any sequence of zero or
//      more characters. The second is a question mark (?) to match any
//      single character. The third specifies a specific set of
//      characters. The set is specified as a list of characters, or as
//      a range of characters where the beginning and end of the range
//      are separated by a minus (or dash) character, or as any
//      combination of lists and ranges. The dash can also be included
//      in the range as a character it if is the beginning or end of
//      the range. This set is enclosed in square brackets. The close
//      square bracket (]) may be used in a range if it is the first
//      character in the set. The fourth operation is the same as the
//      logical not of the third operation and is specified the same
//      way as the third with the addition of a caret character (^) at
//      the beginning of the test string just inside the open square
//      bracket. The final operation uses the backslash character to
//      invalidate the special meaning of the a open square bracket ([),
//      the asterisk, or the question mark.
//  
//  3.3.1 Examples
//  
//      a. [^]-] -- matches any character other than a close square bracket
//                  or a minus sign/dash.
//  
//      b. *bdc  -- matches any string that ends with the string "bdc"
//                  including the string "bdc" (without quotes).
//  
//      c. [0-9a-zA-Z] -- matches any string containing any alphanumeric string
//                  in English.
//  
//      d. a??d  --  matches any four character string which begins
//                   with a and ends with d.
//  
//-----------------------------------------------------------------------------



//----[ NOTES ]----------------------------------------------------------------
//                                                                            
// 		This function will raise an invalid access exception if either pszText                                                     
// 		or pszPattern is invalid or not null terminated while dereferencing the                                                    
// 		string. If this is possible, surround the call in a try-except block.                                                      
//  
//-----------------------------------------------------------------------------



//---[ Defines ]---------------------------------------------------------------

#define STACK_SIZE      256



//---[ HrMatchWildmat ]--------------------------------------------------------
//
//  Description:
//
//      Provides support for the "Wildmat" wild-card matching standard. See
//      description above.
//
//  Params:
//
//      pszText         String to test
//      pszPattern      Pattern to test against
//
//  Returns:
//      
//      ERROR_SUCCESS               If function succeeded, and match was found
//      ERROR_INVALID_PARAMETER     Text or pattern string is invalid
//      
//      ERROR_CAN_NOT_COMPLETE      Some other error occurred.
//
//  
//-----------------------------------------------------------------------------


HRESULT HrMatchWildmat(const char* pszText, const char* pszPattern)
{


	_ASSERT(pszText != NULL && pszPattern != NULL);



	BOOL fCharSet = FALSE;	// TRUE if currently parsing a character set in a pattern
	BOOL fNegated = FALSE;	// TRUE if there is a '^' at the beginning of the set
	BOOL fInSet   = FALSE;  // indicates when matching of a character set has completed
				// used to short-circuit character set evaluation
	int iStackPtr = 0;	// stack pointer
    
	const char* textStack[STACK_SIZE];	// stack of text pointers
	const char* patternStack[STACK_SIZE];	// stack of pattern pointers


	// If the pattern consists solely of a * then any text will match
	if (strcmp(pszPattern, "*") == 0)
		return ERROR_SUCCESS;


	while (TRUE) 
    {
		switch (*pszPattern) 
        {
		    case '*':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
                    

				// If there is a * at the end of the pattern then at this point we are
				// sure that we got a match
				if (pszPattern[1] == '\0')
					return ERROR_SUCCESS;


				// We could write a simpler recursive wildmat function. Here we would
				// recursively call wildmat. Instead, for performance reasons this
				// solution is iterative.
				// Here we save the current values of the text pointer and stack pointer
				// on a stack and we leave the * in the pattern, with the effect of
				// matching one character with the *. The next time through the while
				// loop, the * will still be in the pattern, thus we will try to match
				// the rest of the input with this *. If it turns to fail, we go back
				// one character.
				// See the comments right before the BACK label below.
		    	if (*pszText != '\0') 
                {
		    		if (iStackPtr == STACK_SIZE) 
                        return ERROR_CAN_NOT_COMPLETE;			// stack overflow
                        
		    		textStack[iStackPtr] = pszText;			// save current text pointer
		    		patternStack[iStackPtr] = pszPattern;	// save current pattern pointer
		    		iStackPtr++;
		    		pszPattern--;	// leave * in the input pattern and match one character
		    	}
		    	break;

		    case '?':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
		    	if (*pszText == '\0') 
                    goto BACK;
		    	break;

		    case '[':
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
                    
		    	fCharSet = TRUE;		    // beginning a character set
		    	fNegated = FALSE;			// so far we haven't seen a '^'
		    	fInSet = FALSE;				// used to short-circuit the evaluation of
		    						// membership to the character set

		    	// treat '^', '-' and ']' as special cases if they are
		    	// at the beginning of the character set (also "[^-a]" and "[^]a]")
		    	if (pszPattern[1] == '^') 
                {
		    		fNegated = TRUE;
		    		pszPattern++;
		    	}
		    	// '-' and ']' are literals if they appear at the beggining of the set
		    	if (pszPattern[1] == '-' || pszPattern[1] == ']') 
                {
		    		fInSet = (*pszText == pszPattern[1]);
		    		pszPattern++;
		    	}
		    	break;
		    		
		    case ']':
		    	if (fCharSet) 
                {
		    		if ((!fNegated && !fInSet) || (fNegated && fInSet)) 
                        goto BACK;
                        
		    		fCharSet = FALSE;		// this marks the end of a character set
		    	} 
                else 
                {
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '-':
		    	if (fCharSet) 
                {
		    		unsigned char startRange = pszPattern[-1];	// we use unsigned char
					unsigned char endRange;						// to support extended
					unsigned char ch;							// characters

		    		if (pszPattern[1] == '\0')
		    			return ERROR_INVALID_PARAMETER;
		    		else 
                    {
                        if (pszPattern[1] == ']')		// a dash at the end of the set is
		    			    fInSet = (*pszText == '-');	// treated as a literal
		    		    else 
                        {							    // we have a range
		    		    	if (pszPattern[1] == '\\')  // escape character, skip it
                            {	
		    		    		pszPattern++;
		    		    		if (pszPattern[1] == '\0') 
                                    return ERROR_INVALID_PARAMETER;
		    		    	}
							ch = *pszText;
							endRange = pszPattern[1];

							if (startRange > endRange)
								return ERROR_INVALID_PARAMETER;
							// here is where we could need unsigned characters
		    		    	fInSet = (ch >= startRange && ch <= endRange);
		    		    	pszPattern++;
		    		    	break;
		    		    }
                    }
		    	} 
                else 
                {						// outside a character set '-' has no special meaning
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '\0':					// end of the pattern
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
		    	if (*pszText == '\0')
		    		return ERROR_SUCCESS;
		    	else
		    		goto BACK;
		    	break;

		    default:				
DEFAULT:    	
                if (*pszPattern == '\\') 
                {
		    		pszPattern++;		// escape character, treat the next character as a literal
		    		if (*pszPattern == '\0') 
                        return ERROR_INVALID_PARAMETER;
		    	}
		    	if (!fCharSet) 
                {						// any other character is treated as a literal
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	} 
                else 
                {
		    		// the following if takes care of the two "special" cases:
		    		//		[c-a]       (we don't want to accept c), and
		    		//		[c-]		(we want to accept c)
		    		if (!(pszPattern[1] == '-' && pszPattern[2] != ']'))
		    			fInSet = (*pszText == *pszPattern);
		    	}
		    	break;
		} // switch

		pszPattern++;
		
        if (!fCharSet) 
        {
			if (*pszText != '\0') 
                pszText++;
		} 
        else 
        {               			// code to short-circuit character set evaluation
			if (fInSet) 			// skip the rest of the character set
            {		
				while (*pszPattern != '\0' && *pszPattern != ']') 
                {
					if (*pszPattern == '\\')
                    {				// escape character, treat the next character as a literal
						pszPattern++;
						if (*pszPattern == '\0') 
                            return ERROR_INVALID_PARAMETER;
					}
					pszPattern++;
				}
			}
		}
		continue;	// the continue statement is to jump to the beginning of the loop,
					// we could have used used goto some label but that's what continue's
					// are for.


		// This is only reached by jumping to BACK.
		// This is equivalent to returning from a recursive solution of wildmat.
		// If the stack pointer is zero then the bottommost "recursive call" failed,
		// otherwise we "unwind one stack frame" and resume execution of the previous
		// call at the top of the while loop. Notice that since "recursive calls" are
		// only done when we find a '*' in the pattern outside a character set, the
		// value of fCharSet has to be set to false.
BACK:	
        if (iStackPtr == 0)                     	// we exhausted all possibilities
            return ERROR_FILE_NOT_FOUND;
            
		iStackPtr--;						    	// try matching no characters with the '*'
		pszText = textStack[iStackPtr];
		pszPattern = patternStack[iStackPtr] + 1;	// eat the '*' matching no input characters
		fCharSet = FALSE;				        	// this has to be the case
	} // while

    // should never get here
	_ASSERT(FALSE);						
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\nntp\server\watchci\src\watchci.cpp ===
#include <windows.h>
#include <dbgtrace.h>
#include <stdlib.h>
#include <tflist.h>
#include <rwnew.h>
#include <xmemwrpr.h>
#include "watchci.h"

CWatchCIRoots::CWatchCIRoots() :
	m_CIRootList (&CCIRoot::m_pPrev, &CCIRoot::m_pNext),
	m_dwUpdateLock(-1),
	m_dwTicksLastUpdate(0) {
	TraceFunctEnter("WatchCIRoots::CWatchCIRoots");
	
	m_heRegNot = NULL;
	m_hkCI = NULL;
	
	TraceFunctLeave();
}

CWatchCIRoots::~CWatchCIRoots() {
	TraceFunctEnter("CWatchCIRoots::~CWatchCIRoots");

	Terminate();

	TraceFunctLeave();
}

HRESULT CWatchCIRoots::Terminate() {
	TraceFunctEnter("CWatchCIRoots::Terminate");

	m_Lock.ExclusiveLock();

	if (m_hkCI != NULL)
		_VERIFY(RegCloseKey(m_hkCI) == ERROR_SUCCESS);
	m_hkCI = NULL;

	if (m_heRegNot != NULL)
		_VERIFY(CloseHandle(m_heRegNot));
	m_heRegNot = NULL;

	EmptyList();

	m_Lock.ExclusiveUnlock();

	TraceFunctLeave();

	return S_OK;
}

HRESULT CWatchCIRoots::Initialize(WCHAR *pwszCIRoots) {
	TraceFunctEnter("CWatchCIRoots::Initialize");

	_ASSERT(m_heRegNot == NULL);
	_ASSERT(m_hkCI == NULL);

	if (m_hkCI != NULL || m_heRegNot != NULL) {
		ErrorTrace((DWORD_PTR)this, "Already initialized");
		return E_FAIL;
	}

	m_Lock.ExclusiveLock();

	DWORD ec = ERROR_SUCCESS;
	HRESULT hr = S_OK;
	do {
		// this event will get signalled whenever the CI registry changes
		m_heRegNot = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_heRegNot == NULL) { ec = GetLastError(); break; }

		// open the registry pointing to the content index information
		ec = RegOpenKey(HKEY_LOCAL_MACHINE, pwszCIRoots, &m_hkCI);
		if (ec != ERROR_SUCCESS) break;

		// register to get notified on changes
		ec = RegNotifyChangeKeyValue(m_hkCI, TRUE,
									 REG_NOTIFY_CHANGE_NAME |
									 REG_NOTIFY_CHANGE_LAST_SET,
									 m_heRegNot,
									 TRUE);
		if (ec != ERROR_SUCCESS) break;

		// Load the initial values
		ec = ReadCIRegistry();
		if (ec != ERROR_SUCCESS) break;

	} while (0);

	// handle error conditions
	if (ec != ERROR_SUCCESS || hr != S_OK) {
		// if hr is still S_OK then an error code is in ec
		if (hr == S_OK) hr = HRESULT_FROM_WIN32(ec);

		// free up any resources we might have created
		if (m_hkCI != NULL) {
			_VERIFY(RegCloseKey(m_hkCI) == ERROR_SUCCESS);
			m_hkCI = NULL;
		}

		if (m_heRegNot != NULL) {
			_VERIFY(CloseHandle(m_heRegNot));
			m_heRegNot = NULL;
		}
	}

	m_Lock.ExclusiveUnlock();

	return hr;
}

void CWatchCIRoots::EmptyList() {
	TFList<CCIRoot>::Iterator it(&m_CIRootList);

	while (!it.AtEnd()) {
		CCIRoot *pRoot = it.Current();
		XDELETE pRoot->m_pwszPath;
		it.RemoveItem();
		XDELETE pRoot;
	}
}

HRESULT CWatchCIRoots::CheckForChanges(DWORD cTimeout) {
	TraceFunctEnter("CWatchCIRoots::CheckForChanges");

	DWORD hr;
	DWORD w = WaitForSingleObject(m_heRegNot, cTimeout);
	switch (w) {
		case WAIT_OBJECT_0:
			DebugTrace(0, "WatchCI: registry changes");
			m_Lock.ExclusiveLock();
			hr = ReadCIRegistry();
			m_Lock.ExclusiveUnlock();
			// register to get notified on changes
			RegNotifyChangeKeyValue(m_hkCI, TRUE,
									REG_NOTIFY_CHANGE_NAME |
									REG_NOTIFY_CHANGE_LAST_SET,
									m_heRegNot,
									TRUE);
			break;
		case WAIT_TIMEOUT:
			hr = S_OK;
			break;
		default:
			hr = HRESULT_FROM_WIN32(GetLastError());
			break;
	}

	TraceFunctLeave();
	return hr;
}

//
// this function allows us to query a content index value.  if it isn't
// found in the hkPrimary key then it will be looked for in the hkSecondary
// key.
//
// parameters:
//	hkPrimary - the primary key to look in
// 	hkSecondary - the secondary key to look in
//	szValueName - the value to look up
//	pResultType - pointer to receive the type of the data
//	pbResult - pointer to receive the data itself
//	pcbResult - the number of bytes in lpByte
// returns:
//	S_FALSE - the value doesn't exist
//	S_OK - the value exists
//	any other - a error code as an HRESULT
//
HRESULT CWatchCIRoots::QueryCIValue(HKEY hkPrimary, HKEY hkSecondary,
								    LPCTSTR szValueName, LPDWORD pResultType,
									LPBYTE pbResult, LPDWORD pcbResult)
{
	TraceFunctEnter("CWatchCIRoots::QueryCIValue");

	DWORD ec;
	DWORD hr = S_FALSE;
	DWORD i;
	HKEY hkArray[2] = { hkPrimary, hkSecondary };

	for (i = 0; i < 2 && hr == S_FALSE; i++) {
		ec = RegQueryValueEx(hkArray[i], szValueName, NULL, pResultType,
						 	 pbResult, pcbResult);
		switch (ec) {
			case ERROR_SUCCESS:
				hr = S_OK;
				break;
			case ERROR_FILE_NOT_FOUND:
				hr = S_FALSE;
				break;
			default:
				hr = HRESULT_FROM_WIN32(ec);
				break;
		}
	}

	return hr;
}

HRESULT CWatchCIRoots::QueryCIValueDW(HKEY hkPrimary, HKEY hkSecondary,
								      LPCTSTR szValueName, LPDWORD pdwResult)
{
	TraceFunctEnter("CWatchCIRoots::QueryCIValueDW");
	
	DWORD hr;
	DWORD dwType, cbResult = 4;

	hr = QueryCIValue(hkPrimary, hkSecondary, szValueName,
		&dwType, (LPBYTE) pdwResult, &cbResult);
	if (hr == S_OK && dwType != REG_DWORD) {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
	}

	TraceFunctLeave();
	return hr;
}

HRESULT CWatchCIRoots::QueryCIValueSTR(HKEY hkPrimary, HKEY hkSecondary,
								       LPCTSTR szValueName, LPCTSTR pszResult,
									   PDWORD pchResult)
{
	TraceFunctEnter("CWatchCIRoots::QueryCIValueSTR");
	
	DWORD hr;
	DWORD dwType;

	hr = QueryCIValue(hkPrimary, hkSecondary, szValueName,
		&dwType, (LPBYTE) pszResult, pchResult);
	if (hr == S_OK && dwType != REG_SZ) {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
	}

	TraceFunctLeave();
	return hr;
}

HRESULT CWatchCIRoots::ReadCIRegistry(void) {

	// Assume we have an exclusive lock upon entry to this routine
	
	TraceFunctEnter("CWatchCIRoots::ReadCIRegistry");
	
	HKEY hkCatalogs;
	DWORD ec;
	DWORD hr;

	// open the key to the catalogs
	ec = RegOpenKey(m_hkCI, REGCI_CATALOGS, &hkCatalogs);
	if (ec != ERROR_SUCCESS) {
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(ec);
	}

	EmptyList();

	// enumerate the catalogs
	TCHAR szSubkey[_MAX_PATH];
	DWORD iSubkey = 0, cbSubkey;
	for (iSubkey = 0; ec != ERROR_NO_MORE_ITEMS; iSubkey++) {
		cbSubkey = _MAX_PATH;
		ec = RegEnumKeyEx(hkCatalogs, iSubkey, szSubkey, &cbSubkey, NULL,
						  NULL, NULL, NULL);
		if (ec == ERROR_NO_MORE_ITEMS) break;
		if (ec != ERROR_SUCCESS) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}

		DebugTrace(0, "looking at catalog %S", szSubkey);

		// open this subkey
		HKEY hkThisCatalog = 0;
		ec = RegOpenKey(hkCatalogs, szSubkey, &hkThisCatalog);
		if (ec != ERROR_SUCCESS) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}

		// see if this catalog is being indexed
		DWORD dwIsIndexed;
		hr = QueryCIValueDW(hkThisCatalog, m_hkCI, REGCI_ISINDEXED,
							&dwIsIndexed);
		if (FAILED(hr)) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}
		if (hr == S_FALSE || dwIsIndexed != 0x1) {
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			continue;
		}
		DebugTrace(0, "this catalog is being indexed");

		// find the location of this catalog
		TCHAR szLocation[_MAX_PATH];
		DWORD cLocation = sizeof(szLocation);
		hr = QueryCIValueSTR(hkThisCatalog, m_hkCI, REGCI_LOCATION,
							 szLocation, &cLocation);
		if (FAILED(hr)) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}
		if (hr == S_FALSE) {
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			continue;
		}
		DebugTrace(0, "catalog location = %S", szLocation);

		// find out which NNTP instance is being indexed
		DWORD dwInstance = sizeof(szLocation);
		hr = QueryCIValueDW(hkThisCatalog, m_hkCI, REGCI_NNTPINSTANCE,
							&dwInstance);
		if (FAILED(hr)) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return HRESULT_FROM_WIN32(ec);
		}
		if (hr == S_FALSE) {
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			continue;
		}
		DebugTrace(0, "dwInstance = %lu", dwInstance);

		WCHAR *pwszLocation = XNEW WCHAR [lstrlenW(szLocation)+1];
		if (!pwszLocation) {
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return E_OUTOFMEMORY;
		}

		lstrcpyW(pwszLocation, szLocation);
		
		CCIRoot *pRoot = XNEW CCIRoot(dwInstance, pwszLocation);
		if (!pRoot) {
			XDELETE pwszLocation;
			_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);
			_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
			TraceFunctLeave();
			return E_OUTOFMEMORY;
		}

		m_CIRootList.PushBack(pRoot);

		_VERIFY(RegCloseKey(hkThisCatalog) == ERROR_SUCCESS);
	}

	_VERIFY(RegCloseKey(hkCatalogs) == ERROR_SUCCESS);

	TraceFunctLeave();
	return S_OK;
}

// don't read the catalogs more than once per second
#define CATALOG_UPDATE_RATE 1000

void CWatchCIRoots::UpdateCatalogInfo(void) {
    long sign = InterlockedIncrement(&m_dwUpdateLock);
    if (sign == 0) {
        DWORD dwTicks = GetTickCount();
        if (dwTicks - m_dwTicksLastUpdate > CATALOG_UPDATE_RATE)
            CheckForChanges();
    }
    InterlockedDecrement(&m_dwUpdateLock);
}

HRESULT CWatchCIRoots::GetCatalogName(
	DWORD dwInstance, DWORD cbSize, WCHAR *pwszBuffer) {

	HRESULT hr = S_FALSE;

	// If we don't have a handle to the registry key or an event watching
	// the key, then content indexing must not be installed.  Fail.
	if (m_heRegNot == NULL || m_hkCI == NULL)
		return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);

	UpdateCatalogInfo();

	m_Lock.ShareLock();

	TFList<CCIR