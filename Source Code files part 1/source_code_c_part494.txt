 of IMimeMessage objects
// --------------------------------------------------------------------------------
void ReleaseParts(ULONG cParts, LPPARTINFO prgPart)
{
    // Loop
    for (ULONG i=0; i<cParts; i++)
    {
        SafeRelease(prgPart[i].pMessage);
    }
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::CMimeMessageParts
// --------------------------------------------------------------------------------
CMimeMessageParts::CMimeMessageParts(void)
{
	m_cRef = 1;
    m_cParts = 0;
    m_cAlloc =0;
    m_prgPart = NULL;
	InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::CMimeMessageParts
// --------------------------------------------------------------------------------
CMimeMessageParts::~CMimeMessageParts(void)
{
    ReleaseParts(m_cParts, m_prgPart);
    SafeMemFree(m_prgPart);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeMessageParts == riid)
        *ppv = (IMimeMessageParts *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeMessageParts::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeMessageParts::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::AddPart
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::AddPart(IMimeMessage *pMessage)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid ARg
    if (NULL == pMessage)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Grow my internal array
    if (m_cParts + 1 >= m_cAlloc)
    {
        // Grow my array
        CHECKHR(hr = HrRealloc((LPVOID *)&m_prgPart, sizeof(PARTINFO) * (m_cAlloc + 10)));

        // Set alloc size
        m_cAlloc += 10;
    }

    // Set new
    ZeroMemory(&m_prgPart[m_cParts], sizeof(PARTINFO));
    m_prgPart[m_cParts].pMessage = pMessage;
    m_prgPart[m_cParts].pMessage->AddRef();
    m_cParts++;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::SetMaxParts
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::SetMaxParts(ULONG cParts)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Less than number alloced?
    if (cParts <= m_cAlloc)
        goto exit;

    // Grow my array
    CHECKHR(hr = HrAlloc((LPVOID *)&m_prgPart, sizeof(PARTINFO) * (cParts + 10)));

    // Set alloc size
    m_cAlloc = cParts + 10;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::CountParts
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::CountParts(ULONG *pcParts)
{
    // Invalid ARg
    if (NULL == pcParts)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set count
    *pcParts = m_cParts;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::EnumParts
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::EnumParts(IMimeEnumMessageParts **ppEnum)
{
    // Locals
    HRESULT         hr=S_OK;
    CMimeEnumMessageParts *pEnum=NULL;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppEnum = NULL;

    // Create the clone.
    pEnum = new CMimeEnumMessageParts;
    if (NULL == pEnum)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Init
    CHECKHR(hr = pEnum->HrInit(0, m_cParts, m_prgPart));

    // Set Return
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::CombineParts
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::CombineParts(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSTREAM            pstmMsg=NULL,
                        pstmSource=NULL;
    ULONG               i,
                        cMimePartials=0,
                        iPart,
                        cRejected=0;
    IMimeMessage       *pMessage;
    IMimeMessage       *pCombine=NULL;
    IMimeBody          *pRootBody=NULL;
    BOOL                fTreatAsMime;
    BODYOFFSETS         rOffsets;
    LPSTR               pszSubject=NULL;
    PROPVARIANT         rData;

    // Invalid ARg
    if (NULL == ppMessage)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppMessage = NULL;

    // Create Temp Stream...
    CHECKALLOC(pstmMsg = new CVirtualStream);

    // Set all rejected flags to FALSE...
    for (i=0; i<m_cParts; i++)
        m_prgPart[i].fRejected = FALSE;

    // Enumerate parts
    for (i=0; i<m_cParts; i++)
    {
        // Reability
        pMessage = m_prgPart[i].pMessage;
        Assert(pMessage);

        // Get Message Source
        CHECKHR(hr = pMessage->GetMessageSource(&pstmSource, COMMIT_ONLYIFDIRTY));

        // Get Tree Object
        CHECKHR(hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *)&pRootBody));

        // Get Root Body Offset
        CHECKHR(hr = pRootBody->GetOffsets(&rOffsets));

        // Un-init iPart
        iPart = 0;

        // Mime Message ?
        rData.vt = VT_UI4;
        if (pRootBody->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL) == S_OK && SUCCEEDED(pRootBody->GetProp(STR_PAR_NUMBER, 0, &rData)))
        {
            // Count MimePartials
            cMimePartials++;

            // Treat this part as mime...
            fTreatAsMime = TRUE;

            // Get Part Number
            iPart = rData.ulVal;
        }

        // Otherwise
        else
        {
            // Don't treat as mime
            fTreatAsMime = FALSE;

            // If There have been legal mime partials, this part is rejected
            m_prgPart[i].fRejected = BOOL(cMimePartials > 0);
        }

        // If Rejected, continue...
        if (m_prgPart[i].fRejected)
        {
            cRejected++;
            continue;
        }

        // If MIME - and part one
        if (i == 0)
        {
            // Treat as mime
            if (fTreatAsMime && 1 == iPart)
            {
                // Merge the headers of part one
                CHECKHR(hr = MimeOleMergePartialHeaders(pstmSource, pstmMsg));

                // CRLF
                CHECKHR(hr = pstmMsg->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

                // Append message body onto lpstmOut
                CHECKHR(hr = HrCopyStream(pstmSource, pstmMsg, NULL));
            }

            else
            {
                // Seek to body start
                CHECKHR(hr = HrStreamSeekSet(pstmSource, 0));

                // Append message body onto lpstmOut
                CHECKHR(hr = HrCopyStream(pstmSource, pstmMsg, NULL));
            }
        }

        else
        {
            // Seek to body start
            CHECKHR(hr = HrStreamSeekSet(pstmSource, rOffsets.cbBodyStart));

            // Append message body onto lpstmOut
            CHECKHR(hr = HrCopyStream(pstmSource, pstmMsg, NULL));
        }

        // Raid 67648 - Need to append a CRLF to the end of the last message...
        if (i < m_cParts - 1)
        {
            // Locals
            DWORD cbMsg;

            // Read the last 2 bytes...
            CHECKHR(hr = HrGetStreamSize(pstmMsg, &cbMsg));

            // If greater than 2...
            if (cbMsg > 2)
            {
                // Locals
                BYTE rgCRLF[2];

                // Seek...
                CHECKHR(hr = HrStreamSeekSet(pstmMsg, cbMsg - 2));

                // Read the last two bytes
                CHECKHR(hr = pstmMsg->Read(rgCRLF, 2, NULL));

                // If not a crlf, then write a crlf
                if (rgCRLF[0] != chCR && rgCRLF[1] != chLF)
                {
                    // Write CRLF
                    CHECKHR(hr = pstmMsg->Write(c_szCRLF, 2, NULL));
                }
            }
        }
        
        // Release
        SafeRelease(pstmSource);
        SafeRelease(pRootBody);
    }

    // Rewind message stream..
    CHECKHR(hr = HrRewindStream(pstmMsg));

    // Create a message
    CHECKHR(hr = MimeOleCreateMessage(NULL, &pCombine));

    // Init New
    CHECKHR(hr = pCombine->InitNew());

    // Load the message
    CHECKHR(hr = pCombine->Load(pstmMsg));

    // Any Rejected ?
    if (cRejected)
    {
        // Attach rejected messages
        for (i=0; i<m_cParts; i++)
        {
            // Rejected...
            if (m_prgPart[i].fRejected)
            {
                // Attach body to combined message
                CHECKHR(hr = pCombine->AttachObject(IID_IMimeMessage, m_prgPart[i].pMessage, NULL));
            }
        }
    }

    // Return the new message
    *ppMessage = pCombine;
    (*ppMessage)->AddRef();

    // Debug to temp file...
#ifdef DEBUG
    LPSTREAM pstmFile;
    if (SUCCEEDED(OpenFileStream("d:\\lastcom.txt", CREATE_ALWAYS, GENERIC_WRITE, &pstmFile)))
    {
        HrRewindStream(pstmMsg);
        HrCopyStream(pstmMsg, pstmFile, NULL);
        pstmFile->Commit(STGC_DEFAULT);
        pstmFile->Release();
    }
#endif

exit:
    // Cleanup
    SafeRelease(pstmMsg);
    SafeRelease(pstmSource);
    SafeRelease(pRootBody);
    SafeRelease(pCombine);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::CMimeEnumMessageParts
// --------------------------------------------------------------------------------
CMimeEnumMessageParts::CMimeEnumMessageParts(void)
{
    m_cRef = 1;
    m_iPart = 0;
    m_cParts = 0;
    m_prgPart = NULL;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::~CMimeEnumMessageParts
// --------------------------------------------------------------------------------
CMimeEnumMessageParts::~CMimeEnumMessageParts(void)
{
    ReleaseParts(m_cParts, m_prgPart);
    SafeMemFree(m_prgPart);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeEnumMessageParts == riid)
        *ppv = (IMimeEnumMessageParts *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumMessageParts::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumMessageParts::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Next
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Next(ULONG cWanted, IMimeMessage **prgpMessage, ULONG *pcFetched)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cFetch=1, iPart=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pcFetched)
        *pcFetched = 0;

    // No Internal Formats
    if (NULL == m_prgPart || NULL == prgpMessage)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_cParts - m_iPart);
    if (0 == cFetch)
        goto exit;

    // Copy cWanted
    for (iPart=0; iPart<cFetch; iPart++)
    {
        prgpMessage[iPart] = m_prgPart[m_iPart].pMessage;
        prgpMessage[iPart]->AddRef();
        m_iPart++;
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (cFetch == cWanted) ? S_OK : S_FALSE;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Skip
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Skip(ULONG cSkip)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Can we do it...
    if (((m_iPart + cSkip) >= m_cParts) || NULL == m_prgPart)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Skip
    m_iPart += cSkip;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Reset
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Reset(void)
{
    EnterCriticalSection(&m_cs);
    m_iPart = 0;
    LeaveCriticalSection(&m_cs);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Count
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Count(ULONG *pcCount)
{
    // Invalid Arg
    if (NULL == pcCount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set Count
    *pcCount = m_cParts;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Clone(IMimeEnumMessageParts **ppEnum)
{
    // Locals
    HRESULT         hr=S_OK;
    CMimeEnumMessageParts *pEnum=NULL;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppEnum = NULL;

    // Create the clone.
    pEnum = new CMimeEnumMessageParts;
    if (NULL == pEnum)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Init
    CHECKHR(hr = pEnum->HrInit(m_iPart, m_cParts, m_prgPart));

    // Set Return
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::HrInit
// --------------------------------------------------------------------------------
HRESULT CMimeEnumMessageParts::HrInit(ULONG iPart, ULONG cParts, LPPARTINFO prgPart)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check param
    Assert(m_prgPart == NULL);

    // Empty Enumerator ?
    if (0 == cParts)
    {
        Assert(prgPart == NULL);
        m_cParts = m_iPart = 0;
        goto exit;
    }

    // Allocat an internal array
    CHECKHR(hr = HrAlloc((LPVOID *)&m_prgPart, sizeof(PARTINFO) * cParts));

    // Copy prgPart
    for (i=0; i<cParts; i++)
    {
        CopyMemory(&m_prgPart[i], &prgPart[i], sizeof(PARTINFO));
        Assert(m_prgPart[i].pMessage);
        m_prgPart[i].pMessage->AddRef();
    }

    // Save Size and State
    m_cParts = cParts;
    m_iPart = iPart;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\olealloc.h ===
// --------------------------------------------------------------------------------
// Malloc.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __MALLOC_H
#define __MALLOC_H

// --------------------------------------------------------------------------------
// mimeole.h
// --------------------------------------------------------------------------------
#include "mimeole.h"

// --------------------------------------------------------------------------------
// CMimeAllocator
// --------------------------------------------------------------------------------
class CMimeAllocator : public IMimeAllocator
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeAllocator(void);
    ~CMimeAllocator(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // IMalloc members
    // ---------------------------------------------------------------------------
    STDMETHODIMP_(LPVOID) Alloc(SIZE_T cb); 
    STDMETHODIMP_(LPVOID) Realloc(void *pv, SIZE_T cb);
    STDMETHODIMP_(void)   Free(void * pv);
    STDMETHODIMP_(SIZE_T)  GetSize(void *pv);
    STDMETHODIMP_(int)    DidAlloc(void *pv);
    STDMETHODIMP_(void)   HeapMinimize();

    // ---------------------------------------------------------------------------
    // IMimeAllocator members
    // ---------------------------------------------------------------------------
    STDMETHODIMP ReleaseObjects(ULONG cObjects, IUnknown **prgpUnknown, boolean fFreeArray);
    STDMETHODIMP FreeAddressList(LPADDRESSLIST pList);
    STDMETHODIMP FreeAddressProps(LPADDRESSPROPS pAddress);
    STDMETHODIMP FreeParamInfoArray(ULONG cParams, LPMIMEPARAMINFO prgParam, boolean fFreeArray);
    STDMETHODIMP FreeEnumHeaderRowArray(ULONG cRows, LPENUMHEADERROW prgRow, boolean fFreeArray);
    STDMETHODIMP FreeEnumPropertyArray(ULONG cProps, LPENUMPROPERTY prgProp, boolean fFreeArray);
    STDMETHODIMP FreeThumbprint(THUMBBLOB *pthumbprint);
    STDMETHODIMP PropVariantClear(LPPROPVARIANT pProp);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG m_cRef;     // Reference Counting
};


#endif // __MALLOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\partial.h ===
// --------------------------------------------------------------------------------
// Partial.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __PARTIAL_H
#define __PARTIAL_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "mimeole.h"

// --------------------------------------------------------------------------------
// PARTINFO
// --------------------------------------------------------------------------------
typedef struct tagPARTINFO {
    BYTE                fRejected;      // Rejected in CombineParts
    IMimeMessage       *pMessage;       // The message object...
} PARTINFO, *LPPARTINFO;

// --------------------------------------------------------------------------------
// CMimeMessageParts
// --------------------------------------------------------------------------------
class CMimeMessageParts : public IMimeMessageParts
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeMessageParts(void);
    ~CMimeMessageParts(void);

    // ----------------------------------------------------------------------------
    // IUnknown
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IMimeMessageParts
    // ----------------------------------------------------------------------------
    STDMETHODIMP CombineParts(IMimeMessage **ppMessage);
    STDMETHODIMP AddPart(IMimeMessage *pMessage);
    STDMETHODIMP SetMaxParts(ULONG cParts);
    STDMETHODIMP CountParts(ULONG *pcParts);
    STDMETHODIMP EnumParts(IMimeEnumMessageParts **ppEnum);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
	LONG				m_cRef;			// Reference count
    ULONG               m_cParts;       // Valid elements in m_prgpPart
    ULONG               m_cAlloc;       // Size of m_prgPart
    LPPARTINFO          m_prgPart;      // Array of partinfo structures;
	CRITICAL_SECTION	m_cs;			// Thread safety
};

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts
// --------------------------------------------------------------------------------
class CMimeEnumMessageParts : public IMimeEnumMessageParts
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeEnumMessageParts(void);
    ~CMimeEnumMessageParts(void);

    // ----------------------------------------------------------------------------
    // IUnknown
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IMimeEnumMessageParts
    // ----------------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cParts, IMimeMessage **prgpMessage, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cParts);
    STDMETHODIMP Reset(void); 
    STDMETHODIMP Clone(IMimeEnumMessageParts **ppEnum);
    STDMETHODIMP Count(ULONG *pcParts);

    // ----------------------------------------------------------------------------
    // CMimeEnumMessageParts
    // ----------------------------------------------------------------------------
    HRESULT HrInit(ULONG iPart, ULONG cParts, LPPARTINFO prgPart);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    LONG                m_cRef;         // Reference count
    ULONG               m_iPart;        // Current Part
    ULONG               m_cParts;       // Total number of parts
    LPPARTINFO          m_prgPart;      // Array of parts to enumerate
	CRITICAL_SECTION	m_cs;			// Thread safety
};

#endif // __PARTIAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\olealloc.cpp ===
// --------------------------------------------------------------------------------
// Olealloc.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "olealloc.h"
#include "smime.h"

// --------------------------------------------------------------------------------
// CMimeAllocator::CMimeAllocator
// --------------------------------------------------------------------------------
CMimeAllocator::CMimeAllocator(void)
{
    if (NULL != g_pMoleAlloc)
        DllAddRef();
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::~CMimeAllocator
// --------------------------------------------------------------------------------
CMimeAllocator::~CMimeAllocator(void)
{
    if (this != g_pMoleAlloc)
        DllRelease();
}

// --------------------------------------------------------------------------------
// CMimeAllocator::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimeAllocator *)this;
    else if (IID_IMimeAllocator == riid)
        *ppv = (IMimeAllocator *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeAllocator::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeAllocator::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeAllocator::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::Alloc
// --------------------------------------------------------------------------------
STDMETHODIMP_(LPVOID) CMimeAllocator::Alloc(SIZE_T cb)
{
    // Locals
    LPVOID pv;

    // Do I have a global Allocator
    Assert(g_pMalloc);

    // Allocate it
    pv = g_pMalloc->Alloc(cb);
    if (NULL == pv)
    {
        TrapError(E_OUTOFMEMORY);
        return NULL;
    }

    // Done
    return pv;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::Realloc
// --------------------------------------------------------------------------------
STDMETHODIMP_(LPVOID) CMimeAllocator::Realloc(void *pv, SIZE_T cb)
{
    // Locals
    LPVOID pvNew;

    // Do I have a global Allocator
    Assert(g_pMalloc);

    // Realloc
    pvNew = g_pMalloc->Realloc(pv, cb);
    if (NULL == pvNew)
    {
        TrapError(E_OUTOFMEMORY);
        return NULL;
    }

    // Done
    return pvNew;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::Free
// --------------------------------------------------------------------------------
STDMETHODIMP_(void) CMimeAllocator::Free(void * pv)
{
    // Better have pv
    Assert(pv && g_pMalloc);

    // If Not NULL
    if (pv)
    {
        // Free It
        g_pMalloc->Free(pv);
    }
}

// --------------------------------------------------------------------------------
// CMimeAllocator::GetSize
// --------------------------------------------------------------------------------
STDMETHODIMP_(SIZE_T) CMimeAllocator::GetSize(void *pv)
{
    return g_pMalloc->GetSize(pv);
}

// --------------------------------------------------------------------------------
// CMimeAllocator::DidAlloc
// --------------------------------------------------------------------------------
STDMETHODIMP_(int) CMimeAllocator::DidAlloc(void *pv)
{
    return g_pMalloc->DidAlloc(pv);
}

// --------------------------------------------------------------------------------
// CMimeAllocator::HeapMinimize
// --------------------------------------------------------------------------------
STDMETHODIMP_(void) CMimeAllocator::HeapMinimize(void)
{
    g_pMalloc->HeapMinimize();
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeParamInfoArray
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeParamInfoArray(ULONG cParams, LPMIMEPARAMINFO prgParam, boolean fFreeArray)
{
    // Nothing to Free
    if (0 == cParams || NULL == prgParam)
        return S_OK;

    // Loop
    for (ULONG i=0; i<cParams; i++)
    {
        SafeMemFree(prgParam[i].pszName);
        SafeMemFree(prgParam[i].pszData);
    }

    // Free the Array
    if (fFreeArray)
    {
        SafeMemFree(prgParam);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::ReleaseObjects
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::ReleaseObjects(ULONG cObjects, IUnknown **prgpUnknown, boolean fFreeArray)
{
    // Nothing to Free
    if (0 == cObjects || NULL == prgpUnknown)
        return S_OK;

    // Loop
    for (ULONG i=0; i<cObjects; i++)
    {
        SafeRelease(prgpUnknown[i]);
    }

    // Free Array
    if (fFreeArray)
    {
        SafeMemFree(prgpUnknown);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeHeaderLineArray
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeEnumHeaderRowArray(ULONG cRows, LPENUMHEADERROW prgRow, boolean fFreeArray)
{
    // Nothing to Free
    if (0 == cRows || NULL == prgRow)
        return S_OK;

    // Loop the cells
    for (ULONG i=0; i<cRows; i++)
    {
        SafeMemFree(prgRow[i].pszHeader);
        SafeMemFree(prgRow[i].pszData);
    }

    // Free Array
    if (fFreeArray)
        SafeMemFree(prgRow);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeEnumPropertyArray
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeEnumPropertyArray(ULONG cProps, LPENUMPROPERTY prgProp, boolean fFreeArray)
{
    // Nothing to Free
    if (0 == cProps || NULL == prgProp)
        return S_OK;

    // Loop the cells
    for (ULONG i=0; i<cProps; i++)
        SafeMemFree(prgProp[i].pszName);

    // Free Array
    if (fFreeArray)
        SafeMemFree(prgProp);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeAddressProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeAddressProps(LPADDRESSPROPS pAddress)
{
    // Invalid Arg
    if (NULL == pAddress)
        return TrapError(E_INVALIDARG);

    // IAP_FRIENDLY
    if (ISFLAGSET(pAddress->dwProps, IAP_FRIENDLY) && pAddress->pszFriendly)
        g_pMalloc->Free(pAddress->pszFriendly);

    // IAP_FRIENDLYW
    if (ISFLAGSET(pAddress->dwProps, IAP_FRIENDLYW) && pAddress->pszFriendlyW)
        g_pMalloc->Free(pAddress->pszFriendlyW);

    // IAP_EMAIL
    if (ISFLAGSET(pAddress->dwProps, IAP_EMAIL) && pAddress->pszEmail)
        g_pMalloc->Free(pAddress->pszEmail);

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pAddress->dwProps, IAP_SIGNING_PRINT) && pAddress->tbSigning.pBlobData)
        g_pMalloc->Free(pAddress->tbSigning.pBlobData);

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pAddress->dwProps, IAP_ENCRYPTION_PRINT) && pAddress->tbEncryption.pBlobData)
        g_pMalloc->Free(pAddress->tbEncryption.pBlobData);

    // No legal props
    ZeroMemory(pAddress, sizeof(ADDRESSPROPS));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeAddressList
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeAddressList(LPADDRESSLIST pList)
{
    // Invalid Arg
    if (NULL == pList || (pList->cAdrs > 0 && NULL == pList->prgAdr))
        return TrapError(E_INVALIDARG);

    // Free Each Item
    for (ULONG i=0; i<pList->cAdrs; i++)
        FreeAddressProps(&pList->prgAdr[i]);

    // Free the list
    SafeMemFree(pList->prgAdr);

    // Zero It
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::PropVariantClear
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::PropVariantClear(LPPROPVARIANT pProp)
{
    return MimeOleVariantFree(pProp);
}

// ---------------------------------------------------------------------------
// CMimeAllocator::FreeThumbprint
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeThumbprint(THUMBBLOB *pthumbprint)
{
    if (pthumbprint->pBlobData)
        {
        Assert(0 != g_pMalloc->DidAlloc(pthumbprint->pBlobData));
        MemFree(pthumbprint->pBlobData);
        }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\objpool.h ===
#ifndef __OBJPOOL_INC
#define __OBJPOOL_INC

// --------------------------------------------------------------------------------
// ObjPool.h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Don Dumitru (dondu@microsoft.com)
// --------------------------------------------------------------------------------

/*
    Typical usage of this set of templates is like this:

    Say you want to provide a pool of structs of type PROPERTY.  You
    would first define the allocator class that you want to use for
    allocating those structs - if you wanted to use operator new and
    operator delete, you would do this...
        typedef CAllocObjWithNew<PROPERTY> PROPERTY_ALLOCATOR;
    Now, you can define a pool of PROPERTY structs, using that allocator
    class, by doing this...
        typedef CAutoObjPool<PROPERTY,offsetof(PROPERTY,pNext),PROPERTY_ALLOCATOR> PROPERTY_POOL;
    and then declare instances of the PROPERTY pool by doing this...
        PROPERTY_POOL g_PropPool;

    If you want to use a different allocator, just change the definition of
    the PROPERTY_ALLOCATOR typedef - templates for using operator new and
    operator delete, or for using an instance of interface IMalloc are
    provided.  Or you can implement your own allocator class using
    whatever mechanism you want.

    If for some reason you can't use the provided auto-allocator mechanism
    in CAutoObjPool<> (maybe you need to pass parameters to the constructor
    or somesuch - although you might be able to solve that by how you define
    the allocator class...), you can implement your own version of
    CAutoObjPool<> which does it the way you want.

    One feature of this set of templates is the ability to adjust the size
    of the pool.  This would let you, for example, adjust the pool size up
    as container objects were allocated, and adjust it back down as those
    container objects were freed.  This would let the pool be sized based
    on how many container objects were being held by the application - so
    the overall caching strategy of the subsystem would be responsive to
    how the top-level objects were being cached by the application.
*/

//#include <stdarg.h>

// Since InterlockedExchangeAdd is not available on Win95, we'll just
// disable all of this stats stuff...
#if 0
class CPoolStatsDebug {
    public:
        CPoolStatsDebug() {
            m_lTotalAllocs = 0;
            m_lFailedAllocs = 0;
            m_lTotalAllocOverhead = 0;
            m_lTotalFrees = 0;
            m_lFailedFrees = 0;
            m_lTotalFreeOverhead = 0;
        };
        void AllocSuccess(DWORD dwOverhead) {
            InterlockedIncrement(&m_lTotalAllocs);
            InterlockedExchangeAdd(&m_lTotalAllocOverhead,dwOverhead);
        };
        void AllocFail() {
            InterlockedIncrement(&m_lTotalAllocs);
            InterlockedIncrement(&m_lFailedAllocs);
        };
        void FreeSuccess(DWORD dwOverhead) {
            InterlockedIncrement(&m_lTotalFrees);
            InterlockedExchangeAdd(&m_lTotalFreeOverhead,dwOverhead);
        };
        void FreeFail() {
            InterlockedIncrement(&m_lTotalFrees);
            InterlockedIncrement(&m_lFailedFrees);
        };
        void Dump() {
            DbgPrintF("Object Pool Stats:\r\n");
            DbgPrintF("  Total Allocs - %u\r\n",m_lTotalAllocs);
            DbgPrintF("  Failed Allocs - %u\r\n",m_lFailedAllocs);
            DbgPrintF("  Total Alloc Overhead - %u\r\n",m_lTotalAllocOverhead);
            if (m_lTotalAllocs-m_lFailedAllocs) {
                DbgPrintF("  Average Alloc Overhead - %u\r\n",m_lTotalAllocOverhead/(m_lTotalAllocs-m_lFailedAllocs));
            }
            DbgPrintF("  Total Frees - %u\r\n",m_lTotalFrees);
            DbgPrintF("  Failed Frees - %u\r\n",m_lFailedFrees);
            DbgPrintF("  Total Free Overhead - %u\r\n",m_lTotalFreeOverhead);
            if (m_lTotalFrees-m_lFailedFrees) {
                DbgPrintF("  Average Free Overhead - %u\r\n",m_lTotalFreeOverhead/(m_lTotalFrees-m_lFailedFrees));
            }
        };
    private:
        static void DbgPrintF(LPCSTR pszFmt, ...)
        {
            char szOutput[512];
            va_list val;

            va_start(val,pszFmt);
            wvnsprintfA(szOutput, ARRAYSIZE(szOutput), pszFmt,val);
            va_end(val);
            OutputDebugStringA(szOutput);
        };
        long m_lTotalAllocs;
        long m_lFailedAllocs;
        long m_lTotalAllocOverhead;
        long m_lTotalFrees;
        long m_lFailedFrees;
        long m_lTotalFreeOverhead;
};
#endif

class CPoolStatsRetail {
    public:
        static void AllocSuccess(DWORD) {
        };
        static void AllocFail() {
        };
        static void FreeSuccess(DWORD) {
        };
        static void FreeFail() {
        };
        static void Dump() {
        };
};

#if 0
#ifdef DEBUG
    typedef CPoolStatsDebug CPoolStats;
#else
    typedef CPoolStatsRetail CPoolStats;
#endif
#else
typedef CPoolStatsRetail CPoolStats;
#endif

// This class provides the base implementation of the object pool operations.
// Basically, this class implements everything that doesn't depend in any way
// on the type of the object being pooled.  By doing a base class for all of
// these methods, we minimize the number of instances of these methods which
// will be generated by the compiler (since these particular methods are not
// dependent on the template parameters, we only need to have one version of
// them).
//
// This class' locking is based on critical sections.  On multi-proc machines
// you can get much better contention behavior by keeping the length of time
// that you hold critical sections at an absolute minimum, and by using the
// InitializeCriticalSectionAndSpinCount function (provided by NT4.sp3).  This
// class does this - and since the function is not available on older versions
// of NT, or on Win95, this class uses LoadLibrary/GetProcAddress to attempt
// to call the new function, and it falls back on InitializeCriticalSection
// if the new function is not available.
class CObjPoolImplBase : public CPoolStats
{
    private:
        typedef BOOL (WINAPI *PFN_ICSASC)(LPCRITICAL_SECTION,DWORD);
    public:
        void Init(DWORD dwMax)
        {
            HMODULE hmod;
            PFN_ICSASC pfn = NULL;

            m_pvList = NULL;
            m_lCount = 0;
            m_lMax = dwMax;
            // WARNING!  This Init() method might be called from within
            // DllEntryPoint - which means that calling LoadLibrary is
            // a Bad Idea.  But, we know that kernel32.dll is always
            // loaded already, so it happens to be safe in this one
            // instance...
            hmod = LoadLibrary("kernel32.dll");
            if (hmod)
            {
                pfn = (PFN_ICSASC) GetProcAddress(hmod,"InitializeCriticalSectionAndSpinCount");
            }
            if (!pfn || !pfn(&m_cs,4000))
            {
                // Either we didn't get the function pointer, or
                // the function failed - either way, fall-back to
                // using a normal critsec.
                InitializeCriticalSection(&m_cs);
            }
            if (hmod)
            {
                FreeLibrary(hmod);
            }
        };
        LPVOID Term()
        {
            LPVOID pvResult;

            Assert(m_lCount>=0);
            EnterCriticalSection(&m_cs);
            pvResult = m_pvList;
            m_pvList = NULL;
            m_lCount = 0;
            m_lMax = 0;
            LeaveCriticalSection(&m_cs);
            DeleteCriticalSection(&m_cs);
            Dump();
            return (pvResult);
        };
        void GrowPool(DWORD dwGrowBy)
        {
            EnterCriticalSection(&m_cs);
            m_lMax += dwGrowBy;
            LeaveCriticalSection(&m_cs);
            Assert(m_lMax>=0);
        };
        LPVOID GetAll() {
            LPVOID pvObject;

            EnterCriticalSection(&m_cs);
            pvObject = m_pvList;
            m_pvList = NULL;
            m_lCount = 0;
            LeaveCriticalSection(&m_cs);
            return (pvObject);
        };
    protected:
        volatile LPVOID m_pvList;
        volatile LONG m_lCount;
        volatile LONG m_lMax;
        CRITICAL_SECTION m_cs;
};

// This template class inherits from the base class, and adds all of the
// things which depend on the offset of the "next" field in the objects
// being pooled.  The compiler will instantiate a version of this template
// class for each object pool which has the "next" field at a different
// offset within the pooled objects.
template <DWORD dwNextLinkOffset>
class CObjPoolImpl : public CObjPoolImplBase
{
    public:
        LPVOID GetFromPool()
        {
            LPVOID pvResult = NULL;

            Assert(m_lCount>=0);
            EnterCriticalSection(&m_cs);
            Assert(!m_pvList||(m_lCount>0));
            if (m_pvList)
            {
                pvResult = m_pvList;
                m_pvList = *off(m_pvList);
                *off(pvResult) = NULL;
                m_lCount--;
                AllocSuccess(m_lMax-m_lCount);
            } else {
                AllocFail();
            }
            LeaveCriticalSection(&m_cs);
            return (pvResult);
        };
        BOOL AddToPool(LPVOID pvObject)
        {
            BOOL bResult = FALSE;

            Assert((m_lCount>=0)&&(m_lCount<=m_lMax));
            EnterCriticalSection(&m_cs);
            if (m_lCount < m_lMax)
            {
                *off(pvObject) = m_pvList;
                m_pvList = pvObject;
                m_lCount++;
                bResult = TRUE;
                FreeSuccess(m_lMax-m_lCount);
            } else {
                FreeFail();
            }
            LeaveCriticalSection(&m_cs);
            return (bResult);
        };
        LPVOID ShrinkPool(DWORD dwShrinkBy)
        {
            LPVOID pvResult = NULL;
            DWORD dwCount;

            Assert((m_lCount>=0)&&(m_lCount<=m_lMax));
            Assert((DWORD) m_lMax>=dwShrinkBy);
            EnterCriticalSection(&m_cs);
            m_lMax -= dwShrinkBy;
            while (m_lCount > m_lMax)
            {
                LPVOID pvTmp;

                pvTmp = m_pvList;
                m_pvList = *off(m_pvList);
                *off(pvTmp) = pvResult;
                pvResult = pvTmp;
                m_lCount--;
            }
            LeaveCriticalSection(&m_cs);
            return (pvResult);
        };
        static LPVOID *off(LPVOID pvObject)
        {
            return ((LPVOID *) (((LPBYTE) pvObject)+dwNextLinkOffset));
        };
};

// This template class just wraps the CObjPoolImpl<> template class
// with type conversion for the actual object type being pooled - it
// hides the fact that the underlying implementation is dealing with
// void pointers.  The compiler will instantiate a version of this
// template for each different type of object being pooled.  However,
// since all of the methods of this template class are doing trivial
// type casting, this template class shouldn't actually cause any code
// to be generated.
template <class T, DWORD dwNextLinkOffset, class A>
class CObjPool : public CObjPoolImpl<dwNextLinkOffset>
{
    private:
        typedef CObjPoolImpl<dwNextLinkOffset> O;
    public:
        T *Term()
        {
            return ((T *) O::Term());
        };
        T *GetFromPool()
        {
            return ((T *) O::GetFromPool());
        };
        BOOL AddToPool(T *pObject)
        {
            A::CleanObject(pObject);
            return (O::AddToPool(pObject));
        };
        void GrowPool(DWORD dwGrowBy)
        {
            O::GrowPool(dwGrowBy);
        };
        T *ShrinkPool(DWORD dwShrinkBy)
        {
            return ((T *) O::ShrinkPool(dwShrinkBy));
        };
        T *GetAll() {
            return ((T *) O::GetAll());
        };
        static T **off(T *pObject)
        {
            return ((T ** ) O::off(pObject));
        };
};

// This template class provides multi-proc scalability for
// a pool, by creating up to eight sub-pools - the actual
// number of sub-pools is equal to the number of processors
// on the machine, and the objects are evenly distributed
// between the sub-pools.
template <class T, DWORD dwNextLinkOffset, class O>
class CObjPoolMultiBase
{
    public:
        void Init(DWORD dwMax)
        {
            SYSTEM_INFO siInfo;
            DWORD dwIdx;

            m_dwNext = 0;
            GetSystemInfo(&siInfo);
            m_dwMax = siInfo.dwNumberOfProcessors;
            if (m_dwMax < 1) {
                m_dwMax = 1;
            }
            if (m_dwMax > sizeof(m_abPool)/sizeof(m_abPool[0])) {
                m_dwMax = sizeof(m_abPool)/sizeof(m_abPool[0]);
            }
            for (dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                m_abPool[dwIdx].Init(Calc(dwMax));
            }
        };
        T *Term() {
            T *pObject = NULL;
            T **ppLast = &pObject;
            DWORD dwIdx;

            for (dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                *ppLast = m_abPool[dwIdx].Term();
                while (*ppLast) {
                    ppLast = off(*ppLast);
                }
            }
            return (pObject);
        };
        T *GetFromPool() {
            return (m_abPool[PickNext()].GetFromPool());
        };
        BOOL AddToPool(T* pObject) {
            return (m_abPool[PickNext()].AddToPool(pObject));
        };
        void GrowPool(DWORD dwGrowBy) {
            for (DWORD dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                m_abPool[dwIdx].GrowPool(Calc(dwGrowBy));
            }
        };
        T *ShrinkPool(DWORD dwShrinkBy) {
            T *pObject = NULL;
            T **ppLast = &pObject;
            DWORD dwIdx;

            for (dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                *ppLast = m_abPool[dwIdx].ShrinkPool(Calc(dwGrowBy));
                while (*ppLast) {
                    ppLast = off(*ppLast);
                }
            }
            return (pObject);
        };
        T *GetAll() {
            T *pObject = NULL;
            T **ppLast = &pObject;
            DWORD dwIdx;

            for (dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                *ppLast = m_abPool[dwIdx].GetAll();
                while (*ppLast) {
                    ppLast = off(*ppLast);
                }
            }
            return (pObject);
        };
        static T **off(T* pObject) {
            return (O::off(pObject));
        };
    private:
        DWORD Calc(DWORD dwInput) {
            return ((dwInput+m_dwMax-1)/m_dwMax);
        };
        DWORD PickNext() {
            return (((DWORD) InterlockedIncrement((LONG *) &m_dwNext)) % m_dwMax);
        };
        O m_abPool[8];
        DWORD m_dwMax;
        DWORD m_dwNext;
};

// This template class implements a pool object with automatic
// allocation and freeing of objects.  It does this by taking
// an "allocator" class as a template parameter, and using
// methods on that allocator class to perform the allocation
// and freeing of the objects.
template <class T, DWORD dwNextLinkOffset, class A>
class CAutoObjPool : public CObjPool<T,dwNextLinkOffset,A>
{
    private:
        typedef CObjPool<T,dwNextLinkOffset,A> O;
    public:
        T *Term()
        {
            A::FreeList(O::Term());
            return (NULL);
        };
        T *GetFromPool()
        {
            T *pObject = O::GetFromPool();
            if (!pObject)
            {
                pObject = A::AllocObject();
            }
            return (pObject);
        };
        BOOL AddToPool(T *pObject)
        {
            if (!O::AddToPool(pObject))
            {
                A::FreeObject(pObject);
            }
            return (TRUE);
        };
        T *ShrinkPool(DWORD dwShrinkBy)
        {
            A::FreeList(O::ShrinkPool(dwShrinkBy));
            return (NULL);
        };
};

// This template class provides a multi-proc pool without automatic allocation.
template <class T, DWORD dwNextLinkOffset, class A>
class CObjPoolMulti : public CObjPoolMultiBase<T,dwNextLinkOffset,CObjPool<T,dwNextLinkOffset,A> >
{
    // nothing
};

// The template class provides a multi-proc pool with automatic allocation.
template <class T, DWORD dwNextLinkOffset, class A>
class CAutoObjPoolMulti : public CObjPoolMultiBase<T,dwNextLinkOffset,CAutoObjPool<T,dwNextLinkOffset,A> >
{
    // nothing
};

// This template class provides a base implementation for allocator classes.
template <class T, DWORD dwNextLinkOffset>
class CAllocObjBase
{
    public:
        static void InitObject(T *pObject) {
            memset(pObject,0,sizeof(*pObject));
        };
        static void CleanObject(T *pObject) {
            memset(pObject,0,sizeof(*pObject));
        };
        static void TermObject(T *pObject) {
            // memset(pObject,0xfe,sizeof(*pObject));
        };
        static T **Off(T *pObject) {
            return (T **) (((LPBYTE) pObject)+dwNextLinkOffset);
        };
};

// This template class provides a base implementation for allocator classes
// which use new and delete.
template <class T, class O>
class CAllocObjWithNewBase
{
    public:
        static T *AllocObject()
        {
            T *pObject = new T;
            if (pObject) {
                O::InitObject(pObject);
            }
            return (pObject);
        };
        static void FreeObject(T *pObject)
        {
            if (pObject) {
                O::TermObject(pObject);
            }
            delete pObject;
        };
    static void FreeList(T *pObject) {
        while (pObject) {
            T *pNext;

            pNext = *O::Off(pObject);
            FreeObject(pObject);
            pObject = pNext;
        }
    };
};

// This template class provides an allocator using operator
// new and operator delete.
template <class T, DWORD dwNextLinkOffset>
class CAllocObjWithNew :
    public CAllocObjBase<T,dwNextLinkOffset>,
    public CAllocObjWithNewBase<T,CAllocObjBase<T,dwNextLinkOffset> >
{
    // nothing
};

// This template class provides a base implementation for allocator classes
// which use an instance of IMalloc.
template <class T, class O>
class CAllocObjWithIMallocBase
{
    public:
        static T *AllocObject()
        {
            T *pObject = (T *) g_pMalloc->Alloc(sizeof(T));
            if (pObject) {
                O::InitObject(pObject);
            }
            return (pObject);
        };
        static void FreeObject(T *pObject)
        {
            if (pObject) {
                O::TermObject(pObject);
            }
            g_pMalloc->Free(pObject);
        }
        static void FreeList(T *pObject) {
            while (pObject) {
                T *pNext;

                pNext = *O::Off(pObject);
                FreeObject(pObject);
                pObject = pNext;
            }
        };
};

// This template class provides an allocator using an
// instance of the IMalloc interface.
template <class T, DWORD dwNextLinkOffset>
class CAllocObjWithIMalloc :
    public CAllocObjBase<T,dwNextLinkOffset>,
    public CAllocObjWithIMallocBase<T, CAllocObjBase<T,dwNextLinkOffset> >
{
    // nothing
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\rfc1522.cpp ===
// --------------------------------------------------------------------------------
// rfc1522.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "internat.h"
#include "dllmain.h"
#include "inetconv.h"
#include "strconst.h"
#include "variantx.h"
#include "mimeapi.h"
#include "demand.h"
#include "shlwapi.h"

// --------------------------------------------------------------------------------
// ISQPESCAPE(_ch)
// --------------------------------------------------------------------------------
#define ISQPESCAPE(_ch) \
    (IS_EXTENDED(_ch) || _ch == '?' || _ch == '=' || \
                        _ch == '_' || _ch == '"' || \
                        _ch == '<' || _ch == '>' || \
                        _ch == '(' || _ch == ')' || \
                        _ch == '[' || _ch == ']' || \
                        _ch == ',')

// --------------------------------------------------------------------------------
// RFC1522OUT
// --------------------------------------------------------------------------------
typedef struct tagRFC1522OUT {
    BOOL            fWrite;
    CHAR            szBuffer[512];
    ULONG           iBuffer;
    LPSTREAM        pstm;
} RFC1522OUT, *LPRFC1522OUT;

// --------------------------------------------------------------------------------
// HrRfc1522WriteDone
// --------------------------------------------------------------------------------
HRESULT HrRfc1522WriteDone(LPRFC1522OUT pOut, LPSTR *ppszRfc1522)
{
    // We better be writing
    Assert(pOut->fWrite && ppszRfc1522);

    // Init
    *ppszRfc1522 = NULL;

    // If we haven't created the stream yet, just use the buffer...
    if (NULL == pOut->pstm)
    {
        // No data
        if (0 == pOut->iBuffer)
            return S_OK;

        // Allocate
        *ppszRfc1522 = PszAllocA(pOut->iBuffer + 1);
        if (NULL == *ppszRfc1522)
            return TrapError(E_OUTOFMEMORY); 

        // Copy data
        CopyMemory(*ppszRfc1522, pOut->szBuffer, pOut->iBuffer);

        // Null term
        *((*ppszRfc1522) + pOut->iBuffer) = '\0';
    }

    // Otherwise, do stream
    else
    {
        // Commit final data to stream...
        if (0 != pOut->iBuffer)
        {
            if (FAILED(pOut->pstm->Write(pOut->szBuffer, pOut->iBuffer, NULL)))
                return TrapError(E_OUTOFMEMORY); 
        }

        // Commit the stream
        if (FAILED(pOut->pstm->Commit(STGC_DEFAULT)))
            return TrapError(E_OUTOFMEMORY); 

        // Convert the stream to an ANSI string
        *ppszRfc1522 = PszFromANSIStreamA(pOut->pstm);
        Assert(NULL != *ppszRfc1522);

        // Release the stream
        SafeRelease(pOut->pstm);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// HrRfc1522Write
// --------------------------------------------------------------------------------
HRESULT HrRfc1522Write(LPRFC1522OUT pOut, UCHAR ch)
{
    // If not saving data..
    if (!pOut->fWrite)
        return S_OK;

    // If buffer + 1 is full, dump to stream
    if (pOut->iBuffer + 1 > sizeof(pOut->szBuffer))
    {
        // Do I have a stream yet...
        if (NULL == pOut->pstm)
        {
            // Create stream
            if (FAILED(MimeOleCreateVirtualStream(&pOut->pstm)))
                return TrapError(E_OUTOFMEMORY);
        }

        // Write buffer to the stream
        if (FAILED(pOut->pstm->Write(pOut->szBuffer, pOut->iBuffer, NULL)))
            return TrapError(E_OUTOFMEMORY); 

        // Reset buffers
        pOut->iBuffer = 0;
    }

    // Add character to the buffer
    pOut->szBuffer[pOut->iBuffer++] = ch;

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// HrRfc1522WriteStr
// --------------------------------------------------------------------------------
HRESULT HrRfc1522WriteStr(LPRFC1522OUT pOut, LPSTR psz, LONG cb)
{
    HRESULT hr;
    while(cb)
    {
        hr = HrRfc1522Write(pOut, *psz);
        if (FAILED(hr))
            return hr;
        psz++;
        cb--;
    }

    return S_OK;
}

inline BOOL IsRfc1522Token(UCHAR ch)
{
                        //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    static UINT abToken[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	// 000-031
                             1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,	// 032-063
                             0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,	// 064-095
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	// 096-127
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	// 128-159
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	// 160-191
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	// 192-223
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};	// 224-255

    Assert(sizeof(abToken)/sizeof(abToken[1])==256);
    Assert(abToken['(']==FALSE);
    Assert(abToken[')']==FALSE);
    Assert(abToken['<']==FALSE);
    Assert(abToken['>']==FALSE);
    Assert(abToken['@']==FALSE);
    Assert(abToken[',']==FALSE);
    Assert(abToken[';']==FALSE);
    Assert(abToken[':']==FALSE);
    Assert(abToken['/']==FALSE);
    Assert(abToken['[']==FALSE);
    Assert(abToken[']']==FALSE);
    Assert(abToken['?']==FALSE);
    Assert(abToken['.']==FALSE);
    Assert(abToken['=']==FALSE);

    return (BOOL) abToken[ch];
}


// --------------------------------------------------------------------------------
// PszRfc1522Find
//
// Find an RFC1522 word.  If the string pointer passed in is NULL, then NULL is
// returned.  If a word is not found, then a pointer to the terminatng NULL is
// returned.  If a word is found, then a pointer to the word is returned, and
// an output parameter for whether the word was preceeded by non-blank characters
// is set.
//
// If a word is not found, then the output parameter is undefined.
//
// The output parameter is optional - it may be NULL, in which case the value
// will not be stored.
//
// --------------------------------------------------------------------------------
LPSTR PszRfc1522Find(LPSTR psz,
                     BOOL *pbNonBlankLeading)
{
    LPSTR pszCharset;

    if (!psz || !*psz)
    {
        goto exit;
    }

    if (pbNonBlankLeading)
    {
        *pbNonBlankLeading = FALSE;
    }

    // Skip over any leading blanks.
    while (*psz && (*psz == ' ' || *psz == '\t' || *psz == '\r' || *psz == '\n'))
    {
        psz++;
    }

    if (*psz && (psz[0] != '=' || psz[1] != '?'))
    {
again:
        // If we end up here (either through the if above or by a goto from below),
        // it means that we have some number of non-blank characters before the
        // RFC1522 word.
        if (pbNonBlankLeading)
        {
            *pbNonBlankLeading = TRUE;
        }
    }
    // Skip until we find an =?.
    while (*psz && (psz[0] != '=' || psz[1] != '?'))
    {
        psz++;
    }
    if (!*psz)
    {
        // End of the string.
        goto exit;
    }
    Assert(psz[0] == '=' && psz[1] == '?');

    // Parse out the charset.
    pszCharset = psz;
    psz += 2;
    while (IsRfc1522Token(*psz))
    {
        psz++;
    }
    if (!*psz)
    {
        // End of the string.
        goto exit;
    }
    if (*psz != '?')
    {
        // Malformed.
        goto again;
    }
    Assert(*psz == '?');

    // Parse out the encoding.
    psz++;
    while (IsRfc1522Token(*psz))
    {
        psz++;
    }
    if (!*psz)
    {
        // End of the string.
        goto exit;
    }
    if (*psz != '?')
    {
        // Malformed.
        goto again;
    }
    Assert(*psz == '?');

    // Parse out the data.
    psz++;
    while (*psz && (psz[0] != '?' || psz[1] != '='))
    {
        psz++;
    }
    if (!*psz)
    {
        // End of the string.
        goto exit;
    }
    Assert(psz[0] == '?' && psz[1] == '=');

    psz = pszCharset;

exit:
    return psz;
}

// --------------------------------------------------------------------------------
// PszRfc1522Decode - *(*ppsz) -> '?'
// --------------------------------------------------------------------------------
LPSTR PszRfc1522Decode(LPSTR psz, CHAR chEncoding, LPRFC1522OUT pOut)
{
    // Check params
    Assert(pOut && psz && *psz == '?');
    Assert(chEncoding == 'B' || chEncoding == 'b' || chEncoding == 'Q' || chEncoding == 'q');

    // Step over '?'
    psz++;

    // Done...
    if ('\0' == *psz)
        return psz;

    // Q encoding
    if ('Q' == chEncoding || 'q' == chEncoding)
    {
        // Locals
        UCHAR   uch;
        CHAR    ch,
                ch1,
                ch2;
        LPSTR   pszMark;

        // While we have characters and '?=' is not found...
        while(*psz && (psz[0] != '?' || psz[1] != '='))
        {
            // Get next char
            uch = *psz++;

            // Encoded hex pair i.e. '=1d'
            if (uch == '=')
            {
                // Mark position
                pszMark = psz;

                // Hex char 1 - If no null...
                if (*psz != '\0') ch1 = ChConvertFromHex (*psz++);
                else ch1 = (char)255;

                // Hex char 2 - if no null
                if (*psz != '\0') ch2 = ChConvertFromHex (*psz++);
                else ch2 = (char)255;
                
                //////////////////////////////////////////////////////////////////
                // raid x5-69640 - Incomplete QP encoded letter causes 
                // This is a sign-extension bug - we need to compare against
                // (char)255 instead of 255...
                //
                // If both are = 255, its an equal sign
                if (ch1 == (char)255 || ch2 == (char)255)
                //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                {
                    if (FAILED(HrRfc1522Write(pOut, '=')))
                        return NULL;
                    psz = pszMark;
                }

                // Otherwise, build character
                else
                {
                    ch = ( ch1 << 4 ) | ch2;
                    if (FAILED(HrRfc1522Write(pOut, ch)))
                        return NULL;
                }
            }

            // _ equals space...
            else if( uch == '_' )
            {
                if (FAILED(HrRfc1522Write(pOut, ' ')))
                    return NULL;
            }

            // Otherwise, just append the character
            else
            {
                if (FAILED(HrRfc1522Write(pOut, uch)))
                    return NULL;
            }
        }
    }

    // B encoding
    else
    {
        // Locals
        ULONG  cbIn=0,
               cbPad=0;
        UCHAR  ucIn[4], 
               uch;

        // While we have characters and '?=' is not found...
        while(*psz && (psz[0] != '?' || psz[1] != '='))
        {
            // Gets 4 legal Base64 characters, ignores if illegal
            uch = *psz++;

            // Decode base64 character
            ucIn[cbIn] = DECODE64(uch) ;

            // Inc count
            if (ucIn[cbIn] < 64 || (uch == '=' && cbIn > 1))
                cbIn++;

            // Pad it
            if (uch == '=' && cbIn > 1)
                cbPad++;

            // Outputs when 4 legal Base64 characters are in the buffer
            if (cbIn == 4)
            {
                if (cbPad < 3) 
                {
                    if (FAILED(HrRfc1522Write(pOut, (ucIn[0] << 2) | (ucIn[1] >> 4))))
                        return NULL;
                }
                if (cbPad < 2) 
                {
                    if (FAILED(HrRfc1522Write(pOut, (ucIn[1] << 4) | (ucIn[2] >> 2))))
                        return NULL;
                }
                if (cbPad < 1) 
                {
                    if (FAILED(HrRfc1522Write(pOut, (ucIn[2] << 6) | (ucIn[3]))))
                        return NULL;
                }
                cbIn = 0;
            }
        }
    }

    // Finish stepping
    if ('?' == *psz)
        psz++;
    if ('=' == *psz)
        psz++;

    // Done
    return psz;
}

// --------------------------------------------------------------------------------
// PszRfc1522GetEncoding - *(*ppsz) -> '?'
//
// Returns NULL if '?X?' is not found... or B b Q q is not found
// --------------------------------------------------------------------------------
LPSTR PszRfc1522GetEncoding(LPSTR psz, CHAR *pchEncoding)
{
    // Done
    if ('\0' == *psz)
        return NULL;

    // Should be pointing to '='
    if ('?' != *psz)
        return NULL;

    // Next character
    psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Save encoding...
    *pchEncoding = *psz;

    // Step over encoding character
    psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Should be pointing to '='
    if ('?' != *psz)
        return NULL;

    // Invalid encoding
    if ('B' != *pchEncoding && 'b' != *pchEncoding && 'Q' != *pchEncoding && 'q' != *pchEncoding)
        return NULL;

    // Continue
    return psz;
}

// --------------------------------------------------------------------------------
// PszRfc1522GetCset - *(*ppsz) -> '='
//
// Returns NULL if '=?CHARSET?' is not found
// --------------------------------------------------------------------------------
LPSTR PszRfc1522GetCset(LPSTR psz, LPSTR pszCharset, ULONG cchmax)
{
    // Locals
    LPSTR   pszStart, pszEnd;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Should be pointing to '='
    if ('=' != *psz)
        return NULL;

    // Next character
    psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Should be pointing to '?'
    if ('?' != *psz)
        return NULL;

    // Step over '?'
    psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Save Start
    pszStart = psz;

    // Seek to next '?'
    while(*psz && *psz != '?')
        psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Save end
    pszEnd = psz;
    Assert(*pszEnd == '?');

    // Charset name is too large...
    if ((ULONG)(pszEnd - pszStart) > cchmax)
        return NULL;

    // Copy charset
    *pszEnd = '\0';
    StrCpyNA(pszCharset, pszStart, cchmax);
    *pszEnd = '?';

    // Continue
    return psz;
}

// --------------------------------------------------------------------------------
// HrRfc1522EncodeBase64
// --------------------------------------------------------------------------------
HRESULT HrRfc1522EncodeBase64(UCHAR *pb, ULONG cb, LPSTREAM pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    BYTE            rgbEncoded[1024];
    ULONG           cbEncoded=0;
    ULONG           i;
    UCHAR           uch[3];

    // Encodes 3 characters at a time
    for (i=0; i<cb; i+=3)
    {
        // Setup Buffer
        uch[0] = pb[i];
        uch[1] = (i + 1 < cb) ? pb[i + 1] : '\0';
        uch[2] = (i + 2 < cb) ? pb[i + 2] : '\0';

        // Encode first tow
        rgbEncoded[cbEncoded++] = g_rgchEncodeBase64[(uch[0] >> 2) & 0x3F];
        rgbEncoded[cbEncoded++] = g_rgchEncodeBase64[(uch[0] << 4 | uch[1] >> 4) & 0x3F];

        // Encode Next
        if (i + 1 < cb)
            rgbEncoded[cbEncoded++] = g_rgchEncodeBase64[(uch[1] << 2 | uch[2] >> 6) & 0x3F];
        else
            rgbEncoded[cbEncoded++] = '=';

        // Encode Net
        if (i + 2 < cb)
            rgbEncoded[cbEncoded++] = g_rgchEncodeBase64[(uch[2]) & 0x3F];
        else
            rgbEncoded[cbEncoded++] = '=';
    }

    // Write rgbEncoded
    CHECKHR(hr = pStream->Write(rgbEncoded, cbEncoded, NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrRfc1522EncodeQP
// --------------------------------------------------------------------------------
HRESULT HrRfc1522EncodeQP(UCHAR *pb, ULONG cb, LPSTREAM pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    BYTE        rgbEncoded[1024];
    ULONG       cbEncoded=0;
    ULONG       i;

    // Loop through buffer
    for (i=0; i<cb; i++)
    {
        // Replace spaces with underscore - this is a more portable character
        if (pb[i] == ' ')
            rgbEncoded[cbEncoded++] = '_';

        // Otherwise, if this is an escapeable character
        else if (ISQPESCAPE(pb[i]))
        {
            // Write equal sign (start of an encodedn QP character
            rgbEncoded[cbEncoded++] = '=';
            rgbEncoded[cbEncoded++] = g_rgchHex[pb[i] >> 4];
            rgbEncoded[cbEncoded++] = g_rgchHex[pb[i] & 0x0F];
        }

        // Otherwise, just write the char as is
        else
            rgbEncoded[cbEncoded++] = pb[i];
    }

    // Write rgbEncoded
    CHECKHR(hr = pStream->Write(rgbEncoded, cbEncoded, NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// FContainsExtended
// --------------------------------------------------------------------------------
BOOL FContainsExtended(LPPROPSTRINGA pStringA, ULONG *pcExtended)
{
    // Invalid Arg
    Assert(ISVALIDSTRINGA(pStringA) && pcExtended);

    // Init
    *pcExtended = 0;

    // Look for an extended character
    for (ULONG cch=0; cch<pStringA->cchVal; cch++)
    {
        // Is this an extended char
        if (IS_EXTENDED(pStringA->pszVal[cch]))
        {
            // Count
            (*pcExtended)++;
        }
    }

    // Done
    return ((*pcExtended) > 0) ? TRUE : FALSE;
}

#define IS_EXTENDED_W(wch) \
    ((wch > 126 || wch < 32) && wch != L'\t' && wch != L'\n' && wch != L'\r')

// --------------------------------------------------------------------------------
// FContainsExtendedW
// --------------------------------------------------------------------------------
BOOL FContainsExtendedW(LPPROPSTRINGW pStringW, ULONG *pcExtended)
{
    // Invalid Arg
    Assert(ISVALIDSTRINGW(pStringW) && pcExtended);

    // Init
    *pcExtended = 0;

    // Look for an extended character
    for (ULONG cch=0; cch<pStringW->cchVal; cch++)
    {
        // Is this an extended char
        if (IS_EXTENDED_W(pStringW->pszVal[cch]))
        {
            // Count
            (*pcExtended)++;
        }
    }

    // Done
    return ((*pcExtended) > 0) ? TRUE : FALSE;
}

// --------------------------------------------------------------------------------
// HrRfc1522Encode
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleRfc1522Encode(
            /* in */        LPCSTR              pszValue,
            /* in */        HCHARSET            hCharset,
            /* out */       LPSTR               *ppszEncoded)
{
    // Locals
    HRESULT             hr=S_OK;
    LPINETCSETINFO      pCharset;
    MIMEVARIANT         rSource;
    MIMEVARIANT         rDest;
    CODEPAGEID          cpiSource;
    CODEPAGEID          cpiDest;

    // Invalid Arg
    if (NULL == pszValue || NULL == hCharset || NULL == ppszEncoded)
        return TrapError(E_INVALIDARG);

    // Init rDest
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Setup rSource
    rSource.type = MVT_STRINGA;
    rSource.rStringA.pszVal = (LPSTR)pszValue;
    rSource.rStringA.cchVal = lstrlen(pszValue);

    // Open the Character Set
    CHECKHR(hr = g_pInternat->HrOpenCharset(hCharset, &pCharset));

    // Setup rDest
    rDest.type = MVT_STRINGA;

    // Convert the String
    CHECKHR(hr = g_pInternat->HrConvertString(pCharset->cpiWindows, pCharset->cpiInternet, &rSource, &rDest));

    // Setup Source and Dest Charset
    cpiSource = pCharset->cpiWindows;
    cpiDest = pCharset->cpiInternet;

    // Adjust the Codepages
    CHECKHR(hr = g_pInternat->HrValidateCodepages(&rSource, &rDest, NULL, NULL, &cpiSource, &cpiDest));

    // 1522 Encode this dude
    CHECKHR(hr = HrRfc1522Encode(&rSource, &rDest, cpiSource, cpiDest, pCharset->szName, ppszEncoded));

exit:
    // Cleanup
    MimeVariantFree(&rDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrRfc1522Encode
// --------------------------------------------------------------------------------
HRESULT HrRfc1522Encode(LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, CODEPAGEID cpiSource,
    CODEPAGEID cpiDest, LPCSTR pszCharset, LPSTR *ppszEncoded)
{
    // Locals
    HRESULT         hr=S_OK;
    CByteStream     cStream;
    CHAR            chEncoding;
    ULONG           cExtended=0;
    LPBYTE          pb;
    ULONG           cb;
    ULONG           i=0;
    ULONG           cbFirstTry;
    ULONG           cbRead;
    BLOB            rBlobSource;
    BLOB            rBlobCset;
    ULONG           cTrys;
    CHAR            szEncoding[1];
    ULONG           iBefore;
    ULONG           iAfter;
    ULONG           cbExtra;
    ULARGE_INTEGER  uli;
    LARGE_INTEGER   li;
    //IStream        *pStream=NULL;

    // Invalid Arg
    Assert(pSource && pDest && pszCharset && ppszEncoded);
    Assert(MVT_STRINGW == pSource->type ? CP_UNICODE == cpiSource : CP_UNICODE != cpiSource);
    Assert(cpiDest != CP_UNICODE && MVT_STRINGA == pDest->type);

    // Init
    *ppszEncoded = NULL;
    uli.HighPart = 0;
    li.HighPart = 0;
    rBlobCset.pBlobData = NULL;

    // Raid-50014: Will will always rfc1522 encode utf encodings
    // Raid-50788: Cannot post UTF news messages
    if (MVT_STRINGW != pSource->type)
    {
        // If it does not contain 8bit, then no rfc1522 encoding is needed
        if (FALSE == FContainsExtended(&pSource->rStringA, &cExtended))
        {
            hr = E_FAIL;
            goto exit;
        }
    }

    // We should be converting to UTF...
    else
    {
        // Must be encoding into utf
        Assert(65000 == cpiDest || 65001 == cpiDest);

        // If it does not contain 8bit, then no rfc1522 encoding is needed
        if (FALSE == FContainsExtendedW(&pSource->rStringW, &cExtended))
        {
            hr = E_FAIL;
            goto exit;
        }
    }

    // Create a Stream
    // CHECKHR(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream));

    // Compute Encoding...
    chEncoding = (((cExtended * 100) / pSource->rStringA.cchVal) >= 17) ? 'B' : 'Q';

    // RAID-21673: If DBCS source codepage, then, encode the entire string so that I don't fragment the character set encoding.
    if (IsDBCSCodePage(cpiSource))
        chEncoding = 'B';

    // Set szEncoding
    szEncoding[0] = chEncoding;

    // Setup Encoding Loop
    pb = (MVT_STRINGW == pSource->type) ? (LPBYTE)pSource->rStringW.pszVal : (LPBYTE)pSource->rStringA.pszVal;
    cb = (MVT_STRINGW == pSource->type) ? (pSource->rStringW.cchVal * sizeof(WCHAR)) : pSource->rStringA.cchVal;

    // Adjust pszCharset
    if (CP_JAUTODETECT == cpiDest || 50222 == cpiDest || 50221 == cpiDest)
        pszCharset = (LPSTR)c_szISO2022JP;

    // Compute cbExtra - =?cchCharset?1?<cbFirstTry>?=
    cbExtra = 2 + lstrlen(pszCharset) + 3 + 2;

    // Compute cbFirstTry
    cbFirstTry = 76 - cbExtra;

    // cbFirstTry needs to be even if we are encoding unicode
    cbFirstTry -= (cbFirstTry % 2);    

    // Adjust cbFirstTry if its greater than cb
    cbFirstTry = min(cb, cbFirstTry);

    // Make sure cbFirstTry is even ... That's a good starting point,
    // but we need to make sure that we're not breaking on a leading byte
    // On Korean (and other DBCS locales) we can have a mix of
    // SBCs and MBCs, so just being even isn't enough
    if(pb && (MVT_STRINGW != pSource->type))
    {
        LPCSTR pszEnd = (LPCSTR)&pb[cbFirstTry],
               pszNewEnd = NULL;

        pszNewEnd = CharPrevExA((WORD)cpiSource, (LPCSTR)pb, pszEnd, 0);
        if(pszNewEnd && (pszNewEnd == (pszEnd - 1)) && IsDBCSLeadByteEx(cpiSource, *pszNewEnd))
            cbFirstTry-= (ULONG)(pszEnd - pszNewEnd);
    }

    // Loop until we have encoded the entire string
    while (i < cb)
    {
        // Write Prefix
        CHECKHR(hr = cStream.Write("=?", 2, NULL));
        CHECKHR(hr = cStream.Write(pszCharset, lstrlen(pszCharset), NULL));
        CHECKHR(hr = cStream.Write("?", 1, NULL));
        CHECKHR(hr = cStream.Write(szEncoding, 1, NULL));
        CHECKHR(hr = cStream.Write("?", 1, NULL));

        // Compute Try Amount
        rBlobSource.cbSize = min(cb - i, cbFirstTry);
        rBlobSource.pBlobData = (LPBYTE)(pb + i);

        // Get Index
        CHECKHR(hr = HrGetStreamPos(&cStream, &iBefore));

        // Encoded blocks until we get one at a good length
        for (cTrys=0;;cTrys++)
        {
            // Too many Trys ?
            if (cTrys > 100)
            {
                AssertSz(FALSE, "Too many rfc1522 encode buffer reduction attemps, failing (No rfc1522 encoding will be applied).");
                hr = TrapError(E_FAIL);
                goto exit;
            }

            // Memory Leak
            Assert(NULL == rBlobCset.pBlobData);

            // Convert Block
            CHECKHR(hr = g_pInternat->ConvertBuffer(cpiSource, cpiDest, &rBlobSource, &rBlobCset, &cbRead));

            // Problem
            if (cbRead == 0)
            {
                AssertSz(FALSE, "Bad buffer conversion");
                hr = TrapError(E_FAIL);
                goto exit;
            }

            // Validate
            Assert(cbRead <= rBlobSource.cbSize);

            // 'B' Encoding
            if ('B' == chEncoding)
            {
                // ApplyBase64
                CHECKHR(hr = HrRfc1522EncodeBase64(rBlobCset.pBlobData, rBlobCset.cbSize, &cStream));
            }
            else
            {
                // ApplyQP
                CHECKHR(hr = HrRfc1522EncodeQP(rBlobCset.pBlobData, rBlobCset.cbSize, &cStream));
            }

            // Get Index
            CHECKHR(hr = HrGetStreamPos(&cStream, &iAfter));

            // Validate
            Assert(iAfter > iBefore);

            // Too big ?
            if ((iAfter - iBefore) + cbExtra <= 76)
                break;

            // Problem
            if (rBlobSource.cbSize <= 5)
            {
                Assert(FALSE);
                hr = TrapError(E_FAIL);
                goto exit;
            }

            // Cleanup
            SafeMemFree(rBlobCset.pBlobData);

            // Seek Back to iBefore
            uli.LowPart = iBefore;
            cStream.SetSize(uli);

            // Seek Backwards
            li.LowPart = iBefore;
            cStream.Seek(li, STREAM_SEEK_SET, NULL);

            // Compute Inflation Rate
            if (0 == cTrys)
                rBlobSource.cbSize = (((76 - cbExtra) * rBlobSource.cbSize) / (iAfter - iBefore));

            // Otherwise, start taking off 5 bytes
            else
                rBlobSource.cbSize -= 5;

            // Make sure it is even ... That's a good starting point,
            // but we need to make sure that we're not breaking on a leading byte
            // On Korean (and other DBCS locales) we can have a mix of
            // SBCs and MBCs, so just being even isn't enough
            rBlobSource.cbSize -= (rBlobSource.cbSize % 2);
            if(rBlobSource.pBlobData && (MVT_STRINGW != pSource->type))
            {
                LPCSTR pszEnd = (LPCSTR)&rBlobSource.pBlobData[rBlobSource.cbSize],
                       pszNewEnd = NULL;

                pszNewEnd = CharPrevExA((WORD)cpiSource, (LPCSTR)rBlobSource.pBlobData, pszEnd, 0);
                if(pszNewEnd && (pszNewEnd == (pszEnd - 1)) && IsDBCSLeadByteEx(cpiSource, *pszNewEnd))
                    rBlobSource.cbSize-= (ULONG)(pszEnd - pszNewEnd);
            }

            // Should be less than cb
            Assert(rBlobSource.cbSize < cb);
        }

        // Write termination
        CHECKHR(hr = cStream.Write("?=", 2, NULL));

        // Increment i
        i += cbRead;

        // Cleanup
        SafeMemFree(rBlobCset.pBlobData);

        // Write folding
        if (i < cb)
        {
            // Write Fold
            CHECKHR(hr = cStream.Write(c_szCRLFTab, lstrlen(c_szCRLFTab), NULL));
        }
    }

    // Return the encoded string
    CHECKHR(hr = cStream.HrAcquireStringA(&cb, ppszEncoded, ACQ_DISPLACE));
    //cStream.Commit(STGC_DEFAULT);
    //CHECKALLOC(*ppszEncoded = PszFromANSIStreamA(pStream));

exit:
    // Cleanup
    //ReleaseObj(pStream);
    g_pMalloc->Free(rBlobCset.pBlobData);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleRfc1522Decode
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleRfc1522Decode(LPCSTR pszValue, LPSTR pszCharset, ULONG cchmax, LPSTR *ppszDecoded)
{
    // Locals
    HRESULT             hrEncoded=E_FAIL,
                        hrCsetFound=E_FAIL;
    RFC1522OUT          rOut;
    LPSTR               psz=(LPSTR)pszValue,
                        pszNew;
    CHAR                szCset[CCHMAX_CSET_NAME],
                        chEncoding;
    BOOL                bNonBlankLeading;

    // check params
    if (NULL == pszValue)
        return TrapError(E_INVALIDARG);

    // Init out structure
    ZeroMemory(&rOut, sizeof(RFC1522OUT));

    // Save data..
    if (ppszDecoded)
        rOut.fWrite = TRUE;

    // Start decoding loop...
    while(psz && *psz)
    {
        // Seek to start of 1522 encoding...
        pszNew = PszRfc1522Find(psz, &bNonBlankLeading);
        Assert(pszNew!=NULL);

        if (bNonBlankLeading || psz == pszValue || !*psz)
        {
            // Either we found non-blank characters before the word,
            // or this is the first word on the line, or we didn't
            // find a word.  Whatever, we need to write all of the
            // data before the word.
            if (FAILED(HrRfc1522WriteStr(&rOut, psz, (LONG) (pszNew-psz))))
            {
                break;
            }
        }
        // If didn't find start.. were done
        if (!*pszNew)
            break;

        // Set psz to new position
        psz = pszNew;

        // Get charset
        pszNew = PszRfc1522GetCset(psz, szCset, ARRAYSIZE(szCset));

        // If didn't parse charset correctly, continue
        if (NULL == pszNew)
        {
            psz++;
            continue;
        }

        // Character set was found
        hrCsetFound = S_OK;
        
        // Was caller just looking for the charset...
        if (NULL == ppszDecoded)
            break;

        // Otherwise, parse encoding
        pszNew = PszRfc1522GetEncoding(pszNew, &chEncoding);

        // If didn't parse charset correctly, continue
        if (NULL == pszNew)
        {
            psz++;
            continue;
        }

        // Decode the text to the end - THIS SHOULD NEVER FAIL...
        psz = PszRfc1522Decode(pszNew, chEncoding, &rOut);

        // It is a valid encoded string
        if (psz)
            hrEncoded = S_OK;
    }

    // Were we actually decoding...
    if (ppszDecoded && hrEncoded == S_OK)
    {
        // Commit the stream
        if (FAILED(HrRfc1522WriteDone(&rOut, ppszDecoded)))
        {
            *ppszDecoded = NULL;
            hrEncoded = S_FALSE;
        }
    }

    // Otherwise, return charset...
    if (pszCharset && hrCsetFound == S_OK)
        StrCpyN(pszCharset, szCset, cchmax);

    // Cleanup
    SafeRelease(rOut.pstm);

    // Done
    return ppszDecoded ? hrEncoded : hrCsetFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\stackstr.h ===
// --------------------------------------------------------------------------------
// Stackstr.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __STACKSTR_H
#define __STACKSTR_H

// --------------------------------------------------------------------------------
// Use this macro to define a stack string within a function
// --------------------------------------------------------------------------------
#define STACKSTRING_DEFINE(_name, _size) \
    struct { \
        CHAR szScratch[_size]; \
        LPSTR pszVal; \
        } _name = { '0', NULL };

// --------------------------------------------------------------------------------
// Use this macro to insure that _name::pszVal can hold _cchVal. This macro 
// depends on the local variable 'hr', and that there is a label named 'exit' at
// the end of your function.
// --------------------------------------------------------------------------------
#define STACKSTRING_SETSIZE(_name, _cchVal) \
    if (NULL != _name.pszVal && _name.pszVal != _name.szScratch) { \
        LPSTR psz = (LPSTR)g_pMalloc->Realloc(_name.pszVal, _cchVal); \
        if (NULL == psz) { \
            hr = TrapError(E_OUTOFMEMORY); \
            goto exit; \
        } \
        _name.pszVal = psz; \
    } \
    else if (_cchVal <= sizeof(_name.szScratch)) { \
        _name.pszVal = _name.szScratch; \
    }  \
    else { \
        _name.pszVal = (LPSTR)g_pMalloc->Alloc(_cchVal); \
    }

// --------------------------------------------------------------------------------
// Use this macro to free a stack string
// --------------------------------------------------------------------------------
#define STACKSTRING_FREE(_name) \
    if (NULL != _name.pszVal && _name.pszVal != _name.szScratch) { \
        g_pMalloc->Free(_name.pszVal); \
        _name.pszVal = NULL; \
    }

#endif // __STACKSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\stmlock.h ===
// --------------------------------------------------------------------------------
// Stmlock.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __STMLOCK_H
#define __STMLOCK_H

// -----------------------------------------------------------------------------
// IID_CStreamLockBytes - {62A83701-52A2-11d0-8205-00C04FD85AB4}
// -----------------------------------------------------------------------------
DEFINE_GUID(IID_CStreamLockBytes, 0x62a83701, 0x52a2, 0x11d0, 0x82, 0x5, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// -----------------------------------------------------------------------------
// CStreamLockBytes
// -----------------------------------------------------------------------------
class CStreamLockBytes : public ILockBytes
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CStreamLockBytes(IStream *pStream);
    ~CStreamLockBytes(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // ILockBytes methods
    // -------------------------------------------------------------------------
    STDMETHODIMP Flush(void); 
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
#ifndef WIN16
    STDMETHODIMP ReadAt(ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead); 
#else
    STDMETHODIMP ReadAt(ULARGE_INTEGER ulOffset, void HUGEP *pv, ULONG cb, ULONG *pcbRead);
#endif // !WIN16
    STDMETHODIMP SetSize(ULARGE_INTEGER cb); 
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType); 
#ifndef WIN16
    STDMETHODIMP WriteAt(ULARGE_INTEGER ulOffset, void const *pv, ULONG cb, ULONG *pcbWritten); 
#else
    STDMETHODIMP WriteAt(ULARGE_INTEGER ulOffset, void const HUGEP *pv, ULONG cb, ULONG *pcbWritten);
#endif // !WIN16

    // -------------------------------------------------------------------------
    // CStreamLockBytes
    // -------------------------------------------------------------------------
    void ReplaceInternalStream(IStream *pStream);
    HRESULT HrHandsOffStorage(void);
    HRESULT HrSetPosition(ULARGE_INTEGER uliOffset);
    void GetCurrentStream(IStream **ppStream);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                m_cRef;       // Ref count
    IStream            *m_pStream;    // Protected stream
    CRITICAL_SECTION    m_cs;         // Critical Section for m_pStream
};

// -----------------------------------------------------------------------------
// CLockedStream
// -----------------------------------------------------------------------------
class CLockedStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CLockedStream(ILockBytes *pLockBytes, ULONG cbSize);
    ~CLockedStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
#ifndef WIN16
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *);
#else
    STDMETHODIMP Read(VOID HUGEP *, ULONG, ULONG *);
#endif // !WIN16
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
    STDMETHODIMP Stat(STATSTG *, DWORD);
#ifndef WIN16
    STDMETHODIMP Write(const void *, ULONG, ULONG *) {
#else
    STDMETHODIMP Write(const void HUGEP *, ULONG, ULONG *) {
#endif // !WIN16
        return TrapError(STG_E_ACCESSDENIED); }
    STDMETHODIMP SetSize(ULARGE_INTEGER) {
        return E_NOTIMPL; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *);
    STDMETHODIMP Commit(DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Revert(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) {
        return E_NOTIMPL; }

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG             m_cRef;            // Reference count
    ILockBytes      *m_pLockBytes;      // Protected data stream
    ULARGE_INTEGER   m_uliOffset;       // 64bit Addressable internal lockbyte space
    ULARGE_INTEGER   m_uliSize;         // Size of internal lockbytes
    CRITICAL_SECTION m_cs;              // Critical Section for m_pStream
};

#endif // __STMLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimecap.cpp ===
#include        "pch.hxx"
#include        "demand.h"
#include        <shlwapi.h>
#include        "resource.h"
#include        "dllmain.h"


#ifdef WIN16
#define CRYPT_ACQUIRE_CONTEXT   CryptAcquireContextA
#else
#define CRYPT_ACQUIRE_CONTEXT   CryptAcquireContextW
#endif


////////////////////////////////////////////////////////////////////////////////

const BYTE      RgbRc2_40bit[] = {0x2, 0x01, 40};
const BYTE      RgbRc2_64bit[] = {0x2, 0x01, 64};
const BYTE      RgbRc2_128bit[] = {0x2, 0x02, 0, 128};
const char      SzRc2_128[] = "RC2 (128-bit)";
const char      SzRc2_64[] = "RC2 (64-bit)";
const char      SzRc2_40[] = "RC2 (40-bit)";
const char      SzRc2[] = "RC2";
const char      SzDES[] = "DES";
const char      Sz3DES[] = "3DES";
const char      SzSHA1[] = "SHA1";
const char      SzSHA_1[] = "SHA-1";
const char      SzMD5[] = "MD5";
const char      SzSkipjack[] = "SKIPJACK";
static char     RgchUnknown[256];
static char     Rgch[256];

// encryption bits
const DWORD     cdwBits_3DES =          3 * 56;
const DWORD     cdwBits_RC2_128bit =    128;
const DWORD     cdwBits_RC2_64bit =     64;
const DWORD     cdwBits_DES =           56;
const DWORD     cdwBits_RC2_40bit =     40;
// signing
const DWORD     cdwBits_SHA1RSA =       160;
const DWORD     cdwBits_OIWSEC_sha1 =   160;
const DWORD     cdwBits_MD5 =           128;

#define         flEncryption   1
#define         flSigning   2
#define         flOther     3

struct {
    DWORD       dwFlags;
    char *      pszObjId;       // OID for the alg
    DWORD       cbData;         // size of parameters
    const BYTE * pbData;
    DWORD       dwBits;         // size in bits
    const char * szCSPAlgName;
    const char * szAlgName;      // Name of algorithm
} const RgAlgsDesc[] = {
    {flEncryption,  szOID_RSA_DES_EDE3_CBC,     0,                      NULL,
        cdwBits_3DES,       Sz3DES,     Sz3DES},
    {flEncryption,  szOID_RSA_RC2CBC,           sizeof(RgbRc2_128bit),  RgbRc2_128bit,
        cdwBits_RC2_128bit, SzRc2,      SzRc2_128},
    {flEncryption,  szOID_RSA_RC2CBC,           sizeof(RgbRc2_64bit),   RgbRc2_64bit,
        cdwBits_RC2_64bit,  SzRc2,      SzRc2_64},
    {flEncryption,  szOID_OIWSEC_desCBC,        0,                      NULL,
        cdwBits_DES,        SzDES,      SzDES},
    {flEncryption,  szOID_RSA_RC2CBC,           sizeof(RgbRc2_40bit),   RgbRc2_40bit,
        cdwBits_RC2_40bit,  SzRc2,      SzRc2_40},
    {flEncryption,  szOID_INFOSEC_mosaicConfidentiality, 0,             NULL,
        80,                 SzSkipjack, SzSkipjack},
    {flSigning,     szOID_OIWSEC_sha1,          0,                      NULL,
        cdwBits_OIWSEC_sha1,SzSHA_1,    SzSHA1},
    {flSigning,     szOID_RSA_MD5,              0,                      NULL,
        cdwBits_MD5,    SzMD5,          SzMD5},
    {flOther,       szOID_RSA_preferSignedData, 0,                      NULL,
        0,              NULL,           NULL}
};
const DWORD CEncAlgs = sizeof(RgAlgsDesc)/sizeof(RgAlgsDesc[0]);
const int   ISignDef = 5;            // Must be updated whend RgAlgsDesc modified
const int   IRC240 = 4;


HRESULT GetAlgorithmsFromCert(PCCERT_CONTEXT pcCert, BOOL * rgfShow, ULONG CEncAlgs) {
    HCRYPTPROV              hprov;
    PCRYPT_KEY_PROV_INFO    pkeyinfo = NULL;
    LPWSTR                  pwszContainer = NULL;
    LPWSTR                  pwszProvName = NULL;    // use default provider
    DWORD                   dwProvType = PROV_RSA_FULL;
    HRESULT                 hr = S_OK;
    ULONG                   f;
    BOOL                    fRetried = FALSE;
    ULONG                   i2;
    ULONG                   cb;

    if (pcCert) {
        cb = 0;
        f = CertGetCertificateContextProperty(pcCert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cb);
        if (cb) {
            if (!MemAlloc((LPVOID *) &pkeyinfo, cb)) {
                hr = E_OUTOFMEMORY;
                goto err;
            }

            f = CertGetCertificateContextProperty(pcCert, CERT_KEY_PROV_INFO_PROP_ID, pkeyinfo, &cb);
            Assert(f);
            pwszProvName = pkeyinfo->pwszProvName;
            dwProvType = pkeyinfo->dwProvType;
            pwszContainer = pkeyinfo->pwszContainerName;
        } // else cert doesn't specify provider.  Use default provider.
    } // else use default provider

TryEnhanced:
    f = CRYPT_ACQUIRE_CONTEXT(&hprov, pwszContainer, pwszProvName, dwProvType, 0);
#ifdef DEBUG
    {
        DWORD       dw = GetLastError();
    }
#endif // DEBUG
    if (f) {
        DWORD               cbMax;
        PROV_ENUMALGS *     pbData = NULL;

        cbMax = 0;
        CryptGetProvParam(hprov, PP_ENUMALGS, NULL, &cbMax, CRYPT_FIRST);

        if ((cbMax == 0) || !MemAlloc((LPVOID *) &pbData, cbMax)) {
            hr = E_OUTOFMEMORY;
            goto err;
        }

        cb = cbMax;
        f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, CRYPT_FIRST);
        Assert(f);

        do {
            for (i2 = 0; i2 < CEncAlgs - 1; i2++) {
                if ((strcmp(pbData->szName, RgAlgsDesc[i2].szCSPAlgName) == 0) &&
                    (pbData->dwBitLen == RgAlgsDesc[i2].dwBits)) {
                    rgfShow[i2] = TRUE;
                    break;
                }
            }

            cb = cbMax;
            f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE) pbData, &cb, 0);
        } while (f);

        CryptReleaseContext(hprov, 0);

        SafeMemFree(pbData);

        //
        //  Some providers are really crazy, they have a base and an enhanced provider
        //      and these providers do not do the same set of algorithms.  THis means
        //      that we need to enumerate all of the different algorithms when we
        //      are looking at these providers.  We have the "exhaustive" set of
        //      providers at this point in time.
        //
        
        if (!fRetried) {
            fRetried = TRUE;
#ifndef WIN16
            if (! pwszProvName || (StrCmpW(pwszProvName, MS_DEF_PROV_W) == NULL)) {
                pwszProvName = MS_ENHANCED_PROV_W;
                goto TryEnhanced;
            }
        
            if (StrCmpW(pwszProvName, MS_DEF_DSS_DH_PROV_W) == 0) {
                pwszProvName = MS_ENH_DSS_DH_PROV_W;
                goto TryEnhanced;
            }

            if (StrCmpW(pwszProvName, MS_ENHANCED_PROV_W) == NULL) {
                pwszProvName = MS_DEF_PROV_W;
                goto TryEnhanced;
            }

            if (StrCmpW(pwszProvName, MS_ENH_DSS_DH_PROV_W) == NULL) {
                pwszProvName = MS_DEF_DSS_DH_PROV_W;
                goto TryEnhanced;
            }
#else
            if (! pwszProvName || (wcscmp(pwszProvName, MS_DEF_PROV_A) == NULL)) {
                pwszProvName = MS_ENHANCED_PROV_A;
                goto TryEnhanced;
            }

#endif
        }
    }

    SafeMemFree(pkeyinfo);

    //
    //  If we are looking at diffie-hellman certificates, then we must remove DES
    //  from the list as there is no support in the core code.
    //
    
    if (dwProvType == PROV_DSS_DH) {
        for (i2=0; i2<CEncAlgs; i2++) {
            if (RgAlgsDesc[i2].pszObjId == SzDES) {
                rgfShow[i2] = FALSE;
                break;
            }
        }
    }

err:
    return(hr);
}


MIMEOLEAPI MimeOleSMimeCapsToDlg(LPBYTE pbSymCaps, DWORD cbSymCaps, DWORD cCerts,
                                 PCCERT_CONTEXT * rgCerts, HWND hwnd, DWORD idEncAlgs,
                                 DWORD idSignAlgs, DWORD idBlob)
{
    DWORD                       cb;
    BOOL                        f;
    HRESULT                     hr = E_FAIL;
    DWORD                       i;
    WPARAM                      j;
    int                         iSignDef = -1;
    int                         iEncDef = -1;
    DWORD                       i2;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;
    CHAR                        rgch[100];
    BOOL                        rgfShow[CEncAlgs] = {0};

    if (cbSymCaps != 0) {

        if ((hr = HrDecodeObject(pbSymCaps, cbSymCaps, PKCS_SMIME_CAPABILITIES,
          CRYPT_DECODE_NOCOPY_FLAG, &cb, (LPVOID *)&pcaps)) || ! pcaps) {
            goto err;
        }

        Assert(pcaps);

        //
        //  Filter the list of capabilities passed in by the list of items that
        //  we already know about.  We don't display algorithms that we don't
        //  recognize.
        //

        for (i=0; i<pcaps->cCapability; i++) {
            for (i2=0; i2<CEncAlgs; i2++) {
                if ((strcmp(pcaps->rgCapability[i].pszObjId,
                            RgAlgsDesc[i2].pszObjId) == 0) &&
                    (pcaps->rgCapability[i].Parameters.cbData ==
                     RgAlgsDesc[i2].cbData) &&
                    (memcmp(pcaps->rgCapability[i].Parameters.pbData,
                            RgAlgsDesc[i2].pbData, RgAlgsDesc[i2].cbData) == 0)) {
                    rgfShow[i2] = TRUE;
                    if ((RgAlgsDesc[i2].dwFlags == flEncryption) && (iEncDef == -1)) {
                        iEncDef = i2;
                    }
                    else if ((RgAlgsDesc[i2].dwFlags == flSigning) && (iSignDef == -1)) {
                        iSignDef = i2;
                    }
                    break;
                }
            }
            if (i2 == CEncAlgs) {
                pcaps->rgCapability[i].pszObjId = NULL;
            }
        }
    }

    //
    //  For each certificate, we now want to find the list of capabilities
    //  provided by each of the CSP providers
    //

    for (i = 0; i < cCerts; i++) {
        hr = GetAlgorithmsFromCert(rgCerts[i], rgfShow, CEncAlgs);
    }

    // If there were no cert, get the algorithms from the default provider.
    if (! cCerts) {
        hr = GetAlgorithmsFromCert(NULL, rgfShow, CEncAlgs);
    }

    //
    //  Now populate the combo box with the encryption algrithms if we have
    //  a possiblity todo this.
    //

    if (idEncAlgs != 0) {
        SendDlgItemMessageA(hwnd, idEncAlgs, CB_RESETCONTENT, 0, 0);
        for (i=0; i<CEncAlgs; i++) {
            if (rgfShow[i] && (RgAlgsDesc[i].dwFlags == flEncryption)) {
                j = SendDlgItemMessageA(hwnd, idEncAlgs, CB_ADDSTRING,
                                        0, (LPARAM) RgAlgsDesc[i].szAlgName);
                SendDlgItemMessageA(hwnd, idEncAlgs, CB_SETITEMDATA, j, i);
                if (iEncDef == -1) {
                    iEncDef = i;
                }
            }
        }

        if (iEncDef != (DWORD)-1) {
            SendDlgItemMessageA(hwnd, idEncAlgs, CB_SELECTSTRING,
                                (WPARAM) -1, (LPARAM) RgAlgsDesc[iEncDef].szAlgName);
        }
    }

    //
    //  Now populate the Signature Alg combo box
    //

    if (idSignAlgs != 0) {
        SendDlgItemMessageA(hwnd, idSignAlgs, CB_RESETCONTENT, 0, 0);
        for (i=0; i<CEncAlgs; i++) {
            if (rgfShow[i] && (RgAlgsDesc[i].dwFlags == flSigning)) {
                j = SendDlgItemMessageA(hwnd, idSignAlgs, CB_ADDSTRING,
                                        0, (LPARAM) RgAlgsDesc[i].szAlgName);
                SendDlgItemMessageA(hwnd, idSignAlgs, CB_SETITEMDATA, j, i);
                if (iSignDef == -1) {
                    iSignDef = i;
                }
            }
        }

        if (iSignDef != (DWORD)-1) {
            SendDlgItemMessageA(hwnd, idSignAlgs, CB_SELECTSTRING,
                                (WPARAM) -1, (LPARAM) RgAlgsDesc[iSignDef].szAlgName);
        }
    }

    //
    //  Finally, lets play with the question of perference for signed blob data
    //

    if (idBlob != 0) {
        SendDlgItemMessageA(hwnd, idBlob, BM_SETCHECK, rgfShow[CEncAlgs-1], 0);
    }

    hr = S_OK;
err:
    SafeMemFree(pcaps);
    return hr;
}



MIMEOLEAPI MimeOleSMimeCapsFromDlg(HWND hwnd, DWORD idEncAlgs, DWORD idSignAlgs,
                                   DWORD idBlob, LPBYTE pbSymCaps, DWORD * pcbSymCaps)
{
    DWORD       c;
    CRYPT_SMIME_CAPABILITIES     caps;
    BOOL        f;
    int         fBlob = FALSE;
    DWORD       i;
    DWORD       i1;
    DWORD       j;
    DWORD       iEncDef = (DWORD) -1;
    DWORD       iSignDef = (DWORD) -1;
    CRYPT_SMIME_CAPABILITY      rgcaps[CEncAlgs];
    BOOL        rgfShow[CEncAlgs] = {0};

    //
    //  If we were passed a combo box for the encryption alg, then we pull
    //  the default information out of it.
    //
    //  Additionally we are going to pull out information about which algs
    //  are currently supported by the CSPs involved in the process.  This
    //  will have been populated from a previous call to SymCapsToDlg
    //

    if (idEncAlgs != 0) {
        i = (DWORD) SendDlgItemMessageA(hwnd, idEncAlgs, CB_GETCURSEL, 0, 0);
        iEncDef = (DWORD) SendDlgItemMessageA(hwnd, idEncAlgs, CB_GETITEMDATA, i, 0);

        c = (DWORD) SendDlgItemMessageA(hwnd, idEncAlgs, CB_GETCOUNT, 0, 0);
        for (i=0; i<c; i++) {
            i1 = (DWORD) SendDlgItemMessageA(hwnd, idEncAlgs, CB_GETITEMDATA, i, 0);
            if (i1 < CEncAlgs) {
                rgfShow[i1] = TRUE;
            }
        }
    }

    //
    //  If we were passed a combo box for the signing algs, then we pull the
    //  default information out of it.
    //
    //  Additionally, we are going to pull out information about which algs
    //  are currently supported by the CSPs involved in the in process.  This
    //  will have been populated from a previous call to  SymCapsToDlg.
    //

    if (idSignAlgs != 0) {
        i = (DWORD) SendDlgItemMessageA(hwnd, idSignAlgs, CB_GETCURSEL, 0, 0);
        iSignDef = (DWORD) SendDlgItemMessageA(hwnd, idSignAlgs, CB_GETITEMDATA, i, 0);

        c = (DWORD) SendDlgItemMessageA(hwnd, idSignAlgs, CB_GETCOUNT, 0, 0);
        for (i=0; i<c; i++) {
            i1 = (DWORD) SendDlgItemMessageA(hwnd, idSignAlgs, CB_GETITEMDATA, i, 0);
            if (i1 < CEncAlgs) {
                rgfShow[i1] = TRUE;
            }
        }
    }

    j = 0;
    if (idEncAlgs != 0) {
        //
        //  If we have a default encryuption alg, then put it first
        //

        if (iEncDef != -1) {
            rgcaps[j].pszObjId = RgAlgsDesc[iEncDef].pszObjId;
            rgcaps[j].Parameters.cbData = RgAlgsDesc[iEncDef].cbData;
            rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[iEncDef].pbData;
            j += 1;
        }

        //
        //  We need to build the list of encryption algs supported, if we have
        //  a dialog box item, then use that to build the list.
        //

        for (i=0; i<CEncAlgs; i++) {
            if (rgfShow[i] && (RgAlgsDesc[i].dwFlags == flEncryption) && (iEncDef != i)) {
                rgcaps[j].pszObjId = RgAlgsDesc[i].pszObjId;
                rgcaps[j].Parameters.cbData = RgAlgsDesc[i].cbData;
                rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[i].pbData;
                j += 1;
            }
        }
    }
    else {
        //
        //  No dialog, so we are just going to assume that only 40-bit RC2 is
        //      supported
        //

        rgcaps[j].pszObjId = szOID_RSA_RC2CBC;
        rgcaps[j].Parameters.cbData = sizeof(RgbRc2_40bit);
        rgcaps[j].Parameters.pbData = (LPBYTE) RgbRc2_40bit;
        j += 1;
    }

    if (idSignAlgs != 0) {
        if (iSignDef != -1) {
            rgcaps[j].pszObjId = RgAlgsDesc[iSignDef].pszObjId;
            rgcaps[j].Parameters.cbData = RgAlgsDesc[iSignDef].cbData;
            rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[iSignDef].pbData;
            j += 1;
        }

        for (i=0; i<CEncAlgs; i++) {
            if (rgfShow[i] && (RgAlgsDesc[i].dwFlags == flSigning) && (iSignDef != i)) {
                rgcaps[j].pszObjId = RgAlgsDesc[i].pszObjId;
                rgcaps[j].Parameters.cbData = RgAlgsDesc[i].cbData;
                rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[i].pbData;
                j += 1;
            }
        }
    }
    else {
        //
        //  No dialog, so we are just going to assume that only SHA-1 is
        //      supported
        //

        rgcaps[j].pszObjId = szOID_OIWSEC_sha1RSASign;
        rgcaps[j].Parameters.cbData = 0;
        rgcaps[j].Parameters.pbData = NULL;
        j += 1;
    }

    //
    // If we were passed in an ID blob item, then we should see if we are
    //  going to force a send in blob format
    //

    if (idBlob != 0) {
        if (SendDlgItemMessageA(hwnd, idBlob, BM_GETCHECK, 0, 0) == 1) {
            rgcaps[j].pszObjId = RgAlgsDesc[CEncAlgs-1].pszObjId;
            rgcaps[j].Parameters.cbData = RgAlgsDesc[CEncAlgs-1].cbData;
            rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[CEncAlgs-1].pbData;
            j += 1;
        }
    }

    //
    //  Now actually encrypt the data and return the result.  Note that we
    //  don't allocate space but use the space allocated by our caller
    //

    caps.cCapability = j;
    caps.rgCapability = rgcaps;

    f = CryptEncodeObject(X509_ASN_ENCODING, PKCS_SMIME_CAPABILITIES,
                          &caps, pbSymCaps, pcbSymCaps);
    return f ? S_OK : E_FAIL;
}



static HRESULT SymCapAdd(LPBYTE pbSymCaps, DWORD cbSymCaps, BYTE * rgbFilter)
{
    DWORD               cb;
    BOOL                f;
    HRESULT             hr;
    DWORD               i;
    DWORD               i2;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;

    //
    //  Take the sym caps and decode it
    //

    if ((hr = HrDecodeObject(pbSymCaps, cbSymCaps, PKCS_SMIME_CAPABILITIES,
      CRYPT_DECODE_NOCOPY_FLAG, &cb, (LPVOID *)&pcaps)) || ! pcaps) {
        goto err;
    }

    Assert(pcaps);

    //
    //  Filter the list of capabilities passed in by the list of items that
    //  are on the list.
    //

    for (i2=0, f = TRUE; i2<CEncAlgs; i2++) {
        if (rgbFilter[i2] == FALSE) {
            f = FALSE;
            continue;
        }

        for (i=0; i<pcaps->cCapability; i++) {
            if ((strcmp(pcaps->rgCapability[i].pszObjId,
                        RgAlgsDesc[i2].pszObjId) == 0) &&
                (pcaps->rgCapability[i].Parameters.cbData ==
                 RgAlgsDesc[i2].cbData) &&
                (memcmp(pcaps->rgCapability[i].Parameters.pbData,
                        RgAlgsDesc[i2].pbData, RgAlgsDesc[i2].cbData) == 0)) {
                break;
            }
        }
        if (i == pcaps->cCapability) {
            rgbFilter[i2] = FALSE;
            f = FALSE;
        }
    }

    hr =  f ? S_OK : S_FALSE;

err:
    SafeMemFree(pcaps);
    return hr;
}


////    SymCapInit
//

MIMEOLEAPI MimeOleSMimeCapInit(LPBYTE pbSymCapSender, DWORD cbSymCapSender, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    DWORD       i;
    LPBYTE      pb = NULL;

    if (!MemAlloc((LPVOID *) &pb, CEncAlgs * sizeof(BYTE))) {
        return E_OUTOFMEMORY;
    }

    if (pbSymCapSender && cbSymCapSender) {
        for (i=0; i<CEncAlgs; i++) pb[i] = TRUE;

        hr = SymCapAdd(pbSymCapSender, cbSymCapSender, pb);
        if (FAILED(hr)) {
            MemFree(pb);
            goto exit;
        }
        // Assert(hr == S_OK);
    } else {
        HCRYPTPROV              hprov = NULL;
        LPTSTR                  pszProvName = NULL;    // use default provider
        DWORD                   dwProvType = PROV_RSA_FULL;
        BOOL                    f;
        ULONG                   cb;

        // No sender symcap specified.  Init it to the highest available.
        for (i = 0; i < CEncAlgs; i++) {        // init to all false
            pb[i] = FALSE;
        }

TryEnhanced:
        // Open the provider
        hr = E_OUTOFMEMORY;
        f = CryptAcquireContext(&hprov, NULL, pszProvName, dwProvType, CRYPT_VERIFYCONTEXT);
        if (f) {
            DWORD               cbMax;
            PROV_ENUMALGS *     pbData = NULL;

            hr = S_OK;
            cbMax = 0;
            CryptGetProvParam(hprov, PP_ENUMALGS, NULL, &cbMax, CRYPT_FIRST);

            if ((cbMax == 0) || ! MemAlloc((LPVOID *)&pbData, cbMax)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            cb = cbMax;
            f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, CRYPT_FIRST);
            Assert(f);

            do {
                //  Walk through the list of all known S/MIME caps looking to see if we
                //  have a match.
                for (i = 0; i < CEncAlgs; i++) {
                    // Assume if we get the correct algorithm name, that the CAPI
                    // bitLen parameter is a max value and we will support all smaller ones
                    // as well.
                    if (lstrcmpi(pbData->szName, RgAlgsDesc[i].szCSPAlgName) == 0) {
                        if (pbData->dwBitLen >= RgAlgsDesc[i].dwBits) {
                            pb[i] = TRUE;   // We support this one
                        }
                    }
                }

                cb = cbMax;
                f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, 0);
            } while (f);

            CryptReleaseContext(hprov, 0);

            SafeMemFree(pbData);

            // Try the enhanced provider?
            if (! pszProvName || (lstrcmpi(pszProvName, MS_DEF_PROV) == NULL)) {
                pszProvName = MS_ENHANCED_PROV;
                goto TryEnhanced;
            }
        }
    }

    *ppv = pb;

exit:
    return(hr);
}


MIMEOLEAPI MimeOleSMimeCapAddSMimeCap(LPBYTE pbSymCap, DWORD cbSymCap, LPVOID pv)
{
    if ((pbSymCap != NULL) && (cbSymCap > 0)) {
        return SymCapAdd(pbSymCap, cbSymCap, (LPBYTE) pv);
    }
    return E_INVALIDARG;
}

MIMEOLEAPI MimeOleSMimeCapAddCert(LPBYTE /*pbCert*/, DWORD /*cbCert*/,
                               BOOL fParanoid, LPVOID pv)
{
    BOOL        f;
    DWORD       i;
    DWORD       iSkip;
    LPBYTE      pb = (LPBYTE) pv;

    //
    //  If we are paranoid, then we only allow 3-DES
    //  Otherwise we only allow RC2 40-bit
    //

    if (fParanoid) {
        iSkip = 0;
    }
    else {
        iSkip = IRC240;
    }

    for (i=0, f = TRUE; i<CEncAlgs; i++) {
        if ((i != iSkip) && (RgAlgsDesc[i].dwFlags == flEncryption)) {
            pb[i] &= 0;
            f = pb[i];
        }
    }

    return f ? S_OK : S_FALSE;
}

HRESULT GetResult(DWORD iTarget, LPBYTE pb, LPBYTE pbEncode, DWORD * pcbEncode,
                  DWORD * pdw)
{
    CRYPT_SMIME_CAPABILITY      cap;
    CRYPT_SMIME_CAPABILITIES    caps;
    BOOL        f = FALSE;
    int         i;

    //
    //  Look for the first possible answer to the question
    //

    for (i=0; i<CEncAlgs; i++) {
        if (RgAlgsDesc[i].dwFlags == iTarget) {
            break;
        }
    }

    Assert(i != CEncAlgs);

    //
    //  Look for the highest possible alg to send data with
    //

    for (; i<CEncAlgs; i++) {
        if ((RgAlgsDesc[i].dwFlags != iTarget) || pb[i]) {
            break;
        }
    }

    //
    //  We must not have run off the end of the array, all hash algs come after encryption
    //  algs
    //

    Assert( i < CEncAlgs );

    //
    //  If did not find an algorithm, return the appropriate error
    //

    if (RgAlgsDesc[i].dwFlags != iTarget) {
        *pcbEncode = 0;
        if (pdw != NULL) {
            *pdw = 0;
        }
        return S_FALSE;
    }

    //
    //  Build the S/MIME Capability string with just this one item in it
    //

    caps.cCapability = 1;
    caps.rgCapability = &cap;

    cap.pszObjId = RgAlgsDesc[i].pszObjId;
    cap.Parameters.cbData = RgAlgsDesc[i].cbData;
    cap.Parameters.pbData = (LPBYTE)RgAlgsDesc[i].pbData;

    //
    //  Determine the "extra" parameter.  For encryption it is the
    //  bit size of the algorithm.  For Signing it is weither we should be doing
    //  blob signed
    //

    if (pdw != NULL) {
        if (iTarget == 1) {
            *pdw = RgAlgsDesc[i].dwBits;
        }
        else {
            Assert(iTarget == 2);
            *pdw = pb[CEncAlgs-1];
        }
    }

    f = CryptEncodeObject(X509_ASN_ENCODING, PKCS_SMIME_CAPABILITIES,
                          &caps, pbEncode, pcbEncode);
#ifndef WIN16
    if (!f && (::GetLastError() != ERROR_MORE_DATA)) {
        return E_FAIL;
    }
#endif
    return f ? S_OK : S_FALSE;
}

MIMEOLEAPI MimeOleSMimeCapGetEncAlg(LPVOID pv, LPBYTE pbEncode, DWORD * pcbEncode,
                                    DWORD * pdwBits)
{
    return GetResult(1, (LPBYTE) pv, pbEncode, pcbEncode, pdwBits);
}

MIMEOLEAPI MimeOleSMimeCapGetHashAlg(LPVOID pv, LPBYTE pbEncode, DWORD * pcbEncode,
                                     DWORD * pfBlobSign)
{
    return GetResult(2, (LPBYTE) pv, pbEncode, pcbEncode, pfBlobSign);
}

MIMEOLEAPI MimeOleSMimeCapRelease(LPVOID pv)
{
    MemFree(pv);
    return S_OK;
}

MIMEOLEAPI MimeOleAlgNameFromSMimeCap(LPBYTE pbEncode, DWORD cbEncode,
                                      LPCSTR * ppszProtocol)
{
    DWORD                       cb = 0;
    BOOL                        f;
    HRESULT                     hr;
    DWORD                       i;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;

    //
    //  Decode the S/MIME caps which is passed in, allocate space to hold
    //  the resulting value
    //

    hr = HrDecodeObject(pbEncode, cbEncode, PKCS_SMIME_CAPABILITIES, CRYPT_DECODE_NOCOPY_FLAG, &cb, (LPVOID *)&pcaps);
    if (FAILED(hr) || NULL == pcaps)
    {
        if (hr != E_OUTOFMEMORY) 
        {
            if (RgchUnknown[0] == 0) 
            {
                LoadStringA(g_hLocRes, IDS_UNKNOWN_ALG, RgchUnknown, sizeof(RgchUnknown));
            }
            *ppszProtocol = RgchUnknown;
            return S_FALSE;
        } 
        else 
        {
            return E_OUTOFMEMORY;
        }
    }

    Assert(pcaps);
    Assert(pcaps->cCapability == 1);

    //
    //  Walk through the list of all known S/MIME caps looking to see if we
    //  have a match.   If so then setup the return answer.
    //

    for (i=0; i<CEncAlgs; i++) {
        if ((strcmp(pcaps->rgCapability[0].pszObjId, RgAlgsDesc[i].pszObjId) == 0) &&
            (pcaps->rgCapability[0].Parameters.cbData == RgAlgsDesc[i].cbData) &&
            (memcmp(pcaps->rgCapability[0].Parameters.pbData,
                    RgAlgsDesc[i].pbData, RgAlgsDesc[i].cbData) == 0)) {
            *ppszProtocol = RgAlgsDesc[i].szAlgName;
            break;
        }
    }

    //
    //  We did not find a match.  So now we need to assume that we might have been
    //  passed a Parameter rather than an S/MIME cap.  So try decoding as a parameter
    //

    if (i== CEncAlgs) {
        if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_RC2CBC) == 0) {
            PCRYPT_RC2_CBC_PARAMETERS   prc2;
            prc2 = (PCRYPT_RC2_CBC_PARAMETERS)
                PVDecodeObject(pcaps->rgCapability[0].Parameters.pbData,
                                pcaps->rgCapability[0].Parameters.cbData,
                                PKCS_RC2_CBC_PARAMETERS, NULL);
            if (prc2 != NULL) {
                if (prc2->dwVersion == CRYPT_RC2_40BIT_VERSION) {
                    *ppszProtocol = SzRc2_40;
                }
                else if (prc2->dwVersion == CRYPT_RC2_64BIT_VERSION) {
                    *ppszProtocol = SzRc2_64;
                }
                else if (prc2->dwVersion == CRYPT_RC2_128BIT_VERSION) {
                    *ppszProtocol = SzRc2_128;
                }
                else {
                    *ppszProtocol = SzRc2;
                }
                SafeMemFree(prc2);  // Must be freed prior to pcaps
            }
            else {
                *ppszProtocol = SzRc2;
            }
        }
        else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_DES_EDE3_CBC) == 0) {
            *ppszProtocol = Sz3DES;
        }
        else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_OIWSEC_desCBC) == 0) {
            *ppszProtocol = SzDES;
        }
        else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_INFOSEC_mosaicConfidentiality) == 0) {
            *ppszProtocol = SzSkipjack;
        }
        else {
            StrCpyNA(Rgch, pcaps->rgCapability[0].pszObjId, ARRAYSIZE(Rgch));
            *ppszProtocol = Rgch;
        }
        MemFree(pcaps);
        return S_FALSE;
    }

    MemFree(pcaps);
    return S_OK;
}


MIMEOLEAPI MimeOleAlgStrengthFromSMimeCap(LPBYTE pbEncode, DWORD cbEncode, BOOL fEncryption,
  DWORD * pdwStrength)
{
    DWORD                       cb = 0;
    BOOL                        f;
    HRESULT                     hr = S_OK;
    DWORD                       i;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;

    // Init return value
    *pdwStrength = 0;

    if (pbEncode && cbEncode) {
        //
        //  Decode the S/MIME caps which is passed in, allocate space to hold
        //  the resulting value
        //

        if ((hr = HrDecodeObject(pbEncode, cbEncode, PKCS_SMIME_CAPABILITIES,
          CRYPT_DECODE_NOCOPY_FLAG, &cb, (LPVOID *)&pcaps)) || ! pcaps) {
             goto exit;;
        }

        Assert(pcaps);
        Assert(pcaps->cCapability == 1);

        //
        //  Walk through the list of all known S/MIME caps looking to see if we
        //  have a match.   If so then setup the return answer.
        //

        for (i=0; i<CEncAlgs; i++) {
            if ((strcmp(pcaps->rgCapability[0].pszObjId, RgAlgsDesc[i].pszObjId) == 0) &&
                (pcaps->rgCapability[0].Parameters.cbData == RgAlgsDesc[i].cbData) &&
                (memcmp(pcaps->rgCapability[0].Parameters.pbData,
                        RgAlgsDesc[i].pbData, RgAlgsDesc[i].cbData) == 0)) {
                *pdwStrength = RgAlgsDesc[i].dwBits;
                break;
            }
        }

        //
        //  We did not find a match.  So now we need to assume that we might have been
        //  passed a Parameter rather than an S/MIME cap.  So try decoding as a parameter
        //

        if (i== CEncAlgs) {
            if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_RC2CBC) == 0) {
                PCRYPT_RC2_CBC_PARAMETERS   prc2;
                prc2 = (PCRYPT_RC2_CBC_PARAMETERS)
                    PVDecodeObject(pcaps->rgCapability[0].Parameters.pbData,
                                    pcaps->rgCapability[0].Parameters.cbData,
                                    PKCS_RC2_CBC_PARAMETERS, NULL);
                if (prc2 != NULL) {
                    if (prc2->dwVersion == CRYPT_RC2_40BIT_VERSION) {
                        *pdwStrength = cdwBits_RC2_40bit;
                    }
                    else if (prc2->dwVersion == CRYPT_RC2_64BIT_VERSION) {
                        *pdwStrength = cdwBits_RC2_64bit;
                    }
                    else if (prc2->dwVersion == CRYPT_RC2_128BIT_VERSION) {
                        *pdwStrength = cdwBits_RC2_128bit;
                    }
                    else {
                        *pdwStrength = cdwBits_RC2_40bit;
                    }
                    SafeMemFree(prc2);  // Must be freed prior to pcaps
                }
                else {
                    *pdwStrength = cdwBits_RC2_40bit;
                }
            }

            else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_DES_EDE3_CBC) == 0) {
                *pdwStrength = cdwBits_3DES;
            }
            else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_OIWSEC_desCBC) == 0) {
                *pdwStrength = cdwBits_DES;
            }
            else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_INFOSEC_mosaicConfidentiality) == 0) {
                *pdwStrength = 80;
            }
            else {
                *pdwStrength = 0;
            }
            MemFree(pcaps);
            return S_FALSE;
        }

        MemFree(pcaps);
    } else {
        // No SMimeCap passed in, find the maximum supported by this configuration
        HCRYPTPROV              hprov = NULL;
        LPTSTR                  pszProvName = NULL;    // use default provider
        DWORD                   dwProvType = PROV_RSA_FULL;

TryEnhanced:
        f = CryptAcquireContext(&hprov, NULL, pszProvName, dwProvType, CRYPT_VERIFYCONTEXT);
        if (f) {
            DWORD               cbMax;
            PROV_ENUMALGS *     pbData = NULL;

            cbMax = 0;
            CryptGetProvParam(hprov, PP_ENUMALGS, NULL, &cbMax, CRYPT_FIRST);

            if ((cbMax == 0) || ! MemAlloc((LPVOID *)&pbData, cbMax)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            cb = cbMax;
            f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, CRYPT_FIRST);
            Assert(f);

            do {
                //  Walk through the list of all known S/MIME caps looking to see if we
                //  have a match.
                for (i = 0; i < CEncAlgs; i++) {
                    if ((RgAlgsDesc[i].dwFlags == (DWORD)(fEncryption ? flEncryption : flSigning)) && lstrcmpi(pbData->szName, RgAlgsDesc[i].szCSPAlgName) == 0) {
                        if (pbData->dwBitLen > *pdwStrength) {
                            *pdwStrength = pbData->dwBitLen;
                        }
                    }
                }

                cb = cbMax;
                f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, 0);
            } while (f);

            CryptReleaseContext(hprov, 0);

            SafeMemFree(pbData);

            // Try the enhanced provider?
            if (! pszProvName || (lstrcmpi(pszProvName, MS_DEF_PROV) == NULL)) {
                pszProvName = MS_ENHANCED_PROV;
                goto TryEnhanced;
            }
        }
    }

exit:
    return(hr);
}


MIMEOLEAPI MimeOleSMimeCapsFull(LPVOID pv, BOOL fFullEncryption, BOOL fFullSigning, LPBYTE pbSymCaps, DWORD * pcbSymCaps)
{
    CRYPT_SMIME_CAPABILITIES    caps;
    BOOL                        f;
    DWORD                       i;
    DWORD                       j = 0;
    CRYPT_SMIME_CAPABILITY      rgcaps[CEncAlgs];
    LPBYTE                      rgfUse = (LPBYTE)pv;


    //
    //  We need to build the list of encryption algs supported, if we have
    //  a dialog box item, then use that to build the list.
    //
    if (fFullEncryption) {
        for (i = 0; i < CEncAlgs; i++) {
            if (rgfUse[i] && (RgAlgsDesc[i].dwFlags == flEncryption)) {
                rgcaps[j].pszObjId = RgAlgsDesc[i].pszObjId;
                rgcaps[j].Parameters.cbData = RgAlgsDesc[i].cbData;
                rgcaps[j].Parameters.pbData = (LPBYTE)RgAlgsDesc[i].pbData;
                j += 1;
            }
        }
    } else {
        //
        //  Just assume that only 40-bit RC2 is supported
        //
        rgcaps[j].pszObjId = szOID_RSA_RC2CBC;
        rgcaps[j].Parameters.cbData = sizeof(RgbRc2_40bit);
        rgcaps[j].Parameters.pbData = (LPBYTE) RgbRc2_40bit;
        j += 1;
    }

    //
    // Now, put in the signing algorithms
    //
    if (fFullSigning) {
        for (i = 0; i < CEncAlgs; i++) {
            if (rgfUse[i] && (RgAlgsDesc[i].dwFlags == flSigning)) {
                rgcaps[j].pszObjId = RgAlgsDesc[i].pszObjId;
                rgcaps[j].Parameters.cbData = RgAlgsDesc[i].cbData;
                rgcaps[j].Parameters.pbData = (LPBYTE)RgAlgsDesc[i].pbData;
                j += 1;
            }
        }
    } else {
        //
        //  Just assume that only SHA-1 is supported
        //
        rgcaps[j].pszObjId = szOID_OIWSEC_sha1RSASign;
        rgcaps[j].Parameters.cbData = 0;
        rgcaps[j].Parameters.pbData = NULL;
        j += 1;
    }

    //
    //  Now actually encrypt the data and return the result.  Note that we
    //  don't allocate space but use the space allocated by our caller
    //

    caps.cCapability = j;
    caps.rgCapability = rgcaps;

    f = CryptEncodeObject(X509_ASN_ENCODING, PKCS_SMIME_CAPABILITIES,
      &caps, pbSymCaps, pcbSymCaps);
    return(f ? S_OK : E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smime.h ===
/*
**	s m i m e . h
**	
**	Purpose: class for cryptographically enhanced mail.
**
**  Owner:   t-erikne
**  Created: 8/27/96
**	
**	Copyright (C) Microsoft Corp. 1996-1998
*/

#ifndef __SMIME_H
#define __SMIME_H

#include <mimeole.h>

#ifndef __WINCRYPT_H__
#include "wincrypt.h"
#endif

#ifdef SMIME_V3
// #include "..\ess\essout.h"
#endif // SMIME_V3

#define szOID_INFOSEC_keyExchangeAlgorithm "2.16.840.1.101.2.1.1.22"

#include "capitype.h"
#include "cryptdbg.h"

//  WinCrypt.h helper 

#define DOUTL_SMIME     CRYPT_LEVEL

class CCAPIStm;

extern CRYPT_ENCODE_PARA       CryptEncodeAlloc;
extern CRYPT_DECODE_PARA       CryptDecodeAlloc;


#ifdef MAC
/*
**  An array of function pointers, needed because we dynalink to
**  CRYPT32.DLL.  Note that not all of the crypto functions come
**  from this DLL.  I also use functions from ADVAPI32: the CAPI 1
**  functions.  These are not represented in this table and do not
**  need to use GetProcAddress.
**  Typedefs come from capitype.h, local to our project.
*/

typedef struct tagCAPIfuncs {
    CERTENUMCERTIFICATESINSTORE             *EnumCerts;
    CERTNAMETOSTRA                          *CertNameToStr;
} CAPIfuncs, *PCAPIfuncs;
#endif // MAC


/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//

typedef enum {
    ENCRYPT_ITEM_TRANSPORT = 1,
    ENCRYPT_ITEM_AGREEMENT = 2,
    ENCRYPT_ITEM_MAILLIST = 3
} ENCRYPT_ITEM_TYPE;

typedef struct tagEncryptItem {
    DWORD       dwTagType;
    union {
        struct {
            BLOB                blobAlg;
            DWORD               cCert;
            PCCERT_CONTEXT *    rgpccert;
        } Transport;
        struct {
            BLOB                blobAlg;
            DWORD               cCert;
            PCCERT_CONTEXT *    rgpccert;
            PCCERT_CONTEXT      pccertSender;
        } Agreement;
        struct {
            BLOB                blobAlg;        // AlgId + AuxInfo
            BLOB                blobKeyId;      // Data_Blob KeyID
            FILETIME            date;           // Date
            BLOB                blobOctet;      // Other attribute (oid, any)
#ifdef SMIME_V3
            HCRYPTPROV          hprov;          // hprov
            HCRYPTKEY           hkey;           // hkey
#else // !SMIME_V3
            BLOB                blobKeyMaterial;
#endif // SMIME_V3
        } MailList;
    };
} EncryptItem;

typedef struct tagEncryptItems {
    DWORD               cItems;
    EncryptItem *       rgItems;
} EncryptItems;

//
// Notes about the [directions]
// [sgn] - signing -- in for sign ops
// [ver] - verification -- out for sign ops
// [enc] - encryption -- in for encrypt ops
// [dec] - decryption -- out for encrypt ops
// [in] = [sgn,enc]
// [out] = [ver,dec]
//

typedef struct {
    DWORD             ulValidity;         // Validity bits for each signature
    PCCERT_CONTEXT    pccert;             // Signer certificate
    BLOB              blobHashAlg;        // Hash algorithm for signer
    BLOB              blobAuth;           // authenticated attributes
    BLOB              blobUnauth;         // unauthenticated attributes
#ifdef SMIME_V3
    BLOB              blobReceipt;        // Receipt to be returned
    BLOB              blobHash;           // Hash of message 
#endif // SMIME_V3
} SignerData;

class CSECURITY_LAYER_DATA : public IUnknown
{
friend class CSMime;        // Allow CSMime access to our private data
friend class CCAPIStm;      // Allow CCAPIStm access to our private data
public:
    CSECURITY_LAYER_DATA(void);
    ~CSECURITY_LAYER_DATA(void);

    // --------------------------------------------------------------------
    // IUnknown
    // --------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //private:     // private data
    DWORD               m_cRef;
    DWORD               m_dwMsgEnhancement;     // sign?  encrypt?
    BOOL                m_fCertInLayer;         // TRUE if there is a cert included in this layer

    //  The following elements exist one for each signer on the current layer
    DWORD               m_cSigners;             // Count of signers
    SignerData *        m_rgSigners;            // Signer Data

    //  The following items exist to encrypt the current layer
    DWORD               m_cEncryptItems;        // Encrypt Item count
#ifdef SMIME_V3
    CRYPT_ALGORITHM_IDENTIFIER m_ContentEncryptAlgorithm; // Content AlgId
    void *              m_pvEncryptAuxInfo;     // Aux info
    CMSG_RECIPIENT_ENCODE_INFO * m_rgRecipientInfo; // Array of Recpient Infos
    CRYPT_DATA_BLOB     m_blobUnprotectAttrs;   // Unprotected attributes
    HCERTSTORE          m_hstoreEncrypt;        // Encrypt cert store
#else // !SMIME_V3
    EncryptItem *       m_rgEncryptItems;       // count of Encrypt Items
#endif // SMIME_V3

    //  The following items exists for a decrypted message
    DWORD               m_ulDecValidity;
    BLOB                m_blobDecAlg;           // Decryption Algorithm
    PCCERT_CONTEXT      m_pccertDecrypt;        // Decryption Certificate

    //  These are items common to both encryption and signing
    HCERTSTORE          m_hcertstor;            // message cert store
                                                // Cert Bag for signing
                                                // Originator Info for encryption
    //

    CSECURITY_LAYER_DATA * m_psldInner;         // down link
    CSECURITY_LAYER_DATA * m_psldOuter;         // up link
};
typedef class CSECURITY_LAYER_DATA SECURITY_LAYER_DATA;
typedef SECURITY_LAYER_DATA * PSECURITY_LAYER_DATA;


// -------------------------------------------------------------------
// SMIMEINFO:
//  bidirectional communication struct for passing parameter
//  info to/from the en/decode functions
//
//  dwMsgEnhancement    [inout]
//  fCertWithMsg        [ver]
//  ulMsgValidity       [out]
//  ietRequested        [in]
// -------------------------------------------------------------------
struct SMIMEINFOtag {       // si
    DWORD           dwMsgEnhancement;
    PSECURITY_LAYER_DATA psldLayers;        // outermost layer
    PSECURITY_LAYER_DATA psldEncrypt;       // encryption layer
    PSECURITY_LAYER_DATA psldInner;         // innermost layer
    ULONG           cStores;                // size of rgStores
    HCERTSTORE *    rgStores;               // array of cert stores
    BOOL            fCertWithMsg;
    ULONG           ulMsgValidity;
    ENCODINGTYPE    ietRequested;
    HCRYPTPROV      hProv;
#ifdef SMIME_V3
    LPSTR           pszInnerContent;        // Inner content (NULL ->> id-data)
    DWORD           cbInnerContent;         // Inner content size if != id-data
    LPWSTR          pwszKeyPrompt;          // Key password prompt
#endif // SMIME_V3
};
typedef struct SMIMEINFOtag SMIMEINFO;
typedef SMIMEINFO *PSMIMEINFO;
typedef const SMIMEINFO *PCSMIMEINFO;


/////////////////////////////////////////////////////////////////////////////
//
// Class begins
//

class CSMime :
    public IMimeSecurity
{
public:
    //
    // ctor and dtor
    //
    CSMime(void);
    ~CSMime();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IMimeSecurity methods
    //
    STDMETHODIMP InitNew();
    STDMETHODIMP CheckInit();

    STDMETHODIMP EncodeMessage(IMimeMessageTree *const pTree, DWORD dwFlags);
    STDMETHODIMP DecodeMessage(IMimeMessageTree *const pTree, DWORD dwFlags);
    STDMETHODIMP EncodeBody(IMimeMessageTree *const pTree, HBODY hEncodeRoot, DWORD dwFlags);
    STDMETHODIMP DecodeBody(IMimeMessageTree *const pTree, HBODY hDecodeRoot, DWORD dwFlags);

    STDMETHODIMP EnumCertificates(HCAPICERTSTORE hc, DWORD dwUsage, PCX509CERT pPrev, PCX509CERT *pCert);
    STDMETHODIMP GetCertificateName(const PCX509CERT pX509Cert, const CERTNAMETYPE cn, LPSTR *ppszName);
    STDMETHODIMP GetMessageType(const HWND hwndParent, IMimeBody *const pBody, DWORD *const pdwSecType);

    STDMETHODIMP GetCertData(const PCX509CERT pX509Cert, const CERTDATAID dataid, LPPROPVARIANT pValue);

    //  Other methods
    HRESULT     EncodeMessage2(IMimeMessageTree * const pTree, DWORD dwFlags,
                               HWND hwnd);
    HRESULT     DecodeMessage2(IMimeMessageTree * const pTree, DWORD dwFlags,
                               HWND hwnd, IMimeSecurityCallback * pCallback);
    HRESULT     EncodeBody2(IMimeMessageTree *const pTree, HBODY hEncodeRoot,
                            DWORD dwFlags, HWND hwnd);
    HRESULT     DecodeBody2(IMimeMessageTree *const pTree, HBODY hDecodeRoot,
                            DWORD dwFlags, SMIMEINFO * psiOuterOp, HWND hwnd,
                            IMimeSecurityCallback * pCallback);

    //
    // Implementation methods
    //
    static  void    UnloadAll(void);
    static  HRESULT HrGetCertsFromThumbprints(THUMBBLOB *const rgThumbprint, X509CERTRESULT *const pResults);
    static  HRESULT StaticGetMessageType(HWND hwndParent, IMimeBody *const pBody, DWORD *const pdwSecType);

protected:
    static  HRESULT StaticCheckInit();

    struct CERTARRAY {
        DWORD           cCerts;
        PCCERT_CONTEXT *rgpCerts;
        };
    typedef CERTARRAY *PCERTARRAY;
    typedef const CERTARRAY *PCCERTARRAY;

    HRESULT DecodeBody      (IMimeMessageTree *const pTree, HBODY hDecodeRoot, DWORD dwFlags, SMIMEINFO * psiOuterOp);

    HRESULT HrEncodeOpaque      (SMIMEINFO *const psi, IMimeMessageTree *pTree, HBODY hEncodeRoot, IMimeBody *pEncodeRoot, LPSTREAM lpstmOut, HWND hwnd);
    HRESULT HrDecodeOpaque      (DWORD dwFlags, SMIMEINFO *const psi, IMimeBody *const pBody, IStream *const pstmOut, HWND hwnd, IMimeSecurityCallback * pCallback);
    HRESULT HrEncodeClearSigned (SMIMEINFO *const psi, IMimeMessageTree *const pTree, const HBODY hEncodeRoot, IMimeBody *const pEncodeRoot, LPSTREAM lpstmOut, BOOL fCommit, HWND hwnd);
    HRESULT HrDecodeClearSigned (DWORD dwFlags, SMIMEINFO *const psi, IMimeMessageTree *const pTree, const HBODY hData, const HBODY hSig, HWND hwnd, IMimeSecurityCallback * pCallback);

    static  BOOL    FSign(const DWORD dwAction)
                        { return BOOL(dwAction & MST_SIGN_MASK); }
    static  BOOL    FClearSign(const DWORD dwAction)
                        { return (FSign(dwAction) && !(dwAction & MST_BLOB_FLAG)); }
    static  BOOL    FEncrypt(const DWORD dwAction)
                        { return BOOL(dwAction & MST_ENCRYPT_MASK); }

    static  HRESULT HrGetNeededAddresses(const DWORD dwTypes, IMimeMessageTree *pTree, IMimeAddressTable **ppAdrTable, IMimeEnumAddressTypes **ppEnum);
    static  HRESULT HrGetCertificates(IMimeAddressTable *const pAdrTable, IMimeEnumAddressTypes *pEnum, const DWORD dwType, const BOOL fAlreadyHaveSendersCert, CERTARRAY *rgCerts);
    static  HRESULT HrGetThumbprints(IMimeEnumAddressTypes *pEnum, const ITHUMBPRINTTYPE ittType, THUMBBLOB *const rgThumbprint);
    static  HRESULT HrGenerateCertsStatus(X509CERTRESULT *pResults, IMimeAddressTable *const pAdrTable, IMimeEnumAddressTypes *const pEnum, const BOOL fIgnoreSenderError);

    HRESULT HrFindUsableCert(HCERTSTORE hCertStore, BYTE dwKeySpec, PCCERT_CONTEXT pPrevCert, PCCERT_CONTEXT *ppCert);

    static  HRESULT OptionsToSMIMEINFO(BOOL fEncode, IMimeMessageTree *const pmm, IMimeBody *pBody, SMIMEINFO *psi);
    static  HRESULT     SMIMEINFOToOptions(IMimeMessageTree *const pTree, const SMIMEINFO *psi, HBODY hBody);
    static  HRESULT     MergeSMIMEINFO( SMIMEINFO * psiOut, SMIMEINFO * psiInner);
    static  void    FreeSMIMEINFO(SMIMEINFO *psi);

#ifdef DEBUG
    void    DumpAlgorithms();
#endif

private:
    static HRESULT  HrInitCAPI();
    static void     UnloadCAPI();

    static HRESULT      CAPISTMtoSMIMEINFO(CCAPIStm *pcapistm, SMIMEINFO *psi);
    static void MergeSMIMEINFOs(const SMIMEINFO *const psiOuter, SMIMEINFO *const psiInner);

    UINT                m_cRef;
    CRITICAL_SECTION    m_cs;
#ifdef MAC
    static CAPIfuncs    ms_CAPI;
    static LPCSTR       ms_rgszFuncNames[];
#endif // MAC
};

inline BOOL IsOpaqueSecureContentType(IMimePropertySet *pSet)
{
    return (
        S_OK == pSet->IsContentType(STR_CNT_APPLICATION, STR_SUB_XPKCS7MIME) ||
        S_OK == pSet->IsContentType(STR_CNT_APPLICATION, STR_SUB_PKCS7MIME));
}

inline BOOL IsSecureContentType(IMimePropertySet *pSet)
{
    return (
        S_OK == pSet->IsContentType(STR_CNT_MULTIPART, STR_SUB_SIGNED) ||
        IsOpaqueSecureContentType(pSet));
}

BOOL IsSMimeProtocol(LPMIMEPROPERTYSET lpPropSet);

#ifdef SMIME_V3
void    FreeRecipientInfoContent(PCMS_RECIPIENT_INFO pRecipInfo);
HRESULT HrCopyOID(LPCSTR psz, LPSTR * ppsz);
HRESULT HrCopyCryptDataBlob(const CRYPT_DATA_BLOB * pblobSrc, PCRYPT_DATA_BLOB pblobDst);
HRESULT HrCopyCryptBitBlob(const CRYPT_BIT_BLOB * pblobSrc, PCRYPT_BIT_BLOB pblobDst);
HRESULT HrCopyCryptAlgorithm(const CRYPT_ALGORITHM_IDENTIFIER * pAlgSrc,
                             PCRYPT_ALGORITHM_IDENTIFIER pAlgDst);
HRESULT HrCopyCertId(const CERT_ID * pcertidSrc, PCERT_ID pcertidDst);
#endif // SMIME_V3

#endif // _SMIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\symcache.cpp ===
// --------------------------------------------------------------------------------
// Symcache.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "symcache.h"
#include "containx.h"
#include "stackstr.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include "demand.h"
#include "qstrcmpi.h"

// --------------------------------------------------------------------------------
// Array of Pointers to known property symbols. This array's order defines the
// header row order in which headers will be saved.
// --------------------------------------------------------------------------------
static const LPPROPSYMBOL g_prgKnownSymbol[] = {
    { SYM_HDR_RECEIVED      },
    { SYM_HDR_RETURNPATH    },
    { SYM_HDR_RETRCPTTO     },
    { SYM_HDR_RR            },
    { SYM_HDR_REPLYTO       },
    { SYM_HDR_APPARTO       },
    { SYM_HDR_FROM          },
    { SYM_HDR_SENDER        },
    { SYM_HDR_TO            },
    { SYM_HDR_CC            },
    { SYM_HDR_BCC           },
    { SYM_HDR_NEWSGROUPS    },
    { SYM_HDR_PATH          },
    { SYM_HDR_FOLLOWUPTO    },
    { SYM_HDR_REFS          },
    { SYM_HDR_SUBJECT       },
    { SYM_HDR_DATE          },
    { SYM_HDR_EXPIRES       },
    { SYM_HDR_CONTROL       },
    { SYM_HDR_DISTRIB       },
    { SYM_HDR_KEYWORDS      },
    { SYM_HDR_SUMMARY       },
    { SYM_HDR_APPROVED      },
    { SYM_HDR_LINES         },
    { SYM_HDR_XREF          },
    { SYM_HDR_ORG           },
    { SYM_HDR_COMMENT       },
    { SYM_HDR_ENCODING      },
    { SYM_HDR_ENCRYPTED     },
    { SYM_HDR_OFFSETS       },
    { SYM_ATT_FILENAME      },
    { SYM_ATT_GENFNAME      },
    { SYM_PAR_BOUNDARY      },
    { SYM_PAR_CHARSET       },
    { SYM_PAR_NAME          },
    { SYM_PAR_FILENAME      },
    { SYM_ATT_PRITYPE       },
    { SYM_ATT_SUBTYPE       },
    { SYM_ATT_NORMSUBJ      },
    { SYM_ATT_ILLEGAL       },
    { SYM_HDR_MESSAGEID     },
    { SYM_HDR_MIMEVER       },
    { SYM_HDR_CNTTYPE       },
    { SYM_HDR_CNTXFER       },
    { SYM_HDR_CNTID         },
    { SYM_HDR_CNTDESC       },
    { SYM_HDR_CNTDISP       },
    { SYM_HDR_CNTBASE       },
    { SYM_HDR_CNTLOC        },
    { SYM_ATT_RENDERED      },
    { SYM_ATT_SENTTIME      },
    { SYM_ATT_RECVTIME      },
    { SYM_ATT_PRIORITY      },
    { SYM_HDR_ARTICLEID     },
    { SYM_HDR_NEWSGROUP     },
    { SYM_HDR_XPRI          },
    { SYM_HDR_XMSPRI        },
    { SYM_HDR_XMAILER       },
    { SYM_HDR_XNEWSRDR      },
    { SYM_HDR_XUNSENT       },
    { SYM_ATT_SERVER        },
    { SYM_ATT_ACCOUNTID     },
    { SYM_ATT_UIDL          },
    { SYM_ATT_STOREMSGID    },
    { SYM_ATT_USERNAME      },
    { SYM_ATT_FORWARDTO     },
    { SYM_ATT_STOREFOLDERID },
    { SYM_ATT_GHOSTED       },
    { SYM_ATT_UNCACHEDSIZE  },
    { SYM_ATT_COMBINED      },
    { SYM_ATT_AUTOINLINED   },
    { SYM_HDR_DISP_NOTIFICATION_TO }
};                                     

// --------------------------------------------------------------------------------
// Address Types To Property Symbol Mapping Table (Clients can register types)
// --------------------------------------------------------------------------------
static ADDRSYMBOL g_prgAddrSymbol[32] = {
    { IAT_FROM,         SYM_HDR_FROM        },
    { IAT_SENDER,       SYM_HDR_SENDER      },
    { IAT_TO,           SYM_HDR_TO          },
    { IAT_CC,           SYM_HDR_CC          },
    { IAT_BCC,          SYM_HDR_BCC         },
    { IAT_REPLYTO,      SYM_HDR_REPLYTO     },
    { IAT_RETURNPATH,   SYM_HDR_RETURNPATH  },
    { IAT_RETRCPTTO,    SYM_HDR_RETRCPTTO   },
    { IAT_RR,           SYM_HDR_RR          },
    { IAT_APPARTO,      SYM_HDR_APPARTO     },
    { IAT_DISP_NOTIFICATION_TO, SYM_HDR_DISP_NOTIFICATION_TO},
    { FLAG12,           NULL                },
    { FLAG13,           NULL                },
    { FLAG14,           NULL                },
    { FLAG15,           NULL                },
    { FLAG16,           NULL                },
    { FLAG17,           NULL                },
    { FLAG18,           NULL                },
    { FLAG19,           NULL                },
    { FLAG20,           NULL                },
    { FLAG21,           NULL                },
    { FLAG22,           NULL                },
    { FLAG23,           NULL                },
    { FLAG24,           NULL                },
    { FLAG25,           NULL                },
    { FLAG26,           NULL                },
    { FLAG27,           NULL                },
    { FLAG28,           NULL                },
    { FLAG29,           NULL                },
    { FLAG30,           NULL                },
    { FLAG31,           NULL                },
    { FLAG32,           NULL                }
};

// --------------------------------------------------------------------------------
// CPropertySymbolCache::CPropertySymbolCache
// --------------------------------------------------------------------------------
CPropertySymbolCache::CPropertySymbolCache(void)
{
    m_cRef = 1;
    m_dwNextPropId = PID_LAST;
    m_cSymbolsInit = 0;
    ZeroMemory(&m_rTable, sizeof(m_rTable));
    ZeroMemory(m_prgIndex, sizeof(m_prgIndex));
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::CPropertySymbolCache
// --------------------------------------------------------------------------------
CPropertySymbolCache::~CPropertySymbolCache(void)
{
    DebugTrace("MimeOLE - CPropertySymbolCache %d Symbols in Cache.\n", m_rTable.cSymbols);
    _FreeTableElements();
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimePropertySchema == riid)
        *ppv = (IMimePropertySchema *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropertySymbolCache::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropertySymbolCache::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::GetPropertyId
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::GetPropertyId(LPCSTR pszName, LPDWORD pdwPropId)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == pszName || NULL == pdwPropId)
        return TrapError(E_INVALIDARG);

    // Find the Property By Name
    CHECKHR(hr = HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Return the Id
    *pdwPropId = pSymbol->dwPropId;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::GetPropertyName
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::GetPropertyName(DWORD dwPropId, LPSTR *ppszName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == ppszName)
        return TrapError(E_INVALIDARG);

    // Find the Property By Name
    CHECKHR(hr = HrOpenSymbol(PIDTOSTR(dwPropId), FALSE, &pSymbol));

    // Return the Id
    CHECKALLOC(*ppszName = PszDupA(pSymbol->pszName));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::RegisterProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::RegisterProperty(LPCSTR pszName, DWORD dwFlags, 
    DWORD dwRowNumber, VARTYPE vtDefault, LPDWORD pdwPropId)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == pszName)
        return TrapError(E_INVALIDARG);

    // Is Supported VARTYPE
    if (ISSUPPORTEDVT(vtDefault) == FALSE)
        return TrapError(MIME_E_UNSUPPORTED_VARTYPE);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Validate the dwFlags
    CHECKHR(hr = HrIsValidPropFlags(dwFlags));

    // Already Exist ?
    CHECKHR(hr = _HrOpenSymbolWithLockOption(pszName, TRUE, &pSymbol,FALSE));

    // If MPF_ADDRESS flag is not equal to what the symbol already has, this is an error
    if (ISFLAGSET(dwFlags, MPF_ADDRESS) != ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Change the Flags
    pSymbol->dwFlags = dwFlags;

    // Change the row number
    pSymbol->dwRowNumber = ((dwRowNumber == 0) ? 1 : dwRowNumber);

    // Save the Default Data Type
    pSymbol->vtDefault = vtDefault;

    // Return the Property Id
    if (pdwPropId)
        *pdwPropId = pSymbol->dwPropId;

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::ModifyProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::ModifyProperty(LPCSTR pszName, DWORD dwFlags, DWORD dwRowNumber,
    VARTYPE vtDefault)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == pszName)
        return TrapError(E_INVALIDARG);

    // Is Supported VARTYPE
    if (ISSUPPORTEDVT(vtDefault) == FALSE)
        return TrapError(MIME_E_UNSUPPORTED_VARTYPE);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Validate the dwFlags
    CHECKHR(hr = HrIsValidPropFlags(dwFlags));

    // Find the Property By Name
    CHECKHR(hr = _HrOpenSymbolWithLockOption(pszName, FALSE, &pSymbol,FALSE));

    // If MPF_ADDRESS flag is not equal to what the symbol already has, this is an error
    if (ISFLAGSET(dwFlags, MPF_ADDRESS) != ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Change the Flags
    pSymbol->dwFlags = dwFlags;

    // Change the row number
    pSymbol->dwRowNumber = ((dwRowNumber == 0) ? 1 : dwRowNumber);

    // Save the Default Data Type
    pSymbol->vtDefault = vtDefault;

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::RegisterAddressType
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::RegisterAddressType(LPCSTR pszName, LPDWORD pdwAdrType)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == pszName || NULL == pdwAdrType)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Already Exist ?
    CHECKHR(hr = _HrOpenSymbolWithLockOption(pszName, TRUE, &pSymbol,FALSE));

    // If pSymbol already has an address type ?
    if (ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Better have a known address type
        Assert(IAT_UNKNOWN != pSymbol->dwAdrType);

        // Return the Address Type
        *pdwAdrType = pSymbol->dwAdrType;
    }
    
    // Otherwise
    else
    {
        // Better have an unknown address type
        Assert(IAT_UNKNOWN == pSymbol->dwAdrType);

        // Find the first empty cell in the address type table
        for (ULONG i=0; i<ARRAYSIZE(g_prgAddrSymbol); i++)
        {
            // Empty ?
            if (NULL == g_prgAddrSymbol[i].pSymbol)
            {
                // Put the symbol into the address table
                g_prgAddrSymbol[i].pSymbol = pSymbol;

                // Put the address type into the symbol
                pSymbol->dwAdrType = g_prgAddrSymbol[i].dwAdrType;

                // Add the MPF_ADDRESS flag onto the symbol
                FLAGSET(pSymbol->dwFlags, MPF_ADDRESS);

                // Return the Address Type
                *pdwAdrType = pSymbol->dwAdrType;

                // Done
                goto exit;
            }
        }

        // Error
        hr = TrapError(MIME_E_NO_MORE_ADDRESS_TYPES);
        goto exit;
    }

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::_FreeTableElements
// --------------------------------------------------------------------------------
void CPropertySymbolCache::_FreeTableElements(void)
{
    // Thread Safety
    m_lock.ExclusiveLock();
    
    // May not actually exist yet...
    if (m_rTable.prgpSymbol)
    {
        // Loop through the items...
        for (ULONG i=0; i<m_rTable.cSymbols; i++)
            _FreeSymbol(m_rTable.prgpSymbol[i]);

        // Free the array
        SafeMemFree(m_rTable.prgpSymbol);

        // Zero It
        ZeroMemory(&m_rTable, sizeof(SYMBOLTABLE));
    }

    // Thread Safety
    m_lock.ExclusiveUnlock();
}

// ---------------------------------------------------------------------------
// CPropertySymbolCache::_FreeSymbol
// ---------------------------------------------------------------------------
void CPropertySymbolCache::_FreeSymbol(LPPROPSYMBOL pSymbol)
{
    // If Not a Known Property, free the pTag Structure...
    if (pSymbol && ISFLAGSET(pSymbol->dwFlags, MPF_KNOWN) == FALSE)
    {
        // Free Property Name
        SafeMemFree(pSymbol->pszName);

        // Free Global Prop
        SafeMemFree(pSymbol);
    }
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::HrOpenSymbol
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::HrOpenSymbol(DWORD dwAdrType, LPPROPSYMBOL *ppSymbol)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dw=dwAdrType;
    ULONG       iAddress=0;

    // Invalid Arg
    Assert(dwAdrType && dwAdrType <= FLAG32);
    if (0 == dwAdrType || dwAdrType > FLAG32 || NULL == ppSymbol)
        return TrapError(E_INVALIDARG);

    // Init
    *ppSymbol = NULL;

    // Thread Safety
    m_lock.ShareLock();

    // Initialized Yet
    Assert(m_rTable.prgpSymbol);

    // Compute index into g_prgAddrSymbol
    while(dw)
    {
        dw = dw >> 1;
        iAddress++;
    }

    // Decrement one
    iAddress--;

    // iAddress Out of Range
    if (iAddress >= 32)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Get the Symbol
    if (NULL == g_prgAddrSymbol[iAddress].pSymbol)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Return it
    *ppSymbol = g_prgAddrSymbol[iAddress].pSymbol;
    Assert((*ppSymbol)->dwAdrType == dwAdrType);

exit:
    // Thread Safety
    m_lock.ShareUnlock();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::HrOpenSymbol
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::HrOpenSymbol(LPCSTR pszName, BOOL fCreate, LPPROPSYMBOL *ppSymbol)
{
    return(_HrOpenSymbolWithLockOption(pszName,fCreate,ppSymbol,TRUE)); //call with lockOption=TRUE
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::_HrOpenSymbolWithLockOption
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::_HrOpenSymbolWithLockOption(LPCSTR pszName, BOOL fCreate, LPPROPSYMBOL *ppSymbol,BOOL fLockOption)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwFlags;
    ULONG               cchName;
    LPPROPSYMBOL        pSymbol=NULL;
    LPPROPSYMBOL        pLink=NULL;
    BOOL                fExcLock; //flag used to define which unlock to use
    
    
    fExcLock = FALSE;

    // Invalid Arg
    if (NULL == pszName || NULL == ppSymbol)
        return TrapError(E_INVALIDARG);

    // Init
    *ppSymbol = NULL;

    if(TRUE == fLockOption)
        // Thread Safety
        m_lock.ShareLock();

    // Initialized Yet
    Assert(m_rTable.prgpSymbol);

    // If property tag exist, return it
    if (SUCCEEDED(_HrFindSymbol(pszName, ppSymbol)))
        goto exit;

    // Don't Create...
    if (FALSE == fCreate || ISPIDSTR(pszName))
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    //This part is added to convert the lock to Exclusive
    //if the symbol is not found in the cache
    
    if(TRUE == fLockOption)
    {
        fExcLock = TRUE; 
        if(FALSE == m_lock.SharedToExclusive())
        {
            //if the attempt at conversion does not
            //succeed tryu to do it by explicitly

            m_lock.ShareUnlock();       //Release the Sharelock before
            m_lock.ExclusiveLock();     //getting the exclusive lock

            //during the change of lock the cache might have changed
            //check it again

            if (SUCCEEDED(_HrFindSymbol(pszName, ppSymbol)))
                goto exit;
        }
    }      

    // Get the length of the name
    cchName = lstrlen(pszName);

    // MPF_PARAMETER
    if (StrCmpNI(pszName, "par:", 4) == 0)
    {
        // Its a parameter
        dwFlags = MPF_PARAMETER;

        // I need to locate pLink (the root header of this parameter)
        CHECKHR(hr = _HrGetParameterLinkSymbolWithLockOption(pszName, cchName, &pLink,FALSE));
    }

    // MPF_ATTRIBUTE
    else if (StrCmpNI(pszName, "att:", 4) == 0)
        dwFlags = MPF_ATTRIBUTE;

    // MPF_HEADER
    else
    {
        dwFlags = MPF_HEADER;

        // validate each character in the name against rfc (no :, or spaces)
        LPSTR psz = (LPSTR)pszName;
        while(*psz)
        {
            // Invalid Chars
            if ('.'  == *psz || ' '  == *psz || '\t' == *psz || chCR == *psz || chLF == *psz || ':' == *psz)
            {
                hr = MIME_E_INVALID_HEADER_NAME;
                goto exit;
            }

            // Next
            psz++;
        }
    }

    // Do I need to replace an item...
    if (m_rTable.cSymbols + 1 > m_rTable.cAlloc)
    {
        // Reallocate the array
        CHECKHR(hr = HrRealloc((LPVOID *)&m_rTable.prgpSymbol, sizeof(LPPROPSYMBOL) * (m_rTable.cAlloc +  10)));

        // Increment
        m_rTable.cAlloc += 10;
    }

    // Allocate a new propinfo struct
    CHECKALLOC(pSymbol = (LPPROPSYMBOL)g_pMalloc->Alloc(sizeof(PROPSYMBOL)));

    // Zero
    ZeroMemory(pSymbol, sizeof(PROPSYMBOL));

    // Copy Name
    CHECKALLOC(pSymbol->pszName = (LPSTR)g_pMalloc->Alloc(cchName + 1));

    // Copy
    CopyMemory(pSymbol->pszName, pszName, cchName + 1);

    // Copy Other Data
    pSymbol->cchName = cchName;
    pSymbol->dwFlags = dwFlags;
    pSymbol->dwSort = m_rTable.cSymbols;
    pSymbol->dwRowNumber = m_rTable.cSymbols + 1;
    pSymbol->vtDefault = VT_LPSTR;
    pSymbol->dwAdrType = IAT_UNKNOWN;
    pSymbol->pLink = pLink;

    // Compute the property Id
    pSymbol->dwPropId = m_dwNextPropId++;

    // Compute Hash Value
    pSymbol->wHashIndex = (WORD)(pSymbol->dwPropId % CBUCKETS);

    // Save item into array
    m_rTable.prgpSymbol[m_rTable.cSymbols] = pSymbol;

    // Increment count
    m_rTable.cSymbols++;

    // Resort the array
    _SortTableElements(0, m_rTable.cSymbols - 1);

    // Set Handle
    *ppSymbol = pSymbol;

    // Make sure we can still actually find it by property id
#ifdef DEBUG
    LPPROPSYMBOL pDebug;
    Assert(SUCCEEDED(_HrOpenSymbolWithLockOption(PIDTOSTR(pSymbol->dwPropId), FALSE, &pDebug,FALSE)));
#endif

exit:
    // Failure
    if (FAILED(hr) && pSymbol)
        _FreeSymbol(pSymbol);
     
    if(TRUE == fLockOption)
    {
        // Thread Safety
        if(TRUE==fExcLock)
            m_lock.ExclusiveUnlock();
        else
            m_lock.ShareUnlock();
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::_HrGetParameterLinkSymbol
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::_HrGetParameterLinkSymbol(LPCSTR pszName, ULONG cchName, LPPROPSYMBOL *ppSymbol)
{
    return(_HrGetParameterLinkSymbolWithLockOption(pszName,cchName,ppSymbol,TRUE)); //call with LockOption=TRUE
}


// --------------------------------------------------------------------------------
// CPropertySymbolCache::_HrGetParameterLinkSymbolWithLockOption
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::_HrGetParameterLinkSymbolWithLockOption(LPCSTR pszName, ULONG cchName, LPPROPSYMBOL *ppSymbol,BOOL fLockOption)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszStart;
    LPSTR           pszEnd;
    ULONG           cchHeader=0;

    // Invalid Arg
    Assert(pszName && ':' == pszName[3] && ppSymbol);

    // Stack String
    STACKSTRING_DEFINE(rHeader, 255);

    // Find first semicolon
    pszEnd = (LPSTR)(pszName + 4);
    while (*pszEnd && ':' != *pszEnd)
    {
        pszEnd++;
        cchHeader++;
    }

    // Set the name
    STACKSTRING_SETSIZE(rHeader, cchHeader+1);

    // Copy It
    CopyMemory(rHeader.pszVal, (LPBYTE)(pszName + 4), cchHeader);
    *(rHeader.pszVal + cchHeader) = '\0';

    // Find the Symbol
    CHECKHR(hr = _HrOpenSymbolWithLockOption(rHeader.pszVal, TRUE, ppSymbol,fLockOption));

exit:
    // Cleanup
    STACKSTRING_FREE(rHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::_HrFindSymbol
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::_HrFindSymbol(LPCSTR pszName, LPPROPSYMBOL *ppSymbol)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol=NULL;
    DWORD           dwPropId;

    // Invalid Arg
    Assert(ppSymbol);

    // If this is a known property tag...
    if (ISPIDSTR(pszName))
    {
        // Cast the dwPropId
        dwPropId = STRTOPID(pszName);

        // Set Symbol
        if (ISKNOWNPID(dwPropId))
        {
            // De-ref into known property index (ordered differently than g_prgKnownProps)
            pSymbol = m_prgIndex[dwPropId];
        }

        // Otherwise, must be an unknown pid index
        else
        {
            // I need to re-align dwPropId because it starts at PID_LAST and my not be a direct index
            // into the symbol table since the symbol table is not initialized with PID_LAST properties
            dwPropId -= (PID_LAST - ARRAYSIZE(g_prgKnownSymbol));

            // Must be >= PID_LAST and < m_rTable.cSymbols
            if (dwPropId >= m_cSymbolsInit && dwPropId < m_rTable.cSymbols)
            {
                // dwPropId is an index into the symbol table
                pSymbol = m_rTable.prgpSymbol[dwPropId];
                Assert(pSymbol);
            }

            // Else
            else
                AssertSz(FALSE, "How did you get an invalid unknown property id?");
        }
    }

    // Otherwise, look for it by name
    else
    {
        // Locals
        LONG   lUpper, lLower, lMiddle, nCompare;
        ULONG  i;

        // Set lLower and lUpper
        lLower = 0;
        lUpper = m_rTable.cSymbols - 1;

        // Do binary search / insert
        while (lLower <= lUpper)
        {
            // Compute middle record to compare against
            lMiddle = (LONG)((lLower + lUpper) / 2);

            // Get string to compare against
            i = m_rTable.prgpSymbol[lMiddle]->dwSort;

            // Do compare
            nCompare = OEMstrcmpi(pszName, m_rTable.prgpSymbol[i]->pszName);

            // If Equal, then were done
            if (nCompare == 0)
            {
                // Set Symbol
                pSymbol = m_rTable.prgpSymbol[i];

                // Done
                break;
            }

            // Compute upper and lower 
            if (nCompare > 0)
                lLower = lMiddle + 1;
            else 
                lUpper = lMiddle - 1;
        }       
    }

    // Not Found
    if (NULL == pSymbol)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Validate PropSymbol
    Assert(SUCCEEDED(HrIsValidSymbol(pSymbol)));

    // Otherwise...
    *ppSymbol = pSymbol;

exit:
    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CPropertySymbolCache::Init
// ---------------------------------------------------------------------------
HRESULT CPropertySymbolCache::Init(void)
{
    // Locals 
    HRESULT     hr=S_OK;
    ULONG       i;

    // We should not be initialized yet
    Assert(NULL == m_rTable.prgpSymbol);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Set Sizes
    m_rTable.cSymbols = ARRAYSIZE(g_prgKnownSymbol);
    m_rTable.cAlloc = m_rTable.cSymbols + 30;

    // Allocate the global item table
    CHECKHR(hr = HrAlloc((LPVOID *)&m_rTable.prgpSymbol, sizeof(LPPROPSYMBOL) * m_rTable.cAlloc));

    // Zero Init
    ZeroMemory(m_rTable.prgpSymbol, sizeof(LPPROPSYMBOL) * m_rTable.cAlloc);

    // Loop through known items
    for(i=0; i<m_rTable.cSymbols; i++)
    {
        // Just assume the global data pointer
        m_rTable.prgpSymbol[i] = g_prgKnownSymbol[i];

        // Set the sort position
        m_rTable.prgpSymbol[i]->dwSort = i;

        // Compute Hash Index
        m_rTable.prgpSymbol[i]->wHashIndex = (WORD)(m_rTable.prgpSymbol[i]->dwPropId % CBUCKETS);

        // Set the sort position
        m_rTable.prgpSymbol[i]->dwRowNumber = i + 1;

        // Put it into my index
        Assert(ISKNOWNPID(m_rTable.prgpSymbol[i]->dwPropId) == TRUE);

        // Put into symbol index
        m_prgIndex[m_rTable.prgpSymbol[i]->dwPropId] = m_rTable.prgpSymbol[i];
    }

    // Sort the item table...
    _SortTableElements(0, m_rTable.cSymbols - 1);

    // Save Number of Symbols initialised in the table
    m_cSymbolsInit = m_rTable.cSymbols;

    // Table Validation
#ifdef DEBUG
    LPPROPSYMBOL pDebug;

    // Lets validate the table
    for(i=0; i<m_rTable.cSymbols; i++)
    {
        // Validate pLink
        if (ISFLAGSET(m_rTable.prgpSymbol[i]->dwFlags, MPF_PARAMETER))
        {
            // Locals
            LPPROPSYMBOL pLink;

            // Look for the link symbol
            Assert(SUCCEEDED(_HrGetParameterLinkSymbolWithLockOption(m_rTable.prgpSymbol[i]->pszName, m_rTable.prgpSymbol[i]->cchName, &pLink,FALSE)));

            // Validate the the computed link with the const link
            Assert(pLink == m_rTable.prgpSymbol[i]->pLink);
        }

        // If this has an address flag
        if (ISFLAGSET(m_rTable.prgpSymbol[i]->dwFlags, MPF_ADDRESS))
        {
            // Locals
            ULONG       j;
            BOOL        f=FALSE;

            // Make sure it is in the address type table
            for (j=0; j<ARRAYSIZE(g_prgAddrSymbol); j++)
            {
                // Found It
                if (m_rTable.prgpSymbol[i] == g_prgAddrSymbol[j].pSymbol)
                {
                    f=TRUE;
                    break;
                }
            }

            // We better have found it
            AssertSz(f, "A symbol has the MPF_ADDRESS flag, but is not in the address table.");
        }

        // Make sure we can still actually find it by property id
        Assert(SUCCEEDED(_HrOpenSymbolWithLockOption(PIDTOSTR(m_rTable.prgpSymbol[i]->dwPropId), FALSE, &pDebug,FALSE)));
    }
#endif

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertySymbolCache::_SortTableElements
// -----------------------------------------------------------------------------
void CPropertySymbolCache::_SortTableElements(LONG left, LONG right)
{
    // Locals
    register    long i, j;
    DWORD       k, temp;

    i = left;
    j = right;
    k = m_rTable.prgpSymbol[(i + j) / 2]->dwSort;

    do  
    {
        while(OEMstrcmpi(m_rTable.prgpSymbol[m_rTable.prgpSymbol[i]->dwSort]->pszName, m_rTable.prgpSymbol[k]->pszName) < 0 && i < right)
            i++;
        while (OEMstrcmpi(m_rTable.prgpSymbol[m_rTable.prgpSymbol[j]->dwSort]->pszName, m_rTable.prgpSymbol[k]->pszName) > 0 && j > left)
            j--;

        if (i <= j)
        {
            temp = m_rTable.prgpSymbol[i]->dwSort;
            m_rTable.prgpSymbol[i]->dwSort = m_rTable.prgpSymbol[j]->dwSort;
            m_rTable.prgpSymbol[j]->dwSort = temp;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _SortTableElements(left, j);
    if (i < right)
        _SortTableElements(i, right);
}

// --------------------------------------------------------------------------------
// WGetHashTableIndex
// --------------------------------------------------------------------------------
WORD WGetHashTableIndex(LPCSTR pszName, ULONG cchName)
{
    // Locals
    ULONG   nHash=0;
    LONG    c, j=0;
    ULONG   i;
    CHAR    ch;

    // Invalid Arg
    Assert(pszName && pszName[cchName] =='\0');

    // Compute Number of characters to hash
    i = cchName - 1;
    c = min(3, cchName);

    // Loop
    for (; j<c; j++)
    {
        ch = (CHAR)CharLower((LPSTR)(DWORD_PTR)MAKELONG(pszName[i - j], 0));
        nHash += (ULONG)(ch);
    }

    // Done
    return (WORD)(nHash % CBUCKETS);
}

// --------------------------------------------------------------------------------
// HrIsValidSymbol
// --------------------------------------------------------------------------------
HRESULT HrIsValidSymbol(LPCPROPSYMBOL pSymbol)
{
    // Validate the symbol
    if (NULL == pSymbol || NULL == pSymbol->pszName || '\0' != pSymbol->pszName[pSymbol->cchName])
        return TrapError(E_FAIL);

    // Validate the flags
    return HrIsValidPropFlags(pSymbol->dwFlags);
}

// --------------------------------------------------------------------------------
// HrIsValidPropFlags
// --------------------------------------------------------------------------------
HRESULT HrIsValidPropFlags(DWORD dwFlags)
{
    // If has parameters, it can only be a mime header property
    if (ISFLAGSET(dwFlags, MPF_HASPARAMS) && (!ISFLAGSET(dwFlags, MPF_MIME) || !ISFLAGSET(dwFlags, MPF_HEADER)))
        return TrapError(MIME_E_INVALID_PROP_FLAGS);

    // If not inetcset, then rfc1522 better not be set either
    if (!ISFLAGSET(dwFlags, MPF_INETCSET) && ISFLAGSET(dwFlags, MPF_RFC1522))
        return TrapError(MIME_E_INVALID_PROP_FLAGS);

    // If rfc1522 is set, inetset better be set
    if (ISFLAGSET(dwFlags, MPF_RFC1522) && !ISFLAGSET(dwFlags, MPF_INETCSET))
        return TrapError(MIME_E_INVALID_PROP_FLAGS);

    // Is either MDF_ADDRESS or MDF_HASPARAMS    
    if (ISFLAGSET(dwFlags, MPF_ADDRESS) && ISFLAGSET(dwFlags, MPF_HASPARAMS))
        return TrapError(MIME_E_INVALID_PROP_FLAGS);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\stmlock.cpp ===
// --------------------------------------------------------------------------------
// Stmlock.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "stmlock.h"
#include "vstream.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
CStreamLockBytes::CStreamLockBytes(IStream *pStream)
{
    Assert(pStream);
    m_cRef = 1;
    m_pStream = pStream;
    m_pStream->AddRef();
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
CStreamLockBytes::~CStreamLockBytes(void)
{
    SafeRelease(m_pStream);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_ILockBytes == riid)
        *ppv = (ILockBytes *)this;
    else if (IID_CStreamLockBytes == riid)
        *ppv = (CStreamLockBytes *)this;
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStreamLockBytes::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStreamLockBytes::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::HrSetPosition
// --------------------------------------------------------------------------------
HRESULT CStreamLockBytes::HrSetPosition(ULARGE_INTEGER uliOffset)
{
    EnterCriticalSection(&m_cs);
    LARGE_INTEGER liOrigin;
    liOrigin.QuadPart = (DWORDLONG)uliOffset.QuadPart;
    HRESULT hr = m_pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::HrHandsOffStorage
// --------------------------------------------------------------------------------
HRESULT CStreamLockBytes::HrHandsOffStorage(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmNew=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If Reference Count Isn't 1 (i.e. owned by IMimeMessageTree), dup the internal data
    if (1 != m_cRef)
    {
        // Copy m_pStream to a local place...
        CHECKALLOC(pstmNew = new CVirtualStream);

        // Rewind Internal
        CHECKHR(hr = HrRewindStream(m_pStream));

        // Copy the stream
        CHECKHR(hr = HrCopyStream(m_pStream, pstmNew, NULL));

        // Rewind and commit
        CHECKHR(hr = pstmNew->Commit(STGC_DEFAULT));

        // Rewind
        CHECKHR(hr = HrRewindStream(pstmNew));

        // Replace Internal Stream
        ReplaceInternalStream(pstmNew);
    }
    
exit:
    // Cleanup
    SafeRelease(pstmNew);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CStreamLockBytes::GetCurrentStream
// -------------------------------------------------------------------------
void CStreamLockBytes::GetCurrentStream(IStream **ppStream) 
{
    EnterCriticalSection(&m_cs);
    Assert(ppStream && m_pStream);
    *ppStream = m_pStream;
    (*ppStream)->AddRef();
    LeaveCriticalSection(&m_cs);
}


// --------------------------------------------------------------------------------
// CStreamLockBytes::ReplaceInternalStream
// --------------------------------------------------------------------------------
void CStreamLockBytes::ReplaceInternalStream(IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Internal Strea ?
    if (NULL == m_pStream)
    {
        Assert(FALSE);
        goto exit;
    }

    // DEBUG: Make sure stream are EXACTLY the same size
#ifdef DEBUG
    ULONG cbInternal, cbExternal;
    HrGetStreamSize(m_pStream, &cbInternal);
    HrGetStreamSize(pStream, &cbExternal);
    Assert(cbInternal == cbExternal);
#endif

    // Release Internal
    m_pStream->Release();
    m_pStream = pStream;
    m_pStream->AddRef();
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::Flush
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::Flush(void)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->Commit(STGC_DEFAULT);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::LockRegion
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->LockRegion(libOffset, cb, dwLockType);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::UnlockRegion
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->LockRegion(libOffset, cb, dwLockType);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::ReadAt
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CStreamLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CStreamLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    LARGE_INTEGER liOrigin={ulOffset.LowPart, ulOffset.HighPart};
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (SUCCEEDED(hr))
        hr = m_pStream->Read(pv, cb, pcbRead);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::WriteAt
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CStreamLockBytes::WriteAt(ULARGE_INTEGER ulOffset, void const *pv, ULONG cb, ULONG *pcbWritten)
#else
STDMETHODIMP CStreamLockBytes::WriteAt(ULARGE_INTEGER ulOffset, void const HUGEP *pv, ULONG cb, ULONG *pcbWritten)
#endif // !WIN16
{
    LARGE_INTEGER liOrigin={ulOffset.LowPart, ulOffset.HighPart};
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (SUCCEEDED(hr))
        hr = m_pStream->Write(pv, cb, pcbWritten);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::SetSize
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::SetSize(ULARGE_INTEGER cb)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->SetSize(cb);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    // Locals
    HRESULT hr=S_OK;

    // Parameters
    if (NULL == pstatstg)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Zero Init
    ZeroMemory(pstatstg, sizeof(STATSTG));

    // Stat
    if (FAILED(m_pStream->Stat(pstatstg, grfStatFlag)))
    {
        // Locals
        ULARGE_INTEGER uliPos;
        LARGE_INTEGER  liOrigin;

        // Initialize
        uliPos.QuadPart = 0;
        liOrigin.QuadPart = 0;

        // If that failed, lets generate our own information (mainly, fill in size
        pstatstg->type = STGTY_LOCKBYTES;

        // Seek
        if (FAILED(m_pStream->Seek(liOrigin, STREAM_SEEK_END, &uliPos)))
            hr = E_FAIL;
        else
            pstatstg->cbSize.QuadPart = uliPos.QuadPart;
    }

    // URLMON Streams return a filled pwcsName event though this flag is set
    else if (ISFLAGSET(grfStatFlag, STATFLAG_NONAME))
    {
        // Free it
        SafeMemFree(pstatstg->pwcsName);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CLockedStream::CLockedStream
// -------------------------------------------------------------------------
CLockedStream::CLockedStream(ILockBytes *pLockBytes, ULONG cbSize)
{
    Assert(pLockBytes);
    m_cRef = 1;
    m_pLockBytes = pLockBytes;
    m_pLockBytes->AddRef();
    m_uliOffset.QuadPart = 0;
    m_uliSize.QuadPart = cbSize;
    InitializeCriticalSection(&m_cs);
}

// -------------------------------------------------------------------------
// CLockedStream::CLockedStream
// -------------------------------------------------------------------------
CLockedStream::~CLockedStream(void)
{
    SafeRelease(m_pLockBytes);
    DeleteCriticalSection(&m_cs);
}

// -------------------------------------------------------------------------
// CLockedStream::QueryInterface
// -------------------------------------------------------------------------
STDMETHODIMP CLockedStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CLockedStream::AddRef
// -------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLockedStream::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// -------------------------------------------------------------------------
// CLockedStream::Release
// -------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLockedStream::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// -------------------------------------------------------------------------
// CLockedStream::Read
// -------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CLockedStream::Read(LPVOID pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CLockedStream::Read(VOID HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    HRESULT hr=S_OK;
    ULONG cbRead;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Read Buffer
    CHECKHR(hr = m_pLockBytes->ReadAt(m_uliOffset, pv, cb, &cbRead));

    // Done
    m_uliOffset.QuadPart += cbRead;

    // Return amount read
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CLockedStream::Seek
// -------------------------------------------------------------------------
STDMETHODIMP CLockedStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    ULARGE_INTEGER  uliNew;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Seek the file pointer
    switch (dwOrigin)
    {
    // --------------------------------------------------------
   	case STREAM_SEEK_SET:
        uliNew.QuadPart = (DWORDLONG)dlibMove.QuadPart;
        break;

    // --------------------------------------------------------
    case STREAM_SEEK_CUR:
        if (dlibMove.QuadPart < 0)
        {
            if ((DWORDLONG)(0 - dlibMove.QuadPart) > m_uliOffset.QuadPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }
        }
        uliNew.QuadPart = m_uliOffset.QuadPart + dlibMove.QuadPart;
        break;

    // --------------------------------------------------------
    case STREAM_SEEK_END:
        if (dlibMove.QuadPart < 0 || (DWORDLONG)dlibMove.QuadPart > m_uliSize.QuadPart)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        uliNew.QuadPart = m_uliSize.QuadPart - dlibMove.QuadPart;
        break;

    // --------------------------------------------------------
    default:
        hr = TrapError(STG_E_INVALIDFUNCTION);
        goto exit;
    }

    // New offset greater than size...
    m_uliOffset.QuadPart = min(uliNew.QuadPart, m_uliSize.QuadPart);

    // Return Position
    if (plibNew)
        plibNew->QuadPart = (LONGLONG)m_uliOffset.QuadPart;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CLockedStream::CopyTo
// --------------------------------------------------------------------------------
STDMETHODIMP CLockedStream::CopyTo(LPSTREAM pstmDest, ULARGE_INTEGER cb, ULARGE_INTEGER *puliRead, ULARGE_INTEGER *puliWritten)
{
    return HrCopyStreamCB((IStream *)this, pstmDest, cb, puliRead, puliWritten);
}

// --------------------------------------------------------------------------------
// CLockedStream::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CLockedStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    // Parameters
    if (NULL == pstatstg)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If that failed, lets generate our own information (mainly, fill in size
    ZeroMemory(pstatstg, sizeof(STATSTG));
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.QuadPart = m_uliSize.QuadPart;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smime.cpp ===
/*
**  s m i m e . c p p
**
**  Purpose:
**      Implementation of a class to wrap around CAPI functionality
**
**  History
**      1/26/98  (brucek)   Allow multiple security layers (triple-wrapping)
**      6/15/97: (t-erikne) CAPI streaming
**      5/18/97: (t-erikne) new IMimeSecurity interface
**      2/07/97: (t-erikne) multipart/signed
**      1/06/97: (t-erikne) Moved into MimeOLE
**     11/14/96: (t-erikne) CAPI Post-SDR work
**      8/27/96: (t-erikne) Created.
**
**    Copyright (C) Microsoft Corp. 1996-1998.
*/

///////////////////////////////////////////////////////////////////////////
//
// Depends on
//

#include "pch.hxx"
#include "smime.h"
#include "vstream.h"
#include "olealloc.h"
#include "capistm.h"
#include "bookbody.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include <demand.h>

// from dllmain.h
extern CMimeAllocator * g_pMoleAlloc;
extern CRITICAL_SECTION g_csDllMain;
extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

extern HCERTSTORE WINAPI OpenCachedMyStore();
extern HCERTSTORE WINAPI OpenCachedAddressBookStore();

#define MST_THIS_SIGN_ENCRYPT           (MST_THIS_SIGN | MST_THIS_ENCRYPT)

///////////////////////////////////////////////////////////////////////////
//
// Static Prototypes
//

static void     _FreeCertArray(PCCERT_CONTEXT *rgpCert, const UINT cCerts);
static HRESULT  _HrConvertHrFromGetCertToEncode(HRESULT hr, const BOOL fEncrypt);
#ifndef SMIME_V3
static HRESULT ConstructAuthAttributes(BLOB * pblEncoded, BLOB * pblAuthAttr, FILETIME * pftSigntime, BLOB * pblSymcaps);
#endif // SMIME_V3
extern HRESULT HrCopyBlob(LPCBLOB pIn, LPBLOB pOut);
static LPBYTE DuplicateMemory(LPBYTE lpvIn, ULONG cbIn);

///////////////////////////////////////////////////////////////////////////
//
// Macros
//

#define CHECKSMIMEINITDW { if (FAILED(CheckInit())) return (DWORD)-1; }
#define CHECKSMIMEINITV  { if (FAILED(CheckInit())) return; }
#define CHECKSMIMEINITB  { if (FAILED(CheckInit())) return FALSE; }
#define CHECKSMIMEINIT   { if (FAILED(CheckInit())) return MIME_E_SECURITY_NOTINIT; }
#define SCHECKSMIMEINITP { if (FAILED(StaticCheckInit())) return NULL; }
#define SCHECKSMIMEINITV { if (FAILED(StaticCheckInit())) return; }
#define SCHECKSMIMEINIT  { if (FAILED(StaticCheckInit())) return MIME_E_SECURITY_NOTINIT; }
#define ALLOCED(_pv) \
        (0 != g_pMalloc->DidAlloc(_pv))

#define THIS_AS_UNK ((IUnknown *)(IStream *)this)

///////////////////////////////////////////////////////////////////////////
//
// Globals
//

ASSERTDATA

static const char s_szSMIMEP7s[] = "smime.p7s";
static const char s_szSMIMEP7m[] = "smime.p7m";

#ifdef DEBUG

static LPCSTR s_lpszCertStore = "c:\\ttfn\\debug.sto";

// emit signatures, encryption that should be broken
static BOOL s_fDebugEmitBroken      = 0;

// show the certificate found by HrGetUsableCert
static BOOL s_fDebugShowFoundCert   = 0;

// copy the message source to a BYTE *
static BOOL s_fDebugDumpWholeMsg    = 1;

// show/select certs w/o email oids
static BOOL s_fDebugAllowNoEmail    = 1;

#endif // DEBUG

static const char s_cszMy[]             = "My";
static const char s_cszWABCertStore[]   = "AddressBook";

CRYPT_ENCODE_PARA       CryptEncodeAlloc = {
    sizeof(CRYPT_ENCODE_PARA), CryptAllocFunc, CryptFreeFunc
};

CRYPT_DECODE_PARA       CryptDecodeAlloc = {
    sizeof(CRYPT_DECODE_PARA), CryptAllocFunc, CryptFreeFunc
};

///////////////////////////////////////////////////////////////////////////
//
// Initialization of statics to class
//

#ifdef MAC
EXTERN_C WINCRYPT32API HCERTSTORE WINAPI MacCertOpenStore(LPCSTR lpszStoreProvider,
                                                 DWORD dwEncodingType,
                                                 HCRYPTPROV hCryptProv,
                                                 DWORD dwFlags,
                                                 const void *pvPara);
#define CertOpenStore   MacCertOpenStore

// We don't have DLL's on the Mac, so let's just hardcode the vtable.
CAPIfuncs CSMime::ms_CAPI = {   CertEnumCertificatesInStore,
                                CertNameToStrA
                            };
#endif  // MAC

///////////////////////////////////////////////////////////////////////////
//
// inlines
//

INLINE void ReleaseCert(PCCERT_CONTEXT pc)
    { if (pc) CertFreeCertificateContext(pc); }

INLINE void ReleaseCertStore(HCERTSTORE hc)
    { if (hc) CertCloseStore(hc, 0); }

INLINE void FreeCert(PCCERT_CONTEXT pc)
    { CertFreeCertificateContext(pc); }

INLINE PCCERT_CONTEXT DupCert(const PCCERT_CONTEXT pc)
    { return CertDuplicateCertificateContext(pc); }

///////////////////////////////////////////////////////////////////////////
//
// ctor, dtor
//

CSMime::CSMime(void)
{
    DllAddRef();
    m_cRef  = 1;
    InitializeCriticalSection(&m_cs);
    DOUT("CSMIME::constructor() %#x -> %d", this, m_cRef);
}

CSMime::~CSMime()
{
    DOUT("CSMIME::destructor() %#x -> %d", this, m_cRef);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//

STDMETHODIMP CSMime::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimeSecurity *)this;
    else if (IID_IMimeSecurity == riid)
        *ppv = (IMimeSecurity *)this;
    else
        {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
        }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


STDMETHODIMP_(ULONG) CSMime::AddRef(void)
{
    DOUT("CSMime::AddRef() %#x -> %d", this, m_cRef+1);
    InterlockedIncrement((LPLONG)&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSMime::Release(void)
{
    DOUT("CSMime::Release() %#x -> %d", this, m_cRef-1);
    if (0 == InterlockedDecrement((LPLONG)&m_cRef))
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////
//
// Initialization functions
//

STDMETHODIMP CSMime::CheckInit(void)
{
    register BOOL f;

    EnterCriticalSection(&m_cs);
#ifdef MAC
    f = TRUE;
#else   // !MAC
    f = !!DemandLoadCrypt32();
#endif  // MAC
#ifdef DEBUG
    if(!f) {
        DebugStrf("CSMime not initialized ! ! !\n");
    }
#endif

    LeaveCriticalSection(&m_cs);
    return f ? S_OK : MIME_E_SECURITY_NOTINIT;
}

inline HRESULT CSMime::StaticCheckInit(void)
{
#ifdef MAC
    return S_OK;
#else   // !MAC
    HRESULT hr;

    if(DemandLoadCrypt32()) {
        hr = S_OK;
    }
    else {
#ifdef DEBUG
        DebugStrf("CSMime not initialized ! ! !\n");
#endif
        hr = MIME_E_SECURITY_NOTINIT;
    }
    return hr;
#endif  // MAC
}

/*  InitNew:
**
**  Purpose:
**      Called after the ctor by clients.  Initializes CSMime.
*/
STDMETHODIMP CSMime::InitNew(void)
{
    register HRESULT hr;

    EnterCriticalSection(&m_cs);
    hr = HrInitCAPI();

#ifdef DEBUG
    if (SUCCEEDED(hr))
#ifdef MAC
        InitDebugHelpers((HINSTANCE) 1);
#else   // !MAC
        InitDebugHelpers(/*g_hCryptoDll*/ (HINSTANCE) 1);
#endif  // MAC
    if (0) {
        DumpAlgorithms();
    }
    TrapError(hr);
#endif

    LeaveCriticalSection(&m_cs);
    if (E_FAIL == hr) {
        hr = MIME_E_SECURITY_NOTINIT;
    }
    return hr;
}

/*  InitCAPI:
**
**  Purpose:
**      Loads the required dll and inits the function table.
**  Returns:
**      MIME_E_SECURITY_LOADCRYPT32 if LoadLibrary fails
**      MIME_E_SECURITY_BADPROCADDR if any of the GetProcAddress calls fail
*/
HRESULT CSMime::HrInitCAPI()
{
#ifdef MAC
    return S_OK;
#else   // !MAC
    HRESULT     hr = S_OK;
    UINT        u = 0;
    FARPROC     *pVTable;

    EnterCriticalSection(&g_csDllMain);

    if (!DemandLoadCrypt32()) {
        hr = TrapError(MIME_E_SECURITY_LOADCRYPT32);
        goto ErrorReturn;
    }

exit:
    LeaveCriticalSection(&g_csDllMain);
    return hr;
ErrorReturn:
    {
    DWORD dwErr = GetLastError();
    UnloadCAPI();
    SetLastError(dwErr);
    Assert(S_OK != hr);
    }
    goto exit;
#endif  // MAC
}

/*  UnloadAll:
**
**  Purpose:
**      Called during deinit of our DLL to unload S/MIME
*/
void CSMime::UnloadAll(void)
{
    UnloadCAPI();
    return;
}

/*  UnloadCAPI:
**
**  Purpose:
**      Frees the crypt32 library.  Note that this will
**      cause subsequent CheckInit calls to fail
*/
void CSMime::UnloadCAPI()
{
}

///////////////////////////////////////////////////////////////////////////
//
// Encode/Decode stuff . . .
//
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
//
// Message crackers
//

#ifndef WIN16
HRESULT CSMime::GetMessageType(
    HWND                    hwndParent,
    IMimeBody *const        pBody,
    DWORD *const            pdwSecType)
#else
HRESULT CSMime::GetMessageType(
    const HWND              hwndParent,
    IMimeBody *const        pBody,
    DWORD *const            pdwSecType)
#endif // !WIN16
{
    return StaticGetMessageType(hwndParent, pBody, pdwSecType);
}

/*  StaticGetMessageType:
**
**  Purpose:
**      Used to figure out if a message is signed/encrypted/none/both
**      without doing any cryptographic operations.
**  Takes:
**      IN      hwndParent  - all modal UI to this
**      IN      pBody       - body to decode
**         OUT  dwSecType   - which, if any, S/MIME types have been applied
**  Notes:
**      if MIME_E_SECURITY_BADSECURETYPE is returned, pdwSecType is set
**      to the actual CMSG_ return from CAPI.
**      (7/10/97) MIME_E_SECURITY_BADSECURETYPE now comes from CAPISTM.
*/

HRESULT CSMime::StaticGetMessageType(
    HWND                    hwndParent,
    IMimeBody *const        pBody,
    DWORD *const            pdwSecType)
{
    HRESULT     hr;

//    SCHECKSMIMEINIT

    if (!(pBody && pdwSecType))
        return TrapError(E_INVALIDARG);

    CCAPIStm    capistmMsg(NULL);

    hr = capistmMsg.HrInitialize(0, hwndParent, FALSE, NULL, CSTM_TYPE_ONLY, NULL, NULL);
    if (SUCCEEDED(hr)) {
        IStream *       pstmCapi;
        PSECURITY_LAYER_DATA psld;

        capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);

#ifdef N_BAD1
        // This is what would happen if I were passed a stream
        // instead of a body

        LPSTREAM pstmBody;
        ULARGE_INTEGER  uliCopy;

        hr = pBody->GetData(IET_BINARY, &pstmBody);

        uliCopy.HighPart = (ULONG)-1;
        uliCopy.LowPart = (ULONG)-1;

        pstmBody->CopyTo(pstmCapi, uliCopy, NULL, NULL);
#else
        hr = pBody->GetDataHere(IET_BINARY, pstmCapi);
#endif

        // We expect CAPISTM_E_GOTTYPE because the streamer
        // fails its Write() as soon as it gets the type
        Assert(FAILED(hr));
        // However, try to get the data even if we succeeded.  That
        // would surprise me.

        // BUGBUG: Does this make sense?  We're only dealing with the outer layer here.
        if (psld = capistmMsg.GetSecurityLayerData()) {
            if (CAPISTM_E_GOTTYPE == hr) {
                hr = S_OK;
            }
            *pdwSecType = psld->m_dwMsgEnhancement;
            psld->Release();
        } else {
            hr = E_FAIL;
        }

        pstmCapi->Release();
        hr = capistmMsg.EndStreaming();
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////
//
// Encode methods
//


/*  EncodeMessage:
**
**  Purpose:
**      call EncodeBody for lazy developers
**  Takes:
**      IN pTree            - the tree of the message
**      IN dwFlags          - SEF_*
*/
STDMETHODIMP CSMime::EncodeMessage(
    IMimeMessageTree *const pTree,
    DWORD                   dwFlags)
{
    HRESULT hr;
    HBODY   hRoot;

    if (!pTree || (dwFlags & ~SEF_MASK)) {
        hr = TrapError(E_INVALIDARG);
    }
    else if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {
        hr = TrapError(EncodeBody(pTree, hRoot, dwFlags|EBF_RECURSE|EBF_COMMITIFDIRTY));
    }

    return hr;
}

HRESULT CSMime::EncodeMessage2(IMimeMessageTree *const pTree, DWORD dwFlags,
                               HWND hwnd)
{
    HRESULT hr;
    HBODY   hRoot;

    if (!pTree || (dwFlags & ~SEF_MASK)) {
        hr = TrapError(E_INVALIDARG);
    }
    else if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {
        hr = TrapError(EncodeBody2(pTree, hRoot, dwFlags|EBF_RECURSE|
                                  EBF_COMMITIFDIRTY, hwnd));
    }

    return hr;
}

/*  EncodeBody:
**
**  Purpose:
**      Do the entirety of the S/MIME encode operation.  This includes converting bodyoptions
**      to SMIMEINFO and calling the appropriate encoding subfunctions.
**
**  Takes:
**      IN pTree        - the tree of the body to encode
**      IN hEncodeRoot  - body from which to encode downward
**      IN dwFlags      - set of EBF_ or SEF_
*/

STDMETHODIMP CSMime::EncodeBody(
    IMimeMessageTree *const pTree,
    HBODY                   hEncodeRoot,
    DWORD                   dwFlags)
{
    HRESULT             hr;
    HWND                hwnd = NULL;
    IMimeBody *         pEncodeRoot = NULL;
    PROPVARIANT         var;

    if (! pTree || ! hEncodeRoot) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    //  Get the body we are suppose to be encoding
    CHECKHR(hr = pTree->BindToObject(hEncodeRoot, IID_IMimeBody, (void**)&pEncodeRoot));

#ifdef _WIN64
    if (SUCCEEDED(pEncodeRoot->GetOption(OID_SECURITY_HWND_OWNER_64, &var)) && (NULL != (HWND)(var.pulVal))) {
        Assert(VT_UI8 == var.vt);
        hwnd = *(HWND *)(&(var.uhVal));
    }
#else
    if (SUCCEEDED(pEncodeRoot->GetOption(OID_SECURITY_HWND_OWNER, &var)) && (NULL != var.ulVal)) 
    {
        Assert(VT_UI4 == var.vt);
        hwnd = (HWND)var.ulVal;
    }
#endif // _WIN64
    
    hr = EncodeBody2(pTree, hEncodeRoot, dwFlags, hwnd);

exit:
    ReleaseObj(pEncodeRoot);

    return hr;
}

HRESULT CSMime::EncodeBody2(IMimeMessageTree *const pTree, HBODY hEncodeRoot,
                            DWORD dwFlags, HWND hwnd)
{
    IMimeAddressTable *     pAdrTable = NULL;
    IMimeEnumAddressTypes * pAdrEnum = NULL;
    CVirtualStream *        pvstmEncoded = NULL;
    IMimeBody *             pEncodeRoot = NULL;
    HRESULT                 hr;
    SMIMEINFO               si;
    CERTARRAY               caCerts;
    BOOL                    fIgnoreSenderCertProbs;
    PSECURITY_LAYER_DATA    psldLoop;
    PROPVARIANT             var;

    memset(&si, 0, sizeof(si));
    memset(&caCerts, 0, sizeof(caCerts));

    if (! pTree || ! hEncodeRoot) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    //  Get the body we are suppose to be encoding
    CHECKHR(hr = pTree->BindToObject(hEncodeRoot, IID_IMimeBody, (void**)&pEncodeRoot));

    //  We are going to set the state to don't encode this body
    //  We we are called this should never be set to TRUE as we are getting explicity called.
    //  If it is true, then ignore it.
#ifdef DEBUG
    hr = pEncodeRoot->GetOption(OID_NOSECURITY_ONSAVE, &var);
    Assert((hr == S_OK) && (var.boolVal == FALSE));
#endif // DEBUG
    var.boolVal = TRUE;
    CHECKHR(hr = pEncodeRoot->SetOption(OID_NOSECURITY_ONSAVE, &var));
    hr = OptionsToSMIMEINFO(TRUE, pTree, pEncodeRoot, &si);
    if (S_OK != hr) {
        goto exit;
    }

    if (MIME_S_SECURITY_NOOP == hr) {
        SMDOUT("Encode body called on plain set.");
        goto exit;
    }
    if (EBF_RECURSE & dwFlags) {
        if (MST_DESCENDENT_MASK & si.dwMsgEnhancement) {
            AssertSz(0, "nyi: recursion.");
        }
    }
    if (MIME_S_SECURITY_RECURSEONLY == hr) {
        hr = MIME_S_SECURITY_NOOP;
        SMDOUT("Encode body called on plain body.");
        goto exit;
    }

    fIgnoreSenderCertProbs = (SEF_ENCRYPTWITHNOSENDERCERT|SEF_SENDERSCERTPROVIDED) & dwFlags;


    psldLoop = si.psldLayers;
    while (psldLoop) {
        //  Can only apply one of signing or encryption
        Assert(!!(psldLoop->m_dwMsgEnhancement & MST_THIS_SIGN) +
               !!(psldLoop->m_dwMsgEnhancement & MST_THIS_ENCRYPT) == 1);

        if (psldLoop->m_dwMsgEnhancement & MST_SIGN_MASK) {
            // 2nd attempt at finding a signing cert
            Assert(psldLoop->m_rgSigners != NULL);
            if (psldLoop->m_rgSigners[0].pccert == NULL) {
                CHECKHR(hr = HrGetNeededAddresses(IAT_FROM, pTree, &pAdrTable,
                                                  &pAdrEnum));

                hr = HrGetCertificates(pAdrTable, pAdrEnum, ITT_SIGNING, 
                                       fIgnoreSenderCertProbs, &caCerts);
                if (S_OK != hr) {
                    hr = _HrConvertHrFromGetCertToEncode(hr, FALSE);
                    Assert(FAILED(hr));
                    goto exit;
                }
                Assert(caCerts.rgpCerts);
                Assert(1 == caCerts.cCerts);

                // need the sender's cert listed a second time
                if (caCerts.rgpCerts[0]) {
                    psldLoop->m_rgSigners[0].pccert = DupCert(caCerts.rgpCerts[0]);
                }
            }
        }

        if (psldLoop->m_dwMsgEnhancement & MST_THIS_ENCRYPT) {
            Assert(! caCerts.rgpCerts);

            // 2nd place to look for encryption certs
            ReleaseObj(pAdrTable);
            ReleaseObj(pAdrEnum);
            // NOTE: Do NOT include IAT_REPLYTO in the needed addresses!

#ifdef SMIME_V3
            if (psldLoop->m_rgRecipientInfo == NULL) {
                hr = E_FAIL;
                Assert(FAILED(hr));
                goto exit;
            }
#else  // !SMIME_V3
            if (psldLoop->m_rgEncryptItems == NULL) {
                hr = HrGetNeededAddresses(IAT_FROM | IAT_TO | IAT_CC | IAT_BCC | IAT_SENDER, pTree, &pAdrTable, &pAdrEnum);

                if (SUCCEEDED(hr)) {
                    DWORD i;
                    DWORD dexBogus; // the index into certResults of the NULL sender's cert
                    
                    hr = HrGetCertificates(pAdrTable, pAdrEnum, ITT_ENCRYPTION, 
                                           fIgnoreSenderCertProbs, &caCerts);
                
                    //
                    // Outlook98 doesn't pass us an address table, all of the certs 
                    // are already in the SMIMEINFO struct.  So if we're told that the
                    // sender certs are provided, and we don't have any certificates 
                    // from the table, we just continue.  We'll fail properly
                    // in the zero certificate case down below.
                    //
                
                    if ((S_OK != hr) &&
                        !((MIME_S_SECURITY_NOOP == hr) &&
                          ((fIgnoreSenderCertProbs & SEF_SENDERSCERTPROVIDED) != 0))) {
                        hr = _HrConvertHrFromGetCertToEncode(hr, TRUE);
                        Assert(FAILED(hr));
                        goto exit;
                    }

                    if (caCerts.cCerts == 0) {
                        hr = TrapError(MIME_E_SECURITY_NOCERT);
                        goto exit;
                    }
                        
                    // just reference the certResults as the encryption array
                    Assert(0 == psldLoop->m_cEncryptItems);
                    if (!MemAlloc((LPVOID *) &psldLoop->m_rgEncryptItems,
                                  sizeof(EncryptItem))) {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                    psldLoop->m_cEncryptItems = 1;
                    psldLoop->m_rgEncryptItems[0].dwTagType = ENCRYPT_ITEM_TRANSPORT;
                    psldLoop->m_rgEncryptItems[0].Transport.cCert = caCerts.cCerts;
                    psldLoop->m_rgEncryptItems[0].Transport.rgpccert = caCerts.rgpCerts;
                    psldLoop->m_rgEncryptItems[0].Transport.blobAlg.pBlobData = NULL;
                    psldLoop->m_rgEncryptItems[0].Transport.blobAlg.cbSize = 0;
                    caCerts.rgpCerts = NULL;            // we're holding it in the layer now
                    // Encryption algorithm
                    if (SUCCEEDED(pEncodeRoot->GetOption(OID_SECURITY_ALG_BULK, &var)) &&
                        (0 != var.blob.cbSize)) {
                        Assert(VT_BLOB == var.vt);
                        psldLoop->m_rgEncryptItems[0].Transport.blobAlg.pBlobData = var.blob.pBlobData;
                        psldLoop->m_rgEncryptItems[0].Transport.blobAlg.cbSize = var.blob.cbSize;
                    }
                }
            }
            else {
                if (!fIgnoreSenderCertProbs) {
                    hr = TrapError(MIME_E_SECURITY_ENCRYPTNOSENDERCERT);
                    goto exit;
                }
            }
#endif // SMIME_V3
        }   // encryption

        // Clean up cert array for next round
        if (caCerts.rgpCerts) {
            _FreeCertArray(caCerts.rgpCerts, caCerts.cCerts);
            caCerts.rgpCerts = NULL;
        }

        psldLoop = psldLoop->m_psldInner;
    }


    if (!(pvstmEncoded = new CVirtualStream)) {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    if (FClearSign(si.dwMsgEnhancement)) {
        if (FEncrypt(si.dwMsgEnhancement)) {
            si.dwMsgEnhancement |= MST_BLOB_FLAG;
            CHECKHR(hr = HrEncodeOpaque(&si, pTree, hEncodeRoot, pEncodeRoot, pvstmEncoded, hwnd));
        }
        else {
            CHECKHR(hr = HrEncodeClearSigned(&si, pTree, hEncodeRoot, pEncodeRoot,
                pvstmEncoded, (dwFlags & EBF_COMMITIFDIRTY), hwnd));
            //  Since this went multi-part, the root body changed on us and we need to get
            //  it back
            pEncodeRoot->Release();
            CHECKHR(hr = pTree->BindToObject(hEncodeRoot, IID_IMimeBody,
                                             (void**)&pEncodeRoot));
        }
    }
    else {
        // encryption and/or signedData signature
        CHECKHR(hr = HrEncodeOpaque(&si, pTree, hEncodeRoot, pEncodeRoot, pvstmEncoded, hwnd));
    }

CommonReturn:
    if (pEncodeRoot != NULL)
        {
            var.boolVal = FALSE;
            pEncodeRoot->SetOption(OID_NOSECURITY_ONSAVE, &var);
        }

    ReleaseObj(pAdrTable);
    ReleaseObj(pAdrEnum);
    ReleaseObj(pvstmEncoded);
    ReleaseObj(pEncodeRoot);
    FreeSMIMEINFO(&si);
    return hr;
exit:
    // these objects are only need attention on error
    _FreeCertArray(caCerts.rgpCerts, caCerts.cCerts);
    goto CommonReturn;
}

/*  HrEncodeClearSigned:
**
**  Purpose:
**      Builds the multipart message needed for clear signing and
**      retrieves the data stream to pass to the stream wrapepr.
**  Takes:
**      IN      psi         - needs the certificate array, signing
**                          certificate, etc.
**      IN      pTree       - tree containing body to convert to m/s
**      IN      pEncodeRoot - body that will become 1st child of the m/s
**          OUT lpstmOut    - contains the signature bits (PKCS#7 nodata)
**  Returns:
**      hresult.  no function-specific return values.
*/

HRESULT CSMime::HrEncodeClearSigned(
    SMIMEINFO *const        psi,
    IMimeMessageTree *const pTree,
    const HBODY             hEncodeRoot,
    IMimeBody *const        pEncodeRoot,
    LPSTREAM                lpstmOut,
    BOOL                    fCommit,
    HWND                    hwnd)
{
    HBODY           hNew, hSignature, hData;
    HRESULT         hr;
    HRESULT         hr_smime = S_OK;
    DWORD           i;
    IMimeBody *     pSig = NULL;
    IMimeBody *     pMS = NULL;
    IMimeBody *     pData = NULL;
    IMimeBody *     pRoot = NULL;
    IStream *       pstmMsg = NULL;
    BODYOFFSETS     boData;
    LARGE_INTEGER   liPos;
    PROPVARIANT     var;
#ifdef DEBUG
    BLOB            blobMsg = {NULL,0};
#endif
    ULARGE_INTEGER  uliCopy;
    ALG_ID          aid;
    const char *    lpszProtocol;
    CCAPIStm        capistmMsg(lpstmOut);

    // We need lpstmOut because it is the media of transmission for
    // the signature.  The sig body gets it through SetData

    Assert(psi && hEncodeRoot && pEncodeRoot && pTree && lpstmOut);

    CHECKHR(hr = pTree->ToMultipart(hEncodeRoot, STR_SUB_SIGNED, &hNew));

    if (fCommit) {
        BOOL fCleanup;

        // Need to commit the tree, but if Tonja cleans it, I'll lose my
        // multipart.  So, turn off cleaning and save the value to set back.
        CHECKHR(hr = pTree->GetOption(OID_CLEANUP_TREE_ON_SAVE, &var));
        fCleanup    = var.boolVal ? TRUE : FALSE;
        var.boolVal = FALSE;
        CHECKHR(hr = pTree->SetOption(OID_CLEANUP_TREE_ON_SAVE, &var));
        CHECKHR(hr = pTree->Commit(COMMIT_SMIMETRANSFERENCODE));
        var.boolVal = (VARIANT_BOOL) !!fCleanup;
        pTree->SetOption(OID_CLEANUP_TREE_ON_SAVE, &var);
    }

    CHECKHR(hr = pTree->GetBody(IBL_FIRST, hNew, &hData));
    CHECKHR(hr = pTree->BindToObject(hData, IID_IMimeBody, (LPVOID *)&pData));
    CHECKHR(hr = pData->GetOffsets(&boData));

    // BUG 38411:  I need a clean pristine virginal-white stream
    // so we have to go straight to the horse's smelly mouth.
    CHECKHR(hr = pTree->GetMessageSource(&pstmMsg, 0));

#if defined(DEBUG) && !defined(MAC)
    if (s_fDebugDumpWholeMsg) {
        hr = HrStreamToByte(pstmMsg, &blobMsg.pBlobData, &blobMsg.cbSize);
        HrRewindStream(pstmMsg);
    }
#endif

    // Now slice out the part we actually want
    liPos.HighPart = 0;
    liPos.LowPart = boData.cbHeaderStart;
    CHECKHR(hr = pstmMsg->Seek(liPos, STREAM_SEEK_SET, NULL));

    CHECKHR(hr = capistmMsg.HrInitialize(0, hwnd, TRUE, psi, CSTM_DETACHED, NULL, psi->psldInner));
    if (SUCCEEDED(hr)) {
        IStream *pstmCapi;

        uliCopy.HighPart = 0;
        uliCopy.LowPart = boData.cbBodyEnd-boData.cbHeaderStart;
        capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);
        hr = pstmMsg->CopyTo(pstmCapi, uliCopy, NULL, NULL);
        pstmCapi->Release();
        CHECKHR(hr = capistmMsg.EndStreaming());
    }

    CHECKHR(hr = pTree->InsertBody(IBL_LAST, hNew, &hSignature));
    CHECKHR(hr = pTree->BindToObject(hSignature, IID_IMimeBody, (void**)&pSig));
    CHECKHR(hr = pSig->SetData(IET_BINARY, STR_CNT_APPLICATION,
      STR_SUB_XPKCS7SIG, IID_IStream, (void*)lpstmOut));
    if (-1 != psi->ietRequested) {
        var.vt = VT_UI4;
        var.ulVal = psi->ietRequested;
        pSig->SetOption(OID_TRANSMIT_BODY_ENCODING, &var);
    }

    // Set the properties for the signature blob as in S/MIGv2 3.3
    var.vt = VT_LPSTR;
    var.pszVal = (LPSTR)STR_DIS_ATTACHMENT;
    CHECKHR(hr = pSig->SetProp(PIDTOSTR(PID_HDR_CNTDISP), 0, &var));

    var.pszVal = (char *)s_szSMIMEP7s;
    pSig->SetProp(PIDTOSTR(PID_PAR_FILENAME), 0, &var);
    pSig->SetProp(PIDTOSTR(PID_PAR_NAME), 0, &var);

    // Set the parameters on the m/s root as in rfc1847 2.1
    CHECKHR(hr = pTree->BindToObject(hNew, IID_IMimeBody, (void**)&pMS));

    var.pszVal = (char *)STR_MIME_APPL_PKCS7SIG;
    CHECKHR(hr = pMS->SetProp(STR_PAR_PROTOCOL, 0, &var));

    // Get the HASH algorithm.  Note that we should NOT get a multi-layer
    // message with Multipart/Signed so we should not have to worry about
    // what layer this is for.
    Assert(psi->psldLayers);
    Assert(psi->psldLayers->m_psldInner == NULL);
    Assert(psi->psldLayers->m_cSigners > 0);
    Assert(psi->psldLayers->m_rgSigners != NULL);
    if (psi->psldLayers->m_cSigners == 0) {
        hr = E_INVALIDARG;
        goto exit;
    }

    lpszProtocol = "unknown";
    // M00BUG -- should add these together and remove duplicates
    for (i=0; i<psi->psldLayers->m_cSigners; i++) {
        hr = MimeOleAlgNameFromSMimeCap(psi->psldLayers->m_rgSigners[i].blobHashAlg.pBlobData,
                                        psi->psldLayers->m_rgSigners[i].blobHashAlg.cbSize,
                                        &lpszProtocol);
    }
    
    var.pszVal = (LPSTR)lpszProtocol;
    CHECKHR(hr = pMS->SetProp(STR_PAR_MICALG, 0, &var));

    var.ulVal = 0;
    CHECKHR(hr = pTree->BindToObject(HBODY_ROOT, IID_IMimeBody, (void**)&pRoot));
    SideAssert(SUCCEEDED(pRoot->SetOption(OID_SECURITY_SIGNATURE_COUNT, &var)));
    SideAssert(SUCCEEDED(pRoot->SetOption(OID_SECURITY_TYPE, &var)));

exit:
#ifdef DEBUG
    if (blobMsg.pBlobData) {
        MemFree(blobMsg.pBlobData);
    }
#endif
    ReleaseObj(pRoot);
    ReleaseObj(pSig);
    ReleaseObj(pData);
    ReleaseObj(pMS);
    ReleaseObj(pstmMsg);
    if (FAILED(hr) && hNew) {
        // need to undo the multipartization and delete the sig body
        // errors are not as important as the one that has already occured
        if (hSignature) {
            pTree->DeleteBody(hSignature, 0);
        }
        pTree->DeleteBody(hNew, DELETE_PROMOTE_CHILDREN);
    }
    if (S_OK != hr_smime && SUCCEEDED(hr)) {
        hr = hr_smime;
    }
    return hr;
}

/*  HrEncodeOpaque:
**
**  Purpose:
**
**  Takes:
**      IN      psi         - needs signing cert,
**                            certificate array (opt)
**      IN      pTree       - the normal tree baggage
**      IN      hEncodeRoot - the tree likes handles
**      IN      pEncodeRoot - body to begin encoding at
**         OUT  lpstmOut    - contains the PKCS#7 message
*/
HRESULT CSMime::HrEncodeOpaque(
    SMIMEINFO *const    psi,
    IMimeMessageTree *  pTree,
    HBODY               hEncodeRoot,
    IMimeBody *         pEncodeRoot,
    LPSTREAM            lpstmOut,
    HWND                hwnd)
{
    HRESULT             hr;
    HRESULT             hrCAPI = S_OK;
    CCAPIStm            capistmMsg(lpstmOut);
    IMimePropertySet   *pFullProp = NULL, *pBodyProp = NULL;

    hr = capistmMsg.HrInitialize(0, hwnd, TRUE, psi, 0, NULL, psi->psldInner);
#ifdef INTEROP2
    //N8 This is one half of the fix to do headers correctly
    // In the inner, no 822 headers, just MIME
    // See another N8 comment for the other half, which is to
    // have the outer 822's merged with the inner's MIME headers
    // on decode
    if (SUCCEEDED(hr)) {
        hr = pEncodeRoot->BindToObject(IID_IMimePropertySet, (LPVOID *)&pBodyProp);
    }
    if (SUCCEEDED(hr)) {
        hr = pBodyProp->Clone(&pFullProp);
    }
    if (SUCCEEDED(hr)) {
        LPCSTR  rgszHdrKeep[] = {
            PIDTOSTR(PID_HDR_CNTTYPE),
            PIDTOSTR(PID_HDR_CNTXFER),
            PIDTOSTR(PID_HDR_CNTID),
            PIDTOSTR(PID_HDR_CNTDESC),
            PIDTOSTR(PID_HDR_CNTDISP),
            PIDTOSTR(PID_HDR_CNTBASE),
            PIDTOSTR(PID_HDR_CNTLOC),
            };

        hr = pBodyProp->DeleteExcept(ARRAYSIZE(rgszHdrKeep), rgszHdrKeep);
#endif
        if (SUCCEEDED(hr)) {
            IStream *pstmCapi;

            capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);
            hr = pTree->SaveBody(hEncodeRoot, 0, pstmCapi);

#if defined(DEBUG) && !defined(MAC)
            if (s_fDebugDumpWholeMsg) {
                BYTE *pb;
                DWORD cb;

                if (SUCCEEDED(HrStreamToByte(lpstmOut, &pb, &cb))) {
                    MemFree(pb);
                }
            }
#endif
            pstmCapi->Release();
            hrCAPI = capistmMsg.EndStreaming();
            if (SUCCEEDED(hr)) {    // hr from the SaveBody takes precedence
                hr = hrCAPI;
            }
        }
#ifdef INTEROP2
    }
#endif

    if (SUCCEEDED(hr)) {
        PROPVARIANT     var;
        
        pTree->DeleteBody(hEncodeRoot, DELETE_CHILDREN_ONLY);
        pEncodeRoot->EmptyData();

        var.ulVal = 0;
        SideAssert(SUCCEEDED(pEncodeRoot->SetOption(OID_SECURITY_TYPE, &var)));
        SideAssert(SUCCEEDED(pEncodeRoot->SetOption(OID_SECURITY_SIGNATURE_COUNT, &var)));

#ifdef INTEROP2
        // reset the propset
        pFullProp->CopyProps(0, NULL, pBodyProp);
#endif

        //QPTEST DebugDumpStreamToFile(lpstmOut, "c:\\hexin.bin");

        hr = pEncodeRoot->SetData(IET_BINARY, STR_CNT_APPLICATION,
          STR_SUB_XPKCS7MIME, IID_IStream, (void*)lpstmOut);

        if (SUCCEEDED(hr)) {
            PROPVARIANT var;

            var.vt = VT_UI4;
            if (-1 != psi->ietRequested) {
                var.ulVal = psi->ietRequested;
            }
            else {
                var.ulVal = IET_BASE64;
            }
            pEncodeRoot->SetOption(OID_TRANSMIT_BODY_ENCODING, &var);

            // Set the properties for the opaque blob as in S/MIGv2 3.3
            var.vt = VT_LPSTR;
            var.pszVal = (LPSTR)STR_DIS_ATTACHMENT;
            pEncodeRoot->SetProp(PIDTOSTR(PID_HDR_CNTDISP), 0, &var);

            var.pszVal = (LPSTR)s_szSMIMEP7m;
            pEncodeRoot->SetProp(PIDTOSTR(PID_PAR_FILENAME), 0, &var);
            pEncodeRoot->SetProp(PIDTOSTR(PID_PAR_NAME), 0, &var);

            if (FEncrypt(psi->dwMsgEnhancement))
                {
                var.pszVal = (LPSTR) STR_SMT_ENVELOPEDDATA;
                }
            else
                {
#ifdef SMIME_V3
                if ((psi->pszInnerContent != NULL) &&
                    (strcmp(psi->pszInnerContent, szOID_SMIME_ContentType_Receipt) == 0))
                    {
                    var.pszVal = (LPSTR) STR_SMT_SIGNEDRECEIPT;
                    }
                else 
                    {
                    var.pszVal = (LPSTR) STR_SMT_SIGNEDDATA;
                    }
#else  // !SMIME_V3
                var.pszVal = (LPSTR) STR_SMT_SIGNEDDATA;
#endif // SMIME_V3
                }
            pEncodeRoot->SetProp(STR_PAR_SMIMETYPE, 0, &var);
        }
    }

    ReleaseObj(pFullProp);
    ReleaseObj(pBodyProp);
    return hr;
}


///////////////////////////////////////////////////////////////////////////
//
// Decode methods
//

/*  DecodeMessage:
**
**  Purpose:
**      To rip the shroud of secrecy from a message, leaving it naked in the
**      harsh light of dawning comprehension.  However, this function hides
**      the unsightly goings-on that accomplish this task, simply returning
**      a radically different tree
**  Takes:
**      IN pTree            - the message's tree
**      IN dwFlags          - expansion.  must be 0
**  Returns:
**      a variety of good and bad responses
*/
HRESULT CSMime::DecodeMessage(
    IMimeMessageTree *const pTree,
    DWORD                   dwFlags)
{
    HRESULT             hr;
    HBODY               hRoot;
    HWND                hwnd = NULL;
    IMimeBody *         pDecodeRoot = NULL;
    PROPVARIANT         var;

    if (!pTree || (dwFlags & ~SEF_MASK)) {
        return TrapError(E_INVALIDARG);
    }

    if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {

        CHECKHR(hr = pTree->BindToObject(hRoot, IID_IMimeBody, (void**)&pDecodeRoot));
        
#ifdef _WIN64
        if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HWND_OWNER_64, &var)) &&
            (NULL != (HWND)(var.pulVal)))
            {
            Assert(VT_UI8 == var.vt);
            hwnd = *(HWND *)(&(var.uhVal));
            }
#else
        if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HWND_OWNER, &var)) &&
            (NULL != var.ulVal)) 
            {
                Assert(VT_UI4 == var.vt);
                hwnd = (HWND)var.ulVal;
            }
#endif // _WIN64
    
        hr = TrapError(DecodeBody2(pTree, hRoot, dwFlags|EBF_RECURSE, NULL,
                                   hwnd, NULL));
    }

exit:
    ReleaseObj(pDecodeRoot);

    return hr;
}

HRESULT CSMime::DecodeMessage2(IMimeMessageTree *const pTree, DWORD dwFlags,
                               HWND hwnd, IMimeSecurityCallback * pCallback)
{
    HRESULT hr;
    HBODY   hRoot;

    if (!pTree || (dwFlags & ~SEF_MASK)) {
        return TrapError(E_INVALIDARG);
    }

    if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {
        hr = TrapError(DecodeBody2(pTree, hRoot, dwFlags|EBF_RECURSE, NULL,
                                   hwnd, pCallback));
    }

    return hr;
}

/*  DecodeBody:
**
**  Purpose:
**      Do the entirety of the S/MIME decode operation.
**
**  Takes:
**      IN pTree        - the tree of the body to decode
**      IN hEncodeRoot  - body from which to decode downward
**      IN dwFlags      - set of DBF_ or SDF_
*/
HRESULT CSMime::DecodeBody(
    IMimeMessageTree *const pTree,
    HBODY                   hDecodeRoot,
    DWORD                   dwFlags)
{
    return DecodeBody(pTree, hDecodeRoot, dwFlags, NULL);
}

/*  DecodeBody:
**
**  Purpose:
**      The X-rated version of the released (interface) copy.  This
**      one can tell if it has been recursed and merge the data.
**
**  Takes:
**      all the scenes of the original film plus:
**      IN psiOuterOp   - SMIMEINFO from the outer operation
**                      Note that this doesn't really mean
**                      subbodys or messages, but nested S/MIME.
**                      Simplest case is clearsigned in encryption.
*/
HRESULT CSMime::DecodeBody(
    IMimeMessageTree *const pTree,
    HBODY                   hDecodeRoot,
    DWORD                   dwFlags,
    SMIMEINFO *             psiOuterOp)
{
    HRESULT             hr;
    HWND                hwnd = NULL;
    IMimeBody *         pDecodeRoot = NULL;
    PROPVARIANT         var;

    if (! pTree || ! hDecodeRoot) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    //  Get the body we are suppose to be encoding
    CHECKHR(hr = pTree->BindToObject(hDecodeRoot, IID_IMimeBody, (void**)&pDecodeRoot));

#ifdef _WIN64
    if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HWND_OWNER_64, &var)) && (NULL != (HWND)(var.pulVal))) {
        Assert(VT_UI8 == var.vt);
        hwnd = *(HWND *)(&(var.uhVal));
    }
#else
    if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HWND_OWNER, &var)) && (NULL != var.ulVal)) 
    {
        Assert(VT_UI4 == var.vt);
        hwnd = (HWND)var.ulVal;
    }
#endif // _WIN6
    
    hr = DecodeBody2(pTree, hDecodeRoot, dwFlags, psiOuterOp, hwnd, NULL);

exit:
    ReleaseObj(pDecodeRoot);

    return hr;
}

HRESULT CSMime::DecodeBody2(
    IMimeMessageTree *const pTree,
    HBODY                   hDecodeRoot,
    DWORD                   dwFlags,
    SMIMEINFO *             psiOuterOp,
    HWND                    hwnd,
    IMimeSecurityCallback * pCallback)
{
    PROPVARIANT         var;
    IMimeBody *         pData;
    IMimeBody *         pDecodeRoot = NULL;
    HRESULT             hr, hr_smime = S_OK;
    HBODY               hSignature, hData;
    SMIMEINFO           si;
    CVirtualStream *    pvstmDecoded = NULL;
    IStream *           pstmMsg = NULL;

    if (!(pTree && hDecodeRoot)) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    //
    //  Get the body we are going to decode
    //
    
    CHECKHR(hr = pTree->BindToObject(hDecodeRoot, IID_IMimeBody, (void**)&pDecodeRoot));

    memset(&si, 0, sizeof(SMIMEINFO));
    OptionsToSMIMEINFO(FALSE, pTree, pDecodeRoot, &si);

    //
    //  If we know what crypt provider to use, then grab it
    //

#ifndef _WIN64    
    if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HCRYPTPROV, &var)) &&
            (NULL != var.ulVal)) 
    {
        Assert(VT_UI4 == var.vt);
        si.hProv = var.ulVal;
    }
#else // _WIN64
    if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HCRYPTPROV_64, &var)) &&
            (NULL != var.pulVal)) 
    {
        Assert(VT_UI8 == var.vt);
        si.hProv = (HCRYPTPROV) var.pulVal;
    }

#endif //_WIN64
    //
    //  Determine if this is a multi-part signed message, if so then do the appropriate
    //  decoding.  Determined by "content-type: multipart/signed; protocol=pkcs7-signature"
    //
    
    if (S_OK == pDecodeRoot->IsContentType(STR_CNT_MULTIPART, STR_SUB_SIGNED) &&
        IsSMimeProtocol(pDecodeRoot)) {
        
        CHECKHR(hr = pTree->GetBody(IBL_FIRST, hDecodeRoot, &hData));
        CHECKHR(hr = pTree->GetBody(IBL_LAST, hDecodeRoot, &hSignature));
        if FAILED(hr_smime = HrDecodeClearSigned(dwFlags, &si, pTree, hData,
                                                 hSignature, hwnd, pCallback)) {
            goto exit;
        }

        // now we need to make the message readable.  get rid of the signature
        // blob.  this will leave the m/s with one child, the message data.
        // delete the parent with DELETE_PROMOTE_CHILDREN and this will
        // kick the data body up as the only remaining body.
        pTree->DeleteBody(hSignature, 0);
        pTree->DeleteBody(hDecodeRoot, DELETE_PROMOTE_CHILDREN);
        pTree->Commit(0);
    }
    //
    //  Determine if this is a blob signed or encrypted message.  If it is then
    //  do the appropriate decoding.
    //
    
    else if (S_OK == pDecodeRoot->IsContentType(STR_CNT_APPLICATION, STR_SUB_XPKCS7MIME) ||
             S_OK == pDecodeRoot->IsContentType(STR_CNT_APPLICATION, STR_SUB_PKCS7MIME)) {
        
        //
        //  Create the stream to hold the decoded mime body
        //
    
        if (!(pvstmDecoded = new CVirtualStream)) {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        //
        //  Do the actual decode of the message.  This produces the decode stream in
        //      pvstmDecode.
        //

        if (FAILED(hr_smime = HrDecodeOpaque(dwFlags, &si, pDecodeRoot,
                                             pvstmDecoded, hwnd, pCallback))) {
            goto exit;
        }

        // Header bug fix:
        // we need to blow away the subtree below this body
        // however, we have to keep the 822 headers around. This option
        // change does this, mostly.  the EmptyData call removes
        // some of the body's properties, most notably the content-*
        // ones.  when I use RELOAD_HEADER_REPLACE, the inner body
        // will blow away any of the overlapping outer headers, but
        // keep the ones that don't exist.
        //
        // Why did I do this?
        // Deming doesn't put a from: line in the #7 signedData.  We
        // shoudln't either.  Now we don't.  Without this fix, this
        // would prevent us from being able to add to WAB because
        // the address table would be empty.

        CHECKHR(hr = pTree->DeleteBody(hDecodeRoot, DELETE_CHILDREN_ONLY));
        CHECKHR(hr = pDecodeRoot->EmptyData());

        ULONG ulOldval;
        pTree->GetOption(OID_HEADER_RELOAD_TYPE, &var);
        Assert(VT_UI4 == var.vt);
        ulOldval = var.ulVal;
        var.ulVal = RELOAD_HEADER_REPLACE;
        pTree->SetOption(OID_HEADER_RELOAD_TYPE, &var);

        //
        //  Load the decoded message back into the message so that we can have the
        //      decrypted message.
        //
        
        CHECKHR(hr = pTree->Load(pvstmDecoded));

        var.ulVal = ulOldval;
        pTree->SetOption(OID_HEADER_RELOAD_TYPE, &var);

        //
        //  Grab the root node -- this is where we are going to put the info relative
        //      to the decryption/decoding we just did.
        //
        
        CHECKHR(hr = pTree->GetBody(IBL_ROOT, NULL, &hData));
    }
    else {
        hr = MIME_S_SECURITY_NOOP;
        goto exit;
    }

    // now, this could be way cool and actually have another S/MIME part inside
    // The most common case is a clear signed message inside of encryption, but
    // others could occur.
    // Recurse!

    {
        HBODY   hRoot;

        if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {
            hr = TrapError(DecodeBody2(pTree, hRoot, dwFlags|EBF_RECURSE, &si,
                                       hwnd, pCallback));
        }

        CHECKHR(hr);
    }

    if (hr == MIME_S_SECURITY_NOOP) {
        hr = S_OK;
    }
    else {
        hData = HBODY_ROOT;
    }

    //
    //  If this is the root of the decode, then we move the decryption information back
    //  into the message we are dealing with.  If this is not the root then merge together
    //  the S/MIME info structure from the caller.
    //
    
    if (psiOuterOp == NULL) {
        hr = SMIMEINFOToOptions(pTree, &si, hData);
    }
    else {
        hr = MergeSMIMEINFO(psiOuterOp, &si);
    }
    Assert(SUCCEEDED(hr));

exit:
    ReleaseObj(pDecodeRoot);
    ReleaseObj(pstmMsg);
    ReleaseObj(pvstmDecoded);
    FreeSMIMEINFO(&si);
    if (S_OK != hr_smime && SUCCEEDED(hr)) {
        hr = (MIME_E_SECURITY_NOOP == hr_smime) ? MIME_S_SECURITY_NOOP : hr_smime;
    }

    return TrapError(hr);
}

/*  HrDecodeOpaque:
**
**  Purpose:
**
**  Takes:
**
**
*/

HRESULT CSMime::HrDecodeOpaque(DWORD dwFlags,
    SMIMEINFO *const    psi,
    IMimeBody *const    pBody,
    IStream *const      pstmOut,
    HWND                hwnd,
                               IMimeSecurityCallback * pCallback)
{
    HRESULT     hr;
    CCAPIStm    capistmMsg(pstmOut);

    hr = capistmMsg.HrInitialize(dwFlags, hwnd, FALSE, psi, 0, pCallback, NULL);
    if (SUCCEEDED(hr)) {
        IStream *       pstmCapi;
        HCRYPTMSG       hMsg;

        //QPTEST hr = pBody->GetDataHere(IET_BINARY, pstmOut);
        //QPTEST DebugDumpStreamToFile(pstmOut, "c:\\stmout.bin");
        //QPTEST HrRewindStream(pstmOut);

        capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);
        hr = pBody->GetDataHere(IET_BINARY, pstmCapi);
        pstmCapi->Release();
        if (FAILED(hr)) goto exit;
        CHECKHR(hr = capistmMsg.EndStreaming());

#if defined(DEBUG) && !defined(MAC)
        if (s_fDebugDumpWholeMsg) {
            BYTE *pb;
            DWORD cb;

            if (SUCCEEDED(HrStreamToByte(pstmOut, &pb, &cb))) {
                MemFree(pb);
            }
        }
#endif

        hr = CAPISTMtoSMIMEINFO(&capistmMsg, psi);
    }
exit:
    return hr;
}

/*  HrDecodeClearSigned:
**
**  Purpose:
**      Reform the signed body to be hashed and extract the signature
**      data.  Pass these through to the interface stream method.
**  Takes:
**      IN      dwFlags     - Control Flags for the decode
**      IN OUT  psi         - passed to DecodeDetachedStream
**      IN      pTree       - tree to get message source from
**      IN      hData       - handle to body with signed data
**      IN      hSig        - handle to body with signature
**  Returns:
**      hresult.  no function-specific return values.
*/

HRESULT CSMime::HrDecodeClearSigned(DWORD dwFlags,
    SMIMEINFO *const        psi,
    IMimeMessageTree *const pTree,
    const HBODY             hData,
    const HBODY             hSig,
    HWND                    hwnd, IMimeSecurityCallback * pCallback)
{
    HRESULT         hr, hr_smime=S_OK;
    IMimeBody      *pData = NULL,
                   *pSig = NULL;
    IStream        *pstmSig,
                   *pstmMsg = NULL;
    BODYOFFSETS     boData;
    LARGE_INTEGER   liPos;
    ULARGE_INTEGER  uliToCopy;
    CVirtualStream *pvstmDecoded = NULL;
    CCAPIStm        capistmMsg(NULL);
#ifdef DEBUG
    BLOB            blobMsg = {NULL,0};
#endif

    CHECKHR(hr = pTree->BindToObject(hData, IID_IMimeBody, (void**)&pData));
    CHECKHR(hr = pData->GetOffsets(&boData));

    // BUG 38411:  I need a clean pristine virginal-white stream
    // so we have to go straight to the horse's smelly mouth.

    CHECKHR(hr = pTree->GetMessageSource(&pstmMsg, 0));
#if defined(DEBUG) && !defined(MAC)
    if (s_fDebugDumpWholeMsg) {
        CHECKHR (hr = HrStreamToByte(pstmMsg, &blobMsg.pBlobData, &blobMsg.cbSize));
        HrRewindStream(pstmMsg);
    }
#endif

    // Compute the portion we want of the mondo stream
    liPos.HighPart = 0;
    liPos.LowPart = boData.cbHeaderStart;
    CHECKHR(hr = pstmMsg->Seek(liPos, STREAM_SEEK_SET, NULL));

    hr = capistmMsg.HrInitialize(dwFlags, hwnd, FALSE, psi, CSTM_DETACHED, pCallback, NULL);
    if (SUCCEEDED(hr)) {
        IStream *pstmCapi;

        capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);

        // Get the signature data and feed it in
        hr = pTree->BindToObject(hSig, IID_IMimeBody, (void**)&pSig);
        if (SUCCEEDED(hr)) {
            hr = pSig->GetDataHere(IET_BINARY, pstmCapi);
            if (SUCCEEDED(hr)) {
                hr = capistmMsg.EndStreaming();
            }
        }

        uliToCopy.HighPart = 0;
        uliToCopy.LowPart = boData.cbBodyEnd-boData.cbHeaderStart;

        // Now feed in the actual data to hash
        if (SUCCEEDED(hr)) {
            hr = pstmMsg->CopyTo(pstmCapi, uliToCopy, NULL, NULL);
        }
        
        if (SUCCEEDED(hr)) {
            hr = capistmMsg.EndStreaming();
        }

        if (SUCCEEDED(hr)) {
            hr = CAPISTMtoSMIMEINFO(&capistmMsg, psi);
        }

        pstmCapi->Release();
    }

exit:
    ReleaseObj(pData);
    ReleaseObj(pSig);
    ReleaseObj(pstmMsg);
#ifdef DEBUG
    if (blobMsg.pBlobData) {
        MemFree(blobMsg.pBlobData);
    }
#endif
    if (S_OK != hr_smime && SUCCEEDED(hr)) {
        hr = hr_smime;
    }
    return hr;
}

HRESULT CSMime::CAPISTMtoSMIMEINFO(CCAPIStm *pcapistm, SMIMEINFO *psi)
{
    DWORD               i;
    PSECURITY_LAYER_DATA psldMessage = pcapistm->GetSecurityLayerData();

    psi->dwMsgEnhancement = MST_NONE;
    psi->ulMsgValidity = MSV_OK;

#ifdef DEBUG
    {
        DWORD dwLevel = 0;
        PSECURITY_LAYER_DATA psldLoop;

        psldLoop = psldMessage;
        if (psldLoop) {
            SMDOUT("Decode called on:");
        }
        else {
            SMDOUT("Decode called but the message data is NULL.");
        }

        dwLevel = 0;
        while (psldLoop) {
            for (DWORD i = 0; i <= dwLevel; i++) {
                DebugTrace("     ");
            }

            if (MST_BLOB_FLAG & psldLoop->m_dwMsgEnhancement) {
                SMDOUT("CMSG_SIGNED");
            }
            else if ((MST_THIS_SIGN | MST_THIS_ENCRYPT) ==
              ((MST_THIS_SIGN | MST_THIS_ENCRYPT) & psldLoop->m_dwMsgEnhancement)) {
                SMDOUT("CMSG_SIGNED_AND_ENVELOPED, uhoh.");
            }
            else if (MST_THIS_SIGN & psldLoop->m_dwMsgEnhancement) {
                SMDOUT("clear signed mail");
            }
            else if (MST_THIS_ENCRYPT & psldLoop->m_dwMsgEnhancement) {
                SMDOUT("CMSG_ENVELOPED");
            }
            dwLevel++;
            psldLoop = psldLoop->m_psldInner;
        }
    }
#endif

    if (psldMessage) {
        PSECURITY_LAYER_DATA psldLoop;

        Assert(0 == psi->dwMsgEnhancement);
        Assert(0 == psi->ulMsgValidity);
        Assert(NULL == psi->psldLayers);
        Assert(NULL == psi->psldEncrypt);
        Assert(NULL == psi->psldInner);

        psi->psldLayers = psldMessage;
        psi->psldLayers->AddRef();

        for (psldLoop = psldMessage; psldLoop != NULL; 
             psldLoop = psldLoop->m_psldInner) {
            
            psi->dwMsgEnhancement |= psldLoop->m_dwMsgEnhancement;
            psi->fCertWithMsg |= psldLoop->m_fCertInLayer;
            if (MST_THIS_SIGN & psldLoop->m_dwMsgEnhancement) {
                for (i=0; i<psldLoop->m_cSigners; i++) {
                    psi->ulMsgValidity |= psldLoop->m_rgSigners[i].ulValidity;
                }
            }

            //
            //  We need to get the inner most encryption item here.
            //
            
            if (MST_THIS_ENCRYPT & psldLoop->m_dwMsgEnhancement) {
                psi->ulMsgValidity |= psldLoop->m_ulDecValidity;

                // Keep track of the innermost encryption layer for easy access

                psi->psldEncrypt = psldLoop;
            }

            if (! psldLoop->m_psldInner) {
                psi->psldInner = psldLoop;
            }

        }
        CCAPIStm::FreeSecurityLayerData(psldMessage);
    }

    // need to handle this stuff again
    //hr = MIME_E_SECURITY_CANTDECRYPT;
    //case CMSG_SIGNED_AND_ENVELOPED:
    //case CMSG_DATA:
    //default:
    //hr = MIME_E_SECURITY_UNKMSGTYPE;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// Crytographic transformations... functions that do the real work
//
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
//
// Signature verification and decryption
//


///////////////////////////////////////////////////////////////////////////
//
// Other function sets
//
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
//

// Other certificate routines
//


/*  GetCertificateName:
**
**  Purpose:
**
**  Takes:
**      IN pX509Cert    - certificate from which to snarf name
**      IN cn           - style of name to return (SIMPLE|OID|X500)
**      OUT ppszName    - name gets stuffed here.  Caller frees.
**  Returns:
**      hresult
*/
STDMETHODIMP CSMime::GetCertificateName(
    const PCX509CERT    pX509Cert,
    const CERTNAMETYPE  cn,
    LPSTR *             ppszName)
{
    DWORD   flag, cch;
    HRESULT hr;

    CHECKSMIMEINIT
    if (!(pX509Cert && ppszName)) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // convert to CAPI flag
    switch (cn) {
        case SIMPLE:
            flag = CERT_SIMPLE_NAME_STR;
            break;
        case OID:
            flag = CERT_OID_NAME_STR;
            break;
        case X500:
            flag = CERT_X500_NAME_STR;
            break;
        default:
            hr = TrapError(E_INVALIDARG);
            goto exit;
    }

#define pCert ((PCCERT_CONTEXT)pX509Cert)
    cch = CertNameToStr(pCert->dwCertEncodingType, &pCert->pCertInfo->Subject,
        flag, NULL, 0);
    CHECKHR(hr = HrAlloc((void**)ppszName, cch*sizeof(TCHAR)));
    CertNameToStr(pCert->dwCertEncodingType, &pCert->pCertInfo->Subject,
      flag|CERT_NAME_STR_SEMICOLON_FLAG, *ppszName, cch);
#undef pCert

exit:
    return hr;
}

/*  HrGetCertsFromThumbprints:
**
**  Purpose:
**      This version of the function opens the "My" and "AddressBook" stores
**      and calls the exposed GetCertsFromThumbprints method.
**
*/
HRESULT CSMime::HrGetCertsFromThumbprints(
    THUMBBLOB *const        rgThumbprint,
    X509CERTRESULT *const   pResults)
{
    HRESULT     hr = E_FAIL;
    const DWORD cStores = 2;
    HCERTSTORE  rgCertStore[cStores];

    rgCertStore[0] = OpenCachedMyStore();
    if (rgCertStore[0]) {
        rgCertStore[1] = OpenCachedAddressBookStore();
        if (rgCertStore[1]) {
            hr = MimeOleGetCertsFromThumbprints(rgThumbprint, pResults, rgCertStore, cStores);
            CertCloseStore(rgCertStore[1], 0);
        }
        else {
            // No WAB store, so there are NO matching certs
            CRDOUT("No thumbprints in WAB");
            for (ULONG iEntry = 0; iEntry < pResults->cEntries; iEntry++) {
                pResults->rgpCert[iEntry] = NULL;
                pResults->rgcs[iEntry] = CERTIFICATE_NOPRINT;
            }
            hr = MIME_S_SECURITY_ERROROCCURED;
        }
        CertCloseStore(rgCertStore[0], 0);
    }

    return hr;
}

/*  EnumCertificates:
**
**  Purpose:
**      enumerate certificates from a store
**  Takes:
**      IN hc       - store to query
**      IN dwUsage  - ITT_* or 0
**                      maps to a CAPI dwKeyUsage (AT_*)
**      IN pPrev    - last certificate received from this function
**                      (NULL to get first cert)
**      OUT pCert   - certificate next in enumeration
**  Notes:
**      pPrev and pCert may reference the same variable
**      dwUsage may be 0 if caller just wants to check for existance of any certs
**  Returns:
**      CRYPT_E_NOT_FOUND if no more certs
**      S_FALSE if dwUsage is 0 and no certs exist
*/
STDMETHODIMP CSMime::EnumCertificates(
    HCAPICERTSTORE  hc,
    DWORD           dwUsage,
    PCX509CERT      pPrev,
    PCX509CERT *    ppCert)
{
    HRESULT         hr;
    PCCERT_CONTEXT  pNewCert = NULL;

    CHECKSMIMEINIT
    if (!(hc && (ppCert || !dwUsage))) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    if (ITT_SIGNING == dwUsage || ITT_ENCRYPTION == dwUsage) {
        dwUsage = AT_KEYEXCHANGE;
        hr = HrFindUsableCert((HCERTSTORE)hc, (BYTE)dwUsage, (PCCERT_CONTEXT)pPrev, &pNewCert);
    }
    else if (0 == dwUsage) {
        pNewCert = CertEnumCertificatesInStore(hc, NULL);
        if (pNewCert) {
            hr = S_OK;
            FreeCert(pNewCert);
        }
        else {
            hr = S_FALSE;
        }
    }
    else {
        hr = TrapError(E_INVALIDARG);
    }

exit:
    if (ppCert) {
        *ppCert = (PCX509CERT)pNewCert;
    }
    return hr;
}

/*  HrGetLastError
**
**  Purpose:
**      Convert a GetLastError value to an HRESULT
**      A failure HRESULT must have the high bit set.
**
**  Takes:
**      none
**
**  Returns:
**      HRESULT
*/
HRESULT HrGetLastError(void)
{
    DWORD error;
    HRESULT hr;

    error = GetLastError();

    if (!(error & 0x80000000)) {
        hr = error | 0x80070000;    // system error
    } else {
        hr = (HRESULT)error;
    }

    return(hr);
}

/*  HrFindUsableCert:
**
**  Purpose:
**      Get a cert out of a cert store that has the right keyspec
**  Takes:
**      IN hCertStore   - store to enumerate
**      IN dwKeySpec    - AT_SIGNATURE or AT_KEYEXCHANGE
**      IN pPrevCert    - last certificate received from this function
**                          (NULL to get first cert)
**      OUT ppCert      - the matching cert, NULL iff none
**  Returns:
**      SMIME_E_NOCERT if no cert can be found
*/
HRESULT CSMime::HrFindUsableCert(
    HCERTSTORE      hCertStore,
    BYTE            dwKeySpec,
    PCCERT_CONTEXT  pPrevCert,
    PCCERT_CONTEXT *ppCert)
{
    PCCERT_CONTEXT          pCert;
    PCRYPT_KEY_PROV_INFO    pKPI;
    HRESULT                 hr = S_OK;
    BOOL                    fFound = FALSE;
    PCERT_NAME_INFO         pNameInfo;
    PCERT_RDN_ATTR          pRDNAttr;
#ifdef DEBUG
    DWORD                   count=0;
#endif
    LPTSTR                  lpEmailAddress;

    CHECKSMIMEINIT
    Assert(hCertStore && ppCert);
    Assert(AT_SIGNATURE == dwKeySpec || AT_KEYEXCHANGE == dwKeySpec);

    *ppCert = NULL;
    pKPI = NULL;
    while (!fFound) {
        pCert = CertEnumCertificatesInStore(hCertStore, pPrevCert);
        if (pCert == NULL) { // no more certs?
            break;
        }

        // Need to find the key provider
        pKPI = (PCRYPT_KEY_PROV_INFO)PVGetCertificateParam(pCert, CERT_KEY_PROV_INFO_PROP_ID, NULL);
#ifdef DEBUG
        count++;

        // We want to be able to send broken mail so that the
        // verify/decrypt fails.
        if (s_fDebugEmitBroken) {
            if (pKPI && pKPI->dwKeySpec != dwKeySpec) fFound = TRUE;
        }
        else {
            if (pKPI && pKPI->dwKeySpec == dwKeySpec) fFound = TRUE;
        }
#else
        if (pKPI && pKPI->dwKeySpec == dwKeySpec)  {
            fFound = TRUE;
        }
#endif

        // Validate the email address
        if (fFound && (lpEmailAddress = SzGetCertificateEmailAddress(pCert))) {
            MemFree(lpEmailAddress);
        }
        else {
#ifdef DEBUG
            {
                SMDOUT("Certificate %d has no email address", count);
                if (fFound && !s_fDebugAllowNoEmail) {
                    fFound = FALSE;
                }
            }
#else
            fFound = FALSE;
#endif
        }


        if (pKPI) {
            MemFree(pKPI);
            pKPI = NULL;
        }
        pPrevCert = pCert;  // next enumeration round
    }  // enum

    if (pCert == NULL) {
        CRDOUT("Couldn't find a signature cert having a key provider");
        hr = HrGetLastError();
        if (hr == CRYPT_E_NOT_FOUND) {
            hr = S_FALSE;
        }
        else {
            hr = MIME_E_SECURITY_NOCERT;
        }
    }
#ifdef DEBUG
    else {
        CRDOUT("Usable cert #%d found with keyspec==%d", count, dwKeySpec);
        Assert(pCert);
        if (s_fDebugShowFoundCert) {
            DisplayCert(pCert);
        }
    }
#endif

    *ppCert = pCert;
    return TrapError(hr);
}

///////////////////////////////////////////////////////////////////////////
//
// Other functions
//
///////////////////////////////////////////////////////////////////////////


/*  HrGetNeededAddresses:
**
**  Purpose:
**      get the maximum set of addresses needed for S/MIME to work
**  Takes:
**      IN dwTypes      - class(es) of addresses to get
**      IN pTree        - source of addresses
**      OUT ppEnum      - enumerator for found addresses
*/
HRESULT CSMime::HrGetNeededAddresses(
    const DWORD             dwTypes,
    IMimeMessageTree *      pTree,
    IMimeAddressTable **    ppAdrTable,
    IMimeEnumAddressTypes **ppEnum)
{
    HRESULT         hr;

    Assert(ppEnum && ppAdrTable && pTree);

    if (SUCCEEDED(hr = pTree->BindToObject(HBODY_ROOT, IID_IMimeAddressTable, (void**)ppAdrTable))) {
        hr = (*ppAdrTable)->EnumTypes(dwTypes,
          IAP_HANDLE | IAP_ADRTYPE | IAP_SIGNING_PRINT | IAP_ENCRYPTION_PRINT | IAP_CERTSTATE, ppEnum);
    }
    return hr;
}

/*  HrGetThumbprints:
**
**  Purpose:
**
**  Takes:
**      IN pEnum            - enumerator walked for source addresses
**      IN dwType           - which SECURE-type certs are needed
**      OUT rgThumbprint    - array of found thumbprints
**  Returns:
**      S_OK, unless a GetProp call fails
**      E_FAIL if the loop doesn't run for Count times
*/
HRESULT CSMime::HrGetThumbprints(
    IMimeEnumAddressTypes * pEnum,
    const ITHUMBPRINTTYPE   ittType,
    THUMBBLOB *const        rgThumbprint)
{
    HRESULT             hr = S_OK;
    ADDRESSPROPS        apEntry;
    const ULONG         numToGet = 1;
    ULONG               cPrints = 0;

    Assert(pEnum && rgThumbprint);
    Assert((ITT_SIGNING == ittType) || (ITT_ENCRYPTION == ittType));
    Assert(!IsBadWritePtr(rgThumbprint, sizeof(THUMBBLOB)*cPrints));

    pEnum->Reset();
    while(S_OK == pEnum->Next(numToGet, &apEntry, NULL)) {
        // if the print isn't found, we deal with that elsewhere
        if (ITT_SIGNING == ittType) {
            Assert((apEntry.tbSigning.pBlobData && apEntry.tbSigning.cbSize) ||
                  (!apEntry.tbSigning.pBlobData && !apEntry.tbSigning.cbSize));
            if (apEntry.tbSigning.cbSize) {
                // we need to null out the thumbprint flag so print doesn't get
                // freed below
                rgThumbprint[cPrints].pBlobData = apEntry.tbSigning.pBlobData;
                rgThumbprint[cPrints].cbSize = apEntry.tbSigning.cbSize;
                apEntry.dwProps &= ~IAP_SIGNING_PRINT;
            }
        }
        else {
            Assert(ITT_ENCRYPTION == ittType);
            Assert((apEntry.tbEncryption.pBlobData && apEntry.tbEncryption.cbSize) ||
                  (!apEntry.tbEncryption.pBlobData && !apEntry.tbEncryption.cbSize));
            if (apEntry.tbEncryption.cbSize) {
                // we need to null out the thumbprint flag so print doesn't get
                // freed below
                rgThumbprint[cPrints].pBlobData = apEntry.tbEncryption.pBlobData;
                rgThumbprint[cPrints].cbSize = apEntry.tbEncryption.cbSize;
                apEntry.dwProps &= ~IAP_ENCRYPTION_PRINT;
            }
        }
        cPrints++;

        g_pMoleAlloc->FreeAddressProps(&apEntry);
    }

    return hr;
}

/*  HrGetCertificates:
**
**  Purpose:
**      Get certificates based from thumbprints, then update the address
**      table based on the return of that operation
**  Takes:
**      IN pEnum        - enumerator that provides the thumbprints
**      IN dwType       - which certs are needed
**      IN fAlreadyHaveSendersCert - if the sender's cert is already found
**      OUT pResults    - get an array of certs and the assoc certstates
**                        pResults->cEntries has the size measured in entries
**  Returns:
**      SMIME_E_CERTERROR if not all certs were retrieved
*/
HRESULT CSMime::HrGetCertificates(
    IMimeAddressTable *const    pAdrTable,
    IMimeEnumAddressTypes *     pEnum,
    const DWORD                 dwType,
    const BOOL                  fAlreadyHaveSendersCert,
    CERTARRAY *                 pcaCerts)
{
    HRESULT         hr;
    THUMBBLOB *     rgThumbprint;
    ULONG           cCerts;
    X509CERTRESULT  certResults;

    Assert(pAdrTable && pEnum && pcaCerts);

    pcaCerts->rgpCerts = NULL;
    pcaCerts->cCerts = 0;

    pEnum->Count(&cCerts);
    if (! cCerts) {
        return MIME_S_SECURITY_NOOP;
    }

    if (! MemAlloc((void**)&rgThumbprint, sizeof(THUMBBLOB)*cCerts)) {
        return E_OUTOFMEMORY;
    }
    memset(rgThumbprint, 0, sizeof(THUMBBLOB)*cCerts);
    if (! MemAlloc((void**)&certResults.rgpCert, sizeof(PCX509CERT)*cCerts)) {
        return E_OUTOFMEMORY;
    }
    memset(certResults.rgpCert, 0, sizeof(PCX509CERT)*cCerts);
    if (! MemAlloc((void**)&certResults.rgcs, sizeof(CERTSTATE)*cCerts)) {
        return E_OUTOFMEMORY;
    }
    memset(certResults.rgcs, 0, sizeof(CERTSTATE)*cCerts);
    certResults.cEntries = cCerts;

    HrGetThumbprints(pEnum, dwType, rgThumbprint);
    hr = HrGetCertsFromThumbprints(rgThumbprint, &certResults);
    if (SUCCEEDED(hr)) {
        hr = HrGenerateCertsStatus(&certResults, pAdrTable, pEnum, fAlreadyHaveSendersCert);
        if (SUCCEEDED(hr)) {
            pcaCerts->cCerts = certResults.cEntries;
            pcaCerts->rgpCerts = (PCCERT_CONTEXT*)certResults.rgpCert;
        }
    }

    if (FAILED(hr)) {
        _FreeCertArray((PCCERT_CONTEXT *)certResults.rgpCert, certResults.cEntries);
    }
    MemFree(certResults.rgcs);

    if (rgThumbprint) {
        for (DWORD i = 0; i < cCerts; i++) {
            if (rgThumbprint[i].pBlobData) {
                MemFree(rgThumbprint[i].pBlobData);
            }
        }
        MemFree(rgThumbprint);
    }

    return hr;
}

/*  HrGenerateCertsStatus:
**
**  Purpose:
**      No assumptions about the rghr in pResults, this function scans the
**      HRESULTs and sets the CERTSTATEs in pAdrTable (1:1 mapping) accordingly
**  Takes:
**      IN pResults     - results to use for CERTSTATEs
**      IN pAdrTable    - address table to set states on
**      IN pEnum        - list of address handles
**  Returns:
**
*/
HRESULT CSMime::HrGenerateCertsStatus(
    X509CERTRESULT *                pResults,
    IMimeAddressTable *const        pAdrTable,
    IMimeEnumAddressTypes *const    pEnum,
    const BOOL                      fIgnoreSenderError)
{
    ADDRESSPROPS        apEntry;
    ADDRESSPROPS        apModify;
    UINT                i;
    const ULONG         numToGet = 1;
    DWORD               dexBogus = (DWORD)-1;
    HRESULT             hr = S_OK;

    // Walk the entire Enumerator
    i=0;
    pEnum->Reset();
    apModify.dwProps = IAP_CERTSTATE;
    while(S_OK == pEnum->Next(numToGet, &apEntry, NULL)) {
        Assert(apEntry.hAddress);
        apModify.certstate = pResults->rgcs[i];

        // Why was this added, you ask?
        // if the client has set OID_SECURITY_CERT_INCLUDED then
        // we need to not return spurious errors about the sender's
        // certificate.  if we didn't find it but were given it
        // elsewhere, say things are cool.

        // make sure to run through the whole array because the
        // error MIME_S_SECURITY_CERTERROR is the most important
        // since the sender cert one is really just a warning.

        if (CERTIFICATE_OK != apModify.certstate) {
            if (FMissingCert(apModify.certstate)) {
                if (apEntry.dwAdrType == IAT_FROM) {
                    if (fIgnoreSenderError) {
                        apModify.certstate = CERTIFICATE_OK;
                    }
                    else {
                        // since this can be ignored with fIgnoreSenderError
                        // it should never override another warning
                        if (S_OK == hr) {
                            hr = MIME_S_SECURITY_NOSENDERCERT;
                        }
                    }
                    dexBogus = i;
                }
                else {
                    hr = MIME_S_SECURITY_NOCERT;
                }
            }
            else {
                hr = MIME_S_SECURITY_CERTERROR;
            }
        }

        SideAssert(SUCCEEDED(pAdrTable->SetProps(apEntry.hAddress, &apModify)));
        g_pMoleAlloc->FreeAddressProps(&apEntry);
        i++;
    }

    if (i == pResults->cEntries) {    // success
        if ((DWORD)-1 != dexBogus) {
            // we found the sender and the cert for this entry is NULL.
            // CAPI doesn't like null certificates, so replace it
            if (dexBogus != pResults->cEntries-1) {
                // don't need to dupe b/c the end will no
                // longer be included in the count
                pResults->rgpCert[dexBogus] = pResults->rgpCert[pResults->cEntries-1];
            }
            --pResults->cEntries;
        }
    }
    else {
        hr = E_FAIL;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////
//
// CAPI wrappers
//

/*  GetCertData:
**
**  Returns:
**      MIME_E_NOT_FOUND if the data is not in the cert
**
**  Note:
**      Currently only supports CDID_EMAIL
*/
STDMETHODIMP CSMime::GetCertData(
    const PCX509CERT    pX509Cert,
    const CERTDATAID    dataid,
    LPPROPVARIANT       pValue)
{
#define pCert ((PCCERT_CONTEXT)pX509Cert)
    PCERT_NAME_INFO         pNameInfo = NULL;
    PCERT_RDN_ATTR          pRDNAttr;
    HRESULT                 hr = MIME_E_NOT_FOUND;
    LPSTR                   szOID;

    CHECKSMIMEINIT
    if (!(pX509Cert && pCert->pCertInfo) || dataid >= CDID_MAX) {
        return TrapError(E_INVALIDARG);
    }

    switch (dataid) {
        case CDID_EMAIL:
            // Let msoert handle this request
            if (pValue->pszVal = SzGetCertificateEmailAddress(pCert)) {
                pValue->vt = VT_LPSTR;
                hr = S_OK;
            }
            break;
        // if you add any cases, rewrite the findRDN code below
        // I assume IA5 and PhilH's NULL's at the end, leaving me
        // a very clean copy
        default:
            hr = E_INVALIDARG;
            goto exit;
    }

exit:
    return TrapError(hr);
#undef pCert
}

///////////////////////////////////////////////////////////////////////////
//
// Static functions
//
///////////////////////////////////////////////////////////////////////////

/***************************************************************************

    Name      : _HrConvertHrFromGetCertToEncode

    Purpose   :

    Parameters: hr = input HRESULT
                fEncrypt = TRUE if we are encrypting

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT _HrConvertHrFromGetCertToEncode(HRESULT hr, const BOOL fEncrypt)
{
    if (MIME_S_SECURITY_NOSENDERCERT == hr)
        if (fEncrypt) {
            hr = MIME_E_SECURITY_ENCRYPTNOSENDERCERT;
        }
        else {
            hr = MIME_E_SECURITY_NOSIGNINGCERT;
        }
    else if (MIME_S_SECURITY_CERTERROR == hr) {
        hr = MIME_E_SECURITY_CERTERROR;
    }
    else if (MIME_S_SECURITY_NOCERT == hr) {
        hr = MIME_E_SECURITY_NOCERT;
    }
    return hr;
}

/***************************************************************************

    Name      : _FreeCertArray

    Purpose   : Free an array of certs

    Parameters: rgpCert = array of cert pointers
                cCerts = number of certs in rgpCert

    Returns   : void

    Comment   :

***************************************************************************/
void _FreeCertArray(PCCERT_CONTEXT *rgpCert, const UINT cCerts)
{
    if (rgpCert) {
        for (register DWORD i = 0; i < cCerts; i++) {
            ReleaseCert(rgpCert[i]);
        }
        Assert(ALLOCED(rgpCert));
        MemFree(rgpCert);
    }
}

#ifdef DEBUG
///////////////////////////////////////////////////////////////////////////
//
// Debugging functions
//
///////////////////////////////////////////////////////////////////////////


/***************************************************************************

    Name      : DumpAlgorithms

    Purpose   : Debug dump of algorithms

    Parameters: void

    Returns   : void

    Comment   :

***************************************************************************/
void CSMime::DumpAlgorithms()
{
    DWORD   dwAlgCount;
    char *ptr = NULL;
    DWORD i;
    ALG_ID  aiAlgid;
    DWORD dwBits;
    DWORD dwNameLen;
    char szName[100];
    BYTE pbData[1000];
    DWORD dwDataLen;
    DWORD dwFlags;
    CHAR *pszAlgType = NULL;
    HCRYPTPROV hProv;

    CryptAcquireContext(&hProv, NULL, NULL, 5, 0);
    Assert(hProv);
    for(i=0; ;i++) {
        if (0==i) {
            dwFlags = CRYPT_FIRST;
        }
        else {
            dwFlags = 0;
        }

        dwDataLen = 1000;
        if(!CryptGetProvParam(hProv, PP_ENUMALGS, pbData, &dwDataLen, 0)) {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
                break;
            }
            else {
                Assert(0);
            }
        }

        ptr = (char *)pbData;

        aiAlgid = *(ALG_ID *)ptr;
        ptr += sizeof(ALG_ID);
        dwBits = *(DWORD *)ptr;
        ptr += sizeof(DWORD);
        dwNameLen = *(DWORD *)ptr;
        ptr += sizeof(DWORD);
        StrCpyN(szName, ptr, (int)(min(dwNameLen, ARRAYSIZE(szName))));

        switch(GET_ALG_CLASS(aiAlgid)) {
            case ALG_CLASS_DATA_ENCRYPT:
                pszAlgType = "Encrypt  ";
                break;
            case ALG_CLASS_HASH:
                pszAlgType = "Hash     ";
                break;
            case ALG_CLASS_KEY_EXCHANGE:
                pszAlgType = "Exchange ";
                break;
            case ALG_CLASS_SIGNATURE:
                pszAlgType = "Signature";
                break;
            default:
                pszAlgType = "Unknown  ";
        }

        DOUTL(CRYPT_LEVEL, "Algid:%8.8xh, Bits:%-4d, Type:%s, NameLen:%-2d, Name:%s\n",
            aiAlgid, dwBits, pszAlgType, dwNameLen, szName);
    }
    CryptReleaseContext(hProv, 0);
    return;
}

#endif // debug

BOOL FSameAgreeParameters(CMS_RECIPIENT_INFO * pRecipInfo1,
                          CMS_RECIPIENT_INFO * pRecipInfo2)
{
    if (pRecipInfo1->dwU1 != pRecipInfo2->dwU1)         return FALSE;
    if (pRecipInfo1->dwU1 == CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE) {
        if ((lstrcmp(pRecipInfo1->u1.u3.EphemeralAlgorithm.pszObjId,
                     pRecipInfo2->u1.u3.EphemeralAlgorithm.pszObjId) != 0) ||
            (pRecipInfo1->u1.u3.EphemeralAlgorithm.Parameters.cbData !=
             pRecipInfo2->u1.u3.EphemeralAlgorithm.Parameters.cbData) ||
            (memcmp(pRecipInfo1->u1.u3.EphemeralAlgorithm.Parameters.pbData,
                    pRecipInfo2->u1.u3.EphemeralAlgorithm.Parameters.pbData,
                    pRecipInfo1->u1.u3.EphemeralAlgorithm.Parameters.cbData) != 0)){
            return FALSE;
        }
        if ((pRecipInfo1->u1.u3.UserKeyingMaterial.cbData !=
             pRecipInfo2->u1.u3.UserKeyingMaterial.cbData) ||
            (memcmp(pRecipInfo1->u1.u3.UserKeyingMaterial.pbData,
                    pRecipInfo2->u1.u3.UserKeyingMaterial.pbData,
                    pRecipInfo1->u1.u3.UserKeyingMaterial.cbData) != 0)) {
            return FALSE;
        }
    }
    else if (pRecipInfo1->dwU1 == CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE) {
        //
        //  We don't bother checking the sender cert id.  I don't know of
        //      any reason why the same key would be encoded with different
        //      identifiers (issuer and serial vs subject key id)
        //
        
        if (pRecipInfo1->u1.u4.hprov != pRecipInfo2->u1.u4.hprov) return FALSE;
        if (pRecipInfo1->u1.u4.dwKeySpec != pRecipInfo2->u1.u4.dwKeySpec) {
            return FALSE;
        }
        if ((pRecipInfo1->u1.u3.UserKeyingMaterial.cbData !=
             pRecipInfo2->u1.u3.UserKeyingMaterial.cbData) ||
            (memcmp(pRecipInfo1->u1.u3.UserKeyingMaterial.pbData,
                    pRecipInfo2->u1.u3.UserKeyingMaterial.pbData,
                    pRecipInfo1->u1.u3.UserKeyingMaterial.cbData) != 0)) {
            return FALSE;
        }
    }
    else return FALSE;

    return TRUE;
}

HRESULT ConvertEncryptionLayer(IMimeBody * pBody, IMimeSecurity2 * psm, SMIMEINFO * psi)
{
    DWORD                                       cAgree;
    DWORD                                       cRecipients;
    HRESULT                                     hr;
    DWORD                                       i;
    DWORD                                       i2;
    DWORD                                       iAgree;
    DWORD                                       iRecip;
    CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO *      pAgree = NULL;
    CRYPT_ATTRIBUTE *                           pattr = NULL;
    CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO *      pMailList = NULL;
    PSECURITY_LAYER_DATA                        psld = NULL;
    CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO *      pTrans = NULL;
    CMS_RECIPIENT_INFO *                        rgRecipInfo = NULL;
    PROPVARIANT                                 var;
    
    PropVariantInit(&var);

    //
    //  Create a layer to hold the encryption information
    //
            
    if (! (psld = new CSECURITY_LAYER_DATA)) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Link together the different layers
    if (psi->psldLayers == NULL) {
        psi->psldLayers = psld;
    }

    psld->m_psldOuter = psi->psldInner;
    if (psld->m_psldOuter != NULL) {
        psld->m_psldOuter->m_psldInner = psld;
    }
    psi->psldInner = psld;

    //
    //  Encryption layers must be blobed -- so or it in.
    //
            
    psi->dwMsgEnhancement |= MST_BLOB_FLAG;
    psld->m_dwMsgEnhancement = psi->dwMsgEnhancement &
        (MST_ENCRYPT_MASK | MST_BLOB_FLAG);

    //
    // The encryption algorithm may not be encoded the way we need it
    //  to be.  The call will re-encode correctly for CMS.
    //
    //  If we are encrypting, it is an error to not have an encryption
    //  algorithm.
    //

    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_ALG_BULK, &var)) &&
        (0 != var.blob.cbSize)) {
        Assert(VT_BLOB == var.vt);

        hr = HrBuildContentEncryptionAlg(psld, &var.blob);
        if (hr != S_OK) {
            Assert(FALSE);
            // goto exit;
        }
    }
    else {
        hr = E_INVALIDARG;
        goto exit;
    }

    //  
    // The call may have provided a specific certificate to be used
    //  in decrypting the message.  This functionality is now obsolete but
    //  still supported.  If no certificate is provided then we will search
    //  for a valid decryption key.
    //
    PropVariantClear(&var);
#ifdef _WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_DECRYPTION_64, &var)) &&
        (NULL != (PCCERT_CONTEXT *) var.pulVal)) 
    {
        Assert(VT_UI8 == var.vt);
        // don't need to dupe the cert, been done in GetOption
        psld->m_pccertDecrypt = (PCCERT_CONTEXT) var.pulVal;
#else // !_WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_DECRYPTION, &var)) &&
        (NULL != (PCCERT_CONTEXT *) var.ulVal)) 
    {
        Assert(VT_UI4 == var.vt);
        // don't need to dupe the cert, been done in GetOption
        psld->m_pccertDecrypt = (PCCERT_CONTEXT) var.ulVal;
#endif // _WIN64

        // Included a cert in this layer
        psld->m_fCertInLayer = TRUE;
    }

    //
    //  Allocate the space to hold the Encryption structures we are going 
    //  to pass into the CMS structures.
    //
            
    CHECKHR(hr = psm->GetRecipientCount(0, &cRecipients));
    if (cRecipients == 0) {
        hr = MIME_E_SECURITY_ENCRYPTNOSENDERCERT;
        goto exit;
    }

    if (!MemAlloc((LPVOID *) &psld->m_rgRecipientInfo,
                  cRecipients * sizeof(CMSG_RECIPIENT_ENCODE_INFO))) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    memset(psld->m_rgRecipientInfo, 0,
           cRecipients*sizeof(CMSG_RECIPIENT_ENCODE_INFO));

    //
    //  Allocate the space to hold the values we currently are holding
    //

    if (!MemAlloc((LPVOID *) &rgRecipInfo,
                  cRecipients * sizeof(rgRecipInfo[0]))) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    memset(rgRecipInfo, 0, cRecipients*sizeof(rgRecipInfo[0]));
    CHECKHR(hr = psm->GetRecipient(0, 0, cRecipients, rgRecipInfo));

    //
    //  Walk through and process all of the recipients by copying data
    //  from the current structure into the CMS version of the structure.
    //
    //  Note that we do no free any of the data allocated in the GetRecipient
    //  call.  The data will be freed as part of freeing the CMS data
    //  structure instead. Ownership of all data is transfered.
    //
            
    for (i=0, iRecip = 0; i<cRecipients; i++) {
        switch (rgRecipInfo[i].dwRecipientType) {
            //
            //  If this is set then we must have already processed this item
            //
        case CMS_RECIPIENT_INFO_TYPE_UNKNOWN:
            break;

            //
            //  Key Transport items copy over one-for-one.
            //
                    
        case CMS_RECIPIENT_INFO_TYPE_KEYTRANS:
            //  try and allocate the object to hold the data.
            if (!MemAlloc((LPVOID *) &pTrans, sizeof (*pTrans))) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            memset(pTrans, 0, sizeof(*pTrans));

            //
            //  Copy the data over from the old to the new structure.
            //  Ownership of all data is transfered here.
            //

            pTrans->cbSize = sizeof(*pTrans);
            pTrans->KeyEncryptionAlgorithm = rgRecipInfo[i].KeyEncryptionAlgorithm;
            pTrans->pvKeyEncryptionAuxInfo = rgRecipInfo[i].pvKeyEncryptionAuxInfo;
                    
            Assert(rgRecipInfo[i].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_KEYTRANS);
            pTrans->RecipientPublicKey = rgRecipInfo[i].u1.SubjectPublicKey;
                    
            Assert((rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) ||
                   (rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL));
            if (rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) {
                pTrans->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
                pTrans->RecipientId.KeyId = rgRecipInfo[i].u3.KeyId;
            }
            else if (rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL) {
                pTrans->RecipientId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
                pTrans->RecipientId.IssuerSerialNumber = rgRecipInfo[i].u3.IssuerSerial;
            }
            else {
                hr = E_INVALIDARG;
                goto exit;
            }

            //
            //  The copy has been sucessful so point to the new data.
            //

            psld->m_rgRecipientInfo[iRecip].dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
            psld->m_rgRecipientInfo[iRecip].pKeyTrans = pTrans;
            pTrans = NULL;
            iRecip += 1;
            
            if(rgRecipInfo[i].pccert)
                CertFreeCertificateContext(rgRecipInfo[i].pccert); 
            break;

            //
            //  Mail List items can also just be copied over from the source
            //  to the destination structures
            //
                    
        case CMS_RECIPIENT_INFO_TYPE_MAIL_LIST:
            //  Allocate the CMS structure to hold this data
            if (!MemAlloc((LPVOID *) &pMailList, sizeof(*pMailList))) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            memset(pMailList, 0, sizeof(*pMailList));

            //
            //  Copy the data over from the old to the new structure.  
            //  Ownership of all data is transfered here.
            //

            pMailList->cbSize = sizeof(*pMailList);
            pMailList->KeyEncryptionAlgorithm = rgRecipInfo[i].KeyEncryptionAlgorithm;
            pMailList->pvKeyEncryptionAuxInfo = rgRecipInfo[i].pvKeyEncryptionAuxInfo;
            Assert(rgRecipInfo[i].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_PROVIDER);
            pMailList->hCryptProv = rgRecipInfo[i].u1.u2.hprov;
            pMailList->dwKeyChoice = CMSG_MAIL_LIST_HANDLE_KEY_CHOICE;
            pMailList->hKeyEncryptionKey = rgRecipInfo[i].u1.u2.hkey;
            Assert(rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID);
            pMailList->KeyId = rgRecipInfo[i].u3.KeyId;
            pMailList->Date = rgRecipInfo[i].filetime;
            pMailList->pOtherAttr = rgRecipInfo[i].pOtherAttr;

            //
            //  Copy is successful so point to the data
            //

            psld->m_rgRecipientInfo[iRecip].dwRecipientChoice = CMSG_MAIL_LIST_RECIPIENT;
            psld->m_rgRecipientInfo[iRecip].pMailList = pMailList;
            iRecip += 1;
            pMailList = NULL;
            break;

            //
            //  We need to do some magic with key agree structures. 
            //  Specifically we want to do the following:
            //  - Combine together all key agrees with the same parameters
            //          into a single record to pass into the CMS code.
            //  - 

        case CMS_RECIPIENT_INFO_TYPE_KEYAGREE:
            //  allocate the CMS structure to hold this data
            if (!MemAlloc((LPVOID *) &pAgree, sizeof(*pAgree))) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            memset(pAgree, 0, sizeof(*pAgree));

            //
            //  Start by setting up the common parameters used by all of the
            //    recipients in the common key set.
            //  Setup the key agreement parameters for encoding and 
            //    so forth.

            pAgree->cbSize = sizeof(*pAgree);

            //  Key Encryption Algorithm - 

            pAgree->KeyEncryptionAlgorithm = rgRecipInfo[i].KeyEncryptionAlgorithm;
            pAgree->pvKeyEncryptionAuxInfo = rgRecipInfo[i].pvKeyEncryptionAuxInfo;
                    
            // Key Wrap Algorithm - Derive from the content algorithm
            //     if not already known.

            if (rgRecipInfo[i].KeyWrapAlgorithm.pszObjId != NULL) {
                pAgree->KeyWrapAlgorithm = rgRecipInfo[i].KeyWrapAlgorithm;
                pAgree->pvKeyWrapAuxInfo = rgRecipInfo[i].pvKeyWrapAuxInfo;
            }
            else {
                hr = HrDeriveKeyWrapAlg(psld, pAgree);
                if (FAILED(hr)) {
                    goto exit;
                }
            }

            //  Items which are specificly located accroding to static or
            //          ephemeral key agreement.

            if (rgRecipInfo[i].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE) {
                pAgree->UserKeyingMaterial = rgRecipInfo[i].u1.u3.UserKeyingMaterial;

                if (!MemAlloc((LPVOID *) &pAgree->pEphemeralAlgorithm,
                              sizeof(CRYPT_ALGORITHM_IDENTIFIER))) {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                memset(pAgree->pEphemeralAlgorithm, 0,
                       sizeof(CRYPT_ALGORITHM_IDENTIFIER));

                    
                pAgree->dwKeyChoice = CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE;
                memcpy(pAgree->pEphemeralAlgorithm,
                       &rgRecipInfo[i].u1.u3.EphemeralAlgorithm,
                       sizeof(CRYPT_ALGORITHM_IDENTIFIER));
            }
            else {
                Assert(rgRecipInfo[i].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE);
                pAgree->dwKeyChoice = CMSG_KEY_AGREE_STATIC_KEY_CHOICE;
                pAgree->UserKeyingMaterial = rgRecipInfo[i].u1.u4.UserKeyingMaterial;

                if (!MemAlloc((LPVOID *) &pAgree->pSenderId, sizeof(CERT_ID))) {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                memcpy(pAgree->pSenderId, &rgRecipInfo[i].u1.u4.senderCertId,
                       sizeof(CERT_ID));

                pAgree->hCryptProv = rgRecipInfo[i].u1.u4.hprov;
                pAgree->dwKeySpec = rgRecipInfo[i].u1.u4.dwKeySpec;
            }

            //
            //  We need to count of common items
            //

            for (i2=i+1, cAgree = 1; i2<cRecipients; i2++) {
                cAgree += FSameAgreeParameters(&rgRecipInfo[i],
                                               &rgRecipInfo[i2]);
            }

            //
            //

            //
            //  Allocate space to hold the set of common key agree recipients
            //

            if (!MemAlloc((LPVOID *) &pAgree->rgpRecipientEncryptedKeys,
                          cAgree * sizeof(LPVOID))) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            pAgree->cRecipientEncryptedKeys = cAgree;
            memset(pAgree->rgpRecipientEncryptedKeys, 0, cAgree * sizeof(LPVOID));

            for (i2=i, iAgree = 0; i2<cRecipients; i2++) {
                if ((i2 != i) && !FSameAgreeParameters(&rgRecipInfo[i],
                                                       &rgRecipInfo[i2])) {
                    continue;
                }
                        
                if (!MemAlloc((LPVOID *) &pAgree->rgpRecipientEncryptedKeys[iAgree],
                              sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO))) {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                memset(pAgree->rgpRecipientEncryptedKeys[iAgree], 0,
                       sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO));

                pAgree->rgpRecipientEncryptedKeys[iAgree]->cbSize = sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO);

                //
                //  Get the recipients Public Key value
                //
                        
                if (rgRecipInfo[i2].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE) {
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientPublicKey = rgRecipInfo[i2].u1.u3.SubjectPublicKey;
                }
                else {
                    Assert(rgRecipInfo[i2].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE);

                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientPublicKey = rgRecipInfo[i2].u1.u4.SubjectPublicKey;
                }

                //
                //  Get the recipients certificate ID
                //
                        
                Assert((rgRecipInfo[i2].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) ||
                       (rgRecipInfo[i2].dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL));
                if (rgRecipInfo[i2].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) {
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientId.KeyId = rgRecipInfo[i2].u3.KeyId;
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->Date = rgRecipInfo[i2].filetime;
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->pOtherAttr = rgRecipInfo[i2].pOtherAttr;
                }
                else if (rgRecipInfo[i2].dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL) {
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientId.IssuerSerialNumber = rgRecipInfo[i2].u3.IssuerSerial;
                }
                else {
                    hr = E_INVALIDARG;
                    goto exit;
                }

                //
                //  Zero the data so it does not freed twice.  (pointers are now
                //      in the CMS structure)
                //

                if (i != i2) {
                    memset(&rgRecipInfo[i2], 0, sizeof(rgRecipInfo[i2]));
                }

                iAgree += 1;
            }
                    
            Assert(iAgree == cAgree);

            //
            //  The copy has been successfully completed.  We now move
            //  the data (and ownership) into new structure.
            //

            psld->m_rgRecipientInfo[iRecip].dwRecipientChoice = CMSG_KEY_AGREE_RECIPIENT;
            psld->m_rgRecipientInfo[iRecip].pKeyAgree = pAgree;
            iRecip += 1;
            pAgree = NULL;
            break;
        }

        //
        //  Zero the data so it does not freed twice.  (pointers are now
        //      in the CMS structure)
        //

        memset(&rgRecipInfo[i], 0, sizeof(rgRecipInfo[i]));
    }
    psld->m_cEncryptItems = iRecip;

    PropVariantClear(&var);
#ifndef _WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCRYPTPROV, &var))) 
    {
        psi->hProv = (HCRYPTPROV) var.ulVal;
    }
#else // _WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCRYPTPROV_64, &var))) 
    {
        psi->hProv = (HCRYPTPROV) var.pulVal;
    }
#endif // _WIN64

    //
    //  Pickup the set of encryption certificate bag
    //

    PropVariantClear(&var);
#ifdef _WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_ENCRYPT_CERT_BAG_64, &var))) {
        psld->m_hstoreEncrypt = (HCERTSTORE) var.pulVal;
#else
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_ENCRYPT_CERT_BAG, &var))) {
        psld->m_hstoreEncrypt = (HCERTSTORE) var.ulVal;
#endif // _WIN64
    }

    //
    //   Pick up the unprotected attributes
    //

    if (g_FSupportV3) {
        hr = psm->GetAttribute(0, 0, SMIME_ATTRIBUTE_SET_UNPROTECTED, 0, NULL,
                               &pattr);
        if (FAILED(hr)) {
            goto exit;
        }
        else if (hr == S_OK) {
            Assert(pattr != NULL);
            CHECKHR(hr = HrCopyCryptDataBlob(&pattr->rgValue[0],
                                             &psld->m_blobUnprotectAttrs));
        }
    }
    
    hr = S_OK;
    
exit:
    PropVariantClear(&var);
    if (rgRecipInfo != NULL) {
        for (i=0; i<cRecipients; i++) {
            FreeRecipientInfoContent(&rgRecipInfo[i]);
        }
        SafeMemFree(rgRecipInfo);
    }
    SafeMemFree(pTrans);
    SafeMemFree(pMailList);
    if (pAgree != NULL) {
        for (i=0; pAgree->cRecipientEncryptedKeys; i++) {
            SafeMemFree(pAgree->rgpRecipientEncryptedKeys[i]);
        }
        SafeMemFree(pAgree->pEphemeralAlgorithm);
        SafeMemFree(pAgree->pSenderId);
        SafeMemFree(pAgree->rgpRecipientEncryptedKeys);
        SafeMemFree(pAgree);
    }
    SafeMemFree(pattr);
    return hr;
}

/***************************************************************************

    Name      : OptionsToSMIMEINFO

    Purpose   : Fill the SMIMEINFO from the body properties

    Parameters: fEncode = TRUE if encoding
                pBody -> Body object
                psi -> target SMIMEINFO

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CSMime::OptionsToSMIMEINFO(
    BOOL        fEncode,
    IMimeMessageTree *const pmm,
    IMimeBody * pBody,
    SMIMEINFO * psi)
{
    CRYPT_ATTRIBUTE                             attr;
    DWORD                                       cb;
    DWORD                                       cAgree;
    ULONG                                       cCertBag = 0;
    DWORD                                       dwSecurity;
    FILETIME                                    ftSignTime;
    HCERTSTORE                                  hCertStore = NULL;
    HRESULT                                     hr = S_OK;
    ULONG                                       i;
    DWORD                                       i2;
    DWORD                                       iAgree;
    ULONG                                       iLayer;
    DWORD                                       iSigner;
    PSECURITY_LAYER_DATA                        psld = NULL, psldTemp;
    BYTE                                        rgb[50];
    PCCERT_CONTEXT *                            rgpccCertSigning = NULL;
    PCCERT_CONTEXT *                            rgpcCertBag = NULL;
    PROPVARIANT *                               rgpvAlgHash = NULL;
    PROPVARIANT *                               rgpvAuthAttr = NULL;
    PROPVARIANT *                               rgpvUnauthAttr = NULL;
    IMimeSecurity2 *                            psm = NULL;
    ULONG                                       ulLayers = 0;
    CRYPT_ATTR_BLOB                             valTime;
    PROPVARIANT                                 var;

    Assert(pBody && psi);

    //
    //  Pick up the security interface on the body.  It makes life easier
    //

    hr = pBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &psm);
    if (FAILED(hr)) {
        goto exit;
    }

    //
    //  If we are going to encode the body, then see if the content type is
    //  "OID/xxx".  In this case we encode the body specially and we need to
    //  get the size of the inner blob.
    //
    
    if (fEncode) {
        //  Must determine the body type to see if it needs special processing
        if (pBody->IsContentType("OID", NULL) == S_OK) {
            PROPVARIANT     var;
            var.vt = VT_LPSTR;
        
            if (FAILED(pBody->GetProp(STR_ATT_SUBTYPE, 0, &var))) {
                return TrapError(E_FAIL);
            }
            if (strcmp(var.pszVal, szOID_RSA_data) != 0) {
                psi->pszInnerContent = var.pszVal;
                if (FAILED(pBody->GetEstimatedSize(IET_BINARY, &psi->cbInnerContent))) {
                    return TrapError(E_FAIL);
                }
            }
        }
    }

    if (FAILED(pBody->GetOption(OID_SECURITY_KEY_PROMPT, &var))) {
        return TrapError(E_FAIL);
    }
    Assert(VT_LPWSTR == var.vt);
    if (var.pwszVal != NULL) {
        psi->pwszKeyPrompt = PszDupW(var.pwszVal);
        if (psi->pwszKeyPrompt == NULL) {
            return TrapError(E_OUTOFMEMORY);
        }
    }

    //
    //  Get the security to be applied and put it into the security info layer
    //          structure
    //
    
    if (FAILED(pBody->GetOption(OID_SECURITY_TYPE, &var))) {
        return TrapError(E_FAIL);
    }
    Assert(VT_UI4 == var.vt);
    psi->dwMsgEnhancement = var.ulVal;

    //
    //  Start doing the setup for encode operations.
    //

    if (fEncode) {
        //
        //  We must be doing some type of encoding operation, or we should fail.
        //

        if (MST_NONE == var.ulVal) {
            hr = TrapError(MIME_S_SECURITY_NOOP);
            goto exit;
        }
        else if (!(MST_THIS_MASK & var.ulVal)) {
            hr = TrapError(MIME_S_SECURITY_RECURSEONLY);
            goto exit;
        }
        else if (MST_CLASS_SMIME_V1 != (var.ulVal & MST_CLASS_MASK)) {
            hr = TrapError(MIME_E_SECURITY_CLASSNOTSUPPORTED);
            goto exit;
        }

        //
        //  If we are doing multiple layers of encrption, then we require that
        //      the inner level be blobed and not clear.
        //
        
        if ((psi->pszInnerContent != NULL) && !(var.ulVal & MST_BLOB_FLAG)) {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        //
        //  Are we encrypting
        //

        if (psi->dwMsgEnhancement & MST_ENCRYPT_MASK) {
            hr = ConvertEncryptionLayer(pBody, psm, psi);
            if (FAILED(hr)) {
                goto exit;
            }
        }

        //
        //  Are we signing?
        //
        if (psi->dwMsgEnhancement & MST_SIGN_MASK) {
            //
            // Force in a a signing time
            //

            GetSystemTimeAsFileTime(&ftSignTime);
            cb = sizeof(rgb);
            if (CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                    &ftSignTime, 0, NULL, rgb, &cb)) {
                attr.pszObjId = szOID_RSA_signingTime;
                attr.cValue = 1;
                attr.rgValue = &valTime;
                valTime.pbData = rgb;
                valTime.cbData = cb;

                hr = psm->SetAttribute(SMIME_ATTR_ADD_IF_NOT_EXISTS,
                                       (DWORD) -1, SMIME_ATTRIBUTE_SET_SIGNED,
                                       &attr);
                if (FAILED(hr)) {
                    goto exit;
                }
            }

            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_SIGNATURE_COUNT, &var))) {
                Assert(VT_UI4 == var.vt);
                ulLayers = var.ulVal;
            }
#ifdef _WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_RG_64, &var))) {
                Assert((VT_VECTOR | VT_UI8) == var.vt);
                Assert(var.cauh.cElems == ulLayers);
                rgpccCertSigning = (PCCERT_CONTEXT *) (var.cauh.pElems);
            }
            // These next two are optional
            // Furthermore, if we get the first, we don't check the second.  BJK - Huh?
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var))) 
            {
                Assert(VT_UI8 == var.vt);
                hCertStore = (HCERTSTORE) var.pulVal;
#else
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_RG, &var))) {
                Assert((VT_VECTOR | VT_UI4) == var.vt);
                Assert(var.caul.cElems == ulLayers);
                rgpccCertSigning = (PCCERT_CONTEXT *)var.caul.pElems;
            }
            // These next two are optional
            // Furthermore, if we get the first, we don't check the second.  BJK - Huh?
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var))) 
            {
                Assert(VT_UI4 == var.vt);
                hCertStore = (HCERTSTORE) var.ulVal;
#endif //_WIN64
            }

            // NOTE: OID_SECURITY_RG_CERT_BAG is not a per-layer array!  It
            // is an array of all the certs for the entire message.

#ifndef _WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_RG_CERT_BAG, &var))) {
                Assert((VT_VECTOR | VT_UI4) == var.vt);
                cCertBag = var.caul.cElems;
                rgpcCertBag = (PCCERT_CONTEXT*)var.caul.pElems;

#else
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_RG_CERT_BAG_64, &var))) {
                Assert((VT_VECTOR | VT_UI8) == var.vt);
                cCertBag = var.cauh.cElems;
                rgpcCertBag = (PCCERT_CONTEXT*)(var.cauh.pElems);
#endif //_WIN64
            }
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_ALG_HASH_RG, &var))) {
                Assert((VT_VECTOR | VT_VARIANT) == var.vt);
                Assert(var.capropvar.cElems == ulLayers);
                rgpvAlgHash = var.capropvar.pElems;
            }

            //  Grab the unauthenicated attributes
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_UNAUTHATTR_RG, &var))) {
                Assert((VT_VECTOR | VT_VARIANT) == var.vt);
                Assert(var.capropvar.cElems == ulLayers);
                rgpvUnauthAttr = var.capropvar.pElems;
            }

            //  Grab the initial authenicated attributes
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_AUTHATTR_RG, &var))) {
                Assert((VT_VECTOR | VT_VARIANT) == var.vt);
                Assert(var.capropvar.cElems == ulLayers);
                rgpvAuthAttr = var.capropvar.pElems;
            }

            //  Create a layer to hold the signing information
            
            if (! (psld = new CSECURITY_LAYER_DATA)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Link together the different layers

            if (psi->psldLayers == NULL) {
                psi->psldLayers = psld;
            }

            psld->m_psldOuter = psi->psldInner;
            if (psld->m_psldOuter != NULL) {
                psld->m_psldOuter->m_psldInner = psld;
            }
            psi->psldInner = psld;

            //

            psld->m_dwMsgEnhancement = psi->dwMsgEnhancement &
                (MST_SIGN_MASK | MST_BLOB_FLAG);

            //  Fill in the signing information

            if (!MemAlloc((LPVOID *) &psld->m_rgSigners,
                          sizeof(SignerData)*ulLayers)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            
            memset(psld->m_rgSigners, 0, sizeof(SignerData)*ulLayers);
            psld->m_cSigners = ulLayers;

            for (iSigner=0; iSigner < ulLayers; iSigner++) {
                psld->m_rgSigners[iSigner].pccert = DupCert(rgpccCertSigning[iSigner]);
                HrCopyBlob(&rgpvAlgHash[iSigner].blob,
                           &psld->m_rgSigners[iSigner].blobHashAlg);
                HrCopyBlob(&rgpvUnauthAttr[iSigner].blob,
                           &psld->m_rgSigners[iSigner].blobUnauth);
                HrCopyBlob(&rgpvAuthAttr[iSigner].blob,
                           &psld->m_rgSigners[iSigner].blobAuth);
            }

#ifdef _WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var))) 
                {
                    //  Don't addref as we are just giving it to the sld object
                    psld->m_hcertstor = (HCERTSTORE) var.pulVal;
#else
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var))) 
                {
                    //  Don't addref as we are just giving it to the sld object
                    psld->m_hcertstor = (HCERTSTORE) var.ulVal;
#endif // _WIN64
                }

        }

        //
        // read these for both signing and encryption
        //

        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_REQUESTED_CTE, &var))) {
            Assert(VT_I4 == var.vt);
            psi->ietRequested = ENCODINGTYPE(var.lVal);
        }
        else {
            psi->ietRequested = ENCODINGTYPE(-1);
        }
    }

    //
    // read these for both encoding and decoding
    //

    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_SEARCHSTORES, &var)) &&
#ifdef _WIN64
        (NULL != var.cauh.pElems)
#else
        (NULL != var.caul.pElems)
#endif // _WIN64
     ) {
#ifdef _WIN64
        CAUH& caul = var.cauh;  // On Win64, it's really a cauh
#else
        CAUL& caul = var.caul;
#endif // _WIN64

        psi->rgStores = (HCERTSTORE*)g_pMoleAlloc->Alloc(caul.cElems * sizeof(HCERTSTORE));
        if (psi->rgStores) {
            for (DWORD i = 0; i < caul.cElems; i++) {
                // Shouldn't have to duplicate since we're not freeing them here
#ifdef _WIN64
                psi->rgStores[i] = (HCERTSTORE)caul.pElems[i].QuadPart;
#else
                psi->rgStores[i] = (HCERTSTORE)caul.pElems[i];
#endif // _WIN64
            }
            psi->cStores = caul.cElems;
        }
        SafeMemFree(caul.pElems);
    }
    else {
        // if we were given no stores, open "My"
        psi->rgStores = (HCERTSTORE*)g_pMoleAlloc->Alloc(sizeof(HCERTSTORE));
        if (psi->rgStores) {
            psi->rgStores[0] = OpenCachedMyStore();
            if (psi->rgStores[0]) {
                psi->cStores = 1;
            } else {
                g_pMoleAlloc->Free(psi->rgStores);
            }
        }
    }

exit:
#ifdef SMIME_V3
    if (psm != NULL)            psm->Release();
#endif // SMIME_V3

#ifndef SMIME_V3    
    SafeMemFree(rgftSigningTime);
#endif  // SMIME_V3

    if (rgpccCertSigning) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            if (rgpccCertSigning[iLayer]) {
                CertFreeCertificateContext(rgpccCertSigning[iLayer]);
            }
        }
    }
    SafeMemFree(rgpccCertSigning);

    if (hCertStore) {
        CertCloseStore(hCertStore, 0);
    }

    if (rgpcCertBag) {
        // NOTE: rgpcCertBag isn't indexed by layer!
        for (i = 0; i < cCertBag; i++) {
            if (rgpcCertBag[i]) {
                CertFreeCertificateContext(rgpcCertBag[i]);
            }
        }
    }
    SafeMemFree(rgpcCertBag);

    if (rgpvAlgHash) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            SafeMemFree(rgpvAlgHash[iLayer].blob.pBlobData);
        }
    }
    SafeMemFree(rgpvAlgHash);

    if (rgpvUnauthAttr) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            SafeMemFree(rgpvUnauthAttr[iLayer].blob.pBlobData);
        }
    }
    SafeMemFree(rgpvUnauthAttr);

    if (rgpvAuthAttr) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            SafeMemFree(rgpvAuthAttr[iLayer].blob.pBlobData);
        }
    }
    SafeMemFree(rgpvAuthAttr);

#ifndef SMIME_V3
    if (rgpvSymcaps) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            SafeMemFree(rgpvSymcaps[iLayer].blob.pBlobData);
        }
    }
    SafeMemFree(rgpvSymcaps);
#endif // !SMIME_V3

    return(hr);
}

/***************************************************************************

    Name      : SMIMEINFOToOptions

    Purpose   : set the body properties based on contents of the SMIMEINFO

    Parameters: psi -> source SMIMEINFO
                pBody -> target body object

    Returns   : void

    Comment   :

***************************************************************************/
HRESULT CSMime::SMIMEINFOToOptions(
    IMimeMessageTree * const pTree,
    const SMIMEINFO *   psi,
    HBODY               hBody)
{
    DWORD               dwSecurityType = 0;
    HBODY               hBody2;
    HRESULT             hr;
    ULONG               iLayer;
    PCRYPT_ATTRIBUTES   pattrsUnprot = NULL;
    CMessageBody *      pPrivBody = NULL;
    PSECURITY_LAYER_DATA psldLoop;
    IMimeSecurity2 *     psm = NULL;                
    PROPVARIANT         var;
#ifdef _WIN64
    UNALIGNED CRYPT_ATTR_BLOB *pVal = NULL;
#endif

    Assert(psi && hBody);
    CHECKHR(hr = pTree->BindToObject(hBody, IID_CMessageBody, (void**)&pPrivBody));
    Assert(pPrivBody);

    pPrivBody->GetOption(OID_SECURITY_CERT_INCLUDED, &var);
    Assert(VT_BOOL == var.vt);
    if (!var.boolVal && psi->fCertWithMsg) {
        var.boolVal = (VARIANT_BOOL) !!psi->fCertWithMsg;
        pPrivBody->InternalSetOption(OID_SECURITY_CERT_INCLUDED, &var,
                                     TRUE, TRUE);
    }

    pPrivBody->GetOption(OID_SECURITY_TYPE, &var);
    dwSecurityType = var.ulVal;

    //  We could have been passed something like ROOT, move to a real handle
    pPrivBody->GetHandle(&hBody2);

    for (iLayer = 0, psldLoop = psi->psldLayers; psldLoop != NULL;
        psldLoop = psldLoop->m_psldInner, iLayer++) {

        //  The rule here is:  Always insert a new layer UNLESS:
        //      1.  this is an encrpytion layer and
        //      2.  the previous layer was a signing layer

        if ((dwSecurityType != 0) &&
            (!(dwSecurityType & MST_THIS_ENCRYPT) ||
             !(psldLoop->m_dwMsgEnhancement & MST_THIS_SIGN))) {
            /*            ((dwSecurityType & MST_THIS_SIGN_ENCRYPT) != MST_THIS_SIGN) &&
            ((psldLoop->m_dwMsgEnhancement & MST_THIS_SIGN_ENCRYPT) != MST_THIS_ENCRYPT)) {
            */
            if (psm != NULL) {
                psm->Release();
                psm = NULL;
            }
            pPrivBody->Release();
            CHECKHR(hr = pTree->ToMultipart(hBody2, "y-security", NULL));
            CHECKHR(hr = pTree->BindToObject(hBody2, IID_CMessageBody,
                                             (void**)&pPrivBody));
        }

        //  This must be after the above check for inserting a layer
        dwSecurityType |= psldLoop->m_dwMsgEnhancement | MST_CLASS_SMIME_V1;

        if (MST_SIGN_MASK & psldLoop->m_dwMsgEnhancement) {
            DWORD               cSigners = psldLoop->m_cSigners;
            DWORD               iSigner;
            SignerData *        pSigner;

            // Allocate enough space in the option arrays for this layer
            // OID_SECURITY_TYPE_RG             // DWORD
            // OID_SECURITY_ALG_HASH_RG         // BLOB
            // OID_SECURITY_CERT_SIGNING_RG     // DWORD
            // OID_SECURITY_HCERTSTORE_RG       // DWORD
            // OID_SECURITY_SYMCAPS_RG          // BLOB
            // OID_SECURITY_AUTHATTR_RG         // BLOB
            // OID_SECURITY_UNAUTHATTR_RG       // BLOB
            // OID_SECURITY_SIGNTIME_RG         // FILETIME
            // OID_SECURITY_USER_VALIDITY_RG    // DWORD
            // OID_SECURITY_RO_MSG_VALIDITY_RG  // DWORD

#ifdef _WIN64
            ULONG cbrgullCertSigning = cSigners * sizeof(ULONGLONG);
            ULONGLONG * rgullCertSigning;
#else   // !_WIN64
            ULONG cbrgdwCertSigning = cSigners * sizeof(DWORD);
            DWORD * rgdwCertSigning;
#endif  // _WIN64

            ULONG cbrgdwUserValidity = cSigners * sizeof(DWORD);
            ULONG cbrgdwROMsgValidity = cSigners * sizeof(DWORD);
            ULONG cbrgftSigntime = cSigners * sizeof(FILETIME);
            ULONG cbrgpvAlgHash = cSigners * sizeof(PROPVARIANT);
            ULONG cbrgpvSymcaps = cSigners * sizeof(PROPVARIANT);
            ULONG cbrgpvAuthattr = cSigners * sizeof(PROPVARIANT);
            ULONG cbrgpvUnauthattr = cSigners * sizeof(PROPVARIANT);
#ifdef SMIME_V3            
            ULONG cbrgpvReceipt = cSigners * sizeof(PROPVARIANT);
            ULONG cbrgpvHash = cSigners * sizeof(PROPVARIANT);
#endif // SMIME_V3            
#ifdef _WIN64
            ULONG cbArrays = cbrgullCertSigning + 
#else
            ULONG cbArrays = cbrgdwCertSigning + 
#endif 
                cbrgdwUserValidity + cbrgdwROMsgValidity +
                cbrgftSigntime + cbrgpvAlgHash + cbrgpvSymcaps + cbrgpvAuthattr +
#ifdef SMIME_V3            
                cbrgpvReceipt +  cbrgpvHash +
#endif // SMIME_V3            
                cbrgpvUnauthattr;

            LPBYTE lpbArrays = NULL;

            LPDWORD rgdwUserValidity;
            LPDWORD rgdwROMsgValidity;
            FILETIME * rgftSigntime;
            PROPVARIANT * rgpvAlgHash;
            PROPVARIANT * rgpvSymcaps;
            PROPVARIANT * rgpvAuthattr;
            PROPVARIANT * rgpvUnauthattr;
#ifdef SMIME_V3            
            PROPVARIANT * rgpvReceipt;
            PROPVARIANT * rgpvHash;
#endif // SMIME_V3            
            
            // Allocate them all at once.
            if (! MemAlloc((LPVOID *)&lpbArrays, cbArrays)) {
                return E_OUTOFMEMORY;
            }
            ZeroMemory(lpbArrays, cbArrays);

            // Set up the pointers
#ifdef _WIN64
            rgullCertSigning = (ULONGLONG *) lpbArrays;
            rgdwUserValidity = (LPDWORD)((LPBYTE)rgullCertSigning + cbrgullCertSigning);
#else  // !_WIN64
            rgdwCertSigning = (DWORD *) lpbArrays;
            rgdwUserValidity = (LPDWORD)((LPBYTE)rgdwCertSigning + cbrgdwCertSigning);
#endif // _WIN64
            rgdwROMsgValidity = (LPDWORD)((LPBYTE)rgdwUserValidity + cbrgdwUserValidity);
            rgftSigntime = (FILETIME *)((LPBYTE)rgdwROMsgValidity + cbrgdwROMsgValidity);
            rgpvAlgHash = (PROPVARIANT *)((LPBYTE)rgftSigntime + cbrgftSigntime);
            rgpvSymcaps = (PROPVARIANT *)((LPBYTE)rgpvAlgHash + cbrgpvAlgHash);
            rgpvAuthattr = (PROPVARIANT *)((LPBYTE)rgpvSymcaps + cbrgpvSymcaps);
            rgpvUnauthattr = (PROPVARIANT *)((LPBYTE)rgpvAuthattr + cbrgpvAuthattr);
#ifdef SMIME_V3            
            rgpvReceipt = (PROPVARIANT *)((LPBYTE)rgpvUnauthattr + cbrgpvUnauthattr);
            rgpvHash = (PROPVARIANT *)((LPBYTE)rgpvReceipt + cbrgpvReceipt);
#endif // SMIME_V3            

            for (iSigner=0, pSigner = psldLoop->m_rgSigners; iSigner<cSigners;
                 iSigner++, pSigner++) {
#ifdef _WIN64
                rgullCertSigning[iSigner] = (ULONGLONG) pSigner->pccert;
#else  // !_WIN64
                rgdwCertSigning[iSigner] = (DWORD) pSigner->pccert;
#endif // _WIN64
                if (pSigner->blobHashAlg.cbSize) {
                    rgpvAlgHash[iSigner].vt = VT_BLOB;
                    rgpvAlgHash[iSigner].blob.cbSize = pSigner->blobHashAlg.cbSize;
                    // Don't need to duplicate
                    rgpvAlgHash[iSigner].blob.pBlobData = pSigner->blobHashAlg.pBlobData;
                }

                if (pSigner->blobAuth.cbSize) {
                    rgpvAuthattr[iSigner].vt = VT_BLOB;
                    rgpvAuthattr[iSigner].blob.cbSize = pSigner->blobAuth.cbSize;
                    // Don't need to duplicate
                    rgpvAuthattr[iSigner].blob.pBlobData = pSigner->blobAuth.pBlobData;

                    //  We want to break out two values from the authenticated blobs and put
                    //  them into someplace easy to access

                    DWORD               cbData = 0;
                    BOOL                f;
                    DWORD               i;
                    PCRYPT_ATTRIBUTES   pattrs = NULL;

                    if ((! HrDecodeObject(pSigner->blobAuth.pBlobData, 
                                          pSigner->blobAuth.cbSize,
                                          szOID_Microsoft_Attribute_Sequence, 0, &cbData,
                                          (LPVOID *)&pattrs)) && pattrs) {

                        FILETIME * pSigningTime = NULL;

                        Assert(pattrs);

                        for (i = 0; i < pattrs->cAttr; i++) {
                            Assert(pattrs->rgAttr[i].cValue == 1);
                            if (lstrcmp(pattrs->rgAttr[i].pszObjId, szOID_RSA_signingTime) == 0) {
#ifndef _WIN64
                                if ((! HrDecodeObject(pattrs->rgAttr[i].rgValue[0].pbData,
                                                      pattrs->rgAttr[i].rgValue[0].cbData,
                                                      X509_CHOICE_OF_TIME, 0, &cbData, (LPVOID *)&pSigningTime)) && pSigningTime) 
#else // _WIN64
                                pVal = &(pattrs->rgAttr[i].rgValue[0]);
                                if ((! HrDecodeObject(pVal->pbData,
                                                      pVal->cbData,
                                                      X509_CHOICE_OF_TIME, 0, &cbData, (LPVOID *)&pSigningTime)) && pSigningTime)        
#endif //_WIN64
                                {
                                    Assert(cbData == sizeof(FILETIME));
                                    memcpy(&rgftSigntime[iSigner], pSigningTime, sizeof(FILETIME));
                                    SafeMemFree(pSigningTime);
                                }
                            }
                            else if (lstrcmp(pattrs->rgAttr[i].pszObjId, szOID_RSA_SMIMECapabilities) == 0) {
                                rgpvSymcaps[iSigner].vt = VT_BLOB;
#ifndef _WIN64

                                rgpvSymcaps[iSigner].blob.cbSize = pattrs->rgAttr[i].rgValue[0].cbData;
                                // Duplicate the blob data since the MemFree(pattrs) will nuke this pointer.
                                rgpvSymcaps[iSigner].blob.pBlobData =
                                    DuplicateMemory(pattrs->rgAttr[i].rgValue[0].pbData, rgpvSymcaps[iSigner].blob.cbSize);
#else // _WIN64
                                pVal = &(pattrs->rgAttr[i].rgValue[0]);
                                rgpvSymcaps[iSigner].blob.cbSize = pVal->cbData;
                                // Duplicate the blob data since the MemFree(pattrs) will nuke this pointer.
                                rgpvSymcaps[iSigner].blob.pBlobData =
                                    DuplicateMemory(pVal->pbData, rgpvSymcaps[iSigner].blob.cbSize);
#endif //_WIN64
                            }
                        }
                        MemFree(pattrs);
                    }
                }

                if (pSigner->blobUnauth.cbSize) {
                    rgpvUnauthattr[iSigner].vt = VT_BLOB;
                    rgpvUnauthattr[iSigner].blob.cbSize = pSigner->blobUnauth.cbSize;
                    // Don't need to duplicate
                    rgpvUnauthattr[iSigner].blob.pBlobData = pSigner->blobUnauth.pBlobData;
                }

#ifdef SMIME_V3
                if (pSigner->blobReceipt.cbSize) {
                    rgpvReceipt[iSigner].vt = VT_BLOB;
                    rgpvReceipt[iSigner].blob.cbSize = pSigner->blobReceipt.cbSize;
                    // Don't need to duplicate
                    rgpvReceipt[iSigner].blob.pBlobData = pSigner->blobReceipt.pBlobData;
                    dwSecurityType |= MST_RECEIPT_REQUEST;
                }

                if (pSigner->blobHash.cbSize) {
                    rgpvHash[iSigner].vt = VT_BLOB;
                    rgpvHash[iSigner].blob.cbSize = pSigner->blobHash.cbSize;
                    // Don't need to duplicate
                    rgpvHash[iSigner].blob.pBlobData = pSigner->blobHash.pBlobData;
                }

#endif // SMIME_V3

                // Signature validity
                rgdwROMsgValidity[iSigner] = pSigner->ulValidity;
            }
            
#ifdef SMIME_V3
            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvReceipt;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_RECEIPT_RG, &var, TRUE, TRUE);
            
            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvHash;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_MESSAGE_HASH_RG, &var, TRUE, TRUE);
#endif // SMIME_V3


            // Set the array options
#ifdef _WIN64
            var.vt = VT_VECTOR | VT_UI8;
            var.cauh.pElems = (ULARGE_INTEGER *)(rgullCertSigning);
            var.cauh.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_CERT_SIGNING_RG_64, &var, TRUE, TRUE);
#else
            var.vt = VT_VECTOR | VT_UI4;
            var.caul.pElems = rgdwCertSigning;
            var.caul.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_CERT_SIGNING_RG, &var, TRUE, TRUE);
#endif // _WIN64

            var.vt = VT_VECTOR | VT_UI4;
            var.caul.pElems = rgdwUserValidity;
            var.caul.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_USER_VALIDITY_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_UI4;
            var.caul.pElems = rgdwROMsgValidity;
            var.caul.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_RO_MSG_VALIDITY_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_FILETIME;
            var.cafiletime.pElems = rgftSigntime;
            var.cafiletime.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_SIGNTIME_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvAlgHash;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_ALG_HASH_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvSymcaps;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_SYMCAPS_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvAuthattr;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_AUTHATTR_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvUnauthattr;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_UNAUTHATTR_RG, &var, TRUE, TRUE);

            // clean up the duplicated rgpvSymcaps
            if (rgpvSymcaps) {
                for (iSigner = 0; iSigner < cSigners; iSigner++) {
                    SafeMemFree(rgpvSymcaps[iSigner].blob.pBlobData);
                }
            }

            // Free the arrays
            SafeMemFree(lpbArrays);
        }

        if (MST_THIS_ENCRYPT & psldLoop->m_dwMsgEnhancement) {
            Assert(psldLoop->m_pccertDecrypt != NULL);
            if (psldLoop->m_pccertDecrypt != NULL) {
#ifdef _WIN64
                var.vt = VT_UI8;
                var.pulVal = (ULONG *) (psldLoop->m_pccertDecrypt);
                pPrivBody->InternalSetOption(OID_SECURITY_CERT_DECRYPTION_64, &var,
                                             TRUE, TRUE);
#else   // !_WIN64
                var.vt = VT_UI4;
                var.ulVal = (ULONG) psldLoop->m_pccertDecrypt;
                pPrivBody->InternalSetOption(OID_SECURITY_CERT_DECRYPTION, &var,
                                             TRUE, TRUE);
#endif  // _WIN64
            }

            //N TODO: convert oids to symcaps
            //BruceK: Why?  Does this make sense on an encrypted layer?  Maybe Erik is
            //  suggesting that we put can gather a little bit of information about
            //  the sender's capabilities from the encryption method he used.  At any
            //  rate, it isn't nearly as important as the signed message case.
            Assert(psldLoop->m_blobDecAlg.cbSize != 0);
            if (psldLoop->m_blobDecAlg.cbSize) {
                var.vt = VT_BLOB;
                var.blob.cbSize = psldLoop->m_blobDecAlg.cbSize;
                var.blob.pBlobData = psldLoop->m_blobDecAlg.pBlobData;
                pPrivBody->InternalSetOption(OID_SECURITY_ALG_BULK, &var,
                                             TRUE, TRUE);
            }
            if (g_FSupportV3 && (psldLoop->m_blobUnprotectAttrs.cbData > 0)) {
                DWORD   iAttr; 
                DWORD   cbData = 0;

                if (psm == NULL) {
                    CHECKHR(hr = pPrivBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &psm));
                }
                CHECKHR(hr = HrDecodeObject(psldLoop->m_blobUnprotectAttrs.pbData,
                                            psldLoop->m_blobUnprotectAttrs.cbData,
                                            szOID_Microsoft_Attribute_Sequence, 0,
                                            &cbData, (LPVOID *) &pattrsUnprot));
                for (iAttr = 0; iAttr < pattrsUnprot->cAttr; iAttr++) {
                    CHECKHR(hr = psm->SetAttribute(0, 0, SMIME_ATTRIBUTE_SET_UNPROTECTED,  
                                                   &pattrsUnprot->rgAttr[iAttr]));
                }
            }
        }

        var.vt = VT_UI4;
        var.ulVal = dwSecurityType;
        pPrivBody->InternalSetOption(OID_SECURITY_TYPE, &var, TRUE, TRUE);

        // M00BUG -- must deal with two?
#ifdef _WIN64
        if (psldLoop->m_hcertstor != NULL) {
            var.vt = VT_UI8;
            var.pulVal = (ULONG *) (psldLoop->m_hcertstor);
            pPrivBody->InternalSetOption(OID_SECURITY_HCERTSTORE_64, &var, TRUE, TRUE);
        }
#else
        if (psldLoop->m_hcertstor != NULL) 
        {
            var.vt = VT_UI4;
            var.ulVal = (ULONG)psldLoop->m_hcertstor;
            pPrivBody->InternalSetOption(OID_SECURITY_HCERTSTORE, &var, TRUE, TRUE);
        }
#endif // _WIN64
    }
    
    hr = S_OK;
exit:
    if (psm != NULL)            psm->Release();
    SafeMemFree(pattrsUnprot);
    if (pPrivBody != NULL)      pPrivBody->Release();
    return hr;
}

/***************************************************************************

    Name      : MergeSMIMEINFO

    Purpose   : 

    Parameters: psiOuter -> Object to be merged into
                psiInner -> Object to merge from

    Returns   : HRESULT of errors

    Comment   :

***************************************************************************/
HRESULT CSMime::MergeSMIMEINFO(SMIMEINFO *psiOuter, SMIMEINFO * psiInner)
{
    PSECURITY_LAYER_DATA        psld;
    
    psiOuter->fCertWithMsg |= psiInner->fCertWithMsg;

    //  Just stick the inner data at the inner most point in the outer data
    //  and the clear out the inner data structure.

    if (psiInner->psldLayers != NULL) {
        for (psld = psiOuter->psldLayers; psld->m_psldInner != NULL;
             psld = psld->m_psldInner);
        psld->m_psldInner = psiInner->psldLayers;
        psiInner->psldLayers = NULL;
    }
    return S_OK;
}

/***************************************************************************

    Name      : FreeSMIMEINFO

    Purpose   : Free and Release the memory and objects stored in the
                SMIMEINFO.

    Parameters: psi -> SMIMEINFO

    Returns   : none

    Comment   :

***************************************************************************/
void CSMime::FreeSMIMEINFO(SMIMEINFO *psi)
{
    register DWORD i;

    if (psi->psldLayers) {
        psi->psldLayers->Release();
    }

    for (i = 0; i < psi->cStores; i++) {
        CertCloseStore(psi->rgStores[i], 0);
    }
    if (psi->rgStores) {
        g_pMoleAlloc->Free(psi->rgStores);
    }

    if (psi->hProv) {
        CryptReleaseContext(psi->hProv, 0);
    }

#ifdef SMIME_V3
    MemFree(psi->pszInnerContent);
    SafeMemFree(psi->pwszKeyPrompt);
#endif // SMIME_V3

    return;
}

#ifdef KILL_THIS
/***************************************************************************

    Name      : MergeSMIMEINFOs

    Purpose   : Merge two SMIMEINFO structures into one

    Parameters: psiOuter -> Source structure
                psiInner -> Destination structure

    Returns   : void

    Comment   :

***************************************************************************/
void CSMime::MergeSMIMEINFOs(const SMIMEINFO *const psiOuter, SMIMEINFO *const psiInner)
{
    PSECURITY_LAYER_DATA psldLoopOuter;
    PSECURITY_LAYER_DATA psldLoopInner;

    psiInner->fCertWithMsg |= psiOuter->fCertWithMsg;

    Assert(0 == (psiOuter->ulMsgValidity & psiInner->ulMsgValidity));
    psiInner->ulMsgValidity |= psiOuter->ulMsgValidity;

    if (psiOuter->dwMsgEnhancement & MST_SIGN_MASK) {
        // Duplicate the stores
        if (psiOuter->cStores) {
            psiInner->rgStores = (HCERTSTORE*)
              g_pMoleAlloc->Alloc(psiOuter->cStores * sizeof(HCERTSTORE));
            if (psiOuter->rgStores) {
                for (DWORD i = 0; i < psiOuter->cStores; i++) {
                    psiInner->rgStores[i] = CertDuplicateStore(psiOuter->rgStores[i]);
                }
                psiInner->cStores = psiOuter->cStores;
            }
        }
    }

    psiInner->dwMsgEnhancement |= psiOuter->dwMsgEnhancement;

    // Before I link in this new list, I'd like to do some error checking.  In particular, I
    // want to aviod loops and duplicates in my linked list.
    psldLoopOuter = psiOuter->psldLayers;
    while (psldLoopOuter) {
        psldLoopInner = psiInner->psldLayers;
        while (psldLoopInner) {
            if (psldLoopInner == psldLoopOuter) {
                AssertSz(FALSE, "MergeSMIMEINFOs found duplicate layer data");
                // OK, we'll just ignore the outer layer data.
                goto exit;
            }
            psldLoopInner = psldLoopInner->m_psldInner;
        }
        psldLoopOuter = psldLoopOuter->m_psldInner;
    }

    // Insert the outer layer data list at the head of the inner list.
    psldLoopInner = psiInner->psldLayers;
    psldLoopOuter = psiOuter->psldLayers;

    psiInner->psldLayers = psldLoopOuter;
    if (psldLoopOuter) {
        // We've linked it into another SMIMEINFO, AddRef.
        psldLoopOuter->AddRef();

        // Walk the Outer list to find the end.
        while (psldLoopOuter) {
            if (! psldLoopOuter->m_psldInner) {
                // Found end of list.  Tack on original inner list here.
                psldLoopOuter->m_psldInner = psldLoopInner;

                // Hook up the Outer link
                Assert(! psldLoopInner->m_psldOuter);
                psldLoopInner->m_psldOuter = psldLoopOuter;
                break;
            }
            psldLoopOuter = psldLoopOuter->m_psldInner;
        }
    }

    // Make sure we bring the encryption layer with us.
    if (psiOuter->psldEncrypt) {
        Assert(! psiInner->psldEncrypt);
        if (! psiInner->psldEncrypt) {
            psiInner->psldEncrypt = psiOuter->psldEncrypt;
        }
    }

    // Update the inner layer pointer (in case there was none before)
    if (! psiInner->psldInner) {
        psiInner->psldInner = psiOuter->psldInner;
    }
    psiInner->ulLayers += psiOuter->ulLayers;

exit:
    return;
}
#endif // KILL_THIS?

#ifndef SMIME_V3
// Bitfield for dw below
#define CAA_SIGNING_TIME        1
#define CAA_SMIME_CAPABILITIES  2
#define CAA_ALL                 (CAA_SIGNING_TIME | CAA_SMIME_CAPABILITIES)

/***************************************************************************

    Name      : ConstructAuthAttributes

    Purpose   : crack open the authenticated attributes blobs and check
                if there is a signing time specified.  If not, we must
                add one.  Ditto with the S/Mime Capabilities.

    Parameters: pblEncoded -> return blob of encoded Authenticated Attributes
                pblAuthAttr -> authenticated attribute blob
                                data pointer may be replaced
                pftSigntime -> signing time
                pblSymcaps -> symcaps blob

    Returns   : HRESULT

    Comment   : The caller should be careful not to cache the
                data pointer within the authenticated attributes blob since
                it may be freed in here and replaced with a different one.

***************************************************************************/
static HRESULT ConstructAuthAttributes(BLOB * pblEncoded, BLOB * pblAuthAttr, FILETIME * pftSigntime,  BLOB * pblSymcaps)
{
    HRESULT             hr = S_OK;
    ULONG               cbData;
    ULONG               i;
    DWORD               dw;     // bitfield: CAA_SIGNING_TIME, CAA_SMIME_CAPABILITIES
    PCRYPT_ATTRIBUTES   pattrs = NULL;
    BOOL                fpattrs = FALSE;
    PCRYPT_ATTRIBUTE    pattr = NULL;
    LPBYTE              pbSignTime = NULL;
    LPBYTE              pbAttr = NULL;
    CRYPT_ATTRIBUTES    attrs;
    CRYPT_ATTR_BLOB     valCaps;
    CRYPT_ATTR_BLOB     valTime;

    Assert(pblAuthAttr);
    Assert(pftSigntime);
    Assert(pblSymcaps);
    Assert(pblEncoded);

    if ((pblAuthAttr->cbSize > 0) &&
        ((! HrDecodeObject(pblAuthAttr->pBlobData, pblAuthAttr->cbSize,
                           szOID_Microsoft_Attribute_Sequence,
                           0, &cbData, (LPVOID *)&pattrs)) && pattrs)) {
        fpattrs = TRUE; // don't forget to free pattrs!
        for (i = 0, dw = CAA_ALL; i < pattrs->cAttr; i++) {
            if (lstrcmp(pattrs->rgAttr[i].pszObjId, szOID_RSA_signingTime) == 0) {
                dw &= ~CAA_SIGNING_TIME;
            }
            else if (lstrcmp(pattrs->rgAttr[i].pszObjId, szOID_RSA_SMIMECapabilities) == 0) {
                dw &= ~CAA_SMIME_CAPABILITIES;
            }
        }
    } else {
        // BUGBUG: Should probably report the error if MemAlloc failed.  As it sits, there is no
        // real harm except that the message will go out without a signing time and symcaps.
        dw = CAA_ALL;
        pattrs = &attrs;
        attrs.cAttr = 0;
        attrs.rgAttr = NULL;
    }

    if (MemAlloc((LPVOID *)&pattr, (pattrs->cAttr + 2) * sizeof(CRYPT_ATTRIBUTE))) {
        memcpy(pattr, pattrs->rgAttr, pattrs->cAttr * sizeof(CRYPT_ATTRIBUTE));
        pattrs->rgAttr = pattr;

        //
        //  The default answer does not have a signing time in it.  We are going
        //      to create and add a signing time.  This may come from either
        //      a passed in parameter, or from the system.
        if (dw & CAA_SIGNING_TIME) {
            if ((pftSigntime->dwLowDateTime == 0) &&
                (pftSigntime->dwHighDateTime == 0)) {
                GetSystemTimeAsFileTime(pftSigntime);   // caller sees it now!
            }

            cbData = 0;
            if (CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                    pftSigntime, CRYPT_ENCODE_ALLOC_FLAG,
                                    &CryptEncodeAlloc, &pbSignTime, &cbData)) {
                // BUGBUG: Should probably report the error if MemAlloc failed.  As it sits, there is no
                // real harm except that the message will go out without a signing time and symcaps.

                pattr[pattrs->cAttr].pszObjId = szOID_RSA_signingTime;
                pattr[pattrs->cAttr].cValue = 1;
                pattr[pattrs->cAttr].rgValue = &valTime;
                pattr[pattrs->cAttr].rgValue[0].pbData = pbSignTime;
                pattr[pattrs->cAttr].rgValue[0].cbData = cbData;
                pattrs->cAttr += 1;
            }
        }
        if (dw & CAA_SMIME_CAPABILITIES) {
            if (pblSymcaps->cbSize > 0) {
                pattr[pattrs->cAttr].pszObjId = szOID_RSA_SMIMECapabilities;
                pattr[pattrs->cAttr].cValue = 1;
                pattr[pattrs->cAttr].rgValue = &valCaps;
                pattr[pattrs->cAttr].rgValue[0].pbData = pblSymcaps->pBlobData;
                pattr[pattrs->cAttr].rgValue[0].cbData = pblSymcaps->cbSize;
                pattrs->cAttr += 1;
            }
        }

        cbData = 0;
        if (CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                 pattrs, CRYPT_ENCODE_ALLOC_FLAG,
                                 &CryptEncodeAlloc, &pbAttr, &cbData)) {
            hr = HrGetLastError();
            goto exit;
        }
        pblEncoded->cbSize = cbData;
        pblEncoded->pBlobData = pbAttr;
        pbAttr = NULL;      // Drop this pointer so that it won't be freed below
    } else {
        hr = E_OUTOFMEMORY;
    }

  exit:
    SafeMemFree(pattr);
    if (fpattrs) {
        SafeMemFree(pattrs);
    }
    SafeMemFree(pbSignTime);

    return(hr);
}
#endif // !SMIME_V3


/***************************************************************************

    Name      : IsSMimeProtocol

    Purpose   : Test if the protocol type of this root message body is
                application/x-pkcs7-signature

    Parameters: lpPropSet -> Property set of message

    Returns   : TRUE if this is an S/MIME protocol message

    Comment   : Used to differentiate between S/MIME and PGP signatures.

***************************************************************************/
BOOL IsSMimeProtocol(LPMIMEPROPERTYSET lpPropSet) {
    PROPVARIANT var;
    BOOL        fReturn = FALSE;

    var.vt = VT_LPSTR;

    if (SUCCEEDED(lpPropSet->GetProp(
      STR_PAR_PROTOCOL,
      0,                  // [in] DWORD dwFlags,
      &var))) {
        if (var.pszVal) {
            fReturn = (! lstrcmpi(var.pszVal, STR_MIME_APPL_PKCS7SIG)) ||
              (! lstrcmpi(var.pszVal, STR_MIME_APPL_PKCS7SIG_1));
            SafeMemFree(var.pszVal);
        }
    }
    return(fReturn);
}


/***************************************************************************

    Name      : DuplicateMemory

    Purpose   : Allocate a new buffer and copy the old one into it.

    Parameters: lpbIn -> Existing buffer
                cbIn = size of lpvIn

    Returns   : new MemAlloc'ed buffer

    Comment   : Caller is responsible for MemFree'ing the returned buffer.

***************************************************************************/
LPBYTE DuplicateMemory(LPBYTE lpvIn, ULONG cbIn) {
    LPBYTE lpbReturn = NULL;

    if (MemAlloc((void**)&lpbReturn, cbIn)) {
        memcpy(lpbReturn, lpvIn, cbIn);
    }

    return(lpbReturn);
}


//*************************************************************************
//                  CSECURITY_LAYER_DATA
//*************************************************************************

///////////////////////////////////////////////////////////////////////////
//
// ctor/dtor
//


CSECURITY_LAYER_DATA::CSECURITY_LAYER_DATA(void)
{
    m_cRef = 1;
    DOUT("CSECURITY_LAYER_DATA::constructor() %#x -> %d", this, m_cRef);

    m_dwMsgEnhancement = MST_NONE;
    m_fCertInLayer = FALSE;

    m_cSigners = 0;
    m_rgSigners = NULL;

    m_cEncryptItems = 0;
#ifdef SMIME_V3
    m_rgRecipientInfo = NULL;
    m_ContentEncryptAlgorithm.pszObjId = NULL;
    m_ContentEncryptAlgorithm.Parameters.cbData = 0;
    m_ContentEncryptAlgorithm.Parameters.pbData = NULL;
    m_pvEncryptAuxInfo = NULL;
    m_blobUnprotectAttrs.pbData = NULL;
    m_blobUnprotectAttrs.cbData = 0;
    m_hstoreEncrypt = NULL;
#else  // !SMIME_V3
    m_rgEncryptItems = NULL;
#endif // SMIME_V3

    m_ulDecValidity = 0;
    m_blobDecAlg.cbSize = 0;
    m_blobDecAlg.pBlobData = NULL;
    m_pccertDecrypt = NULL;

    m_hcertstor = NULL;

    m_psldInner = NULL;
    m_psldOuter = NULL;
}

CSECURITY_LAYER_DATA::~CSECURITY_LAYER_DATA(void)
{
    DWORD       i;
    DWORD       i1;
    DWORD       iSigner;
    DOUT("CSECURITY_LAYER_DATA::destructor() %#x -> %d", this, m_cRef);

    if (m_psldInner != NULL) {
        m_psldInner->Release();
    }
    
    if (m_hcertstor != NULL)            CertCloseStore(m_hcertstor, 0);

    if (m_pccertDecrypt != NULL)        CertFreeCertificateContext(m_pccertDecrypt);
    SafeMemFree(m_blobDecAlg.pBlobData);

    for (iSigner=0; iSigner<m_cSigners; iSigner++) {
        if (m_rgSigners[iSigner].pccert != NULL) 
            CertFreeCertificateContext(m_rgSigners[iSigner].pccert);
        SafeMemFree(m_rgSigners[iSigner].blobHashAlg.pBlobData);
        SafeMemFree(m_rgSigners[iSigner].blobAuth.pBlobData);
        SafeMemFree(m_rgSigners[iSigner].blobUnauth.pBlobData);
#ifdef SMIME_V3
        SafeMemFree(m_rgSigners[iSigner].blobReceipt.pBlobData);
        SafeMemFree(m_rgSigners[iSigner].blobHash.pBlobData);
#endif // SMIME_V3
    }
    SafeMemFree(m_rgSigners);

    for (i=0; i<m_cEncryptItems; i++) {
#ifdef SMIME_V3
        switch (m_rgRecipientInfo[i].dwRecipientChoice) {
        case CMSG_KEY_TRANS_RECIPIENT:
            if (m_rgRecipientInfo[i].pKeyTrans->KeyEncryptionAlgorithm.pszObjId != 0) {
                MemFree(m_rgRecipientInfo[i].pKeyTrans->KeyEncryptionAlgorithm.pszObjId);
                MemFree(m_rgRecipientInfo[i].pKeyTrans->KeyEncryptionAlgorithm.Parameters.pbData);
            }

            if (m_rgRecipientInfo[i].pKeyTrans->pvKeyEncryptionAuxInfo != NULL) {
                MemFree(m_rgRecipientInfo[i].pKeyTrans->pvKeyEncryptionAuxInfo);
            }

            if (m_rgRecipientInfo[i].pKeyTrans->RecipientPublicKey.cbData != 0) {
                MemFree(m_rgRecipientInfo[i].pKeyTrans->RecipientPublicKey.pbData);
            }

            if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.dwIdChoice == CERT_ID_KEY_IDENTIFIER)
            {
                if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.KeyId.cbData != 0) {
                    MemFree(m_rgRecipientInfo[i].pKeyTrans->RecipientId.KeyId.pbData);
                }
            }
            else if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.dwIdChoice == CERT_ID_ISSUER_SERIAL_NUMBER)
            {
                if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.cbData != 0) {
                    MemFree(m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.pbData);
                }
                if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber.cbData != 0) {
                    MemFree(m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber.pbData);
                }
            }

            SafeMemFree(m_rgRecipientInfo[i].pKeyTrans);
            break;

        case CMSG_MAIL_LIST_RECIPIENT:
            if (m_rgRecipientInfo[i].pMailList->KeyEncryptionAlgorithm.pszObjId != 0) {
                MemFree(m_rgRecipientInfo[i].pMailList->KeyEncryptionAlgorithm.pszObjId);
                MemFree(m_rgRecipientInfo[i].pMailList->KeyEncryptionAlgorithm.Parameters.pbData);
            }

            if (m_rgRecipientInfo[i].pMailList->pvKeyEncryptionAuxInfo != NULL) {
                MemFree(m_rgRecipientInfo[i].pMailList->pvKeyEncryptionAuxInfo);
            }

            if (m_rgRecipientInfo[i].pMailList->pOtherAttr != NULL) {
                MemFree(m_rgRecipientInfo[i].pMailList->pOtherAttr->pszObjId);
                MemFree(m_rgRecipientInfo[i].pMailList->pOtherAttr->Value.pbData);
            }

            SafeMemFree(m_rgRecipientInfo[i].pMailList);
            break;

        case CMSG_KEY_AGREE_RECIPIENT:
            if (m_rgRecipientInfo[i].pKeyAgree->KeyEncryptionAlgorithm.pszObjId != 0) {
                MemFree(m_rgRecipientInfo[i].pKeyAgree->KeyEncryptionAlgorithm.pszObjId);
                MemFree(m_rgRecipientInfo[i].pKeyAgree->KeyEncryptionAlgorithm.Parameters.pbData);
            }

            if (m_rgRecipientInfo[i].pKeyAgree->pvKeyEncryptionAuxInfo != NULL) {
                MemFree(m_rgRecipientInfo[i].pKeyAgree->pvKeyEncryptionAuxInfo);
            }

            SafeMemFree(m_rgRecipientInfo[i].pKeyAgree);
            break;

        default:
            Assert(FALSE);
            break;
        }
#else  // SMIME_V3
        SafeMemFree(m_rgEncryptItems[i].Transport.blobAlg.pBlobData);
        switch (m_rgEncryptItems[i].dwTagType) {
        case ENCRYPT_ITEM_TRANSPORT:
            for (i1=0; i1<m_rgEncryptItems[i].Transport.cCert; i1++) {
                CertFreeCertificateContext(m_rgEncryptItems[i].Transport.rgpccert[i1]);
            }
            SafeMemFree(m_rgEncryptItems[i].Transport.rgpccert);
            break;
            
        default:
            Assert(FALSE);
            break;
        }
#endif // SMIME_V3
    }
#ifdef SMIME_V3
    SafeMemFree(m_rgRecipientInfo);
    SafeMemFree(m_pvEncryptAuxInfo);
    SafeMemFree(m_ContentEncryptAlgorithm.pszObjId);
    SafeMemFree(m_ContentEncryptAlgorithm.Parameters.pbData);
    SafeMemFree(m_blobUnprotectAttrs.pbData);
    CertCloseStore(m_hstoreEncrypt, 0);
#else  // SMIME_V3
    SafeMemFree(m_rgEncryptItems);
#endif // SMIME_V3
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//

STDMETHODIMP CSECURITY_LAYER_DATA::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid) {
        *ppv = THIS_AS_UNK;
    }
    else if (IID_IStream == riid) {
        *ppv = (IStream *)this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CSECURITY_LAYER_DATA::AddRef(void)
{
    DOUT("CSECURITY_LAYER_DATA::AddRef() %#x -> %d", this, m_cRef+1);
    InterlockedIncrement((LPLONG)&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSECURITY_LAYER_DATA::Release(void)
{
    DOUT("CSECURITY_LAYER_DATA::Release() %#x -> %d", this, m_cRef-1);

    if (0 == InterlockedDecrement((LPLONG)&m_cRef)) {
        delete this;
        return 0;
    }
    return m_cRef;
}

#ifdef SMIME_V3
/***    HrCopyOID
 *
 * Description:
 *      General utility function to make copying of recipient info objects much easier
 */

HRESULT HrCopyOID(LPCSTR psz, LPSTR * ppsz)
{
    DWORD       cb;
    HRESULT     hr = S_OK;

    cb = strlen(psz) + 1;
    CHECKHR(hr = HrAlloc((void **) ppsz, cb));
    memcpy(*ppsz, psz, cb);

exit:
    return hr;
}

/***    HrCopyCryptDataBlob
 *
 * Description:
 *      General utility function to make copying of recipient info objects much easier
 */

HRESULT HrCopyCryptDataBlob(const CRYPT_DATA_BLOB * pblobSrc, PCRYPT_DATA_BLOB pblobDst)
{
    HRESULT     hr = S_OK;
    
    if (pblobSrc->cbData == 0) {
        Assert(pblobDst->pbData == NULL);
        Assert(pblobDst->cbData == 0);
        goto exit;
    }
    
    CHECKHR(hr = HrAlloc((void **) &pblobDst->pbData, pblobSrc->cbData));
    memcpy(pblobDst->pbData, pblobSrc->pbData, pblobSrc->cbData);
    pblobDst->cbData = pblobSrc->cbData;

exit:
    return hr;
}

/***    HrCopyCryptDataBlob
 *
 * Description:
 *      General utility function to make copying of recipient info objects much easier
 */

HRESULT HrCopyCryptBitBlob(const CRYPT_BIT_BLOB * pblobSrc, PCRYPT_BIT_BLOB pblobDst)
{
    HRESULT     hr = S_OK;
    
    if (pblobSrc->cbData == 0) {
        Assert(pblobDst->pbData == NULL);
        Assert(pblobDst->cbData == 0);
        goto exit;
    }
    
    CHECKHR(hr = HrAlloc((void **) &pblobDst->pbData, pblobSrc->cbData));
    memcpy(pblobDst->pbData, pblobSrc->pbData, pblobSrc->cbData);
    pblobDst->cbData = pblobSrc->cbData;
    pblobDst->cUnusedBits = pblobSrc->cUnusedBits;

exit:
    return hr;
}

HRESULT HrCopyCryptAlgorithm(const CRYPT_ALGORITHM_IDENTIFIER * pAlgSrc,
                             PCRYPT_ALGORITHM_IDENTIFIER pAlgDst)
{
    HRESULT     hr = S_OK;
    
    CHECKHR(hr = HrCopyOID(pAlgSrc->pszObjId, &pAlgDst->pszObjId));

    if (pAlgSrc->Parameters.cbData != 0) {
        CHECKHR(hr = HrCopyCryptDataBlob(&pAlgSrc->Parameters, &pAlgDst->Parameters));
    }

exit:
    return hr;
}

HRESULT HrCopyCertId(const CERT_ID * pcertidSrc, PCERT_ID pcertidDst)
{
    HRESULT     hr = S_OK;

    pcertidDst->dwIdChoice = pcertidSrc->dwIdChoice;
    switch (pcertidSrc->dwIdChoice) {
    case CERT_ID_ISSUER_SERIAL_NUMBER:
        hr = HrCopyCryptDataBlob(&pcertidSrc->IssuerSerialNumber.Issuer,
                                 &pcertidDst->IssuerSerialNumber.Issuer);
        hr = HrCopyCryptDataBlob(&pcertidSrc->IssuerSerialNumber.SerialNumber,
                                 &pcertidDst->IssuerSerialNumber.SerialNumber);
        break;
        
    case CERT_ID_KEY_IDENTIFIER:
        hr = HrCopyCryptDataBlob(&pcertidSrc->HashId, &pcertidDst->HashId);
        break;
        
    case CERT_ID_SHA1_HASH:
        hr = HrCopyCryptDataBlob(&pcertidSrc->HashId, &pcertidDst->HashId);
        break;
        
    default:
        return E_FAIL;
    }

    return hr;
}

/***    FreeRecipientInfo
 *
 * Description:
 *      Free all of the data pointed to by the recipient info as well as the recipient
 *      info object itself.
 */

void FreeRecipientInfoContent(PCMS_RECIPIENT_INFO pRecipInfo)
{
    if (pRecipInfo->pccert != NULL) {
        CertFreeCertificateContext(pRecipInfo->pccert);
    }

    if (pRecipInfo->KeyEncryptionAlgorithm.pszObjId != 0) {
        MemFree(pRecipInfo->KeyEncryptionAlgorithm.pszObjId);
        MemFree(pRecipInfo->KeyEncryptionAlgorithm.Parameters.pbData);
    }

    if (pRecipInfo->pvKeyEncryptionAuxInfo != NULL) {
        MemFree(pRecipInfo->pvKeyEncryptionAuxInfo);
    }

    if ((pRecipInfo->dwU1 == CMS_RECIPIENT_INFO_PUBKEY_KEYTRANS) &&
        (pRecipInfo->u1.SubjectPublicKey.cbData != 0)) {
        MemFree(pRecipInfo->u1.SubjectPublicKey.pbData);
    }

    if (pRecipInfo->dwU1 == CMS_RECIPIENT_INFO_PUBKEY_PROVIDER) {
        Assert(FALSE);
    }

    if (pRecipInfo->dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL) {
        if (pRecipInfo->u3.IssuerSerial.Issuer.cbData != 0) {
            MemFree(pRecipInfo->u3.IssuerSerial.Issuer.pbData);
        }
        if (pRecipInfo->u3.IssuerSerial.SerialNumber.cbData != 0) {
            MemFree(pRecipInfo->u3.IssuerSerial.SerialNumber.pbData);
        }
    }

    if (pRecipInfo->dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) {
        if (pRecipInfo->u3.KeyId.cbData != 0) {
            MemFree(pRecipInfo->u3.KeyId.pbData);
        }
    }

    if (pRecipInfo->pOtherAttr != NULL) {
        MemFree(pRecipInfo->pOtherAttr->pszObjId);
        MemFree(pRecipInfo->pOtherAttr->Value.pbData);
    }

    return;
}
#endif // SMIME_V3

/* * * END --- SMIME.CPP --- END * * */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\variantx.cpp ===
// --------------------------------------------------------------------------------
// VariantX.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "variantx.h"
#include "wchar.h"
#include "internat.h"
#include "symcache.h"
#include "dllmain.h"
#include "containx.h"
#include <shlwapi.h>
#include "mimeapi.h"
#include "strconst.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Helper Prototypes
// --------------------------------------------------------------------------------
HRESULT HrWriteHeaderFormatA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT HrWriteHeaderFormatW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT HrWriteNameInDataA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT HrWriteNameInDataW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);

// --------------------------------------------------------------------------------
// International Conversion Prototypes
// --------------------------------------------------------------------------------
HRESULT Internat_StringA_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT, LPSTR *);
HRESULT Internat_StringA_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT, LPWSTR *);
HRESULT Internat_StringW_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT, LPWSTR *);
HRESULT Internat_StringW_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT, LPSTR *);

// --------------------------------------------------------------------------------
// Variant Conversion Function Prototype
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFNVARIANTCONVERT)(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);

// --------------------------------------------------------------------------------
// Converter Prototypes
// --------------------------------------------------------------------------------
HRESULT StringA_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringA_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringA_To_Variant(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringW_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringW_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringW_To_Variant(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT Variant_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT Variant_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT Variant_To_Variant(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);

// --------------------------------------------------------------------------------
// VCASSERTARGS - Common Invalid Arg Assert Macro
// --------------------------------------------------------------------------------
#define VCASSERTARGS(_typeSource, _typeDest) \
    Assert(pConvert && pSource && pDest && pSource->type == _typeSource); \
    if (MVT_STRINGA == _typeDest) \
        Assert(MVT_STRINGA == pDest->type || MVT_STREAM == pDest->type); \
    else if (MVT_STRINGW == _typeDest) \
        Assert(MVT_STRINGW == pDest->type || MVT_STREAM == pDest->type); \
    else \
        Assert(_typeDest == pDest->type);

// --------------------------------------------------------------------------------
// VARIANTCONVERTMAP
// --------------------------------------------------------------------------------
typedef struct tagVARIANTCONVERTMAP {
    PFNVARIANTCONVERT pfnConvertTo[MVT_LAST];
} VARIANTCONVERTMAP;

// --------------------------------------------------------------------------------
// PVC - Cast to PFNVARIANTCONVERT
// --------------------------------------------------------------------------------
#define PVC(_function) ((PFNVARIANTCONVERT)_function)

// --------------------------------------------------------------------------------
// Variant Conversion Map
// --------------------------------------------------------------------------------
static const VARIANTCONVERTMAP g_rgVariantX[MVT_LAST - 1] = {
    { NULL, NULL,                    NULL,                    NULL,                    NULL                    }, // MVT_EMPTY
    { NULL, PVC(StringA_To_StringA), PVC(StringA_To_StringW), PVC(StringA_To_Variant), PVC(StringA_To_StringA) }, // MVT_STRINGA / MVT_STREAM 
    { NULL, PVC(StringW_To_StringA), PVC(StringW_To_StringW), PVC(StringW_To_Variant), PVC(StringW_To_StringA) }, // MVT_STRINGW
    { NULL, PVC(Variant_To_StringA), PVC(Variant_To_StringW), PVC(Variant_To_Variant), PVC(Variant_To_StringA) }, // MVT_VARIANT
};

// --------------------------------------------------------------------------------
// _HrConvertVariant - Looks up the correct Variant Conversion function
// --------------------------------------------------------------------------------
#define _HrConvertVariant(_typeSource, _typeDest, _pConvert, _pSource, _pDest) \
    (*(g_rgVariantX[_typeSource].pfnConvertTo[_typeDest]))(_pConvert, _pSource, _pDest)

// --------------------------------------------------------------------------------
// HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT HrConvertVariant(
        /* in */        LPHEADOPTIONS       pOptions,
        /* in */        LPPROPSYMBOL        pSymbol,
        /* in */        LPINETCSETINFO      pCharset,
        /* in */        ENCODINGTYPE        ietSource,
        /* in */        DWORD               dwFlags, 
        /* in */        DWORD               dwState, 
        /* in */        LPMIMEVARIANT       pSource, 
        /* in,out */    LPMIMEVARIANT       pDest,
        /* out,opt */   BOOL               *pfRfc1522 /* = NULL */)
{
    // Locals
    HRESULT         hr=S_OK;
    VARIANTCONVERT  rConvert;

    // Invalid Arg
    Assert(pOptions && pSymbol && pSource && pDest && pOptions->pDefaultCharset);
    Assert(IET_ENCODED == ietSource || IET_DECODED == ietSource);

    // Init
    if (pfRfc1522)
        *pfRfc1522 = FALSE;

    // Failure
    if (!ISVALIDVARTYPE(pSource->type) || !ISVALIDVARTYPE(pDest->type))
    {
        AssertSz(FALSE, "An invalid VARTYPE was encountered!");
        hr = TraceResult(MIME_E_VARTYPE_NO_CONVERT);
        goto exit;
    }

    // Init pDest
    pDest->fCopy = FALSE;

    // Init rConvert
    ZeroMemory(&rConvert, sizeof(VARIANTCONVERT));
    rConvert.pOptions = pOptions;
    rConvert.pSymbol = pSymbol;
    rConvert.pCharset = pCharset ? pCharset : pOptions->pDefaultCharset;
    rConvert.ietSource = ietSource;
    rConvert.dwFlags = dwFlags;
    rConvert.dwState = dwState;

    // Remove PRSTATE_RFC1522
    FLAGCLEAR(rConvert.dwState, PRSTATE_RFC1522);

    // Valid Charset
    Assert(g_rgVariantX[pSource->type].pfnConvertTo[pDest->type]);

    // Remove Comments and fixup the source...
    if (ISFLAGSET(dwFlags, PDF_NOCOMMENTS) && (MVT_STRINGA == pSource->type || MVT_STRINGW == pSource->type))
    {
        // Locals
        MIMEVARIANT     rVariant;
        BYTE            rgbScratch[256];

        // Init
        ZeroMemory(&rVariant, sizeof(MIMEVARIANT));

        // Strip Comments
        if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
        {
            // Change the Source
            pSource = &rVariant;

            // Remove CF_NOALLOC
            FLAGCLEAR(dwFlags, CVF_NOALLOC);
        }

        // Do the Conversion
        hr = _HrConvertVariant(pSource->type, pDest->type, &rConvert, pSource, pDest);

        // Free the Variant
        MimeVariantFree(&rVariant);

        // Failure
        if (FAILED(hr))
        {
            TrapError(hr);
            goto exit;
        }
    }

    // Otherwise, normal Conversion
    else
    {
        // Do the Conversion
        CHECKHR(hr = _HrConvertVariant(pSource->type, pDest->type, &rConvert, pSource, pDest));
    }

    // 1522 Encoded ?
    if (pfRfc1522 && ISFLAGSET(rConvert.dwState, PRSTATE_RFC1522))
        *pfRfc1522 = TRUE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringA_To_StringA
// --------------------------------------------------------------------------------
HRESULT StringA_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszFree=NULL;
    MIMEVARIANT     rVariant;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGA);

    // Invalid Arg
    if (ISVALIDSTRINGA(&pSource->rStringA) == FALSE)
        return TrapError(E_INVALIDARG);

    // Init pDest
    if (MVT_STRINGA == pDest->type)
    {
        pDest->rStringA.pszVal = NULL;
        pDest->rStringA.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));
    rVariant.type = MVT_STRINGA;

    // Is International Property
    CHECKHR(hr = Internat_StringA_To_StringA(pConvert, pSource, &rVariant, &pszFree));

    // If Transmit, setup wrapinfo
    if (ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT))
    {
        // WriteHeaderFormatA
        CHECKHR(hr = HrWriteHeaderFormatA(pConvert, &rVariant, pDest));
    }

    // Wanted in a stream
    else if (MVT_STREAM == pDest->type)
    {
        // No Stream...
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Write to the stream
        CHECKHR(hr = pDest->pStream->Write(rVariant.rStringA.pszVal, rVariant.rStringA.cchVal, NULL));
    }

    // MVT_STRINGA
    else if (MVT_STRINGA == pDest->type)
    {
        // If Writing Transmit (Write Header Name)
        if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
        {
            // Write Name Into Data
            CHECKHR(hr = HrWriteNameInDataA(pConvert, &rVariant, pDest));
        }

        // No Conversion
        else if (rVariant.rStringA.pszVal == pSource->rStringA.pszVal)
        {
            // Copy
            CHECKHR(hr = HrMimeVariantCopy(pConvert->dwFlags, &rVariant, pDest));
        }

        // Is Equal to pszFree
        else if (rVariant.rStringA.pszVal == pszFree)
        {
            // Just Copy It
            CopyMemory(pDest, &rVariant, sizeof(MIMEVARIANT));

            // Not a copy
            pDest->fCopy = FALSE;

            // Don't free pszFree
            pszFree = NULL;
        }

        // Big Problem
        else
            Assert(FALSE);
    }

    // Big Problem
    else
        Assert(FALSE);

exit:
    // Cleanup 
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringA_To_StringW
// --------------------------------------------------------------------------------
HRESULT StringA_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pszFree=NULL;
    MIMEVARIANT     rVariant;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGW);

    // Invalid Arg
    if (ISVALIDSTRINGA(&pSource->rStringA) == FALSE)
        return TrapError(E_INVALIDARG);

    // Init pDest
    if (MVT_STRINGW == pDest->type)
    {
        pDest->rStringW.pszVal = NULL;
        pDest->rStringW.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));
    rVariant.type = MVT_STRINGW;

    // Internat Conversion
    CHECKHR(hr = Internat_StringA_To_StringW(pConvert, pSource, &rVariant, &pszFree));

    // If Transmit, setup wrapinfo
    if (ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT))
    {
        // WriteHeaderFormatW
        CHECKHR(hr = HrWriteHeaderFormatW(pConvert, &rVariant, pDest));
    }

    // MVT_STREAM
    else if (MVT_STREAM == pDest->type)
    {
        // No Stream...
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Write to the stream
        CHECKHR(hr = pDest->pStream->Write(rVariant.rStringW.pszVal, rVariant.rStringW.cchVal, NULL));
    }
    
    // MVT_STRINGW
    else if (MVT_STRINGW == pDest->type)
    {
        // If Writing Transmit (Write Header Name)
        if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
        {
            CHECKHR(hr = HrWriteNameInDataW(pConvert, &rVariant, pDest));
        }

        // Equal to Data that we Allocated
        else if (rVariant.rStringW.pszVal == pszFree)
        {
            // Copy Memory
            CopyMemory(pDest, &rVariant, sizeof(MIMEVARIANT));

            // Not a copy
            pDest->fCopy = FALSE;

            // Don't Free pszFree
            pszFree = NULL;
        }

        // Big Problem
        else
            Assert(FALSE);
    }

    // Big Problem
    else
        Assert(FALSE);

exit:
    // Cleanup 
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringA_To_Variant
// --------------------------------------------------------------------------------
HRESULT StringA_To_Variant(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           psz;
    MIMEVARIANT     rVariant;
    BYTE            rgbScratch[255];

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_VARIANT);
    Assert(!ISFLAGSET(pConvert->dwFlags, PDF_ENCODED) && !ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT));

    // Init
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_STRINGA_TO_VARIANT))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_STRINGA_TO_VARIANT, pConvert->dwFlags, pSource, pDest));
    }

    // Otherwise, use default converter
    else
    {
        // Handle Variant Type
        switch(pDest->rVariant.vt)
        {
        case VT_UI4:
            // Strip Comments
            if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
                pSource = &rVariant;

            // Convert to ULONG
            pDest->rVariant.ulVal = strtoul(pSource->rStringA.pszVal, &psz, 10);
            break;

        case VT_I4:
            // Strip Comments
            if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
                pSource = &rVariant;

            // Convert to Long
            pDest->rVariant.lVal = strtol(pSource->rStringA.pszVal, &psz, 10);
            break;

        case VT_FILETIME:
            CHECKHR(hr = MimeOleInetDateToFileTime(pSource->rStringA.pszVal, &pDest->rVariant.filetime));
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

exit:
    // Cleanup
    MimeVariantFree(&rVariant);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringW_To_StringA
// --------------------------------------------------------------------------------
HRESULT StringW_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszFree=NULL;
    MIMEVARIANT     rVariant;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGA);

    // Invalid Arg
    if (ISVALIDSTRINGW(&pSource->rStringW) == FALSE)
        return TrapError(E_INVALIDARG);

    // Init pDest
    if (MVT_STRINGA == pDest->type)
    {
        pDest->rStringA.pszVal = NULL;
        pDest->rStringA.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));
    rVariant.type = MVT_STRINGA;

    // Internat Conversion
    CHECKHR(hr = Internat_StringW_To_StringA(pConvert, pSource, &rVariant, &pszFree));

    // If Transmit, setup wrapinfo
    if (ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT))
    {
        // WriteHeaderFormatA
        CHECKHR(hr = HrWriteHeaderFormatA(pConvert, &rVariant, pDest));
    }

    // Wanted in a stream
    else if (MVT_STREAM == pDest->type)
    {
        // No Stream...
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Write to the stream
        CHECKHR(hr = pDest->pStream->Write(rVariant.rStringA.pszVal, rVariant.rStringA.cchVal, NULL));
    }

    // MVT_STRINGA
    else if (MVT_STRINGA == pDest->type)
    {
        // If Writing Transmit (Write Header Name)
        if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
        {
            // Write Name Into Data
            CHECKHR(hr = HrWriteNameInDataA(pConvert, &rVariant, pDest));
        }

        // Is Equal to pszFree
        else if (rVariant.rStringA.pszVal == pszFree)
        {
            // Copy Memory
            CopyMemory(pDest, &rVariant, sizeof(MIMEVARIANT));

            // Not a Copy
            pDest->fCopy = FALSE;

            // Don't Free pszFree
            pszFree = NULL;
        }

        // Big Problem
        else
            Assert(FALSE);
    }

    // Big Problem
    else
        Assert(FALSE);

exit:
    // Cleanup 
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringW_To_StringW
// --------------------------------------------------------------------------------
HRESULT StringW_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rVariant;
    LPWSTR          pszFree=NULL;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGW);

    // Invalid Arg
    if (ISVALIDSTRINGW(&pSource->rStringW) == FALSE)
        return TrapError(E_INVALIDARG);

    // Init pDest
    if (MVT_STRINGW == pDest->type)
    {
        pDest->rStringW.pszVal = NULL;
        pDest->rStringW.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));
    rVariant.type = MVT_STRINGW;

    // Internat Conversion
    CHECKHR(hr = Internat_StringW_To_StringW(pConvert, pSource, &rVariant, &pszFree));

    // If Transmit, setup wrapinfo
    if (ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT))
    {
        // WriteHeaderFormatW
        CHECKHR(hr = HrWriteHeaderFormatW(pConvert, &rVariant, pDest));
    }

    // Wanted in a stream
    else if (MVT_STREAM == pDest->type)
    {
        // No Stream...
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Write to the stream
        CHECKHR(hr = pDest->pStream->Write(rVariant.rStringW.pszVal, rVariant.rStringW.cchVal, NULL));
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pDest->type)
    {
        // If Writing Transmit (Write Header Name)
        if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
        {
            CHECKHR(hr = HrWriteNameInDataW(pConvert, &rVariant, pDest));
        }

        // No Change
        else if (rVariant.rStringW.pszVal == pSource->rStringW.pszVal)
        {
            // Copy
            CHECKHR(hr = HrMimeVariantCopy(pConvert->dwFlags, &rVariant, pDest));
        }

        // Is Decoded Data
        else if (rVariant.rStringW.pszVal == pszFree)
        {
            // Copy Memory
            CopyMemory(pDest, &rVariant, sizeof(MIMEVARIANT));

            // Not a Copy
            pDest->fCopy = FALSE;

            // Don't Free pszFree
            pszFree = NULL;
        }

        // Problem
        else
            Assert(FALSE);
    }

    // Problem
    else
        Assert(FALSE);

exit:
    // Cleanup 
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringW_To_Variant
// --------------------------------------------------------------------------------
HRESULT StringW_To_Variant(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwsz;
    LPSTR           pszANSI=NULL;
    MIMEVARIANT     rVariant;
    BYTE            rgbScratch[255];

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_VARIANT);
    Assert(!ISFLAGSET(pConvert->dwFlags, PDF_ENCODED) && !ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT));

    // Init
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_STRINGW_TO_VARIANT))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_STRINGW_TO_VARIANT, pConvert->dwFlags, pSource, pDest));
    }

    // Otherwise, use default converter
    else
    {
        // Handle Variant Type
        switch(pDest->rVariant.vt)
        {
        case VT_UI4:
            // Strip Comments
            if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
                pSource = &rVariant;

            // Convert to ulong
            pDest->rVariant.ulVal = StrToUintW(pSource->rStringW.pszVal);
            break;

        case VT_I4:
            // Strip Comments
            if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
                pSource = &rVariant;

            // Convert to Long
            pDest->rVariant.lVal = StrToIntW(pSource->rStringW.pszVal);
            break;

        case VT_FILETIME:
            // Convert Unicode to ANSI
            CHECKALLOC(pszANSI = PszToANSI(CP_ACP, pSource->rStringW.pszVal));

            // String to FileTime
            CHECKHR(hr = MimeOleInetDateToFileTime(pSource->rStringA.pszVal, &pDest->rVariant.filetime));
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

exit:
    // Cleanup
    SafeMemFree(pszANSI);
    MimeVariantFree(&rVariant);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Variant_To_StringA
// --------------------------------------------------------------------------------
HRESULT Variant_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            sz[255];
    MIMEVARIANT     rValue;

    // Invalid Arg
    VCASSERTARGS(MVT_VARIANT, MVT_STRINGA);

    // Init pDest
    if (MVT_STRINGA == pDest->type)
    {
        pDest->rStringA.pszVal = NULL;
        pDest->rStringA.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));
    rValue.type = MVT_STRINGA;

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_VARIANT_TO_STRINGA))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_VARIANT_TO_STRINGA, pConvert->dwFlags, pSource, &rValue));
    }

    // Otherwise, default translator
    else
    {
        // Handle Variant Type
        switch(pSource->rVariant.vt)
        {
        case VT_UI4:
            rValue.rStringA.pszVal = sz;
            rValue.rStringA.cchVal = wnsprintfA(rValue.rStringA.pszVal, ARRAYSIZE(sz), "%d", pSource->rVariant.ulVal);
            break;

        case VT_I4:
            rValue.rStringA.pszVal = sz;
            rValue.rStringA.cchVal = wnsprintfA(rValue.rStringA.pszVal, ARRAYSIZE(sz), "%d", pSource->rVariant.lVal);
            break;

        case VT_FILETIME:
            CHECKHR(hr = MimeOleFileTimeToInetDate(&pSource->rVariant.filetime, sz, sizeof(sz)));
            rValue.rStringA.pszVal = sz;
            rValue.rStringA.cchVal = lstrlen(sz);
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

    // VX_StringA_To_StringA
    CHECKHR(hr = StringA_To_StringA(pConvert, &rValue, pDest));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Variant_To_StringW
// --------------------------------------------------------------------------------
HRESULT Variant_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszVal=NULL;
    WCHAR           wsz[255];
    CHAR            szData[CCHMAX_INTERNET_DATE];
    MIMEVARIANT     rValue;

    // Invalid Arg
    VCASSERTARGS(MVT_VARIANT, MVT_STRINGW);

    // Init pDest
    if (MVT_STRINGW == pDest->type)
    {
        pDest->rStringW.pszVal = NULL;
        pDest->rStringW.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));
    rValue.type = MVT_STRINGW;

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_VARIANT_TO_STRINGW))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_VARIANT_TO_STRINGW, pConvert->dwFlags, pSource, &rValue));
    }

    // Otherwise, use default converter
    else
    {
        // Handle Variant Type
        switch(pSource->rVariant.vt)
        {
        case VT_UI4:
            rValue.rStringW.pszVal = wsz;
            rValue.rStringW.cchVal = wnsprintfW(rValue.rStringW.pszVal, ARRAYSIZE(wsz), L"%d", pSource->rVariant.ulVal);
            break;

        case VT_I4:
            rValue.rStringW.pszVal = wsz;
            rValue.rStringW.cchVal = wnsprintfW(rValue.rStringW.pszVal, ARRAYSIZE(wsz), L"%d", pSource->rVariant.lVal);
            break;

        case VT_FILETIME:
            CHECKHR(hr = MimeOleFileTimeToInetDate(&pSource->rVariant.filetime, szData, sizeof(szData)));
            CHECKALLOC(pwszVal = PszToUnicode(CP_ACP, szData));
            rValue.rStringW.pszVal = pwszVal;
            rValue.rStringW.cchVal = lstrlenW(pwszVal);
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

    // VX_StringA_To_StringA
    CHECKHR(hr = StringW_To_StringW(pConvert, &rValue, pDest));

exit:
    // Cleanup
    SafeMemFree(pwszVal);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Variant_To_Variant
// --------------------------------------------------------------------------------
HRESULT Variant_To_Variant(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_VARIANT, MVT_VARIANT);

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_VARIANT_TO_VARIANT))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_VARIANT_TO_VARIANT, pConvert->dwFlags, pSource, pDest));
    }

    // Otherwise, use default converter
    else
    {
        // Handle Variant Type
        switch(pSource->rVariant.vt)
        {
        case VT_UI4:
            switch(pDest->rVariant.vt)
            {
            case VT_UI4:
                pDest->rVariant.ulVal = pSource->rVariant.ulVal;
                break;

            case VT_I4:
                pDest->rVariant.lVal = (LONG)pSource->rVariant.ulVal;
                break;

            default:
                hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
                goto exit;
            }
            break;

        case VT_I4:
            switch(pDest->rVariant.vt)
            {
            case VT_UI4:
                pDest->rVariant.ulVal = (ULONG)pSource->rVariant.lVal;
                break;

            case VT_I4:
                pDest->rVariant.lVal = pSource->rVariant.lVal;
                break;

            default:
                hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
                goto exit;
            }
            break;

        case VT_FILETIME:
            switch(pDest->rVariant.vt)
            {
            case VT_FILETIME:
                CopyMemory(&pDest->rVariant.filetime, &pSource->rVariant.filetime, sizeof(FILETIME));
                break;

            default:
                hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
                goto exit;
            }
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrMimeVariantCopy
// --------------------------------------------------------------------------------
HRESULT HrMimeVariantCopy(DWORD dwFlags, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    Assert(pSource && pDest);

    // CVF_NOALLOC
    if (ISFLAGSET(dwFlags, CVF_NOALLOC))
    {
        // Just Copy It
        CopyMemory(pDest, pSource, sizeof(MIMEVARIANT));

        // Set fCopy so we don't free it
        pDest->fCopy = TRUE;
    }

    // Allocate Memory
    else
    {
        // Not a Copy
        pDest->fCopy = FALSE;

        // MVT_STRINGA
        if (MVT_STRINGA == pSource->type)
        {
            // Validate
            Assert(ISVALIDSTRINGA(&pSource->rStringA));

            // Set Dest Type
            pDest->type = MVT_STRINGA;

            // Allocate Memory
            CHECKALLOC(pDest->rStringA.pszVal = (LPSTR)g_pMalloc->Alloc(pSource->rStringA.cchVal + 1));

            // Copy the memory
            CopyMemory(pDest->rStringA.pszVal, pSource->rStringA.pszVal, pSource->rStringA.cchVal + 1);

            // Return the Size
            pDest->rStringA.cchVal = pSource->rStringA.cchVal;
        }

        // MVT_STRINGW
        else if (MVT_STRINGW == pSource->type)
        {
            // Validate
            Assert(ISVALIDSTRINGW(&pSource->rStringW));

            // Set Dest Type
            pDest->type = MVT_STRINGW;

            // Compute CB
            ULONG cb = ((pSource->rStringW.cchVal + 1) * sizeof(WCHAR));

            // Allocate Memory
            CHECKALLOC(pDest->rStringW.pszVal = (LPWSTR)g_pMalloc->Alloc(cb));

            // Copy the memory
            CopyMemory(pDest->rStringW.pszVal, pSource->rStringW.pszVal, cb);

            // Return the Size
            pDest->rStringW.cchVal = pSource->rStringW.cchVal;
        }

        // MVT_VARIANT
        else if (MVT_VARIANT == pSource->type)
        {
            // Set Dest Type
            pDest->type = MVT_VARIANT;

            // Copy the Variant
            CopyMemory(&pDest->rVariant, &pSource->rVariant, sizeof(PROPVARIANT));
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrWriteNameInDataA
// --------------------------------------------------------------------------------
HRESULT HrWriteNameInDataA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGA);

    // Generic STuff
    pDest->fCopy = FALSE;

    // pszNamed
    DWORD cchSize = (pSource->rStringA.cchVal + 3 + pConvert->pSymbol->cchName);
    CHECKALLOC(pDest->rStringA.pszVal = (LPSTR)g_pMalloc->Alloc(cchSize));

    // Write the named header
    pDest->rStringA.cchVal = wnsprintf(pDest->rStringA.pszVal, cchSize, "%s: %s", pConvert->pSymbol->pszName, pSource->rStringA.pszVal);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrWriteNameInDataW
// --------------------------------------------------------------------------------
HRESULT HrWriteNameInDataW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cb;
    LPWSTR      pszName=NULL;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGW);

    // Generic STuff
    pDest->fCopy = FALSE;

    // Convert Name to Unicode
    CHECKALLOC(pszName = PszToUnicode(CP_ACP, pConvert->pSymbol->pszName));

    // Compute CB
    cb = ((pSource->rStringW.cchVal + 3 + lstrlenW(pszName)) * sizeof(WCHAR));

    // pszNamed
    CHECKALLOC(pDest->rStringW.pszVal = (LPWSTR)g_pMalloc->Alloc(cb));

    // Write the named header
    pDest->rStringW.cchVal = wnsprintfW(pDest->rStringW.pszVal, (cb/sizeof(WCHAR)), L"%s: %s", pszName, pSource->rStringW.pszVal);

exit:
    // Cleanup
    SafeMemFree(pszName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrWriteHeaderFormatA
// --------------------------------------------------------------------------------
HRESULT HrWriteHeaderFormatA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pStream;
    CByteStream     cByteStream;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGA);

    // Generic Stuff
    pDest->fCopy = FALSE;

    // I need a stream to write to...
    if (MVT_STREAM == pDest->type)
    {
        // Validate the stream
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Save the Stream
        pStream = pDest->pStream;
    }

    // Otherwise, create my own stream
    else
        pStream = &cByteStream;

    // If Writing Transmit (Write Header Name)
    if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
    {
        // Write the header name
        CHECKHR(hr = pStream->Write(pConvert->pSymbol->pszName, pConvert->pSymbol->cchName, NULL));

        // Write Colon
        CHECKHR(hr = pStream->Write(c_szColonSpace, lstrlen(c_szColonSpace), NULL));
    }

    // If not rfc1522 Encoded
    if (FALSE == ISFLAGSET(pConvert->dwState, PRSTATE_RFC1522))
    {
        // PID_HDR_CNTID
        if (PID_HDR_CNTID == pConvert->pSymbol->dwPropId)
        {
            // If not a < yet...
            if ('<' != pSource->rStringA.pszVal[0])
            {
                // Write it
                CHECKHR(hr = pStream->Write(c_szEmailStart, lstrlen(c_szEmailStart), NULL));
            }

            // Write the data
            CHECKHR(hr = pStream->Write(pSource->rStringA.pszVal, pSource->rStringA.cchVal, NULL));

            // >
            if ('>' != pSource->rStringA.pszVal[pSource->rStringA.cchVal - 1])
            {
                // Write it
                CHECKHR(hr = pStream->Write(c_szEmailEnd, lstrlen(c_szEmailEnd), NULL));
            }

            // Write CRLF
            CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));
        }

        // Do a wrap text
        else
        {
            // Wrap pszData to the stream
            CHECKHR(hr = MimeOleWrapHeaderText(CP_USASCII, pConvert->pOptions->cbMaxLine, pSource->rStringA.pszVal, pSource->rStringA.cchVal, pStream));
        }
    }

    // Otherwise
    else
    {
        // Write the data
        CHECKHR(hr = pStream->Write(pSource->rStringA.pszVal, pSource->rStringA.cchVal, NULL));

        // Write CRLF
        CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));
    }

    // MVT_STRINGA
    if (MVT_STRINGA == pDest->type)
    {
        // pStream better be the byte stream
        Assert(pStream == &cByteStream);

        // Get string from stream...
        CHECKHR(hr = cByteStream.HrAcquireStringA(&pDest->rStringA.cchVal, &pDest->rStringA.pszVal, ACQ_DISPLACE));
    }
    else
        Assert(MVT_STREAM == pDest->type);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrWriteHeaderFormatW
// --------------------------------------------------------------------------------
HRESULT HrWriteHeaderFormatW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    return TrapError(MIME_E_VARTYPE_NO_CONVERT);
}

// --------------------------------------------------------------------------------
// Internat_StringA_To_StringA
// --------------------------------------------------------------------------------
HRESULT Internat_StringA_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, LPSTR *ppszFree)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGA);

    // Init
    pDest->rStringA.pszVal = NULL;
    *ppszFree = NULL;

    // Internat
    if (ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET))
    {
        // Encoded...
        if (ISFLAGSET(pConvert->dwFlags, PDF_ENCODED))
        {
            // Save no encode
            if (!ISFLAGSET(pConvert->dwState, PRSTATE_SAVENOENCODE))
            {
                // Decode the Property
                if (SUCCEEDED(g_pInternat->HrEncodeProperty(pConvert, pSource, pDest)))
                    *ppszFree = pDest->rStringA.pszVal;
            }
        }

        // Decoded
        else if (IET_ENCODED == pConvert->ietSource)
        {
            // Decode Property
            if (SUCCEEDED(g_pInternat->HrDecodeProperty(pConvert, pSource, pDest)))
                *ppszFree = pDest->rStringA.pszVal;
        }
    }

    // Default
    if (NULL == pDest->rStringA.pszVal)
    {
        // Check State
        Assert(NULL == *ppszFree);

        // Copy It
        pDest->rStringA.pszVal = pSource->rStringA.pszVal;
        pDest->rStringA.cchVal = pSource->rStringA.cchVal;

        // pDest is a copy
        pDest->fCopy = TRUE;
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Internat_StringW_To_StringW
// --------------------------------------------------------------------------------
HRESULT Internat_StringW_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, LPWSTR *ppszFree)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGW);

    // Init
    pDest->rStringW.pszVal = NULL;
    *ppszFree = NULL;

    // Internat
    if (ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET))
    {
        // Encoded...
        if (ISFLAGSET(pConvert->dwFlags, PDF_ENCODED))
        {
            // Save no encode
            if (!ISFLAGSET(pConvert->dwState, PRSTATE_SAVENOENCODE))
            {
                // Decode the Property
                if (SUCCEEDED(g_pInternat->HrEncodeProperty(pConvert, pSource, pDest)))
                    *ppszFree = pDest->rStringW.pszVal;
            }
        }

        // Decoded
        else if (IET_ENCODED == pConvert->ietSource)
        {
            // Decode Property
            if (SUCCEEDED(g_pInternat->HrDecodeProperty(pConvert, pSource, pDest)))
                *ppszFree = pDest->rStringW.pszVal;
        }
    }

    // Default
    if (NULL == pDest->rStringW.pszVal)
    {
        // Check State
        Assert(NULL == *ppszFree);

        // Copy It
        pDest->rStringW.pszVal = pSource->rStringW.pszVal;
        pDest->rStringW.cchVal = pSource->rStringW.cchVal;

        // Its a copy 
        pDest->fCopy = TRUE;
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Internat_StringA_To_StringW
// --------------------------------------------------------------------------------
HRESULT Internat_StringA_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, LPWSTR *ppszFree)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGW);

    // Init
    pDest->rStringW.pszVal = NULL;
    *ppszFree = NULL;

    // Internat
    if (ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET))
    {
        // Encoded...
        if (ISFLAGSET(pConvert->dwFlags, PDF_ENCODED))
        {
            // Save no encode
            if (!ISFLAGSET(pConvert->dwState, PRSTATE_SAVENOENCODE))
            {
                // Decode the Property
                if (SUCCEEDED(g_pInternat->HrEncodeProperty(pConvert, pSource, pDest)))
                    *ppszFree = pDest->rStringW.pszVal;
            }
        }

        // Decoded
        else if (IET_ENCODED == pConvert->ietSource)
        {
            // Decode Property
            if (SUCCEEDED(g_pInternat->HrDecodeProperty(pConvert, pSource, pDest)))
                *ppszFree = pDest->rStringW.pszVal;
        }
    }

    // Simple Conversion to Unicode
    if (NULL == pDest->rStringW.pszVal)
    {
        // Check State
        Assert(NULL == *ppszFree);

        // HrMultiByteToWideChar
        CHECKHR(hr = g_pInternat->HrMultiByteToWideChar(pConvert->pCharset->cpiWindows, &pSource->rStringA, &pDest->rStringW));

        // Save Charset/Encoding
        pDest->fCopy = FALSE;

        // Save pwszWide
        *ppszFree = pDest->rStringW.pszVal;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Internat_StringW_To_StringA
// --------------------------------------------------------------------------------
HRESULT Internat_StringW_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, LPSTR *ppszFree)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGA);

    // Init
    pDest->rStringA.pszVal = NULL;
    *ppszFree = NULL;

    // Internat
    if (ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET))
    {
        // Encoded...
        if (ISFLAGSET(pConvert->dwFlags, PDF_ENCODED))
        {
            // Save no encode
            if (!ISFLAGSET(pConvert->dwState, PRSTATE_SAVENOENCODE))
            {
                // Decode the Property
                if (SUCCEEDED(g_pInternat->HrEncodeProperty(pConvert, pSource, pDest)))
                    *ppszFree = pDest->rStringA.pszVal;
            }
        }

        // Decoded
        else if (IET_ENCODED == pConvert->ietSource)
        {
            // Decode Property
            if (SUCCEEDED(g_pInternat->HrDecodeProperty(pConvert, pSource, pDest)))
                *ppszFree = pDest->rStringA.pszVal;
        }
    }

    // Simple Conversion to Unicode
    if (NULL == pDest->rStringA.pszVal)
    {
        // Check State
        Assert(NULL == *ppszFree);

        // HrMultiByteToWideChar
        CHECKHR(hr = g_pInternat->HrWideCharToMultiByte(pConvert->pCharset->cpiWindows, &pSource->rStringW, &pDest->rStringA));

        // Save Charset/Encoding
        pDest->fCopy = FALSE;

        // Save pwszWide
        *ppszFree = pDest->rStringA.pszVal;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeVariantFree
// --------------------------------------------------------------------------------
void MimeVariantFree(LPMIMEVARIANT pVariant)
{
    // Invalid Arg
    Assert(pVariant);

    // If not a copy
    if (FALSE == pVariant->fCopy)
    {
        // MVT_STRINGA
        if (MVT_STRINGA == pVariant->type && NULL != pVariant->rStringA.pszVal)
            g_pMalloc->Free(pVariant->rStringA.pszVal);

        // MVT_STRINGW
        else if (MVT_STRINGW == pVariant->type && NULL != pVariant->rStringW.pszVal)
            g_pMalloc->Free(pVariant->rStringW.pszVal);
    }

    // Zero Out the Structure
    ZeroMemory(pVariant, sizeof(MIMEVARIANT));
}

// ---------------------------------------------------------------------------------------
// MimeVariantCleanupFileName
// ---------------------------------------------------------------------------------------
void MimeVariantCleanupFileName(CODEPAGEID codepage, LPMIMEVARIANT pVariant)
{
    // Locals
    ULONG       i=0;

    // MVT_STRINGA
    if (MVT_STRINGA == pVariant->type && ISVALIDSTRINGA(&pVariant->rStringA))
    {
        // Cleanup
        pVariant->rStringA.cchVal = CleanupFileNameInPlaceA(codepage, pVariant->rStringA.pszVal);
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pVariant->type && ISVALIDSTRINGW(&pVariant->rStringW))
    {
        // Cleanup
        pVariant->rStringW.cchVal = CleanupFileNameInPlaceW(pVariant->rStringW.pszVal);
    }

    // Hmmm....
    else
        Assert(FALSE);

    // Done
    return;
}

// ---------------------------------------------------------------------------------------
// MimeVariantStripComments
// ---------------------------------------------------------------------------------------
HRESULT MimeVariantStripComments(LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, LPBYTE pbScratch, ULONG cbScratch)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchVal=0;
    BOOL        fInQuoted=FALSE;
    ULONG       cNested=0;

    // Init
    ZeroMemory(pDest, sizeof(MIMEVARIANT));

    // MVT_STRINGA
    if (MVT_STRINGA == pSource->type && ISVALIDSTRINGA(&pSource->rStringA))
    {
        // Locals
        LPSTR psz;

        // Setup pDest
        pDest->type = MVT_STRINGA;

        // Dup It
        if (pSource->rStringA.cchVal + 1 <= cbScratch)
        {
            pDest->fCopy = TRUE;
            pDest->rStringA.pszVal = (LPSTR)pbScratch;
        }

        // Otherwise, allocate memory
        else
        {
            // Allocate
            CHECKALLOC(pDest->rStringA.pszVal = (LPSTR)g_pMalloc->Alloc(pSource->rStringA.cchVal + 1));
        }

        // Setup Loop
        psz = pSource->rStringA.pszVal;
        while(*psz)
        {
            // If lead byte, skip it, its leagal
            if (IsDBCSLeadByte(*psz))
            {
                pDest->rStringA.pszVal[cchVal++] = *psz++;
                pDest->rStringA.pszVal[cchVal++] = *psz++;
            }

            // Starting Comment
            else if ('(' == *psz && !fInQuoted)
            {
                cNested++;
                psz++;
            }

            // Ending Comment
            else if (')' == *psz && !fInQuoted)
            {
                cNested--;
                psz++;
            }

            // Otherwise, if not nested, append
            else if (!cNested)
            {
                // Copy the Char
                pDest->rStringA.pszVal[cchVal++] = *psz++;

                // Check for Quote
                if ('\"' == *psz)
                    fInQuoted = (fInQuoted) ? FALSE : TRUE;
            }

            // Skip Char
            else
                psz++;
        }

        // No Change
        if (cchVal == pSource->rStringA.cchVal)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Null It
        pDest->rStringA.pszVal[cchVal] = '\0';
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pSource->type && ISVALIDSTRINGW(&pSource->rStringW))
    {
        // Locals
        LPWSTR pwsz;

        // Setup pDest
        pDest->type = MVT_STRINGW;

        // Dup It
        if ((pSource->rStringW.cchVal + 1) * sizeof(WCHAR) <= cbScratch)
        {
            pDest->fCopy = TRUE;
            pDest->rStringW.pszVal = (LPWSTR)pbScratch;
        }

        // Otherwise, allocate memory
        else
        {
            // Dup It
            CHECKALLOC(pDest->rStringW.pszVal = (LPWSTR)g_pMalloc->Alloc((pSource->rStringW.cchVal + 1) * sizeof(WCHAR)));
        }

        // Setup Loop
        pwsz = pSource->rStringW.pszVal;
        while(*pwsz)
        {
            // Starting Comment
            if (L'(' == *pwsz && !fInQuoted)
            {
                cNested++;
                pwsz++;
            }

            // Ending Comment
            if (L')' == *pwsz && !fInQuoted)
            {
                cNested--;
                pwsz++;
            }

            // Otherwise, if not nested, append
            else if (!cNested)
            {
                // Copy the Character
                pDest->rStringW.pszVal[cchVal++] = *pwsz++;

                // Check for Quote
                if (L'\"' == *pwsz)
                    fInQuoted = (fInQuoted) ? FALSE : TRUE;
            }

            // Skip Char
            else
                pwsz++;
        }

        // No Change
        if (cchVal == pSource->rStringW.cchVal)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Null It
        pDest->rStringW.pszVal[cchVal] = L'\0';
    }

    // Hmmm....
    else
        Assert(FALSE);

exit:
    // Cleanup
    if (FAILED(hr))
        MimeVariantFree(pDest);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\variantx.h ===
// --------------------------------------------------------------------------------
// VariantX.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __VARIANTX_H
#define __VARIANTX_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef class CMimePropertyContainer *LPCONTAINER;
typedef struct tagMIMEVARIANT *LPMIMEVARIANT;
typedef struct tagPROPSYMBOL *LPPROPSYMBOL;
typedef struct tagHEADOPTIONS *LPHEADOPTIONS;

// --------------------------------------------------------------------------------
// MIMEVARTYPE
// --------------------------------------------------------------------------------
typedef enum tagMIMEVARTYPE {
    MVT_EMPTY,             // The Variant is Empty
    MVT_STRINGA,           // Ansi/multibyte string
    MVT_STRINGW,           // Unicode String
    MVT_VARIANT,           // PropVariant
    MVT_STREAM,            // Internal type used to when saving properties
    MVT_LAST               // Illegal, don't use
} MIMEVARTYPE;

// ---------------------------------------------------------------------------------------
// ISSUPPORTEDVT
// ---------------------------------------------------------------------------------------
#define ISSUPPORTEDVT(_vt) \
    (VT_LPSTR == _vt || VT_LPWSTR == _vt || VT_FILETIME == _vt || VT_UI4 == _vt || VT_I4 == _vt || VT_STREAM == _vt)

// ---------------------------------------------------------------------------------------
// ISVALIDVARTYPE
// ---------------------------------------------------------------------------------------
#define ISVALIDVARTYPE(_vartype) \
    (_vartype > MVT_EMPTY && _vartype < MVT_LAST)

// ---------------------------------------------------------------------------------------
// ISVALIDSTRINGA - Validates a PROPSTRINGA
// ---------------------------------------------------------------------------------------
#define ISVALIDSTRINGA(_pStringA) \
    (NULL != (_pStringA) && NULL != (_pStringA)->pszVal && '\0' == (_pStringA)->pszVal[(_pStringA)->cchVal])

// ---------------------------------------------------------------------------------------
// ISVALIDSTRINGW - Validates a PROPSTRINGW
// ---------------------------------------------------------------------------------------
#define ISVALIDSTRINGW(_pStringW) \
    (NULL != (_pStringW) && NULL != (_pStringW)->pszVal && L'\0' == (_pStringW)->pszVal[(_pStringW)->cchVal])

// ---------------------------------------------------------------------------------------
// ISSTRINGA - Determines if a MIMEVARIANT is a valid MVT_STRINGA
// ---------------------------------------------------------------------------------------
#define ISSTRINGA(_pVariant) \
    (NULL != (_pVariant) && MVT_STRINGA == (_pVariant)->type && ISVALIDSTRINGA(&((_pVariant)->rStringA)))

// ---------------------------------------------------------------------------------------
// ISSTRINGW - Determines if a MIMEVARIANT is a valid MVT_STRINGW
// ---------------------------------------------------------------------------------------
#define ISSTRINGW(_pVariant) \
    (NULL != (_pVariant) && MVT_STRINGW == (_pVariant)->type && ISVALIDSTRINGW(&((_pVariant)->rStringW)))

// ---------------------------------------------------------------------------------------
// PSZSTRINGA - Derefs rStringA.pszVal or uses _pszDefault if not a valid string
// ---------------------------------------------------------------------------------------
#define PSZSTRINGA(_pVariant) \
    (ISSTRINGA((_pVariant)) ? (_pVariant)->rStringA.pszVal : NULL)

// ---------------------------------------------------------------------------------------
// PSZDEFSTRINGA - Derefs rStringA.pszVal or uses _pszDefault if not a valid string
// ---------------------------------------------------------------------------------------
#define PSZDEFSTRINGA(_pVariant, _pszDefault) \
    (ISSTRINGA((_pVariant)) ? (_pVariant)->rStringA.pszVal : _pszDefault)

// --------------------------------------------------------------------------------
// PROPSTRINGA
// --------------------------------------------------------------------------------
typedef struct tagPROPSTRINGA {
    LPSTR               pszVal;             // Pointer to multibyte string    
    ULONG               cchVal;             // Number of characters in psz
} PROPSTRINGA, *LPPROPSTRINGA;
typedef const PROPSTRINGA *LPCPROPSTRINGA;

// --------------------------------------------------------------------------------
// PROPSTRINGW
// --------------------------------------------------------------------------------
typedef struct tagPROPSTRINGW {
    LPWSTR              pszVal;             // Pointer to multibyte string    
    ULONG               cchVal;             // Number of characters in psz
} PROPSTRINGW, *LPPROPSTRINGW;
typedef const PROPSTRINGW *LPCPROPSTRINGW;

// --------------------------------------------------------------------------------
// MIMEVARIANT
// --------------------------------------------------------------------------------
typedef struct tagMIMEVARIANT {
    MIMEVARTYPE         type;               // Property Data Type
    BYTE                fCopy;              // The data was copied, don't free it
    union {
        PROPSTRINGA     rStringA;           // MVT_STRINGA
        PROPSTRINGW     rStringW;           // MVT_STRINGW
        PROPVARIANT     rVariant;           // MVT_VARIANT
        LPSTREAM        pStream;            // MVT_STREAM
    };
} MIMEVARIANT, *LPMIMEVARIANT;
typedef const MIMEVARIANT *LPCMIMEVARIANT;

// --------------------------------------------------------------------------------
// Convert Variant Flags (WARNING: DO NOT OVERFLAG PROPDATAFLAGS WITH THESE)
// --------------------------------------------------------------------------------
#define CVF_NOALLOC     FLAG32              // Tells the converter to copy data if it can

// --------------------------------------------------------------------------------
// VARIANTCONVERT
// --------------------------------------------------------------------------------
typedef struct tagVARIANTCONVERT {
    LPHEADOPTIONS       pOptions;           // Header Options
    LPPROPSYMBOL        pSymbol;            // Property Symbol
    LPINETCSETINFO      pCharset;           // Charset to use in conversion
    ENCODINGTYPE        ietSource;          // Encoding of source item
    DWORD               dwFlags;            // Property Data Flags
    DWORD               dwState;            // PRSTATE_xxx Flags
} VARIANTCONVERT, *LPVARIANTCONVERT;

// --------------------------------------------------------------------------------
// HrMimeVariantCopy
// --------------------------------------------------------------------------------
HRESULT HrMimeVariantCopy(
        /* in */        DWORD               dwFlags,  // CVF_xxx Flags
        /* in */        LPMIMEVARIANT       pSource, 
        /* out */       LPMIMEVARIANT       pDest);

// --------------------------------------------------------------------------------
// HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT HrConvertVariant(
        /* in */        LPHEADOPTIONS       pOptions,
        /* in */        LPPROPSYMBOL        pSymbol,
        /* in */        LPINETCSETINFO      pCharset,
        /* in */        ENCODINGTYPE        ietSource,
        /* in */        DWORD               dwFlags, 
        /* in */        DWORD               dwState,
        /* in */        LPMIMEVARIANT       pSource, 
        /* in,out */    LPMIMEVARIANT       pDest,
        /* out,opt */   BOOL               *pfRfc1522=NULL);

// --------------------------------------------------------------------------------
// MimeVariantFree
// --------------------------------------------------------------------------------
void MimeVariantFree(
        /* in */        LPMIMEVARIANT       pVariant);

// --------------------------------------------------------------------------------
// MimeVariantCleanupFileName
// --------------------------------------------------------------------------------
void MimeVariantCleanupFileName(
        /* in */        CODEPAGEID          codepage, 
        /* in,out */    LPMIMEVARIANT       pVariant);

// --------------------------------------------------------------------------------
// MimeVariantStripComments
// --------------------------------------------------------------------------------
HRESULT MimeVariantStripComments(
        /* in */        LPMIMEVARIANT       pSource, 
        /* in,out */    LPMIMEVARIANT       pDest,
        /* in,out */    LPBYTE              pbScratch, 
        /* in */        ULONG               cbScratch);


// ---------------------------------------------------------------------------------------
// MimeVT_To_PropVT
// ---------------------------------------------------------------------------------------
inline VARTYPE MimeVT_To_PropVT(LPMIMEVARIANT pVariant) {
    Assert(pVariant);
    if (MVT_STRINGA == pVariant->type)
        return(VT_LPSTR);
    else if (MVT_STRINGW == pVariant->type)
        return(VT_LPWSTR);
    else if (MVT_VARIANT == pVariant->type)
        return(pVariant->rVariant.vt);
    else
        return(VT_EMPTY);
}

#endif // __VARIANTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\vstream.cpp ===
// --------------------------------------------------------------------------------
// Vstream.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Ronald E. Gray
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "vstream.h"
#include "dllmain.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Utilities
// --------------------------------------------------------------------------------
inline ULONG ICeil(ULONG x, ULONG interval)
{
    return (x ? (((x-1)/interval) + 1) * interval : 0);
}

// --------------------------------------------------------------------------------
// CVirtualStream::CVirtualStream
// --------------------------------------------------------------------------------
CVirtualStream::CVirtualStream(void)
{
    m_cRef          = 1; 
    m_cbSize        = 0;
    m_cbCommitted   = 0;
    m_cbAlloc       = 0;
    m_dwOffset      = 0;
    m_pstm          = NULL;
    m_pb            = 0;
    m_fFileErr      = FALSE;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CVirtualStream::~CVirtualStream
// --------------------------------------------------------------------------------
CVirtualStream::~CVirtualStream(void)
{
    if (m_pb)
        VirtualFree(m_pb, 0, MEM_RELEASE);
    if (m_pstm)
        m_pstm->Release();

    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CVirtualStream::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CVirtualStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (    (IID_IUnknown == riid)
        ||  (IID_IStream == riid)
        ||  (IID_IVirtualStream == riid))
        *ppv = (IStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    AddRef();

    // Done
    return (ResultFromScode(S_OK));
}

// --------------------------------------------------------------------------------
// CVirtualStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CVirtualStream::AddRef(void)
{
    return InterlockedIncrement((LONG*)&m_cRef);
}


// --------------------------------------------------------------------------------
// CVirtualStream::SyncFileStream
// --------------------------------------------------------------------------------
HRESULT CVirtualStream::SyncFileStream()
{
    LARGE_INTEGER   li;
    HRESULT         hr;

    // figure out where to set the file stream be subtracting the memory portion
    // of the stream from the offset
#ifdef MAC
    if (m_dwOffset < m_cbAlloc)
        LISet32(li, 0);
    else
    {
        LISet32(li, m_dwOffset);
        li.LowPart -= m_cbAlloc;
    }
#else   // !MAC
    if (m_dwOffset < m_cbAlloc)
        li.QuadPart = 0;
    else
        li.QuadPart = m_dwOffset - m_cbAlloc;
#endif  // MAC

    // seek in the stream
    hr = m_pstm->Seek(li, STREAM_SEEK_SET, NULL);

    // reset the file err member based on the current error
    m_fFileErr = !!hr;

    return hr;
}
// --------------------------------------------------------------------------------
// CVirtualStream::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CVirtualStream::Release(void)
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_cRef);
    if (0 != cRef)
    {
#ifdef	DEBUG
        return cRef;
#else
        return 0;
#endif
    }
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CVirtualStream::Read
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CVirtualStream::Read(LPVOID pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CVirtualStream::Read(VOID HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    HRESULT     hr      = ResultFromScode(S_OK);
    ULONG       cbGet   = 0;

        // Check
    AssertWritePtr(pv, cb);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // if the steam pointer is possibly out of sync
    // resync
    if (m_fFileErr)
    {
        hr = SyncFileStream();
        if (hr) goto err;
    }
    
    // make sure there's something to read
    if (m_dwOffset < m_cbSize)
    {
        // figure out what we're getting out of memory
        if (m_dwOffset < m_cbCommitted)
        {
            if (m_cbSize > m_cbCommitted)
                cbGet = min(cb, m_cbCommitted - m_dwOffset);
            else
                cbGet = min(cb, m_cbSize - m_dwOffset);
            // copy the memory stuff
            CopyMemory((LPBYTE)pv, m_pb + m_dwOffset, cbGet);

        }

        // if we still have stuff to read
        // and we've used all of the memory
        // and we do have a stream, try to get the rest of the data out of the stream
        if (    (cbGet != cb)
           &&   (m_cbCommitted == m_cbAlloc)
           &&   m_pstm)
        {
            ULONG           cbRead;

    #ifdef	DEBUG
            LARGE_INTEGER   li  = {0, 0};
            ULARGE_INTEGER  uli = {0, 0};

            if (!m_pstm->Seek(li, STREAM_SEEK_CUR, &uli))
#ifdef MAC
                Assert(((m_dwOffset + cbGet) - m_cbAlloc) == uli.LowPart);
#else   // !MAC
                Assert(((m_dwOffset + cbGet) - m_cbAlloc) == uli.QuadPart);
#endif  // MAC
    #endif
            hr = m_pstm->Read(((LPBYTE)pv) + cbGet, cb - cbGet, &cbRead);
            if (hr)
            {
                m_fFileErr = TRUE;
                goto err;
            }

            cbGet += cbRead;
        }

        m_dwOffset += cbGet;
    }
    
    if (pcbRead)
        *pcbRead = cbGet;
err:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CVirtualStream::SetSize
// --------------------------------------------------------------------------------
HRESULT CVirtualStream::SetSize(ULARGE_INTEGER uli)
{
    // Locals
    HRESULT     hr          = ResultFromScode(S_OK);
    ULONG       cbDemand    = uli.LowPart;
    ULONG       cbCommit    = ICeil(cbDemand, g_dwSysPageSize);
    
    if (uli.HighPart != 0)
		return(ResultFromScode(STG_E_MEDIUMFULL));
        
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // if we haven't initialized memory, do it now
    if (!m_cbAlloc)
    {
        LPVOID  pv;
        ULONG   cb  = 32 * g_dwSysPageSize; // use 32 pages

        while ((!(pv = VirtualAlloc(NULL, cb, MEM_RESERVE, PAGE_READWRITE)))
               && (cb > g_dwSysPageSize))
        {
            cb /= 2;
        }
        if (!pv)
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
            goto err;
        }
        m_cbAlloc   = cb;
        m_pb        = (LPBYTE)pv;
    }
        
    if (cbCommit  < m_cbCommitted)
    {
        // shrink the stream
        LPBYTE  pb  =m_pb;
        ULONG   cb;

        // figure out the begining of the last page in the range not used
        pb += cbCommit;

        // figure out the size of the range being decommitted
        cb = m_cbCommitted - cbCommit;
                  
#ifndef MAC
        VirtualFree(pb, cb, MEM_DECOMMIT);
#endif  // !MAC

        // figure out what we have left committed
        m_cbCommitted = cbCommit;
        
    }
    else if (cbCommit > m_cbCommitted)
    {
        LPBYTE  pb;

        // figure out how much memory to commit
        cbCommit = (cbDemand <= m_cbAlloc)
                   ?    ICeil(cbDemand,  g_dwSysPageSize)
                   :    m_cbAlloc;

        if (cbCommit > m_cbCommitted)
        {
#ifndef MAC
            if (!VirtualAlloc(m_pb, cbCommit, MEM_COMMIT, PAGE_READWRITE))
            {
                hr = ResultFromScode(E_OUTOFMEMORY);
                goto err;
            }
#endif  // !MAC
        }

        m_cbCommitted = cbCommit;

        // Wow, we've used all of memory, start up the disk
        if (cbDemand > m_cbAlloc)
        {
            ULARGE_INTEGER uliAlloc;

            // no stream? better create it now
            if (!m_pstm)
            {                
                hr = CreateTempFileStream(&m_pstm);
                if (hr) goto err;
            }
            uliAlloc.LowPart = cbDemand - m_cbAlloc;
            uliAlloc.HighPart = 0;
            
            hr = m_pstm->SetSize(uliAlloc);
            if (hr) goto err;
            
            // if the current offset beyond the end of the memory allocation,
            // initialize the stream pointer correctly
            if (m_dwOffset > m_cbAlloc)
            {
                hr = SyncFileStream();
                if (hr) goto err;
            }
        }
    }

    m_cbSize = cbDemand;
    
err:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CVirtualStream::QueryStat
// --------------------------------------------------------------------------------
STDMETHODIMP CVirtualStream::Stat(STATSTG *pStat, DWORD grfStatFlag)
{
    // Invalid Arg
    if (NULL == pStat)
        return TrapError(E_INVALIDARG);

    // Fill pStat
    pStat->type = STGTY_STREAM;
    pStat->cbSize.HighPart = 0;
    pStat->cbSize.LowPart = m_cbSize;

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CVirtualStream::QueryStat
// --------------------------------------------------------------------------------
void CVirtualStream::QueryStat(ULARGE_INTEGER *puliOffset, ULARGE_INTEGER *pulSize)
{
#ifdef MAC
    if (puliOffset)
        ULISet32(*puliOffset, m_dwOffset);
    if (pulSize)
        ULISet32(*pulSize, m_cbSize);
#else   // !MAC
    if (puliOffset)
        puliOffset->QuadPart = (LONGLONG)m_dwOffset;
    if (pulSize)
        pulSize->QuadPart = (LONGLONG)m_cbSize;
#endif  // MAC
}

// --------------------------------------------------------------------------------
// CVirtualStream::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CVirtualStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    // Locals
    HRESULT     hr  = ResultFromScode(S_OK);
    BOOL    	fForward;
	ULONG       ulOffset;
#ifdef MAC
    ULONG       llCur;
#else   // !MAC
	LONGLONG    llCur;
#endif  // MAC

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // look for starting position
	if (dwOrigin == STREAM_SEEK_CUR)
		llCur = m_dwOffset;
	else if (dwOrigin == STREAM_SEEK_END)
		llCur = m_cbSize;
	else
		llCur = 0;

#ifdef MAC
    Assert(0 == dlibMove.HighPart);
    llCur += dlibMove.LowPart;
#else   // !MAC
    llCur += dlibMove.QuadPart;
#endif  // MAC

    // limit to 4 Gig
    if (llCur > 0xFFFFFFFF)
        goto seekerr;

    // if we have a stream and
    // we are currently in the file stream or the new seek seeks into the 
    // stream and the seek will not grow the stream, reseek in the stream
    if (    m_pstm
        &&  (   (m_dwOffset > m_cbAlloc)
            ||  (llCur > m_cbAlloc))
        &&  (llCur <= m_cbSize))
    {
        LARGE_INTEGER   li;
        
#ifdef MAC
        LISet32(li ,llCur < m_cbAlloc ? 0 : llCur - m_cbAlloc);
#else   // !MAC
        li.QuadPart = llCur < m_cbAlloc ? 0 : llCur - m_cbAlloc;
#endif  // MAC

        hr = m_pstm->Seek(li, STREAM_SEEK_SET, NULL);
        if (hr)
        {
            m_fFileErr = TRUE;
            goto err;
        }
    }

    m_dwOffset = (ULONG)llCur;

	if (plibNewPosition)
#ifdef MAC
        LISet32(*plibNewPosition, llCur);
#else   // !MAC
        plibNewPosition->QuadPart = llCur;
#endif  // MAC

err:
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    return hr;
    
seekerr:
	hr = ResultFromScode(STG_E_MEDIUMFULL);
    goto err;
    // Done
}


// --------------------------------------------------------------------------------
// CVirtualStream::Write
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CVirtualStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
#else
STDMETHODIMP CVirtualStream::Write(const void HUGEP *pv, ULONG cb, ULONG *pcbWritten)
#endif // !WIN16
{
    // Locals
    HRESULT     hr      = ResultFromScode(S_OK);
    ULONG       cbNew;
    ULONG       cbWrite = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // figure out where we'll end up
    cbNew = cb + m_dwOffset;

    // make sure that we won't wrap
    if (cbNew < m_dwOffset)
        goto stmfull;

    // if that is past the end of the stream, make more stream
    if (cbNew > m_cbSize)
    {
        ULARGE_INTEGER uli = {cbNew, 0};
        hr = SetSize(uli);
        if (hr) goto err;
    }
        
    // figure out what we're putting into memory
    if (m_dwOffset < m_cbCommitted)
    {
        cbWrite = min(cb, m_cbCommitted - m_dwOffset);

        // copy the memory stuff
        CopyMemory(m_pb + m_dwOffset, (LPBYTE)pv, cbWrite);
    }

    // if we still have stuff to write, dump to the file
    if (cbWrite != cb)
    {
        ULONG   cbWritten;

        Assert(m_pstm);
        
#ifdef	DEBUG
        LARGE_INTEGER   li  = {0, 0};
        ULARGE_INTEGER  uli = {0, 0};

        if (!m_pstm->Seek(li, STREAM_SEEK_CUR, &uli))
#ifdef MAC
            Assert(0 == uli.HighPart);
            Assert(((m_dwOffset + cbWrite) - m_cbAlloc) == uli.LowPart);
#else   // !MAC
            Assert(((m_dwOffset + cbWrite) - m_cbAlloc) == uli.QuadPart);
#endif  // MAC
#endif
        
        hr = m_pstm->Write(((LPBYTE)pv) + cbWrite, cb - cbWrite, &cbWritten);
        if (hr)
        {
            m_fFileErr = TRUE;
            goto err;
        }
        
        cbWrite += cbWritten;
    }

    m_dwOffset += cbWrite;
    
    if (pcbWritten)
        *pcbWritten = cbWrite;
err:
   
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;

stmfull:
	hr = ResultFromScode(STG_E_MEDIUMFULL);
    goto err;
}


STDMETHODIMP CVirtualStream::CopyTo(LPSTREAM pstmDst,
                                    ULARGE_INTEGER uli,
                                    ULARGE_INTEGER* puliRead,
                                    ULARGE_INTEGER* puliWritten)
{
    HRESULT         hr          = 0;
    UINT            cbBuf;
    ULONG           cbRemain;
    ULONG           cbReadMem   = 0;
    ULONG           cbWriteMem  = 0;
#ifdef MAC
    ULARGE_INTEGER  uliRead     = {0, 0};    
    ULARGE_INTEGER  uliWritten  = {0, 0};    
#else   // !MAC
    ULARGE_INTEGER  uliRead     = {0};    
    ULARGE_INTEGER  uliWritten  = {0};    
#endif  // MAC

    // Initialize the outgoing params
    if (puliRead)
    {
        ULISet32((*puliRead), 0);
    }

    if (puliWritten)
    {
        ULISet32((*puliWritten), 0);
    }
    
    if (!m_cbSize)
        goto err;

    // if the request is greater than the max ULONG, bring the request down to
    // the max ULONG
    if (uli.HighPart)
#ifdef MAC
        ULISet32(uli, ULONG_MAX);
#else   // !MAC
        uli.QuadPart = 0xFFFFFFFF;
#endif  // MAC

    if (m_dwOffset < m_cbCommitted)
    {
        if (m_cbSize < m_cbAlloc)
            cbReadMem = (ULONG)min(uli.LowPart, m_cbSize - m_dwOffset);
        else
            cbReadMem = (ULONG)min(uli.LowPart, m_cbAlloc - m_dwOffset);

        hr = pstmDst->Write(m_pb + m_dwOffset, cbReadMem, &cbWriteMem);
        if (!hr && (cbReadMem != cbWriteMem))
            hr = ResultFromScode(E_OUTOFMEMORY);
        if (hr) goto err;

        uli.LowPart -= cbReadMem;
    }

    // if we didn't get it all from memory and there is information in
    // the file stream, read from the file stream
    if (    uli.LowPart
        &&  (m_cbSize > m_cbAlloc)
        &&  m_pstm)
    {
        hr = m_pstm->CopyTo(pstmDst, uli, &uliRead, &uliWritten);
        if (hr)
        {
            m_fFileErr = TRUE;
            goto err;
        }
    }

    m_dwOffset += uliRead.LowPart + cbReadMem;
    
    // Total cbReadMem and ulRead because we have them both.
#ifdef MAC
    if (puliRead)
    {
        ULISet32(*puliRead, uliRead.LowPart);
        Assert(INT_MAX - cbReadMem >= puliRead->LowPart);
        puliRead->LowPart += cbReadMem;
    }

    if (puliWritten)
        puliWritten->LowPart = uliWritten.LowPart + cbWriteMem;
#else   // !MAC
    if (puliRead)
        puliRead->QuadPart = cbReadMem + uliRead.LowPart;

    // Add in cbWriteMem because any written from the file stream was
    // already set
    if (puliWritten)
        puliWritten->QuadPart = uliWritten.LowPart + cbWriteMem;
#endif  // MAC

err:
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\symcache.h ===
// --------------------------------------------------------------------------------
// Symcache.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __SYMCACHE_H
#define __SYMCACHE_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "containx.h"
#include "exrwlck.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CPropertySymbolCache;
typedef class CPropertySymbolCache *LPSYMBOLCACHE;

// --------------------------------------------------------------------------------
// Don't let this flag overlap with MIMEPROPFLAGS
// --------------------------------------------------------------------------------
#define MPF_NODIRTY     FLAG28          // Property does not allow container to get dirty
#define MPF_HEADER      FLAG29          // Property is a header and should be persisted
#define MPF_PARAMETER   FLAG30          // Property is a header parameter
#define MPF_ATTRIBUTE   FLAG31          // Property is a non-persisting attribute
#define MPF_KNOWN       FLAG32          // Property is known by mimeole (it holds const data)

// --------------------------------------------------------------------------------
// Forward Typedefs
// --------------------------------------------------------------------------------
typedef struct tagPROPSYMBOL const *LPCPROPSYMBOL;
typedef struct tagPROPSYMBOL *LPPROPSYMBOL;

// --------------------------------------------------------------------------------
// PROPSYMBOL
// --------------------------------------------------------------------------------
typedef struct tagPROPSYMBOL {
    LPSTR               pszName;        // Property Name
    ULONG               cchName;        // Property Name Length
    DWORD               dwPropId;       // Property Id (PID_UNKNOWN if not known)
    DWORD               dwFlags;        // Property Flags
    DWORD               dwAdrType;      // Address Type
    WORD                wHashIndex;     // Symbol's Hash Index in the Property Container
    DWORD               dwSort;         // By Name Sort Position
    DWORD               dwRowNumber;    // Header Line Persist Postion
    VARTYPE             vtDefault;      // Default data type
    LPPROPSYMBOL        pLink;          // Link to property id for parameter properties
    LPSYMBOLTRIGGER     pTrigger;       // Proerty Notification Handler
} PROPSYMBOL;

// --------------------------------------------------------------------------------
// Macro used to define global property symbols
// --------------------------------------------------------------------------------
#ifdef DEFINE_PROPSYMBOLS

#define DEFINESYMBOL(_NAME, _vtDefault, _dwFlags, _dwAdrType, _pLink, _pfnDispatch) \
    PROPSYMBOL rSYM_##_NAME = \
    { \
        /* PROPSYMBOL::pszName     */ (LPSTR)(STR_##_NAME), \
        /* PROPSYMBOL::cchName     */ sizeof(STR_##_NAME) - 1, \
        /* PROPSYMBOL::dwPropId    */ PID_##_NAME, \
        /* PROPSYMBOL::dwFlags     */ (_dwFlags | MPF_KNOWN), \
        /* PROPSYMBOL::dwAdrType   */ _dwAdrType, \
        /* PROPSYMBOL::wHashIndex  */ 0, \
        /* PROPSYMBOL::dwSort      */ 0, \
        /* PROPSYMBOL::dwRowNumber */ 0, \
        /* PROPSYMBOL::vtDefault   */ _vtDefault, \
        /* PROPSYMBOL::pLink       */ _pLink, \
        /* PROPSYMBOL::pfnDispatch */ _pfnDispatch \
    }; \
    LPPROPSYMBOL SYM_##_NAME = &rSYM_##_NAME;
#else

#define DEFINESYMBOL(_NAME, _vtDefault, _dwFlags, _dwAdrType, _pLink, _pfnDispatch) \
    extern LPPROPSYMBOL SYM_##_NAME;

#endif

// --------------------------------------------------------------------------------
// Property Flags Groups
// --------------------------------------------------------------------------------
#define MPG_GROUP01 (MPF_HEADER)
#define MPG_GROUP02 (MPF_HEADER)
#define MPG_GROUP03 (MPF_HEADER | MPF_INETCSET | MPF_RFC1522 | MPF_ADDRESS)
#define MPG_GROUP04 (MPF_HEADER | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP05 (MPF_HEADER | MPF_MIME)
#define MPG_GROUP06 (MPF_HEADER | MPF_MIME | MPF_HASPARAMS)
#define MPG_GROUP07 (MPF_HEADER | MPF_MIME)
#define MPG_GROUP08 (MPF_HEADER | MPF_MIME | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP09 (MPF_PARAMETER | MPF_MIME)
#define MPG_GROUP10 (MPF_PARAMETER | MPF_MIME | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP11 (MPF_ATTRIBUTE | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP12 (MPF_ATTRIBUTE)
#define MPG_GROUP13 (MPF_ATTRIBUTE | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP14 (MPF_HEADER | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP15 (MPF_ATTRIBUTE | MPF_INETCSET | MPF_RFC1522 | MPF_READONLY)
#define MPG_GROUP16 (MPF_ATTRIBUTE | MPF_READONLY)
#define MPG_GROUP17 (MPF_ATTRIBUTE | MPF_NODIRTY)

// --------------------------------------------------------------------------------
// Header Property Tag Definitions
// --------------------------------------------------------------------------------
DEFINESYMBOL(HDR_RECEIVED,   VT_LPSTR,    MPG_GROUP01, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XMAILER,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XUNSENT,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XNEWSRDR,   VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_RETURNPATH, VT_LPSTR,    MPG_GROUP03, IAT_RETURNPATH, NULL, NULL);
DEFINESYMBOL(HDR_RETRCPTTO,  VT_LPSTR,    MPG_GROUP03, IAT_RETRCPTTO,  NULL, NULL);
DEFINESYMBOL(HDR_RR,         VT_LPSTR,    MPG_GROUP03, IAT_RR,         NULL, NULL);
DEFINESYMBOL(HDR_REPLYTO,    VT_LPSTR,    MPG_GROUP03, IAT_REPLYTO,    NULL, NULL);
DEFINESYMBOL(HDR_APPARTO,    VT_LPSTR,    MPG_GROUP03, IAT_APPARTO,    NULL, NULL);
DEFINESYMBOL(HDR_FROM,       VT_LPSTR,    MPG_GROUP03, IAT_FROM,       NULL, NULL);
DEFINESYMBOL(HDR_SENDER,     VT_LPSTR,    MPG_GROUP03, IAT_SENDER,     NULL, NULL);
DEFINESYMBOL(HDR_TO,         VT_LPSTR,    MPG_GROUP03, IAT_TO,         NULL, NULL);
DEFINESYMBOL(HDR_CC,         VT_LPSTR,    MPG_GROUP03, IAT_CC,         NULL, NULL);
DEFINESYMBOL(HDR_BCC,        VT_LPSTR,    MPG_GROUP03, IAT_BCC,        NULL, NULL);
DEFINESYMBOL(HDR_NEWSGROUPS, VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_PATH,       VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_FOLLOWUPTO, VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_REFS,       VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_SUBJECT,    VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, LPTRIGGER_HDR_SUBJECT);
DEFINESYMBOL(HDR_ORG,        VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_DATE,       VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_EXPIRES,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CONTROL,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_DISTRIB,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_KEYWORDS,   VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_SUMMARY,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_APPROVED,   VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_LINES,      VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XREF,       VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XPRI,       VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XMSPRI,     VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_MESSAGEID,  VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_MIMEVER,    VT_LPSTR,    MPG_GROUP05, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTTYPE,    VT_LPSTR,    MPG_GROUP06, IAT_UNKNOWN,    NULL, LPTRIGGER_HDR_CNTTYPE);
DEFINESYMBOL(HDR_CNTDISP,    VT_LPSTR,    MPG_GROUP06, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTXFER,    VT_LPSTR,    MPG_GROUP07, IAT_UNKNOWN,    NULL, LPTRIGGER_HDR_CNTXFER);
DEFINESYMBOL(HDR_CNTID,      VT_LPSTR,    MPG_GROUP07, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTDESC,    VT_LPSTR,    MPG_GROUP08, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTBASE,    VT_LPSTR,    MPG_GROUP08, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTLOC,     VT_LPSTR,    MPG_GROUP08, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_COMMENT,    VT_LPSTR,    MPG_GROUP14, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_ENCODING,   VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_ENCRYPTED,  VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_OFFSETS,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_ARTICLEID,  VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_NEWSGROUP,  VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_DISP_NOTIFICATION_TO,    VT_LPSTR,    MPG_GROUP03,    IAT_DISP_NOTIFICATION_TO, NULL, NULL);
                                                                                      
// --------------------------------------------------------------------------------
// Parameter Property Tags Definitions
// --------------------------------------------------------------------------------
DEFINESYMBOL(PAR_BOUNDARY,   VT_LPSTR,    MPG_GROUP09, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  NULL);
DEFINESYMBOL(PAR_CHARSET,    VT_LPSTR,    MPG_GROUP09, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  NULL);
DEFINESYMBOL(PAR_FILENAME,   VT_LPSTR,    MPG_GROUP10, IAT_UNKNOWN,    SYM_HDR_CNTDISP,  LPTRIGGER_PAR_FILENAME);
DEFINESYMBOL(PAR_NAME,       VT_LPSTR,    MPG_GROUP10, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  LPTRIGGER_PAR_NAME);
                                                                                      
// --------------------------------------------------------------------------------
// Attribute Property Tags Definitions
// --------------------------------------------------------------------------------
DEFINESYMBOL(ATT_FILENAME,   VT_LPSTR,    MPG_GROUP11, IAT_UNKNOWN,    NULL,             LPTRIGGER_ATT_FILENAME);
DEFINESYMBOL(ATT_GENFNAME,   VT_LPSTR,    MPG_GROUP15, IAT_UNKNOWN,    NULL,             LPTRIGGER_ATT_GENFNAME);
DEFINESYMBOL(ATT_NORMSUBJ,   VT_LPSTR,    MPG_GROUP15, IAT_UNKNOWN,    NULL,             LPTRIGGER_ATT_NORMSUBJ);
DEFINESYMBOL(ATT_ILLEGAL,    VT_LPSTR,    MPG_GROUP13, IAT_UNKNOWN,    NULL,             NULL);
DEFINESYMBOL(ATT_PRITYPE,    VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  LPTRIGGER_ATT_PRITYPE);
DEFINESYMBOL(ATT_SUBTYPE,    VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  LPTRIGGER_ATT_SUBTYPE);
DEFINESYMBOL(ATT_RENDERED,   VT_UI4,      MPG_GROUP17, IAT_UNKNOWN,    NULL,             NULL);
DEFINESYMBOL(ATT_SENTTIME,   VT_FILETIME, MPG_GROUP12, IAT_UNKNOWN,    SYM_HDR_DATE,     LPTRIGGER_ATT_SENTTIME);
DEFINESYMBOL(ATT_RECVTIME,   VT_FILETIME, MPG_GROUP16, IAT_UNKNOWN,    SYM_HDR_RECEIVED, LPTRIGGER_ATT_RECVTIME);
DEFINESYMBOL(ATT_PRIORITY,   VT_UI4,      MPG_GROUP12, IAT_UNKNOWN,    NULL,             LPTRIGGER_ATT_PRIORITY);
DEFINESYMBOL(ATT_SERVER,     VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_ACCOUNTID,  VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_UIDL,       VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_STOREMSGID, VT_UI4,      MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_USERNAME,   VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(ATT_FORWARDTO,  VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(ATT_STOREFOLDERID, VT_UI4,   MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_GHOSTED,    VT_I4,       MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);   
DEFINESYMBOL(ATT_UNCACHEDSIZE, VT_UI4,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(ATT_COMBINED,   VT_UI4,      MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_AUTOINLINED, VT_UI4,      MPG_GROUP17, IAT_UNKNOWN,    NULL, NULL);

// --------------------------------------------------------------------------------
// ADDRSYMBOL
// --------------------------------------------------------------------------------
typedef struct tagADDRSYMBOL {
    DWORD               dwAdrType;      // Address Type (bitmask)
    LPPROPSYMBOL        pSymbol;        // Property Symbol
} ADDRSYMBOL, *LPADDRSYMBOL;        

// --------------------------------------------------------------------------------
// Internet Property Tag Table (Sorted by Name)
// --------------------------------------------------------------------------------
typedef struct tagSYMBOLTABLE {
    ULONG               cSymbols;       // Number of elements in prgTag
    ULONG               cAlloc;         // Number of elements allocated in prgTag
    LPPROPSYMBOL       *prgpSymbol;     // Array of pointers to inet properties
} SYMBOLTABLE, *LPSYMBOLTABLE;

// --------------------------------------------------------------------------------
// CPropertySymbolCache
// --------------------------------------------------------------------------------
class CPropertySymbolCache : public IMimePropertySchema
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPropertySymbolCache(void);
    ~CPropertySymbolCache(void);

    // -------------------------------------------------------------------
    // IUnknown Members
    // -------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------
    // IMimePropertySchema Members
    // -------------------------------------------------------------------
    STDMETHODIMP RegisterProperty(LPCSTR pszName, DWORD dwFlags, DWORD dwRowNumber, VARTYPE vtDefault, LPDWORD pdwPropId);
    STDMETHODIMP ModifyProperty(LPCSTR pszName, DWORD dwFlags, DWORD dwRowNumber, VARTYPE vtDefault);
    STDMETHODIMP RegisterAddressType(LPCSTR pszName, LPDWORD pdwAdrType);
    STDMETHODIMP GetPropertyId(LPCSTR pszName, LPDWORD pdwPropId);
    STDMETHODIMP GetPropertyName(DWORD dwPropId, LPSTR *ppszName);

    // -------------------------------------------------------------------
    // CPropertySymbolCache Members
    // -------------------------------------------------------------------
    HRESULT Init(void);
    HRESULT HrOpenSymbol(LPCSTR pszName, BOOL fCreate, LPPROPSYMBOL *ppSymbol);
    HRESULT HrOpenSymbol(DWORD dwAdrType, LPPROPSYMBOL *ppSymbol);

    // -------------------------------------------------------------------
    // GetCount
    // -------------------------------------------------------------------
    ULONG GetCount(void) {
        
        m_lock.ShareLock();
        ULONG c = m_rTable.cSymbols;
        m_lock.ShareUnlock();
        return c;
    }
        
private:
    // -------------------------------------------------------------------
    // Private Utilities
    // -------------------------------------------------------------------
    HRESULT _HrOpenSymbolWithLockOption(LPCSTR pszName, BOOL fCreate, LPPROPSYMBOL *ppSymbol,BOOL fLockOption);
    void    _FreeTableElements(void);
    void    _FreeSymbol(LPPROPSYMBOL pSymbol);
    void    _SortTableElements(LONG left, LONG right);
    HRESULT _HrFindSymbol(LPCSTR pszName, LPPROPSYMBOL *ppSymbol);
    ULONG   _UlComputeHashIndex(LPCSTR pszName, ULONG cchName);
    HRESULT _HrGetParameterLinkSymbol(LPCSTR pszName, ULONG cchName, LPPROPSYMBOL *ppSymbol);
    HRESULT _HrGetParameterLinkSymbolWithLockOption(LPCSTR pszName, ULONG cchName, LPPROPSYMBOL *ppSymbol,BOOL fLockOption);
	
private:
    // -------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------
    LONG                m_cRef;               // Reference Count
    DWORD               m_dwNextPropId;       // NextProperty Id to be assigned
    DWORD               m_cSymbolsInit;       // Base symbol propert id for new props
    SYMBOLTABLE         m_rTable;             // Property Symbol Table
    LPPROPSYMBOL        m_prgIndex[PID_LAST]; // Index of Known Property Symbols
    CExShareLock        m_lock;               //Thread Safety
};

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
HRESULT HrIsValidPropFlags(DWORD dwFlags);
HRESULT HrIsValidSymbol(LPCPROPSYMBOL pSymbol);
WORD    WGetHashTableIndex(LPCSTR pszName, ULONG cchName);

                                                                                     
#endif // __SYMCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\trigger.cpp ===
// --------------------------------------------------------------------------------
// Trigger.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "containx.h"
#include "symcache.h"
#include "containx.h"
#include "stackstr.h"
#include "variantx.h"
#include "mimeapi.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include "demand.h"

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_FILENAME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_FILENAME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fUseProperty;
    LPWSTR          pszExt;
    LPWSTR          pszFileName=NULL;
    LPPROPSYMBOL    pSymbol;

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        if (pContainer->_HrIsTriggerCaller(PID_PAR_FILENAME, IST_DELETEPROP) == S_FALSE)
        {
            pContainer->DeleteProp(SYM_PAR_FILENAME);
        }
        break;

    case IST_POSTSETPROP:
        // Update PID_PAR_NAME, if it didn't generate this
        if (pContainer->_HrIsTriggerCaller(PID_PAR_NAME, IST_POSTSETPROP) == S_FALSE)
            pContainer->SetProp(SYM_PAR_NAME, dwFlags, pValue);

        // Update PAR_FILENAME, if it didn't generate this
        if (pContainer->_HrIsTriggerCaller(PID_PAR_FILENAME, IST_POSTSETPROP) == S_FALSE)
            pContainer->SetProp(SYM_PAR_FILENAME, dwFlags, pValue);
        break;

    case IST_POSTGETPROP:
        // Cleanup the file name
        if (!ISFLAGSET(dwFlags, PDF_ENCODED))
            MimeVariantCleanupFileName(pContainer->GetWindowsCP(), pValue);
        break;

    case IST_GETDEFAULT:
        // Try to get PID_PAR_FILENAME first
        if (FAILED(pContainer->GetPropW(SYM_PAR_FILENAME, &pszFileName)))
        {
            // Try to get PID_PAR_NAME
            if (FAILED(pContainer->GetPropW(SYM_PAR_NAME, &pszFileName)))
            {
                hr = MIME_E_NO_DATA;
                goto exit;
            }
            else
                pSymbol = SYM_PAR_NAME;
        }
        else
            pSymbol = SYM_PAR_FILENAME;

        // Set Source
        fUseProperty = TRUE;

        // Locate the extension of the file
        pszExt = PathFindExtensionW(pszFileName);

        // If .com
        if (pszExt && StrCmpIW(pszExt, L".com") == 0)
        {
            // Locals
            LPWSTR pszCntType=NULL;
            LPWSTR pszSubType=NULL;

            // Get the file information
            if (SUCCEEDED(MimeOleGetFileInfoW(pszFileName, &pszCntType, &pszSubType, NULL, NULL, NULL)))
            {
                // Extension is .com and content types don't match what is in the body
                if (pContainer->IsContentTypeW(pszCntType, pszSubType) == S_FALSE)
                {
                    // Generate It
                    if (SUCCEEDED(pContainer->_HrGenerateFileName(NULL, dwFlags, pValue)))
                        fUseProperty = FALSE;
                }
            }

            // Cleanup
            SafeMemFree(pszCntType);
            SafeMemFree(pszSubType);
        }

        // Raid-63402: OE: cc: mail problems with OE
        // Empty file extension ?
        else if (NULL == pszExt || L'\0' == *pszExt)
        {
            // Generate a new filename
            CHECKHR(hr = pContainer->_HrGenerateFileName(pszFileName, dwFlags, pValue));

            // Done
            fUseProperty = FALSE;
        }

        // Return per user request
        if (fUseProperty)
        {
            // Use the property
            CHECKHR(hr = pContainer->GetProp(pSymbol, dwFlags, pValue));
        }

        // Cleanup the file name
        if (!ISFLAGSET(dwFlags, PDF_ENCODED))
            MimeVariantCleanupFileName(pContainer->GetWindowsCP(), pValue);
        break;
    }

exit:
    // Cleanup
    SafeMemFree(pszFileName);

    // Done
    return hr;
}
             
// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_GENFNAME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_GENFNAME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;
    LPSTR       pszDefExt=NULL,
                pszData=NULL,
                pszFree=NULL,
                pszSuggest=NULL;
    LPCSTR      pszCntType=NULL;
    MIMEVARIANT rSource;

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_POSTGETPROP:
        if (!ISFLAGSET(dwFlags, PDF_ENCODED))
            MimeVariantCleanupFileName(pContainer->GetWindowsCP(), pValue);
        break;

    case IST_GETDEFAULT:
        // Try to just get the normal filename
        if (SUCCEEDED(TRIGGER_ATT_FILENAME(pContainer, IST_GETDEFAULT, dwFlags, pValue, NULL)))
            goto exit;

        // Call back into the container
        CHECKHR(hr = pContainer->_HrGenerateFileName(NULL, dwFlags, pValue));

        // Cleanup the file name
        if (!ISFLAGSET(dwFlags, PDF_ENCODED))
            MimeVariantCleanupFileName(pContainer->GetWindowsCP(), pValue);
        break;
    }

exit:
    // Cleanup
    SafeMemFree(pszData);
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_NORMSUBJ
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_NORMSUBJ(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    MIMEVARIANT rSubject;
    MIMEVARIANT rNormal;
    LPSTR       pszNormal,
                pszFree=NULL;
    LPWSTR      pszNormalW,
                pszFreeW=NULL;
    ULONG       i=0,
                cch=0;
    LPPROPERTY  pSubject;

    // Handle Dispatch Type
    if (IST_GETDEFAULT == tyTrigger)
    {
        // Get Subject
        pSubject = pContainer->m_prgIndex[PID_HDR_SUBJECT];

        // No Data
        if (NULL == pSubject)
        {
            hr = MIME_E_NO_DATA;
            goto exit;
        }

        switch (pValue->type)
        {
            case MVT_STRINGA:
            {
                // Set Subject Type
                rSubject.type = MVT_STRINGA;

                // Return per user request
                CHECKHR(hr = pContainer->HrConvertVariant(pSubject, CVF_NOALLOC, &rSubject));

                // Set Normal subject
                pszFree = rSubject.fCopy ? NULL : rSubject.rStringA.pszVal;
                pszNormal = rSubject.rStringA.pszVal;

                // Less than 5 "xxx: "
                if (rSubject.rStringA.cchVal >= 4)
                {
                    // 1, 2, 3, 4 spaces followed by a ':' then a space
                    while (cch < 7 && i < rSubject.rStringA.cchVal)
                    {
                        // Skip Lead Bytes
                        if (IsDBCSLeadByte(rSubject.rStringA.pszVal[i]))
                        {
                            i++;
                            cch++;
                        }

                        // Colon
                        else if (':' == rSubject.rStringA.pszVal[i])
                        {
                            if (i+1 >= rSubject.rStringA.cchVal)
                            {
                                i++;
                                pszNormal = (LPSTR)(rSubject.rStringA.pszVal + i);
                                break;
                            }

                            else if (cch <= 4 && ' ' == rSubject.rStringA.pszVal[i+1])
                            {
                                i++;
                                pszNormal = PszSkipWhiteA((LPSTR)(rSubject.rStringA.pszVal + i));
                                break;
                            }
                            else
                                break;
                        }

                        // Next Character
                        i++;
                        cch++;
                    }    
                }

                // Reset Source
                if (pszNormal != rSubject.rStringA.pszVal)
                {
                    rSubject.rStringA.pszVal = pszNormal;
                    rSubject.rStringA.cchVal = lstrlen(pszNormal);
                }
                break;
            }

            case MVT_STRINGW:
            {
                // Set Subject Type
                rSubject.type = MVT_STRINGW;

                // Return per user request
                CHECKHR(hr = pContainer->HrConvertVariant(pSubject, CVF_NOALLOC, &rSubject));

                // Set Normal subject
                pszFreeW = rSubject.fCopy ? NULL : rSubject.rStringW.pszVal;
                pszNormalW = rSubject.rStringW.pszVal;

                // Less than 5 "xxx: "
                if (rSubject.rStringW.cchVal >= 4)
                {
                    // 1, 2, or 3 spaces followed by a ':' then a space
                    while (cch < 7 && i < rSubject.rStringW.cchVal)
                    {
                        // Colon
                        if (L':' == rSubject.rStringW.pszVal[i])
                        {
                            if (i+1 >= rSubject.rStringW.cchVal)
                            {
                                i++;
                                pszNormalW = (LPWSTR)(rSubject.rStringW.pszVal + i);
                                break;
                            }

                            else if (cch <= 4 && L' ' == rSubject.rStringW.pszVal[i+1])
                            {
                                i++;
                                pszNormalW = PszSkipWhiteW((LPWSTR)(rSubject.rStringW.pszVal + i));
                                break;
                            }
                            else
                                break;
                        }

                        // Next Character
                        i++;
                        cch++;
                    }    
                }

                // Reset Source
                if (pszNormalW != rSubject.rStringW.pszVal)
                {
                    rSubject.rStringW.pszVal = pszNormalW;
                    rSubject.rStringW.cchVal = lstrlenW(pszNormalW);
                }
                break;
            }
            default:
                AssertSz(FALSE, "Didn't prepare for this type!!!");
                break;
        }

        // Return per user request
        CHECKHR(hr = pContainer->HrConvertVariant(pSubject->pSymbol, pSubject->pCharset, IET_DECODED, dwFlags, 0, &rSubject, pValue));
    }

exit:
    // Cleanup
    SafeMemFree(pszFree);
    SafeMemFree(pszFreeW);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_HDR_SUBJECT
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_HDR_SUBJECT(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Handle Dispatch type
    if (IST_DELETEPROP == tyTrigger)
        pContainer->DeleteProp(SYM_ATT_NORMSUBJ);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_HDR_CNTTYPE
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_HDR_CNTTYPE(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    CStringParser   cString;
    CHAR            chToken;
    MIMEVARIANT     rValue;
    LPSTR           pszCntType=NULL;

    // Invalid Arg
    Assert(pContainer);

    // Handle Dispatch type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        pContainer->DeleteProp(SYM_ATT_PRITYPE);
        pContainer->DeleteProp(SYM_ATT_SUBTYPE);
        break;

    case IST_POSTSETPROP:
        // If not generated from corresponding atributes
        if (pContainer->_HrIsTriggerCaller(PID_ATT_PRITYPE, IST_POSTSETPROP) == S_OK || 
            pContainer->_HrIsTriggerCaller(PID_ATT_SUBTYPE, IST_POSTSETPROP) == S_OK)
            goto exit;

        // Validate the Variant
        if (ISSTRINGA(pValue))
        {
            // Locals
            CHAR szPriType[255];

            // Set the Members
            cString.Init(pValue->rStringA.pszVal, pValue->rStringA.cchVal, PSF_NOTRAILWS | PSF_NOCOMMENTS);

            // Set Parse Tokens
            chToken = cString.ChParse("/");
            if ('\0' == chToken && 0 == cString.CchValue())
                goto exit;

            // Setup the Variant
            rValue.type = MVT_STRINGA;
            rValue.rStringA.pszVal = (LPSTR)cString.PszValue();
            rValue.rStringA.cchVal = cString.CchValue();

            // Save Primary Type
            StrCpyN(szPriType, rValue.rStringA.pszVal, ARRAYSIZE(szPriType));

            // Add New attribute...
            CHECKHR(hr = pContainer->SetProp(SYM_ATT_PRITYPE, 0, &rValue));

            // Raid-52462: outlook express: mail with bad content type header comes in as an attachment
            // Seek end of sub content-type
            chToken = cString.ChParse(" ;");
            if (0 == cString.CchValue())
            {
                // Locals
                LPCSTR pszSubType = PszDefaultSubType(szPriType);
                ULONG cchCntType;

                // Set Default SubType
                CHECKHR(hr = pContainer->SetProp(SYM_ATT_SUBTYPE, pszSubType));

                // Build ContentType
                DWORD cchSize = (lstrlen(szPriType) + lstrlen(pszSubType) + 2);
                CHECKALLOC(pszCntType = PszAllocA(cchSize));

                // Format the ContentType
                cchCntType = wnsprintf(pszCntType, cchSize, "%s/%s", szPriType, pszSubType);

                // Setup a variant
                rValue.type = MVT_STRINGA;
                rValue.rStringA.pszVal = (LPSTR)pszCntType;
                rValue.rStringA.cchVal = cchCntType;

                // Store the variant data
                Assert(pContainer->m_prgIndex[PID_HDR_CNTTYPE]);
                CHECKHR(hr = pContainer->_HrStoreVariantValue(pContainer->m_prgIndex[PID_HDR_CNTTYPE], 0, &rValue));

                // Done
                goto exit;
            }

            // Setup the Variant
            rValue.rStringA.pszVal = (LPSTR)cString.PszValue();
            rValue.rStringA.cchVal = cString.CchValue();

            // Add New attribute...
            CHECKHR(hr = pContainer->SetProp(SYM_ATT_SUBTYPE, 0, &rValue));

            // We should be done
            Assert(';' == chToken || '(' == chToken || '\0' == chToken || ' ' == chToken);
        }
        break;

    case IST_GETDEFAULT:
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;
        rValue.rStringA.cchVal = lstrlen(STR_MIME_TEXT_PLAIN);
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_HDR_CNTTYPE, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
        break;
    }

exit:
    // Cleanup
    SafeMemFree(pszCntType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_PRITYPE
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_PRITYPE(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pSubType;
    LPSTR       pszSubType;
    ULONG       cchSubType;
    MIMEVARIANT rValue;

    // Define a Stack String
    STACKSTRING_DEFINE(rContentType, 255);

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_POSTSETPROP:
        {
            // If inside content type dispatch setprop
            if (pContainer->_HrIsTriggerCaller(PID_HDR_CNTTYPE, IST_POSTSETPROP) == S_OK)
                goto exit;

            // Asser Type
            Assert(pValue && ISSTRINGA(pValue));

            // Get pCntType
            pSubType = pContainer->m_prgIndex[PID_ATT_SUBTYPE];

            // Is the subtype set yet
            if (pSubType)
            {
                Assert(ISSTRINGA(&pSubType->rValue));
                pszSubType = pSubType->rValue.rStringA.pszVal;
                cchSubType = pSubType->rValue.rStringA.cchVal;
            }
            else
            {
                pszSubType = (LPSTR)STR_SUB_PLAIN;
                cchSubType = lstrlen(STR_SUB_PLAIN);
            }

            // Make Sure the stack string can hold the data
            DWORD cchSize = (cchSubType + pValue->rStringA.cchVal + 2);
            STACKSTRING_SETSIZE(rContentType, cchSize);

            // Init rValue
            ZeroMemory(&rValue, sizeof(MIMEVARIANT));

            // Format the content type
            rValue.rStringA.cchVal = wnsprintf(rContentType.pszVal, cchSize, "%s/%s", pValue->rStringA.pszVal, pszSubType);

            // Setup the value
            rValue.type = MVT_STRINGA;
            rValue.rStringA.pszVal = rContentType.pszVal;

            // SetProp
            CHECKHR(hr = pContainer->SetProp(SYM_HDR_CNTTYPE, 0, &rValue));
        }
        break;

    case IST_GETDEFAULT:
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = (LPSTR)STR_CNT_TEXT;
        rValue.rStringA.cchVal = lstrlen(STR_CNT_TEXT);
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_HDR_CNTTYPE, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
        break;
    }

exit:
    // Cleanup
    STACKSTRING_FREE(rContentType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_SUBTYPE
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_SUBTYPE(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pPriType;
    LPSTR       pszPriType;
    ULONG       cchPriType;
    MIMEVARIANT rValue;

    // Define a Stack String
    STACKSTRING_DEFINE(rContentType, 255);

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_POSTSETPROP:
        {
            // If inside content type dispatch setprop
            if (pContainer->_HrIsTriggerCaller(PID_HDR_CNTTYPE, IST_POSTSETPROP) == S_OK)
                goto exit;

            // Asser Type
            Assert(pValue && ISSTRINGA(pValue));

            // Get pCntType
            pPriType = pContainer->m_prgIndex[PID_ATT_PRITYPE];

            // Is the subtype set yet
            if (pPriType)
            {
                Assert(ISSTRINGA(&pPriType->rValue));
                pszPriType = pPriType->rValue.rStringA.pszVal;
                cchPriType = pPriType->rValue.rStringA.cchVal;
            }
            else
            {
                pszPriType = (LPSTR)STR_CNT_TEXT;
                cchPriType = lstrlen(STR_CNT_TEXT);
            }

            // Make Sure the stack string can hold the data
            DWORD cchSize = (cchPriType + pValue->rStringA.cchVal + 2);
            STACKSTRING_SETSIZE(rContentType, cchSize);

            // Init rValue
            ZeroMemory(&rValue, sizeof(MIMEVARIANT));

            // Format the content type
            rValue.rStringA.cchVal = wnsprintf(rContentType.pszVal, cchSize, "%s/%s", pszPriType, pValue->rStringA.pszVal);

            // Setup the value
            rValue.type = MVT_STRINGA;
            rValue.rStringA.pszVal = rContentType.pszVal;

            // SetProp
            CHECKHR(hr = pContainer->SetProp(SYM_HDR_CNTTYPE, 0, &rValue));
        }
        break;

    case IST_GETDEFAULT:
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = (LPSTR)STR_SUB_PLAIN;
        rValue.rStringA.cchVal = lstrlen(STR_SUB_PLAIN);
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_HDR_CNTTYPE, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
        break;
    }

exit:
    // Cleanup
    STACKSTRING_FREE(rContentType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_HDR_CNTXFER
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_HDR_CNTXFER(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_GETDEFAULT:
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = (LPSTR)STR_ENC_7BIT;
        rSource.rStringA.cchVal = lstrlen(STR_ENC_7BIT);
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_HDR_CNTXFER, NULL, IET_DECODED, dwFlags, 0, &rSource, pValue));
        break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_PAR_NAME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_PAR_NAME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Handle Dispatch type
    switch(tyTrigger)
    {
    case IST_POSTSETPROP:
        if (pContainer->_HrIsTriggerCaller(PID_ATT_FILENAME, IST_POSTSETPROP) == S_FALSE)
            pContainer->SetProp(SYM_ATT_FILENAME, dwFlags, pValue);
        break;
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_PAR_FILENAME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_PAR_FILENAME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Handle Dispatch type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        if (pContainer->_HrIsTriggerCaller(PID_ATT_FILENAME, IST_DELETEPROP) == S_FALSE)
            pContainer->DeleteProp(SYM_ATT_FILENAME);
        break;

    case IST_POSTSETPROP:
        if (pContainer->_HrIsTriggerCaller(PID_ATT_FILENAME, IST_POSTSETPROP) == S_FALSE)
            pContainer->SetProp(SYM_ATT_FILENAME, dwFlags, pValue);
        break;
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_SENTTIME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_SENTTIME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT hr=S_OK;

    // Handle Dispatch type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        pContainer->DeleteProp(SYM_HDR_DATE);
        break;

    case IST_POSTSETPROP:
        pContainer->SetProp(SYM_HDR_DATE, dwFlags, pValue);
        break;

    case IST_GETDEFAULT:
        // Raid-39471-Mail: Date showing as jan 01, 1601 in readnote for attached message
        if (FAILED(pContainer->GetProp(SYM_HDR_DATE, dwFlags, pValue)))
        {
            // Get Known Property
            LPPROPERTY pProperty = pContainer->m_prgIndex[PID_HDR_RECEIVED];
            if (pProperty && ISSTRINGA(&pProperty->rValue))
            {
                // Try Getting Sent Time
                CHECKHR(hr = pContainer->GetProp(SYM_ATT_RECVTIME, dwFlags, pValue));
            }
            else
            {
                // Locals
                SYSTEMTIME  st;
                MIMEVARIANT rValue;

                // Setup rValue
                rValue.type = MVT_VARIANT;
                rValue.rVariant.vt = VT_FILETIME;

                // Get current systemtime
                GetSystemTime(&st);
                SystemTimeToFileTime(&st, &rValue.rVariant.filetime);

                // If the Conversion Fails, get the current time
                CHECKHR(hr = pContainer->HrConvertVariant(SYM_ATT_SENTTIME, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
            }
        }
        break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_RECVTIME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_RECVTIME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    LPMIMEVARIANT   pSource;
    LPPROPERTY      pProperty;

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        pContainer->DeleteProp(SYM_HDR_RECEIVED);
        break;

    case IST_GETDEFAULT:
        // Get Known Property
        pProperty = pContainer->m_prgIndex[PID_HDR_RECEIVED];
        if (NULL == pProperty || !ISSTRINGA(&pProperty->rValue))
        {
            // Try Getting Sent Time
            MimeOleGetSentTime(pContainer, dwFlags, pValue);
        }

        // Otherwise, try to convert it
        else
        {
            // If StringA
            if (MVT_STRINGA == pProperty->rValue.type)
            {
                // Find the first header which has a semi-colon in it
                while(1)
                {
                    // Seek to last colon
                    LPSTR psz = pProperty->rValue.rStringA.pszVal;
                    int i;
                    for (i = 0; psz[i] ; i++);
                    rSource.rStringA.pszVal = psz + i;  // set to end of string
                    for (; i >= 0 ; i--)
                    {
                        if (psz[i] == ';')
                        {
                            rSource.rStringA.pszVal = psz + i;
                            break;
                        }
                    }

                    if ('\0' == *rSource.rStringA.pszVal)
                    {
                        // No more values
                        if (NULL == pProperty->pNextValue)
                        {
                            // Try Getting Sent Time
                            MimeOleGetSentTime(pContainer, dwFlags, pValue);

                            // Done
                            goto exit;
                        }

                        // Goto next
                        pProperty = pProperty->pNextValue;
                    }

                    // Otherwise, we must have a good property
                    else
                        break;
                }

                // Step over ';
                rSource.rStringA.pszVal++;

                // Setup Source
                rSource.type = MVT_STRINGA;
                rSource.rStringA.cchVal = lstrlen(rSource.rStringA.pszVal);
                pSource = &rSource;
            }

            // Otherwise, just try to conver the current property data
            else
                pSource = &pProperty->rValue;

            // If the Conversion Fails, get the current time
            if (FAILED(pContainer->HrConvertVariant(SYM_ATT_RECVTIME, NULL, IET_DECODED, dwFlags, 0, pSource, pValue)))
            {
                // Try Getting Sent Time
                MimeOleGetSentTime(pContainer, dwFlags, pValue);
            }
        }
        break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_PRIORITY
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_PRIORITY(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    PROPVARIANT     rVariant;
    LPMIMEVARIANT   pSource;
    LPPROPERTY      pProperty;

    // Handle Dispatch type
    switch(tyTrigger)
    {
    // IST_VARIANT_TO_STRINGA
    case IST_VARIANT_TO_STRINGA:
        Assert(pValue && pDest && MVT_VARIANT == pValue->type && MVT_STRINGA == pDest->type);
        if (VT_UI4 != pValue->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        switch(pValue->rVariant.ulVal)
        {
        // IMSG_PRI_LOW
        case IMSG_PRI_LOW:
            pDest->rStringA.pszVal = (LPSTR)STR_PRI_MS_LOW;
            pDest->rStringA.cchVal = lstrlen(STR_PRI_MS_LOW);
            break;

        // IMSG_PRI_HIGH
        case IMSG_PRI_HIGH:
            pDest->rStringA.pszVal = (LPSTR)STR_PRI_MS_HIGH;
            pDest->rStringA.cchVal = lstrlen(STR_PRI_MS_HIGH);
            break;

        // IMSG_PRI_NORMAL
        default:
        case IMSG_PRI_NORMAL:
            pDest->rStringA.pszVal = (LPSTR)STR_PRI_MS_NORMAL;
            pDest->rStringA.cchVal = lstrlen(STR_PRI_MS_NORMAL);
            break;
        }
        break;

    // IST_VARIANT_TO_STRINGW
    case IST_VARIANT_TO_STRINGW:
        Assert(pValue && pDest && MVT_VARIANT == pValue->type && MVT_STRINGW == pDest->type);
        if (VT_UI4 != pValue->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        switch(pValue->rVariant.ulVal)
        {
        // IMSG_PRI_LOW
        case IMSG_PRI_LOW:
#ifndef WIN16
            pDest->rStringW.pszVal = L"Low";
#else
            pDest->rStringW.pszVal = "Low";
#endif // !WIN16
            pDest->rStringW.cchVal = 3;
            break;

        // IMSG_PRI_HIGH
        case IMSG_PRI_HIGH:
#ifndef WIN16
            pDest->rStringW.pszVal = L"High";
#else
            pDest->rStringW.pszVal = "High";
#endif // !WIN16
            pDest->rStringW.cchVal = 4;
            break;

        // IMSG_PRI_NORMAL
        default:
        case IMSG_PRI_NORMAL:
#ifndef WIN16
            pDest->rStringW.pszVal = L"Normal";
#else
            pDest->rStringW.pszVal = "Normal";
#endif // !WIN16
            pDest->rStringW.cchVal = 6;
            break;
        }
        break;

    // IST_VARIANT_TO_VARIANT
    case IST_VARIANT_TO_VARIANT:
        Assert(pValue && pDest && MVT_VARIANT == pValue->type && MVT_VARIANT == pDest->type);
        if (VT_UI4 != pValue->rVariant.vt && VT_UI4 != pDest->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        // Nice and Easy
        pDest->rVariant.ulVal = pValue->rVariant.ulVal;
        break;
    
    // IST_STRINGA_TO_VARIANT
    case IST_STRINGA_TO_VARIANT:
        Assert(pValue && pDest && MVT_STRINGA == pValue->type && MVT_VARIANT == pDest->type);
        if (VT_UI4 != pDest->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        // Priority From String
        pDest->rVariant.ulVal = PriorityFromStringA(pValue->rStringA.pszVal);
        break;

    // IST_STRINGW_TO_VARIANT
    case IST_STRINGW_TO_VARIANT:
        Assert(pValue && pDest && MVT_STRINGW == pValue->type && MVT_VARIANT == pDest->type);
        if (VT_UI4 != pDest->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        // Priority From String
        pDest->rVariant.ulVal = PriorityFromStringW(pValue->rStringW.pszVal);
        break;

    // IST_DELETEPROP
    case IST_DELETEPROP:
        pContainer->DeleteProp(SYM_HDR_XPRI);
        pContainer->DeleteProp(SYM_HDR_XMSPRI);
        break;

    // IST_POSTSETPROP
    case IST_POSTSETPROP:
        // Setup rSource
        rSource.type = MVT_VARIANT;
        rSource.rVariant.vt = VT_UI4;

        // Convert to User's Variant to a Integer Priority
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_ATT_PRIORITY, NULL, IET_DECODED, 0, 0, pValue, &rSource));

        // Setup rVariant
        rVariant.vt = VT_LPSTR;

        // Switch on priority
        switch(rSource.rVariant.ulVal)
        {
        case IMSG_PRI_LOW:
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XMSPRI), STR_PRI_MS_LOW)); 
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XPRI), STR_PRI_LOW)); 
            break;

        case IMSG_PRI_NORMAL:
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XMSPRI), STR_PRI_MS_NORMAL)); 
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XPRI), STR_PRI_NORMAL)); 
            break;

        case IMSG_PRI_HIGH:
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XMSPRI), STR_PRI_MS_HIGH)); 
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XPRI), STR_PRI_HIGH)); 
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        // Done
        break;

    // IST_GETDEFAULT
    case IST_GETDEFAULT:
        // Get the Priority Property
        pProperty = pContainer->m_prgIndex[PID_HDR_XPRI];
        if (NULL == pProperty)
            pProperty = pContainer->m_prgIndex[PID_HDR_XMSPRI];

        // No Data
        if (NULL == pProperty)
        {
            rSource.type = MVT_VARIANT;
            rSource.rVariant.vt = VT_UI4;
            rSource.rVariant.ulVal = IMSG_PRI_NORMAL;
            pSource = &rSource;
        }

        // Otherwise
        else
            pSource = &pProperty->rValue;

        // Convert to User's Variant
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_ATT_PRIORITY, NULL, IET_DECODED, dwFlags, 0, pSource, pValue));

        // Done
        break;
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\mimetest\pch.h ===
#include <windows.h>
#include <stdio.h>
#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\webdocs.cpp ===
// --------------------------------------------------------------------------------
// WebDocs.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "webdocs.h"
#ifdef MAC
#include "urlhlink.h"
#else   // !MAC
#include "urlmon.h"
#endif  // !MAC
#include "stmlock.h"
#ifndef MAC
#include "wininet.h"
#include "winineti.h"
#endif  // !MAC
#include <demand.h>

#ifndef MAC
HRESULT HrOpenUrlViaCache(LPCSTR pszUrl, LPSTREAM *ppstm);
#endif  // !MAC

// --------------------------------------------------------------------------------
// CMimeWebDocument::CMimeWebDocument
// --------------------------------------------------------------------------------
CMimeWebDocument::CMimeWebDocument(void)
{
    m_cRef = 1;
    m_pszBase = NULL;
    m_pszURL = NULL;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::CMimeWebDocument
// --------------------------------------------------------------------------------
CMimeWebDocument::~CMimeWebDocument(void)
{
    EnterCriticalSection(&m_cs);
    SafeMemFree(m_pszBase);
    SafeMemFree(m_pszURL);
    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeWebDocument::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeWebDocument == riid)
        *ppv = (IMimeWebDocument *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeWebDocument::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeWebDocument::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::GetURL
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeWebDocument::GetURL(LPSTR *ppszURL)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == ppszURL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Data
    if (NULL == m_pszURL)
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

    // Combine the URL
    if (m_pszBase)
    {
        // Combine
        CHECKHR(hr = MimeOleCombineURL(m_pszBase, lstrlen(m_pszBase), m_pszURL, lstrlen(m_pszURL), FALSE, ppszURL));
    }

    // Otherwise, just dup m_pszURL
    else
    {
        // Dup It
        CHECKALLOC(*ppszURL = PszDupA(m_pszURL));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::BindToStorage
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeWebDocument::BindToStorage(REFIID riid, LPVOID *ppvObject)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszURL=NULL;
    IStream    *pStream=NULL;
    ILockBytes *pLockBytes=NULL;

    // Invalid Arg
    if (NULL == ppvObject || (IID_IStream != riid && IID_ILockBytes != riid))
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObject = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Data
    if (NULL == m_pszURL)
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

#ifndef MAC
    // Combine the URL
    if (m_pszBase)
    {
        // Combine
        CHECKHR(hr = MimeOleCombineURL(m_pszBase, lstrlen(m_pszBase), m_pszURL, lstrlen(m_pszURL), FALSE, &pszURL));

        // Get the Stream
        CHECKHR(hr = HrOpenUrlViaCache(pszURL, &pStream));
    }

    // Otherwise, just dup m_pszURL
    else
    {
        // Get the Stream
        CHECKHR(hr = HrOpenUrlViaCache(m_pszURL, &pStream));
    }
#endif  // !MAC

    // User wants ILockBytes
    if (IID_ILockBytes == riid)
    {
        // Create CStreamLockBytes
        CHECKALLOC(pLockBytes = new CStreamLockBytes(pStream));

        // Add Ref It
        pLockBytes->AddRef();

        // Return It
        *ppvObject = pLockBytes;
    }

    // IID_IStream
    else
    {
        // Add Ref It
        pStream->AddRef();

        // Return It
        *ppvObject = pStream;
    }

exit:
    // Cleanup
    SafeMemFree(pszURL);
    SafeRelease(pStream);
    SafeRelease(pLockBytes);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::HrInitialize
// --------------------------------------------------------------------------------
HRESULT CMimeWebDocument::HrInitialize(LPCSTR pszBase, LPCSTR pszURL)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == pszURL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Free Current Data
    SafeMemFree(m_pszBase);
    SafeMemFree(m_pszURL);

    // pszURL
    CHECKALLOC(m_pszURL = PszDupA(pszURL));

    // pszBase
    if (pszBase)
    {
        // Dup the Base
        CHECKALLOC(m_pszBase = PszDupA(pszBase));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}


#ifndef MAC
HRESULT HrOpenUrlViaCache(LPCSTR pszUrl, LPSTREAM *ppstm)
{
    BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFO  *pCacheInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
    DWORD                       cInfo = sizeof(buf);
    HRESULT                     hr;

    pCacheInfo->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);
    
    // try to get from the cache
    if (RetrieveUrlCacheEntryFileA(pszUrl, pCacheInfo, &cInfo, 0))
        {
        UnlockUrlCacheEntryFile(pszUrl, 0);
        if (OpenFileStream(pCacheInfo->lpszLocalFileName, OPEN_EXISTING, GENERIC_READ, ppstm)==S_OK)
            return S_OK;
        }

    // if failed to get a cache, get from the net
    hr = URLOpenBlockingStreamA(NULL, pszUrl, ppstm, 0, NULL);

    return hr == S_OK ? S_OK : MIME_E_URL_NOTFOUND;
   
};
#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\mimetest\mimetest.h ===
#ifndef __MAIN_H
#define __MAIN_H

extern UINT g_msgSMTP;

#endif __MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\webdocs.h ===
// --------------------------------------------------------------------------------
// WebDocs.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __WEBDOCS_H
#define __WEBDOCS_H

// --------------------------------------------------------------------------------
// CMimeWebDocument
// --------------------------------------------------------------------------------
class CMimeWebDocument : public IMimeWebDocument
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeWebDocument(void);
    ~CMimeWebDocument(void);

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IMimeWebDocument Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP GetURL(LPSTR *ppszURL);
    STDMETHODIMP BindToStorage(REFIID riid, LPVOID *ppvObject);

    // ----------------------------------------------------------------------------
    // CMimeWebDocument Members
    // ----------------------------------------------------------------------------
    HRESULT HrInitialize(LPCSTR pszBase, LPCSTR pszURL);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    LPSTR               m_pszBase;      // URL Base
    LPSTR               m_pszURL;       // URL
    CRITICAL_SECTION    m_cs;           // Thread Safety
};

#endif // __WEBDOCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\vstream.h ===
// --------------------------------------------------------------------------------
// Vstream.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Ronald E. Gray
// --------------------------------------------------------------------------------
#ifndef __VSTREAM_H
#define __VSTREAM_H

// --------------------------------------------------------------------------------
// CVirtualStream
// --------------------------------------------------------------------------------
class CVirtualStream : public IStream
{
private:
    ULONG       m_cRef;         // Reference count
    DWORD       m_cbSize;       // Current size of the stream
    DWORD       m_cbCommitted;  // Amount of virtual space committed
    DWORD       m_cbAlloc;      // Amount of virtual space reserved
    DWORD       m_dwOffset;     // Current location in stream
    IStream *   m_pstm;         // File backed stream for overflow
    LPBYTE      m_pb;           // pointer to memory part of stream
    BOOL        m_fFileErr;     // the pointer in the file stream may not
                                // be in sync with our pointer.  Try to sync
                                // before any other operation.
    CRITICAL_SECTION m_cs;      // Thread Safety

    // -------------------------------------------------------------------------
    // Utilities
    // -------------------------------------------------------------------------
    HRESULT SyncFileStream();

public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CVirtualStream(void);
    ~CVirtualStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
#ifndef WIN16
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *);
#else
    STDMETHODIMP Read (VOID HUGEP *, ULONG, ULONG*);
#endif // !WIN16
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
#ifndef WIN16
    STDMETHODIMP Write(const void *, ULONG, ULONG *);
#else
    STDMETHODIMP Write (const void HUGEP *, ULONG, ULONG*);
#endif // !WIN16
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP Commit(DWORD) {
        return S_OK; }
    STDMETHODIMP SetSize(ULARGE_INTEGER);
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *);
    STDMETHODIMP Revert(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) {
        return E_NOTIMPL; }

    // -------------------------------------------------------------------------
    // CVirtualStream
    // -------------------------------------------------------------------------
    void QueryStat(ULARGE_INTEGER *puliOffset, ULARGE_INTEGER *pulSize);
};

#endif // __VSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\attrib.h ===
BOOL AuthAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL UnAuthAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL UnProtAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\webpage.h ===
// --------------------------------------------------------------------------------
// WebPage.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __WEBPAGE_H
#define __WEBPAGE_H

// -----------------------------------------------------------------------------
// Forward Decls
// -----------------------------------------------------------------------------
class CVirtualStream;
class CMessageTree;
class CActiveUrlRequest;
typedef class CActiveUrlRequest *LPURLREQUEST;
typedef CMessageTree *LPMESSAGETREE;
typedef struct tagTREENODEINFO *LPTREENODEINFO;

// -----------------------------------------------------------------------------
// PAGESEGMENT
// -----------------------------------------------------------------------------
typedef struct tagPAGESEGMENT *LPPAGESEGMENT;
typedef struct tagPAGESEGMENT {
    DWORD               cbOffset;           // IStream Read / Seek Offset
    DWORD               cbLength;           // How long is this segment
    BYTE                fLengthKnown;       // Have I computed the length of this segment
    IStream            *pStream;            // The stream containing the data for this segment
    LPPAGESEGMENT       pPrev;              // The previous segment
    LPPAGESEGMENT       pNext;              // The next segment
} PAGESEGMENT;

// -----------------------------------------------------------------------------
// CMessageWebPage
// -----------------------------------------------------------------------------
class CMessageWebPage : public IStream, public IMimeMessageCallback
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CMessageWebPage(LPURLREQUEST pRequest);
    ~CMessageWebPage(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
    STDMETHODIMP Read(LPVOID pvData, ULONG cbData, ULONG *pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP Write(const void *, ULONG, ULONG *) { return TrapError(STG_E_ACCESSDENIED); }
    STDMETHODIMP SetSize(ULARGE_INTEGER) { return E_NOTIMPL; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *) { return E_NOTIMPL; }
    STDMETHODIMP Stat(STATSTG *pStat, DWORD dw) { return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Revert(void) { return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) { return E_NOTIMPL; }

    // ----------------------------------------------------------------------------
    // IMimeWebaPageCallback (Default Implementation if client doesn't specify)
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnWebPageSplitter(DWORD cInlined, IStream *pStream);

    // -------------------------------------------------------------------------
    // CMessageWebPage Methods
    // -------------------------------------------------------------------------
    HRESULT Initialize(IMimeMessageCallback *pCallback, LPMESSAGETREE pTree, LPWEBPAGEOPTIONS pOptions);
    HRESULT OnBodyBoundToTree(LPMESSAGETREE pTree, LPTREENODEINFO pNode);
    HRESULT OnBindComplete(LPMESSAGETREE pTree);

private:
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    void _VFreeSegmentList(void);
    void _VFreeSegment(LPPAGESEGMENT pSegment);
    void _VAppendSegment(LPPAGESEGMENT pSegment);
    void _VInitializeCharacterSet(LPMESSAGETREE pTree);
    HRESULT _AllocateSegment(LPPAGESEGMENT *ppSegment, BOOL fCreateStream);
    HRESULT _GetInlineHtmlStream(LPMESSAGETREE pTree, LPTREENODEINFO pNode, LPSTREAM *ppStream);
    HRESULT _InlineTextBody(LPMESSAGETREE pTree, LPTREENODEINFO pNode, BOOL fSetParents);
    HRESULT _InlineImageBody(LPMESSAGETREE pTree, LPTREENODEINFO pNode);
    HRESULT _DoAttachmentLinks(LPMESSAGETREE pTree);
    HRESULT _DoSegmentSplitter(void);
    HRESULT _SetContentId(LPTREENODEINFO pNode, LPSTR pszCID, ULONG cchCID);
    HRESULT _ComputeStreamSize(LPDWORD pcbSize);
    HRESULT _DoSlideShow(LPMESSAGETREE pTree);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                    m_cRef;             // Reference count
    HCHARSET                m_hCharset;         // Character set of the message
    WEBPAGEOPTIONS          m_rOptions;         // WebPage Options
    LPURLREQUEST            m_pRequest;         // Url Request for root stream
    LPPAGESEGMENT           m_pHeadSegment;     // First Segment
    LPPAGESEGMENT           m_pTailSegment;     // Last Segment
    LPPAGESEGMENT           m_pCurrSegment;     // Current Segment
    DWORD                   m_cbOffset;         // Stream Offset
    BYTE                    m_fComplete;        // Has BindComplete been called
    DWORD                   m_cInline;          // Number of inline bodies
    DWORD                   m_cSlideShow;       // Number of images to put into a slide show
    IMimeMessageCallback   *m_pCallback;        // WebPage Callback
    CRITICAL_SECTION        m_cs;               // Critical Section for m_pStream
};

#endif // __WEBPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\data.h ===
#define FILTER_NONE             0
#define FILTER_RSA_KEYEX        1
#define FILTER_RSA_SIGN         2
#define FILTER_DSA_SIGN         4
#define FILTER_DH_KEYEX         8
#define FILTER_KEA_KEYEX        16

#define szOID_INFOSEC_keyExchangeAlgorithm "2.16.840.1.101.2.1.1.22"

extern BOOL DoCertDialog(HWND hwndOwner, LPTSTR szTitle, HCERTSTORE hCertStore, PCCERT_CONTEXT *ppCert, int iFilter);
HRESULT HrValidateCert(PCCERT_CONTEXT pccert, HCERTSTORE hstore, HCRYPTPROV hprov,
                       HCERTSTORE * phcertstorOut, DWORD * pdwErrors);

extern  HCERTSTORE              HCertStoreMy;
extern  BYTE                    RgbSignHash[20];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\webpage.cpp ===
// --------------------------------------------------------------------------------
// WebPage.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "mhtmlurl.h"
#include "webpage.h"
#include "vstream.h"
#include "booktree.h"
#include "strconst.h"
#include "containx.h"
#include "bookbody.h"
#include "mimeapi.h"
#include "plainstm.h"
#include "mimeutil.h"
#include "symcache.h"
#include "dllmain.h"
#include "internat.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "enriched.h"
#include "resource.h"
//#include "util.h"
#include "demand.h"

// From Util.h
HRESULT HrLoadStreamFileFromResourceW(ULONG uCodePage, LPCSTR lpszResourceName, LPSTREAM *ppstm);

// --------------------------------------------------------------------------------
// CMessageWebPage::CMessageWebPage
// --------------------------------------------------------------------------------
CMessageWebPage::CMessageWebPage(LPURLREQUEST pRequest) : m_pRequest(pRequest)
{
    TraceCall("CMessageWebPage::CMessageWebPage");
    Assert(m_pRequest);
    m_cRef = 1;
    m_pCallback = NULL;
    m_pRequest->AddRef();
    m_pHeadSegment = NULL;
    m_pTailSegment = NULL;
    m_pCurrSegment = NULL;
    m_fComplete = FALSE;
    m_cInline = 0;
    m_cbOffset = 0;
    m_cSlideShow = 0;
    ZeroMemory(&m_rOptions, sizeof(WEBPAGEOPTIONS));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageWebPage::~CMessageWebPage
// --------------------------------------------------------------------------------
CMessageWebPage::~CMessageWebPage(void)
{
    TraceCall("CMessageWebPage::~CMessageWebPage");
    Assert(m_pRequest == NULL);
    _VFreeSegmentList();
    if (m_pCallback && m_pCallback != this)
        m_pCallback->Release();
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageWebPage::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageWebPage::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Tracing
    TraceCall("CMessageWebPage::QueryInterface");

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IStream *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else if (IID_IMimeMessageCallback == riid)
        *ppv = (IMimeMessageCallback *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageWebPage::AddRef(void)
{
    TraceCall("CMessageWebPage::AddRef");
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMessageWebPage::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageWebPage::Release(void)
{
    TraceCall("CMessageWebPage::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::Read
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageWebPage::Read(LPVOID pvData, ULONG cbData, ULONG *pcbRead)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbLeft=cbData;
    ULONG           cbRead=0;
    ULONG           cbSegmentRead;
    LPPAGESEGMENT   pSegment;

    // Tracing
    TraceCall("CMessageWebPage::Read");

    // Invalid Ags
    if (NULL == pvData)
        return TraceResult(E_INVALIDARG);

    // HrInitialize
    if (pcbRead)
        *pcbRead = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Only if there is a current segment
    if (m_pCurrSegment)
    {
        // HrInitialize Segment Loop
        while (cbLeft)
        {
            // Is there data left to read in this segment ?
            if (m_pCurrSegment->cbOffset == m_pCurrSegment->cbLength && TRUE == m_pCurrSegment->fLengthKnown)
            {
                // Are there no more segments ?
                if (NULL == m_pCurrSegment->pNext)
                    break;

                // Goto Next Segment
                m_pCurrSegment = m_pCurrSegment->pNext;
            }

            // We should have a stream for the current segment
            Assert(m_pCurrSegment->pStream);

            // Compute the current position of the stream
#ifdef DEBUG
            DWORD cbOffset;
            SideAssert(SUCCEEDED(HrGetStreamPos(m_pCurrSegment->pStream, &cbOffset)));
            Assert(cbOffset == m_pCurrSegment->cbOffset);
#endif
            // If I have computed the length of this item yet?
            IF_FAILEXIT(hr = m_pCurrSegment->pStream->Read((LPVOID)((LPBYTE)pvData + cbRead), cbLeft, &cbSegmentRead));

            // Increment offset
            m_pCurrSegment->cbOffset += cbSegmentRead;

            // Compute Global Offset
            m_cbOffset += cbSegmentRead;

            // Adjust the size of this segment ?
            if (m_pCurrSegment->cbOffset > m_pCurrSegment->cbLength)
            {
                Assert(FALSE == m_pCurrSegment->fLengthKnown);
                m_pCurrSegment->cbLength = m_pCurrSegment->cbOffset;
            }

            // Decrement amount left
            cbLeft -= cbSegmentRead;

            // Increment Amount Actually Read
            cbRead += cbSegmentRead;

            // If we read zero...we must have read all the data in this segment
            if (0 == cbSegmentRead)
            {
                Assert(m_pCurrSegment->cbLength == m_pCurrSegment->cbOffset);
                m_pCurrSegment->fLengthKnown = TRUE;
            }
        }
    }

    // Return Amount Read
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageWebPage::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbOffsetNew;
    DWORD           cbSize=0xffffffff;

    // Tracing
    TraceCall("CMessageWebPage::Seek");

    // Invalid Args
    Assert(dlibMove.HighPart == 0);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Relative to the beginning of the stream
    if (STREAM_SEEK_SET == dwOrigin)
    {
        // If less than zero, its an error
//        if (dlibMove.LowPart < 0)
//        {
//            hr = TraceResult(E_FAIL);
//            goto exit;
//        }
        // else

        // Otherwise, if past current offset...
        if (dlibMove.LowPart > m_cbOffset)
        {
            // If not finished binding, return E_PENDING 
            if (FALSE == m_fComplete)
            {
                hr = TraceResult(E_PENDING);
                goto exit;
            }

            // Compute Size of the Entire Stream
            IF_FAILEXIT(hr = _ComputeStreamSize(&cbSize));

            // If past end of stream, error
            if (dlibMove.LowPart > cbSize)
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }
        }

        // Set new offset
        cbOffsetNew = (DWORD)dlibMove.LowPart;
    }

    // Relative to current offset
    else if (STREAM_SEEK_CUR == dwOrigin)
    {
        // If less than zero, and absolute is greater than its an error
        if ( (DWORD)(0 - dlibMove.LowPart) > m_cbOffset)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Otherwise, if past current offset...
        else if (m_cbOffset + dlibMove.LowPart > m_cbOffset)
        {
            // If not finished binding, return E_PENDING 
            if (FALSE == m_fComplete)
            {
                hr = TraceResult(E_PENDING);
                goto exit;
            }

            // Compute Size of the Entire Stream
            IF_FAILEXIT(hr = _ComputeStreamSize(&cbSize));

            // If past end of stream, error
            if (dlibMove.LowPart > cbSize)
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }
        }

        // Set new offset
        cbOffsetNew = m_cbOffset + dlibMove.LowPart;
    }

    // Relative to the end of the stream
    else if (STREAM_SEEK_END == dwOrigin)
    {
        // If not finished binding, return E_PENDING 
        if (FALSE == m_fComplete)
        {
            hr = TraceResult(E_PENDING);
            goto exit;
        }

        // Compute Size of the Entire Stream
        IF_FAILEXIT(hr = _ComputeStreamSize(&cbSize));

        // If negative or greater than size, its an error
        if ( (DWORD)dlibMove.LowPart > cbSize)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Set new offset
        cbOffsetNew = cbSize - dlibMove.LowPart;
    }

    // Otherwise, its an error
    else
    {
        hr = TraceResult(STG_E_INVALIDFUNCTION);
        goto exit;
    }

    // Only if a change
    if (m_cbOffset != cbOffsetNew)
    {
        // New offset greater than size...
        m_cbOffset = cbOffsetNew;

        // Walk through the segments
        for (m_pCurrSegment=m_pHeadSegment; m_pCurrSegment!=NULL; m_pCurrSegment=m_pCurrSegment->pNext)
        {
            // Never Seeks beyond length
            Assert(FALSE == m_pCurrSegment->fLengthKnown ? cbOffsetNew <= m_pCurrSegment->cbLength : TRUE);

            // Offset falls into this segment ?
            if (cbOffsetNew <= m_pCurrSegment->cbLength)
            {
                // Set Offset within m_pCurrSegment->pStream
                m_pCurrSegment->cbOffset = cbOffsetNew;

                // Should have a stream
                Assert(m_pCurrSegment->pStream);

                // Seek the stream
                IF_FAILEXIT(hr = HrStreamSeekSet(m_pCurrSegment->pStream, m_pCurrSegment->cbOffset));

                // Reset the Offsets of the remaining segments
                for (LPPAGESEGMENT pSegment=m_pCurrSegment->pNext; pSegment!=NULL; pSegment=pSegment->pNext)
                {
                    // At 0
                    pSegment->cbOffset = 0;

                    // Seek the stream
                    IF_FAILEXIT(hr = HrStreamSeekSet(pSegment->pStream, 0));
                }
                
                // Done
                break;
            }

            // Otherwise, seek the stream to the end offset / length
            else
            {
                // Must know the length
                Assert(m_pCurrSegment->fLengthKnown);

                // Set Offset
                m_pCurrSegment->cbOffset = m_pCurrSegment->cbLength;

                // Seek the stream
                IF_FAILEXIT(hr = HrStreamSeekSet(m_pCurrSegment->pStream, m_pCurrSegment->cbOffset));
            }

            // Decrement cbOffsetNew
            cbOffsetNew -= m_pCurrSegment->cbLength;
        }
    }

    // Return Position
    if (plibNew)
    {
        plibNew->HighPart = 0;
        plibNew->LowPart = (LONG)m_cbOffset;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_ComputeStreamSize
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_ComputeStreamSize(LPDWORD pcbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPAGESEGMENT   pCurrSegment;

    // Tracing
    TraceCall("CMessageWebPage::_ComputeStreamSize");

    // Invalid Args
    Assert(pcbSize && m_fComplete);

    // Initialize
    *pcbSize = 0;

    // Walk through the segments
    for (pCurrSegment=m_pHeadSegment; pCurrSegment!=NULL; pCurrSegment=pCurrSegment->pNext)
    {
        // If length is not known, then get its size
        if (FALSE == pCurrSegment->fLengthKnown)
        {
            // There better be a stream
            Assert(pCurrSegment->pStream);

            // Get the size of the stream
            IF_FAILEXIT(hr = HrGetStreamSize(pCurrSegment->pStream, &pCurrSegment->cbLength));

            // Set Size is known
            pCurrSegment->fLengthKnown = TRUE;
        }

        // Increment Size
        (*pcbSize) += pCurrSegment->cbLength;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_AllocateSegment
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_AllocateSegment(LPPAGESEGMENT *ppSegment, BOOL fCreateStream)
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid Args
    Assert(ppSegment);

    // Tracing
    TraceCall("CMessageWebPage::_AllocateSegment");

    // Allocate It
    IF_NULLEXIT(*ppSegment = (LPPAGESEGMENT)g_pMalloc->Alloc(sizeof(PAGESEGMENT)));

    // Zero
    ZeroMemory(*ppSegment, sizeof(PAGESEGMENT));

    // Create a Stream ?
    if (fCreateStream)
    {
        // Allocate a Stream
        IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&(*ppSegment)->pStream));
    }

exit:
    // Failure ?
    if (FAILED(hr) && *ppSegment != NULL)
    {
        SafeRelease((*ppSegment)->pStream);
        SafeMemFree((*ppSegment));
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_VAppendSegment
// --------------------------------------------------------------------------------
void CMessageWebPage::_VAppendSegment(LPPAGESEGMENT pSegment)
{
    // Invalid Args
    Assert(pSegment);

    // Tracing
    TraceCall("CMessageWebPage::_VAppendSegment");

    // Head is Null
    if (NULL == m_pHeadSegment)
    {
        Assert(NULL == m_pTailSegment);
        m_pCurrSegment = m_pHeadSegment = m_pTailSegment = pSegment;
    }

    // Otherwise, append to tail
    else
    {
        Assert(m_pTailSegment);
        m_pTailSegment->pNext = pSegment;
        pSegment->pPrev = m_pTailSegment;
        m_pTailSegment = pSegment;
    }
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_VFreeSegmentList
// --------------------------------------------------------------------------------
void CMessageWebPage::_VFreeSegmentList(void)
{
    // Locals
    LPPAGESEGMENT       pCurr;
    LPPAGESEGMENT       pNext;

    // Tracing
    TraceCall("CMessageWebPage::_VFreeSegmentList");

    // HrInitialize Curr
    pCurr = m_pHeadSegment;

    // Loop
    while(pCurr)
    {
        // Set pNext
        pNext = pCurr->pNext;

        // Free This One
        _VFreeSegment(pCurr);

        // Goto Next
        pCurr = pNext;
    }

    // Set Head and Tail
    m_pHeadSegment = m_pTailSegment = NULL;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_VFreeSegment
// --------------------------------------------------------------------------------
void CMessageWebPage::_VFreeSegment(LPPAGESEGMENT pSegment)
{
    TraceCall("CMessageWebPage::_VFreeSegment");
    SafeRelease(pSegment->pStream);
    g_pMalloc->Free(pSegment);
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_VInitializeCharacterSet
// --------------------------------------------------------------------------------
void CMessageWebPage::_VInitializeCharacterSet(LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;
    INETCSETINFO    rCharset;
    DWORD           dwCodePage=0;
    HCHARSET        hCharset;

    // Tracing
    TraceCall("CMessageWebPage::_VInitializeCharacterSet");

    // Get the Character Set
    pTree->GetCharset(&m_hCharset);

    // Raid-47838: Nav4 message in iso-2022-jp causes initialization error
    if (NULL == m_hCharset)
    {
        // Get the default character set
        if (SUCCEEDED(g_pInternat->GetDefaultCharset(&hCharset)))
            m_hCharset = hCharset;
    }

#ifdef BROKEN
    // Raid-43580: Special case for codepage 50220 - iso-2022-jp and 50932 - JP auto use JP windows codepage instead to preserve half width Kana data
    MimeOleGetCharsetInfo(m_hCharset, &rCharset);

    // Map Character set
    if (rCharset.cpiInternet == 50220 || rCharset.cpiInternet == 50932)
    {
        // Raid-35230: hard-code to ISO-2022-JP-ESC or ISO-2022-JP-SIO
        hCharset = GetJP_ISOControlCharset();
        if (hCharset)
            m_hCharset = hCharset;
    }
#endif

    // We better have a charset
    Assert(m_hCharset);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::Initialize
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::Initialize(IMimeMessageCallback *pCallback, LPMESSAGETREE pTree, 
    LPWEBPAGEOPTIONS pOptions)
{
    // Locals
    HRESULT         hr=S_OK;
    INETCSETINFO    rCsetInfo;
    CODEPAGEINFO    rCodePage;
    LPSTR           pszCharset;
    LPPAGESEGMENT   pSegment=NULL;

    // Tracing
    TraceCall("CMessageWebPage::Initialize");

    // No Options ?
    Assert(pOptions);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Better have a request
    Assert(m_pRequest);

    // No WebPage Callback
    if (pCallback)
    {
        m_pCallback = pCallback;
        m_pCallback->AddRef();
    }
    else
        m_pCallback = this;

    // Save the Options
    CopyMemory(&m_rOptions, pOptions, sizeof(WEBPAGEOPTIONS));

    // Remap the Character Set ?
    _VInitializeCharacterSet(pTree);

    // Append a PageSegment
    IF_FAILEXIT(hr = _AllocateSegment(&pSegment, TRUE));

    // Client wants meta-tag?
    if (!ISFLAGSET(m_rOptions.dwFlags, WPF_NOMETACHARSET))
    {
        // Get the charset information
        IF_FAILEXIT(hr = MimeOleGetCharsetInfo(m_hCharset, &rCsetInfo));

        // Get the codepage information
        IF_FAILEXIT(hr = MimeOleGetCodePageInfo(rCsetInfo.cpiInternet, &rCodePage));

        // Set the charset to write into the meta tag
        pszCharset = FIsEmpty(rCodePage.szWebCset) ? rCodePage.szBodyCset : rCodePage.szWebCset;

        // If Still Empty, use iso-8859-1
        if (FIsEmpty(pszCharset))
            pszCharset = (LPSTR)STR_ISO88591;

        // Write STR_METATAG_PREFIX
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_METATAG_PREFIX, lstrlen(STR_METATAG_PREFIX), NULL));

        // Write the Charset
        IF_FAILEXIT(hr = pSegment->pStream->Write(pszCharset, lstrlen(pszCharset), NULL));

        // Write STR_METATAG_POSTFIX
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_METATAG_POSTFIX, lstrlen(STR_METATAG_POSTFIX), NULL));
    }

    // Only showing images ?
    if (ISFLAGSET(m_rOptions.dwFlags, WPF_IMAGESONLY))
    {
        // Locals
        CHAR szRes[255];

        // Load the string
        LoadString(g_hLocRes, idsImagesOnly, szRes, ARRAYSIZE(szRes));

        // Write idsImagesOnly
        IF_FAILEXIT(hr = pSegment->pStream->Write(szRes, lstrlen(szRes), NULL));
    }

    // Rewind the segment
    IF_FAILEXIT(hr = HrRewindStream(pSegment->pStream));

    // Link Segment into list...
    _VAppendSegment(pSegment);

    // Don't Free It
    pSegment = NULL;

    // Report that some data is available
    m_pRequest->OnBindingDataAvailable();

exit:
    // Cleanup
    if (pSegment)
        _VFreeSegment(pSegment);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_GetInlineHtmlStream
// --------------------------------------------------------------------------------
#define CCHMAX_SNIFFER 64
HRESULT CMessageWebPage::_GetInlineHtmlStream(LPMESSAGETREE pTree, LPTREENODEINFO pNode,
                                              LPSTREAM *ppStream)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fQuote;
    IStream        *pStmHtml=NULL;
    IStream        *pStmHtmlW=NULL;
    IStream        *pStmPlainW=NULL;
    IStream        *pStmEnriched=NULL;
    ULONG           cbRead;
    LPWSTR          pwszType=NULL;
    WCHAR           wszHeader[CCHMAX_SNIFFER];
    CHAR            szHeader[CCHMAX_SNIFFER];
    
    // Tracing
    TraceCall("CMessageWebPage::_GetInlineHtmlStream");
    
    // Invalid Args
    Assert(pTree && pNode && ppStream);
    
    // HrInitialize
    *ppStream = NULL;
    
    // text/html ?
    if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_HTML))
    {
        // Just get and return an HTML inetcset encoded stream
        IF_FAILEXIT(hr = pNode->pBody->GetData(IET_INETCSET, &pStmHtml));
    }
    
    // text/enriched
    else if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_ENRICHED))
    {
        // Convert to HTML
        IF_FAILEXIT(hr = MimeOleConvertEnrichedToHTMLEx((IMimeBody *)pNode->pBody, IET_INETCSET, &pStmHtml));
    }
    
    // text/*
    else if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, NULL))
    {
        // Get the data
        IF_FAILEXIT(hr = pNode->pBody->GetData(IET_UNICODE, &pStmPlainW));
        
        // Read Off the first 255 bytes
        IF_FAILEXIT(hr = pStmPlainW->Read(wszHeader, (CCHMAX_SNIFFER * sizeof(WCHAR)), &cbRead));
        
        // Did we read something
        if (cbRead > 0)
        {
            // Null It
            ULONG cchRead = (cbRead / sizeof(WCHAR)) - 1;
            
            // Null It Out
            wszHeader[cchRead] = L'\0';
            
            // Convert to ANSI
            szHeader[0] = L'\0';
            
            if(WideCharToMultiByte(CP_ACP, 0, wszHeader, -1, szHeader, ARRAYSIZE(szHeader) - 1, NULL, NULL) == 0)
            {
                IF_FAILEXIT(hr = HrRewindStream(pStmPlainW));
            }
            
            else
            {
                // Lets Read the first "<x-rich>" bytes and see if it might be text/enriched
                if (0 == StrCmpI(szHeader, "<x-rich>"))
                {
                    // Convert to HTML
                    IF_FAILEXIT(hr = MimeOleConvertEnrichedToHTMLEx((IMimeBody *)pNode->pBody, IET_INETCSET, &pStmHtml));
                }
                
                // Is this html ?
                else if (SUCCEEDED(FindMimeFromData(NULL, NULL, szHeader, cchRead, NULL, NULL, &pwszType, 0)) && pwszType && 0 == StrCmpIW(pwszType, L"text/html"))
                {
                    // Release pStmPlainW
                    SafeRelease(pStmPlainW);
                    
                    // Just get and return an HTML inetcset encoded stream
                    IF_FAILEXIT(hr = pNode->pBody->GetData(IET_INETCSET, &pStmHtml));
                }
                
                // Otherwise, rewind pStmPlainW
                else
                {
                    // Rewind
                    IF_FAILEXIT(hr = HrRewindStream(pStmPlainW));
                }
            }
        }
    }
    
    // Otheriwse
    else
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // We have HTML
    if (pStmHtml)
    {
        // Client wants HTML
        if (ISFLAGSET(m_rOptions.dwFlags, WPF_HTML))
        {
            // Return the Html Stream
            *ppStream = pStmHtml;
            pStmHtml = NULL;
            goto exit;
        }
        
        // Otherwise, client wants plain text
        else
        {
            // Convert to Plain text
            IF_FAILEXIT(hr = HrConvertHTMLToFormat(pStmHtml, &pStmPlainW, CF_UNICODETEXT));
        }
    }
    
    // Otherwise, if I have a plain stream
    if (NULL == pStmPlainW)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Determine if we should quote (Can't quote QP)
    fQuote = (IET_QP == pNode->pContainer->GetEncodingType()) ? FALSE : TRUE;
    
    // Convert Unicode Plain stream to HTML
    IF_FAILEXIT(hr = HrConvertPlainStreamW(pStmPlainW, fQuote ? m_rOptions.wchQuote : NULL, &pStmHtmlW));
    
    // Convert from unicode back to internet character set
    IF_FAILEXIT(hr = HrIStreamWToInetCset(pStmHtmlW, m_hCharset, &pStmHtml));
    
    // Return pStmHtml
    *ppStream = pStmHtml;
    pStmHtml = NULL;
// #ifdef DEBUG

//     WriteStreamToFile(*ppStream, "c:\\dump.htm", CREATE_ALWAYS, GENERIC_WRITE);    
// #endif
    
exit:
    // Cleanup
    SafeRelease(pStmHtml);
    SafeRelease(pStmHtmlW);
    SafeRelease(pStmPlainW);
    SafeRelease(pStmEnriched);
    SafeMemFree(pwszType);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_DoSegmentSplitter
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_DoSegmentSplitter(void)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPAGESEGMENT   pSegment=NULL;

    // Trace
    TraceCall("CMessageWebPage::_DoSegmentSplitter");

    // Append a PageSegment
    IF_FAILEXIT(hr = _AllocateSegment(&pSegment, TRUE));

    // If more than one inline bodies ?
    if (S_OK == m_pCallback->OnWebPageSplitter(m_cInline, pSegment->pStream))
    {
        // Rewind the stream
        HrRewindStream(pSegment->pStream);

        // Link Segment into list...
        _VAppendSegment(pSegment);

        // Don't Free It
        pSegment = NULL;
    }

    // Otherwise, free this segment
    else
    {
        // Free It
        _VFreeSegment(pSegment);

        // Done Free it again
        pSegment = NULL;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_InlineTextBody
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_InlineTextBody(LPMESSAGETREE pTree, LPTREENODEINFO pNode, BOOL fSetParents)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rVariant;
    LPSTREAM        pStream=NULL;
    LPPAGESEGMENT   pSegment=NULL;
    LPTREENODEINFO  pCurrent;
    LPSTR           pszFileName=NULL;

    // Tracing
    TraceCall("CMessageWebPage::_InlineTextBody");

    // This node better not already be on the webpage
    Assert(FALSE == ISFLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE));

    // Handle Text Types that I explicitly will never inline
    if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_VCARD))
        goto exit;

    // Inline the body
    if (S_OK != _GetInlineHtmlStream(pTree, pNode, &pStream))
        goto exit;

    // Setup a Variant
    rVariant.vt = VT_LPSTR;

    // If this body has a file name, lets also show it as an attachment
    if (SUCCEEDED(pNode->pContainer->GetProp(PIDTOSTR(PID_ATT_FILENAME), NOFLAGS, &rVariant)))
    {
        // Save the File name
        pszFileName = rVariant.pszVal;
    }

    // Only showing images ?
    if (FALSE == ISFLAGSET(m_rOptions.dwFlags, WPF_IMAGESONLY))
    {
        // Segment Split
        _DoSegmentSplitter();

        // Append a PageSegment
        IF_FAILEXIT(hr = _AllocateSegment(&pSegment, FALSE));

        // Set pStream
        pSegment->pStream = pStream;
        pSegment->pStream->AddRef();

        // Link Segment into list...
        _VAppendSegment(pSegment);

        // Don't Free It
        pSegment = NULL;

        // Report that some data is available
        m_pRequest->OnBindingDataAvailable();

        // Increment number of inline bodies
        m_cInline++;
    }

    // Mark the node as rendered
    rVariant.vt = VT_UI4;
    rVariant.ulVal = TRUE;

    // If this has a filename
    if (pszFileName)
    {
        // Mark it as auto-inlined
        SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &rVariant)));
    }

    // Set the Property
    SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));

    // We have rendered this node on the webpage
    FLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE);

    // Set parents are on webpage
    if (fSetParents)
    {
        // Raid-45116: new text attachment contains message body on Communicator inline image message
        pCurrent = pNode->pParent;

        // Try to find an alternative parent...
        while(pCurrent)
        {
            // If multipart/alternative, walk all of its children and mark them as being rendered
            if (S_OK == pCurrent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE))
            {
                // Get Parent
                for (LPTREENODEINFO pChild=pCurrent->pChildHead; pChild!=NULL; pChild=pChild->pNext)
                {
                    // Set Resolve Property
                    SideAssert(SUCCEEDED(pChild->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));
                }
            }

            // Mark as being on the webpage
            FLAGSET(pCurrent->dwState, NODESTATE_ONWEBPAGE);

            // Get Next Parent
            pCurrent = pCurrent->pParent;
        }
    }

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeMemFree(pszFileName);
    if (pSegment)
        _VFreeSegment(pSegment);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_SetContentId
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_SetContentId(LPTREENODEINFO pNode, LPSTR pszCID, ULONG cchCID)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszContentId=NULL;
    GUID            guid;
    WCHAR           wszGUID[64];
    LPSTR           pszFile;
    LPSTR           pszGuid=0;
    LPSTR           pszT;

    // Tracing
    TraceCall("CMessageWebPage::_SetContentId");

    // See of pNode already has a Content-ID
    if (S_FALSE == pNode->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTID)))
    {
        // $BUG #64186
        //   Create a content-id in the form:
        //   CID:{guid}/<filename>
        //   so that trident's save-as dialog has a meaningful
        //   filename to work with

        // Create a guid
        IF_FAILEXIT(hr = CoCreateGuid(&guid));

        // Convert the GUID to a string
        if (0 == StringFromGUID2(guid, wszGUID, ARRAYSIZE(wszGUID)))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Convert to ANSI
        pszGuid = PszToANSI(CP_ACP, wszGUID);
        if (!pszGuid)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        // [PaulHi] 6/18/99.  Raid 76531.  Don't append the file name to the GUID ... 
        // it causes encoding problems with Trident International.  In particular the 
        // DBCS characters in the filename can cause the HTML to contain both JIS and 
        // SHIFT-JIS encodings.  I believe this is a Trident bug because we explicitly
        // set the Trident to CP_JAUTODETECT (JIS) and it still performs SHIFT_JIS decoding
        // if the attachment filename is long.  However, the real fix is to make the entire
        // HTML text a single (JIS) encoding, but this is difficult to do because the attachment
        // code is single byte (DBCS) which equates to SHIFT-JIS.  We need to convert fully to
        // Unicode.
        INETCSETINFO    rCharset;
        MimeOleGetCharsetInfo(m_hCharset, &rCharset);
        if (rCharset.cpiInternet != CP_JAUTODETECT) // code page 50932
        {
            // If we have a file-name, append to guid
            if (pNode->pContainer->GetProp(PIDTOSTR(STR_ATT_GENFNAME), &pszFile)==S_OK)
            {
                // Allocate Buffer
                DWORD cchSize = (lstrlen(pszFile) + lstrlen(pszGuid) + 2);
                pszT = PszAllocA(cchSize);
                if (pszT)
                {
                    // Copy contents and free old GUID
                    wnsprintfA(pszT, cchSize, "%s/%s", pszGuid, pszFile);
                    MemFree(pszGuid);
                    pszGuid = pszT;
                }
                MemFree(pszFile);
            }
        }
        else
        {
            // @HACK [PaulHi]  Preempt any JIS encoding problems by just appending "/.".
            // This will allow right-click save image as operation to work without
            // the user seeing the URL GUID.
            DWORD cchSize = (lstrlen(pszGuid) + 3);
            pszT = PszAllocA(cchSize);
            if (pszT)
            {
                // Copy conents and free old GUID
                wnsprintfA(pszT, cchSize, "%s/.", pszGuid);
                MemFree(pszGuid);
                pszGuid = pszT;
            }
        }

        // copy GUID to output buffer
        StrCpyNA(pszCID, pszGuid, cchCID);

        // Store the content-id into the node
        IF_FAILEXIT(hr = pNode->pContainer->SetProp(PIDTOSTR(PID_HDR_CNTID), pszCID));
    }

    // Otheriwse, get the Content-ID from this body
    else
    {
        // Get the Content-Id
        IF_FAILEXIT(hr = pNode->pContainer->GetProp(PIDTOSTR(PID_HDR_CNTID), &pszContentId));

        // Copy it into pszCID
        Assert(lstrlen(pszContentId) <= (LONG)cchCID);

        // Copy the cid to the outbound variable
        StrCpyN(pszCID, pszContentId, cchCID);
    }

exit:
    // Cleanup
    SafeMemFree(pszContentId);
    SafeMemFree(pszGuid);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_InlineImageBody
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_InlineImageBody(LPMESSAGETREE pTree, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszFile=NULL;
    LPSTR           pszExt;
    CHAR            szCID[CCHMAX_CID + 1];
    PROPVARIANT     rVariant;
    LPPAGESEGMENT   pSegment=NULL;

    // Tracing
    TraceCall("CMessageWebPage::_InlineImageBody");

    // This node better not already be on the webpage
    Assert(pTree && pNode && FALSE == ISFLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE));

    // Setup the Variant
    rVariant.vt = VT_UI4;

    // If the body is marked as inline, or autoline attachments is enabled and (slideshow is disabled)
    if (S_OK == pNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_INLINE, FALSE, FALSE) || ISFLAGSET(m_rOptions.dwFlags, WPF_AUTOINLINE))
    {
        // Get a generated filename from the body
        IF_FAILEXIT(hr = pNode->pContainer->GetProp(PIDTOSTR(PID_ATT_GENFNAME), &pszFile));

        // Look up the file extension of the body
        pszExt = PathFindExtension(pszFile);
        
        // Do I support inlining this object ?
        if (lstrcmpi(pszExt, c_szBmpExt) ==  0  || 
            lstrcmpi(pszExt, c_szJpgExt) ==  0  || 
            lstrcmpi(pszExt, c_szJpegExt) == 0  || 
            lstrcmpi(pszExt, c_szGifExt) ==  0  || 
            lstrcmpi(pszExt, c_szIcoExt) ==  0  ||
            lstrcmpi(pszExt, c_szWmfExt) ==  0  ||
            lstrcmpi(pszExt, c_szPngExt) ==  0  ||
            lstrcmpi(pszExt, c_szEmfExt) ==  0  ||
            lstrcmpi(pszExt, c_szArtExt) ==  0  ||
            lstrcmpi(pszExt, c_szXbmExt) ==  0)
        {
            // Generate a Content-Id for this body
            IF_FAILEXIT(hr = _SetContentId(pNode, szCID, CCHMAX_CID));

            // If the user wants a slide show, then lets mark this body as a slideshow image
            if (ISFLAGSET(m_rOptions.dwFlags, WPF_SLIDESHOW))
            {
                // Mark the node as rendered
                rVariant.vt = VT_UI4;
                rVariant.ulVal = TRUE;

                // Set the Property
                SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));
                SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &rVariant)));

                // Count the number of items in the slide show
                m_cSlideShow++;

                // This node is in the slide show and will be processed at the end of the rendering
                FLAGSET(pNode->dwState, NODESTATE_INSLIDESHOW);

                // Basically, we rendered this body
                FLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE);

                // Done
                goto exit;
            }

            // Otherwise, inline it and mark it as rendered
            else
            {
                // Segment Splitter
                _DoSegmentSplitter();

                // Append a PageSegment
                IF_FAILEXIT(hr = _AllocateSegment(&pSegment, TRUE));

                // Write the HTML for an inline image
                IF_FAILEXIT(hr = pSegment->pStream->Write(STR_INLINE_IMAGE1, lstrlen(STR_INLINE_IMAGE1), NULL));

                // Write the CID
                IF_FAILEXIT(hr = pSegment->pStream->Write(szCID, lstrlen(szCID), NULL));

                // Write the HTML for an inline image
                IF_FAILEXIT(hr = pSegment->pStream->Write(STR_INLINE_IMAGE2, lstrlen(STR_INLINE_IMAGE2), NULL));

                // Rewind the stream
                IF_FAILEXIT(hr = HrRewindStream(pSegment->pStream));

                // Link Segment into list...
                _VAppendSegment(pSegment);

                // Don't Free It
                pSegment = NULL;

                // Report that some data is available
                m_pRequest->OnBindingDataAvailable();

                // Mark the node as rendered
                rVariant.vt = VT_UI4;
                rVariant.ulVal = TRUE;

                // Set the Property
                SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));
                SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &rVariant)));
            
                // Basically, we rendered this body
                FLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE);

                // Basically, we rendered this body
                goto exit;
            }
        }
    }

    // If we got here, we didn't inline the iamge
    hr = E_FAIL;

exit:
    // Cleanup
    SafeMemFree(pszFile);
    if (pSegment)
        _VFreeSegment(pSegment);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::OnBodyBoundToTree
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::OnBodyBoundToTree(LPMESSAGETREE pTree, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszStart=NULL;
    LPSTR           pszType=NULL;
    PROPVARIANT     Variant;
    RESOLVEURLINFO  rInfo;

    // Tracing
    TraceCall("CMessageWebPage::OnBodyBoundToTree");

    // Invalid Args
    Assert(pTree && pNode && BINDSTATE_COMPLETE == pNode->bindstate);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set Variant
    Variant.vt = VT_UI4;
    Variant.ulVal = FALSE;

    // Remove PID_ATT_RENDERED and PID_ATT_AUTOINLINED Properties
    pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &Variant);
    pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &Variant);

    // If pNode is a multipart...
    if (S_OK == pNode->pContainer->IsContentType(STR_CNT_MULTIPART, NULL))
    {
        // Alternative
        if (S_OK == pNode->pContainer->IsContentType(NULL, STR_SUB_ALTERNATIVE))
        {
            // Bound multipart/alternative and non of its bodies got displayed on the web page
            if (FALSE == ISFLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE))
            {
                // Loop through this multipart's alternative bodies...
                for (LPTREENODEINFO pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
                {
                    // text/plain -> text/html
                    if (S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, NULL))
                    {
                        // Inline the body
                        IF_FAILEXIT(hr = _InlineTextBody(pTree, pChild, TRUE));

                        // Done
                        break;
                    }
                }
            }
        }
    }

    // Otherwise, non-multipart body
    else
    {
        // If in multipart/mixed or not in a multipart
        if (NULL == pNode->pParent || 
            S_OK == pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_MIXED) ||
            S_OK == pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, "report"))
        {
            // Try to inline as an image...
            if (FAILED(_InlineImageBody(pTree, pNode)))
            {
                // If is inline body
                if (S_FALSE == pNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_ATTACHMENT, FALSE, FALSE) || ISFLAGSET(pNode->dwState, NODESTATE_AUTOATTACH))
                {
                    // Inline the body
                    IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, FALSE));
                }
            }
        }

        // Otheriwse, is pNode inside of a multipart/related section
        else if (S_OK == pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_RELATED))
        {
            // If we haven't rendered a body for this multipart/related section yet ?
            if (FALSE == ISFLAGSET(pNode->pParent->dwState, NODESTATE_ONWEBPAGE))
            {
                // Get the start parameter from pNode->pParent
                if (SUCCEEDED(pNode->pParent->pContainer->GetProp(STR_PAR_START, &pszStart)))
                {
                    // Setup Resolve URL Info
                    rInfo.pszInheritBase = NULL;
                    rInfo.pszBase = NULL;
                    rInfo.pszURL = pszStart;
                    rInfo.fIsCID = TRUE;

                    // See if pNode's Content-Id matches this...
                    if (SUCCEEDED(pNode->pContainer->HrResolveURL(&rInfo)))
                    {
                        // Inline the body
                        IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                    }
                }

                // Otherwise, fetch the type parameter
                else if (SUCCEEDED(pNode->pParent->pContainer->GetProp(STR_PAR_TYPE, &pszType)))
                {
                    // Is this the type ?
                    if (S_OK == pNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTTYPE), pszType, FALSE, FALSE))
                    {
                        // Inline the body
                        IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                    }
                }

                // Otherwise, if this is the first body in the multipart/related section
                else if (pNode == pNode->pParent->pChildHead)
                {
                    // Inline the body
                    IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                }
            }
        }

        // Otheriwse, is pNode inside of a multipart/alternative section
        else if (S_OK == pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE))
        {
            // If we haven't rendered a body for this multipart/related section yet ?
            if (FALSE == ISFLAGSET(pNode->pParent->dwState, NODESTATE_ONWEBPAGE))
            {
                // Is there are start parameter ?
                if (pNode->pParent->pParent)
                {
                    // Is multipart/related ?
                    if (S_OK == pNode->pParent->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_RELATED))
                    {
                        // Get the Start Parameter
                        pNode->pParent->pParent->pContainer->GetProp(STR_PAR_START, &pszStart);
                    }
                }

                // Something that is not marked as an attachment ?
                if (S_FALSE == pNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_ATTACHMENT, FALSE, FALSE))
                {
                    // Try to inline ?
                    BOOL fTryToInline = TRUE;

                    // If there is a start parameter and this nod'es Content-Id is equal to start...
                    if (pszStart)
                    {
                        // Setup Resolve URL Info
                        rInfo.pszInheritBase = NULL;
                        rInfo.pszBase = NULL;
                        rInfo.pszURL = pszStart;
                        rInfo.fIsCID = TRUE;

                        // See if pNode's Content-Id matches this...
                        if (!SUCCEEDED(pNode->pContainer->HrResolveURL(&rInfo)))
                            fTryToInline = FALSE;
                    }

                    // Try to inline
                    if (fTryToInline)
                    {
                        // If we are rendering HTML
                        if (ISFLAGSET(m_rOptions.dwFlags, WPF_HTML))
                        {
                            // If this body is HTML
                            if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_HTML))
                            {
                                // Inline the body
                                IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                            }

                            // We can convert text/enriched to html
                            else if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_ENRICHED))
                            {
                                // Inline the body
                                IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                            }
                        }

                        // Otherwise, we are rendering plain text, and this body is plain text
                        else if (FALSE == ISFLAGSET(m_rOptions.dwFlags, WPF_HTML))
                        {
                            // Is text/*
                            if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN))
                            {
                                // Inline the body
                                IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                            }
                        }
                    }
                }
            }            
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeMemFree(pszStart);
    SafeMemFree(pszType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_DoAttachmentLinks
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_DoAttachmentLinks(LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;
    LPHBODY         prghAttach=NULL;
    CHAR            szRes[256];
    LPPAGESEGMENT   pSegment=NULL;
    CHAR            szCID[CCHMAX_CID];
    LPTREENODEINFO  pNode;
    LPSTR           pszDisplay=NULL;
    DWORD           cAttach;
    DWORD           i;

    // Tracing
    TraceCall("CMessageWebPage::_DoAttachmentLinks");

    // Get all the un-rendered stuff from the message
    IF_FAILEXIT(hr = pTree->GetAttachments(&cAttach, &prghAttach));
    
    // No Attachments
    if (0 == cAttach)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Append a PageSegment
    IF_FAILEXIT(hr = _AllocateSegment(&pSegment, TRUE));

    // Load Attachment Title
    LoadString(g_hLocRes, idsAttachTitleBegin, szRes, ARRAYSIZE(szRes));

    // Write the HTML for the attachment section title...
    IF_FAILEXIT(hr = pSegment->pStream->Write(szRes, lstrlen(szRes), NULL));

    // Loop through the Attachments
    for (i=0; i<cAttach; i++)
    {
        // Get the Node
        pNode = pTree->_PNodeFromHBody(prghAttach[i]);

        // Should not already be on the web page
        Assert(!ISFLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE) && !ISFLAGSET(pNode->dwState, NODESTATE_INSLIDESHOW));

        // Get the display name
        IF_FAILEXIT(hr = pNode->pBody->GetDisplayName(&pszDisplay));

        // Generate a Content-Id for this body
        IF_FAILEXIT(hr = _SetContentId(pNode, szCID, CCHMAX_CID));

        // Write the HTML for a bulleted attachment
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_ATTACH_BEGIN, lstrlen(STR_ATTACH_BEGIN), NULL));

        // Write the Content-Id
        IF_FAILEXIT(hr = pSegment->pStream->Write(szCID, lstrlen(szCID), NULL));

        // Write the HTML for a bulleted attachment
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_ATTACH_MIDDLE, lstrlen(STR_ATTACH_MIDDLE), NULL));

        // Write the friendly name
        IF_FAILEXIT(hr = pSegment->pStream->Write(pszDisplay, lstrlen(pszDisplay), NULL));

        // Write the HTML for a bulleted attachment
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_ATTACH_END, lstrlen(STR_ATTACH_END), NULL));

        // Cleanup
        SafeMemFree(pszDisplay);

        // This node is on the webpage
        FLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE);
    }

    // Write the HTML for the attachment title end
    IF_FAILEXIT(hr = pSegment->pStream->Write(STR_ATTACH_TITLE_END, lstrlen(STR_ATTACH_TITLE_END), NULL));

    // Rewind the stream
    IF_FAILEXIT(hr = HrRewindStream(pSegment->pStream));

    // Link Segment into list...
    _VAppendSegment(pSegment);

    // Don't Free It
    pSegment = NULL;

    // Report that some data is available
    m_pRequest->OnBindingDataAvailable();

exit:
    // Cleanup
    SafeMemFree(prghAttach);
    if (pSegment)
        _VFreeSegment(pSegment);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_DoSlideShow
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_DoSlideShow(LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPTREENODEINFO  pNode;
    LPPAGESEGMENT   pSegment=NULL;
    CHAR            szSlideEnd[255];
    IStream        *pStmHtmlW=NULL;
    LPSTR           pszValueA=NULL;
    LPWSTR          pszValueW=NULL;

    // Tracing
    TraceCall("CMessageWebPage::_DoSlideShow");

    // Invalid Arg
    Assert(pTree);

    // No Slides
    if (0 == m_cSlideShow)
        return S_OK;

    // Load the inline HTML
    IF_FAILEXIT(hr = HrLoadStreamFileFromResourceW(GetACP(), "inline.htm", &pStmHtmlW));

    // Walk through all the nodes and get the things that are marked for the slide show
    for (i=0; i<pTree->m_rTree.cNodes; i++)
    {
        // Get the node
        pNode = pTree->m_rTree.prgpNode[i];
        if (NULL == pNode)
            continue;

        // If not marked NODESTATE_INSLIDESHOW
        if (FALSE == ISFLAGSET(pNode->dwState, NODESTATE_INSLIDESHOW))
            continue;

        // Append the ssimage
        IF_FAILEXIT(hr = pStmHtmlW->Write(STR_SLIDEIMG_BEGIN, lstrlenW(STR_SLIDEIMG_BEGIN) * sizeof(WCHAR), NULL));

        // Get the ContentId
        IF_FAILEXIT(hr = pNode->pContainer->GetProp(PIDTOSTR(PID_HDR_CNTID), &pszValueA));

        // Convert to Unicode
        IF_NULLEXIT(pszValueW = PszToUnicode(MimeOleGetWindowsCP(m_hCharset), pszValueA));

        // Append the Content-ID
        IF_FAILEXIT(hr = pStmHtmlW->Write(pszValueW, lstrlenW(pszValueW) * sizeof(WCHAR), NULL));

        // Free pszValue
        SafeMemFree(pszValueA);
        SafeMemFree(pszValueW);

        // Append the separator
        IF_FAILEXIT(hr = pStmHtmlW->Write(STR_QUOTECOMMASPACEQUOTE, lstrlenW(STR_QUOTECOMMASPACEQUOTE) * sizeof(WCHAR), NULL));

        // Get the Display Name
        IF_FAILEXIT(hr = pNode->pBody->GetDisplayName(&pszValueA));

        // Convert to Unicode
        IF_NULLEXIT(pszValueW = PszToUnicode(MimeOleGetWindowsCP(m_hCharset), pszValueA));

        // Append the Display Name
        IF_FAILEXIT(hr = pStmHtmlW->Write(pszValueW, lstrlenW(pszValueW) * sizeof(WCHAR), NULL));

        // Free pszValue
        SafeMemFree(pszValueA);
        SafeMemFree(pszValueW);

        // Append the separator
        IF_FAILEXIT(hr = pStmHtmlW->Write(STR_QUOTEPARASEMI, lstrlenW(STR_QUOTEPARASEMI) * sizeof(WCHAR), NULL));
    }

    // Format the Ending String
    wnsprintf(szSlideEnd, ARRAYSIZE(szSlideEnd), "g_dwTimeOutSec=%d\r\n</SCRIPT>\r\n", (m_rOptions.dwDelay / 1000));

    // Convert to Unicode
    IF_NULLEXIT(pszValueW = PszToUnicode(MimeOleGetWindowsCP(m_hCharset), szSlideEnd));

    // Append the separator
    IF_FAILEXIT(hr = pStmHtmlW->Write(pszValueW, lstrlenW(pszValueW) * sizeof(WCHAR), NULL));

    // Rewind the stream
    IF_FAILEXIT(hr = HrRewindStream(pStmHtmlW));

    // Append a PageSegment
    IF_FAILEXIT(hr = _AllocateSegment(&pSegment, FALSE));

    // Now we have a unicode stream, we have to convert back to internet charset for rootstream
    IF_FAILEXIT(hr = HrIStreamWToInetCset(pStmHtmlW, m_hCharset, &pSegment->pStream));

    // Rewind the stream
    IF_FAILEXIT(hr = HrRewindStream(pSegment->pStream));

    // Link Segment into list...
    _VAppendSegment(pSegment);

    // Don't Free It
    pSegment = NULL;

    // Report that some data is available
    m_pRequest->OnBindingDataAvailable();

exit:
    // Cleanup
    SafeMemFree(pszValueA);
    SafeMemFree(pszValueW);
    SafeRelease(pStmHtmlW);
    if (pSegment)
        _VFreeSegment(pSegment);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::OnBindComplete
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::OnBindComplete(LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;

    // Tracing
    TraceCall("CMessageWebPage::OnBindComplete");

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // We Better have a Request
    Assert(pTree && m_pRequest && FALSE == m_fComplete);

    // Attachment Links ?
    if (ISFLAGSET(m_rOptions.dwFlags, WPF_ATTACHLINKS))
        _DoAttachmentLinks(pTree);

    // Slide Show ?
    if (ISFLAGSET(m_rOptions.dwFlags, WPF_SLIDESHOW))
        _DoSlideShow(pTree);

    // Complete
    m_fComplete = TRUE;

    // Tell the Request That we are done
    m_pRequest->OnBindingComplete(S_OK);

    // Release the Request
    SafeRelease(m_pRequest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::OnWebPageSplitter
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageWebPage::OnWebPageSplitter(DWORD cInlined, IStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;

    // Tracing
    TraceCall("CMessageWebPage::OnWebPageSplitter");

    // I'm going to put a horizontal line between each segment
    if (cInlined > 0)
    {
        // Write STR_METATAG_PREFIX
        IF_FAILEXIT(hr = pStream->Write(STR_SEGMENT_SPLIT, lstrlen(STR_SEGMENT_SPLIT), NULL));
    }

    // Otherwise, I did nothing
    else
        hr = S_FALSE;

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\attrib.cpp ===
#include "item.h"
#include <stdio.h>

BOOL DataToString(LPBYTE pb, DWORD cb, LPSTR *szData)
{
    LPSTR   szTmp = NULL;
    CHAR    szNum[5];
    
    szTmp = (LPSTR) malloc(cb*2 + 1);
    if (szTmp != NULL) {
        szTmp[0] = '\0';
        for (;cb > 0;cb -= 1, pb += 1) {
            sprintf(szNum,"%02hX", *pb);
            strcat(szTmp, szNum);
        }
    }
    *szData = szTmp;
    return TRUE;
}

BOOL StringToData(LPSTR szData, LPBYTE *pb, DWORD *cb)
{
    LPBYTE  pbData = NULL;
    LPBYTE  pbTemp = NULL;
    DWORD   cbData = 0;
    CHAR    szNum[5];

    *cb = 0;
    if ((szData != NULL) && (strlen(szData) > 0)) {
        cbData = strlen(szData)/2;
        AssertSz(((strlen(szData) % 2) == 0), "Not in even bytes. ignoring last character");
        pbData = (LPBYTE) malloc(cbData + 3);
        if (pbData != NULL) {
            pbTemp = pbData;
            for (;strlen(szData) > 1;szData += 2, pbTemp += 1) {
                sscanf(szData,"%2X", pbTemp);
            }
            *cb = cbData;
        }
    }
    *pb = pbData;
    return TRUE;
}

BOOL AuthAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    LPBYTE                      pb;
    LPSTR                       szOID;
    LPSTR                       szASN;
    static CSignData *          psd = NULL;
    CHAR                        rgchOID[256];
    
    switch (message) {
    case WM_INITDIALOG:
        psd = (CSignData *) lParam;
        szOID = psd->GetAuthAttribOID();
        if (szOID != NULL) {
        
            SetDlgItemText(hwnd, IDC_BA_OID, szOID);

            psd->GetAuthAttribData(&pb, &cb);
            if ((cb > 0) && (pb != NULL)) {
                DataToString(pb,cb,&szASN);
                if (szASN != NULL) {
                    SetDlgItemText(hwnd, IDC_BA_ASN, szASN);
                    free(szASN);
                }
            }
        }
        break;

    case WM_COMMAND:
        switch(wParam) {
        case IDOK:
            GetDlgItemText(hwnd, IDC_BA_OID,
                           rgchOID, sizeof(rgchOID));
            if (rgchOID[0] != '\0') {
                psd->SetAuthAttribOID(rgchOID);
            }
            else {
                psd->SetAuthAttribOID(NULL);
            }

            cb = SendDlgItemMessage(hwnd, IDC_BA_ASN, WM_GETTEXTLENGTH,0,0);
            szASN = (LPSTR) malloc(cb+1);
            if (szASN != NULL) {
                GetDlgItemText(hwnd, IDC_BA_ASN, szASN, cb+1);
                StringToData(szASN, &pb, &cb);
                psd->SetAuthAttribData(pb, cb);
            }
            
            // 
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL UnAuthAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    LPBYTE                      pb;
    LPSTR                       szOID;
    LPSTR                       szASN;
    static CSignData *          psd = NULL;
    CHAR                        rgchOID[256];
    
    switch (message) {
    case WM_INITDIALOG:
        psd = (CSignData *) lParam;
        szOID = psd->GetUnAuthAttribOID();
        if (szOID != NULL) {
        
            SetDlgItemText(hwnd, IDC_BA_OID, szOID);

            psd->GetUnAuthAttribData(&pb, &cb);
            if ((cb > 0) && (pb != NULL)) {
                DataToString(pb,cb,&szASN);
                if (szASN != NULL) {
                    SetDlgItemText(hwnd, IDC_BA_ASN, szASN);
                    free(szASN);
                }
            }
        }
        break;

    case WM_COMMAND:
        switch(wParam) {
        case IDOK:
            GetDlgItemText(hwnd, IDC_BA_OID,
                           rgchOID, sizeof(rgchOID));
            if (rgchOID[0] != '\0') {
                psd->SetUnAuthAttribOID(rgchOID);
            }
            else {
                psd->SetUnAuthAttribOID(NULL);
            }

            cb = SendDlgItemMessage(hwnd, IDC_BA_ASN, WM_GETTEXTLENGTH,0,0);
            szASN = (LPSTR) malloc(cb+1);
            if (szASN != NULL) {
                GetDlgItemText(hwnd, IDC_BA_ASN, szASN, cb+1);
                StringToData(szASN, &pb, &cb);
                psd->SetUnAuthAttribData(pb, cb);
            }
            
            // 
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL UnProtAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    LPBYTE                      pb;
    LPSTR                       szOID;
    LPSTR                       szASN;
    static CEnvData *           ped = NULL;
    CHAR                        rgchOID[256];
    
    switch (message) {
    case WM_INITDIALOG:
        ped = (CEnvData *) lParam;
        szOID = ped->GetUnProtAttribOID();
        if (szOID != NULL) {
        
            SetDlgItemText(hwnd, IDC_BA_OID, szOID);

            ped->GetUnProtAttribData(&pb, &cb);
            if ((cb > 0) && (pb != NULL)) {
                DataToString(pb,cb,&szASN);
                if (szASN != NULL) {
                    SetDlgItemText(hwnd, IDC_BA_ASN, szASN);
                    free(szASN);
                }
            }
        }
        break;

    case WM_COMMAND:
        switch(wParam) {
        case IDOK:
            GetDlgItemText(hwnd, IDC_BA_OID,
                           rgchOID, sizeof(rgchOID));
            if (rgchOID[0] != '\0') {
                ped->SetUnProtAttribOID(rgchOID);
            }
            else {
                ped->SetUnProtAttribOID(NULL);
            }

            cb = SendDlgItemMessage(hwnd, IDC_BA_ASN, WM_GETTEXTLENGTH,0,0);
            szASN = (LPSTR) malloc(cb+1);
            if (szASN != NULL) {
                GetDlgItemText(hwnd, IDC_BA_ASN, szASN, cb+1);
                StringToData(szASN, &pb, &cb);
                ped->SetUnProtAttribData(pb, cb);
            }
            
            // 
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\assert.cpp ===
//
//

#include <windows.h>

extern const char SzNull[] = "";

////    AssertFn
//

VOID DigSigAssertFn(LPCTSTR szWhy, LPCTSTR szInfo, int lineno, LPCTSTR fname)
{
    int         nRet;
    TCHAR       rgch[1024];
    
    wsprintf(rgch, "An assertion has occurred in the code.\n"
                   "Assertion was located at File: %s, Line: %d\n"
                   "Assertion condition was %s\n%s\n"
                   "\nPress Ignore to skip assertion, Retry to break into the"
                   " debugger, or Abort to kill the program.\n\n"
                   "Make sure that JIT is setup to use WinDbg please.",
             fname, lineno, szWhy, szInfo);

    nRet = MessageBox(GetActiveWindow(), rgch, "S/MIME Test Assert",
                      MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL |
                      MB_ICONEXCLAMATION | MB_DEFBUTTON3);

    switch( nRet ) {
    case IDABORT:
        FatalAppExit(0, "Terminating App");

    case IDRETRY:
        DebugBreak();
        break;

    case IDIGNORE:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\mimetest\mimetest.cpp ===
// --------------------------------------------------------------------------------
// Mimetest.cpp
//
// This is a console app that has various types of functions that highlight the
// most typical ways to use mimeole. This console app also acts as a test program
// for mimeole, but does not actually do anything.
//
// Here are the files you need to use mimeole:
//
// mimeole.h    - This is the main header file. It is generated from mimeole.idl.
// mimeole.idl  - This is the interface definition file. It has a little bit of
//                documentation. A client should use this file to find out info
//                about mimeole interfaces, data types, utility functions, etc.
// inetcomm.dll - This is the DLL that contains the implementation of everything
//                in mimeole.h. You should run regsvr32.exe on inetcomm.dll.
// msoert2.dll  - inetcomm.dll statically links to this dll. msoert2 is the Microsoft
//                Outlook Express runtime library. msoert2.dll is part of the Outlook
//                Express installation. This DLL does not require any registration.
// shlwapi.dll  - inetcomm.dll statically links to this dll. shlwapi is part of the
//                Internet Explorer installation. shlwapi does not require any
//                registration.
// mlang.dll    - inetcomm.dll will dynamically load this dll. mlang is used to support
//                various character set translations. mlang stands for multi-language.
//                This DLL is part of the Internet Explorer installation. You should
//                run regsvr32.exe on mlang.dll to register it.
// urlmon.dll   - inetcomm.dll will dynamically load this dll. urlmon is used by 
//                inetcomm to support various parts of MHTML as well as rendering
//                MHTML inside of the IE browser.
// SMIME        - SMIME support in mimeole requires the crypto API, which is part of
//                the IE installation.

// Notes: shlwapi and msoert2, as well as any other DLLs that inetcomm.dll statically
//        links to must be either in the same directory as inetcomm.dll, or be located
//        in a directory that is in the system path.
//
//        The DLLs that inetcomm dynamically load are not required. Inetcomm will still
//        work, although certain functionality will be disabled.
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// To use mimeole objects, per COM rules, you must have one file in your project that
// has the #define INITGUID line, and then include mimeole.h. This will cause all of 
// the CLSIDs and IIDs to be defined.
// --------------------------------------------------------------------------------
#define INITGUID

// --------------------------------------------------------------------------------
// This is simply my precompiled header
// --------------------------------------------------------------------------------
#include "pch.h"
#include <shlwapi.h>
#include <shlwapip.h>

// --------------------------------------------------------------------------------
// Part of the initguid process
// --------------------------------------------------------------------------------
#include <initguid.h>

// --------------------------------------------------------------------------------
// Primary mimeole header file
// --------------------------------------------------------------------------------
#include <mimeole.h>
                      

#define DEFINE_HOTSTORE

// --------------------------------------------------------------------------------
// I'm disable various parts of MOSERT so that I can use it from within this test
// program.
// --------------------------------------------------------------------------------
#define MSOERT_NO_PROTSTOR
#define MSOERT_NO_BYTESTM
#define MSOERT_NO_STRPARSE
#define MSOERT_NO_ENUMFMT
#define MSOERT_NO_CLOGFILE
#define MSOERT_NO_DATAOBJ

// --------------------------------------------------------------------------------
// I know you don't have this, but you can if you want it. This header has a bunch
// of slick macros. I will try not to use too many of them.
// --------------------------------------------------------------------------------
#include "d:\\athena\\inc\\msoert.h"

// --------------------------------------------------------------------------------
// Test function Prototypes
// --------------------------------------------------------------------------------
HRESULT MimeTestAppendRfc822(IMimeMessage **ppMessage);
HRESULT MimeTestSettingContentLocation(IMimeMessage **ppMessage);
HRESULT MimeTestGetMultiValueAddressProp(IMimeMessage **ppMessage);
HRESULT MimeTestLookupCharsetHandle(LPCSTR pszCharset, LPHCHARSET phCharset);
HRESULT MimeTestSettingReplyTo(IMimeMessage **ppMessage);
HRESULT MimeTestSplitMessageIntoParts(void);
HRESULT MimeTestRecombineMessageParts(LPWSTR *prgpszFile, ULONG cFiles);
HRESULT MimeTestIsContentType(IMimeMessage **ppMessage);
HRESULT MimeTestBodyStream(IMimeMessage **ppMessage);
HRESULT MimeTestDeleteBody(IMimeMessage **ppMessage);
HRESULT MimeTestEnumHeaderTable(IMimeMessage **ppMessage);
HRESULT MimeTestCDO(IMimeMessage **ppMessage);

// --------------------------------------------------------------------------------
// Utility functions used by mimetest
// --------------------------------------------------------------------------------
HRESULT DumpStreamToConsole(IStream *pStream);
HRESULT ReportError(LPCSTR pszFunction, INT nLine, LPCSTR pszErrorText, HRESULT hrResult);
HRESULT ReportStatus(LPCSTR pszStatusText);
HRESULT CreateMimeMessage(IMimeMessage **ppMessage);
HRESULT SaveMimeMessage(IMimeMessage *pMessage, MIMESAVETYPE savetype, IStream **ppStream);
         
// --------------------------------------------------------------------------------
// Testing Switches
// --------------------------------------------------------------------------------
// #define TEST_MimeTestAppendRfc822
// #define TEST_MimeTestSettingContentLocation
// #define TEST_MimeTestGetMultiValueAddressProp
// #define TEST_MimeTestSettingReplyTo
// #define TEST_MimeTestSplitMessageIntoParts
// #define TEST_MimeTestIsContentType
// #define TEST_MimeTestBodyStream
// #define TEST_MimeTestDeleteBody
// #define TEST_MimeTestEnumHeaderTable
#define TEST_MimeTestCDO

// --------------------------------------------------------------------------------
// MimeTest Entry Point
// --------------------------------------------------------------------------------
void __cdecl main(int argc, char *argv[])
{
    // Locals
    HRESULT hr;
    IMimeMessage *pMessage=NULL;

    // You must always call this if you are going to use COM
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "CoInitialize failed.", hr);
        exit(1);
    }

    IDatabaseTable *pTable;
    HROWSET hRowset;
    MESSAGEINFO Message;
    CoCreateInstance(CLSID_DatabaseTable, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseTable, (LPVOID *)&pTable);
    pTable->Open("d:\\store\\00000004.dbx", 0, &g_MessageTableSchema, NULL);
    pTable->CreateRowset(IINDEX_SUBJECT, 0, &hRowset);
    while (S_OK == pTable->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        printf("%08d: %s\n", Message.idMessage, Message.pszSubject);
        pTable->FreeRecord(&Message);
    }
    pTable->CloseRowset(&hRowset);
    pTable->Release();
    exit(1);


    // ----------------------------------------------------------------------------
    // TEST_MimeTestCDO
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestCDO
    MimeTestCDO(NULL);
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestEnumHeaderTable
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestEnumHeaderTable
    hr = MimeTestEnumHeaderTable(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestEnumHeaderTable failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestDeleteBody
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestDeleteBody
    hr = MimeTestDeleteBody(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestDeleteBody failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestBodyStream
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestBodyStream
    hr = MimeTestBodyStream(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestBodyStream failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestIsContentType
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestIsContentType
    hr = MimeTestIsContentType(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestIsContentType failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestAppendRfc822
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestAppendRfc822
    hr = MimeTestAppendRfc822(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestAppendRfc822 failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestGetMultiValueAddressProp
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestGetMultiValueAddressProp
    hr = MimeTestGetMultiValueAddressProp(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestAppendRfc822 failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestSettingContentLocation
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestSettingContentLocation
    hr = MimeTestSettingContentLocation(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestSettingContentLocation failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestSettingReplyTo
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestSettingReplyTo
    hr = MimeTestSettingReplyTo(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestSettingReplyTo failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestSplitMessageIntoParts
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestSplitMessageIntoParts
    hr = MimeTestSplitMessageIntoParts();
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestSplitMessageIntoParts failed.", hr);
        goto exit;
    }
#endif

exit:
    // Cleanup
    if (pMessage)
        pMessage->Release();

    // I called CoInitialize, so lets call this...
    CoUninitialize();

    // Done
    exit(1);
}


// --------------------------------------------------------------------------------
// MimeTestCDO
// --------------------------------------------------------------------------------
//#define RAID_17675
#define RAID_20406
//#define RAID_29961

HRESULT MimeTestCDO(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                  hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IPersistFile            *pPersistFile=NULL;
    PROPVARIANT              Variant;
    LPSTR                    psz;
    FINDBODY                 FindBody={0};
    HBODY                    hBody;
    HCHARSET                 hCharset;
    IMimeBody               *pBody=NULL;
    IMimeInternational      *pInternat=NULL;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
        goto exit;

#ifdef RAID_29961
    hr = CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER, IID_IMimeInternational, (LPVOID *)&pInternat);
    if (FAILED(hr))
        goto exit;

    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
        goto exit;

    hr = pPersistFile->Load(L"j:\\test\\raid29961.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
        goto exit;

    FindBody.pszPriType = "text";
    FindBody.pszSubType = "plain";

    hr = pMessage->FindFirst(&FindBody, &hBody);
    if (FAILED(hr))
        goto exit;

    hr = pMessage->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody);
    if (FAILED(hr))
        goto exit;

    hr = pInternat->FindCharset("iso-8859-7", &hCharset);
    if (FAILED(hr))
        goto exit;

    hr = pBody->SetCharset(hCharset, CSET_APPLY_ALL);
    if (FAILED(hr))
        goto exit;

    pBody->Release();
    pBody = NULL;

    hr = pMessage->FindNext(&FindBody, &hBody);
    if (FAILED(hr))
        goto exit;

    hr = pMessage->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody);
    if (FAILED(hr))
        goto exit;

    hr = pInternat->FindCharset("iso-8859-4", &hCharset);
    if (FAILED(hr))
        goto exit;

    hr = pBody->SetCharset(hCharset, CSET_APPLY_ALL);
    if (FAILED(hr))
        goto exit;

    pBody->Release();
    pBody = NULL;

    hr = pInternat->FindCharset("iso-8859-3", &hCharset);
    if (FAILED(hr))
        goto exit;

    hr = pMessage->SetCharset(hCharset, CSET_APPLY_UNTAGGED);
    if (FAILED(hr))
        goto exit;

    hr = pPersistFile->Save(L"j:\\test\\raid29961_saved.eml", FALSE);
    if (FAILED(hr))
        goto exit;
    
#endif

#ifdef RAID_17675
    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
        goto exit;

    // Load
    hr = pPersistFile->Load(L"c:\\test\\cdo.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
        goto exit;

    ZeroMemory(&Variant, sizeof(PROPVARIANT));
    Variant.vt = VT_EMPTY;        
    hr = pMessage->SetProp("par:content-type:charset", 0, &Variant);
//    if (FAILED(hr))
//        goto exit;

    Variant.vt = VT_LPSTR;        
    hr = pMessage->GetProp("par:content-type:charset", 0, &Variant);
    if (FAILED(hr))
        goto exit;

#endif // RAID_17675

#ifdef RAID_20406

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
        goto exit;

    // Load
    hr = pPersistFile->Load(L"c:\\test\\address.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
        goto exit;

    pMessage->GetAddressFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &psz);
    printf("AFT_DISPLAY_FRIENDLY: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_DISPLAY_EMAIL, &psz);
    printf("AFT_DISPLAY_EMAIL: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_DISPLAY_BOTH, &psz);
    printf("AFT_DISPLAY_BOTH: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_RFC822_DECODED, &psz);
    printf("AFT_RFC822_DECODED: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_RFC822_ENCODED, &psz);
    printf("AFT_RFC822_ENCODED: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_RFC822_TRANSMIT, &psz);
    printf("AFT_RFC822_TRANSMIT: %s\n", psz);
    CoTaskMemFree(psz);

#endif // RAID_20406

exit:
    // Cleanup
    if (pMessage)
        pMessage->Release();
    if (pPersistFile)
        pPersistFile->Release();
    if (pInternat)
        pInternat->Release();

    // Done
    return(hr);
}
 
// --------------------------------------------------------------------------------
// MimeTestEnumHeaderTable
// --------------------------------------------------------------------------------
HRESULT MimeTestEnumHeaderTable(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IPersistFile            *pPersistFile=NULL;
    IMimeHeaderTable        *pTable=NULL;
    IMimeEnumHeaderRows     *pEnum=NULL;
    ENUMHEADERROW            Row;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile) failed.", hr);
        goto exit;
    }

    // Load
    hr = pPersistFile->Load(L"c:\\test\\multiadd.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "IPersistFile::Load failed.", hr);
        goto exit;
    }

    // Get Enumerator
    hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeHeaderTable, (LPVOID *)&pTable);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "pMessage->BindToObject(HBODY_ROOT, IID_IMimeHeaderTable, ...) failed.", hr);
        goto exit;
    }

    // EnumRows
    hr = pTable->EnumRows(NULL, 0, &pEnum);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "pTable->EnumRows failed.", hr);
        goto exit;
    }

    // Loop
    while (S_OK == pEnum->Next(1, &Row, NULL))
    {
        printf("%s: %s\n", Row.pszHeader, Row.pszData);
        CoTaskMemFree(Row.pszHeader);
        CoTaskMemFree(Row.pszData);
    }

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pPersistFile)
        pPersistFile->Release();
    if (pMessage)
        pMessage->Release();
    if (pTable)
        pTable->Release();
    if (pEnum)
        pEnum->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestDeleteBody
// --------------------------------------------------------------------------------
HRESULT MimeTestDeleteBody(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IPersistFile            *pPersistFile=NULL;
    HBODY                   hBody;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile) failed.", hr);
        goto exit;
    }

    // Load
    hr = pPersistFile->Load(L"d:\\test\\delbody.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "IPersistFile::Load failed.", hr);
        goto exit;
    }

    // Load
    hr = pPersistFile->Load(L"d:\\test\\delbody.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "IPersistFile::Load failed.", hr);
        goto exit;
    }

    goto exit;

    // Get the root body
    hr = pMessage->GetBody(IBL_ROOT, NULL, &hBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->GetBody failed.", hr);
        goto exit;
    }

    // Get the root body
    hr = pMessage->GetBody(IBL_FIRST, hBody, &hBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->GetBody failed.", hr);
        goto exit;
    }

    // Delete the Root
    hr = pMessage->DeleteBody(hBody, DELETE_PROMOTE_CHILDREN);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->DeleteBody failed.", hr);
        goto exit;
    }

    // Get the root body
    hr = pMessage->GetBody(IBL_ROOT, NULL, &hBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->GetBody failed.", hr);
        goto exit;
    }

    // Delete the Root
    hr = pMessage->DeleteBody(hBody, 0);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->DeleteBody failed.", hr);
        goto exit;
    }

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pPersistFile)
        pPersistFile->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestBodyStream
// --------------------------------------------------------------------------------
#if 0
HRESULT MimeTestBodyStream(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IStream                 *pStmSave=NULL;
    IStream                 *pStmBody=NULL;
    IStream                 *pStmText=NULL;
    IStream                 *pStmTxtOut=NULL;
    IMimeBody               *pBody=NULL;
    PROPVARIANT             rVariant;
    IWaveAudio              *pWave=NULL;
    IWaveStream             *pStmWave=NULL;
    DWORD                   cAttach;
    HBODY                   hBody;
    HBODY                   *prghAttach=NULL;
    DWORD                   cb;
    DWORD                   dw;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Create a stream in which to save the message...
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStmText);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateStreamOnHGlobal failed", hr);
        goto exit;
    }

    // Write some text into pStmText
    hr = pStmText->Write("Testing BodyStream.", lstrlen("Testing BodyStream."), NULL);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pStmText->Write failed", hr);
        goto exit;
    }

    // Commit
    pStmText->Commit(STGC_DEFAULT);

    // Rewind it
    HrRewindStream(pStmText);

    // Set the text body
    hr = pMessage->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pStmText, NULL);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pMessage->SetTextBody failed", hr);
        goto exit;
    }

    // Attach a file
    hr = pMessage->AttachFile("d:\\waveedit\\test.wav", NULL, NULL);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeMessage::AttachFile failed.", hr);
        goto exit;
    }

    // Save that bad boy to a stream
    hr = CreateTempFileStream(&pStmSave);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateTempFileStream failed.", hr);
        goto exit;
    }

    // Save the message
    hr = pMessage->Save(pStmSave, TRUE);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pMessage->Save failed.", hr);
        goto exit;
    }

    // Commit
    pStmSave->Commit(STGC_DEFAULT);

    // Release pMessage
    pMessage->Release();
    pMessage = NULL;

    // Rewind pStmSave
    HrRewindStream(pStmSave);

    // Create a new message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Load that message object
    hr = pMessage->Load(pStmSave);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeMessage::Load failed.", hr);
        goto exit;
    }

    // Get the text body
    hr = pMessage->GetTextBody(TXT_PLAIN, IET_BINARY, &pStmTxtOut, &hBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pMessage->GetTextBody failed.", hr);
        goto exit;
    }

    // Get the attachment, should be the wave file
    hr = pMessage->GetAttachments(&cAttach, &prghAttach);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pMessage->GetAttachments failed.", hr);
        goto exit;
    }

    // Get the root body
    hr = pMessage->BindToObject(prghAttach[0], IID_IMimeBody, (LPVOID *)&pBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeMessage::BindToObject failed.", hr);
        goto exit;
    }

    // Get the data stream
    hr = pBody->SaveToFile(IET_BINARY, "d:\\waveedit\\test.new");
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeBody::GetData failed.", hr);
        goto exit;
    }

    // Get the data stream
    hr = pBody->GetData(IET_BINARY, &pStmBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeBody::GetData failed.", hr);
        goto exit;
    }

    // Feed this into waveedit
#if 0
    hr = CreateWaveEditObject(IID_IWaveAudio, (LPVOID *)&pWave);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateWaveEditObject failed.", hr);
        goto exit;
    }

    // Get pStmWave
    hr = pWave->QueryInterface(IID_IWaveStream, (LPVOID *)&pStmWave);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pWave->QueryInterface(IID_IWaveStream...) failed.", hr);
        goto exit;
    }

    // Open the stream
    hr = pStmWave->StreamOpen(pStmBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pStmWave->StreamOpen failed.", hr);
        goto exit;
    }

    pWave->GetNumSamples(&dw);

    // Play it
    hr = pWave->Play(WAVE_MAPPER, 0, dw);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pStmWave->Play failed.", hr);
        goto exit;
    }
#endif

    Sleep(8000);

exit:
    // Cleanup
    if (pMessage)
        pMessage->Release();
    if (pBody)
        pBody->Release();
    if (pStmBody)
        pStmBody->Release();
    if (pStmSave)
        pStmSave->Release();
    if (pWave)
        pWave->Release();
    if (pStmWave)
        pStmWave->Release();
    if (pStmText)
        pStmText->Release();
    if (pStmTxtOut)
        pStmTxtOut->Release();
    if (prghAttach)
        CoTaskMemFree(prghAttach);

    // Done
    return hr;
}
#endif

// --------------------------------------------------------------------------------
// MimeTestIsContentType
// --------------------------------------------------------------------------------
HRESULT MimeTestIsContentType(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IPersistFile            *pPersistFile=NULL;
    HBODY                   hBody;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestIsContentType", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        ReportError("MimeTestIsContentType", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile) failed.", hr);
        goto exit;
    }

    // Load
    hr = pPersistFile->Load(L"d:\\test\\vlad.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
    {
        ReportError("MimeTestIsContentType", __LINE__, "IPersistFile::Load failed.", hr);
        goto exit;
    }

    // Get the root body
    hr = pMessage->GetBody(IBL_ROOT, NULL, &hBody);

    // Test for content-Type
    hr = pMessage->IsContentType(hBody, "multipart", NULL);
    if (S_OK == hr)
        printf("The root body of the message is a multipart.");
    else if (S_FALSE == hr)
        printf("The root body of the message is NOT a multipart.");

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pPersistFile)
        pPersistFile->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestSplitMessageIntoParts - How to split a large message into smaller parts
// --------------------------------------------------------------------------------
HRESULT MimeTestSplitMessageIntoParts(void)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessageParts       *pParts=NULL;
    IMimeEnumMessageParts   *pEnumParts=NULL;
    IMimeMessage            *pMessage=NULL;
    IMimeMessage            *pMsgPart=NULL;
    IStream                 *pStream=NULL;
    IPersistFile            *pPersistFile=NULL;
    ULONG                   c;
    ULONG                   cFiles=0;
    ULONG                   i;
    LPWSTR                  *prgpszFile=NULL;
    PROPVARIANT             rVariant;

    // Init the variant
    ZeroMemory(&rVariant, sizeof(PROPVARIANT));

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Attach a large file
    hr = pMessage->AttachFile("c:\\winnt\\winnt256.bmp", NULL, NULL);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessage::AttachFile(...) failed.", hr);
        goto exit;
    }

    // Split the message into parts
    hr = pMessage->SplitMessage(65536, &pParts);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessage::SplitMessage(...) failed.", hr);
        goto exit;
    }

    // Get the number of parts
    hr = pParts->CountParts(&cFiles);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessageParts::EnumParts(...) failed.", hr);
        goto exit;
    }

    // Allocate an array
    prgpszFile = (LPWSTR *)CoTaskMemAlloc(sizeof(LPWSTR) * cFiles);
    if (NULL == prgpszFile)
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "CoTaskMemAlloc Failed.", hr);
        goto exit;
    }

    // Init
    ZeroMemory(prgpszFile, sizeof(LPWSTR) * cFiles);

    // Enumerate the parts
    hr = pParts->EnumParts(&pEnumParts);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessageParts::EnumParts(...) failed.", hr);
        goto exit;
    }

    // INit loop var
    i = 0;

    // Enumerate the parts
    while (SUCCEEDED(pEnumParts->Next(1, &pMsgPart, &c)) && 1 == c)
    {
        // Setup the variant
        rVariant.vt = VT_LPWSTR;

        // Get a filename, in unicode
        hr = pMsgPart->GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_ATT_GENFNAME), 0, &rVariant);
        if (FAILED(hr))
        {
            ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessage::GetBodyProp(HBODY_ROOT, PID_ATT_GENFNAME (Unicode), ...) failed.", hr);
            goto exit;
        }

        // QI for IPersistFile
        hr = pMsgPart->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
        if (FAILED(hr))
        {
            ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile, ...) failed.", hr);
            goto exit;
        }

        // Get the message source and dump to file...
        hr = pPersistFile->Save(rVariant.pwszVal, FALSE);
        if (FAILED(hr))
        {
            ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IPersistFile::Save(...) failed.", hr);
            goto exit;
        }

        // Save the filename
        prgpszFile[i++] = rVariant.pwszVal;
        rVariant.pwszVal = NULL;

        // Release the message
        pMsgPart->Release();
        pMsgPart = NULL;
        pPersistFile->Release();
        pPersistFile = NULL;
    }

    // Lets recombine those message parts
    MimeTestRecombineMessageParts(prgpszFile, cFiles);

exit:
    // Cleanup
    if (pStream)
        pStream->Release();
    if (pMessage)
        pMessage->Release();
    if (pParts)
        pParts->Release();
    if (pEnumParts)
        pEnumParts->Release();
    if (pMsgPart)
        pMsgPart->Release();
    if (pPersistFile)
        pPersistFile->Release();
    if (rVariant.pwszVal)
        CoTaskMemFree(rVariant.pwszVal);
    if (prgpszFile)
    {
        for (i=0; i<cFiles; i++)
            if (prgpszFile[i])
                CoTaskMemFree(prgpszFile[i]);
        CoTaskMemFree(prgpszFile);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestRecombineMessageParts
// --------------------------------------------------------------------------------
HRESULT MimeTestRecombineMessageParts(LPWSTR *prgpszFile, ULONG cFiles)
{
    // Locals
    HRESULT                     hr=S_OK;
    ULONG                       i=0;
    IMimeMessageParts           *pParts=NULL;
    IMimeMessage                *pMsgPart=NULL;
    IMimeMessage                *pMessage=NULL;
    IPersistFile                *pPersistFile=NULL;

    // Create a message object
    hr = CoCreateInstance(CLSID_IMimeMessageParts, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessageParts, (LPVOID *)&pParts);
    if (FAILED(hr))
    {
        ReportError("MimeTestRecombineMessageParts", __LINE__, "CoCreateInstance(CLSID_IMimeMessageParts, ...) failed.", hr);
        goto exit;
    }

    // Loop through the files
    for (i=0; i<cFiles; i++)
    {
        // Create a mime message object
        hr = CreateMimeMessage(&pMsgPart);
        if (FAILED(hr))
        {
            ReportError("MimeTestRecombineMessageParts", __LINE__, "CreateMimeMessage failed.", hr);
            goto exit;
        }

        // Get an IPersistFile
        hr = pMsgPart->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
        if (FAILED(hr))
        {
            ReportError("MimeTestRecombineMessageParts", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile, ...) failed.", hr);
            goto exit;
        }

        // Get the message source and dump to file...
        hr = pPersistFile->Load(prgpszFile[i], STGM_READ | STGM_SHARE_DENY_NONE);
        if (FAILED(hr))
        {
            ReportError("MimeTestRecombineMessageParts", __LINE__, "IPersistFile::Load(...) failed.", hr);
            goto exit;
        }

        // Add the message into the parts list
        hr = pParts->AddPart(pMsgPart);
        if (FAILED(hr))
        {
            ReportError("MimeTestRecombineMessageParts", __LINE__, "IMimeMessageParts::AddPart(...) failed.", hr);
            goto exit;
        }

        // Cleanup
        pMsgPart->Release();
        pMsgPart = NULL;
        pPersistFile->Release();
        pPersistFile = NULL;
    }

    // Combine all the parts into a new message
    hr = pParts->CombineParts(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestRecombineMessageParts", __LINE__, "IMimeMessageParts::CombineParts(...) failed.", hr);
        goto exit;
    }

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        ReportError("MimeTestRecombineMessageParts", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile, ...) failed.", hr);
        goto exit;
    }

    // Get the message source and dump to file...
    hr = pPersistFile->Save(L"combined.eml", FALSE);
    if (FAILED(hr))
    {
        ReportError("MimeTestRecombineMessageParts", __LINE__, "IPersistFile::Save(...) failed.", hr);
        goto exit;
    }

exit:
    // Cleanup
    if (pParts)
        pParts->Release();
    if (pMsgPart)
        pMsgPart->Release();
    if (pMessage)
        pMessage->Release();
    if (pPersistFile)
        pPersistFile->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestLookupCharsetHandle
// --------------------------------------------------------------------------------
HRESULT MimeTestLookupCharsetHandle(LPCSTR pszCharset, LPHCHARSET phCharset)
{
    // Locals
    HRESULT                 hr=S_OK;
    INETCSETINFO            rCharset;
    IMimeInternational      *pInternat=NULL;

    // Create a message object
    hr = CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER, IID_IMimeInternational, (LPVOID *)&pInternat);
    if (FAILED(hr))
    {
        ReportError("MimeTestLookupCharsetHandle", __LINE__, "CoCreateInstance(CLSID_IMimeInternational, ...) failed.", hr);
        goto exit;
    }

    // Look for character set
    hr = pInternat->FindCharset(pszCharset, phCharset);
    if (FAILED(hr))
    {
        ReportError("MimeTestLookupCharsetHandle", __LINE__, "IMimeInternational::FindCharset(...) failed.", hr);
        goto exit;
    }

    // Lets lookup some character set information
    hr = pInternat->GetCharsetInfo(*phCharset, &rCharset);
    if (FAILED(hr))
    {
        ReportError("MimeTestLookupCharsetHandle", __LINE__, "IMimeInternational::GetCharsetInfo(...) failed.", hr);
        goto exit;
    }

    // Print some stuff
    printf("Charset Name: %s, Windows Codepage: %d, Internet Codepage: %d\n", rCharset.szName, rCharset.cpiWindows, rCharset.cpiInternet);
    
exit:
    // Clenaup
    if (pInternat)
        pInternat->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestSettingContentLocation - How to set the Content-Location header
// --------------------------------------------------------------------------------
HRESULT MimeTestSettingContentLocation(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IStream                 *pStream=NULL;
    PROPVARIANT             rVariant;
    HCHARSET                hCharset;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Setup a variant, I can pass in unicode or ansi
    rVariant.vt = VT_LPWSTR;
    rVariant.pwszVal = L"http://www.microsoft.com";

    // Set the Content-Location of the message
    hr = pMessage->SetProp(PIDTOSTR(PID_HDR_CNTLOC), 0, &rVariant);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "IMimeMessage::SetProp(PIDTOSTR(PID_HDR_CNTLOC), 0, ...) failed.", hr);
        goto exit;
    }

    // Setup a variant, I can pass in unicode or ansi
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = "\"Ken Dacey\" <postmaster>";

    // Set the Content-Location of the message
    hr = pMessage->SetProp(PIDTOSTR(PID_HDR_FROM), 0, &rVariant);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "IMimeMessage::SetProp(PIDTOSTR(PID_HDR_FROM), 0, ...) failed.", hr);
        goto exit;
    }

    // I could also set the content-location like this:
    //
    // 1) pMessage->SetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_CNTLOC), 0, &rVariant);
    //
    // 2) pMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pProps);
    //    pProps->SetProp(PIDTOSTR(PID_HDR_CNTLOC), 0, &rVariant);

    // Lets save the message in UTF-7
#if 0
    hr = MimeTestLookupCharsetHandle("utf-8", &hCharset);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "MimeTestLookupCharsetHandle(\"utf-7\", ...) failed.", hr);
        goto exit;
    }

    // Set the charset onto the message
    hr = pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "IMimeMessage::SetCharset(\"utf-7\", CSET_APPLY_ALL) failed.", hr);
        goto exit;
    }
#endif

    // Save the mime message to a stream
    hr = SaveMimeMessage(pMessage, SAVE_RFC1521, &pStream);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "SaveMimeMessage(...) failed.", hr);
        goto exit;
    }

    // Dump the stream to the console, and then wait for input so that the user can view it...
    ReportStatus("\n");
    DumpStreamToConsole(pStream);

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pStream)
        pStream->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestSettingReplyTo - How to set the Reply-To header
// --------------------------------------------------------------------------------
HRESULT MimeTestSettingReplyTo(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IStream                 *pStream=NULL;
    PROPVARIANT             rVariant;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingReplyTo", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Setup a variant, I can pass in unicode or ansi
    rVariant.vt = VT_LPWSTR;
    rVariant.pwszVal = L"Steven Bailey <sbailey@microsoft.com>";

    // Set the Content-Location of the message
    hr = pMessage->SetProp(PIDTOSTR(PID_HDR_REPLYTO), 0, &rVariant);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingReplyTo", __LINE__, "IMimeMessage::SetProp(PIDTOSTR(PID_HDR_REPLYTO), 0, ...) failed.", hr);
        goto exit;
    }

    // Save the mime message to a stream
    hr = SaveMimeMessage(pMessage, SAVE_RFC1521, &pStream);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "SaveMimeMessage(...) failed.", hr);
        goto exit;
    }

    // Dump the stream to the console, and then wait for input so that the user can view it...
    ReportStatus("\n");
    DumpStreamToConsole(pStream);

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pStream)
        pStream->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestGetMultiValueAddressProp
// --------------------------------------------------------------------------------
HRESULT MimeTestGetMultiValueAddressProp(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    PROPVARIANT             rVariant;
    IMimeMessage            *pMessage=NULL;

    // Create a message with some addresses in it
    hr = MimeTestAppendRfc822(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestGetMultiValueAddressProp", __LINE__, "MimeTestAppendRfc822 failed.", hr);
        goto exit;
    }

    // Setup the Variant
    rVariant.vt = VT_LPSTR;

    // Get PID_HDR_TO
    hr = pMessage->GetProp(PIDTOSTR(PID_HDR_TO), 0, &rVariant);
    if (FAILED(hr))
    {
        ReportError("MimeTestGetMultiValueAddressProp", __LINE__, "IMimeMessage::GetProp(PIDTOSTR(PID_HDR_TO), ...) failed.", hr);
        goto exit;
    }

    // Printf It
    printf("PID_HDR_TO = %s\n", rVariant.pszVal);

    // Free it
    CoTaskMemFree(rVariant.pszVal);

exit:
    // Cleanup
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestAppendRfc822 - Test IMimeAddressTable::AppendRfc822
// --------------------------------------------------------------------------------
HRESULT MimeTestAppendRfc822(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IMimeAddressTable       *pAdrTable=NULL;
    IStream                 *pStream=NULL;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Get the address table for the message. The address table should only be used on the root body object.
    hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeAddressTable, (LPVOID *)&pAdrTable);
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "IMimeMessage::BindToObject(HBDOY_ROOT, IID_IMimeAddressTable, ...) failed.", hr);
        goto exit;
    }

    // Append an RFC 822 formatted addresses
    hr = pAdrTable->AppendRfc822(IAT_TO, IET_DECODED, "test1 <test1@andyj.dns.microsoft.com>");
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "IMimeAddressTable::AppendRfc822(...) failed.", hr);
        goto exit;
    }

    // Append an RFC 822 formatted addresses
    hr = pAdrTable->AppendRfc822(IAT_TO, IET_DECODED, "to2 <to2@andyj.dns.microsoft.com>");
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "IMimeAddressTable::AppendRfc822(...) failed.", hr);
        goto exit;
    }

    // Append an RFC 822 formatted addresses
    hr = pAdrTable->AppendRfc822(IAT_TO, IET_DECODED, "to3 <to3@andyj.dns.microsoft.com>");
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "IMimeAddressTable::AppendRfc822(...) failed.", hr);
        goto exit;
    }

    // Save the mime message to a stream
    hr = SaveMimeMessage(pMessage, SAVE_RFC1521, &pStream);
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "SaveMimeMessage(...) failed.", hr);
        goto exit;
    }

    // Dump the stream to the console, and then wait for input so that the user can view it...
    ReportStatus("\n");
    DumpStreamToConsole(pStream);

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pStream)
        pStream->Release();
    if (pAdrTable)
        pAdrTable->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CreateMimeMessage - Basic way of creating a COM object.
// --------------------------------------------------------------------------------
HRESULT CreateMimeMessage(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT hr;

    // Create a message object
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)ppMessage);
    if (FAILED(hr))
    {
        ReportError("CreateMimeMessage", __LINE__, "CoCreateInstance(CLSID_IMimeMessage, ...) failed.", hr);
        goto exit;
    }

    // You must always initnew the message object
    hr = (*ppMessage)->InitNew();
    if (FAILED(hr))
    {
        ReportError("CreateMimeMessage", __LINE__, "IMimeMessage::InitNew() failed.", hr);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Saves a MIME message
// --------------------------------------------------------------------------------
HRESULT SaveMimeMessage(IMimeMessage *pMessage, MIMESAVETYPE savetype, IStream **ppStream)
{
    // Locals
    HRESULT     hr;
    PROPVARIANT rOption;

    // Set the save format option into the message object. The OID_xxx types are defined
    // in mimeole.idl. Go to that file for more information.
    rOption.vt = VT_UI4;
    rOption.ulVal = savetype;
    hr = pMessage->SetOption(OID_SAVE_FORMAT, &rOption);
    if (FAILED(hr))
    {
        ReportError("SaveMimeMessage", __LINE__, "IMimeMessage::SetOption(OID_SAVE_FORMAT, ...) failed", hr);
        goto exit;
    }

    // Create a stream in which to save the message...
    hr = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
    if (FAILED(hr))
    {
        ReportError("SaveMimeMessage", __LINE__, "CreateStreamOnHGlobal failed", hr);
        goto exit;
    }

    // Call the save method on IMimeMessage. Mimeole will call commit on the stream object.
    // After this call, the stream will be positioned at the end.
    hr = pMessage->Save(*ppStream, TRUE);
    if (FAILED(hr))
    {
        ReportError("SaveMimeMessage", __LINE__, "IMimeMessage::Save(...) failed", hr);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// ReportError - Simple function to report an error that has an HRESULT
// --------------------------------------------------------------------------------
HRESULT ReportError(LPCSTR pszFunction, INT nLine, LPCSTR pszErrorText, HRESULT hrResult)
{
    printf("Error(HR = 0x%08X) in %s on line %d - %s\n", hrResult, pszFunction, nLine, pszErrorText);
    return hrResult;
}

// --------------------------------------------------------------------------------
// ReportStatus - Simple function to report a string to the user
// --------------------------------------------------------------------------------
HRESULT ReportStatus(LPCSTR pszStatusText)
{
    printf("Status: %s\n", pszStatusText);
    return S_OK;
}

// --------------------------------------------------------------------------------
// DumpStreamToConsole
// --------------------------------------------------------------------------------
HRESULT DumpStreamToConsole(IStream *pStream)
{
    // Locals
    HRESULT hr=S_OK;
    BYTE    rgbBuffer[2048];
    ULONG   cbRead;

    // This is an msoert function
    HrStreamSeekSet(pStream, 0);

    while(1)
    {
        // Read a block from the stream
        hr = pStream->Read(rgbBuffer, sizeof(rgbBuffer), &cbRead);
        if (FAILED(hr))
        {
            ReportError("DumpStreamToConsole", __LINE__, "DumpStreamToConsole - IStream::Read failed.", hr);
            break;
        }

        // If nothing read, then were done
        if (0 == cbRead)
            break;

        // Print it
        printf("%s", (LPSTR)rgbBuffer);
    }

    // Finaly LF
    printf("\n");

    // Done
    return hr;
}


/*
    DWORD i=1;
    DWORD dw;
    CHAR szDate[255];
    HROWSET hRowset;
    FOLDERINFO Folder;
    MESSAGEINFO Message;
    IMessageStore *pStore;
    IMessageFolder *pFolder;
    CoCreateInstance(CLSID_MessageStore, NULL, CLSCTX_INPROC_SERVER, IID_IMessageStore, (LPVOID *)&pStore);
    pStore->Initialize("d:\\storetest");
    pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, FOLDER_INBOX, &pFolder);
    pFolder->CreateRowset(IINDEX_SUBJECT, 0, &hRowset);
    while(S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        dw = FDTF_DEFAULT;
        SHFormatDateTimeA(&Message.ftReceived, &dw, szDate, 255);
        if (Message.pszNormalSubj)
            printf("%05d: %s, %s, %d\n", i, Message.pszNormalSubj, szDate, Message.idMessage);
        else
            printf("%05d: <Empty>, %s, %d\n", i, szDate, Message.idMessage);
        pFolder->FreeRecord(&Message);
        i++;
    }
    pFolder->CloseRowset(&hRowset);
    pFolder->Release();
    pStore->Release();
    exit(1);
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\dbgutil.cpp ===
/***********************************************************************
 *
 * DBGUTIL.CPP
 *
 * Debug utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#include <windows.h>
#include "dbgutil.h"

#define _DBGUTIL_CPP



/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];


    va_start(marker, lpszFmt);
    wvsprintf(String, lpszFmt, marker);
        OutputDebugString(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\encode.h ===
class SMimeEncode
{
public:
    SMimeEncode();
    ~SMimeEncode();

    HRESULT HrConfig(DWORD dwFlags,
                     LPTSTR lpszBody,
                     HCRYPTPROV hCryptProv,
                     HCERTSTORE hMYCertStore,
                     HCERTSTORE hCACertStore,
                     HCERTSTORE hABCertStore,
                     PCCERT_CONTEXT lpSigningCertInner,
                     PCCERT_CONTEXT lpSigningCertOuter,
                     PCCERT_CONTEXT lpEncryptionCert,
                     LPTSTR lpszSenderEmail,
                     LPTSTR lpszSenderName,
                     LPTSTR lpszRecipientEmail,
                     LPTSTR lpszRecipientName,
                     LPTSTR lpszOutputFile
    );
    HRESULT HrExecute(void);

protected:
    DWORD m_dwFlags;                    // signing and encryption options

    IStream * m_stmOutput;              // output stream

    LPTSTR m_szSignAlg;
    LPTSTR m_szEncryptAlg;

    LPTSTR  m_szBody;                   // Body string.
    LPTSTR  m_szSubject;                // Subject string.
    CERT_CONTEXT* m_SigningCertInner;
    CERT_CONTEXT* m_SigningCertOuter;
    CERT_CONTEXT* m_EncryptionCert;     // maybe should be multiple?
    HCRYPTPROV m_hCryptProv;
    HCERTSTORE m_hMYCertStore;
    HCERTSTORE m_hCACertStore;
    HCERTSTORE m_hABCertStore;
    LPTSTR m_szSenderEmail;
    LPTSTR m_szSenderName;
    LPTSTR m_szRecipientEmail;          // maybe should be multiple?
    LPTSTR m_szRecipientName;
    LPTSTR m_szOutputFile;
};

typedef class SMimeEncode SMimeEncode;


// Values for dwFlags
#define encode_Encrypt      0x1
#define encode_InnerSign    0x2
#define encode_OuterSign    0x4
#define encode_InnerClear   0x8
#define encode_InnerOpaque  0
#define encode_OuterClear   0x10
#define encode_OuterOpaque  0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\dbgutil.h ===
/***********************************************************************
 *
 * DBGUTIL.H
 *
 * Debug Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/
#ifdef __cplusplus
extern "C" {
#endif

VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\encode.cpp ===
#define INITGUID
#define DEFINE_STRCONST

#include <windows.h>
#include <ole2.h>

#include <initguid.h>
#include <mimeole.h>

#include "encode.h"

#define CORg(command)       \
    if (FAILED(command)) {  \
        goto Error;         \
    }

#define CPRg(command)       \
    if (! (command)) {      \
        goto Error;         \
    }


static LPWSTR s_rgwszValues[] = { NULL };

#define DEBUGFILE 1
#define MAX_LAYERS  3

//------------------------------------------------------------------
//------------------------------------------------------------------
HRESULT WriteBSTRToMultibyteToStream( const BSTR bstrStr, IStream** ppStream )
{
    HRESULT                 hr = S_OK;
    LARGE_INTEGER           liZero = {0};           // for ->Seek()

    char*   pszMessage = NULL;
    int     len = 0;

    if (!ppStream) return E_INVALIDARG;

    len = wcslen(bstrStr);
    CPRg(pszMessage = new char[len + 1]);
    WideCharToMultiByte(CP_ACP, 0, bstrStr, len,
                        pszMessage, len + 1,
                        NULL, NULL );
    pszMessage[len] = '\0';

    CORg(CreateStreamOnHGlobal(NULL, TRUE, ppStream));
    CORg((*ppStream)->Seek(liZero, STREAM_SEEK_SET, NULL));
    CORg((*ppStream)->Write(pszMessage,  len, NULL));
    CORg((*ppStream)->Seek(liZero, STREAM_SEEK_SET, NULL));
Error:
    if (pszMessage) delete[] pszMessage;
    return hr;
}

//------------------------------------------------------------------
SMimeEncode::SMimeEncode() :
    m_dwFlags(0),
    m_stmOutput(NULL),
    m_szSignAlg(NULL),
    m_szEncryptAlg(NULL),
    m_szBody(NULL),
    m_SigningCertInner(NULL),
    m_SigningCertOuter(NULL),
    m_EncryptionCert(NULL),
    m_hCryptProv(NULL),
    m_hMYCertStore(NULL),
    m_hCACertStore(NULL),
    m_hABCertStore(NULL),
    m_szSenderEmail(NULL),
    m_szSenderName(NULL),
    m_szRecipientEmail(NULL),
    m_szRecipientName(NULL),
    m_szOutputFile(NULL)
{

}

#define APPEND_SEPERATOR(subject) \
    if (lstrlen(subject)) {       \
        lstrcat(subject, " | ");  \
    }


//------------------------------------------------------------------
SMimeEncode::~SMimeEncode()
{
    // BUGBUG: Should clean up any allocated members
}

//------------------------------------------------------------------
HRESULT SMimeEncode::HrConfig(
    DWORD dwFlags,
    LPTSTR lpszBody,
    HCRYPTPROV hCryptProv,
    HCERTSTORE hMYCertStore,
    HCERTSTORE hCACertStore,
    HCERTSTORE hABCertStore,
    PCCERT_CONTEXT lpSigningCertInner,
    PCCERT_CONTEXT lpSigningCertOuter,
    PCCERT_CONTEXT lpEncryptionCert,
    LPTSTR lpszSenderEmail,
    LPTSTR lpszSenderName,
    LPTSTR lpszRecipientEmail,
    LPTSTR lpszRecipientName,
    LPTSTR lpszOutputFile
)
{
    HRESULT     hr = S_OK;
    static      char szSubject[257] = "";

    if (dwFlags & encode_Encrypt) {
        // specify an encryption algorithm
        // BUGBUG: Hardcoded in Encode
    }

    if (dwFlags & encode_InnerSign) {
        // specify a signing algorithm
        // BUGBUG: Hardcoded in Encode
    }


    if (dwFlags & encode_OuterSign) {
        // specify a signing algorithm
        // BUGBUG: Hardcoded in Encode
    }

    m_dwFlags = dwFlags;
    m_szBody = lpszBody;
    m_hCryptProv = hCryptProv;
    m_hMYCertStore = hMYCertStore;
    m_hCACertStore = hCACertStore;
    m_hABCertStore = hABCertStore;
    m_SigningCertInner = (PCERT_CONTEXT)lpSigningCertInner;
    m_SigningCertOuter = (PCERT_CONTEXT)lpSigningCertOuter;
    m_EncryptionCert = (PCERT_CONTEXT)lpEncryptionCert;
    m_szSenderEmail = lpszSenderEmail;
    m_szRecipientEmail = lpszRecipientEmail;
    m_szOutputFile = lpszOutputFile;

    // Set a meaningful subject
    lstrcpy(szSubject, "");
    if (dwFlags & encode_InnerSign) {
        APPEND_SEPERATOR(szSubject);
        if (dwFlags & encode_InnerClear) {
            lstrcat(szSubject, "Clear Sign");
        } else {
            lstrcat(szSubject, "Opaque Sign");
        }
    }
    if (dwFlags & encode_Encrypt) {
        APPEND_SEPERATOR(szSubject);
        lstrcat(szSubject, "Encrypt");
    }
    if (dwFlags & encode_OuterSign) {
        APPEND_SEPERATOR(szSubject);
        if (dwFlags & encode_OuterClear) {
            lstrcat(szSubject, "Clear Sign");
        } else {
            lstrcat(szSubject, "Opaque Sign");
        }
    }
    m_szSubject = szSubject;

    return(hr);
}

//------------------------------------------------------------------
HRESULT SMimeEncode::HrExecute(void) {
    // Using the SMIME engine:
    //
    // Build the message tree (attach the body)
    // CoCreateInstance( CLSID_IMimeSecurity )
    //  InitNew()
    // pSMIMEEngine->EncodeBody( IMimeMessageTree*,
    //              hRoot,
    //              SEF_??? | EBF_RECURSE ) OR ???
    //  HrEncodeOpaque( psi, pTree, hbody, pencoderoot, pstmOut )  ????
    //
    HRESULT                 hr = S_OK;
    LARGE_INTEGER           liZero = {0};               // for ->Seek()
    IStream*                pBuildStream = NULL;        // scratch stream
    IStream*                pResultStream = NULL;       // scratch stream
    IMimeMessage*           pMimeRoot = NULL;           // message in process
    IMimeBody*              pMimeRootBody = NULL;       // another version
    IMimeInternational*     pCharSet = NULL;
    HCHARSET                HCharset = 0;
    SYSTEMTIME              stNow;
    PROPVARIANT             var;
    HBODY                   hbBody;
    IMimeSecurity*          pMimeSecurity = NULL;
    ULONG                   dwSecurityType = MST_NONE;
    IPersistFile*           pIPFFileStore = NULL;
    HRESULT                 hrLocal = S_OK;
    WCHAR                   szwFileName[MAX_PATH + 1];
    CHAR                    szFrom[2 * (MAX_PATH + 1) + 1];

    // Multilayer stuff
    BOOL                    fTripleWrap = m_dwFlags & encode_OuterSign;
    ULONG                   ulSecurityLayers = 0;
    ULONG                   iEncryptLayer = (ULONG)-1;
    ULONG                   iInnerSignLayer = (ULONG)-1;
    ULONG                   iOuterSignLayer = (ULONG)-1;
    // Arrays of option values to set
    DWORD                   rgdwSecurityType[MAX_LAYERS] = {0};
    PCCERT_CONTEXT          rgdwCertSigning[MAX_LAYERS] = {0};
    HCERTSTORE              rgdwhCertStore[MAX_LAYERS] = {0};       // optional
    DWORD                   rgdwUserValidity[MAX_LAYERS] = {0};     // decode only
    DWORD                   rgdwROMsgValidity[MAX_LAYERS] = {0};    // decode only
    FILETIME                rgftSigntime[MAX_LAYERS] = {0};         // optional
    PROPVARIANT             rgpvAlgHash[MAX_LAYERS] = {0};
    PROPVARIANT             rgpvSymcaps[MAX_LAYERS] = {0};
    PROPVARIANT             rgpvAuthattr[MAX_LAYERS] = {0};         // optional
    PROPVARIANT             rgpvUnauthattr[MAX_LAYERS] = {0};       // optional


    // This is the ALOGORITHM ID for SHA1, default supported signing alg
    const BYTE c_SHA1_ALGORITHM_ID[] =
      {0x30, 0x09, 0x30, 0x07, 0x06, 0x05, 0x2B, 0x0E,
       0x03, 0x02, 0x1A};

    // This is the ALOGORITHM ID for RC2 -- 40 bit, the default encrypt
    const BYTE c_RC2_40_ALGORITHM_ID[] =
      {0x30, 0x0F, 0x30, 0x0D, 0x06, 0x08, 0x2A, 0x86,
       0x48, 0x86, 0xF7, 0x0D, 0x03, 0x02, 0x02, 0x01,
       0x28};


    // get the signing cert from my store
    if (! m_hCryptProv || ! m_hMYCertStore || ! m_hCACertStore || ! m_hABCertStore) {
        hr = E_FAIL;
        goto Error;
    }


    // Create the Message object
    //
    CORg(CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER,
      IID_IMimeMessage, (LPVOID*)&pMimeRoot));

    CORg(pMimeRoot->InitNew());


    CORg(CreateStreamOnHGlobal( NULL, TRUE, &pBuildStream));
    CORg(pBuildStream->Seek(liZero, STREAM_SEEK_SET, NULL));
    CORg(pBuildStream->Write(m_szBody, lstrlen(m_szBody), NULL));
    CORg(pBuildStream->Seek(liZero, STREAM_SEEK_SET, NULL));

    CORg(pMimeRoot->SetTextBody(TXT_PLAIN, IET_8BIT, NULL, pBuildStream, &hbBody));

    // Create the formatted From address
    if (m_szSenderName) {
        lstrcpy(szFrom, "\"");
        lstrcat(szFrom, m_szSenderName);
        lstrcat(szFrom, "\" ");
    } else {
        lstrcpy(szFrom, "");
    }
    lstrcat(szFrom, "<");
    lstrcat(szFrom, m_szSenderEmail);
    lstrcat(szFrom, ">");

    var.vt = VT_LPSTR;
    var.pszVal = szFrom;                            // From Email

    CORg(hr = pMimeRoot->SetProp(PIDTOSTR(PID_HDR_FROM), 0, &var));


    var.vt = VT_LPSTR;                              // ignored?
    var.pszVal = (LPSTR) STR_MIME_TEXT_PLAIN;
    CORg(pMimeRoot->SetBodyProp(hbBody, STR_HDR_CNTTYPE, 0, &var));

    var.vt = VT_LPSTR;                              // ignored?
    var.pszVal = (LPSTR) STR_ENC_QP;
    CORg(pMimeRoot->SetBodyProp(hbBody, STR_HDR_CNTXFER, 0, &var));

    // Set subject
    var.vt = VT_LPSTR;
    var.pszVal = (LPSTR) m_szSubject;
    CORg(pMimeRoot->SetBodyProp(hbBody, STR_HDR_SUBJECT, 0, &var));

    CORg(pMimeRoot->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID*)&pMimeRootBody));


    //
    // Set the security options
    //

    // How many layers?
    if (m_dwFlags & encode_InnerSign) {
        iInnerSignLayer = ulSecurityLayers;
        ulSecurityLayers++;
    }
    if (m_dwFlags & encode_Encrypt) {
        iEncryptLayer = ulSecurityLayers;  // index in arrays
        ulSecurityLayers++;
    }
    if (m_dwFlags & encode_OuterSign) {
        iOuterSignLayer = ulSecurityLayers;
        ulSecurityLayers++;
    }


    // Set up for Inner Signing
    if (m_dwFlags & encode_InnerSign) {
        // specifiy the Security Type for this layer
        rgdwSecurityType[iInnerSignLayer] = m_dwFlags & encode_InnerClear ? MST_THIS_SIGN : MST_THIS_BLOBSIGN;
        dwSecurityType |= m_dwFlags & encode_InnerClear ? MST_THIS_SIGN : MST_THIS_BLOBSIGN;

        // Specify the Signing Time for this layer
        GetSystemTime(&stNow);
        SystemTimeToFileTime(&stNow, &rgftSigntime[iInnerSignLayer]);

        // specify the signature alg for this layer
        rgpvAlgHash[iInnerSignLayer].vt = VT_BLOB;
        rgpvAlgHash[iInnerSignLayer].blob.cbSize = sizeof(c_SHA1_ALGORITHM_ID);
        rgpvAlgHash[iInnerSignLayer].blob.pBlobData = (BYTE*)c_SHA1_ALGORITHM_ID;

        // Specify the signing cert for this layer
        rgdwCertSigning[iInnerSignLayer] = m_SigningCertInner;

        // HCERTSTORE              rgdwhCertStore[MAX_LAYERS] = {0};       // optional
        // PROPVARIANT             rgpvSymcaps[MAX_LAYERS] = {0};
        // PROPVARIANT             rgpvAuthattr[MAX_LAYERS] = {0};         // optional
        // PROPVARIANT             rgpvUnauthattr[MAX_LAYERS] = {0};       // optional
    }

    // Set up for Outer Signing
    if (m_dwFlags & encode_OuterSign) {
        // specifiy the Security Type for this layer
        rgdwSecurityType[iOuterSignLayer] = m_dwFlags & encode_InnerClear ? MST_THIS_SIGN : MST_THIS_BLOBSIGN;
        dwSecurityType |= m_dwFlags & encode_OuterClear ? MST_THIS_SIGN : MST_THIS_BLOBSIGN;

        // Specify the Signing Time for this layer
        GetSystemTime(&stNow);
        SystemTimeToFileTime(&stNow, &rgftSigntime[iOuterSignLayer]);

        // specify the signature alg for this layer
        rgpvAlgHash[iOuterSignLayer].vt = VT_BLOB;
        rgpvAlgHash[iOuterSignLayer].blob.cbSize = sizeof(c_SHA1_ALGORITHM_ID);
        rgpvAlgHash[iOuterSignLayer].blob.pBlobData = (BYTE*)c_SHA1_ALGORITHM_ID;

        // Specify the signing cert for this layer
        rgdwCertSigning[iOuterSignLayer] = m_SigningCertOuter;

        // HCERTSTORE              rgdwhCertStore[MAX_LAYERS] = {0};       // optional
        // PROPVARIANT             rgpvSymcaps[MAX_LAYERS] = {0};
        // PROPVARIANT             rgpvAuthattr[MAX_LAYERS] = {0};         // optional
        // PROPVARIANT             rgpvUnauthattr[MAX_LAYERS] = {0};       // optional
    }

    // Set up for Encrypting
    if (m_dwFlags & encode_Encrypt) {
        HCERTSTORE aCertStores[3];

        //
        // BUGBUG: Hardcoded to RC2 40-bit
        var.vt = VT_BLOB;
        var.blob.cbSize = sizeof( c_RC2_40_ALGORITHM_ID );
        var.blob.pBlobData = (BYTE*) c_RC2_40_ALGORITHM_ID;
        CORg(hr = pMimeRootBody->SetOption(OID_SECURITY_ALG_BULK, &var));

        // for encryption, get to the right cert store....
        //
        var.caul.cElems = 3;
        aCertStores[0] = CertDuplicateStore(m_hCACertStore);
        aCertStores[1] = CertDuplicateStore(m_hMYCertStore);
        aCertStores[2] = CertDuplicateStore(m_hABCertStore);
        var.caul.pElems = (ULONG*)aCertStores;
        CORg(hr = pMimeRootBody->SetOption(OID_SECURITY_SEARCHSTORES, &var));

        var.vt = VT_VECTOR | VT_UI4;
        var.caul.cElems = 1;
        var.caul.pElems = (ULONG*)&m_EncryptionCert;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_RG_CERT_ENCRYPT, &var));

#ifdef BUGBUG // This isn't right, is it?
        // include the cert...
        var.vt = VT_VECTOR | VT_UI4;
        var.caul.cElems = 1;
        var.caul.pElems = (ULONG*)&m_EncryptionCert;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_RG_CERT_BAG, &var));
#endif // OLD_STUFF

        dwSecurityType |= MST_THIS_ENCRYPT;
        rgdwSecurityType[iEncryptLayer] = MST_THIS_ENCRYPT;
    }

    // Set the OID_SECURITY_TYPE
    if (fTripleWrap) {
        var.vt = VT_VECTOR | VT_UI4;
        var.caul.cElems = ulSecurityLayers;
        var.caul.pElems = rgdwSecurityType;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_TYPE_RG, &var));

        var.vt = VT_VECTOR | VT_FILETIME;
        var.cafiletime.cElems = ulSecurityLayers;
        var.cafiletime.pElems = rgftSigntime;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_SIGNTIME_RG, &var));

        var.vt = VT_VECTOR | VT_UI4;
        var.caul.cElems = ulSecurityLayers;
        var.caul.pElems = (DWORD *)rgdwCertSigning;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_CERT_SIGNING_RG, &var));

        var.vt = VT_VECTOR | VT_VARIANT;
        var.capropvar.cElems = ulSecurityLayers;
        var.capropvar.pElems = rgpvAlgHash;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_ALG_HASH_RG, &var));

        var.vt = VT_VECTOR | VT_VARIANT;
        var.capropvar.cElems = ulSecurityLayers;
        var.capropvar.pElems = rgpvAlgHash;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_ALG_HASH_RG, &var));

    } else {
        // Security Type
        var.vt = VT_UI4;
        var.ulVal = dwSecurityType;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_TYPE, &var));

        if (dwSecurityType & MST_SIGN_MASK) {
            // Signing Time
            var.vt = VT_FILETIME;
            memcpy(&var.filetime, &rgftSigntime[iInnerSignLayer], sizeof(FILETIME));
            CORg(pMimeRootBody->SetOption(OID_SECURITY_SIGNTIME, &var));

            // Hash Algorithm
            var.vt = VT_BLOB;
            memcpy(&var.blob, &rgpvAlgHash[iInnerSignLayer].blob, sizeof(BLOB));
            CORg(hr = pMimeRootBody->SetOption(OID_SECURITY_ALG_HASH, &var));

            // Signing Cert
            var.vt = VT_UI4;
            var.ulVal = (ULONG)m_SigningCertInner;
            CORg(pMimeRootBody->SetOption(OID_SECURITY_CERT_SIGNING, &var));
        }
    }


    // Set the HWND for CAPI calls
    var.vt = VT_UI4;
    var.ulVal = 0;
    CORg(pMimeRootBody->SetOption(OID_SECURITY_HWND_OWNER, &var));


    // all built, get rid of the shadow pointer we are holding
    //
    pMimeRootBody->Release();
    pMimeRootBody = NULL;

    pMimeRoot->Commit(0);

    // SMIME Engine
    //
    CORg(CoCreateInstance(CLSID_IMimeSecurity, NULL, CLSCTX_INPROC_SERVER,
      IID_IMimeSecurity, (LPVOID*) &pMimeSecurity));

    CORg(pMimeSecurity->InitNew());

    // ERRORMESSAGE( Unable to encrypt/encode string )
    CORg(pMimeSecurity->EncodeBody(pMimeRoot, HBODY_ROOT,
      EBF_RECURSE | SEF_SENDERSCERTPROVIDED | SEF_ENCRYPTWITHNOSENDERCERT |
      EBF_COMMITIFDIRTY));

    // Get an Hcharset to force the encoding correctly
    //
    CORg(CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER,
      IID_IMimeInternational, (LPVOID*)&pCharSet));

    CORg(pCharSet->FindCharset("UTF-8", &HCharset));

    CORg(pMimeRoot->SetCharset(HCharset,    // HCharset
      CSET_APPLY_ALL));                     // Applytype


    // dump it to a file
    //
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, m_szOutputFile, -1, szwFileName, MAX_PATH);
    CORg(pMimeRoot->QueryInterface(IID_IPersistFile, (LPVOID*)&pIPFFileStore));
    CORg(pIPFFileStore->Save(szwFileName, FALSE));


    // extract the whole message into a stream
    //
    CORg(CreateStreamOnHGlobal(NULL, TRUE, &pResultStream));
    CORg(pMimeRoot->Save(pResultStream, FALSE));

Error:
    if (pBuildStream)   pBuildStream->Release();
    if (pResultStream)  pResultStream->Release();
    if (pMimeRoot)      pMimeRoot->Release();
    if (pMimeRootBody)  pMimeRootBody->Release();
    if (pCharSet)       pCharSet->Release();
    if (pMimeSecurity)  pMimeSecurity->Release();
    if (pIPFFileStore)  pIPFFileStore->Release();

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\instring.h ===
#define IDD_INPUT_STRING 2001
#define IDD_INPUT_STRING_PROMPT 2002

ULONG InputString(HINSTANCE hInstance, HWND hwnd, const LPTSTR lpszTitle,
  const LPTSTR lpszPrompt, LPTSTR lpBuffer, ULONG cchBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\encrypt.cpp ===
#include "item.h"
extern HINSTANCE        hInst;

const BYTE          RgbRC2_40[] = {
    0x30, 0x0f, 0x30, 0x0d, 0x06, 0x08, 0x2a, 0x86, 
    0x48, 0x86, 0xf7, 0x0d, 0x03, 0x02, 0x02, 0x01,
    0x28
};
const int CbRC2_40 = sizeof(RgbRC2_40);

const BYTE      RgbRC2_128[] = {
    0x30, 0x10, 
      0x30, 0xe, 
        0x6, 0x8, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x3, 0x2,
        0x2, 0x2, 0x0, 0x80
};

const BYTE      Rgb3DES[] = {
    0x30, 0xc, 
      0x30, 0xa,
        0x6, 0x8, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x3, 0x7
};

const BYTE      RgbRC6[] = {
    0x30, 0xc,
      0x30, 0xa,
        0x6, 0x8, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x3, 0x7f
};

const BYTE      RgbSkipjack[] = {
    0x30, 0xd,
      0x30, 0xb,
        0x6, 0x9, 0x60, 0x86, 0x48, 0x01, 0x65, 0x02, 0x01, 0x01, 0x04
};

struct {
    LPSTR               szDesc;
    const BYTE *        rgbAlg;
    DWORD               cbAlg;
} RgEncAlgs[] = {
    {"RC-2 40-bit", RgbRC2_40, sizeof(RgbRC2_40)},
    {"RC-2 64-bit", NULL, 0},
    {"RC-2 128-bit", RgbRC2_128, sizeof(RgbRC2_128)},
    {"DES", NULL, 0},
    {"Triple DES", Rgb3DES, sizeof(Rgb3DES)},
    {"RC-6", RgbRC6, sizeof(RgbRC6)},
    {"Skipjack", RgbSkipjack, sizeof(RgbSkipjack)},
#define ALG_SKIPJACK 6
};
const int Enc_Alg_Max = sizeof(RgEncAlgs)/sizeof(RgEncAlgs[0]);


////////////////////////////////////////////////////////////////////////////////////

HRESULT CEnvData::AddToMessage(DWORD * pulLayers, IMimeMessage * pmm, HWND hwnd)
{
    CRYPT_ATTRIBUTE             attr;
    DWORD                       cb;
    DWORD                       dwType = 0;
    FILETIME                    ft;
    HRESULT                     hr;
    IMimeBody *                 pmb = NULL;
    IMimeSecurity2 *            pms2 = NULL;
    CItem *                     psd;
    BYTE                        rgb[50];
    CRYPT_ATTR_BLOB             valTime;
    PROPVARIANT                 var;
    
    //  Pull out the body interface to set security properties
    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))             goto exit;

    //  Find out what security already exists
    hr = pmb->GetOption(OID_SECURITY_TYPE, &var);
    if (FAILED(hr))         goto exit;
    dwType = var.ulVal;

    //  if any security, then we need to push on a new layer, all previous security
    //  is now on the "y-security" layer and not on the hbody layer
    
    if (dwType & MST_THIS_ENCRYPT) {
        hr = pmm->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
        if (FAILED(hr))             goto exit;

        hr = pms2->Encode(hwnd, SEF_SENDERSCERTPROVIDED |
                          SEF_ENCRYPTWITHNOSENDERCERT);
        if (FAILED(hr))             goto exit;

        pms2->Release();            pms2 = NULL;
        pmb->Release();             pmb = NULL;
        dwType = 0;

        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;
    }

    //  We are going to put encryption on this layer
    dwType |= MST_THIS_ENCRYPT;
    
    //  Security Type
    var.vt = VT_UI4;
    var.ulVal = dwType;
    hr = pmb->SetOption(OID_SECURITY_TYPE, &var);
    if (FAILED(hr))         goto exit;

    var.vt = VT_BLOB;
    var.blob.cbSize = RgEncAlgs[m_iAlg].cbAlg;
    var.blob.pBlobData = (LPBYTE) RgEncAlgs[m_iAlg].rgbAlg;
    hr = pmb->SetOption(OID_SECURITY_ALG_BULK, &var);
    if (FAILED(hr))     goto exit;

    var.vt = VT_UI4;
    var.ulVal = SEF_SENDERSCERTPROVIDED;
    hr = pmm->SetOption(OID_SECURITY_ENCODE_FLAGS, &var);
    if (FAILED(hr))     goto exit;

    for (psd = Head(); psd != NULL; psd = psd->Next()) {
        hr = psd->AddToMessage(pulLayers, pmm, hwnd);
        if (FAILED(hr))         goto exit;
    }

    if (m_fAttributes  || m_fUnProtAttrib){
        hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
        if (FAILED(hr))             goto exit;
    }

    if (m_fAttributes) {
        GetSystemTimeAsFileTime(&ft);
        cb = sizeof(rgb);
        if (CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                &ft, 0, 0, rgb, &cb)) {
            attr.pszObjId = szOID_RSA_signingTime;
            attr.cValue = 1;
            attr.rgValue = &valTime;
            valTime.pbData = rgb;
            valTime.cbData = cb;

            hr = pms2->SetAttribute(0, 0, SMIME_ATTRIBUTE_SET_UNPROTECTED, &attr);
            if (FAILED(hr))             goto exit;
        }
    }
    
    if (m_fUnProtAttrib  && (m_szUnProtAttribOID != NULL) && (m_valUnProtAttrib.pbData != NULL)) {
        attr.pszObjId = m_szUnProtAttribOID;
        attr.cValue = 1;
        attr.rgValue = &m_valUnProtAttrib;

        hr = pms2->SetAttribute(0, 0, SMIME_ATTRIBUTE_SET_UNPROTECTED, &attr);
        if (FAILED(hr))             goto exit;
    }

    hr = S_OK;
exit:
    if (pms2 != NULL)           pms2->Release();
    if (pmb != NULL)            pmb->Release();
    *pulLayers += 1;
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CEnvCertTrans::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm,
                                    HWND hwnd)
{
    DWORD               cb;
    HRESULT             hr;
    DWORD               i;
    CRYPT_DATA_BLOB *   pblob;
    PCERT_EXTENSION     pext;
    IMimeBody *         pmb = NULL;
    CMS_RECIPIENT_INFO * precipInfo = NULL;
    IMimeSecurity2 *    psm = NULL;

    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))     goto exit;

    hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID*) &psm);
    if (FAILED(hr))     goto exit;

    precipInfo = (CMS_RECIPIENT_INFO *) malloc(sizeof(*precipInfo)*m_cCerts);
    if (precipInfo == NULL) goto exit;

    memset(precipInfo, 0, sizeof(*precipInfo)*m_cCerts);

    for (i=0; i<m_cCerts; i++) {
        precipInfo[i].dwRecipientType = CMS_RECIPIENT_INFO_TYPE_UNKNOWN;
        precipInfo[i].pccert = m_rgpccert[i];

        if (m_fUseSKI) {
            pext = CertFindExtension(szOID_SUBJECT_KEY_IDENTIFIER,
                                     m_rgpccert[i]->pCertInfo->cExtension,
                                     m_rgpccert[i]->pCertInfo->rgExtension);
            if (pext == NULL) {
                continue;
            }

            if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                     szOID_SUBJECT_KEY_IDENTIFIER,
                                     pext->Value.pbData, pext->Value.cbData,
                                     CRYPT_DECODE_ALLOC_FLAG,
                                     NULL, &pblob, &cb)) {
                continue;
            }
            
            precipInfo[i].dwU3 = CMS_RECIPIENT_INFO_KEYID_KEY_ID;
            precipInfo[i].u3.KeyId.pbData = (LPBYTE) malloc(pblob->cbData);
            memcpy(precipInfo[i].u3.KeyId.pbData, pblob->pbData, pblob->cbData);
            precipInfo[i].u3.KeyId.cbData = pblob->cbData;
            LocalFree(pblob);
        }
    }

    hr = psm->AddRecipient(0, m_cCerts, precipInfo);
    if (FAILED(hr)) goto exit;

    for (i=0; i<m_cCerts; i++) {
        if (precipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) {
            free(precipInfo[i].u3.KeyId.pbData);
        }
    }

    hr = S_OK;
exit:
    if (psm != NULL)    psm->Release();
    if (pmb != NULL)    pmb->Release();
    if (precipInfo != NULL)     free(precipInfo);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CEnvCertAgree::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm,
                                    HWND hwnd)
{
    DWORD               cCerts;
    HCRYPTPROV          hprov = NULL;
    HRESULT             hr;
    DWORD               i;
    IMimeBody *         pmb = NULL;
    CMS_RECIPIENT_INFO * precipInfo = NULL;
    IMimeSecurity2 *    psm = NULL;
    PROPVARIANT         var;

    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))     goto exit;

    hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID*) &psm);
    if (FAILED(hr))     goto exit;

    precipInfo = (CMS_RECIPIENT_INFO *) malloc(sizeof(*precipInfo)*m_cCerts);
    if (precipInfo == NULL) goto exit;

    memset(precipInfo, 0, sizeof(*precipInfo)*m_cCerts);

    if (m_cCerts == 0) {
        hr = E_FAIL;
        goto exit;
    }
    
    if (strcmp(m_rgpccert[0]->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
               szOID_INFOSEC_keyExchangeAlgorithm) == 0) {
        DWORD           cb;
        PCRYPT_KEY_PROV_INFO    pInfo;
        //
        //  Get the parameters from the key

        if (!CertGetCertificateContextProperty(m_rgpccert[0],
                                               CERT_KEY_PROV_INFO_PROP_ID,
                                               NULL, &cb)) {
            hr = E_FAIL;
            goto exit;
        }

        pInfo = (PCRYPT_KEY_PROV_INFO) malloc(cb);

        if (!CertGetCertificateContextProperty(m_rgpccert[0],
                                               CERT_KEY_PROV_INFO_PROP_ID,
                                               pInfo, &cb)) {
            hr = E_FAIL;
            goto exit;
        }

        
        //  Setup originator info
        if (!CryptAcquireContextW(&hprov, pInfo->pwszContainerName,
                                  pInfo->pwszProvName, pInfo->dwProvType, 0)) {
            hr = E_FAIL;
            goto exit;
        }

        var.vt = VT_UI4;
        var.ulVal = (DWORD) hprov;
        hr = pmb->SetOption(OID_SECURITY_HCRYPTPROV, &var);
        if (FAILED(hr))         goto exit;

        for (i=1; i<m_cCerts; i++) {
            precipInfo[i-1].dwRecipientType = CMS_RECIPIENT_INFO_TYPE_KEYAGREE;
            precipInfo[i-1].pccert = m_rgpccert[i];

            precipInfo[i-1].KeyEncryptionAlgorithm.pszObjId =
                szOID_INFOSEC_keyExchangeAlgorithm;
            
            precipInfo[i-1].dwU1 = CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE;
            precipInfo[i-1].u1.u4.hprov = hprov;
            precipInfo[i-1].u1.u4.dwKeySpec = AT_KEYEXCHANGE;
            precipInfo[i-1].u1.u4.senderCertId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            precipInfo[i-1].u1.u4.senderCertId.IssuerSerialNumber.Issuer = m_rgpccert[0]->pCertInfo->Issuer;
            precipInfo[i-1].u1.u4.senderCertId.IssuerSerialNumber.SerialNumber = m_rgpccert[0]->pCertInfo->SerialNumber;
            precipInfo[i-1].u1.u4.SubjectPublicKey = m_rgpccert[i]->pCertInfo->SubjectPublicKeyInfo.PublicKey;

            precipInfo[i-1].dwU3 = CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL;
            precipInfo[i-1].u3.IssuerSerial.Issuer = m_rgpccert[i]->pCertInfo->Issuer;
            precipInfo[i-1].u3.IssuerSerial.SerialNumber = m_rgpccert[i]->pCertInfo->SerialNumber;
        }
        hprov = NULL;
        cCerts = m_cCerts - 1;
    }
    else {
        for (i=0; i<m_cCerts; i++) {
            precipInfo[i].dwRecipientType = CMS_RECIPIENT_INFO_TYPE_UNKNOWN;
            precipInfo[i].pccert = m_rgpccert[i];
        }
        cCerts = m_cCerts;
    }

    hr = psm->AddRecipient(0, cCerts, precipInfo);
    if (FAILED(hr)) goto exit;

    hr = S_OK;
exit:
    if (hprov != NULL)          CryptReleaseContext(hprov, 0);
    if (psm != NULL)    psm->Release();
    if (pmb != NULL)    pmb->Release();
    if (precipInfo != NULL)     free(precipInfo);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EncDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       i;
    DWORD                       iSel;
    static CEnvData *           ped = NULL;
    CHAR                        rgch[300];
    
    switch (msg) {
    case WM_INITDIALOG:
        for (i=0; i<sizeof(RgEncAlgs)/sizeof(RgEncAlgs[0]); i++) {
            if (RgEncAlgs[i].rgbAlg != NULL) {
                iSel = SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_ADDSTRING,
                                          0, (LPARAM) RgEncAlgs[i].szDesc);
                SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_SETITEMDATA,
                                   iSel, i);
            }
        }
        SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_SETCURSEL, 0, 0);
        SendDlgItemMessage(hdlg, IDC_EIC_FORCE, BM_SETCHECK, 1, 0);
        break;

    case UM_SET_DATA:
        ped = (CEnvData *) lParam;
        //  Fill in the dialog

        if (ped != NULL) {
            SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_SETCURSEL,
                               ped->GetAlg(), 0);
        }
        SendDlgItemMessage(hdlg, IDC_EIC_ATTRIBUTES, BM_SETCHECK,
                           ((ped != NULL) && (ped->m_fAttributes)), 0);
        SendDlgItemMessage(hdlg, IDC_EIC_UNPROTATTRIB, BM_SETCHECK,
                           ((ped != NULL) && (ped->m_fUnProtAttrib)), 0);

        break;

    case WM_COMMAND:
        switch (wParam) {
        case MAKELONG(IDC_EIC_ALG_SELECT, CBN_SELCHANGE):
            i = SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_GETCURSEL, 0, 0);
            ped->SetAlg(SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT,
                                           CB_GETITEMDATA, i, 0));
            break;

        case MAKELONG(IDC_EIC_ATTRIBUTES, BN_CLICKED):
            ped->m_fAttributes = SendDlgItemMessage(hdlg, IDC_EIC_ATTRIBUTES,
                                                    BM_GETCHECK, 0, 0);
            break;
            
        case MAKELONG(IDC_EIC_UNPROTATTRIB, BN_CLICKED):
            ped->m_fUnProtAttrib = SendDlgItemMessage(hdlg, IDC_EIC_UNPROTATTRIB, BM_GETCHECK,
                                                   0, 0);
            break;
            
        case IDC_EIC_DO_UNPROTATTRIB:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ATTRIB_CREATE), hdlg,
                           UnProtAttribCreateDlgProc, (LPARAM) ped);
            break;

        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK EncDataComposeDlgProc(CEncItem ** ppei, HWND hdlg, UINT msg,
                                    WPARAM wParam, LPARAM lParam, int iFilter)
{
    DWORD                       i;
    DWORD                       i1;
    PCCERT_CONTEXT              pccert;
    char                        rgch[256];
    
    switch (msg) {
    case WM_INITDIALOG:
        break;

    case UM_SET_DATA:
        //  Back load from dialog
        if (*ppei != NULL) {
            if ((*ppei)->m_rgpccert != NULL) {
                for (i=0; i<(*ppei)->m_cCerts; i++) {
                    CertFreeCertificateContext((*ppei)->m_rgpccert[i]);
                }
                free((*ppei)->m_rgpccert);
                (*ppei)->m_rgpccert = 0;
                (*ppei)->m_cCerts = 0;
            }

            i1 = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETCOUNT, 0, 0);
            (*ppei)->m_rgpccert = (PCCERT_CONTEXT *) malloc(sizeof(PCCERT_CONTEXT)*i1);
            for (i=0; i<i1; i++) {
                (*ppei)->m_rgpccert[i] = (PCCERT_CONTEXT) 
                    SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETITEMDATA, i, 0);
            }
            (*ppei)->m_cCerts = i1;
            SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_RESETCONTENT, 0, 0);
        }

        Assert(SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETCOUNT, 0, 0) == 0);
        
        *ppei = (CEncItem *) lParam;
        //  Fill in the dialog

        if (*ppei != NULL) {
            for (i=0; i<(*ppei)->m_cCerts; i++) {
                GetFriendlyNameOfCertA((*ppei)->m_rgpccert[i], rgch, sizeof(rgch));
                i1 = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_ADDSTRING, 0, (LPARAM) rgch);
                SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_SETITEMDATA, i1,
                         (LPARAM) CertDuplicateCertificateContext((*ppei)->m_rgpccert[i]));
            }
        }
        
        SendDlgItemMessage(hdlg, IDC_ETC_LIST, BM_SETCHECK,
                           (((*ppei) != NULL) && ((*ppei)->m_fUseSKI)), 0);
        break;

    case WM_DESTROY:
        i1 = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETCOUNT, 0, 0);
        for (i=0; i<i1; i++) {
            CertFreeCertificateContext((PCCERT_CONTEXT) 
                  SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETITEMDATA, i, 0));
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_ETC_ADD_CERT:
            pccert = NULL;
            if (DoCertDialog(hdlg, "Choose Enryption Certificate To Add",
                             (*ppei)->GetAllStore(), &pccert, iFilter)) {
                GetFriendlyNameOfCertA(pccert, rgch, sizeof(rgch));
                i1 = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_ADDSTRING, 0, (LPARAM) rgch);
                SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_SETITEMDATA, i1,
                         (LPARAM) pccert);
            }
            break;
            
        case IDC_ETC_DEL_CERT:
            i = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETCURSEL, 0, 0);
            if (i != LB_ERR) {
                CertFreeCertificateContext((PCCERT_CONTEXT)
                  SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETITEMDATA, i, 0));
            }
            break;
        
        case MAKELONG(IDC_ETC_SKI, BN_CLICKED):
            (*ppei)->m_fUseSKI = SendDlgItemMessage(hdlg, IDC_ETC_SKI, BM_GETCHECK,
                                                    0, 0);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CALLBACK EncTransCompDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static CEncItem *           pei = NULL;

    return EncDataComposeDlgProc(&pei, hdlg, msg, wParam, lParam, FILTER_RSA_KEYEX);
}
 
BOOL CALLBACK EncAgreeCompDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       dwFilter = FILTER_DH_KEYEX;
    static CEncItem *           pei = NULL;

    if (pei != NULL) {
        if (pei->GetParent()->GetAlg() == ALG_SKIPJACK) {
            dwFilter = FILTER_KEA_KEYEX;
        }
    }

    return EncDataComposeDlgProc(&pei, hdlg, msg, wParam, lParam, dwFilter);
}

BOOL CALLBACK EncInfoReadDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD       i;
    
    switch (msg) {
    case WM_INITDIALOG:
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\instring.cpp ===
#include <windows.h>
#include "instring.h"


typedef struct _STRING_BUFFER {
    ULONG cbBuffer;
    LPTSTR lpBuffer;
    LPTSTR lpPrompt;
    LPTSTR lpTitle;
} STRING_BUFFER, *LPSTRING_BUFFER;

INT_PTR CALLBACK InputStringDlgProc(HWND hDlg, WORD message, WORD wParam, LONG lParam) {
    static LPSTRING_BUFFER lpBuffer = NULL;
    USHORT cchString;

    switch (message) {
        case WM_INITDIALOG:
            // DialogBoxParam passes in pointer to buffer description.
            lpBuffer = (LPSTRING_BUFFER)lParam;

            if (lpBuffer->lpPrompt) {
                SetDlgItemText(hDlg, IDD_INPUT_STRING_PROMPT, lpBuffer->lpPrompt);
            }

            if (lpBuffer->lpTitle) {
                SetWindowText(hDlg, lpBuffer->lpTitle);
            }

            SendDlgItemMessage(hDlg,
              IDD_INPUT_STRING,
              EM_LIMITTEXT,
              (WPARAM)(lpBuffer->cbBuffer - 1), // text length, in characters (leave room for null)
              0);                               // not used; must be zero

            return(TRUE);

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    // Get number of characters.
                    cchString = (WORD)SendDlgItemMessage(hDlg,
                      IDD_INPUT_STRING,
                      EM_LINELENGTH,
                      (WPARAM) 0,
                      (LPARAM) 0);

                    if (cchString == 0) {
                        *(lpBuffer->lpBuffer) = '\0';
                        EndDialog(hDlg, TRUE);
                        lpBuffer->cbBuffer = 0;
                        return FALSE;
                    }

                    // Put the number of characters into first word
                    // of buffer.
                    *((USHORT*)lpBuffer->lpBuffer) = cchString;
                    lpBuffer->cbBuffer = cchString;

                    // Get the characters.
                    SendDlgItemMessage(hDlg,
                      IDD_INPUT_STRING,
                      EM_GETLINE,
                      (WPARAM)0,        // line 0
                      (LPARAM)lpBuffer->lpBuffer);

                    // Null-terminate the string.
                    lpBuffer->lpBuffer[cchString] = 0;
                    lpBuffer = NULL;    // prevent reuse of buffer
                    EndDialog(hDlg, 0);
                    return(TRUE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}

/***************************************************************************

    Name      : InputString

    Purpose   : Brings up a dialog requesting string input

    Parameters: hInstance = hInstance of app
                hwnd = hwnd of parent window
                lpszTitle = Dialog box title
                lpszPrompt = Text in dialog box
                lpBuffer = buffer to fill
                cchBuffer = size of buffer

    Returns   : return ULONG number of characters entered (not including terminating
                NULL)

    Comment   :

***************************************************************************/
ULONG InputString(HINSTANCE hInstance, HWND hwnd, const LPTSTR lpszTitle,
  const LPTSTR lpszPrompt, LPTSTR lpBuffer, ULONG cchBuffer) {
    STRING_BUFFER StringBuffer;

    StringBuffer.lpPrompt = lpszPrompt;
    StringBuffer.lpTitle = lpszTitle;
    StringBuffer.cbBuffer = cchBuffer;
    StringBuffer.lpBuffer = lpBuffer;

    DialogBoxParam(hInstance, (LPCTSTR)"InputString", hwnd, InputStringDlgProc,
      (LPARAM)&StringBuffer);

    return(StringBuffer.cbBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY CONFUSED.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS, THIS IS C++.
//

#define USE_CRITSEC

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#endif // IMPLEMENT_LOADER_FUNCTIONS

extern HINSTANCE g_hInst;

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

#define _CRYPT32_

BOOL DemandLoadCrypt32(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef unsigned long HCRYPTPROV;
typedef struct _CERT_INFO *PCERT_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCERT_NAME_INFO;
typedef void *HCRYPTMSG;
typedef struct _CMSG_STREAM_INFO *PCMSG_STREAM_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCCERT_NAME_INFO;

LOADER_FUNCTION( DWORD, CertRDNValueToStrA,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPTSTR pszValueString, DWORD cszValueString),
    (dwValueType, pValue, pszValueString, cszValueString),
    NULL, Crypt32)
#define CertRDNValueToStrA VAR_CertRDNValueToStrA

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext),
    (hCertStore, pCertContext, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( BOOL, CryptEncodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, BYTE * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObject VAR_CryptEncodeObject

LOADER_FUNCTION( BOOL, CryptDecodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObjectEx VAR_CryptDecodeObjectEx

LOADER_FUNCTION( BOOL, CryptEncodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObjectEx VAR_CryptEncodeObjectEx


LOADER_FUNCTION(PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    TRUE, Crypt32)  // return success since GLE() is meaningless
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    1, Crypt32)
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv, DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( HCERTSTORE, CertDuplicateStore,
    (HCERTSTORE hCertStore),
    (hCertStore),
    NULL, Crypt32)
#define CertDuplicateStore VAR_CertDuplicateStore

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetSubjectCertificateFromStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId),
    (hCertStore, dwCertEncodingType, pCertId),
    NULL, Crypt32)
#define CertGetSubjectCertificateFromStore VAR_CertGetSubjectCertificateFromStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToEncode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, void const *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToEncode VAR_CryptMsgOpenToEncode

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToDecode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToDecode VAR_CryptMsgOpenToDecode

LOADER_FUNCTION( BOOL, CryptMsgUpdate,
    (HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal),
    (hCryptMsg, pbData, cbData, fFinal),
    FALSE, Crypt32)
#define CryptMsgUpdate VAR_CryptMsgUpdate

LOADER_FUNCTION( BOOL, CryptMsgGetParam,
    (HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData),
    (hCryptMsg, dwParamType, dwIndex, pvData, pcbData),
    FALSE, Crypt32)
#define CryptMsgGetParam VAR_CryptMsgGetParam

LOADER_FUNCTION( BOOL, CryptMsgControl,
    (HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, void const *pvCtrlPara),
    (hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara),
    FALSE, Crypt32)
#define CryptMsgControl VAR_CryptMsgControl

LOADER_FUNCTION( BOOL, CryptMsgClose,
    (HCRYPTMSG hCryptMsg),
    (hCryptMsg),
    TRUE, Crypt32)  // return success since GLE() is meaningless
#define CryptMsgClose VAR_CryptMsgClose

LOADER_FUNCTION( BOOL, CertAddEncodedCRLToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext),
    (hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext),
    FALSE, Crypt32)
#define CertAddEncodedCRLToStore VAR_CertAddEncodedCRLToStore

LOADER_FUNCTION( PCCRL_CONTEXT, CertEnumCRLsInStore,
    (HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext),
    (hCertStore, pPrevCrlContext),
    NULL, Crypt32)
#define CertEnumCRLsInStore VAR_CertEnumCRLsInStore

LOADER_FUNCTION( PCERT_EXTENSION, CertFindExtension,
    (LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION * rgExtensions),
    (pszObjId, cExtensions, rgExtensions),
    NULL, Crypt32)
#define CertFindExtension VAR_CertFindExtension

LOADER_FUNCTION( BOOL, CertStrToNameW,
    (DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType,
     void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError),
    (dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded,
     ppszError),
    NULL, Crypt32)
#define CertStrToNameW VAR_CertStrToNameW

LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded,
     DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded,
     cbCertEncoded, dwAddDisposition, ppCertContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

LOADER_FUNCTION( BOOL, CertAddStoreToCollection,
    (HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags,
     DWORD dwPriority),
    (hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority),
    FALSE, Crypt32)
#define CertAddStoreToCollection VAR_CertAddStoreToCollection

/////////////////////////////////////
// CRYPTDLG.DLL

#define _CRYPTDLG_

// Old cert dialogs
typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A *PCERT_VIEWPROPERTIES_STRUCT_A;
typedef struct tagCSSA *PCERT_SELECT_STRUCT_A;

BOOL DemandLoadCryptDlg();

LOADER_FUNCTION( BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo),
    FALSE, CryptDlg)
#define CertViewPropertiesA VAR_CertViewPropertiesA

LOADER_FUNCTION( DWORD, GetFriendlyNameOfCertA,
    (PCCERT_CONTEXT pccert, LPSTR pchBuffer, DWORD cchBuffer),
    (pccert, pchBuffer, cchBuffer),
    0, CryptDlg)
#define GetFriendlyNameOfCertA VAR_GetFriendlyNameOfCertA

LOADER_FUNCTION( BOOL, CertSelectCertificateA,
    (PCERT_SELECT_STRUCT_A pCertSelectInfo),
    (pCertSelectInfo),
    FALSE, CryptDlg)
#define CertSelectCertificateA VAR_CertSelectCertificateA

/////////////////////////////////////
// WINTRUST.DLL

BOOL DemandLoadWinTrust();

LOADER_FUNCTION( LONG, WinVerifyTrust,
    (HWND hwnd, GUID *ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData),
    0, WinTrust)
#define WinVerifyTrust VAR_WinVerifyTrust

#if 0
/////////////////////////////////////
// WININET.DLL

#include <wininet.h>

#define _WININET_

typedef struct _INTERNET_CACHE_ENTRY_INFOA INTERNET_CACHE_ENTRY_INFOA;

BOOL DemandLoadWinINET();

LOADER_FUNCTION( BOOL, RetrieveUrlCacheEntryFileA,
    (LPCSTR  lpszUrlName, INTERNET_CACHE_ENTRY_INFOA *lpCacheEntryInfo, LPDWORD lpdwCacheEntryInfoBufferSize, DWORD dwReserved),
    (lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize, dwReserved),
    FALSE, WinINET)
#define RetrieveUrlCacheEntryFileA VAR_RetrieveUrlCacheEntryFileA

LOADER_FUNCTION( BOOL, UnlockUrlCacheEntryFileA,
    (LPCSTR  lpszUrlName, DWORD dwRes),
    (lpszUrlName, dwRes),
    FALSE, WinINET)
#define UnlockUrlCacheEntryFileA VAR_UnlockUrlCacheEntryFileA

LOADER_FUNCTION( BOOL, InternetQueryOptionA,
    (HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufferLength),
    (hInternet, dwOption, lpBuffer, lpdwBufferLength),
    NULL, WinINET)
#define InternetQueryOptionA VAR_InternetQueryOptionA

LOADER_FUNCTION( BOOL, InternetSetOptionA,
    (HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength),
    (hInternet, dwOption, lpBuffer, dwBufferLength),
    NULL, WinINET)
#define InternetSetOptionA VAR_InternetSetOptionA

LOADER_FUNCTION( BOOL, InternetDialA,
    (HWND hwndParent, LPSTR lpszConnectoid, DWORD dwFlags, DWORD *lpdwConnection, DWORD dwReserved),
    (hwndParent, lpszConnectoid, dwFlags, lpdwConnection, dwReserved),
    NULL, WinINET)
#define InternetDialA VAR_InternetDialA

LOADER_FUNCTION( BOOL, InternetHangUp,
    (DWORD dwConnection, DWORD dwReserved),
    (dwConnection, dwReserved),
    NULL, WinINET)
#define InternetHangUp VAR_InternetHangUp

LOADER_FUNCTION(BOOL, InternetGetConnectedStateExA, 
                (LPDWORD dwFlags,  LPTSTR szconn, DWORD size, DWORD reserved),
                (dwFlags, szconn, size, reserved),
                FALSE, WinINET)
#define InternetGetConnectedStateExA  VAR_InternetGetConnectedStateExA

LOADER_FUNCTION(BOOL, InternetCombineUrlA, 
                (LPCSTR lpszBaseUrl, LPCSTR lpszRelativeUrl, LPSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
                (lpszBaseUrl, lpszRelativeUrl, lpszBuffer, lpdwBufferLength, dwFlags),
                FALSE, WinINET)
#define InternetCombineUrlA  VAR_InternetCombineUrlA

LOADER_FUNCTION(BOOL, InternetCrackUrlA, 
                (LPCSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents),
                (lpszUrl, dwUrlLength, dwFlags, lpUrlComponents),
                FALSE, WinINET)
#define InternetCrackUrlA  VAR_InternetCrackUrlA

LOADER_FUNCTION(BOOL, InternetCloseHandle, 
                (HINTERNET hInternet),
                (hInternet),
                FALSE, WinINET)
#define   InternetCloseHandle   VAR_InternetCloseHandle

LOADER_FUNCTION(BOOL, InternetReadFile, 
                (HINTERNET hInternet, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead),
                (hInternet, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead),
                FALSE, WinINET)
#define   InternetReadFile   VAR_InternetReadFile

LOADER_FUNCTION(HINTERNET, InternetConnectA, 
                (HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort,
                            LPCSTR lpszUserName,LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD dwContext),
                (hInternet, lpszServerName, nServerPort, lpszUserName, lpszPassword, dwService, dwFlags, dwContext),
                NULL, WinINET)
#define   InternetConnectA   VAR_InternetConnectA

LOADER_FUNCTION(HINTERNET, InternetOpenA, 
                (LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags),
                (lpszAgent, dwAccessType, lpszProxy, lpszProxyBypass, dwFlags),
                NULL, WinINET)
#define   InternetOpenA   VAR_InternetOpenA

LOADER_FUNCTION(BOOL, HttpQueryInfoA, 
                (HINTERNET hRequest, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex),
                (hRequest, dwInfoLevel, lpBuffer, lpdwBufferLength, lpdwIndex),
                FALSE, WinINET)
#define   HttpQueryInfoA   VAR_HttpQueryInfoA

LOADER_FUNCTION(HINTERNET, HttpOpenRequestA, 
                (HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion,
                            LPCSTR lpszReferrer, LPCSTR FAR * lplpszAcceptTypes, DWORD dwFlags, DWORD dwContext),
                ( hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferrer, lplpszAcceptTypes, dwFlags, dwContext),
                NULL, WinINET)
#define   HttpOpenRequestA   VAR_HttpOpenRequestA

LOADER_FUNCTION(BOOL, HttpAddRequestHeadersA, 
                (HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwModifiers),
                (hRequest, lpszHeaders, dwHeadersLength, dwModifiers),
                FALSE, WinINET)
#define   HttpAddRequestHeadersA   VAR_HttpAddRequestHeadersA

LOADER_FUNCTION(BOOL, HttpSendRequestA, 
                (HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength),
                (hRequest, lpszHeaders, dwHeadersLength, lpOptional, dwOptionalLength),
                FALSE, WinINET)
#define   HttpSendRequestA   VAR_HttpSendRequestA

LOADER_FUNCTION(BOOL, InternetWriteFile, 
                (HINTERNET hFile, LPCVOID lpBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD lpdwNumberOfBytesWritten),
                (hFile, lpBuffer, dwNumberOfBytesToWrite, lpdwNumberOfBytesWritten),
                FALSE, WinINET)
#define   InternetWriteFile   VAR_InternetWriteFile

LOADER_FUNCTION(BOOL, HttpEndRequestA, 
                (HINTERNET hRequest, LPINTERNET_BUFFERSA lpBuffersOut, DWORD dwFlags, DWORD dwContext),
                (hRequest, lpBuffersOut, dwFlags, dwContext),
                FALSE, WinINET)
#define   HttpEndRequestA   VAR_HttpEndRequestA

LOADER_FUNCTION(BOOL, HttpSendRequestExA, 
                (HINTERNET hRequest, LPINTERNET_BUFFERSA lpBuffersIn,
                                LPINTERNET_BUFFERSA lpBuffersOut, DWORD dwFlags, DWORD dwContext),
                (hRequest, lpBuffersIn, lpBuffersOut, dwFlags, dwContext),
                FALSE, WinINET)
#define   HttpSendRequestExA   VAR_HttpSendRequestExA

/////////////////////////////////////
// SHELL32.DLL

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>

BOOL DemandLoadSHELL32();

LOADER_FUNCTION(BOOL, SHFree, // Actually a void
   (LPVOID lpv),
   (lpv),
   FALSE, SHELL32)
#define SHFree VAR_SHFree

LOADER_FUNCTION(BOOL, SHGetPathFromIDListA,
    (LPCITEMIDLIST pidl, LPSTR pszPath),
    (pidl, pszPath),
    FALSE, SHELL32)
#define SHGetPathFromIDListA VAR_SHGetPathFromIDListA

LOADER_FUNCTION(HRESULT, SHGetSpecialFolderLocation,
    (HWND hwndOwner, int nFolder, LPITEMIDLIST * ppidl),
    (hwndOwner, nFolder, ppidl),
    E_FAIL, SHELL32)
#define SHGetSpecialFolderLocation VAR_SHGetSpecialFolderLocation

LOADER_FUNCTION(LPITEMIDLIST, SHBrowseForFolderA,
    (LPBROWSEINFOA lpbi),
    (lpbi),
    NULL, SHELL32)
#define SHBrowseForFolderA VAR_SHBrowseForFolderA

LOADER_FUNCTION(HINSTANCE, ShellExecuteA,
    (HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd),
    (hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd),
    NULL, SHELL32)
#define ShellExecuteA VAR_ShellExecuteA

LOADER_FUNCTION(BOOL, ShellExecuteExA,
    (LPSHELLEXECUTEINFOA lpExecInfo),
    (lpExecInfo),
    FALSE, SHELL32)
#define ShellExecuteExA VAR_ShellExecuteExA

LOADER_FUNCTION(UINT, DragQueryFileA,
    (HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cb),
    (hDrop, iFile, lpszFile, cb),
    0, SHELL32)
#define DragQueryFileA VAR_DragQueryFileA

LOADER_FUNCTION(DWORD, SHGetFileInfoA,
    (LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags),
    (pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags),
    0, SHELL32)
#define SHGetFileInfoA VAR_SHGetFileInfoA

LOADER_FUNCTION(BOOL, Shell_NotifyIconA,
    (DWORD dwMessage, PNOTIFYICONDATAA lpData),
    (dwMessage, lpData),
    FALSE, SHELL32)
#define Shell_NotifyIconA VAR_Shell_NotifyIconA

LOADER_FUNCTION(int, SHFileOperationA,
    (LPSHFILEOPSTRUCTA lpfo),
    (lpfo),
    -1, SHELL32)
#define SHFileOperationA VAR_SHFileOperationA

LOADER_FUNCTION(HICON, ExtractIconA,
    (HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex),
    (hInst, lpszExeFileName, nIconIndex),
    NULL, SHELL32)
#define ExtractIconA VAR_ExtractIconA

#if 0
/////////////////////////////////////
// OLEAUT32.DLL

BOOL DemandLoadOLEAUT32();

#include <olectl.h>

LOADER_FUNCTION(SAFEARRAY *, SafeArrayCreate,
    (VARTYPE vt, UINT cDims, SAFEARRAYBOUND* rgsabound),
    (vt, cDims, rgsabound),
    NULL, OLEAUT32)
#define SafeArrayCreate VAR_SafeArrayCreate

LOADER_FUNCTION(HRESULT, SafeArrayPutElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv),
    (psa, rgIndices, pv),
    E_FAIL, OLEAUT32)
#define SafeArrayPutElement VAR_SafeArrayPutElement

LOADER_FUNCTION(HRESULT, DispInvoke,
    (void * _this, ITypeInfo * ptinfo, DISPID dispidMember, WORD wFlags, DISPPARAMS * pparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr),
    (_this, ptinfo, dispidMember, wFlags, pparams, pvarResult, pexcepinfo, puArgErr),
    E_FAIL, OLEAUT32)
#define DispInvoke VAR_DispInvoke

LOADER_FUNCTION(HRESULT, DispGetIDsOfNames,
    (ITypeInfo * ptinfo, OLECHAR ** rgszNames, UINT cNames, DISPID * rgdispid),
    (ptinfo, rgszNames, cNames, rgdispid),
    E_FAIL, OLEAUT32)
#define DispGetIDsOfNames VAR_DispGetIDsOfNames

LOADER_FUNCTION(BSTR, SysAllocStringByteLen,
    (LPCSTR psz, UINT len),
    (psz, len),
    NULL, OLEAUT32)
#define SysAllocStringByteLen VAR_SysAllocStringByteLen

LOADER_FUNCTION(int, SysReAllocString,
    (BSTR * pbstr,  const OLECHAR * sz),
    (pbstr, sz),
    0, OLEAUT32)
#define SysReAllocString VAR_SysReAllocString

LOADER_FUNCTION(BSTR, SysAllocStringLen,
    (const OLECHAR *pch, unsigned int i),
    (pch, i),
    NULL, OLEAUT32)
#define SysAllocStringLen VAR_SysAllocStringLen

LOADER_FUNCTION(BSTR, SysAllocString,
    (const OLECHAR *pch),
    (pch),
    NULL, OLEAUT32)
#define SysAllocString VAR_SysAllocString

LOADER_FUNCTION(BOOL, SysFreeString,  // Actually a void
    (BSTR bs),
    (bs),
    FALSE, OLEAUT32)
#define SysFreeString VAR_SysFreeString

LOADER_FUNCTION(UINT, SysStringLen,
    (BSTR bs),
    (bs),
    0, OLEAUT32)
#define SysStringLen VAR_SysStringLen

LOADER_FUNCTION(BOOL, VariantInit,
    (VARIANTARG * pvarg),
    (pvarg),
    FALSE, OLEAUT32)
#define VariantInit VAR_VariantInit

LOADER_FUNCTION(HRESULT, LoadTypeLib,
    (const OLECHAR  *szFile, ITypeLib ** pptlib),
    (szFile, pptlib),
    E_FAIL, OLEAUT32)
#define LoadTypeLib VAR_LoadTypeLib

LOADER_FUNCTION(HRESULT, RegisterTypeLib,
    (ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir),
    (ptlib, szFullPath, szHelpDir),
    E_FAIL, OLEAUT32)
#define RegisterTypeLib VAR_RegisterTypeLib

LOADER_FUNCTION(HRESULT, SafeArrayAccessData,
    (SAFEARRAY * psa, void HUGEP** ppvData),
    (psa, ppvData),
    E_FAIL, OLEAUT32)
#define SafeArrayAccessData VAR_SafeArrayAccessData

LOADER_FUNCTION(HRESULT, SafeArrayUnaccessData,
    (SAFEARRAY * psa),
    (psa),
    E_FAIL, OLEAUT32)
#define SafeArrayUnaccessData VAR_SafeArrayUnaccessData

LOADER_FUNCTION(UINT, SysStringByteLen,
    (BSTR bstr),
    (bstr),
    0, OLEAUT32)
#define SysStringByteLen VAR_SysStringByteLen

LOADER_FUNCTION(HRESULT, SafeArrayDestroy,
    (SAFEARRAY *psa),
    (psa),
    E_FAIL, OLEAUT32)
#define SafeArrayDestroy VAR_SafeArrayDestroy

LOADER_FUNCTION(HRESULT, SafeArrayGetElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv),
    (psa, rgIndices, pv),
    E_FAIL, OLEAUT32)
#define SafeArrayGetElement VAR_SafeArrayGetElement

LOADER_FUNCTION(HRESULT, SafeArrayGetUBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plUbound),
    (psa, nDim, plUbound),
    E_FAIL, OLEAUT32)
#define SafeArrayGetUBound VAR_SafeArrayGetUBound

LOADER_FUNCTION(HRESULT, SafeArrayGetLBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plLbound),
    (psa, nDim, plLbound),
    E_FAIL, OLEAUT32)
#define SafeArrayGetLBound VAR_SafeArrayGetLBound

LOADER_FUNCTION(HRESULT, VariantClear,
    (VARIANTARG * pvarg),
    (pvarg),
    E_FAIL, OLEAUT32)
#define VariantClear VAR_VariantClear

LOADER_FUNCTION(HRESULT, VariantCopy,
    (VARIANTARG * pvargDest, VARIANTARG * pvargSrc),
    (pvargDest, pvargSrc),
    E_FAIL, OLEAUT32)
#define VariantCopy VAR_VariantCopy

LOADER_FUNCTION(HRESULT, SetErrorInfo,
    (ULONG dwReserved, IErrorInfo * perrinfo),
    (dwReserved, perrinfo),
    E_FAIL, OLEAUT32)
#define SetErrorInfo VAR_SetErrorInfo

LOADER_FUNCTION(HRESULT, CreateErrorInfo,
    (ICreateErrorInfo ** pperrinfo),
    (pperrinfo),
    E_FAIL, OLEAUT32)
#define CreateErrorInfo VAR_CreateErrorInfo

#endif

/////////////////////////////////////
// COMDLG32.DLL

#include <commdlg.h>

BOOL DemandLoadCOMDLG32();

LOADER_FUNCTION(BOOL, GetSaveFileNameA,
    (LPOPENFILENAME pof),
    (pof),
    FALSE, COMDLG32)
#define GetSaveFileNameA VAR_GetSaveFileNameA

LOADER_FUNCTION(BOOL, GetOpenFileNameA,
    (LPOPENFILENAME pof),
    (pof),
    FALSE, COMDLG32)
#define GetOpenFileNameA VAR_GetOpenFileNameA

LOADER_FUNCTION(BOOL, ChooseFontA,
    (LPCHOOSEFONT pcf),
    (pcf),
    FALSE, COMDLG32)
#define ChooseFontA VAR_ChooseFontA

/////////////////////////////////////
// VERSION.DLL

BOOL DemandLoadVERSION();

LOADER_FUNCTION(BOOL, VerQueryValueA,
    (const LPVOID pBlock, LPSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen),
    (pBlock, lpSubBlock, lplpBuffer, puLen),
    FALSE, VERSION)
#define VerQueryValueA VAR_VerQueryValueA

LOADER_FUNCTION(BOOL, GetFileVersionInfoA,
    (PSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),
    (lptstrFilename, dwHandle, dwLen, lpData),
    FALSE, VERSION)
#define GetFileVersionInfoA VAR_GetFileVersionInfoA

LOADER_FUNCTION(DWORD, GetFileVersionInfoSizeA,
    (LPSTR lptstrFilename, LPDWORD lpdwHandle),
    (lptstrFilename, lpdwHandle),
    0, VERSION)
#define GetFileVersionInfoSizeA VAR_GetFileVersionInfoSizeA

/////////////////////////////////////
// URLMON.DLL

BOOL DemandLoadURLMON();

LOADER_FUNCTION(HRESULT, CreateURLMoniker,
    (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR *ppmk),
    (pMkCtx, szURL, ppmk),
    E_FAIL, URLMON)
#define CreateURLMoniker VAR_CreateURLMoniker

LOADER_FUNCTION(HRESULT, URLOpenBlockingStreamA,
    (LPUNKNOWN pUnk,LPCSTR pURL,LPSTREAM* ppstm,DWORD i,LPBINDSTATUSCALLBACK p),
    (pUnk, pURL, ppstm, i, p),
    E_FAIL, URLMON)
#define URLOpenBlockingStreamA VAR_URLOpenBlockingStreamA

LOADER_FUNCTION(HRESULT, FindMimeFromData,
    (LPBC pBC, LPCWSTR pwzUrl, LPVOID pBuffer, DWORD cbSize, LPCWSTR pwzMimeProposed, DWORD dwMimeFlags, LPWSTR *ppwzMimeOut, DWORD dwReserved),
    (pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved),
    E_FAIL, URLMON)
#define FindMimeFromData VAR_FindMimeFromData

LOADER_FUNCTION( HRESULT, CoInternetCombineUrl,
    (LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
    (pwzBaseUrl, pwzRelativeUrl, dwCombineFlags, pszResult, cchResult, pcchResult, dwReserved),
    E_FAIL, URLMON)
#define CoInternetCombineUrl VAR_CoInternetCombineUrl

LOADER_FUNCTION( HRESULT, RegisterBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved),
    (pBC, pBSCb, ppBSCBPrev, dwReserved),
    E_FAIL, URLMON)
#define RegisterBindStatusCallback VAR_RegisterBindStatusCallback

LOADER_FUNCTION( HRESULT, RevokeBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb),
    (pBC, pBSCb),
    E_FAIL, URLMON)
#define RevokeBindStatusCallback VAR_RevokeBindStatusCallback

LOADER_FUNCTION( HRESULT, FaultInIEFeature,
    (HWND hwnd,     uCLSSPEC    *classpec, QUERYCONTEXT *pQuery, DWORD dwFlags),
    (hwnd, classpec, pQuery, dwFlags),
    E_FAIL, URLMON)
#define FaultInIEFeature VAR_FaultInIEFeature

LOADER_FUNCTION( HRESULT, CoInternetGetSecurityUrl,
    (LPCWSTR pwzUrl, LPWSTR  *ppwzSecUrl, PSUACTION  psuAction, DWORD   dwReserved),
    (pwzUrl, ppwzSecUrl, psuAction, dwReserved),
    E_FAIL, URLMON)
#define CoInternetGetSecurityUrl VAR_CoInternetGetSecurityUrl

/////////////////////////////////////
// MLANG.DLL

#include <mlang.h>

BOOL DemandLoadMLANG(void);

LOADER_FUNCTION( HRESULT, IsConvertINetStringAvailable,
    (DWORD dwSrcEncoding, DWORD dwDstEncoding),
    (dwSrcEncoding, dwDstEncoding),
    S_FALSE, MLANG)
#define IsConvertINetStringAvailable VAR_IsConvertINetStringAvailable

LOADER_FUNCTION( HRESULT, ConvertINetString,
    (LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize),
    (lpdwMode, dwSrcEncoding, dwDstEncoding, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize),
    E_FAIL, MLANG)
#define ConvertINetString VAR_ConvertINetString

/////////////////////////////////////
// SHDOCVW.DLL

#include <shlobjp.h>
BOOL DemandLoadSHDOCVW();

LOADER_FUNCTION(HRESULT, AddUrlToFavorites,
    (HWND hwnd, LPWSTR pszUrlW, LPWSTR pszTitleW, BOOL fDisplayUI),
    (hwnd, pszUrlW, pszTitleW, fDisplayUI),
    E_FAIL, SHDOCVW)
#define AddUrlToFavorites VAR_AddUrlToFavorites

LOADER_FUNCTION(long, SetQueryNetSessionCount,
    (enum SessionOp Op),
    (Op),
    0, SHDOCVW)
#define SetQueryNetSessionCount VAR_SetQueryNetSessionCount


/////////////////////////////////////
// INETCPL.CPL

BOOL DemandLoadINETCPL();

LOADER_FUNCTION(int, OpenFontsDialog,
    (HWND hwnd, LPCSTR lpszKey),
    (hwnd, lpszKey),
    0, INETCPL)
#define OpenFontsDialog VAR_OpenFontsDialog

LOADER_FUNCTION(BOOL, LaunchConnectionDialog,
    (HWND   hwnd),
    (hwnd),
    FALSE,  INETCPL)
#define LaunchConnectionDialog VAR_LaunchConnectionDialog

/////////////////////////////////////
// MSO9.DLL
#include "msoci.h"
BOOL DemandLoadMSO9();

LOADER_FUNCTION(BOOL, MsoFGetComponentManager,
    (IMsoComponentManager **ppicm),
    (ppicm),
    FALSE, MSO9)
#define MsoFGetComponentManager VAR_MsoFGetComponentManager

/////////////////////////////////////
// WINMM.DLL


BOOL DemandLoadWinMM();

LOADER_FUNCTION(BOOL, sndPlaySoundA,
    (LPCSTR pszSound, UINT fuSound),
    (pszSound, fuSound),
    FALSE, WinMM)
#define sndPlaySoundA VAR_sndPlaySoundA

/////////////////////////////////////
// WSOCK32.DLL

#include <winsock.h>

typedef struct WSAData FAR * LPWSADATA;
typedef unsigned int    u_int;
typedef unsigned short  u_short;
typedef u_int           SOCKET;

BOOL DemandLoadWSOCK32();

LOADER_FUNCTION( int, WSAStartup,
    (WORD wVersionRequired, LPWSADATA lpWSAData),
    (wVersionRequired, lpWSAData),
    WSAVERNOTSUPPORTED, WSOCK32)
#define WSAStartup VAR_WSAStartup

LOADER_FUNCTION( int, WSACleanup,
    (void),
    (),
    SOCKET_ERROR, WSOCK32)
#define WSACleanup VAR_WSACleanup

LOADER_FUNCTION( int, WSAGetLastError,
    (void),
    (),
    0, WSOCK32)
#define WSAGetLastError VAR_WSAGetLastError

LOADER_FUNCTION( int, gethostname,
    (char FAR * name, int namelen),
    (name, namelen),
    SOCKET_ERROR, WSOCK32)
#define gethostname VAR_gethostname

LOADER_FUNCTION( struct hostent FAR *, gethostbyname,
    (const char FAR * name),
    (name),
    NULL, WSOCK32)
#define gethostbyname VAR_gethostbyname

LOADER_FUNCTION( HANDLE, WSAAsyncGetHostByName,
    (HWND hWnd, u_int wMsg, const char FAR * name, char FAR * buf, int buflen),
    (hWnd, wMsg, name, buf, buflen),
    0, WSOCK32)
#define WSAAsyncGetHostByName VAR_WSAAsyncGetHostByName

LOADER_FUNCTION( unsigned long, inet_addr,
    (const char FAR * cp),
    (cp),
    INADDR_NONE, WSOCK32)
#define inet_addr VAR_inet_addr

LOADER_FUNCTION( u_short, htons,
    (u_short hostshort),
    (hostshort),
    0, WSOCK32)
#define htons VAR_htons

LOADER_FUNCTION( int, WSACancelAsyncRequest,
    (HANDLE hAsyncTaskHandle),
    (hAsyncTaskHandle),
    SOCKET_ERROR, WSOCK32)
#define WSACancelAsyncRequest VAR_WSACancelAsyncRequest

LOADER_FUNCTION( int, send,
    (SOCKET s, const char FAR * buf, int len, int flags),
    (s, buf, len, flags),
    SOCKET_ERROR, WSOCK32)
#define send VAR_send

LOADER_FUNCTION( int, connect,
    (SOCKET s, const struct sockaddr FAR *name, int namelen),
    (s, name, namelen),
    SOCKET_ERROR, WSOCK32)
#define connect VAR_connect

LOADER_FUNCTION( int, WSAAsyncSelect,
    (SOCKET s, HWND hWnd, u_int wMsg, long lEvent),
    (s, hWnd, wMsg, lEvent),
    SOCKET_ERROR, WSOCK32)
#define WSAAsyncSelect VAR_WSAAsyncSelect

LOADER_FUNCTION( SOCKET, socket,
    (int af, int type, int protocol),
    (af, type, protocol),
    INVALID_SOCKET, WSOCK32)
#define socket VAR_socket

LOADER_FUNCTION( char FAR *, inet_ntoa,
    (struct in_addr in),
    (in),
    NULL, WSOCK32)
#define inet_ntoa VAR_inet_ntoa

LOADER_FUNCTION( int, closesocket,
    (SOCKET s),
    (s),
    SOCKET_ERROR, WSOCK32)
#define closesocket VAR_closesocket

LOADER_FUNCTION( int, recv,
    (SOCKET s, char FAR * buf, int len, int flags),
    (s, buf, len, flags),
    SOCKET_ERROR, WSOCK32)
#define recv VAR_recv

/////////////////////////////////////
// PSTOREC.DLL

#ifndef __IEnumPStoreProviders_FWD_DEFINED__
    #define __IEnumPStoreProviders_FWD_DEFINED__
    typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif 	/* __IEnumPStoreProviders_FWD_DEFINED__ */
#ifndef __IPStore_FWD_DEFINED__
    #define __IPStore_FWD_DEFINED__
    typedef interface IPStore IPStore;
#endif 	/* __IPStore_FWD_DEFINED__ */
typedef GUID PST_PROVIDERID;

BOOL DemandLoadPStoreC();

LOADER_FUNCTION( HRESULT, PStoreCreateInstance,
    (IPStore __RPC_FAR *__RPC_FAR *ppProvider, PST_PROVIDERID __RPC_FAR *pProviderID, void __RPC_FAR *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL, PStoreC)
#define PStoreCreateInstance VAR_PStoreCreateInstance

/////////////////////////////////////
// RICHED32.DLL
// note: special case as we don't use any riched functions but need to LoadLibrary it.

BOOL DemandLoadRichEdit();

/////////////////////////////////////
// RAS.DLL
#include <ras.h>
#include <raserror.h>

extern BOOL DemandLoadRAS(void);

LOADER_FUNCTION( DWORD, RasEnumEntriesA,
    (LPSTR reserved, LPSTR lpszPhoneBook, LPRASENTRYNAMEA lpEntry, LPDWORD lpcb, LPDWORD lpcEntries),
    (reserved, lpszPhoneBook, lpEntry, lpcb, lpcEntries),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasEnumEntriesA VAR_RasEnumEntriesA

LOADER_FUNCTION( DWORD, RasEditPhonebookEntryA,
    (HWND hwnd, LPSTR lpszPhoneBook, LPSTR lpszEntryName),
    (hwnd, lpszPhoneBook, lpszEntryName),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasEditPhonebookEntryA VAR_RasEditPhonebookEntryA

LOADER_FUNCTION( DWORD, RasCreatePhonebookEntryA,
    (HWND hwnd, LPSTR lpszPhoneBook),
    (hwnd, lpszPhoneBook),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasCreatePhonebookEntryA VAR_RasCreatePhonebookEntryA

/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif
typedef unsigned long HCRYPTKEY;

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\demand.cpp ===
// --------------------------------------------------------------------------------
// Demand.cpp
// Written By: jimsch, brimo, t-erikne (bastardized by sbailey)
// --------------------------------------------------------------------------------
// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------

#include <windows.h>
#include "myassert.h"
#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

// --------------------------------------------------------------------------------
// CRIT_GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
    temp = (TYP_##fn) GetProcAddress(h, #fn);   \
    if (temp)                                   \
        VAR_##fn = temp;                        \
    else                                        \
        {                                       \
        AssertSz(0, VAR_##fn" failed to load"); \
        goto error;                             \
        }

// --------------------------------------------------------------------------------
// RESET
// --------------------------------------------------------------------------------
#define RESET(fn) VAR_##fn = LOADER_##fn;

// --------------------------------------------------------------------------------
// GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
    Assert(VAR_##fn != NULL);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR_ORDINAL
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR_ORDINAL(h, fn, ord) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, MAKEINTRESOURCE(ord));  \
    Assert(VAR_##fn != NULL);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR3
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR3(h, fn, varname) \
    VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
    Assert(VAR_##varname != NULL);

// --------------------------------------------------------------------------------
// Static Globals
// --------------------------------------------------------------------------------
static HMODULE s_hCrypt = 0;
static HMODULE s_hCryptDlg = 0;
static HMODULE s_hWinTrust = 0;
#if 0
static HMODULE s_hWinINET = 0;
static HMODULE s_hShell32 = 0;
static HMODULE s_hOleAut32 = 0;
static HMODULE s_hComDlg32 = 0;
static HMODULE s_hVersion = 0;
static HMODULE s_hUrlmon = 0;
static HMODULE s_hShDocVw = 0;
static HMODULE s_hInetCPL = 0;
static HMODULE s_hMSO9 = 0;
static HMODULE s_hWinMM = 0;
static HMODULE s_hRichEdit = 0;
static HMODULE s_hMLANG = 0;
static HMODULE s_hWSOCK = 0;
static HMODULE s_hPstoreC = 0;
static HMODULE s_hRAS = 0;
static HMODULE s_hAdvApi = 0;
#endif // 0

static CRITICAL_SECTION g_csDefLoad = {0};

// --------------------------------------------------------------------------------
// InitDemandLoadedLibs
// --------------------------------------------------------------------------------
void InitDemandLoadedLibs(void)
{
    InitializeCriticalSection(&g_csDefLoad);
}

// --------------------------------------------------------------------------------
// FreeDemandLoadedLibs
// --------------------------------------------------------------------------------
void FreeDemandLoadedLibs(void)
{
    EnterCriticalSection(&g_csDefLoad);
    if (s_hCrypt)       FreeLibrary(s_hCrypt);
    if (s_hCryptDlg)    FreeLibrary(s_hCryptDlg);
    if (s_hWinTrust)    FreeLibrary(s_hWinTrust);
#if 0
    FreeLibrary(s_hWinINET);
    FreeLibrary(s_hWSOCK);
    FreeLibrary(s_hShell32);
    FreeLibrary(s_hOleAut32);
    FreeLibrary(s_hComDlg32);
    FreeLibrary(s_hVersion);
    FreeLibrary(s_hUrlmon);
    FreeLibrary(s_hMLANG);
    FreeLibrary(s_hShDocVw);
    FreeLibrary(s_hInetCPL);
    FreeLibrary(s_hMSO9);
    FreeLibrary(s_hWinMM);
    FreeLibrary(s_hRichEdit);
    FreeLibrary(s_hPstoreC);
    FreeLibrary(s_hRAS);
    FreeLibrary(s_hAdvApi);
#endif // 0

    LeaveCriticalSection(&g_csDefLoad);
    DeleteCriticalSection(&g_csDefLoad);
}


// --------------------------------------------------------------------------------
// DemandLoadCrypt32
// --------------------------------------------------------------------------------
BOOL DemandLoadCrypt32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCrypt)
        {
        s_hCrypt = LoadLibrary("CRYPT32.DLL");
        AssertSz((BOOL)s_hCrypt, TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCrypt, CertRDNValueToStrA);
            GET_PROC_ADDR(s_hCrypt, CertAddCertificateContextToStore)
            GET_PROC_ADDR(s_hCrypt, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateStore)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertGetSubjectCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToEncode)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToDecode)
            GET_PROC_ADDR(s_hCrypt, CryptMsgControl)
            GET_PROC_ADDR(s_hCrypt, CryptMsgUpdate)
            GET_PROC_ADDR(s_hCrypt, CryptMsgGetParam)
            GET_PROC_ADDR(s_hCrypt, CryptMsgClose)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCRLToStore)
            GET_PROC_ADDR(s_hCrypt, CertEnumCRLsInStore)
            GET_PROC_ADDR(s_hCrypt, CertFindExtension)
            GET_PROC_ADDR(s_hCrypt, CertStrToNameW)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCertificateToStore)
            GET_PROC_ADDR(s_hCrypt, CertAddStoreToCollection)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadCryptDlg
// --------------------------------------------------------------------------------
BOOL DemandLoadCryptDlg(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCryptDlg)
        {
        s_hCryptDlg = LoadLibrary("CRYPTDLG.DLL");
        AssertSz((BOOL)s_hCryptDlg, TEXT("LoadLibrary failed on CRYPTDLG.DLL"));

        if (0 == s_hCryptDlg)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCryptDlg, CertViewPropertiesA)
            GET_PROC_ADDR(s_hCryptDlg, GetFriendlyNameOfCertA)
            GET_PROC_ADDR(s_hCryptDlg, CertSelectCertificateA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinTrust
// --------------------------------------------------------------------------------
BOOL DemandLoadWinTrust(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinTrust)
        {
        s_hWinTrust = LoadLibrary("WINTRUST.DLL");
        AssertSz((BOOL)s_hWinTrust, TEXT("LoadLibrary failed on WINTRUST.DLL"));

        if (0 == s_hWinTrust)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinTrust, WinVerifyTrust)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

#if 0
// --------------------------------------------------------------------------------
// DemandLoadWinINET
// --------------------------------------------------------------------------------
BOOL DemandLoadWinINET(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinINET)
        {
        s_hWinINET = LoadLibrary("WININET.DLL");
        AssertSz((BOOL)s_hWinINET, TEXT("LoadLibrary failed on WININET.DLL"));

        if (0 == s_hWinINET)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinINET, RetrieveUrlCacheEntryFileA)
            GET_PROC_ADDR(s_hWinINET, UnlockUrlCacheEntryFileA)
            GET_PROC_ADDR(s_hWinINET, InternetQueryOptionA)
            GET_PROC_ADDR(s_hWinINET, InternetSetOptionA)
            GET_PROC_ADDR(s_hWinINET, InternetDialA)
            GET_PROC_ADDR(s_hWinINET, InternetHangUp)
            GET_PROC_ADDR(s_hWinINET, InternetGetConnectedStateExA)
            GET_PROC_ADDR(s_hWinINET, InternetCombineUrlA)
            GET_PROC_ADDR(s_hWinINET, InternetCrackUrlA)
            GET_PROC_ADDR(s_hWinINET, InternetCloseHandle)
            GET_PROC_ADDR(s_hWinINET, InternetReadFile)
            GET_PROC_ADDR(s_hWinINET, InternetConnectA)
            GET_PROC_ADDR(s_hWinINET, InternetOpenA)
            GET_PROC_ADDR(s_hWinINET, HttpQueryInfoA)
            GET_PROC_ADDR(s_hWinINET, HttpOpenRequestA)
            GET_PROC_ADDR(s_hWinINET, HttpAddRequestHeadersA)
            GET_PROC_ADDR(s_hWinINET, HttpSendRequestA)
            GET_PROC_ADDR(s_hWinINET, InternetWriteFile)
            GET_PROC_ADDR(s_hWinINET, HttpEndRequestA)
            GET_PROC_ADDR(s_hWinINET, HttpSendRequestExA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWSOCK32
// --------------------------------------------------------------------------------
BOOL DemandLoadWSOCK32()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWSOCK)
        {
        s_hWSOCK = LoadLibrary("WSOCK32.DLL");
        AssertSz((BOOL)s_hWSOCK, TEXT("LoadLibrary failed on WSOCK32.DLL"));

        if (0 == s_hWSOCK)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWSOCK, WSAStartup)
            GET_PROC_ADDR(s_hWSOCK, WSACleanup)
            GET_PROC_ADDR(s_hWSOCK, WSAGetLastError)
            GET_PROC_ADDR(s_hWSOCK, gethostname)
            GET_PROC_ADDR(s_hWSOCK, gethostbyname)
            GET_PROC_ADDR(s_hWSOCK, WSAAsyncGetHostByName)
            GET_PROC_ADDR(s_hWSOCK, inet_addr)
            GET_PROC_ADDR(s_hWSOCK, htons)
            GET_PROC_ADDR(s_hWSOCK, WSACancelAsyncRequest)
            GET_PROC_ADDR(s_hWSOCK, send)
            GET_PROC_ADDR(s_hWSOCK, connect)
            GET_PROC_ADDR(s_hWSOCK, WSAAsyncSelect)
            GET_PROC_ADDR(s_hWSOCK, socket)
            GET_PROC_ADDR(s_hWSOCK, inet_ntoa)
            GET_PROC_ADDR(s_hWSOCK, closesocket)
            GET_PROC_ADDR(s_hWSOCK, recv)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadSHELL32
// --------------------------------------------------------------------------------
BOOL DemandLoadSHELL32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hShell32)
        {
        s_hShell32 = LoadLibrary("SHELL32.DLL");
        AssertSz((BOOL)s_hShell32, TEXT("LoadLibrary failed on SHELL32.DLL"));

        if (0 == s_hShell32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hShell32, SHGetPathFromIDListA);
            GET_PROC_ADDR(s_hShell32, SHGetSpecialFolderLocation);
            GET_PROC_ADDR_ORDINAL(s_hShell32, SHFree, 195);
            GET_PROC_ADDR(s_hShell32, SHBrowseForFolderA);
            GET_PROC_ADDR(s_hShell32, ShellExecuteA);
            GET_PROC_ADDR(s_hShell32, ShellExecuteExA);
            GET_PROC_ADDR(s_hShell32, DragQueryFileA);
            GET_PROC_ADDR(s_hShell32, SHGetFileInfoA);
            GET_PROC_ADDR(s_hShell32, Shell_NotifyIconA);
            GET_PROC_ADDR(s_hShell32, ExtractIconA);
            GET_PROC_ADDR(s_hShell32, SHFileOperationA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
         
#if 0
// --------------------------------------------------------------------------------
// DemandLoadOLEAUT32
// --------------------------------------------------------------------------------
BOOL DemandLoadOLEAUT32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hOleAut32)
        {
        s_hOleAut32 = LoadLibrary("OLEAUT32.DLL");
        AssertSz((BOOL)s_hOleAut32, TEXT("LoadLibrary failed on OLEAUT32.DLL"));

        if (0 == s_hOleAut32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hOleAut32, SafeArrayCreate);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayPutElement);
            GET_PROC_ADDR(s_hOleAut32, DispInvoke);
            GET_PROC_ADDR(s_hOleAut32, DispGetIDsOfNames);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayDestroy);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetUBound);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetLBound);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetElement);
            GET_PROC_ADDR(s_hOleAut32, SysAllocStringByteLen);
            GET_PROC_ADDR(s_hOleAut32, SysReAllocString);
            GET_PROC_ADDR(s_hOleAut32, SysAllocStringLen);
            GET_PROC_ADDR(s_hOleAut32, SysAllocString);
            GET_PROC_ADDR(s_hOleAut32, SysFreeString);
            GET_PROC_ADDR(s_hOleAut32, SysStringLen);
            GET_PROC_ADDR(s_hOleAut32, VariantInit);
            GET_PROC_ADDR(s_hOleAut32, LoadTypeLib);
            GET_PROC_ADDR(s_hOleAut32, RegisterTypeLib);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayAccessData);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayUnaccessData);
            GET_PROC_ADDR(s_hOleAut32, SysStringByteLen);
            GET_PROC_ADDR(s_hOleAut32, VariantClear);
            GET_PROC_ADDR(s_hOleAut32, VariantCopy);
            GET_PROC_ADDR(s_hOleAut32, SetErrorInfo);
            GET_PROC_ADDR(s_hOleAut32, CreateErrorInfo);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
#endif

// --------------------------------------------------------------------------------
// DemandLoadCOMDLG32
// --------------------------------------------------------------------------------
BOOL DemandLoadCOMDLG32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hComDlg32)
        {
        s_hComDlg32 = LoadLibrary("COMDLG32.DLL");
        AssertSz((BOOL)s_hComDlg32, TEXT("LoadLibrary failed on COMDLG32.DLL"));

        if (0 == s_hComDlg32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hComDlg32, GetSaveFileNameA);
            GET_PROC_ADDR(s_hComDlg32, GetOpenFileNameA);
            GET_PROC_ADDR(s_hComDlg32, ChooseFontA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadVERSION
// --------------------------------------------------------------------------------
BOOL DemandLoadVERSION(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hVersion)
        {
        s_hVersion = LoadLibrary("VERSION.DLL");
        AssertSz((BOOL)s_hVersion, TEXT("LoadLibrary failed on VERSION.DLL"));

        if (0 == s_hVersion)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hVersion, VerQueryValueA);
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoA);
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoSizeA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadURLMON
// --------------------------------------------------------------------------------
BOOL DemandLoadURLMON(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hUrlmon)
        {
        s_hUrlmon = LoadLibrary("URLMON.DLL");
        AssertSz((BOOL)s_hUrlmon, TEXT("LoadLibrary failed on URLMON.DLL"));

        if (0 == s_hUrlmon)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hUrlmon, CreateURLMoniker);
            GET_PROC_ADDR(s_hUrlmon, URLOpenBlockingStreamA);
            GET_PROC_ADDR(s_hUrlmon, FindMimeFromData);
            GET_PROC_ADDR(s_hUrlmon, CoInternetCombineUrl);
            GET_PROC_ADDR(s_hUrlmon, RegisterBindStatusCallback);
            GET_PROC_ADDR(s_hUrlmon, RevokeBindStatusCallback);
            GET_PROC_ADDR(s_hUrlmon, FaultInIEFeature);
            GET_PROC_ADDR(s_hUrlmon, CoInternetGetSecurityUrl);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadMLANG
// --------------------------------------------------------------------------------
BOOL DemandLoadMLANG(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hMLANG)
        {
#ifndef WIN16
        s_hMLANG = LoadLibrary("MLANG.DLL");
#else
        s_hMLANG = LoadLibrary("MLANG16.DLL");
#endif // WIN16
        AssertSz((BOOL)s_hMLANG, TEXT("LoadLibrary failed on MLANG.DLL"));

        if (0 == s_hMLANG)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hMLANG, IsConvertINetStringAvailable)
            GET_PROC_ADDR(s_hMLANG, ConvertINetString)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadSHDOCVW
// --------------------------------------------------------------------------------
BOOL DemandLoadSHDOCVW()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hShDocVw)
        {
        s_hShDocVw = LoadLibrary("SHDOCVW.DLL");
        AssertSz((BOOL)s_hShDocVw, TEXT("LoadLibrary failed on SHDOCVW.DLL"));

        if (0 == s_hShDocVw)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hShDocVw, AddUrlToFavorites);
            GET_PROC_ADDR(s_hShDocVw, SetQueryNetSessionCount);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadINETCPL
// --------------------------------------------------------------------------------
BOOL DemandLoadINETCPL()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hInetCPL)
        {
        s_hInetCPL = LoadLibrary("INETCPL.CPL");
        AssertSz((BOOL)s_hInetCPL, TEXT("LoadLibrary failed on INETCPL.CPL"));

        if (0 == s_hInetCPL)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hInetCPL, OpenFontsDialog);
            GET_PROC_ADDR(s_hInetCPL, LaunchConnectionDialog);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadMSO9
// --------------------------------------------------------------------------------
BOOL DemandLoadMSO9(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hMSO9)
        {
#ifdef DEBUG
        s_hMSO9 = LoadLibrary("mso9d.DLL");
        if (!s_hMSO9)
            s_hMSO9 = LoadLibrary("mso9.DLL");
#else
        s_hMSO9 = LoadLibrary("mso9.DLL");
#endif
        AssertSz((BOOL)s_hMSO9, TEXT("LoadLibrary failed on MSO9.DLL"));

        if (0 == s_hMSO9)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR3(s_hMSO9, _MsoFGetComponentManager@4, MsoFGetComponentManager);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinMM
// --------------------------------------------------------------------------------
BOOL DemandLoadWinMM(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinMM)
        {
        s_hWinMM = LoadLibrary("winmm.dll");
        AssertSz((BOOL)s_hWinMM, TEXT("LoadLibrary failed on WINMM.DLL"));

        if (0 == s_hWinMM)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinMM, sndPlaySoundA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadRichEdit
// --------------------------------------------------------------------------------
BOOL DemandLoadRichEdit(void)
{
    if (!s_hRichEdit)
        {
        s_hRichEdit = LoadLibrary("RICHED32.DLL");
        if (!s_hRichEdit)
            return FALSE;
        }

    return TRUE;
}

// --------------------------------------------------------------------------------
// DemandLoadPStoreC
// --------------------------------------------------------------------------------
BOOL DemandLoadPStoreC()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hPstoreC)
        {
        s_hPstoreC = LoadLibrary("PSTOREC.DLL");
        AssertSz((BOOL)s_hPstoreC, TEXT("LoadLibrary failed on PSTOREC.DLL"));

        if (0 == s_hPstoreC)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hPstoreC, PStoreCreateInstance);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadRAS
// --------------------------------------------------------------------------------
BOOL DemandLoadRAS()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hRAS)
        {
        s_hRAS = LoadLibrary("RASAPI32.DLL");
        AssertSz((BOOL)s_hRAS, TEXT("LoadLibrary failed on RASAPI32.DLL"));

        if (0 == s_hRAS)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hRAS, RasEnumEntriesA)
            GET_PROC_ADDR(s_hRAS, RasEditPhonebookEntryA)
            GET_PROC_ADDR(s_hRAS, RasCreatePhonebookEntryA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
#endif // 0

BOOL IsWin95()
{
    OSVERSIONINFOA       ver;
    ver.dwOSVersionInfoSize = sizeof(ver);

    if (GetVersionExA(&ver))
        {
        return (VER_PLATFORM_WIN32_WINDOWS == ver.dwPlatformId);
        }
    return FALSE;
}

BOOL MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                            LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags)
{
    char        rgch1[256];
    char        rgch2[256];

    if (pszContainer != NULL)
        {
        WideCharToMultiByte(CP_ACP, 0, pszContainer, -1, rgch1, sizeof(rgch1),
                            NULL, NULL);
        pszContainer = (LPWSTR) rgch1;
        }

    if (pszProvider != NULL)
        {
        WideCharToMultiByte(CP_ACP, 0, pszProvider, -1, rgch2, sizeof(rgch2),
                            NULL, NULL);
        pszProvider = (LPWSTR) rgch2;
        }

    return CryptAcquireContextA(phProv, (LPCSTR) pszContainer,
                                (LPCSTR) pszProvider, dwProvType, dwFlags);
}

#if 0
BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hAdvApi)
        {
        s_hAdvApi = LoadLibrary("ADVAPI32.DLL");
        AssertSz((BOOL)s_hAdvApi, TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else
            {
            if (IsWin95())
                CryptAcquireContextW = MyCryptAcquireContextW;
            else
                GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\myassert.h ===
#ifndef _MYASSERT_H_
#define _MYASSERT_H_

#ifdef assert
#error("Can't use two assert systems")
#endif // assert

#ifdef DEBUG
extern const TCHAR SzNull[];
VOID   DigSigAssertFn(LPCTSTR, LPCTSTR, int, LPCTSTR);

#define SZASSERT

#define Assert(condition)               \
        if (!(condition)) {             \
            static const char SZASSERT szExpr[] = #condition; \
            static const char SZASSERT szFile[] = __FILE__; \
            DigSigAssertFn(szExpr, SzNull, __LINE__, szFile); \
        }

#define AssertSz(condition, szInfo)             \
        if (!(condition)) {             \
            static const char SZASSERT szExpr[] = #condition; \
            static const char SZASSERT szFile[] = __FILE__; \
            DigSigAssertFn(szExpr, szInfo, __LINE__, szFile); \
         }

#else  // !DEBUG

#define Assert(condition)

#define AssertSz(condition, szInfo)

#endif // DEBUG

#endif // _MYASSERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\maillist.h ===
BOOL CALLBACK EncMLComposeDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);

class CMailListKey 
{
    DWORD               m_cRef;
    CMailListKey *      m_pmlNext;
    
    LPBYTE              m_pbKeyId;
    DWORD               m_cbKeyId;
    FILETIME            m_ft;
    LPBYTE              m_pbOtherKeyId;
    DWORD               m_cbOtherKeyId;
    DWORD               m_iAlg;
    LPBYTE              m_pbKeyMaterial;
    DWORD               m_cbKeyMaterial;

    HCRYPTKEY           m_hkey;
    HCRYPTPROV          m_hprov;

    HRESULT             LoadKey(CMS_RECIPIENT_INFO *, BOOL);
public:
    CMailListKey();
    ~CMailListKey();

    void        AddRef() { m_cRef += 1; }
    void        Release();
    CMailListKey * Next() { return m_pmlNext; }
    void        Next(CMailListKey * pkey) { m_pmlNext = pkey; return; }

    HRESULT     AddToMessage(IMimeSecurity2 * psm, BOOL);

    LPSTR       FormatKeyName(LPSTR rgch, DWORD cch);
    LPSTR       FormatKeyDate(LPSTR rgch, DWORD cch);
    LPSTR       FormatKeyOther(LPSTR rgch, DWORD cch);
    LPSTR       FormatKeyAlg(LPSTR rgch, DWORD cch);
    LPSTR       FormatKeyData(LPSTR rgch, DWORD cch);

    BOOL        ParseKeyName(LPSTR psz);
    BOOL        ParseKeyDate(LPSTR psz);
    BOOL        ParseKeyOther(LPSTR psz);
    BOOL        ParseKeyData(LPSTR psz);
    BOOL        ParseKeyAlg(int);

    BOOL        LoadKey(HKEY);
    BOOL        SaveKey(HKEY);

    static HRESULT FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipIndex,
                           const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                           CMS_CTRL_DECRYPT_INFO * pDecryptInfo);
};


BOOL CALLBACK MailListDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\receipt.h ===
BOOL FormatNames(DWORD cNames, PCERT_NAME_BLOB rgNames, HWND hwnd, DWORD idc);
BOOL ParseNames(DWORD * pcNames, PCERT_NAME_BLOB * prgNames, HWND hwnd, DWORD idc);
BOOL ReceiptCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\maillist.cpp ===
#include        "item.h"
#include        "maillist.h"
#include        "reg.h"

CMailListKey *          PmlHead = NULL;
extern HINSTANCE        hInst;

#define MLALG_3DES      0
#define MLALG_RC2_40    1
#define MLALG_RC2_128   2

struct {
    LPSTR       szDesc;
} RgAlgs[] = {
    {"3DES"},
    {"RC2 128"},
    {"RC2 40"},
};

BYTE rgbPrivKey[] =
{
0x07, 0x02, 0x00, 0x00, 0x00, 0xA4, 0x00, 0x00,
0x52, 0x53, 0x41, 0x32, 0x00, 0x02, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0xAB, 0xEF, 0xFA, 0xC6,
0x7D, 0xE8, 0xDE, 0xFB, 0x68, 0x38, 0x09, 0x92,
0xD9, 0x42, 0x7E, 0x6B, 0x89, 0x9E, 0x21, 0xD7,
0x52, 0x1C, 0x99, 0x3C, 0x17, 0x48, 0x4E, 0x3A,
0x44, 0x02, 0xF2, 0xFA, 0x74, 0x57, 0xDA, 0xE4,
0xD3, 0xC0, 0x35, 0x67, 0xFA, 0x6E, 0xDF, 0x78,
0x4C, 0x75, 0x35, 0x1C, 0xA0, 0x74, 0x49, 0xE3,
0x20, 0x13, 0x71, 0x35, 0x65, 0xDF, 0x12, 0x20,
0xF5, 0xF5, 0xF5, 0xC1, 0xED, 0x5C, 0x91, 0x36,
0x75, 0xB0, 0xA9, 0x9C, 0x04, 0xDB, 0x0C, 0x8C,
0xBF, 0x99, 0x75, 0x13, 0x7E, 0x87, 0x80, 0x4B,
0x71, 0x94, 0xB8, 0x00, 0xA0, 0x7D, 0xB7, 0x53,
0xDD, 0x20, 0x63, 0xEE, 0xF7, 0x83, 0x41, 0xFE,
0x16, 0xA7, 0x6E, 0xDF, 0x21, 0x7D, 0x76, 0xC0,
0x85, 0xD5, 0x65, 0x7F, 0x00, 0x23, 0x57, 0x45,
0x52, 0x02, 0x9D, 0xEA, 0x69, 0xAC, 0x1F, 0xFD,
0x3F, 0x8C, 0x4A, 0xD0,

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

0x64, 0xD5, 0xAA, 0xB1,
0xA6, 0x03, 0x18, 0x92, 0x03, 0xAA, 0x31, 0x2E,
0x48, 0x4B, 0x65, 0x20, 0x99, 0xCD, 0xC6, 0x0C,
0x15, 0x0C, 0xBF, 0x3E, 0xFF, 0x78, 0x95, 0x67,
0xB1, 0x74, 0x5B, 0x60,

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};

BYTE rgbSymKey[] = 
{
0x01, 0x02, 0x00, 0x00, 0x02, 0x66, 0x00, 0x00,
0x00, 0xA4, 0x00, 0x00, 0xAD, 0x89, 0x5D, 0xDA,
0x82, 0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x02, 0x00
};

int ToInt(char a, char b)
{
    return (a-'0')*10 + b-'0';
}

int ToInt(char a)
{
    return (a-'0');
}

BOOL MSProviderCryptImportKey(HCRYPTPROV hProv, LPBYTE rgbSymKey, DWORD cbSymKey,
                              HCRYPTKEY * phkey)
{
    BOOL fSuccess = FALSE;
    HCRYPTKEY hPrivKey = 0;

    if (!CryptImportKey( hProv,
                         rgbPrivKey,
                         sizeof(rgbPrivKey),
                         0,
                         0,
                         &hPrivKey ))
    {
        goto Ret;
    }

    if (!CryptImportKey( hProv,
                         rgbSymKey,
                         cbSymKey,
                         hPrivKey,
                         0,
                         phkey ))
    {
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (hPrivKey)
        CryptDestroyKey( hPrivKey );

    return fSuccess;
}

////////////////////////////////////////////////////////////////////////////////

BOOL FormatDate(LPSTR rgch, DWORD cch, FILETIME ft)
{
    int                 cch2;
    LPWSTR              pwsz;
    SYSTEMTIME          st;

    if (!FileTimeToSystemTime(&ft, &st)) {
        return FALSE;
    }

    cch2 = GetDateFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, rgch, cch);
    cch2 -= 1;
    rgch[cch2++] = ' ';

    GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL,
                   &rgch[cch2], cch-cch2);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////

CMailListKey::CMailListKey()
{
    m_cRef = 1;
    m_pmlNext = NULL;
    
    m_cbKeyId = 0;
    m_pbKeyId = NULL;

    memset(&m_ft, 0, sizeof(m_ft));
    
    m_cbOtherKeyId = 0;
    m_pbOtherKeyId = NULL;

    m_iAlg = -1;

    m_cbKeyMaterial = 0;
    m_pbKeyMaterial = NULL;

    m_hprov = NULL;
    m_hkey = NULL;
}

CMailListKey::~CMailListKey()
{
    AssertSz(m_cRef == 0, "CMailListKey ref count != 0");
    if (m_pbKeyId != NULL)              free(m_pbKeyId);
    if (m_pbOtherKeyId != NULL)         free(m_pbOtherKeyId);
    if (m_pbKeyMaterial != NULL)        free(m_pbKeyMaterial);
    if (m_hkey != NULL)                 CryptDestroyKey(m_hkey);
    if (m_hprov != NULL)                CryptReleaseContext(m_hprov, 0);
}

void CMailListKey::Release()
{
    m_cRef -= 1;
    if (m_cRef == 0) delete this;
    return;
}

LPSTR CMailListKey::FormatKeyName(LPSTR rgch, DWORD cch)
{
    AssertSz(m_cbKeyId > 0, "Must have some key id");
    memcpy(rgch, m_pbKeyId, min(cch, m_cbKeyId+1));
    rgch[min(cch-1, m_cbKeyId)] = 0;
    return rgch;
}

LPSTR CMailListKey::FormatKeyDate(LPSTR rgch, DWORD cch)
{
    if (m_ft.dwHighDateTime == 0) {
        rgch[0] = 0;
    }
    else {
        FormatDate(rgch, cch, m_ft);
    }
    return rgch;
}

LPSTR CMailListKey::FormatKeyOther(LPSTR rgch, DWORD cch)
{
    memcpy(rgch, m_pbOtherKeyId, min(cch, m_cbOtherKeyId));
    rgch[cch-1] = 0;
    return rgch;
}

LPSTR CMailListKey::FormatKeyAlg(LPSTR rgch, DWORD cch)
{
    AssertSz((MLALG_3DES <= m_iAlg) && (m_iAlg <= MLALG_RC2_128),
             "Must have some key Algorithm");
    Assert(cch > strlen(RgAlgs[m_iAlg].szDesc));
    strcpy(rgch, RgAlgs[m_iAlg].szDesc);
    return rgch;
}

LPSTR CMailListKey::FormatKeyData(LPSTR rgch, DWORD cch)
{
    AssertSz(m_cbKeyMaterial > 0, "Must have some key material");
    memcpy(rgch, m_pbKeyMaterial, min(cch, m_cbKeyMaterial));
    rgch[cch-1] = 0;
    return rgch;
}

BOOL CMailListKey::ParseKeyName(LPSTR psz)
{
    if (m_pbKeyId != NULL) {
        LocalFree(m_pbKeyId);
    }
    m_pbKeyId = (LPBYTE) LocalAlloc(0, strlen(psz));
    if (m_pbKeyId == NULL) {
        return FALSE;
    }

    m_cbKeyId = strlen(psz);
    memcpy(m_pbKeyId, psz, strlen(psz));

    return TRUE;
}

BOOL CMailListKey::ParseKeyData(LPSTR psz)
{
    char        ch1;
    char        ch2;
    DWORD       cb;
    LPBYTE      pb;
    BYTE        rgb[50];

    for (cb = 0, pb = rgb; *psz != 0; cb++, pb++) {
        ch1 = *psz++;
        if (('0' <= ch1) && (ch1 <= '9')) ch1 -= '0';
        else if (('a' <= ch1) && (ch1 <= 'f')) ch1 -= 'a' - 10;
        else if (('A' <= ch1) && (ch1 <= 'F')) ch1 -= 'A' - 10;
        else {
            return FALSE;
        }
        
        ch2 = *psz++;
        if (ch2 == 0) return FALSE;
        else if (('0' <= ch2) && (ch2 <= '9')) ch2 -= '0';
        else if (('a' <= ch2) && (ch2 <= 'f')) ch2 -= 'a' - 10;
        else if (('A' <= ch2) && (ch2 <= 'F')) ch2 -= 'A' - 10;
        else {
            return FALSE;
        }

        *pb = (ch1 << 4) | ch2;
    }
    
    if (m_pbKeyMaterial != NULL) {
        LocalFree(m_pbKeyMaterial);
    }

    switch(m_iAlg) {
    case MLALG_3DES:
        if (cb != 196/8) return FALSE;
        break;

    case MLALG_RC2_40:
        if (cb < 40/8) return FALSE;
        break;

    case MLALG_RC2_128:
        if (cb < 128/8) return FALSE;
        break;

    default:
        Assert(FALSE);
        return FALSE;
    }
    
    m_pbKeyMaterial = (LPBYTE) LocalAlloc(0, cb);
    if (m_pbKeyMaterial == NULL) {
        return FALSE;
    }

    m_cbKeyMaterial = cb;
    memcpy(m_pbKeyMaterial, rgb, cb);
    return TRUE;
}

BOOL CMailListKey::ParseKeyOther(LPSTR psz)
{
    return TRUE;
}

BOOL CMailListKey::ParseKeyDate(LPSTR psz)
{
    DWORD       cb;
    SYSTEMTIME  st = {0};
    
    cb = strlen(psz);
    if ((cb != 12) && (cb != 14)) {
        MessageBox(NULL, "Date format is YYMMDDHHMMSS or YYYYMMDDHHMMSS", "smimetst", MB_OK);
        return FALSE;
    }

    if (cb == 12) {
        st.wYear = ToInt(psz[0], psz[1]) + 1900;
    }
    else {
        st.wYear = ToInt(psz[0])*1000 + ToInt(psz[1])*100 + ToInt(psz[2], psz[3]);
        psz += 2;
    }

    st.wMonth = ToInt(psz[2], psz[3]);
    st.wDay = ToInt(psz[4], psz[5]);
    st.wHour = ToInt(psz[6], psz[7]);
    st.wMinute = ToInt(psz[8], psz[9]);
    st.wSecond = ToInt(psz[10], psz[11]);

    SystemTimeToFileTime(&st, &m_ft);
    
    return TRUE;
}

BOOL CMailListKey::ParseKeyAlg(int i)
{
    m_iAlg = i;
    return TRUE;
}

BOOL CMailListKey::LoadKey(HKEY hkey)
{
    DWORD       cb;
    DWORD       dwType;
    
    RegGetBinary(hkey, "KeyId", &m_pbKeyId, &m_cbKeyId);
    RegGetLong(hkey, "Key Type", &m_iAlg);
    RegGetBinary(hkey, "Key Material", &m_pbKeyMaterial, &m_cbKeyMaterial);
    RegGetBinary(hkey, "Other Id", &m_pbOtherKeyId, &m_cbOtherKeyId);

    cb = sizeof(m_ft);
    RegQueryValueEx(hkey, "Time", 0, &dwType, (LPBYTE) &m_ft, &cb);
    return TRUE;
}
    

BOOL CMailListKey::SaveKey(HKEY hkey)
{
    DWORD       dwDisp;
    HKEY        hkey2 = NULL;
    char        rgch[256];

    FormatKeyName(rgch, sizeof(rgch));
    if (RegCreateKeyEx(hkey, (LPSTR) rgch, 0, NULL, 0, KEY_WRITE, NULL,
                       &hkey2, &dwDisp)) {
        goto exit;
    }
    RegSaveBinary(hkey2, "KeyId", m_pbKeyId, m_cbKeyId);
    RegSaveLong(hkey2, "Key Type", m_iAlg);
    RegSaveBinary(hkey2, "Key Material", m_pbKeyMaterial, m_cbKeyMaterial);
    if (m_pbOtherKeyId != NULL) {
        RegSaveBinary(hkey2, "Other Id", m_pbOtherKeyId, m_cbOtherKeyId);
    }
    if (m_ft.dwHighDateTime != 0) {
        RegSaveBinary(hkey2, "Time", (LPBYTE) &m_ft, sizeof(m_ft));
    }

exit:
    if (hkey2 != NULL)          RegCloseKey(hkey2);
    return TRUE;
}

HRESULT CMailListKey::LoadKey(CMS_RECIPIENT_INFO * precipInfo, BOOL fUsePrivateCSPs)
{
    CMSG_RC2_AUX_INFO           aux;
    DWORD                       dwProvType;
    HRESULT                     hr;
    DWORD                       i;
    DWORD                       kt;
    LPBYTE                      pb;
    BLOBHEADER *                pbhdr;
    LPSTR                       pszProvider = NULL;
    BYTE                        rgb[sizeof(rgbSymKey)];

    switch(m_iAlg) {
    case MLALG_3DES:
        precipInfo->KeyEncryptionAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMS3DESwrap;
        kt = CALG_3DES;
        if (!fUsePrivateCSPs) {
            pszProvider = MS_ENHANCED_PROV;
        }
        dwProvType = PROV_RSA_FULL;
        break;

    case MLALG_RC2_40:
        precipInfo->KeyEncryptionAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMSRC2wrap;
        aux.cbSize = sizeof(aux);
        aux.dwBitLen = 40;
        precipInfo->pvKeyEncryptionAuxInfo = (DWORD *) &aux;
        kt = CALG_RC2;
        if (!fUsePrivateCSPs) {
            pszProvider = MS_DEF_PROV;
        }
        dwProvType = PROV_RSA_FULL;
        break;

    case MLALG_RC2_128:
        precipInfo->KeyEncryptionAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMSRC2wrap;
        aux.cbSize = sizeof(aux);
        aux.dwBitLen = 128;
        precipInfo->pvKeyEncryptionAuxInfo = (DWORD *) &aux;
        if (!fUsePrivateCSPs) {
            pszProvider = MS_ENHANCED_PROV;
        }
        kt = CALG_RC2;
        dwProvType = PROV_RSA_FULL;
        break;
    }
    
    precipInfo->dwU1 = CMS_RECIPIENT_INFO_PUBKEY_PROVIDER;
    Assert(m_hprov == NULL);
    Assert(m_hkey == NULL);
#if 1
        // try to open the enhanced provider
    if (!CryptAcquireContext( &m_hprov, "iD2ImportKey", pszProvider, dwProvType,
                              0 )) {
        if (!CryptAcquireContext( &m_hprov, "iD2ImportKey", pszProvider,
                                  dwProvType, CRYPT_NEWKEYSET )) {
            hr = E_FAIL;
            goto exit;
        }
    }

#else // 0 // use this code for exchcsp.dll acting as an rsa provider
    if (!CryptAcquireContext(&m_hprov, NULL, pszProvider, dwProvType,
                             CRYPT_VERIFYCONTEXT)) {
        hr = E_FAIL;
        goto exit;
    }
#endif // 1

    
    memcpy(rgb, rgbSymKey, sizeof(rgbSymKey));

    pbhdr = (BLOBHEADER *) rgb;
    pbhdr->aiKeyAlg = kt;
    pb = &rgb[sizeof(*pbhdr)];
    *((ALG_ID *) pb) = CALG_RSA_KEYX;

    pb += sizeof(ALG_ID);
    for (i=0; i<m_cbKeyMaterial; i++) {
        pb[m_cbKeyMaterial-i-1] = m_pbKeyMaterial[i];
    }
    pb[m_cbKeyMaterial] = 0;

    if (!MSProviderCryptImportKey(m_hprov, rgb, sizeof(rgb), &m_hkey)) {
        hr = E_FAIL;
        CryptReleaseContext(m_hprov, 0);
        m_hprov = NULL;
        goto exit;
    }

    hr = S_OK;
exit:
    return hr;
}

HRESULT CMailListKey::AddToMessage(IMimeSecurity2 * psm, BOOL fUsePrivateCSPs)
{
    CMSG_RC2_AUX_INFO           aux;
    DWORD                       dwProvType;
    HRESULT                     hr;
    DWORD                       i;
    DWORD                       kt;
    LPBYTE                      pb;
    BLOBHEADER *                pbhdr;
    LPSTR                       pszProvider;
    CMS_RECIPIENT_INFO          recipInfo = {0};
    BYTE                        rgb[sizeof(rgbSymKey)];

    hr = LoadKey(&recipInfo, fUsePrivateCSPs);
    if (FAILED(hr)) {
        goto exit;
    }
    
    //    recipInfo.cbSize = sizeof(recipInfo);
    recipInfo.dwRecipientType = /*CMS_RECIPIENT_INFO_KEK*/ 3;
    
    recipInfo.u1.u2.hprov = m_hprov;
    recipInfo.u1.u2.hkey = m_hkey;
    
    recipInfo.dwU3 = CMS_RECIPIENT_INFO_KEYID_KEY_ID;
    recipInfo.u3.KeyId.pbData = m_pbKeyId;
    recipInfo.u3.KeyId.cbData = m_cbKeyId;

    if (m_ft.dwHighDateTime != 0) {
        recipInfo.filetime = m_ft;
    }
    if (m_cbOtherKeyId != 0) {
        // M00BUG -- need to set other key id
        //        recipInfo.pOtherAttr =;
    }

    hr = psm->AddRecipient(0, 1, &recipInfo);

exit:
    return hr;
}

HRESULT CMailListKey::FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipIndex,
                                  const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                                  CMS_CTRL_DECRYPT_INFO * pDecryptInfo)
{
    HRESULT             hr;
    CMS_RECIPIENT_INFO  recipInfo = {0};
    CMailListKey *      pml;

    for (pml = PmlHead; pml != NULL; pml = pml->Next()) {
        if ((pRecipInfo->pMailList->KeyId.cbData == pml->m_cbKeyId) &&
            (memcmp(pRecipInfo->pMailList->KeyId.pbData,
                    pml->m_pbKeyId, pml->m_cbKeyId) == 0) &&
            (memcmp(&pRecipInfo->pMailList->Date,
                    &pml->m_ft, sizeof(FILETIME)) == 0)) {
            // M00BUG -- need to check for otherkeyid still.
            break;
        }
    }

    if (pml == NULL) {
        return S_FALSE;
    }

    hr = pml->LoadKey(&recipInfo, FALSE);
    if (FAILED(hr)) {
        return hr;
    }

    pDecryptInfo->maillist.cbSize = sizeof(CMSG_CTRL_MAIL_LIST_DECRYPT_PARA);
    pDecryptInfo->maillist.hCryptProv = pml->m_hprov;
    pDecryptInfo->maillist.pMailList = pRecipInfo->pMailList;
    pDecryptInfo->maillist.dwRecipientIndex = dwRecipIndex;
    pDecryptInfo->maillist.dwKeyChoice = CMSG_MAIL_LIST_HANDLE_KEY_CHOICE;
    pDecryptInfo->maillist.hKeyEncryptionKey = pml->m_hkey;

    pml->m_hprov = NULL;
    pml->m_hkey = NULL;
    return S_OK;
}
    
////////////////////////////////////////////////////////////////////////////////


BOOL CALLBACK MailListAddDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMailListKey *      pkey;
    char                rgch[100];
    
    switch (msg) {
    case WM_INITDIALOG:
        SendDlgItemMessage(hdlg, IDC_AMLK_ALG, CB_ADDSTRING, 0, (LPARAM) "3DES");
        SendDlgItemMessage(hdlg, IDC_AMLK_ALG, CB_ADDSTRING, 0, (LPARAM) "RC2 128");
        SendDlgItemMessage(hdlg, IDC_AMLK_ALG, CB_ADDSTRING, 0, (LPARAM) "RC2 40");
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            pkey = new CMailListKey();
            
            GetDlgItemText(hdlg, IDC_AMLK_ID, rgch, sizeof(rgch));
            if (!pkey->ParseKeyName(rgch)) {
                goto fail;
            }
            
            pkey->ParseKeyAlg(SendDlgItemMessage(hdlg, IDC_AMLK_ALG, CB_GETCURSEL, 0, 0));
            
            GetDlgItemText(hdlg, IDC_AMLK_KEY, rgch, sizeof(rgch));
            if (!pkey->ParseKeyData(rgch)) {
                goto fail;
            }
            
            GetDlgItemText(hdlg, IDC_AMLK_DATE, rgch, sizeof(rgch));
            if (!pkey->ParseKeyDate(rgch)) {
                goto fail;
            }
            
            GetDlgItemText(hdlg, IDC_AMLK_OTHER, rgch, sizeof(rgch));
            if (!pkey->ParseKeyOther(rgch)) {
                goto fail;
            }

            pkey->Next(PmlHead);
            PmlHead = pkey;
            
            EndDialog(hdlg, IDOK);
            break;

        fail:
            pkey->Release();
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        default:
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void InsertItem(HWND hwnd, int iItem, CMailListKey * pml)
{
    int                 k;
    LV_ITEM             lvI;
    char                rgch[256];
    
    lvI.mask = LVIF_PARAM /* | LVIF_STATE | LVIF_IMAGE*/ | LVIF_TEXT;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.iImage = 0;
    lvI.lParam = (DWORD) pml;
    lvI.iItem = iItem;
            
    pml->FormatKeyName(rgch, sizeof(rgch));
    lvI.pszText = rgch;

    k = ListView_InsertItem(hwnd, &lvI);

    ListView_SetItemText(hwnd, k, 2, pml->FormatKeyDate(rgch, sizeof(rgch)));
    ListView_SetItemText(hwnd, k, 3, pml->FormatKeyOther(rgch, sizeof(rgch)));
    ListView_SetItemText(hwnd, k, 4, pml->FormatKeyAlg(rgch, sizeof(rgch)));
    ListView_SetItemText(hwnd, k, 5, pml->FormatKeyData(rgch, sizeof(rgch)));
    return;
}    

BOOL CALLBACK MailListDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMailListKey *      pmlItem;
    HWND                hwnd;
    int                 i;
    LV_COLUMN           lvC;
    LV_ITEM             lvI;
    char                rgch[256];
    
    switch (msg) {
    case WM_INITDIALOG:
        hwnd = GetDlgItem(hdlg, IDC_FML_LIST);

        //  Insert columns
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvC.fmt = LVCFMT_LEFT;          // Left justify column
        lvC.cx = 650/5;

        lvC.pszText = "Key Name";
        ListView_InsertColumn(hwnd, 0, &lvC);

        lvC.pszText = "Date";
        ListView_InsertColumn(hwnd, 1, &lvC);

        lvC.pszText = "Other";
        ListView_InsertColumn(hwnd, 2, &lvC);

        lvC.pszText = "Algorithm";
        ListView_InsertColumn(hwnd, 3, &lvC);

        lvC.pszText = "Key Data";
        ListView_InsertColumn(hwnd, 4, &lvC);

        for (i=0, pmlItem = PmlHead; pmlItem != NULL; pmlItem = pmlItem->Next()) {
            InsertItem(hwnd, i, pmlItem);
        }

        if (ListView_GetSelectedCount(hwnd) == 0) {
            EnableWindow(GetDlgItem(hdlg, IDC_FML_DELETE), FALSE);
        }
        SendMessage(hwnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog(hdlg, 0);
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        case IDC_FML_ADD:
            if (DialogBox(hInst, MAKEINTRESOURCE(IDD_FILE_ADD_ML), hdlg,
                          MailListAddDlgProc) == IDOK) {
                hwnd = GetDlgItem(hdlg, IDC_FML_LIST);
                InsertItem(hwnd, 100, PmlHead);
            }
            break;

        case IDC_FML_DELETE:
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

DWORD GetMailListKeys(HKEY hkey)
{
    DWORD               cbData;
    DWORD               dw;
    FILETIME            ft;
    HKEY                hkey2;
    DWORD               i;
    CMailListKey *      pml;
    char                rgch[256];
    
    for (i=0; TRUE; i++) {
        cbData = sizeof(rgch);
        dw = RegEnumKeyEx(hkey, i, rgch, &cbData, NULL, NULL, NULL, &ft);
        if (dw != ERROR_SUCCESS) {
            break;
        }

        dw = RegOpenKey(hkey, rgch, &hkey2);

        pml = new CMailListKey;
        if (pml->LoadKey(hkey2)) {
            pml->Next(PmlHead);
            PmlHead = pml;
        }
        RegCloseKey(hkey2);
    }
    return 0;
}

DWORD SaveMailListKeys(HKEY hkey)
{
    CMailListKey *              pml;

    for (pml = PmlHead; pml != NULL; pml = pml->Next()) {
        pml->SaveKey(hkey);
    }
    
    return 0;
}

///////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EncMLComposeDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cItems;
    BOOL                        f;
    DWORD                       i;
    DWORD                       i1;
    static CEnvMailList *       peml = NULL;
    CMailListKey *              pml;
    CMailListKey *              pml1;
    CHAR                        rgch[300];
    
    switch (msg) {
    case WM_INITDIALOG:
        for (pml = PmlHead; pml != NULL; pml = pml->Next()) {
            pml->FormatKeyName(rgch, sizeof(rgch));
            i = SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_ADDSTRING, 0, (LPARAM) rgch);
            SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_SETITEMDATA, i, (LPARAM) pml);
        }
        break;

    case UM_SET_DATA:
        cItems = SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_GETCOUNT, 0, 0);

        if (peml != NULL) {
            for (i=i1=0; i<cItems; i++) {
                if (SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_GETSEL, i, 0)) {
                    i1 += 1;
                }
            }

            if (peml->m_rgKeys != NULL) {
                LocalFree(peml->m_rgKeys);
            }
            peml->m_rgKeys = (CMailListKey **) LocalAlloc(0, i1*sizeof(CMailListKey*));
            for (i=i1=0; i<cItems; i++) {
                if (SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_GETSEL, i, 0)) {
                    peml->m_rgKeys[i1] = (CMailListKey *) SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_GETITEMDATA, i, 0);
                    i1 += 1;
                }
            }
            peml->m_cKeys = i1;
        }
        
        peml = (CEnvMailList *) lParam;
        if (peml != NULL) {
            Assert(peml->GetType() == TYPE_ENV_MAILLIST);
        
            //  Fill in the dialog

            if ((peml != NULL) && (peml->m_cKeys != NULL)) {
                for (i=0; i<cItems; i++) {
                    pml1 = (CMailListKey *) SendDlgItemMessage(hdlg, IDC_MLC_ID,
                                                               LB_GETITEMDATA, i, 0);
                    for (i1=0, f = FALSE; i1<peml->m_cKeys; i1++) {
                        if (peml->m_rgKeys[i1] == pml1) {
                            f = TRUE;
                            break;
                        }
                    }
                    SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_SETSEL, i, f);
                }
            }
            else {
                for (i=0; i<cItems; i++) {
                    SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_SETSEL, i, FALSE);
                }
            }
        }
        
        SendDlgItemMessage(hdlg, IDC_MLC_CSPS, BM_SETCHECK,
                           ((peml != NULL) && (peml->m_fUsePrivateCSPs)), 0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case MAKELONG(IDC_MLC_CSPS, BN_CLICKED):
            peml->m_fUsePrivateCSPs = SendDlgItemMessage(hdlg, IDC_MLC_CSPS,
                                                         BM_GETCHECK, 0, 0);
            return FALSE;

        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }
    return TRUE;
}

///////////////////////////////////////////////////////

HRESULT CEnvMailList::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm,
                                   HWND hwnd)
{
    HRESULT     hr;
    DWORD       i;
    IMimeBody *         pmb = NULL;
    IMimeSecurity2 *    psm = NULL;

    //  Pull out the body interface to set security properties
    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))             goto exit;

    hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID*) &psm);
    if (FAILED(hr))             goto exit;

    for (i=0; i<m_cKeys; i++) {
        hr = m_rgKeys[i]->AddToMessage(psm, m_fUsePrivateCSPs);
        if (FAILED(hr)) {
            goto exit;
        }
    }
    hr = S_OK;
    
exit:
    if (psm != NULL)            psm->Release();
    if (pmb != NULL)            pmb->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\receipt.cpp ===
#include "item.h"

#ifndef CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG
#define CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG 0
#endif

BOOL FormatNames(DWORD cNames, PCERT_NAME_BLOB rgNames, HWND hwnd, DWORD idc)
{
    DWORD                       cb;
    BOOL                        f;
    DWORD                       i;
    DWORD                       i1;
    DWORD                       i2;
    PCERT_ALT_NAME_INFO         pname = NULL;
    WCHAR                       rgwch[4096];
    
    rgwch[0] = 0;

    for (i1=0; i1<cNames; i1++) {
        f = CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                rgNames[i1].pbData, rgNames[i1].cbData,
                                CRYPT_ENCODE_ALLOC_FLAG, NULL, &pname, &cb);
        if (!f) break;

        for (i2=0; i2<pname->cAltEntry; i2++) {
            if (i2 > 0) {
                wcscat(rgwch, L"  ");
            }
            switch( pname->rgAltEntry[i2].dwAltNameChoice ) {
            case CERT_ALT_NAME_RFC822_NAME:
                wcscat(rgwch, L"SMTP: ");
                wcscat(rgwch, pname->rgAltEntry[i2].pwszRfc822Name);
                wcscat(rgwch, L"\r\n");
                break;

            case CERT_ALT_NAME_DIRECTORY_NAME:
                break;
            }
        }
        free(pname);
        pname = NULL;
    }

    if (f) SetDlgItemTextW(hwnd, idc, rgwch);
    return f;
}

BOOL ParseNames(DWORD * pcNames, PCERT_NAME_BLOB * prgNames, HWND hwnd, DWORD idc)
{
    DWORD               cb;
    DWORD               cEntry = 0;
    DWORD               cNames = 0;
    BOOL                f;
    DWORD               i;
    LPWSTR              pwsz;
    LPWSTR              pwsz1;
    CRYPT_DER_BLOB      rgDer[50] = {0};
    CERT_ALT_NAME_INFO  rgNames[50] = {0};
    CERT_ALT_NAME_ENTRY rgEntry[200] = {0};
    WCHAR               rgwch[4096];

    GetDlgItemTextW(hwnd, idc, rgwch, sizeof(rgwch)/sizeof(WCHAR));
    rgwch[4095] = 0;
    
    pwsz = rgwch;

    while (*pwsz != 0) {
        if (cEntry == 200) {
            MessageBox(hwnd, "Can't have more than 200 entries", "smimetst", MB_OK);
            return FALSE;
        }

        if (*pwsz == ' ') {
            while (*pwsz == ' ') pwsz++;
            rgNames[cNames-1].cAltEntry += 1;
        }
        else {
            if (cNames == 50) {
                MessageBox(hwnd, "Can't have more than 50 names", "smimetst", MB_OK);
                return FALSE;
            }
            cNames += 1;
            rgNames[cNames-1].rgAltEntry = &rgEntry[cEntry];
            rgNames[cNames-1].cAltEntry = 1;
        }

        if (_wcsnicmp(pwsz, L"SMTP:", 5) == 0) {
            pwsz += 5;
            while (*pwsz == ' ') pwsz++;
            rgEntry[cEntry].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
            rgEntry[cEntry].pwszRfc822Name = pwsz;
            while ((*pwsz != 0) && (*pwsz != '\n') && (*pwsz != '\r')) pwsz++;
        }
        else if (_wcsnicmp(pwsz, L"X500:", 5) == 0) {
            pwsz += 5;
            while (*pwsz == ' ') pwsz++;
            for (pwsz1 = pwsz; ((*pwsz != 0) && (*pwsz != '\n') &&
                                (*pwsz != '\r')); pwsz++);
            if (*pwsz != 0) {
                *pwsz = 0;
                pwsz++;
            }
            
            rgEntry[cEntry].dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
            f = CertStrToNameW(X509_ASN_ENCODING, pwsz1, 
                               CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG, NULL,
                               NULL, &cb, NULL);
            if (!f) {
                MessageBox(hwnd, "X500 name does not parse", "smimetst", MB_OK);
                return FALSE;
            }
            
            rgEntry[cEntry].DirectoryName.pbData = (LPBYTE) malloc(cb);
            f = CertStrToNameW(X509_ASN_ENCODING, pwsz1,
                               CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG, NULL, 
                               rgEntry[cEntry].DirectoryName.pbData, &cb,
                               NULL);
            if (!f) return FALSE;
            rgEntry[cEntry].DirectoryName.cbData = cb;
        }
        else {
            MessageBox(hwnd, "unknown address type", "smimetst", MB_OK);
            return FALSE;
        }

        if (*pwsz == '\r') {
            *pwsz = 0;
            pwsz++;
        }
        if (*pwsz == '\n') {
            *pwsz = 0;
            pwsz++;
        }
        cEntry += 1;
    }

    *prgNames = (PCERT_NAME_BLOB) malloc(sizeof(CERT_NAME_BLOB) * cNames);
    if (*prgNames == NULL) return FALSE;
    
    for (i=0; i<cNames; i++) {
        f = CryptEncodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                &rgNames[i], CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                &(*prgNames)[i].pbData, &(*prgNames)[i].cbData);
        if (!f) return f;
    }
    *pcNames = cNames;
    return f;
}

BOOL ReceiptCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    DWORD                       cbNames;
    BOOL                        f;
    LPBYTE                      pb;
    PSMIME_RECEIPT_REQUEST      pReceipt;
    static CSignData *          psd = NULL;
    CHAR                        rgchContent[256];
    SMIME_RECEIPT_REQUEST       receipt;
    
    switch (message) {
    case WM_INITDIALOG:
        pReceipt = NULL;

        psd = (CSignData *) lParam;
        psd->GetReceiptData(&pb, &cbNames);
        f = CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Receipt_Request,
                                pb, cbNames, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                &pReceipt, &cb);

        if (pReceipt) {
            //  Set Content Identifier -- M00TODO
            SetDlgItemText(hwnd, IDC_RC_CONTENT,
                           (LPSTR) pReceipt->ContentIdentifier.pbData);

            //  Set Top buttons -
            // M00BUG
            if (pReceipt->ReceiptsFrom.cNames > 0) {
                FormatNames(pReceipt->ReceiptsFrom.cNames,
                            pReceipt->ReceiptsFrom.rgNames, hwnd, IDC_RC_FROM_TEXT);
            }

            //  Set ReceiptsTo
            FormatNames(pReceipt->cReceiptsTo, pReceipt->rgReceiptsTo, hwnd,
                        IDC_RC_TO_TEXT);
        }
        else {
            FormatNames(CMyNames, RgMyNames, hwnd, IDC_RC_TO_TEXT);
        }
        break;

    case WM_COMMAND:
        switch(wParam) {
        case MAKELONG(IDC_RC_FROM_ALL, BN_CLICKED):
        case MAKELONG(IDC_RC_FROM_TOP, BN_CLICKED):
            EnableWindow(GetDlgItem(hwnd, IDC_RC_FROM_TEXT), FALSE);
            break;
            
        case MAKELONG(IDC_RC_FROM_SOME, BN_CLICKED):
            EnableWindow(GetDlgItem(hwnd, IDC_RC_FROM_TEXT), TRUE);
            break;
            
        case IDOK:
            memset(&receipt, 0, sizeof(receipt));

            GetDlgItemText(hwnd, IDC_RC_CONTENT,
                           rgchContent, sizeof(rgchContent));
            receipt.ContentIdentifier.pbData = (LPBYTE) rgchContent;
            receipt.ContentIdentifier.cbData = strlen(rgchContent);

            if (SendMessage(GetDlgItem(hwnd, IDC_RC_FROM_ALL), BM_GETCHECK, 0, 0)) {
                receipt.ReceiptsFrom.AllOrFirstTier = SMIME_RECEIPTS_FROM_ALL;
            }
            else if (SendMessage(GetDlgItem(hwnd, IDC_RC_FROM_TOP), BM_GETCHECK, 0, 0)) {
                receipt.ReceiptsFrom.AllOrFirstTier = SMIME_RECEIPTS_FROM_FIRST_TIER;
            }
            else {
                receipt.ReceiptsFrom.AllOrFirstTier = 0;
                if (!ParseNames(&receipt.ReceiptsFrom.cNames,
                                &receipt.ReceiptsFrom.rgNames,
                                hwnd, IDC_RC_FROM_TEXT)) {
                    return FALSE;
                }
            }

            if (!ParseNames(&receipt.cReceiptsTo, &receipt.rgReceiptsTo,
                            hwnd, IDC_RC_TO_TEXT)) {
                free(receipt.ReceiptsFrom.rgNames);
                return FALSE;
            }
            
            f = CryptEncodeObjectEx(X509_ASN_ENCODING,
                                    szOID_SMIME_Receipt_Request, &receipt,
                                    CRYPT_ENCODE_ALLOC_FLAG, NULL, &pb, &cb);
    

            free(receipt.ReceiptsFrom.rgNames);
            free(receipt.rgReceiptsTo);
            if (!f) return FALSE;
            
            psd->SetReceiptData(pb, cb);
            
            // 
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\reg.h ===
#define CCH_OPTION_STRING   (MAX_PATH + 1)

extern void SaveOptions(void);
extern void GetOptions(void);
extern void CleanupOptions(void);
extern BOOL OptionsDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

DWORD RegGetLong(HKEY hKey, LPTSTR szName, ULONG * plData);
DWORD RegGetBinary(HKEY hKey, LPTSTR szName, LPBYTE * ppData, ULONG * lpcbData);
DWORD RegSaveLong(HKEY hKey, LPTSTR szName, ULONG lData);
DWORD RegSaveBinary(HKEY hKey, LPTSTR szName, LPBYTE pData, ULONG cbData);


extern TCHAR szSenderEmail[];
extern TCHAR szSenderName[];
extern SBinary SenderEntryID;
extern TCHAR szRecipientEmail[];
extern TCHAR szRecipientName[];
extern SBinary RecipientEntryID;
extern TCHAR szOutputFile[];
extern TCHAR szInputFile[];
extern CRYPT_HASH_BLOB SignHash;
extern DWORD                    CMyNames;
extern PCERT_NAME_BLOB          RgMyNames;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\smtpcall.h ===
// --------------------------------------------------------------------------------
// Smtpcall.h
// --------------------------------------------------------------------------------
#ifndef __SMTPCALL_H
#define __SMTPCALL_H
#include "imnxport.h"

HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP);

// --------------------------------------------------------------------------------
// CSMTPCallback Implementation
// --------------------------------------------------------------------------------
class CSMTPCallback : public ISMTPCallback
{
private:
    ULONG m_cRef;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CSMTPCallback(void);
    ~CSMTPCallback(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // ISMTPCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPSMTPRESPONSE              pResponse);
};

#endif // __SMTPCALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\reg.cpp ===
/*
 * REG.c  Registry functions
 *
 */

#include <windows.h>
#include <cryptdlg.h>
#include <wab.h>
#include "demand.h"
#include "data.h"
#include "reg.h"
#include "smimetst.h"
#include "receipt.h"


// Options
TCHAR szSenderEmail[CCH_OPTION_STRING] = "";
TCHAR szSenderName[CCH_OPTION_STRING]  = "";
SBinary SenderEntryID = {0};
TCHAR szRecipientEmail[CCH_OPTION_STRING]  = "";
TCHAR szRecipientName[CCH_OPTION_STRING]  = "";
SBinary RecipientEntryID = {0};
TCHAR szOutputFile[CCH_OPTION_STRING]  = "c:\\SMimeTst.eml";
TCHAR szInputFile[CCH_OPTION_STRING]  = "";
CRYPT_HASH_BLOB SignHash = {0, NULL};
DWORD                   CMyNames = 0;
PCERT_NAME_BLOB         RgMyNames = {0};


const TCHAR szRegKey[] = "Software\\Microsoft\\SMimeTest";

DWORD SaveMailListKeys(HKEY);
DWORD GetMailListKeys(HKEY);


DWORD RegSaveLong(HKEY hKey, LPTSTR szName, ULONG lData) {
    DWORD dwErr;

    dwErr = RegSetValueEx(hKey, szName, 0, REG_DWORD, (LPBYTE)&lData, sizeof(lData));

    return(dwErr);
}

DWORD RegSaveShort(HKEY hKey, LPTSTR szName, USHORT sData) {
    return(RegSaveLong(hKey, szName, (ULONG)sData));
}

DWORD RegSaveBinary(HKEY hKey, LPTSTR szName, LPBYTE pData, ULONG cbData) {
    DWORD dwErr;

    dwErr = RegSetValueEx(hKey, szName, 0, REG_BINARY, pData, cbData);

    return(dwErr);
}

DWORD RegSaveString(HKEY hKey, LPTSTR szName, LPTSTR pszData) {
    DWORD dwErr;

    dwErr = RegSetValueEx(hKey, szName, 0, REG_SZ, (LPBYTE)pszData, lstrlen(pszData) + 1);

    return(dwErr);
}


DWORD RegGetShort(HKEY hKey, LPTSTR szName, USHORT * psData) {
    DWORD dwData = 0;
    DWORD cbData = sizeof(dwData);
    DWORD dwErr;
    DWORD dwType = 0;

    dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, (LPBYTE)&dwData, &cbData);

    *psData = (USHORT)dwData;

    return(dwErr);
}

DWORD RegGetLong(HKEY hKey, LPTSTR szName, ULONG * plData) {
    DWORD dwErr;
    DWORD cbData = sizeof(*plData);
    DWORD dwType = 0;

    dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, (LPBYTE)plData, &cbData);

    return(dwErr);
}


DWORD RegGetBinary(HKEY hKey, LPTSTR szName, LPBYTE * ppData, ULONG * lpcbData) {
    DWORD dwErr;
    DWORD dwType = 0;
    DWORD cbData = 0;
    LPBYTE pData = NULL;

    if (*ppData) {
        LocalFree(*ppData);
        *ppData = NULL;
        *lpcbData = 0;
    }
    dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, pData, &cbData);
    if ((dwErr == ERROR_SUCCESS) && (cbData > 0)) {
        pData = (LPBYTE)LocalAlloc(LPTR, cbData);
        *lpcbData = cbData;
        dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, pData, lpcbData);
        *ppData = pData;
    }

    return(dwErr);
}

DWORD RegGetString(HKEY hKey, LPTSTR szName, LPTSTR pszData) {
    DWORD dwErr;
    DWORD dwType = 0;
    DWORD cbData = CCH_OPTION_STRING;
    TCHAR szExpanded[CCH_OPTION_STRING];

    dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, (LPBYTE)pszData, &cbData);
    if ((REG_EXPAND_SZ == dwType) && (cbData > 0)) {
        ExpandEnvironmentStrings(pszData, szExpanded, cbData);
        lstrcpy(pszData, szExpanded);
    }
    return(dwErr);
}

void SaveOptions(void) {
    HKEY hKey = NULL;
    DWORD dwErr;
    DWORD dwDisposition;

    if (! (dwErr = RegCreateKeyEx(HKEY_CURRENT_USER, szRegKey, 0, NULL, 0, KEY_WRITE, NULL, &hKey, &dwDisposition))) {
        RegSaveString(hKey, "Sender Email", szSenderEmail);
        RegSaveString(hKey, "Sender Name", szSenderName);
        if (SenderEntryID.lpb) {
            RegSaveBinary(hKey, "Sender EntryID", (LPBYTE)SenderEntryID.lpb, SenderEntryID.cb);
        } else {
            RegDeleteValue(hKey, "Sender EntryID");
        }
        RegSaveString(hKey, "Recipient Email", szRecipientEmail);
        RegSaveString(hKey, "Recipient Name", szRecipientName);
        if (RecipientEntryID.lpb) {
            RegSaveBinary(hKey, "Recipient EntryID", (LPBYTE)RecipientEntryID.lpb, RecipientEntryID.cb);
        } else {
            RegDeleteValue(hKey, "Recipient EntryID");
        }
        RegSaveString(hKey, "Output File", szOutputFile);
        RegSaveString(hKey, "Input File", szInputFile);

        RegSaveBinary(hKey, "Signing Hash", SignHash.pbData, SignHash.cbData);

        if (CMyNames > 0) {
            CRYPT_SEQUENCE_OF_ANY       any = {CMyNames, RgMyNames};
            DWORD                       cb;
            BOOL                        f;
            LPBYTE                      pb;
            
            f = CryptEncodeObjectEx(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                                    &any, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                    &pb, &cb);
            RegSaveBinary(hKey, "My Names", pb, cb);
            LocalFree(pb);
        }
        else {
            RegDeleteValue(hKey, "My Names");
        }

        SaveMailListKeys(hKey);
        RegCloseKey(hKey);
    }
}

void GetOptions(void) {
    HKEY hKey = NULL;
    DWORD dwErr;

    if (! (dwErr = RegOpenKeyEx(HKEY_CURRENT_USER, szRegKey, 0, KEY_READ, &hKey))) {
        RegGetString(hKey, "Sender Email", szSenderEmail);
        RegGetString(hKey, "Sender Name", szSenderName);
        RegGetBinary(hKey, "Sender EntryID", &SenderEntryID.lpb, &SenderEntryID.cb);
        RegGetString(hKey, "Recipient Email", szRecipientEmail);
        RegGetString(hKey, "Recipient Name", szRecipientName);
        RegGetBinary(hKey, "Recipient EntryID", &RecipientEntryID.lpb, &RecipientEntryID.cb);
        RegGetString(hKey, "Output File", szOutputFile);
        RegGetString(hKey, "Input File", szInputFile);

        RegGetBinary(hKey, "Signing Hash", &SignHash.pbData, &SignHash.cbData);

        {
            DWORD                       cb = 0;
            PCRYPT_SEQUENCE_OF_ANY      pany;
            LPBYTE                      pb = NULL;
            
            RegGetBinary(hKey, "My Names", &pb, &cb);

            if (cb > 0) {
                CryptDecodeObjectEx(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                                    pb, cb, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                    &pany, &cb);
                RgMyNames = (PCERT_NAME_BLOB) LocalAlloc(0, cb);
                memcpy(RgMyNames, pany->rgValue, cb);
                CMyNames = pany->cValue;
                LocalFree(pany);
            }
            if (pb != NULL)             LocalFree(pb);
        }

        GetMailListKeys(hKey);
        RegCloseKey(hKey);
    }
}


void CleanupOptions(void) {
    if (SenderEntryID.lpb) {
        LocalFree(SenderEntryID.lpb);
        SenderEntryID.lpb = NULL;
    }
    if (RecipientEntryID.lpb) {
        LocalFree(RecipientEntryID.lpb);
        RecipientEntryID.lpb = NULL;
    }
    if (RgMyNames != NULL) {
        LocalFree(RgMyNames);
        RgMyNames = 0;
    }
}

////    OptionsDlgProc
//
//  Description:  This is the dialog proc function which controls the preset
//      options for a user.  These options are stored in the registry code and
//      are on a per-user basis.
//

BOOL OptionsDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    PCCERT_CONTEXT      pccert;
    char                rgch[256];
    
    switch (message) {
    case WM_INITDIALOG:
        // Fill in the fields from the options
        SetDlgItemText(hwnd, IDC_SENDER_EMAIL, szSenderEmail);
        //            SetDlgItemText(hwnd, IDC_SENDER_NAME, szSenderName);
        SetDlgItemText(hwnd, IDC_RECIPIENT_EMAIL, szRecipientEmail);
        //            SetDlgItemText(hwnd, IDC_RECIPIENT_NAME, szRecipientName);
        if (HCertStoreMy == NULL) {
            HCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                         NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                         L"MY");
            if (HCertStoreMy == NULL) {
                break;
            }
        }
        if (SignHash.cbData != 0) {
            pccert = CertFindCertificateInStore(HCertStoreMy,
                                                X509_ASN_ENCODING, 0,
                                                CERT_FIND_SHA1_HASH,
                                                &SignHash, NULL);
            GetFriendlyNameOfCertA(pccert, rgch, sizeof(rgch));
            SetDlgItemText(hwnd, IDC_O_CERT_NAME, rgch);
            CertFreeCertificateContext(pccert);
        }
        if (CMyNames > 0) {
            FormatNames(CMyNames, RgMyNames, hwnd, IDC_O_MY_NAMES);
        }
        break;

    case WM_COMMAND :
        switch (wParam) {
        case IDOK:
            GetDlgItemText(hwnd, IDC_SENDER_EMAIL, szSenderEmail, CCH_OPTION_STRING);
            //                GetDlgItemText(hwnd, IDC_SENDER_NAME, szSenderName, CCH_OPTION_STRING);
            GetDlgItemText(hwnd, IDC_RECIPIENT_EMAIL, szRecipientEmail, CCH_OPTION_STRING);
            //                GetDlgItemText(hwnd, IDC_RECIPIENT_NAME, szRecipientName, CCH_OPTION_STRING);
            if (!ParseNames(&CMyNames, &RgMyNames, hwnd, IDC_O_MY_NAMES)) {
                return FALSE;
            }
            EndDialog(hwnd, 0);
            break;

        case IDC_O_CERT_CHOOSE:
            pccert = NULL;
            if (SignHash.cbData != 0) {
                pccert = CertFindCertificateInStore(HCertStoreMy,
                                                    X509_ASN_ENCODING, 0,
                                                    CERT_FIND_SHA1_HASH,
                                                    &SignHash, NULL);
            }
            if (DoCertDialog(hwnd, "Choose Signature Certificate",
                             HCertStoreMy, &pccert, FILTER_NONE)) {
                SignHash.pbData = RgbSignHash;
                SignHash.cbData = sizeof(RgbSignHash);
                CertGetCertificateContextProperty(pccert, CERT_SHA1_HASH_PROP_ID,
                                                  SignHash.pbData,
                                                  &SignHash.cbData);
                GetFriendlyNameOfCertA(pccert, rgch, sizeof(rgch));
                SetDlgItemText(hwnd, IDC_O_CERT_NAME, rgch);
            }

            CertFreeCertificateContext(pccert);
            break;

        default:
            return(FALSE);
        }
        break ;

    default:
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\item.h ===
#include <windows.h>
#include <wintrust.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <mimeole.h>
#include <imnact.h>
#include <imnxport.h>
#include <wab.h>
#include <reg.h>
#include <cryptdlg.h>
#include <smimepol.h>
#include "demand.h"
#include "..\..\ess\essout.h"
#include "myassert.h"

#include "smimetst.h"
#include "data.h"
#include "receipt.h"
#include "attrib.h"

class CMailListKey;


const int TYPE_MSG = 1;

const int TYPE_SIGN_INFO = 2;
const int TYPE_ENV_INFO = 3;

const int TYPE_SIGN_DATA = 4;
const int TYPE_ENV_AGREE = 5;
const int TYPE_ENV_TRANS = 6;
const int TYPE_ENV_MAILLIST = 7;

const int STATE_COMPOSE = 0x0000;
const int STATE_READ = 0x1000;

const int UM_SET_DATA = WM_USER + 1;
const int UM_RESET = WM_USER + 2;
const int UM_FILL = WM_USER + 3;

class CItem
{
    int         m_type;
    int		m_state;
    CItem *     m_pSibling;
    CItem *     m_pChild;
    CItem *     m_pParent;
    
public:
    CItem(int type, int state) {
        m_type = type;
	m_state = state;
        m_pSibling = NULL;
        m_pChild = NULL;
        m_pParent = NULL;
    }
    virtual ~CItem() {
        if (m_pParent != NULL) m_pParent->RemoveAsChild(this);
    }

    virtual HRESULT     AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND) {
        AssertSz(FALSE, "Should never get here. CItem::AddToMessage");
        return E_FAIL;
    }

    virtual HCERTSTORE  GetAllStore(void) {
        if (m_pParent != NULL) return m_pParent->GetAllStore();
        return NULL;
    }
    virtual HCERTSTORE  GetMyStore(void) {
        if (m_pParent != NULL) return m_pParent->GetMyStore();
        return NULL;
    }
    CItem *             GetParent(void) const { return m_pParent; }
    int                 GetType(void) const {return m_type;}
    int			GetState(void) const { return m_state; }
    CItem *             Head(void) const { return m_pChild; }
    void                MakeChild(CItem * pChild, CItem * pAfter);
    CItem *             Next(void) const { return m_pSibling; }
    void                RemoveAsChild(CItem * pChild);
    void                SetParent(CItem * pParent) { m_pParent = pParent; }
};

class CSignInfo;
class CSignData;

class CMessage : public CItem, public IMimeSecurityCallback
{
    HCERTSTORE          m_hCertStoreAll;
    HCERTSTORE          m_hCertStoreMy;
    int                 m_iterations;
    char                m_rgchPlain[CCH_OPTION_STRING];
    char                m_rgchCipher[CCH_OPTION_STRING];

    int                 m_fToFile:1;
    
public:
    CMessage(int state=STATE_READ) : CItem(TYPE_MSG, state) {
        m_hCertStoreMy = NULL;
        strcpy(m_rgchPlain, "<none>");
        strcpy(m_rgchCipher, "c:\\test.eml");
        m_iterations = 1;
        m_fToFile = TRUE;
    }
    ~CMessage() {
        Assert(m_hCertStoreMy == NULL);
    }

    CSignInfo *         Head(void) const { return (CSignInfo *) CItem::Head(); }
    HRESULT             AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
    HRESULT             AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND, CItem *);
    HRESULT             Decode(HWND);
    HRESULT             Encode(HWND);
    char *              GetCipherFile(void) { return m_rgchCipher; }
    int                 GetFileNameSize(void) const { return CCH_OPTION_STRING; }
    HCERTSTORE          GetAllStore(void);
    HCERTSTORE          GetMyStore(void);
    char *              GetPlainFile(void) { return m_rgchPlain; }
    int&                GetIterationCount(void) { return m_iterations; }
    BOOL                ResetMessage(void);
    void                SetToFile(int i) { m_fToFile = i; }

    //

    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP FindKeyFor(HWND, DWORD, DWORD, const CMSG_CMS_RECIPIENT_INFO *, DWORD *, CMS_CTRL_DECRYPT_INFO *, PCCERT_CONTEXT *);
    STDMETHODIMP GetParameters(PCCERT_CONTEXT, LPVOID, DWORD *, LPBYTE *);
};


class CSignInfo : public CItem
{
    
public:
    DWORD               m_fBlob:1;

    CSignInfo(int state, CMessage * pparent) : CItem(TYPE_SIGN_INFO, state) {
        SetParent(pparent);
        m_fBlob = FALSE;
    }

    ~CSignInfo() {
        AssertSz(Head() == NULL, "Failed to release all children");
        AssertSz(Next() == NULL, "Failed to release all siblings");
    }

    HRESULT             AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
    int                 Count(void) const;
    CSignData *         Head(void) const { return (CSignData *) CItem::Head(); }
    CSignInfo *         Next(void) const { return (CSignInfo *) CItem::Next(); }
};

class CSignData : public CItem
{
    CRYPT_ATTR_BLOB     m_valLabel;
    CRYPT_ATTR_BLOB     m_valReceipt;
    CRYPT_ATTR_BLOB     m_valMLHistory;
    CRYPT_ATTR_BLOB     m_valAuthAttrib;
    LPSTR               m_szAuthAttribOID;
    CRYPT_ATTR_BLOB     m_valUnAuthAttrib;
    LPSTR               m_szUnAuthAttribOID;
    
public:
    PCCERT_CONTEXT      m_pccert;
    DWORD               m_ulValidity;
    DWORD               m_fReceipt:1;
    DWORD               m_fLabel:1;
    DWORD               m_fMLHistory:1;
    DWORD               m_fUseSKI:1;
    DWORD               m_fAuthAttrib:1;
    DWORD               m_fUnAuthAttrib:1;
    
    CSignData(int state);
    ~CSignData(void) {
        CertFreeCertificateContext(m_pccert);
        AssertSz(Head() == NULL, "Should never have any children");
        AssertSz(Next() == NULL, "Failed to release all siblings");
        if (m_valLabel.pbData != NULL) free(m_valLabel.pbData);
        if (m_valReceipt.pbData != NULL) free(m_valReceipt.pbData);
        if (m_valMLHistory.pbData != NULL) free(m_valMLHistory.pbData);
        if (m_valAuthAttrib.pbData != NULL) free(m_valAuthAttrib.pbData);
        if (m_szAuthAttribOID != NULL) free(m_szAuthAttribOID);
        if (m_valUnAuthAttrib.pbData != NULL) free(m_valUnAuthAttrib.pbData);
        if (m_szUnAuthAttribOID != NULL) free(m_szUnAuthAttribOID);
    }

    HRESULT CSignData::BuildArrays(DWORD * pCount, DWORD * dwType,
                               PROPVARIANT * rgvHash, PCCERT_CONTEXT * rgpccert,
                               PROPVARIANT * rgvAuthAttr, HCERTSTORE hcertstore,
                                   IMimeSecurity2 * psmime2);
    void                GetLabel(LPBYTE * ppb, DWORD * pcb) {
        *ppb = m_valLabel.pbData;
        *pcb = m_valLabel.cbData;
    }
    void                GetMLHistory(LPBYTE * ppb, DWORD * pcb) {
        *ppb = m_valMLHistory.pbData;
        *pcb = m_valMLHistory.cbData;
    }
    void                GetReceiptData(LPBYTE * ppbReceiptData,
                                       DWORD * pcbReceiptData) {
        *ppbReceiptData = m_valReceipt.pbData;
        *pcbReceiptData = m_valReceipt.cbData;
    }
    void                GetAuthAttribData(LPBYTE * ppbAuthAttribData,
                                       DWORD * pcbAuthAttribData) {
        *ppbAuthAttribData = m_valAuthAttrib.pbData;
        *pcbAuthAttribData = m_valAuthAttrib.cbData;
    }
    LPSTR                GetAuthAttribOID() {
        return m_szAuthAttribOID;
    }
    void                GetUnAuthAttribData(LPBYTE * ppbUnAuthAttribData,
                                       DWORD * pcbUnAuthAttribData) {
        *ppbUnAuthAttribData = m_valUnAuthAttrib.pbData;
        *pcbUnAuthAttribData = m_valUnAuthAttrib.cbData;
    }
    LPSTR                GetUnAuthAttribOID() {
        return m_szUnAuthAttribOID;
    }
    CSignInfo *         GetParent(void) const {
        return (CSignInfo *) CItem::GetParent();
    }
    CSignData *         Next(void) const { return (CSignData *) CItem::Next(); }
    void                SetLabel(LPBYTE, DWORD);
    
    void                SetMLHistory(LPBYTE pbMLHistoryData, DWORD cbMLHistoryData) {
        if (m_valMLHistory.pbData != NULL) {
            free(m_valMLHistory.pbData);
            m_valMLHistory.pbData = NULL;
        }
        if (cbMLHistoryData > 0) {
            m_valMLHistory.pbData = (LPBYTE) malloc(cbMLHistoryData);
            memcpy(m_valMLHistory.pbData, pbMLHistoryData, cbMLHistoryData);
            m_valMLHistory.cbData = cbMLHistoryData;
        }
        return;
    }

    void                SetReceiptData(LPBYTE pbReceiptData, DWORD cbReceiptData) {
        if (m_valReceipt.pbData != NULL) {
            free(m_valReceipt.pbData);
            m_valReceipt.pbData = NULL;
        }
        if (cbReceiptData > 0) {
            m_valReceipt.pbData = (LPBYTE) malloc(cbReceiptData);
            memcpy(m_valReceipt.pbData, pbReceiptData, cbReceiptData);
            m_valReceipt.cbData = cbReceiptData;
        }
        return;
    }
    void                SetAuthAttribData(LPBYTE pbAuthAttribData, DWORD cbAuthAttribData) {
        if (m_valAuthAttrib.pbData != NULL) {
            free(m_valAuthAttrib.pbData);
            m_valAuthAttrib.pbData = NULL;
        }
        if (cbAuthAttribData > 0) {
            m_valAuthAttrib.pbData = (LPBYTE) malloc(cbAuthAttribData);
            memcpy(m_valAuthAttrib.pbData, pbAuthAttribData, cbAuthAttribData);
            m_valAuthAttrib.cbData = cbAuthAttribData;
        }
        return;
    }
    void                SetAuthAttribOID(LPSTR szAuthAttribOID) {
        if (m_szAuthAttribOID != NULL) {
            free(m_szAuthAttribOID);
            m_szAuthAttribOID = NULL;
        }
        if (szAuthAttribOID != NULL) {
            m_szAuthAttribOID = (LPSTR) malloc(strlen(szAuthAttribOID) + 1);
            strcpy(m_szAuthAttribOID, szAuthAttribOID);
        }
        return;
    }
    void                SetUnAuthAttribData(LPBYTE pbUnAuthAttribData, DWORD cbUnAuthAttribData) {
        if (m_valUnAuthAttrib.pbData != NULL) {
            free(m_valUnAuthAttrib.pbData);
            m_valUnAuthAttrib.pbData = NULL;
        }
        if (cbUnAuthAttribData > 0) {
            m_valUnAuthAttrib.pbData = (LPBYTE) malloc(cbUnAuthAttribData);
            memcpy(m_valUnAuthAttrib.pbData, pbUnAuthAttribData, cbUnAuthAttribData);
            m_valUnAuthAttrib.cbData = cbUnAuthAttribData;
        }
        return;
    }
    void                SetUnAuthAttribOID(LPSTR szUnAuthAttribOID) {
        if (m_szUnAuthAttribOID != NULL) {
            free(m_szUnAuthAttribOID);
            m_szUnAuthAttribOID = NULL;
        }
        if (szUnAuthAttribOID != NULL) {
            m_szUnAuthAttribOID = (LPSTR) malloc(strlen(szUnAuthAttribOID) + 1);
            strcpy(m_szUnAuthAttribOID, szUnAuthAttribOID);
        }
        return;
    }
    void        SetDefaultCert() {
        if (SignHash.cbData != 0) {
            m_pccert = CertFindCertificateInStore(GetMyStore(), X509_ASN_ENCODING,
                                          0, CERT_FIND_SHA1_HASH, &SignHash, NULL);
        }
    }
};

class CEnvData : public CItem
{
    int                 m_iAlg;
    CRYPT_ATTR_BLOB     m_valUnProtAttrib;
    LPSTR               m_szUnProtAttribOID;
    
public:
    DWORD               m_fAttributes:1;
    DWORD               m_fUnProtAttrib:1;
    
    CEnvData(int state, CMessage * pparent) : CItem(TYPE_ENV_INFO, state) {
        m_iAlg = 0;
        m_fAttributes = 0;
        m_fUnProtAttrib = FALSE;
        m_valUnProtAttrib.cbData = 0;
        m_valUnProtAttrib.pbData = NULL;
        m_szUnProtAttribOID = NULL;
        SetParent(pparent);
    }
    ~CEnvData(void) {
        AssertSz(Head() == NULL, "Should never have any children");
        AssertSz(Next() == NULL, "Failed to release all siblings");
    }

    HRESULT             AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
    int                 GetAlg(void) const { return m_iAlg; }
    void                GetUnProtAttribData(LPBYTE * ppbUnProtAttribData,
                                       DWORD * pcbUnProtAttribData) {
        *ppbUnProtAttribData = m_valUnProtAttrib.pbData;
        *pcbUnProtAttribData = m_valUnProtAttrib.cbData;
    }
    LPSTR                GetUnProtAttribOID() {
        return m_szUnProtAttribOID;
    }
    CEnvData *          Next(void) const { return (CEnvData *) CItem::Next(); }
    void                SetAlg(int iAlg) { m_iAlg = iAlg; }
    void                SetUnProtAttribData(LPBYTE pbUnProtAttribData, DWORD cbUnProtAttribData) {
        if (m_valUnProtAttrib.pbData != NULL) {
            free(m_valUnProtAttrib.pbData);
            m_valUnProtAttrib.pbData = NULL;
        }
        if (cbUnProtAttribData > 0) {
            m_valUnProtAttrib.pbData = (LPBYTE) malloc(cbUnProtAttribData);
            memcpy(m_valUnProtAttrib.pbData, pbUnProtAttribData, cbUnProtAttribData);
            m_valUnProtAttrib.cbData = cbUnProtAttribData;
        }
        return;
    }
    void                SetUnProtAttribOID(LPSTR szUnProtAttribOID) {
        if (m_szUnProtAttribOID != NULL) {
            free(m_szUnProtAttribOID);
            m_szUnProtAttribOID = NULL;
        }
        if (szUnProtAttribOID != NULL) {
            m_szUnProtAttribOID = (LPSTR) malloc(strlen(szUnProtAttribOID) + 1);
            strcpy(m_szUnProtAttribOID, szUnProtAttribOID);
        }
        return;
    }
};

class CEncItem : public CItem
{
public:
    DWORD               m_cCerts;
    PCCERT_CONTEXT *    m_rgpccert;

    BOOL                m_fUseSKI:1;

    CEncItem(int a, int b) : CItem(a, b) {
        m_cCerts = 0;
        m_rgpccert = 0;
    }

    ~CEncItem() {
        for (DWORD i=0; i<m_cCerts; i++) {
            CertFreeCertificateContext(m_rgpccert[i]);
        }
        if (m_rgpccert != NULL) free(m_rgpccert);
    }

    CEnvData *         GetParent(void) const {
        return (CEnvData *) CItem::GetParent();
    }
};

class CEnvCertTrans : public CEncItem
{
    
public:
    CEnvCertTrans(int state) : CEncItem(TYPE_ENV_TRANS, state) {
    }

    HRESULT     AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
};
    
class CEnvCertAgree : public CEncItem
{
    
public:
    CEnvCertAgree(int state) : CEncItem(TYPE_ENV_AGREE, state) {
    }

    HRESULT     AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
};
    
class CEnvMailList : public CItem
{
    
public:

    DWORD               m_cKeys;
    CMailListKey **     m_rgKeys;

    int                 m_fUsePrivateCSPs:1;

    CEnvMailList(int state) : CItem(TYPE_ENV_MAILLIST, state) {
        m_cKeys = 0;
        m_rgKeys = NULL;
        m_fUsePrivateCSPs = FALSE;
    }

    ~CEnvMailList() {
        if (m_rgKeys != NULL)   LocalFree(m_rgKeys);
    }

    HRESULT     AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\sign.h ===
BOOL CALLBACK SignDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SignDataReadDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SignInfoDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\sign.cpp ===
#include "item.h"

#define MAX_LAYERS      30
extern HINSTANCE        hInst;

extern const BYTE RgbSHA1AlgId[] =
      {0x30, 0x09, 0x30, 0x07, 0x06, 0x05, 0x2B, 0x0E,
       0x03, 0x02, 0x1A};
extern const int  CbSHA1AlgId = sizeof(RgbSHA1AlgId);

byte RgbEntityId1[] = {0x1, 0x4, 0x7, 0x8, 0x10};
byte RgbEntityId2[] = {0x1, 0x4, 0x7, 0x10, 0x8};

const char      SzPolicyRoot[] = "Software\\Microsoft\\Cryptography\\OID\\EncodingType 1\\SMimeSecurityLabel";
//const char      SzPolicyRoot[] = "Software\\Microsoft\\Cryptography\\SMIME\\SecurityPolicies";

class CSecurityPolicy {
public:
    DWORD               dwFlags;
    char *              szDllName;
    char *              szPolicyOID;
    char *              szFuncName;
    HMODULE             hmod;
    PFNGetSMimePolicy   pfnFuncName;
    ISMimePolicySimpleEdit *      ppolicy;

    CSecurityPolicy() {
        szDllName = szPolicyOID = szFuncName = NULL;
        hmod = 0;
        pfnFuncName = NULL;
        ppolicy = NULL;
        dwFlags = 0;
    }

    ~CSecurityPolicy() {
        free(szDllName);
        free(szPolicyOID);
        free(szFuncName);
        if (ppolicy != NULL)    ppolicy->Release();
        FreeLibrary(hmod);
    }
};

////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK MLDataCreateDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    DWORD                       cb2;
    BOOL                        f;
    SMIME_ML_EXPANSION_HISTORY  mlHistory;
    LPBYTE                      pb;
    PSMIME_ML_EXPANSION_HISTORY pMLHistory;
    static PCCERT_CONTEXT       pccert1 = NULL;
    static PCCERT_CONTEXT       pccert2 = NULL;
    static CSignData *          psd = NULL;
    char                        rgch[256];
    SMIME_MLDATA                rgMLData[5];
    
    switch (msg) {
    case WM_INITDIALOG:
        pccert1 = NULL;
        pccert2 = NULL;
        psd = (CSignData *) lParam;
#if 0
        psd->GetMLHistory(&pb, &cb);
        if (cb > 0) {
            f = CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_MLExpansion_History,
                                    pb, cb, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                    &pMLHistory, &cb2);
        }
#endif // 0
        break;
        
    case WM_COMMAND:
        switch (wParam) {
        case MAKELONG(IDC_MLC_SELECT1, BN_CLICKED):
            if (DoCertDialog(hdlg, "Choose ML Data Certificate",
                             psd->GetMyStore(), &pccert1,
                             FILTER_RSA_SIGN | FILTER_DSA_SIGN)) {
                GetFriendlyNameOfCertA(pccert1, rgch, sizeof(rgch));
                SetDlgItemText(hdlg, IDC_MLC_CERT1, rgch);
            }
            break;
            
        case MAKELONG(IDC_MLC_SELECT2, BN_CLICKED):
            if (DoCertDialog(hdlg, "Choose ML Data Certificate",
                             psd->GetMyStore(), &pccert2,
                             FILTER_RSA_SIGN | FILTER_DSA_SIGN)) {
                GetFriendlyNameOfCertA(pccert2, rgch, sizeof(rgch));
                SetDlgItemText(hdlg, IDC_MLC_CERT2, rgch);
            }
            break;
            
        case MAKELONG(IDC_MLC_ABSENT1, BN_CLICKED):
        case MAKELONG(IDC_MLC_NONE1, BN_CLICKED):
            EnableWindow(GetDlgItem(hdlg, IDC_MLC_NAMES1), FALSE);
            break;

        case MAKELONG(IDC_MLC_INSTEAD1, BN_CLICKED):
        case MAKELONG(IDC_MLC_ALSO1, BN_CLICKED):
            EnableWindow(GetDlgItem(hdlg, IDC_MLC_NAMES1), TRUE);
            break;
            
        case MAKELONG(IDC_MLC_ABSENT2, BN_CLICKED):
        case MAKELONG(IDC_MLC_NONE2, BN_CLICKED):
            EnableWindow(GetDlgItem(hdlg, IDC_MLC_NAMES2), FALSE);
            break;

        case MAKELONG(IDC_MLC_INSTEAD2, BN_CLICKED):
        case MAKELONG(IDC_MLC_ALSO2, BN_CLICKED):
            EnableWindow(GetDlgItem(hdlg, IDC_MLC_NAMES2), TRUE);
            break;
            
        case IDOK:
            memset(&mlHistory, 0, sizeof(mlHistory));
            memset(rgMLData, 0, sizeof(rgMLData));

            mlHistory.cMLData = 0;
            mlHistory.rgMLData = rgMLData;
            
            mlHistory.cMLData = 1;

            if (pccert1 == NULL) {
                break;
            }

            if (SendDlgItemMessage(hdlg, IDC_MLC_ID1, BM_GETCHECK, 0, 0)) {
                rgMLData[0].dwChoice = SMIME_MLDATA_SUBJECT_KEY_IDENTIFIER;
                rgMLData[0].SubjectKeyIdentifier.cbData = sizeof(RgbEntityId1);
                rgMLData[0].SubjectKeyIdentifier.pbData = RgbEntityId1;
            }
            else {
                rgMLData[0].dwChoice = SMIME_MLDATA_ISSUER_SERIAL_NUMBER;
                rgMLData[0].u.SerialNumber = pccert1->pCertInfo->SerialNumber;
                rgMLData[0].u.Issuer = pccert1->pCertInfo->Issuer;
            }

            GetSystemTimeAsFileTime(&rgMLData[0].ExpansionTime);
            
            if (SendDlgItemMessage(hdlg, IDC_MLC_ABSENT1, BM_GETCHECK, 0, 0)) {
                rgMLData[0].dwPolicy = SMIME_MLPOLICY_NO_CHANGE;
            }
            else if (SendDlgItemMessage(hdlg, IDC_MLC_NONE1, BM_GETCHECK, 0, 0)) {
                rgMLData[0].dwPolicy = SMIME_MLPOLICY_NONE;
            }
            else if (SendDlgItemMessage(hdlg, IDC_MLC_INSTEAD1, BM_GETCHECK, 0, 0)) {
                rgMLData[0].dwPolicy = SMIME_MLPOLICY_INSTEAD_OF;
                if (!ParseNames(&rgMLData[0].cNames, &rgMLData[0].rgNames,
                                hdlg, IDC_MLC_NAMES1)) {
                    return FALSE;
                }
            }
            else {
                rgMLData[0].dwPolicy = SMIME_MLPOLICY_IN_ADDITION_TO;
                if (!ParseNames(&rgMLData[0].cNames, &rgMLData[0].rgNames,
                                hdlg, IDC_MLC_NAMES1)) {
                    return FALSE;
                }
            }

            if (SendDlgItemMessage(hdlg, IDC_MLC_INCLUDE2, BM_GETCHECK, 0, 0)) {
                mlHistory.cMLData = 2;

                if (pccert2 == NULL) {
                    break;
                }

                if (SendDlgItemMessage(hdlg, IDC_MLC_ID2, BM_GETCHECK, 0, 0)) {
                    rgMLData[1].dwChoice = SMIME_MLDATA_SUBJECT_KEY_IDENTIFIER;
                    rgMLData[1].SubjectKeyIdentifier.cbData = sizeof(RgbEntityId2);
                    rgMLData[1].SubjectKeyIdentifier.pbData = RgbEntityId2;
                }
                else {
                    rgMLData[1].dwChoice = SMIME_MLDATA_ISSUER_SERIAL_NUMBER;
                    rgMLData[1].u.SerialNumber = pccert2->pCertInfo->SerialNumber;
                    rgMLData[1].u.Issuer = pccert2->pCertInfo->Issuer;
                }

                GetSystemTimeAsFileTime(&rgMLData[1].ExpansionTime);
            
                if (SendDlgItemMessage(hdlg, IDC_MLC_ABSENT2, BM_GETCHECK, 0, 0)) {
                    rgMLData[1].dwPolicy = SMIME_MLPOLICY_NO_CHANGE;
                }
                else if (SendDlgItemMessage(hdlg, IDC_MLC_NONE2, BM_GETCHECK, 0, 0)) {
                    rgMLData[1].dwPolicy = SMIME_MLPOLICY_NONE;
                }
                else if (SendDlgItemMessage(hdlg, IDC_MLC_INSTEAD2, BM_GETCHECK, 0, 0)) {
                    rgMLData[1].dwPolicy = SMIME_MLPOLICY_INSTEAD_OF;
                    if (!ParseNames(&rgMLData[1].cNames, &rgMLData[1].rgNames,
                                    hdlg, IDC_MLC_NAMES2)) {
                        return FALSE;
                    }
                }
                else {
                    rgMLData[1].dwPolicy = SMIME_MLPOLICY_IN_ADDITION_TO;
                    if (!ParseNames(&rgMLData[1].cNames, &rgMLData[1].rgNames,
                                    hdlg, IDC_MLC_NAMES2)) {
                        return FALSE;
                    }
                }
            }

            f = CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_MLExpansion_History,
                                    &mlHistory, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                    &pb, &cb);
            if (!f) return FALSE;
            
            psd->SetMLHistory(pb, cb);
            
        case IDCANCEL:
            CertFreeCertificateContext(pccert1);
            CertFreeCertificateContext(pccert2);
            EndDialog(hdlg, wParam);
            break;

        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////

void InitPolicies(HWND hdlg, DWORD idc1, DWORD idc2, DWORD idc3, DWORD idc4)
{
    DWORD       cbData;
    DWORD       cbMaxData;
    DWORD       cval;
    DWORD       dw;
    FILETIME    ft;
    HKEY        hkey;
    HKEY        hkey2;
    DWORD       i;
    DWORD       i1;
    DWORD       iSel;
    CSecurityPolicy * p;
    char *      pbData = NULL;
    char        rgch[256];

    if (RegOpenKey(HKEY_LOCAL_MACHINE, SzPolicyRoot, &hkey)) {
        return;
    }

    for (i=0; TRUE; i++) {
        cbData =sizeof(rgch);
        dw = RegEnumKeyEx(hkey, i, rgch, &cbData, NULL, NULL, NULL, &ft);
        if (dw != ERROR_SUCCESS) {
            break;
        }

        dw = RegOpenKey(hkey, rgch, &hkey2);

        dw = RegQueryInfoKey(hkey2, NULL, NULL, NULL, NULL, NULL, NULL, &cval,
                             NULL, &cbMaxData, NULL, NULL);

        pbData = (LPSTR) malloc(cbMaxData);

        p = new CSecurityPolicy;

        p->szPolicyOID = _strdup(rgch);

        cbData = cbMaxData;
        dw = RegQueryValueEx(hkey2, "DllPath", NULL, &dw, (LPBYTE) pbData, &cbData);
        p->szDllName = _strdup(pbData);

        dw = RegQueryValueEx(hkey2, "FuncName", NULL, &dw, (LPBYTE) pbData, &cbData);
        if (*pbData != 0) {
            p->szFuncName = _strdup(pbData);
        }

        cbData = cbMaxData;
        dw = RegQueryValueEx(hkey2, "CommonName", NULL, &dw, (LPBYTE) pbData, &cbData);
            
        iSel = SendDlgItemMessage(hdlg, idc1, CB_ADDSTRING, 0, (LPARAM) pbData);
        Assert(iSel != CB_ERR);
        if (iSel == CB_ERR) {
            continue;
        }

        SendDlgItemMessage(hdlg, idc1, CB_SETITEMDATA, iSel, (LPARAM) p);

        free(pbData);   pbData = NULL;

        RegCloseKey(hkey2);     hkey2 = NULL;
    }

    //exit:
    if (pbData != NULL)         free(pbData);
    if (hkey != NULL)           RegCloseKey(hkey);
    if (hkey2 != NULL)          RegCloseKey(hkey2);
}

void PolicyFillClassifications(HWND hwnd, DWORD idc1, DWORD idc2, DWORD idc3,
                               DWORD dw)
{
    DWORD                       cb;
    DWORD                       cbEncode;
    DWORD                       cbMax;
    DWORD                       cClassifications = 0;
    DWORD                       cval;
    DWORD                       dwValue;
    DWORD                       dwDefaultClassification;
    HRESULT                     hr;
    DWORD                       i;
    int                         iSel;
    DWORD                       iSetSel;
    CSecurityPolicy *           p;
    LPBYTE                      pbEncode;
    DWORD *                     pdwClassifications = NULL;
    LPWSTR *                    pwszClassifications = NULL;
    WCHAR                       rgwch[256];
    
    iSel = SendDlgItemMessage(hwnd, IDC_SD_POLICY, CB_GETCURSEL, 0, 0);
    p = (CSecurityPolicy *) SendDlgItemMessage(hwnd, idc1, CB_GETITEMDATA,
                                               iSel, 0);
    if (((int) p) == CB_ERR) {
        return;
    }
    
    if (p->hmod == NULL) {
        p->hmod = LoadLibrary(p->szDllName);
        if (p->hmod == NULL) {
            return;
        }
    }

    if (p->pfnFuncName == NULL) {
        p->pfnFuncName = (PFNGetSMimePolicy) GetProcAddress(p->hmod, p->szFuncName);
        if (p->pfnFuncName == NULL) {
            return;
        }
    }

    if (p->ppolicy == NULL) {
        p->pfnFuncName(0, p->szPolicyOID, 1252, IID_ISMimePolicySimpleEdit,
                       (LPUNKNOWN *) &p->ppolicy);
    }

    p->ppolicy->GetPolicyInfo(0, &p->dwFlags);

    // get the classification information.
    hr = p->ppolicy->GetClassifications(0, &cClassifications, &pwszClassifications,
                                        &pdwClassifications, 
                                        &dwDefaultClassification);
    if (FAILED(hr)) {
        goto Error;    
    }

    
    SendDlgItemMessage(hwnd, idc2, CB_RESETCONTENT, 0, 0);
    for (i=0, iSetSel = 0; i<cClassifications; i++) {
        iSel = SendDlgItemMessageW(hwnd, idc2, CB_ADDSTRING, 0, (LPARAM) pwszClassifications[i]);
        SendDlgItemMessage(hwnd, idc2, CB_SETITEMDATA, iSel, pdwClassifications[i]);
        if (dwDefaultClassification == pdwClassifications[i]) {
            iSetSel = i;
        }
    }
    SendDlgItemMessage(hwnd, idc2, CB_SETCURSEL, iSetSel, 0);

    EnableWindow(GetDlgItem(hwnd, idc3), !!(p->dwFlags & SMIME_POLICY_EDIT_UI));
Error:
    return;
}


BOOL CALLBACK SignInfoDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static CSignInfo *          psi = NULL;

    switch (msg) {
    case UM_SET_DATA:
        psi = (CSignInfo *) lParam;

        SendDlgItemMessage(hdlg, IDC_SI_BLOB_SIGN, BM_SETCHECK,
                           ((psi != NULL) && (psi->m_fBlob)), 0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case MAKELONG(IDC_SI_BLOB_SIGN, BN_CLICKED):
            psi->m_fBlob = SendDlgItemMessage(hdlg, IDC_SI_BLOB_SIGN,
                                              BM_GETCHECK, 0, 0);
            return FALSE;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


BOOL CALLBACK SignDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       c;
    DWORD                       cb;
    DWORD                       cbEncode;
    DWORD                       cch;
    DWORD                       dw;
    BOOL                        f;
    DWORD                       i;
    CSecurityPolicy *           p;
    LPBYTE                      pb;
    LPBYTE                      pbEncode;
    SMIME_SECURITY_LABEL *      plabel;
    static CSignData *          psd = NULL;
    LPWSTR                      psz;
    CHAR                        rgch[300];

    switch (msg) {
    case WM_INITDIALOG:
        InitPolicies(hdlg, IDC_SD_POLICY, IDC_SD_CLASSIFICATION,
                     IDC_SD_PRIVACY_MARK, IDC_SD_ADVANCED);
        SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_SETCURSEL, 0, 0);
        PolicyFillClassifications(hdlg, IDC_SD_POLICY, IDC_SD_CLASSIFICATION,
                                  IDC_SD_ADVANCED, 0);
        break;

    case UM_SET_DATA:
        // Need to extract and build a security label
        if (psd != NULL) {
            if (SendDlgItemMessage(hdlg, IDC_SD_LABEL, BM_GETCHECK, 0, 0)) {
                DWORD                           dw;
                DWORD                           iSel;
                SMIME_SECURITY_LABEL            label = {0};
                CSecurityPolicy *               p;
                WCHAR                           rgwch[255];
                
                iSel = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCURSEL, 0, 0);
                p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                           CB_GETITEMDATA, iSel, 0);
                iSel = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETCURSEL,
                                          0, 0);
                dw = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETITEMDATA,
                                        iSel, 0);
                rgwch[0] = 0;
                GetDlgItemTextW(hdlg, IDC_SD_PRIVACY_MARK, rgwch, sizeof(rgwch)/2);

                label.pszObjIdSecurityPolicy = p->szPolicyOID;
                if (dw == -1) {
                    label.fHasClassification = FALSE;
                }
                else {
                    label.fHasClassification = TRUE;
                    label.dwClassification = dw;
                }
                if (rgwch[0] != 0) {
                    label.wszPrivacyMark = rgwch;
                }
                else {
                    label.wszPrivacyMark = NULL;
                }
                
                label.cCategories = 0;

                f = CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Security_Label,
                                        &label, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                        &pbEncode, &cbEncode);
                Assert(f);

                psd->SetLabel(pbEncode, cbEncode);
                LocalFree(pbEncode);
            }
        }
        
        //  Fill in the dialog
        psd = (CSignData *) lParam;

        if ((psd != NULL) && (psd->m_pccert != NULL)) {
            GetFriendlyNameOfCertA(psd->m_pccert, rgch, sizeof(rgch));
            SetDlgItemText(hdlg, IDC_SD_CERT_NAME, rgch);
        }
        else {
            SetDlgItemText(hdlg, IDC_SD_CERT_NAME, "");
        }

        SendDlgItemMessage(hdlg, IDC_SD_RECEIPT, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fReceipt)), 0);

        SendDlgItemMessage(hdlg, IDC_SD_USE_SKI, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fUseSKI)), 0);

        SendDlgItemMessage(hdlg, IDC_SD_MLDATA, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fMLHistory)), 0);

        SendDlgItemMessage(hdlg, IDC_SD_AUTHATTRIB, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fAuthAttrib)), 0);

        SendDlgItemMessage(hdlg, IDC_SD_UNAUTHATTRIB, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fUnAuthAttrib)), 0);

        if (psd != NULL) {
            psd->GetLabel(&pbEncode, &cbEncode);
            SendDlgItemMessage(hdlg, IDC_SD_LABEL, BM_SETCHECK, (cbEncode > 0), 0);
            c = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCOUNT, 0, 0);
            if (cbEncode > 0) {
                f = CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Security_Label,
                                        pbEncode, cbEncode, CRYPT_ENCODE_ALLOC_FLAG,
                                        NULL, &plabel, &cb);
                Assert(f);

                for (i=0; i<c; i++) {
                    p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                               CB_GETITEMDATA, i, 0);
                    if (strcmp(p->szPolicyOID, plabel->pszObjIdSecurityPolicy) == 0) {
                        break;
                    }
                }

                Assert(i<c);
                if (i<c) {
                    SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_SETCURSEL, i, 0);
                    PolicyFillClassifications(hdlg, IDC_SD_POLICY,
                                              IDC_SD_CLASSIFICATION,
                                              IDC_SD_ADVANCED,
                                              plabel->dwClassification);
                }
            
                LocalFree(plabel);
            }
            else {
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_SD_CERT_CHOOSE:
            if (DoCertDialog(hdlg, "Choose Signing Certificate", psd->GetMyStore(),
                             &psd->m_pccert, FILTER_RSA_SIGN | FILTER_DSA_SIGN)) {
                GetFriendlyNameOfCertA(psd->m_pccert, rgch, sizeof(rgch));
                SetDlgItemText(hdlg, IDC_SD_CERT_NAME, rgch);
            }
            break;

        case MAKELONG(IDC_SD_RECEIPT, BN_CLICKED):
            psd->m_fReceipt = SendDlgItemMessage(hdlg, IDC_SD_RECEIPT, BM_GETCHECK,
                                                 0, 0);
            return FALSE;

        case MAKELONG(IDC_SD_USE_SKI, BN_CLICKED):
            psd->m_fUseSKI = SendDlgItemMessage(hdlg, IDC_SD_USE_SKI, BM_GETCHECK,
                                                0, 0);
            return FALSE;

        case IDC_SD_DO_RECEIPT:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_RECEIPT_CREATE), hdlg,
                           ReceiptCreateDlgProc, (LPARAM) psd);
            break;

        case IDC_SD_ADVANCED:
            //  Query the list to get the policy module descriptor
            i = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCURSEL, 0, 0);
            p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                       CB_GETITEMDATA, i, 0);

            //  Query the classification within the policy module
            i = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETCURSEL,
                                   0, 0);
            dw = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETITEMDATA,
                                    i, 0);

            //  Query back the privacy mark within the policy mark.
            cch = SendDlgItemMessage(hdlg, IDC_SD_PRIVACY_MARK, WM_GETTEXTLENGTH, 0, 0);
            if (cch > 0) {
                psz = (LPWSTR) LocalAlloc(0, cch);
                *psz = 0;
                SendDlgItemMessageW(hdlg, IDC_SD_PRIVACY_MARK, WM_GETTEXT, cch, (LPARAM) psz);
            }
            else {
                psz = NULL;
            }

            //  If we already have a security label on this object, grab it.
            psd->GetLabel(&pb, &cb);
            if (cb > 0) {
                pbEncode = (LPBYTE) LocalAlloc(0, cb);
                memcpy(pbEncode, pb, cb);
            }
            else {
                pbEncode = NULL;
            }

#if 0
            //  Now call the advanced UI to see what it wants to do.  It will return an
            //  new receipt and we go from there
            if (p->ppolicy->EditUI(hdlg, &dw, &psz, &pbEncode, &cb) == S_OK) {
                
                // Put the label back on our object.
                psd->SetLabel(pbEncode, cb);

                //  Put back the classification
                c = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETCOUNT, 0, 0);
                for (i=0; i<c; i++) {
                    if (dw == (DWORD) SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION,
                                                         CB_GETITEMDATA, i, 0)) {
                        SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_SETCURSEL, i, 0);
                        break;
                    }
                }

                //  Put back the privacy mark
                if (psz != NULL) {
                    SetDlgItemTextW(hdlg, IDC_SD_PRIVACY_MARK, psz);
                    LocalFree(psz);
                }
                else {
                    SetDlgItemTextW(hdlg, IDC_SD_PRIVACY_MARK, L"");
                }
            }
#endif // 0

            //  Free the label as encoded, we have already saved it.
            if (pbEncode != NULL) {
                LocalFree(pbEncode);
            }
            break;

        case MAKELONG(IDC_SD_MLDATA, BN_CLICKED):
            psd->m_fMLHistory = SendDlgItemMessage(hdlg, IDC_SD_MLDATA, BM_GETCHECK,
                                                   0, 0);
            break;
            
        case IDC_SD_DO_MLDATA:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_MLDATA_CREATE), hdlg,
                           MLDataCreateDlgProc, (LPARAM) psd);
            break;

        case MAKELONG(IDC_SD_AUTHATTRIB, BN_CLICKED):
            psd->m_fAuthAttrib = SendDlgItemMessage(hdlg, IDC_SD_AUTHATTRIB, BM_GETCHECK,
                                                   0, 0);
            break;
            
        case IDC_SD_DO_AUTHATTRIB:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ATTRIB_CREATE), hdlg,
                           AuthAttribCreateDlgProc, (LPARAM) psd);
            break;

        case MAKELONG(IDC_SD_UNAUTHATTRIB, BN_CLICKED):
            psd->m_fUnAuthAttrib = SendDlgItemMessage(hdlg, IDC_SD_UNAUTHATTRIB, BM_GETCHECK,
                                                   0, 0);
            break;
            
        case IDC_SD_DO_UNAUTHATTRIB:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ATTRIB_CREATE), hdlg,
                           UnAuthAttribCreateDlgProc, (LPARAM) psd);
            break;

        default:
            return FALSE;
        }
        break;
        

    case WM_DESTROY:
        c = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCOUNT, 0, 0);
        for (i=0; i <c; i++) {
            p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                       CB_GETITEMDATA, i, 0);
            delete p;
        }
        break;
        
    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CALLBACK SignDataReadDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       c;
    DWORD                       cb;
    DWORD                       cbEncode;
    BOOL                        f;
    DWORD                       i;
    CSecurityPolicy *           p;
    LPBYTE                      pbEncode;
    SMIME_SECURITY_LABEL *      plabel;
    static CSignData *          psd = NULL;
    CHAR                        rgch[300];

    switch (msg) {
    case WM_INITDIALOG:
        break;

    case UM_SET_DATA:
        //  Fill in the dialog
        psd = (CSignData *) lParam;

        if ((psd != NULL) && (psd->m_pccert != NULL)) {
            GetFriendlyNameOfCertA(psd->m_pccert, rgch, sizeof(rgch));
            SetDlgItemText(hdlg, IDC_SDR_CERT_NAME, rgch);
        }
        else {
            SetDlgItemText(hdlg, IDC_SDR_CERT_NAME, "");
        }

        SendDlgItemMessage(hdlg, IDC_SDR_RECEIPT, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fReceipt)), 0);

        if (psd != NULL) {
            psd->GetLabel(&pbEncode, &cbEncode);
            SendDlgItemMessage(hdlg, IDC_SD_LABEL, BM_SETCHECK, (cbEncode > 0), 0);
            if (cbEncode > 0) {
                f = CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Security_Label,
                                        pbEncode, cbEncode, CRYPT_ENCODE_ALLOC_FLAG,
                                        NULL, &plabel, &cb);
                Assert(f);

                c = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCOUNT, 0, 0);
                for (i=0; i<c; i++) {
                    p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                               CB_GETITEMDATA, i, 0);
                    if (strcmp(p->szPolicyOID, plabel->pszObjIdSecurityPolicy) == 0) {
                        break;
                    }
                }
                if (i<c) {
                    SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_SETCURSEL, i, 0);
                    PolicyFillClassifications(hdlg, IDC_SD_POLICY,
                                              IDC_SD_CLASSIFICATION,
                                              IDC_SD_ADVANCED,
                                              plabel->dwClassification);
                }
		else {
		    SetDlgItemText(hdlg, IDC_SDR_POLICY, plabel->pszObjIdSecurityPolicy);
                    SetDlgItemInt(hdlg, IDC_SDR_CLASSIFICATION, plabel->dwClassification, TRUE);
		}
            
                LocalFree(plabel);
            }
            else {
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_SD_CERT_CHOOSE:
            if (DoCertDialog(hdlg, "Choose Signing Certificate", psd->GetMyStore(),
                             &psd->m_pccert, FILTER_RSA_SIGN | FILTER_DSA_SIGN)) {
                GetFriendlyNameOfCertA(psd->m_pccert, rgch, sizeof(rgch));
                SetDlgItemText(hdlg, IDC_SD_CERT_NAME, rgch);
            }
            break;

        case MAKELONG(IDC_SD_RECEIPT, BN_CLICKED):
            psd->m_fReceipt = SendDlgItemMessage(hdlg, IDC_SD_RECEIPT, BM_GETCHECK,
                                                 0, 0);
            return FALSE;

        case IDC_SD_DO_RECEIPT:
            // Dialog for button
            break;

        case IDM_VALIDATE:
            if (psd->m_pccert != NULL) {
                DWORD   dw;
                HCERTSTORE      hstore = NULL;
                HrValidateCert(psd->m_pccert, NULL, NULL, &hstore, &dw);
                if (hstore != NULL)
                    if (!CertCloseStore(hstore, CERT_CLOSE_STORE_CHECK_FLAG)) {
                        AssertSz(FALSE, "Store did not close");
                    }
            }
            break;

        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }

    return TRUE;
}


////////

HRESULT CSignInfo::AddToMessage(DWORD * pulLayers, IMimeMessage * pmm, HWND hwnd)
{
    HRESULT             hr;
    CSignData *         psd;

    DWORD                       count = 0;
    DWORD                       dwType = 0;
    HCERTSTORE                  hcertstore;
    IMimeBody *                 pmb = NULL;
    IMimeSecurity2 *            psmime2 = NULL;
    IMimeSecurity2 *            pms2 = NULL;
    PROPVARIANT                 rgpvAlgHash[MAX_LAYERS] = {0};
    PROPVARIANT                 rgpvAuthAttr[MAX_LAYERS] = {0};
    PCCERT_CONTEXT              rgpccert[MAX_LAYERS] = {0};
    PROPVARIANT                 var;

    hcertstore = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING, NULL,
                               0, NULL);
    if (hcertstore == NULL) {
        hr = E_FAIL;
        goto exit;
    }

    //  Pull out the body interface to set security properties
    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))             goto exit;

    //  Find out what security already exists
    hr = pmb->GetOption(OID_SECURITY_TYPE, &var);
    if (FAILED(hr))         goto exit;
    dwType = var.ulVal;

    //  if any security, then we need to push on a new layer, all previous security
    //  is now on the "y-security" layer and not on the hbody layer
    
    if (dwType != 0) {
        hr = pmm->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
        if (FAILED(hr))             goto exit;

        hr = pms2->Encode(hwnd, SEF_SENDERSCERTPROVIDED |
                          SEF_ENCRYPTWITHNOSENDERCERT);
        if (FAILED(hr))             goto exit;

        pms2->Release();            pms2 = NULL;
        dwType = 0;

        pmb->Release();             pmb = NULL;
        
        //  Pull out the body interface to set security properties
        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;
    }

    //

    hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &psmime2);
    if (FAILED(hr))             goto exit;

    if (psmime2 != NULL) {
        var.vt = VT_UI4;
        var.ulVal = Count();
        hr = pmb->SetOption(OID_SECURITY_SIGNATURE_COUNT, &var);
        if (FAILED(hr))         goto exit;
    }
    
    for (psd = Head(); psd != NULL; psd = psd->Next()) {
        hr = psd->BuildArrays(&count, &dwType, rgpvAlgHash, rgpccert,
                              rgpvAuthAttr, hcertstore, psmime2);
        if (FAILED(hr))         goto exit;
    }

    if (m_fBlob) {
        dwType |= MST_THIS_BLOBSIGN;
    }
    else {
        dwType |= MST_THIS_SIGN;
    }

    // M00HACK
    //        hr = InsertBody(pmm, HBODY_ROOT);
    //        if (FAILED(hr)) {
    //            goto exit;
    //        }


    //  Security Type
    var.vt = VT_UI4;
    var.ulVal = dwType;
    hr = pmb->SetOption(OID_SECURITY_TYPE, &var);
    if (FAILED(hr))         goto exit;

    var.vt = VT_UI4;
    var.ulVal = (DWORD) hcertstore;
    hr = pmb->SetOption(OID_SECURITY_HCERTSTORE, &var);
    if (FAILED(hr))             goto exit;

    var.vt = VT_UI4;
    var.ulVal = count;
    hr = pmb->SetOption(OID_SECURITY_SIGNATURE_COUNT, &var);
    if (FAILED(hr))         goto exit;
    
    if (count > 1) {
        var.vt = (VT_VECTOR | VT_VARIANT);
        var.capropvar.cElems = count;
        var.capropvar.pElems = rgpvAlgHash;
        hr = pmb->SetOption(OID_SECURITY_ALG_HASH_RG, &var);
        if (FAILED(hr))     goto exit;


        var.vt = (VT_VECTOR | VT_UI4);
        var.caul.cElems = count;
        var.caul.pElems = (DWORD *) rgpccert;
        hr = pmb->SetOption(OID_SECURITY_CERT_SIGNING_RG, &var);
        if (FAILED(hr))     goto exit;

        if (psmime2 == NULL) {
            var.vt = (VT_VECTOR | VT_VARIANT);
            var.capropvar.cElems = count;
            var.capropvar.pElems = rgpvAuthAttr;
            hr = pmb->SetOption(OID_SECURITY_AUTHATTR_RG, &var);
            if (FAILED(hr))         goto exit;
        }
    }
    else {
        var.vt = VT_BLOB;
        memcpy(&var.blob, &rgpvAlgHash[0].blob, sizeof(var.blob));
        hr = pmb->SetOption(OID_SECURITY_ALG_HASH, &var);
        if (FAILED(hr))     goto exit;

        var.vt = VT_UI4;
        var.ulVal = (ULONG) rgpccert[0];
        hr = pmb->SetOption(OID_SECURITY_CERT_SIGNING, &var);
        if (FAILED(hr))     goto exit;

        if (psmime2 == NULL) {
            var.vt = VT_BLOB;
            memcpy(&var.blob, &rgpvAuthAttr[0].blob, sizeof(var.blob));
            hr = pmb->SetOption(OID_SECURITY_AUTHATTR, &var);
            if (FAILED(hr))         goto exit;
        }
    }

    hr = S_OK;
exit:
    CertCloseStore(hcertstore, 0);
    if (pmb != NULL)            pmb->Release();
    if (psmime2 != NULL)        psmime2->Release();
    *pulLayers += 1;
    
    return hr;
}

int CSignInfo::Count() const
{
    int         count = 0;
    CSignData * psd;
    
    for (psd=Head(); psd != NULL; psd = psd->Next()) {
        count += 1;
    }
    
    return count;
}

//////////

CSignData::CSignData(int state) : 
    CItem(TYPE_SIGN_DATA, state)
{
    m_pccert = NULL;
    m_ulValidity = 0;
    m_valLabel.cbData = 0;
    m_valLabel.pbData = NULL;
    m_fReceipt = FALSE;
    m_fMLHistory = FALSE;
    m_fAuthAttrib = FALSE;
    m_fUnAuthAttrib = FALSE;
    m_fLabel = FALSE;
    m_valReceipt.cbData = 0;
    m_valReceipt.pbData = NULL;
    m_valMLHistory.cbData = 0;
    m_valMLHistory.pbData = NULL;
    m_valAuthAttrib.cbData = 0;
    m_valAuthAttrib.pbData = NULL;
    m_szAuthAttribOID = NULL;
    m_valUnAuthAttrib.cbData = 0;
    m_valUnAuthAttrib.pbData = NULL;
    m_szUnAuthAttribOID = NULL;
}

HRESULT CSignData::BuildArrays(DWORD * pCount, DWORD * pdwType,
                               PROPVARIANT * rgvHash, PCCERT_CONTEXT * rgpccert,
                               PROPVARIANT * rgvAuthAttr, HCERTSTORE hcertstore,
                               IMimeSecurity2 * psmime2)
{
    CRYPT_ATTRIBUTES    attrs;
    BOOL                f;
    int                 i = *pCount;
    CRYPT_ATTRIBUTE     rgattrs[4];
    PROPVARIANT         var;



    *pdwType |= MST_THIS_SIGN;
    rgvHash[i].blob.pBlobData = (LPBYTE) RgbSHA1AlgId;
    rgvHash[i].blob.cbSize = CbSHA1AlgId;
    //  Don't add ref the certificate -- we don't free it in the caller.
    rgpccert[i] = m_pccert;
    f = CertAddCertificateContextToStore(hcertstore, m_pccert,
                                         CERT_STORE_ADD_USE_EXISTING, NULL);
    Assert(f);


    //  Setup for encoding authenticated attributes
    attrs.cAttr = 0;
    attrs.rgAttr = rgattrs;
    
    //  Encode in the label
    if (m_valLabel.pbData != NULL) {
        rgattrs[attrs.cAttr].pszObjId = szOID_SMIME_Security_Label;
        rgattrs[attrs.cAttr].cValue = 1;
        rgattrs[attrs.cAttr].rgValue = &m_valLabel;

        if (psmime2 != NULL) {
            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_SIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
        else {
            attrs.cAttr += 1;
        }
    }

    if (m_valReceipt.pbData != NULL) {
        rgattrs[attrs.cAttr].pszObjId = szOID_SMIME_Receipt_Request;
        rgattrs[attrs.cAttr].cValue = 1;
        rgattrs[attrs.cAttr].rgValue = &m_valReceipt;

        if (psmime2 != NULL) {
            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_SIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
        else {
            attrs.cAttr += 1;
        }
    }

    if (m_valMLHistory.pbData != NULL) {
        rgattrs[attrs.cAttr].pszObjId = szOID_SMIME_MLExpansion_History;
        rgattrs[attrs.cAttr].cValue = 1;
        rgattrs[attrs.cAttr].rgValue = &m_valMLHistory;

        if (psmime2 != NULL) {
            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_SIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
        else {
            attrs.cAttr += 1;
        }
    }

    if ((m_szAuthAttribOID != NULL) && (m_valAuthAttrib.pbData != NULL)) {
        rgattrs[attrs.cAttr].pszObjId = m_szAuthAttribOID;
        rgattrs[attrs.cAttr].cValue = 1;
        rgattrs[attrs.cAttr].rgValue = &m_valAuthAttrib;

        if (psmime2 != NULL) {
            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_SIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
        else {
            attrs.cAttr += 1;
        }
    }

    if (psmime2 != NULL) {
        if ((m_szUnAuthAttribOID != NULL) && (m_valUnAuthAttrib.pbData != NULL)) {
            rgattrs[attrs.cAttr].pszObjId = m_szUnAuthAttribOID;
            rgattrs[attrs.cAttr].cValue = 1;
            rgattrs[attrs.cAttr].rgValue = &m_valUnAuthAttrib;

            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_UNSIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
    }

    Assert(attrs.cAttr <= sizeof(rgattrs)/sizeof(rgattrs[0]));
    if (attrs.cAttr > 0) {
        f = CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                &attrs, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                &rgvAuthAttr[i].blob.pBlobData,
                                &rgvAuthAttr[i].blob.cbSize);
        Assert(f);
    }

    *pCount = i+1;
    return S_OK;
}

void CSignData::SetLabel(LPBYTE pb, DWORD cb)
{
    if (m_valLabel.pbData != NULL) {
        free(m_valLabel.pbData);
        m_valLabel.pbData = NULL;
        m_valLabel.cbData = 0;
    }
    if (cb > 0) {
        m_valLabel.pbData = (LPBYTE) malloc(cb);
        memcpy(m_valLabel.pbData, pb, cb);
        m_valLabel.cbData = cb;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\smtpcall.cpp ===
// --------------------------------------------------------------------------------
// Smtpcall.cpp
// --------------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include "smtpcall.h"

extern DWORD            MsgSMTP;
// --------------------------------------------------------------------------------
// HrCreateSMTPTransport
// --------------------------------------------------------------------------------
HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP)
{
    // Locals
    HRESULT             hr;
    CSMTPCallback      *pCallback=NULL;

    // Create callback object
    pCallback = new CSMTPCallback();
    if (NULL == pCallback)
    {
        printf("Memory allocation failure\n");
        return E_OUTOFMEMORY;
    }

    // Load SMTP Transport
    hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport, (LPVOID *)ppSMTP);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_ISMTPTransport\n");
        return E_FAIL;
    }

    // InitNew
    hr = (*ppSMTP)->InitNew(NULL, pCallback);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_ISMTPTransport\n");
        return E_FAIL;
    }

    // Done
    pCallback->Release();
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::CSMTPCallback(void)
{
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::~CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::~CSMTPCallback(void)
{
}

// --------------------------------------------------------------------------------
// CSMTPCallback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_ISMTPCallback
    else if (IID_ISMTPCallback == riid)
        *ppv = (ISMTPCallback *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = E_NOINTERFACE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnLogonPrompt(
        LPINETSERVER            pInetServer,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CSMTPCallback::OnPrompt(
        HRESULT                 hrError, 
        LPCTSTR                 pszText, 
        LPCTSTR                 pszCaption, 
        UINT                    uType,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnError(
        IXPSTATUS               ixpstatus,
        LPIXPRESULT             pIxpResult,
        IInternetTransport     *pTransport)
{
    printf("CSMTPCallback::OnError - Status: %d, hrResult: %08x\n", ixpstatus, pIxpResult->hrResult);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnStatus(
        IXPSTATUS               ixpstatus,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;

    pTransport->GetServerInfo(&rServer);

    switch(ixpstatus)
    {
    case IXP_FINDINGHOST:
        printf("Finding '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTING:
        printf("Connecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_SECURING:
        printf("Establishing secure connection to '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTED:
        printf("Connected '%s'\n", rServer.szServerName);
        break;
    case IXP_AUTHORIZING:
        printf("Authorizing '%s'...\n", rServer.szServerName);
        break;
    case IXP_AUTHRETRY:
        printf("Retrying Logon '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTING:
        printf("Disconnecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTED:
        printf("Disconnected '%s'\n", rServer.szServerName);
        PostThreadMessage(GetCurrentThreadId(), MsgSMTP, IXP_DISCONNECTED, 0);
        PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_QUIT, 0);
        break;
    }
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnProgress(
        DWORD                   dwIncrement,
        DWORD                   dwCurrent,
        DWORD                   dwMaximum,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnCommand(
        CMDTYPE                 cmdtype,                                            
        LPSTR                   pszLine,
        HRESULT                 hrResponse,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    if (CMD_SEND == cmdtype)
    {
        printf("%s[TX]: %s", rServer.szServerName, pszLine);
    }
    else if (CMD_RESP == cmdtype)
        printf("%s[RX]: %s - %08x\n", rServer.szServerName, pszLine, hrResponse);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnTimeout(
        DWORD                  *pdwTimeout,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnResponse(
        LPSMTPRESPONSE              pResponse)
{
    switch(pResponse->command)
    {
    case SMTP_NONE:
        break;

    case SMTP_BANNER:
        break;

    case SMTP_CONNECTED:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_CONNECTED, 0);
        break;

    case SMTP_SEND_MESSAGE:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_SEND_MESSAGE, 0);
        break;

    case SMTP_EHLO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_EHLO, 0);
        break;

    case SMTP_HELO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_HELO, 0);
        break;

    case SMTP_MAIL:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_MAIL, 0);
        break;

    case SMTP_RCPT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_RCPT, 0);
        break;

    case SMTP_RSET:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_RSET, 0);
        break;

    case SMTP_QUIT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_QUIT, 0);
        break;

    case SMTP_DATA:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_DATA, 0);
        break;

    case SMTP_DOT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_DOT, 0);
        break;

    case SMTP_SEND_STREAM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_SEND_STREAM, 0);
        break;

    case SMTP_CUSTOM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_CUSTOM, 0);
        break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\wabstuff.cpp ===
/*
 * WAB stuff for S/Mime Test
 */
#include <windows.h>
#include <wab.h>
#include "smimetst.h"
#include "instring.h"
#include "wabstuff.h"
#include "dbgutil.h"


LPWABOPEN lpfnWABOpen = NULL;
const static TCHAR szWABOpen[] = TEXT("WABOpen");
LPWABOBJECT lpWABObject = NULL;
LPADRBOOK lpAdrBook = NULL;
HINSTANCE hInstWABDll = NULL;


//$$//////////////////////////////////////////////////////////////////////
//
// GetWABDllPath
//
//
//////////////////////////////////////////////////////////////////////////
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    ULONG  cbData;
    HKEY hKey = NULL;
    TCHAR szPathT[MAX_PATH + 1];

    if(szPath) {
        *szPath = '\0';

        // open the szWABDllPath key under
        if (ERROR_SUCCESS == RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                                            WAB_DLL_PATH_KEY,
                                            0,      //reserved
                                            KEY_READ,
                                            &hKey))
        {
            cbData = sizeof(szPathT);
            if (ERROR_SUCCESS == RegQueryValueEx(    hKey,
                                "",
                                NULL,
                                &dwType,
                                (LPBYTE) szPathT,
                                &cbData))
            {
                if (dwType == REG_EXPAND_SZ)
                    cbData = ExpandEnvironmentStrings(szPathT, szPath, cb / sizeof(TCHAR));
                else
                {
                    if(GetFileAttributes(szPathT) != 0xFFFFFFFF)
                        lstrcpy(szPath, szPathT);
                }
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);
}


/***************************************************************************

    Name      : WABFreePadrlist

    Purpose   : Free an adrlist and it's property arrays

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
void WABFreePadrlist(LPADRLIST lpAdrList) {
    ULONG           iEntry;

    if (lpAdrList) {
        for (iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry) {
            if (lpAdrList->aEntries[iEntry].rgPropVals) {
                WABFreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
            }
        }
        WABFreeBuffer(lpAdrList);
    }
}


//$$//////////////////////////////////////////////////////////////////////
//
// LoadLibrary_WABDll()
//
//  Since we are moving the WAB directory out of Windows\SYstem, we cant be
//  sure it will be on the path. Hence we need to make sure that WABOpen will
//  work - by loading the wab32.dll upfront
//
///////////////////////////////////////////////////////////////////////////
HINSTANCE LoadLibrary_WABDll(void)
{
    IF_WIN32(LPTSTR lpszWABDll = TEXT("Wab32.dll");)
    TCHAR  szWABDllPath[MAX_PATH + 1];
    HINSTANCE hinst = NULL;

    GetWABDllPath(szWABDllPath, sizeof(szWABDllPath));

    hinst = LoadLibrary((lstrlen(szWABDllPath)) ? szWABDllPath : lpszWABDll);

    return hinst;
}


void LoadWAB(void) {
    LPWABOPEN lpfnWABOpen = NULL;

    if (! hInstWABDll) {
        hInstWABDll = LoadLibrary_WABDll();
        if (hInstWABDll)
            lpfnWABOpen = (LPWABOPEN) GetProcAddress(hInstWABDll, szWABOpen);
        if (lpfnWABOpen)
            lpfnWABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    }
}


void UnloadWAB(void) {
    if (lpAdrBook) {
        lpAdrBook->Release();
        lpAdrBook = NULL;

        lpWABObject->Release();
        lpWABObject = NULL;
    }
    if (hInstWABDll) {
        FreeLibrary(hInstWABDll);
        hInstWABDll = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\res\inetres.h ===
// INETRES.H

#ifndef __INETRES__H
#define __INETRES__H
#include <windows.h>
#endif // __INETRES__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\wabstuff.h ===
extern LPWABOBJECT lpWABObject;
extern LPADRBOOK lpAdrBook;


extern void LoadWAB(void);
extern void UnloadWAB(void);
extern void WABFreePadrlist(LPADRLIST lpAdrList);

#define WABAllocateBuffer(cbSize, lppBuffer) lpWABObject->AllocateBuffer(cbSize, lppBuffer)
#define WABAllocateMore(cbSize, lpObject, lppBuffer) lpWABObject->AllocateMore(cbSize, lpObject, lppBuffer)
#define WABFreeBuffer(lpBuffer) lpWABObject->FreeBuffer(lpBuffer)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\smimetst.h ===
#define IDM_NEW                     1
#define IDM_OPEN                    2
#define IDM_SAVE                    3
#define IDM_SAVEAS                  4
#define IDM_EXIT                    5
#define IDM_OPTIONS                 6
#define IDM_F_MAILLIST                  7

#define IDM_HELP                    40
#define IDM_ABOUT                   41
#define IDM_ENCODE                      42

#define IDM_E_INSERT_SIGN               100
#define IDM_E_INSERT_ENCRYPT            101
#define IDM_E_INSERT_SIGNATURE          102
#define IDM_E_DELETE_LAYER              103
#define IDM_E_DELETE_SIGNATURE          104
#define IDM_E_INSERT_TRANSPORT          105
#define IDM_E_INSERT_AGREEMENT          106
#define IDM_E_INSERT_MAILLIST           107

#define IDM_F_OPTIONS                   110

#define IDM_ALLOCATE                1001
#define IDM_WABOPEN                 1003
#define IDM_ADDRESS                 1006
#define IDM_ADDRESS_WELLS0          1014
#define IDM_ADDRESS_WELLS1          1015
#define IDM_ADDRESS_WELLS2          1016
#define IDM_ADDRESS_WELLS3          1017
#define IDM_ADDRESS_DEFAULT         1018


#define IDM_CLEARSIGN               1100
#define IDM_OPAQUESIGN              1101
#define IDM_ENCRYPT                 1102
#define IDM_SIGNANDENCRYPT          1103
#define IDM_CLEARTRIPLEWRAP         1104
#define IDM_OPAQUETRIPLEWRAP        1105
#define IDM_DECODE                  1106
#define IDM_RESET                       1107
#define IDM_VALIDATE                    1108

#define idd_Options                     2000
#define IDD_MSG_DATA                    2001
#define IDD_SIGN_INFO_COMPOSE           2002
// #define IDD_SIGN_INFO_READ              2003
#define IDD_SIGN_DATA_COMPOSE           2004
#define IDD_SIGN_DATA_READ		2005
#define IDD_ENCRYPT_INFO_COMPOSE        2006
#define IDD_ENCRYPT_INFO_READ           2007
#define IDD_ENC_AGREE_COMPOSE           2008
#define IDD_ENC_TRANS_COMPOSE           2010
#define IDD_ENC_ML_COMPOSE              2012
#define IDD_RECEIPT_CREATE              2014
#define IDD_DETAIL                      2015
#define IDD_FILE_MAILLIST               2016
#define IDD_MLDATA_CREATE               2017
#define IDD_FILE_ADD_ML                 2018
#define IDD_ATTRIB_CREATE               2019

#define IDC_RC_FROM_ALL                 100
#define IDC_RC_FROM_TOP                 101
#define IDC_RC_FROM_SOME                102
#define IDC_RC_FROM_TEXT                103
#define IDC_RC_TO_TEXT                  104
#define IDC_RC_CONTENT                  105

#define IDC_O_CERT_CHOOSE               100
#define IDC_O_CERT_NAME                 101
#define IDC_O_MY_NAMES                  102
#define IDC_SENDER_GROUP            6000
#define IDC_RECIPIENT_GROUP         6001
#define IDC_SENDER_EMAIL            6100
#define IDC_RECIPIENT_EMAIL         6200

#define IDC_SI_BLOB_SIGN                100

#define IDC_SD_CERT_CHOOSE              100
#define IDC_SD_CERT_NAME                101
#define IDC_SD_USE_SKI                  102
#define IDC_SD_LABEL                    103
#define IDC_SD_POLICY                   104
#define IDC_SD_CLASSIFICATION           105
#define IDC_SD_PRIVACY_MARK             106
#define IDC_SD_ADVANCED                 107
#define IDC_SD_RECEIPT                  108
#define IDC_SD_DO_RECEIPT               109
#define IDC_SD_MLDATA                   110
#define IDC_SD_DO_MLDATA                111
#define IDC_SD_AUTHATTRIB               112
#define IDC_SD_DO_AUTHATTRIB            113
#define IDC_SD_UNAUTHATTRIB             114
#define IDC_SD_DO_UNAUTHATTRIB          115

#define IDC_SDR_CERT_VIEW                100
#define IDC_SDR_CERT_NAME                101
#define IDC_SDR_LABEL                    103
#define IDC_SDR_POLICY                   104
#define IDC_SDR_CLASSIFICATION           105
#define IDC_SDR_PRIVACY_MARK             106
#define IDC_SDR_ADVANCED                 107
#define IDC_SDR_RECEIPT                  108
#define IDC_SDR_DO_RECEIPT               109

#define IDC_MD_PLAIN_CHOOSE             100
#define IDC_MD_PLAIN_NAME               101
#define IDC_MD_CIPHER_CHOOSE            102
#define IDC_MD_CIPHER_NAME              103
#define IDC_MD_ITERATION                104
#define IDC_MD_TOFILE                   105

#define IDC_ETC_LIST                    100
#define IDC_ETC_ADD_CERT                101
#define IDC_ETC_DEL_CERT                102
#define IDC_ETC_SKI                     103

#define IDC_EIC_AUTO                    100
#define IDC_EIC_FORCE                   101
#define IDC_EIC_ENC_ALG                 102
#define IDC_EIC_ALG_SELECT              103
#define IDC_EIC_ATTRIBUTES              104
#define IDC_EIC_UNPROTATTRIB            105
#define IDC_EIC_DO_UNPROTATTRIB         106

#define IDC_MLC_ID                      100
#define IDC_MLC_KEY                     101
#define IDC_MLC_ALG                     102
#define IDC_MLC_CSPS                    103

#define IDC_FML_LIST                    100
#define IDC_FML_ADD                     101
#define IDC_FML_DELETE                  102

#define IDC_MLC_ABSENT1                 100
#define IDC_MLC_NONE1                   101
#define IDC_MLC_INSTEAD1                102
#define IDC_MLC_ALSO1                   103
#define IDC_MLC_NAMES1                  104
#define IDC_MLC_ABSENT2                 105
#define IDC_MLC_NONE2                   106
#define IDC_MLC_INSTEAD2                107
#define IDC_MLC_ALSO2                   108
#define IDC_MLC_NAMES2                  109
#define IDC_MLC_OTHERS                  110
#define IDC_MLC_INCLUDE2                111
#define IDC_MLC_CERT1                   112
#define IDC_MLC_CERT2                   113
#define IDC_MLC_ID1                     114
#define IDC_MLC_ID2                     115
#define IDC_MLC_SELECT1                 116
#define IDC_MLC_SELECT2                 117

#define IDC_AMLK_ID                     100
#define IDC_AMLK_KEY                    101
#define IDC_AMLK_ALG                    102
#define IDC_AMLK_DATE                   103
#define IDC_AMLK_OTHER                  104

#define IDC_BA_OID_L                    100
#define IDC_BA_OID                      101
#define IDC_BA_ASN_L                    102
#define IDC_BA_ASN                      103

#if 0
#define IDC_SENDER_NAME             6101
#define IDC_SENDER_CHOOSE           6102
#define IDC_RECIPIENT_NAME          6201
#define IDC_RECIPIENT_CHOOSE        6202
#define IDC_OUTPUT_FILE             6300
#define IDC_OUTPUT_FILE_BROWSE      6301
#endif // 0
#define IDC_STATIC                  -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\res\makefile.inc ===
$(O)\athver.bat : $(R)\res\athver.tmp $(BASEDIR)\public\sdk\inc\ntverp.h $(BASEDIR)\public\sdk\inc\ieverp.h
    cl /EP /I$(BASEDIR)\public\sdk\inc /DNASHVILLE /Tc $(R)\res\athver.tmp > $@

$(O)\inetcomm.rc : $(R)\res\inetcomm.rc 
    copy $** $@

$(O)\inetcomm.res : $(O)\selfreg.inf

selfreg.src : reg.src strings.src

$(O)\selfreg.inx : selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx $(O)\athver.bat
    $(O)\athver.bat $(O)\selfreg.inx $(O)\selfreg.in2
    $(CLEANINF) $(O)\selfreg.in2 $@
    del $(O)\selfreg.in2

$O\*.sbr :
    move $(R)\inc\$O\*.sbr $O
    move $(R)\mimeole\$O\*.sbr $O
    move $(R)\imnxport\$O\*.sbr $O
    move $(R)\dll\$O\*.sbr $O
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\smimetst.cpp ===
/* --- FIXES

--  SMIME TEST

fixed  --- Can't do more than 4 || signers
fixed  --- Can't Sc(Ekt(B))
-  --- Sb(Sb(Sb(B))) only two layers are generated?
-  --- Unauthenticated attributes
*/


///  http:iptdalpha3 - symbols for crypt32.

/*-----------------------------------------
   SMimeTst.C -- Function Test of S/Mime
  -----------------------------------------*/

#define INITGUID
#define DEFINE_STRCONST
#include "item.h"

#include "smtpcall.h"
#include "instring.h"
#include "dbgutil.h"
#include "sign.h"
#include "maillist.h"


#define WinMainT WinMain
long FAR PASCAL WndProc (HWND, UINT, UINT, LONG);

char szAppName [] = "SMimeTst";
static const TCHAR c_szDebug[]      = "mshtmdbg.dll";
static const TCHAR c_szDebugUI[]    = "DoTracePointsDialog";
static const TCHAR c_szRegSpy[]     = "DbgRegisterMallocSpy";
static const TCHAR c_szInvokeUI1[]   = "/d";
static const TCHAR c_szInvokeUI2[]   = "-d";
HINSTANCE hInst;

const int       MAX_LAYERS = 100;
extern const BYTE RgbSHA1AlgId[];
extern const int  CbSHA1AlgId;

const GUID GuidCertValidate = CERT_CERTIFICATE_ACTION_VERIFY;

HWND            HdlgMsg;
HWND            HwndTree;

BOOL CALLBACK DetailDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncDataComposeDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncTransCompDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncAgreeCompDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncInfoReadDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK MailListDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);

enum {
    Dlg_Message,
    Dlg_Sign_Info_Compose,
    Dlg_Sign_Info_Read,
    Dlg_Sign_Data_Compose,
    Dlg_Sign_Data_Read,
    Dlg_Enc_Info_Compose,
    Dlg_Enc_Info_Read,
    Dlg_Enc_Data_Agree_Compose,
    Dlg_Enc_Data_Trans_Compose,
    Dlg_Enc_Data_MailList_Compose,
    Dlg_Max
};

struct {
    int         id;
    DLGPROC     proc;
    HWND        hwnd;
} RgDlgs[] = {
    {IDD_DETAIL, DetailDlgProc},
    {IDD_SIGN_INFO_COMPOSE, SignInfoDlgProc},
    {IDD_SIGN_INFO_COMPOSE, SignInfoDlgProc},
    {IDD_SIGN_DATA_COMPOSE, SignDataDlgProc},
    {IDD_SIGN_DATA_READ, SignDataReadDlgProc},
    {IDD_ENCRYPT_INFO_COMPOSE, EncDataDlgProc},
    {IDD_ENCRYPT_INFO_READ, EncInfoReadDlgProc},
    {IDD_ENC_AGREE_COMPOSE, EncAgreeCompDlgProc},
    {IDD_ENC_TRANS_COMPOSE, EncTransCompDlgProc},
    {IDD_ENC_ML_COMPOSE, EncMLComposeDlgProc}
};

HWND            HdlgEncData;
HWND            HdlgSignInfo;
HWND            HwndDetail;
CMessage        RootMsg;
BYTE            RgbSignHash[20];

HCERTSTORE              HCertStoreMy = NULL;

IImnAccountManager *    PAcctMan = NULL;
ISMTPTransport *        PSmtp = NULL;
extern DWORD            MsgSMTP = 0;


char    RgchBody[] = "Now is the time for all good men (and women) to come to the aid of their country.\r\n";

char    RgchExample[] = "This is some sample content.";

typedef void (STDAPICALLTYPE *PFNDEBUGUI)(BOOL);
typedef void (STDAPICALLTYPE *PFNREGSPY)(void);

void WaitForCompletion(UINT uiMsg, DWORD wparam)
{
    MSG msg;
    while(GetMessage(&msg, NULL, 0, 0))
    {
        if ((msg.message == uiMsg) && (msg.wParam == wparam) ||
            (msg.wParam == IXP_DISCONNECTED))
            break;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

void ShowWindow(int id, LPARAM lparam)
{
    int         i;
    for (i=0; i<Dlg_Max; i++) {
        ShowWindow(RgDlgs[i].hwnd, SW_HIDE);
    }
    
    ShowWindow(RgDlgs[id].hwnd, SW_SHOWNORMAL);
    SendMessage(RgDlgs[id].hwnd, UM_SET_DATA, 0, lparam);
}

BOOL pfnFilter(PCCERT_CONTEXT pccert, long lCustData, DWORD, DWORD)
{
    BOOL        f = FALSE;
    LPCSTR      pszObjId = pccert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

    if (lCustData & FILTER_RSA_KEYEX) {
        f |= (strcmp(pszObjId, szOID_RSA_RSA) == 0);
    }
    if (lCustData & FILTER_RSA_SIGN) {
        f |= (strcmp(pszObjId, szOID_RSA_RSA) == 0);
    }
    if (lCustData & FILTER_DSA_SIGN) {
        f |= (strcmp(pszObjId, szOID_X957_DSA) == 0);
    }
    if (lCustData & FILTER_DH_KEYEX) {
        f |= (strcmp(pszObjId, szOID_ANSI_X942_DH) == 0);
    }
    if (lCustData & FILTER_KEA_KEYEX) {
        f |= (strcmp(pszObjId, szOID_INFOSEC_keyExchangeAlgorithm) == 0);
    }
    return f;
}


BOOL DoCertDialog(HWND hwndOwner, LPTSTR szTitle, HCERTSTORE hCertStore, PCCERT_CONTEXT *ppCert, int iFilter)
{
    DWORD               cchEmail;
    CERT_SELECT_STRUCT  css = {0};
    PCCERT_CONTEXT      pCurCert;
    BOOL                fRet = FALSE;

    pCurCert = CertDuplicateCertificateContext(*ppCert);

    css.dwSize = sizeof(CERT_SELECT_STRUCT);
    css.hwndParent = hwndOwner;
    css.hInstance = hInst;
    css.arrayCertStore = &hCertStore;
    css.szTitle = szTitle;
    css.cCertStore = 1;
    css.szPurposeOid = szOID_PKIX_KP_EMAIL_PROTECTION;
    css.arrayCertContext = ppCert;
    css.cCertContext = 1;
    css.lCustData = iFilter;
    css.pfnFilter = pfnFilter;

    if (CertSelectCertificate(&css) && (pCurCert != *ppCert)) {
        fRet = TRUE;
    }
    CertFreeCertificateContext(pCurCert);

    return fRet;
}

BOOL ViewCertDialog(HWND hwndOwner, LPTSTR szTitle, PCCERT_CONTEXT pCert)
{
    CERT_VIEWPROPERTIES_STRUCT         cvs = {0};
    char *                             psz = szOID_PKIX_KP_EMAIL_PROTECTION;

    cvs.dwSize = sizeof(cvs);
    cvs.hwndParent = hwndOwner;
    cvs.szTitle = szTitle;
    cvs.pCertContext = pCert;
    cvs.cArrayPurposes = 1;
    cvs.arrayPurposes = &psz;

    CertViewProperties(&cvs);

    return TRUE;
}


//  HrValidateCert
//
//  Description:
//      This routine is used to check the validity of a certificate, the codes
//      are modified from HrDoTrustWork in cryptdlg.dll, by xzhang
//
//  Parameters:
//      pcert - Point to the certificate we want to validate
//      hstore - Extra store for searching certficates
//      pbd - Point to BinData for returning the certificate chain
//      pcCertsInChain - Point to DWORD for returning the # of certs in chain
//      pdwErrors - Returns the errors encountered in validating the cert
//
//  Return Value:
//      Result code of operation.
//
//  Returned in *pdwErrors;
//
//      The return value consists of a set of flags about why we failed to
//      do the validation.  Current reasons are:
//
//      SIGFAILURE_INVALID_CERT - Certificate is internally inconsistant
//      SIGFAILURE_UNKNOWN_ROOT - Root certificate in chain is either unknown
//                                      or not self sign.
//      SIGFAILURE_CERT_EXPIRED - Certificate has expired
//      SIGFAILURE_CERT_REVOKED - Certificate has been revoked
//      SIGFAILURE_CRL_NOT_FOUND - CRL was not found for some Issuer
//      SIGFAILURE_INVALID_SIGNATURE - Invalid signature, not the above reason
//

HRESULT HrValidateCert(PCCERT_CONTEXT pccert, HCERTSTORE hstore, HCRYPTPROV hprov,
                       HCERTSTORE * phcertstorOut, DWORD * pdwErrors)
{
    WINTRUST_BLOB_INFO              blob = {0};
    DWORD                           cCertsInChain = 0;
    DWORD                           cStores;
    WINTRUST_DATA                   data = {0};
    DWORD                           dwCAs = 0;
    DWORD                           dwErrors = 0;
    DWORD                           dwRet = 0;
    BOOL                            f;
    HCERTSTORE                      hcertstorOut;
    DWORD                           i;
    PCCERT_CONTEXT                  pccertOut = NULL;
    PCCERT_CONTEXT *                rgCerts = NULL;
    DWORD *                         rgdwErrors = NULL;
    HCERTSTORE                      rghstoreCA[2] = {NULL};
    CERT_VERIFY_CERTIFICATE_TRUST   trust = {0};
    HRESULT                         hr;

    Assert(pdwErrors != NULL);

    //
    //  Make sure we have a place to store the output unless we are being
    //    told to ignore it
    //

    if (phcertstorOut != NULL) {
        // Try to open an output store if we have not been given one
        
        if (*phcertstorOut == NULL) {
            hcertstorOut = CertOpenStore(CERT_STORE_PROV_MEMORY, 
                                         X509_ASN_ENCODING, hprov,
                                         CERT_STORE_NO_CRYPT_RELEASE_FLAG, 
                                         NULL);
            if (hcertstorOut == NULL) {
                hr = E_FAIL;
                goto ExitHere;
            }
            *phcertstorOut = hcertstorOut;
        }
        else {
            hcertstorOut = *phcertstorOut;
        }
    }
    else {
        // No output is being requested
        
        hcertstorOut = NULL;
    }        

    //
    //  Fill the WINTRUST_DATA 
    //
    
    data.cbStruct = sizeof(WINTRUST_DATA);
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;

    //
    //  Fill the trust blob information
    //
    
    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.cbMemObject = sizeof(CERT_VERIFY_CERTIFICATE_TRUST);
    blob.pbMemObject = (LPBYTE)&trust;


    //
    //  Fill the certificate trust information
    //
    trust.cbSize = sizeof(trust);
    trust.pccert = pccert;
    trust.dwFlags = (CERT_TRUST_DO_FULL_SEARCH | CERT_TRUST_PERMIT_MISSING_CRLS
                    |CERT_TRUST_DO_FULL_TRUST | CERT_TRUST_ADD_CERT_STORES);
    trust.dwIgnoreErr = CERT_VALIDITY_NO_CRL_FOUND;
    trust.pdwErrors = &dwErrors;
    trust.pszUsageOid = szOID_PKIX_KP_EMAIL_PROTECTION;
    trust.hprov = hprov;

    //
    //  If we have a store of certificates, then pass it in to give us additional
    //  places to look
    //

    rghstoreCA[0] = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                  hprov, (CERT_SYSTEM_STORE_CURRENT_USER |
                                          CERT_STORE_NO_CRYPT_RELEASE_FLAG),
                                  L"CA");
    if (rghstoreCA[0] == NULL) {
        hr = E_FAIL;
        goto ExitHere;
    }

    cStores = 1;
    trust.rghstoreCAs = rghstoreCA;
    
    if (hstore) {
        cStores = 2;
        rghstoreCA[1] = hstore;
    }
    trust.cStores = cStores;

    trust.pcChain = &cCertsInChain;
    trust.prgChain = &rgCerts;
    trust.prgdwErrors = &rgdwErrors;

    //
    //  Call the brain function to verify the trust status of this certificate
    //

    hr = WinVerifyTrust(NULL, (GUID *)&GuidCertValidate, &data);
    if(FAILED(hr) || cCertsInChain == 0) {
        //
        //  We completely failed the verificaiton
        //
        
        *pdwErrors = /*SIGFAILURE_OTHER*/ 1;

        //
        //  But we still need to shove this certificate into the output store
        //  if the user wants one
        //
        
        if (NULL != hcertstorOut) {
            // Add the certificate to the store.  We need to remember the
            //  new context so we can properly add CRLs
            
            f = CertAddCertificateContextToStore(hcertstorOut, pccert,
                                                 CERT_STORE_ADD_NEW, 
                                                 &pccertOut);
            Assert(f || (NULL == pccertOut));
            
            // Look for any CRLs which might apply to the new context
            //  and add them to the store as well

            if (NULL != pccertOut) {
                //                hr = HrAddValidCRLsToStore(hcertstorOut, pccertOut, 
                //                                           rghstoreCA, cStores);
                Assert(S_OK == hr);                        
            }                
        }                                                 
        hr = S_OK;
        goto ExitHere;
    }

    //
    // Now build the certificates chain for SSignature when requested
    //
    
    if (hcertstorOut != NULL) {
        if (cCertsInChain == 0) {
            // Store the certificate in the output store and remember the
            //  new certificate context for checking the CRLs
            
            f = CertAddCertificateContextToStore(hcertstorOut, pccert,
                                                 CERT_STORE_ADD_NEW, 
                                                 &pccertOut);
            Assert(f || (NULL == pccertOut));
                                                 
            // Look for any CRLs which might apply and add them to the store
            //  as well

            if (NULL != pccertOut) {
                //                hr = HrAddValidCRLsToStore(hcertstorOut, pccertOut,
                //                                           rghstoreCA, cStores);
                Assert(S_OK == hr);
            }                
        }

        for (i=0; i<cCertsInChain; i++) {
            // Free any output certificate context we have already

            if (NULL != pccertOut) {
                CertFreeCertificateContext(pccertOut);
                pccertOut = NULL;
            }
            
            // Add the encoded certificate to the store
            
            f = CertAddEncodedCertificateToStore(hcertstorOut, X509_ASN_ENCODING,
                                                 rgCerts[i]->pbCertEncoded,
                                                 rgCerts[i]->cbCertEncoded,
                                                 CERT_STORE_ADD_NEW, &pccertOut);
            Assert(f || (NULL == pccertOut));

            // Add any appropriate CRLs to the store as well

            if (NULL != pccertOut) {
                // hr = HrAddValidCRLsToStore(hcertstorOut, pccertOut,
                //                                           rghstoreCA, cStores);
                Assert(S_OK == hr);                        
            }                
        }
    }

    //
    // Setup the signuare error flags as used in ExSec32.dll
    //
    
    if(rgdwErrors == NULL) {
        *pdwErrors = /*SIGFAILURE_OTHER*/ 1;
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto ExitHere;
    }
    
    // We only care about the trust status of the leaf certificate
    
    dwErrors = rgdwErrors[0];

    if (dwErrors != 0) {
        if(dwErrors & CERT_VALIDITY_SIGNATURE_FAILS) {
            dwRet |= /*SIGFAILURE_INVALID_CERT*/ 2;
            dwErrors &= ~CERT_VALIDITY_SIGNATURE_FAILS;
        }
        if(dwErrors & CERT_VALIDITY_CERTIFICATE_REVOKED) {
            dwRet |= /*SIGFAILURE_CERT_REVOKED*/ 4;
            dwErrors &= ~CERT_VALIDITY_CERTIFICATE_REVOKED;
        }
        if(dwErrors & CERT_VALIDITY_AFTER_END) {
            dwRet |= /*SIGFAILURE_CERT_EXPIRED*/ 8;
            dwErrors &= ~CERT_VALIDITY_AFTER_END;
        }
        if(dwErrors & CERT_VALIDITY_EXPLICITLY_DISTRUSTED) {
            dwRet |= /*SIGFAILURE_CERT_DISTRUSTED*/ 16;
            dwErrors &= ~CERT_VALIDITY_EXPLICITLY_DISTRUSTED;
        }
        if((dwErrors & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) &&
           (cCertsInChain == 1)) {
            dwRet |= /*SIGFAILURE_CERT_DISTRUSTED*/ 128;
            dwErrors &= ~CERT_VALIDITY_NO_ISSUER_CERT_FOUND;
        }
        if((dwErrors & CERT_VALIDITY_NO_TRUST_DATA) &&
           (cCertsInChain == 1)) {
            dwRet |= /*SIGFAILURE_CERT_DISTRUSTED*/ 256;
            dwErrors &= ~CERT_VALIDITY_NO_TRUST_DATA;
        }
        if(dwErrors & CERT_VALIDITY_NO_TRUST_DATA) {
            dwRet |= /*SIGFAILURE_UNKNOWN_ROOT*/ 32;
            dwErrors &= ~CERT_VALIDITY_NO_TRUST_DATA;
        }
        if(dwErrors & CERT_VALIDITY_ISSUER_DISTRUST) {
            dwRet |= /*SIGFAILURE_ISSUER_DISTRUSTED*/ 64;
            dwErrors &= ~CERT_VALIDITY_ISSUER_DISTRUST;
        }
        if(dwErrors) { // catch all other non-specified case
            dwRet |= /*SIGFAILURE_OTHER*/ 1;
        }
    }

    *pdwErrors = dwRet;
    hr = S_OK;
    
ExitHere:
    // 
    //  Clean up any items laying around
    //

    if (NULL != pccertOut) {
        CertFreeCertificateContext(pccertOut);
    }
    
    if (rghstoreCA[0] != NULL) {
        CertCloseStore(rghstoreCA[0], 0);
    }
    
    if(rgdwErrors)
        LocalFree(rgdwErrors);
    
    if(rgCerts != NULL) {
        for(i=0; i < cCertsInChain; ++i) {
            CertFreeCertificateContext(rgCerts[i]);
        }
        LocalFree(rgCerts);
    }
    
    return hr;
}




BOOL GetOpenEmailFileName(HWND hwnd, LPTSTR szInputFile, LPCSTR szTitle) {
    TCHAR szFileName[CCH_OPTION_STRING];
    OPENFILENAME ofn = {0};


    lstrcpy(szFileName, szInputFile);
    if (szInputFile[0] == '<') szInputFile[0] = 0;
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = hInst;
    ofn.lpstrFilter = "Email File\0*.eml\0";
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = CCH_OPTION_STRING;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = "eml";
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if (GetOpenFileName(&ofn)) {
        lstrcpy(szInputFile, szFileName);
        return(TRUE);
    }
    return(FALSE);
}


HRESULT InsertBody(IMimeMessage * pmm, HBODY hbody)
{
    HRESULT     hr;
    
    hr = pmm->ToMultipart(hbody, "y-security", NULL);
    if (FAILED(hr))             return hr;

    return S_OK;
}

int PASCAL 
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine,
        int nCmdShow)
{
    BOOL        f;
    HINSTANCE   hInstDebug = NULL;
    HRESULT     hr;
    HWND        hwnd;
    INITCOMMONCONTROLSEX        initCommCtrl = { 8, ICC_TREEVIEW_CLASSES };
    MSG         msg;
    WNDCLASS    wndclass;

    // OLE Init
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        exit(1);
    }

    InitDemandLoadedLibs();
    InitCommonControlsEx(&initCommCtrl);

    //  Load options from the registry
    GetOptions();

    if (!hPrevInstance) {
        hInst = hInstance;

        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.lpfnWndProc   = WndProc ;
        wndclass.cbClsExtra    = 0 ;
        wndclass.cbWndExtra    = 0 ;
        wndclass.hInstance     = hInstance ;
        wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION) ;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wndclass.hbrBackground = CreateSolidBrush(0x00ffff);
        wndclass.lpszMenuName  = szAppName ;
        wndclass.lpszClassName = szAppName ;

        RegisterClass (&wndclass) ;
    }

    MsgSMTP = RegisterWindowMessage("SMTPTransport_Notify");

    if (! hInstDebug) {
        // Load mshtmdbg.dll
        hInstDebug = LoadLibrary(c_szDebug);

        // Did it load ?
        if (NULL != hInstDebug) {
            // Locals
            PFNREGSPY  pfnRegSpy;

            // If the user passed /d on the command line, lets configure mshtmdbg.dll
            if (0 == lstrcmpi(lpszCmdLine, c_szInvokeUI1) || 
                0 == lstrcmpi(lpszCmdLine, c_szInvokeUI2)) {
                // Locals
                PFNDEBUGUI pfnDebugUI;

                // Get the proc address of the UI
                pfnDebugUI = (PFNDEBUGUI)GetProcAddress(hInstDebug, c_szDebugUI);
                if (NULL != pfnDebugUI) {
                    (*pfnDebugUI)(TRUE);
                }
            }

            // Get the process address of the registration
            pfnRegSpy = (PFNREGSPY)GetProcAddress(hInstDebug, c_szRegSpy);
            if (NULL != pfnRegSpy)
                (*pfnRegSpy)();
        }
    }

    hwnd = CreateWindow (szAppName, "S/Mime Test", WS_OVERLAPPEDWINDOW,
                         CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                         CW_USEDEFAULT, NULL, NULL, hInstance, NULL) ;

    ShowWindow (hwnd, nCmdShow) ;
    UpdateWindow (hwnd) ;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage (&msg) ;
        DispatchMessage (&msg) ;
    }


    f = CertCloseStore(HCertStoreMy, CERT_CLOSE_STORE_CHECK_FLAG);
    if (!f) {
        AssertSz(FALSE, "Global My Cert store did not close completely");
    }

    if (PSmtp)                  PSmtp->Release();
    if (PAcctMan)               PAcctMan->Release();

    if (hInstDebug) {
        FreeLibrary(hInstDebug);
    }

    FreeDemandLoadedLibs();
    CoFreeUnusedLibraries();
    
    return(msg.wParam);
}


BOOL CALLBACK DetailDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_INITDIALOG:
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK MsgDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR       rgchFileName[CCH_OPTION_STRING];

    
    switch (msg) {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_MD_PLAIN_NAME, RootMsg.GetPlainFile());        
        SetDlgItemText(hdlg, IDC_MD_CIPHER_NAME, RootMsg.GetCipherFile());
        SetDlgItemInt(hdlg, IDC_MD_ITERATION, RootMsg.GetIterationCount(), FALSE);
        SendDlgItemMessage(hdlg, IDC_MD_TOFILE, BM_SETCHECK, FALSE, 0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_MD_PLAIN_CHOOSE:
            if (GetOpenEmailFileName(hdlg, RootMsg.GetPlainFile(),
                                     "Select Plain Text File")) {
                SetDlgItemText(hdlg, IDC_MD_PLAIN_NAME, RootMsg.GetPlainFile());
            }
            break;
            
        case IDC_MD_CIPHER_CHOOSE:
            if (GetOpenEmailFileName(hdlg, RootMsg.GetCipherFile(),
                                     "Select Cipher Text File")) {
                SetDlgItemText(hdlg, IDC_MD_CIPHER_NAME, RootMsg.GetCipherFile());
            }
            break;

        case MAKELONG(IDC_MD_PLAIN_NAME, EN_CHANGE):
            GetDlgItemText(hdlg, IDC_MD_PLAIN_NAME, RootMsg.GetPlainFile(),
                           RootMsg.GetFileNameSize());
            break;
            
        case MAKELONG(IDC_MD_CIPHER_NAME, EN_CHANGE):
            GetDlgItemText(hdlg, IDC_MD_CIPHER_NAME, RootMsg.GetCipherFile(),
                           RootMsg.GetFileNameSize());
            break;

        case MAKELONG(IDC_MD_ITERATION, EN_CHANGE):
            RootMsg.GetIterationCount() = GetDlgItemInt(hdlg, IDC_MD_ITERATION,
                                                        NULL, FALSE);
            break;

        case MAKELONG(IDC_MD_TOFILE, BN_CLICKED):
            RootMsg.SetToFile(!SendDlgItemMessage(hdlg, IDC_MD_TOFILE, BM_GETCHECK, 0, 0));
            break;

        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL InsertNode(LPSTR pszLayerName, int iImage, DWORD iDlg, DWORD dwData)
{
    HTREEITEM           hitem;
    CItem *             pitem;
    TV_INSERTSTRUCT     tvins;
    TV_ITEM             tvitm;

    hitem = TreeView_GetSelection(HwndTree);

    tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvins.hParent = TreeView_GetParent(HwndTree, hitem);
    if (tvins.hParent == NULL) {
        tvins.hParent = hitem;
        tvins.hInsertAfter = TVI_FIRST;
        pitem = NULL;
    }
    else {
        tvins.hInsertAfter = hitem;
        tvitm.mask = TVIF_PARAM;
        tvitm.hItem = hitem;
        TreeView_GetItem(HwndTree, &tvitm);
        pitem = (CItem *) tvitm.lParam;
    }
    tvins.item.pszText = pszLayerName;
    tvins.item.cchTextMax = strlen(pszLayerName);
    tvins.item.iImage = iImage;
    tvins.item.iSelectedImage = tvins.item.iImage;

    tvins.item.lParam = dwData;

    hitem = TreeView_InsertItem(HwndTree, &tvins);
    TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);
    TreeView_SelectItem(HwndTree, hitem);
                
    SendMessage(RgDlgs[iDlg].hwnd, UM_SET_DATA, 0, tvins.item.lParam);

    RootMsg.MakeChild((CItem *) tvins.item.lParam, pitem);

    return TRUE;
}

BOOL InsertNode2(int typeParent, LPSTR pszTitle, DWORD iImage, DWORD iDlg,
                 CItem * pItemNew)
{
    HTREEITEM           hitem;
    HTREEITEM           hitemParent;
    CItem *             pitem;
    CItem *             pitemParent;
    TV_ITEM             tvitm;
    TV_INSERTSTRUCT     tvins;

    hitem = TreeView_GetSelection(HwndTree);
    hitemParent = TreeView_GetParent(HwndTree, hitem);
                
    tvitm.mask = TVIF_PARAM;
    tvitm.hItem = hitem;
    TreeView_GetItem(HwndTree, &tvitm);
    pitemParent = (CItem *) tvitm.lParam;
    if (pitemParent->GetType() == typeParent) {
        tvins.hParent = hitemParent;
        tvins.hInsertAfter = hitem;
        pitem = pitemParent;
        pitemParent = ((CSignData *) pitemParent)->GetParent();
    }
    else {
        tvins.hParent = hitem;
        tvins.hInsertAfter = TVI_FIRST;
        pitem = NULL;
    }
                
    tvins.item.lParam = (DWORD) pItemNew;
    pItemNew->SetParent(pitemParent);

    tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvins.hInsertAfter = hitem;
    tvins.item.pszText = pszTitle;
    tvins.item.cchTextMax = strlen(pszTitle);
    tvins.item.iImage = iImage;
    tvins.item.iSelectedImage = tvins.item.iImage;

    hitem = TreeView_InsertItem(HwndTree, &tvins);
    TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);
    TreeView_SelectItem(HwndTree, hitem);
    SendMessage(RgDlgs[iDlg].hwnd, UM_SET_DATA, 0, tvins.item.lParam);

    pitemParent->MakeChild((CItem *) tvins.item.lParam, pitem);
    return 0;
}

long FAR PASCAL WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam)
{
    HTREEITEM           hitem;
    HTREEITEM           hitemRoot;
    HRESULT             hr;
    int                 i;
    CItem *             pitem;
    CItem *             pitemParent;
    LPNMTREEVIEW        ptv;
    char                rgch[300];
    TV_ITEM             tvitm;
    TV_INSERTSTRUCT     tvins;
    
    switch (message) {
    case WM_CREATE:
        //  Create our child windows -- we only have one top level window so use
        //      some globals

        HdlgMsg = CreateDialog(hInst, MAKEINTRESOURCE(IDD_MSG_DATA), hwnd,
                               MsgDataDlgProc);

        HwndTree = CreateWindow(WC_TREEVIEW, "Tree", 
                                WS_CHILD | WS_CLIPCHILDREN | WS_HSCROLL | 
                                WS_VSCROLL | WS_VISIBLE | TVS_HASBUTTONS |
                                TVS_HASLINES , 0, 0, 0, 0,
                                hwnd, NULL, hInst, NULL);


        for (i=0; i<Dlg_Max; i++) {
            RgDlgs[i].hwnd = CreateDialog(hInst, MAKEINTRESOURCE(RgDlgs[i].id),
                                          hwnd, RgDlgs[i].proc);
            AssertSz(RgDlgs[i].hwnd != NULL, "Missed creating a window");
        }

        //  Initialize Tree with an item

        tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
        tvins.hParent = TVI_ROOT;
        tvins.hInsertAfter = TVI_FIRST;
        tvins.item.pszText = "Message";
        tvins.item.cchTextMax = 7;
        tvins.item.iImage = 0;
        tvins.item.iSelectedImage = tvins.item.iImage;
        tvins.item.lParam = (DWORD) &RootMsg;
            
        hitem = TreeView_InsertItem(HwndTree, &tvins);
        TreeView_SelectItem(HwndTree, hitem);

        TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);
        
        //        LoadWAB();

        break;

    case WM_COMMAND :
        switch (wParam) {
        case IDM_EXIT :
            SendMessage (hwnd, WM_CLOSE, 0, 0L) ;
            return 0 ;

        case IDM_E_INSERT_SIGN:
            InsertNode("Signature Layer", 1, Dlg_Sign_Info_Compose,
                       (DWORD) new CSignInfo(STATE_COMPOSE, &RootMsg));
            return 0;

        case IDM_E_INSERT_SIGNATURE:
            pitem = new CSignData(STATE_COMPOSE);
            InsertNode2(TYPE_SIGN_DATA, "Signature", 2, Dlg_Sign_Data_Compose,
                        pitem);
            ((CSignData *) pitem)->SetDefaultCert();
            return 0;

        case IDM_E_INSERT_ENCRYPT:
            InsertNode("Encryption Layer", 3, Dlg_Enc_Info_Compose,
                       (DWORD) new CEnvData(STATE_COMPOSE, &RootMsg));
            return 0;

        case IDM_E_INSERT_TRANSPORT:
            InsertNode2(TYPE_ENV_MAILLIST, "Transport", 3, Dlg_Enc_Data_Trans_Compose, 
                        new CEnvCertTrans(STATE_COMPOSE));
            break;

        case IDM_E_INSERT_AGREEMENT:
            InsertNode2(TYPE_ENV_MAILLIST, "Agree", 3, Dlg_Enc_Data_Agree_Compose, 
                        new CEnvCertAgree(STATE_COMPOSE));
            break;

        case IDM_E_INSERT_MAILLIST:
            InsertNode2(TYPE_ENV_MAILLIST, "Mail List", 3, Dlg_Enc_Data_MailList_Compose, 
                        new CEnvMailList(STATE_COMPOSE));
            break;

        case IDM_ENCODE:
            SendMessage(RgDlgs[Dlg_Sign_Data_Compose].hwnd, UM_SET_DATA, 0, NULL);
            SendMessage(RgDlgs[Dlg_Enc_Info_Compose].hwnd, UM_SET_DATA, 0, NULL);
            SendMessage(RgDlgs[Dlg_Enc_Data_Agree_Compose].hwnd, UM_SET_DATA, 0, NULL);
            SendMessage(RgDlgs[Dlg_Enc_Data_Trans_Compose].hwnd, UM_SET_DATA, 0, NULL);
            SendMessage(RgDlgs[Dlg_Enc_Data_MailList_Compose].hwnd, UM_SET_DATA, 0, NULL);

            for (i=0; i<RootMsg.GetIterationCount(); i++) {
                hr = RootMsg.Encode(hwnd);
                if (FAILED(hr)) {
                    wsprintf(rgch, "Encode failed with 0x%08x on iteration %d",
                             hr, i);
                    MessageBox(hwnd, rgch, szAppName, MB_OK);
                    break;
                }
                CoFreeUnusedLibraries();
            }
            SendMessage(hwnd, UM_RESET, 0, 0);
            RootMsg.ResetMessage();
            return 0;

        case IDM_DECODE:
            for (i=0; i<RootMsg.GetIterationCount(); i++) {
                SendMessage(hwnd, UM_RESET, 0, 0);
                RootMsg.ResetMessage();
                hr = RootMsg.Decode(hwnd);
                if (FAILED(hr)) {
                    wsprintf(rgch, "Decode failed with 0x%08x on iteration %d",
                             hr, i);
                    MessageBox(hwnd, rgch, szAppName, MB_OK);
                    RootMsg.ResetMessage();
                    break;
                }
                CoFreeUnusedLibraries();
            }
            SendMessage(hwnd, UM_FILL, 0, 0);
            return(0);

        case IDM_RESET:
            SendMessage(hwnd, UM_RESET, 0, 0);
            RootMsg.ResetMessage();
            return 0;

        case IDM_VALIDATE:
            for (i=0; i<Dlg_Max; i++) {
                if (IsWindowVisible(RgDlgs[i].hwnd)) {
                    SendMessage(RgDlgs[i].hwnd, message, wParam, lParam);
                    break;
                }
            }
            break;

        case IDM_F_OPTIONS:
            DialogBox(hInst, MAKEINTRESOURCE(idd_Options), hwnd, OptionsDlgProc);
            return(0);

        case IDM_F_MAILLIST:
            DialogBox(hInst, MAKEINTRESOURCE(IDD_FILE_MAILLIST), hwnd, MailListDlgProc);
            return 0;

        case IDM_ABOUT:
            MessageBox (hwnd, "S/Mime Function Test.",
                        szAppName, MB_ICONINFORMATION | MB_OK);
            return(0);
        }
        break ;

    case WM_SIZE:
        {
            int         cx = LOWORD(lParam);
            int         cy = HIWORD(lParam);

            MoveWindow(HdlgMsg, 0, 1, cx, (cy/3)-2, TRUE);
            MoveWindow(HwndTree, 0, (cy/3)+1, (cx/3-1), cy-((cy/3)+1), TRUE);

            for (i=0; i<Dlg_Max; i++) {
                MoveWindow(RgDlgs[i].hwnd, (cx/3)+1, (cy/3+1), cx-(cx/3)+1,
                           cy-((cy/3)+1), TRUE);
            }
        }
        break;

    case WM_SETFOCUS:
        SetFocus(HwndTree);
        return 0;

    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            ptv = (LPNMTREEVIEW) lParam;
            switch (((CItem *) ptv->itemNew.lParam)->GetType() | 
                    ((CItem *) ptv->itemNew.lParam)->GetState()) {
            case TYPE_SIGN_DATA | STATE_COMPOSE:
                ShowWindow(Dlg_Sign_Data_Compose, ptv->itemNew.lParam);
                break;
                
            case TYPE_SIGN_DATA | STATE_READ:
                ShowWindow(Dlg_Sign_Data_Read, ptv->itemNew.lParam);
                break;
                
            case TYPE_ENV_INFO | STATE_COMPOSE:
                ShowWindow(Dlg_Enc_Info_Compose, ptv->itemNew.lParam);
                break;
                
            case TYPE_ENV_INFO | STATE_READ:
                Assert(FALSE);
                break;

            case TYPE_ENV_AGREE | STATE_COMPOSE:
                ShowWindow(Dlg_Enc_Data_Agree_Compose, ptv->itemNew.lParam);
                break;

            case TYPE_ENV_AGREE | STATE_READ:
                Assert(FALSE);
                break;

            case TYPE_ENV_TRANS | STATE_COMPOSE:
                ShowWindow(Dlg_Enc_Data_Trans_Compose, ptv->itemNew.lParam);
                break;

            case TYPE_ENV_TRANS | STATE_READ:
                Assert(FALSE);
                break;

            case TYPE_ENV_MAILLIST | STATE_COMPOSE:
                ShowWindow(Dlg_Enc_Data_MailList_Compose, ptv->itemNew.lParam);
                break;

            case TYPE_ENV_MAILLIST | STATE_READ:
                Assert(FALSE);
                break;

            case TYPE_MSG | STATE_COMPOSE:
            case TYPE_MSG | STATE_READ:
                ShowWindow(Dlg_Message, NULL);
                break;
                
            case TYPE_SIGN_INFO | STATE_COMPOSE:
            case TYPE_SIGN_INFO | STATE_READ:
                ShowWindow(Dlg_Sign_Info_Compose, ptv->itemNew.lParam);
                break;
            }
        }
        return 0;

    case WM_INITMENU:
        tvitm.mask = TVIF_PARAM | TVIF_CHILDREN;
        tvitm.hItem = TreeView_GetSelection(HwndTree);
        TreeView_GetItem(HwndTree, &tvitm);
        i = ((CItem *) tvitm.lParam)->GetType();
        
        EnableMenuItem(GetMenu(hwnd), IDM_E_INSERT_SIGN, MF_BYCOMMAND |
                       (i == TYPE_SIGN_DATA) ? MF_GRAYED : MF_ENABLED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_INSERT_ENCRYPT, MF_BYCOMMAND | 
                       (i == TYPE_SIGN_DATA) ? MF_GRAYED : MF_ENABLED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_INSERT_SIGNATURE, MF_BYCOMMAND |
                       ((i == TYPE_SIGN_DATA) || (i == TYPE_SIGN_INFO)) ?
                       MF_ENABLED : MF_GRAYED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_INSERT_TRANSPORT, MF_BYCOMMAND |
                       ((i == TYPE_ENV_INFO) || (i == TYPE_ENV_AGREE) ||
                        (i == TYPE_ENV_TRANS) || (i == TYPE_ENV_MAILLIST)) ?
                       MF_ENABLED : MF_GRAYED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_DELETE_LAYER, MF_BYCOMMAND |
                       (((i == TYPE_SIGN_INFO) || (i == TYPE_ENV_INFO)) &&
                        (tvitm.cChildren == 0)) ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_DELETE_SIGNATURE, MF_BYCOMMAND | 
                       (i == TYPE_SIGN_DATA) ? MF_ENABLED : MF_GRAYED);
        break;

    case WM_DESTROY:
        //      Reset the message object to have no contents
        SendMessage(hwnd, UM_RESET, 0, 0);
        RootMsg.ResetMessage();
        
        SaveOptions();

        CleanupOptions();

        //        UnloadWAB();

        for (i=0; i<Dlg_Max; i++) {
            DestroyWindow(RgDlgs[i].hwnd);
        }
        DestroyWindow(HwndTree);
        DestroyWindow(HdlgMsg);

        PostQuitMessage(0);

        return(0);

    case UM_RESET:
        hitemRoot = TreeView_GetRoot(HwndTree);
        while (TRUE) {
            TVITEM          tvitem;
                
            tvitem.hItem = TreeView_GetChild(HwndTree, hitemRoot);
            if (tvitem.hItem == NULL) {
                break;
            }
                
            tvitem.mask = TVIF_PARAM | TVIF_CHILDREN;
            TreeView_GetItem(HwndTree, &tvitem);
            if (tvitem.cChildren != 0) {
                for (i=0; i<tvitem.cChildren; i++) {
                    TVITEM      tvitem2;
                    tvitem2.hItem = TreeView_GetChild(HwndTree, tvitem.hItem);
                    tvitem2.mask = TVIF_PARAM | TVIF_CHILDREN;
                    TreeView_GetItem(HwndTree, &tvitem2);
                    delete (CItem *) tvitem2.lParam;
                    TreeView_DeleteItem(HwndTree, tvitem2.hItem);
                }
            }
            delete (CItem *) tvitem.lParam;
            TreeView_DeleteItem(HwndTree, tvitem.hItem);
        }
        
    }
    return(DefWindowProc (hwnd, message, wParam, lParam));
}


int _stdcall WinMainCRTStartup (void)
{
        int i;
        STARTUPINFOA si;
        PTSTR pszCmdLine = GetCommandLine();

        SetErrorMode(SEM_FAILCRITICALERRORS);

        if (*pszCmdLine == TEXT ('\"'))
        {
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                while (*++pszCmdLine && (*pszCmdLine != TEXT ('\"')));

                // If we stopped on a double-quote (usual case), skip over it.
                if (*pszCmdLine == TEXT ('\"')) pszCmdLine++;
        }
        else
        {
                while (*pszCmdLine > TEXT (' ')) pszCmdLine++;
        }

        // Skip past any white space preceeding the second token.
        while (*pszCmdLine && (*pszCmdLine <= TEXT (' '))) pszCmdLine++;

        si.dwFlags = 0;
        GetStartupInfo (&si);

        i = WinMainT(GetModuleHandle (NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

        ExitProcess(i);

        return i;
}

//////////////////////////////////////////////////////////////////////////

void CItem::MakeChild(CItem * pChild, CItem * pAfter)
{
    if (pAfter == NULL) {
        pChild->m_pSibling = m_pChild;
        m_pChild = pChild;
    }
    else if (m_pChild == pAfter) {
        pChild->m_pSibling = pAfter;
        m_pChild = pChild;
    }
    else {
        CItem *     pItem = m_pChild;
        while (pItem != NULL) {
            if (pItem == pAfter) {
                pChild->m_pSibling = pItem->m_pSibling;
                pItem->m_pSibling = pChild;
                break;
            }
            pItem = pItem->m_pSibling;
        }
    }
}

void CItem::RemoveAsChild(CItem * pChild)
{
    if (m_pChild == pChild) {
        m_pChild = pChild->m_pSibling;
        pChild->m_pSibling = NULL;
    }
    else {
        CItem *     pItem = m_pChild;
        while (pItem != NULL) {
            if (pItem->m_pSibling == pChild) {
                pItem->m_pSibling = pChild->m_pSibling;
                pChild->m_pSibling = NULL;
                break;
            }
            pItem = pItem->m_pSibling;
        }
    }
}

HCERTSTORE CMessage::GetAllStore()
{
    HCERTSTORE  hCertStore;
    
    if (m_hCertStoreAll == NULL) {
        m_hCertStoreAll = CertOpenStore(CERT_STORE_PROV_COLLECTION,
                                        X509_ASN_ENCODING, NULL, 0, NULL);
        AssertSz(m_hCertStoreAll != NULL, "Open Collection Store");
        
        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      L"MY");
        AssertSz(hCertStore != NULL, "Open My Cert Store failed");
        CertAddStoreToCollection(m_hCertStoreAll, hCertStore, 0, 0);
        CertCloseStore(hCertStore, 0);

        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      L"AddressBook");
        AssertSz(hCertStore != NULL, "Open Address Book Cert Store failed");
        CertAddStoreToCollection(m_hCertStoreAll, hCertStore, 0, 0);
        CertCloseStore(hCertStore, 0);

        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      L"CA");
        AssertSz(hCertStore != NULL, "Open CA Cert Store failed");
        CertAddStoreToCollection(m_hCertStoreAll, hCertStore, 0, 0);
        CertCloseStore(hCertStore, 0);
    }

    return m_hCertStoreAll;
        
}

HCERTSTORE CMessage::GetMyStore()
{
    if (m_hCertStoreMy == NULL) {
        m_hCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                       NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                       L"MY");
        AssertSz(m_hCertStoreMy != NULL, "Open My Cert Store failed");
    }
    return m_hCertStoreMy;
}

BOOL CMessage::ResetMessage(void)
{
    BOOL        f;
    CItem *     pItem;
    CItem *     pItemNext;

    AssertSz(Head() == NULL, "Failed to release all children");
    AssertSz(Next() == NULL, "Should never have ANY siblings");

    for (pItem = Head(); pItem != NULL; pItem = pItemNext) {
        pItemNext = pItem->Next();
        delete pItem;
    }
    
    if (m_hCertStoreMy != NULL) {
        f = CertCloseStore(m_hCertStoreMy, CERT_CLOSE_STORE_CHECK_FLAG);
        if (!f) {
            AssertSz(FALSE, "My Cert store did not close completely");
        }
        m_hCertStoreMy = NULL;
    }

    return TRUE;
}


HRESULT CMessage::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND hwnd)
{
    *pulLayer = 0;

    return AddToMessage(pulLayer, pmm, hwnd, Head());
}

HRESULT CMessage::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm,
                               HWND hwnd, CItem * pitem)
{
    HRESULT     hr;
    
    if (pitem == NULL) {
        return S_OK;
    }

    hr = pitem->AddToMessage(pulLayer, pmm, hwnd);
    if (FAILED(hr))     return hr;

    return AddToMessage(pulLayer, pmm, hwnd, pitem->Next());
}

HRESULT CMessage::Decode(HWND hwnd)
{
    DWORD                       cLayers;
    HBODY                       hNode;
    HRESULT                     hr;
    DWORD                       iLayer;
    PCCERT_CONTEXT              pccert = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeBody *                 pmbReceipt = NULL;
    IMimeMessage *              pmm = NULL;
    IMimeMessage *              pmmReceipt = NULL;
    IMimeSecurity *             pms = NULL;
    IMimeSecurity2 *            pms2 = NULL;
    IPersistFile *              pfile = NULL;
    IPersistFile *              pfileOut = NULL;
    WCHAR                       rgchW[MAX_PATH];
    DWORD *                     rgdwSecurityType = NULL;
    DWORD *                     rgdwValidity = NULL;
    PCCERT_CONTEXT *            rgpccert = NULL;
    PROPVARIANT *               rgpvAlgHash = NULL;
    ULONG                       ulType;
    PROPVARIANT                 var;
    
    //  Build the message tree and attach the input file
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER,
                          IID_IMimeMessage, (LPVOID *) &pmm);
    if (FAILED(hr))             goto exit;
    hr = pmm->InitNew();
    if (FAILED(hr))             goto exit;

    //  Load the file
    hr = pmm->QueryInterface(IID_IPersistFile, (LPVOID *) &pfile);
    if (FAILED(hr))             goto exit;

    MultiByteToWideChar(CP_ACP, 0, GetCipherFile(), -1,
                        rgchW, sizeof(rgchW)/sizeof(rgchW[0]));
    
    hr = pfile->Load(rgchW, STGM_READ | STGM_SHARE_EXCLUSIVE);
    if (FAILED(hr))             goto exit;

    //
    //  Try using the IMimeSecurity2 interface if it exists and will work

    hr = pmm->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
    if (FAILED(hr)) {
        if (hr == E_NOINTERFACE)        goto TryOldCode;
        goto exit;
    }

    hr = pms2->Decode(hwnd, 0, this);
    if (FAILED(hr)) {
        if (hr != E_FAIL)               goto exit;

    TryOldCode:
        //  Start up the S/MIME engine
        hr = CoCreateInstance(CLSID_IMimeSecurity, NULL, CLSCTX_INPROC_SERVER,
                              IID_IMimeSecurity, (LPVOID *) &pms);
        if (FAILED(hr))             goto exit;
        hr = pms->InitNew();
        if (FAILED(hr))             goto exit;

        //  Bind in the HWND
        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;

        var.vt = VT_UI4;
        var.ulVal = (DWORD) hwnd;
        hr = pmb->SetOption(OID_SECURITY_HWND_OWNER, &var);
        if (FAILED(hr))             goto exit;

        pmb->Release();             pmb = NULL;

        //  Now decode the message
        hr = pms->DecodeMessage(pmm, 0);
        if (FAILED(hr))             goto exit;
    }

    //

    hNode = HBODY_ROOT;


    while (TRUE) {
        hr = pmm->BindToObject(hNode, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;

        //  Create the fun objects from the properties

        hr = pmb->GetOption(OID_SECURITY_TYPE, &var);
        if (FAILED(hr))         goto exit;
        ulType = var.ulVal;

        if (ulType & MST_THIS_SIGN) {
            HTREEITEM           hitem;
            TV_INSERTSTRUCT     tvins;

            CSignInfo *         psi = new CSignInfo(STATE_READ, &RootMsg);
            CSignData *         psd = new CSignData(STATE_READ);
            psd->SetParent(psi);
            tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
            tvins.hParent = TreeView_GetRoot(HwndTree);
            tvins.hInsertAfter = TVI_LAST;
            tvins.item.pszText = "Signature Layer";
            tvins.item.cchTextMax = 15;
            tvins.item.iImage = 1;
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (DWORD) psi;
            
            if (ulType & MST_BLOB_FLAG) {
                psi->m_fBlob = TRUE;
            }

            hitem = TreeView_InsertItem(HwndTree, &tvins);
            TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);

            tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
            tvins.hParent = hitem;
            tvins.hInsertAfter = TVI_LAST;
            tvins.item.pszText = "Signature";
            tvins.item.cchTextMax = 15;
            tvins.item.iImage = 2;
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (DWORD) psd;

            TreeView_InsertItem(HwndTree, &tvins);
            TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);
            
            hr = pmb->GetOption(OID_SECURITY_RO_MSG_VALIDITY, &var);
            if (FAILED(hr))     goto exit;
            psd->m_ulValidity = var.ulVal;
            

            //            hr = pmb->GetOption(OID_SECURITY_HCERTSTORE, &var);
            //            if (FAILED(hr))     goto exit;

            hr = pmb->GetOption(OID_SECURITY_CERT_SIGNING, &var);
            if (FAILED(hr))     goto exit;
            psd->m_pccert = (PCCERT_CONTEXT) var.ulVal;

            //            hr = pmb->GetOption(OID_SECURITY_ALG_HASH, &var);
            //            if (FAILED(hr))     goto exit;
        }

        if (ulType & MST_THIS_ENCRYPT) {
            HTREEITEM           hitem;
            TV_INSERTSTRUCT     tvins;

            CEnvData *          ped = new CEnvData(STATE_READ, &RootMsg);
            tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
            tvins.hParent = TreeView_GetRoot(HwndTree);
            tvins.hInsertAfter = TVI_LAST;
            tvins.item.pszText = "Envelope";
            tvins.item.cchTextMax = 15;
            tvins.item.iImage = 1;
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (DWORD) ped;
            
            hitem = TreeView_InsertItem(HwndTree, &tvins);

            hr = pmb->GetOption(OID_SECURITY_CERT_DECRYPTION, &var);
            if (FAILED(hr))     goto exit;
            Assert(FALSE);
            //            ped->m_pccert = (PCCERT_CONTEXT) var.ulVal;
        }

        if (ulType & MST_RECEIPT_REQUEST) {
            CERT_ALT_NAME_ENTRY     rgNames[1];
            CERT_ALT_NAME_INFO      myNames = {1, rgNames};

            rgNames[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
            rgNames[0].pwszRfc822Name = L"jimsch@microsoft.com";
        
            if (HCertStoreMy == NULL) {
                HCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                             NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                             L"MY");
                if (HCertStoreMy == NULL)   goto exit;
            }
            if (SignHash.cbData != 0) {
                pccert = CertFindCertificateInStore(HCertStoreMy,
                                                    X509_ASN_ENCODING, 0,
                                                    CERT_FIND_SHA1_HASH,
                                                    &SignHash, NULL);
                if (pccert == NULL)         goto exit;
            }
        
            //            hr = MimeOleCreateReceipt(pmm, pccert, hwnd, &pmmReceipt,
            //                                      &myNames);
            if (FAILED(hr))         goto exit;

            //  Get the root body
            hr = pmmReceipt->BindToObject(HBODY_ROOT, IID_IMimeBody,
                                          (LPVOID *) &pmbReceipt);
            if (FAILED(hr))             goto exit;

            //  Set the HWND for CAPI calls
            var.vt = VT_UI4;
            var.ulVal = (ULONG) hwnd;
            hr = pmbReceipt->SetOption(OID_SECURITY_HWND_OWNER, &var);
            if (FAILED(hr))             goto exit;

            var.vt = VT_UI4;
            var.ulVal = MST_THIS_SIGN | MST_THIS_BLOBSIGN;
            hr = pmbReceipt->SetOption(OID_SECURITY_TYPE, &var);
            if (FAILED(hr))             goto exit;

            var.vt = VT_BLOB;
            var.blob.pBlobData = (LPBYTE) RgbSHA1AlgId;
            var.blob.cbSize = CbSHA1AlgId;
            hr = pmbReceipt->SetOption(OID_SECURITY_ALG_HASH, &var);
            if (FAILED(hr))             goto exit;

            var.vt = VT_UI4;
            var.ulVal = (ULONG) pccert;
            hr = pmbReceipt->SetOption(OID_SECURITY_CERT_SIGNING, &var);

            if (hr == S_OK) {
                hr = pmmReceipt->QueryInterface(IID_IPersistFile, (LPVOID *) &pfileOut);
                if (FAILED(hr))         goto exit;

                hr = pfileOut->Save(L"c:\\receipt.eml", FALSE);
                if (FAILED(hr))         goto exit;
            }
            pmbReceipt->Release();
        }

        if (pmb->IsContentType(STR_CNT_MULTIPART, "y-security") != S_OK) {
            break;
        }

        if (hNode == HBODY_ROOT) {
            pmb->GetHandle(&hNode);
        }
        pmb->Release();         pmb = NULL;
        hr = pmm->GetBody(IBL_FIRST, hNode, &hNode);
        if (FAILED(hr))                 goto exit;
    }
            


    hr = S_OK;
exit:
    if (pfileOut != NULL)       pfileOut->Release();
    if (pfile != NULL)          pfile->Release();
    if (pmb != NULL)            pmb->Release();
    if (pms != NULL)            pms->Release();
    if (pmm != NULL)            pmm->Release();
    if (pmmReceipt != NULL)     pmmReceipt->Release();
    if (pccert != NULL)         CertFreeCertificateContext(pccert);

    return hr;
}

HRESULT CMessage::Encode(HWND hwnd)
{
    DWORD                       cLayers;
    HBODY                       hbody;
    HRESULT                     hr;
    HCERTSTORE                  hstore = NULL;
    IImnAccount *               pAccount = NULL;
    PCCERT_CONTEXT              pccertEncrypt = NULL;
    LPSTR                       pchBody;
    IPersistFile *              pfileIn = NULL;
    IPersistFile *              pfileOut = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeMessage *              pmm = NULL;
    IMimeSecurity *             pms = NULL;
    IMimeSecurity2 *            pms2 = NULL;
    LPSTREAM                    pstmBody = NULL;
    LPSTREAM                    pstmFile = NULL;
    WCHAR                       rgchW[CCH_OPTION_STRING];
    DWORD                       ulLayers = 0;
    PROPVARIANT                 var;

    //  Build the message tree and attach the body
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER,
                         IID_IMimeMessage, (LPVOID *) &pmm);
    if (FAILED(hr))     goto exit;

    hr = pmm->InitNew();
    if (FAILED(hr))     goto exit;

    pchBody = GetPlainFile();
    if ((*pchBody == 0) || (_stricmp(pchBody, "<none>") == 0)) {
        //  Create the body stream
        hr = CreateStreamOnHGlobal( NULL, TRUE, &pstmBody);
        if (FAILED(hr))     goto exit;
        hr = pstmBody->Write(RgchBody, lstrlen(RgchBody), NULL);
        if (FAILED(hr))     goto exit;

        //  Attach the body to the message
        hr = pmm->SetTextBody(TXT_PLAIN, IET_8BIT, NULL, pstmBody, &hbody);
        if (FAILED(hr))         goto exit;

        //
    }
    else if (_stricmp(pchBody, "<example>") == 0) {
        //  Create the body stream
        hr = CreateStreamOnHGlobal( NULL, TRUE, &pstmBody);
        if (FAILED(hr))     goto exit;
        hr = pstmBody->Write(RgchExample, lstrlen(RgchExample), NULL);
        if (FAILED(hr))     goto exit;

        //  Get the root body
        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;
        
        hr = pmb->SetData(IET_BINARY, "OID", szOID_RSA_data,
                          IID_IStream, pstmBody);
        if (FAILED(hr))         goto exit;

        pmb->Release();         pmb = NULL;
    }
    else {
        MultiByteToWideChar(CP_ACP, 0, pchBody, -1,
                            rgchW, sizeof(rgchW)/sizeof(rgchW[0]));
        //  Load the file
        hr = pmm->QueryInterface(IID_IPersistFile, (LPVOID *) &pfileIn);
        if (FAILED(hr))             goto exit;
        hr = pfileIn->Load(rgchW, STGM_READ | STGM_SHARE_EXCLUSIVE);
        if (FAILED(hr))             goto exit;
    }

    var.vt = VT_BOOL;
    var.boolVal = TRUE;
    hr = pmm->SetOption(OID_SAVEBODY_KEEPBOUNDARY, &var);
    if (hr) goto exit;

    //  Find out what goes where for initialization
    hr = AddToMessage(&cLayers, pmm, hwnd);
    if (FAILED(hr))     goto exit;

    if (1) {
        hr = pmm->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
        if (FAILED(hr))             goto exit;

        hr = pms2->Encode(hwnd, SEF_SENDERSCERTPROVIDED |
                          SEF_ENCRYPTWITHNOSENDERCERT);
        if (FAILED(hr))             goto exit;

        pms2->Release();            pms2 = NULL;
    }
    else {
        //  Get the root body
        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;

        //  Set the HWND for CAPI calls
        var.vt = VT_UI4;
        var.ulVal = (ULONG) hwnd;
        hr = pmb->SetOption(OID_SECURITY_HWND_OWNER, &var);
        if (FAILED(hr))             goto exit;

        pmb->Release();             pmb = NULL;

        //  Sometimes we must force the encode outside of the Save call

        if (1) {
            hr = CoCreateInstance(CLSID_IMimeSecurity, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IMimeSecurity, (LPVOID *) &pms);
            if (FAILED(hr))         goto exit;
            hr = pms->InitNew();
            if (FAILED(hr))         goto exit;

            hr = pms->EncodeBody(pmm, HBODY_ROOT, EBF_RECURSE | 
                                 SEF_SENDERSCERTPROVIDED |
                                 SEF_ENCRYPTWITHNOSENDERCERT |
                                 EBF_COMMITIFDIRTY);
            if (FAILED(hr))         goto exit;

            pms->Release();         pms = NULL;
        }
    }

    //  Set the subject
    var.vt = VT_LPSTR;
    var.pszVal = "Test subject";
    hr = pmm->SetBodyProp(HBODY_ROOT, STR_HDR_SUBJECT, 0, &var);
    if (FAILED(hr))     goto exit;

    //  Deal with either dump to file or send via SMTP

    if (m_fToFile) {
        //  Dump to a file
        hr = pmm->QueryInterface(IID_IPersistFile, (LPVOID *) &pfileOut);
        if (FAILED(hr))             goto exit;

        MultiByteToWideChar(CP_ACP, 0, GetCipherFile(), -1,
                            rgchW, sizeof(rgchW)/sizeof(rgchW[0]));
        hr = pfileOut->Save(rgchW, FALSE);
        if (FAILED(hr))             goto exit;
    }
    else {
        SMTPMESSAGE             rMessage = {0};
        INETSERVER              rServer;
        char                    szAccount[] = "SMimeTst";
        INETADDR                rgAddress[11];

        if (PAcctMan == NULL) {
            hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IImnAccountManager, (LPVOID *) &PAcctMan);
            if (FAILED(hr))     goto exit;
            hr = PAcctMan->Init(NULL);
            if (FAILED(hr))     goto exit;
        }

        if (PSmtp == NULL) {
            // Create smtp transport
            hr = HrCreateSMTPTransport(&PSmtp);
            if (FAILED(hr))     goto exit;
        }

        memset(&rgAddress, 0, sizeof(rgAddress));

        rMessage.rAddressList.prgAddress = rgAddress;
        rMessage.rAddressList.cAddress = 2;
        
        strcpy(rgAddress[0].szEmail, szSenderEmail);
        rgAddress[0].addrtype = ADDR_FROM;

        strcpy(rgAddress[1].szEmail, szRecipientEmail);
        rgAddress[1].addrtype = ADDR_TO;

        pmm->GetMessageSource(&rMessage.pstmMsg, 0);
        pmm->GetMessageSize(&rMessage.cbSize, 0);

        hr = PAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount);
        if (FAILED(hr))         goto exit;

        hr = PSmtp->InetServerFromAccount(pAccount, &rServer);
        if (FAILED(hr))         goto exit;

        hr = PSmtp->Connect(&rServer, TRUE, TRUE);
        if (FAILED(hr))         goto exit;

        WaitForCompletion(MsgSMTP, SMTP_CONNECTED);
        pAccount->Release();    pAccount = NULL;

        hr = PSmtp->SendMessage(&rMessage);
        WaitForCompletion(MsgSMTP, SMTP_SEND_MESSAGE);

        hr = PSmtp->CommandQUIT();
        if (FAILED(hr))         goto exit;
        WaitForCompletion(MsgSMTP, SMTP_QUIT);
    }
    
    hr = NULL;
exit:
    if (pAccount != NULL)       pAccount->Release();
    if (pfileIn != NULL)        pfileIn->Release();
    if (pfileOut != NULL)       pfileOut->Release();
    if (pstmBody != NULL)       pstmBody->Release();
    if (pstmFile != NULL)       pstmFile->Release();
    if (pms2 != NULL)           pms2->Release();
    if (pms != NULL)            pms->Release();
    if (pmb != NULL)            pmb->Release();
    if (pmm != NULL)            pmm->Release();
    return hr;
}

STDMETHODIMP CMessage::QueryInterface(REFIID riid, LPVOID *ppv)
{
    return E_FAIL;
}

STDMETHODIMP_(ULONG) CMessage::AddRef(void)
{
    return E_FAIL;
}

STDMETHODIMP_(ULONG) CMessage::Release(void)
{
    return E_FAIL;
}

STDMETHODIMP CMessage::FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipIndex,
                                  const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                                  DWORD * pdwCtrl, CMS_CTRL_DECRYPT_INFO * pDecryptInfo,
                                  PCCERT_CONTEXT * ppcert)
{
    //  Only support mail list recipients
    if (pRecipInfo->dwRecipientChoice != CMSG_MAIL_LIST_RECIPIENT) {
        return S_FALSE;
    }

    *pdwCtrl = CMSG_CTRL_MAIL_LIST_DECRYPT;
    return CMailListKey::FindKeyFor(hwnd, dwFlags, dwRecipIndex,
                                    pRecipInfo, pDecryptInfo);
}

STDMETHODIMP CMessage::GetParameters(PCCERT_CONTEXT, LPVOID, DWORD *, LPBYTE *)
{
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDOCOBJ -DDBCS_DIVIDE -DBCC -D_MSOEAPI_ -D_WIN32_OE=0x501 -D_WINDLL
WIN32_IE_VERSION=0x0560
USE_ATL=1
ATL_VER=21

!ifndef WIN16
INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(ATHROOT)\msoeres; \
    $(R)\inc; \
    $(R)\inc\$(O); \
    $(R)\common; \
    $(R)\shell; \
    $(R)\mail; \
    $(R)\news; \
    $(R)\rules; \
    $(R)\store; \
    $(R)\spooler; \
    $(R)\view; \
    $(R)\bactrl; \
    $(R)\bactrl\$(O); \
    $(R)\extinc; \
    $(ATHROOT)\directdb\inc; \
    $(ATHROOT)\directdb\inc\$(O); \
    $(ATHROOT)\inetcomm\mimeole; \
    $(ATHROOT)\common; \
    $(INCLUDES)
!else
INCLUDES=\
    $(R)\inc; \
    $(R)\mime; \
    $(R)\imap; \
    $(R)\proptree; \
    $(R)\common; \
    $(R)\mail; \
    $(R)\news; \
    $(R)\shell; \
    $(R)\store; \
    $(R)\spooler; \
    $(R)\extinc; \
    $(ATHROOT)\inetcomm\mimeole; \
    $(ATHROOT)\common;           \
    $(INCLUDES)
!endif

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin

PRECOMPILED_CXX=1

!ifndef WIN16
PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\inc\$(_OBJ_DIR)\*\pch.pch
!else
PRECOMPILED_OPTION=/fh=$(O)\pch.pch
!endif

PRECOMPILED_TARGET=$(R)\inc\$(_OBJ_DIR)\*\pch.pch

!ifdef WIN16
C_DEFINES=$(C_DEFINES) -D__IUnknown_INTERFACE_DEFINED__ -D__IClassFactory_INTERFACE_DEFINED__
RCOPTIONS=-DBCC
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\resdummy\makefile.inc ===
INETRES_RC_DEPENDS = inetcomm.rcv		    \
		    ..\res\selfreg.inf \
                    ..\inc\resource.h

$O\inetdum.res : $(INETRES_RC_DEPENDS)

..\res\selfreg.inf : ..\res\selfreg.inx
        $(CLEANINF) $** $@

.SUFFIXES: .htx

frntpage.htm : dlg.sed
        -del *.htm
        sed -f dlg.sed $(@:.htm=.htx) >$@

.htx.htm:
        sed -f dlg.sed $** >$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\logwatch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LogWatch.rc
//
#define IDD_LOGWATCH                    101
#define IDC_EDIT                        102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\baprop.cpp ===
// baprop.cpp
// WAB & Messenger integration to OE
// Created 06/23/98 by YST
//
//////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include "badata.h"
#include "baprop.h"
#include "bllist.h"
#include "baui.h"
#include "shlwapip.h"
#include "demand.h"
#include "mailnews.h"
#include "menuutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MAX_SUMMARY_ID  13
#define Msgr_Index      0

extern ULONG MsgrPropTags[];
extern ULONG PR_MSGR_DEF_ID;

static TCHAR szDefault[CCHMAX_STRINGRES];  // TEXT(" (default)");
static TCHAR szPending[CCHMAX_STRINGRES];  // TEXT(" (Pending...)");

const LPTSTR szDomainSeparator = TEXT("@");
const LPTSTR szSMTP = TEXT("SMTP");

#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)
static int nDefault = -1;
static HFONT hBold = NULL;
static HFONT hNormal = NULL;
static CMsgrList *s_pMsgrList = NULL;

static SizedSPropTagArray(1, pTagProp)=
{
    1,
    {
        PR_EMAIL_ADDRESS,
    }
};

///$$/////////////////////////////////////////////////////////////////////////
//
// AddCBEmailItem - Adds an email address to the personal tab list view
//
// lpszAddrType can be NULL in which case a default one of type SMTP will be used
//
//////////////////////////////////////////////////////////////////////////////
void AddCBEmailItem(HWND    hWndCB,
                    LPTSTR  lpszEmailAddress,
                    BOOL    fDefault,
                    LPTSTR lpszPendName)
{
    TCHAR szBuf[CCHMAX_STRINGRES];
    TCHAR szTmp[CCHMAX_STRINGRES];
    LV_ITEM lvi = {0};
    UINT nSim = 0;
    int index = -1;

    StrCpyN(szTmp, lpszEmailAddress, ARRAYSIZE(szTmp));

    // TCHAR *pch = StrStr(CharUpper(szTmp), szHotMail);
    // if(pch != NULL)
    nSim = lstrlen(szTmp); //(UINT) (pch - szTmp + 1);

    Assert(nSim < CCHMAX_STRINGRES);

    if(nSim > 0)
    {
        if(nSim > (CCHMAX_STRINGRES - strlen(szDefault) - 2))
        {
            nSim = CCHMAX_STRINGRES - strlen(szDefault) - 2;
            StrCpyN(szBuf, lpszEmailAddress, nSim);
            szBuf[nSim] = '\0';
        }
        else
            StrCpyN(szBuf, lpszEmailAddress, ARRAYSIZE(szBuf));

        if(fDefault)
        {

            if(s_pMsgrList)
            {
                if(s_pMsgrList->FindAndDeleteUser(lpszEmailAddress, FALSE /*fDelete*/) == S_OK)
                    StrCatBuff(szBuf, szDefault, ARRAYSIZE(szBuf));
                else if(!lstrcmpi(lpszPendName, lpszEmailAddress))
                    StrCatBuff(szBuf, szPending, ARRAYSIZE(szBuf));
            }

        }

        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvi.iImage = IMAGE_EMPTY;
        lvi.pszText = szBuf;
        lvi.cchTextMax = 256; //nSim;
        lvi.iItem = ListView_GetItemCount(hWndCB);
        lvi.iSubItem = 0;
        lvi.lParam = fDefault;

        index = ListView_InsertItem(hWndCB, &lvi);
        if(fDefault)
            nDefault = index;
    }
    return;
}

const static HELPMAP g_rgCtxWabExt[] =
{
    {IDC_MSGR_ID_EDIT,              IDH_WAB_ONLINE_ADDNEW},
    {IDC_MSGR_ADD,                  IDH_WAB_ONLINE_ADD},
    {IDC_MSGR_BUTTON_SETDEFAULT,    IDH_WAB_ONLINE_SETAS},
    {IDC_SEND_INSTANT_MESSAGE,      IDH_WAB_ONLINE_SENDIM},
    {IDC_USER_NAME,                 IDH_WAB_ONLINE_LIST},
    {idcStatic1,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                    IDH_NEWS_COMM_GROUPBOX},
    {0,                             0}
};

INT_PTR CALLBACK WabExtDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD dwError = 0;
    HIMAGELIST himl = NULL;

    switch (msg)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE * pps = (PROPSHEETPAGE *) lParam;
            LPWABEXTDISPLAY * lppWED = (LPWABEXTDISPLAY *) pps->lParam;
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
                // Add two columns to the listview
            LVCOLUMN lvc;
            RECT rc;
            HWND ctlList = GetDlgItem(hDlg, IDC_USER_NAME);

            s_pMsgrList = OE_OpenMsgrList();

            // one column
            lvc.mask = LVCF_FMT | LVCF_WIDTH;
            lvc.fmt = LVCFMT_LEFT;
            lvc.iSubItem = 0;

            GetWindowRect(ctlList,&rc);
            lvc.cx = rc.right - rc.left - 20; //TBD

            ListView_InsertColumn(ctlList, 0, &lvc);

            if(lppWED)
            {
                SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM)*lppWED);
                lpWED = *lppWED;
            }
            InitFonts();
            AthLoadString(idsBADefault, szDefault, ARRAYSIZE(szDefault));
            AthLoadString(idsBADispStatus, szPending, ARRAYSIZE(szPending));
            // ListView_SetExtendedListViewStyle(ctlList, LVS_EX_FULLROWSELECT);

            himl = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbAddrBookHot), 18, 0,
                               RGB(255, 0, 255), IMAGE_BITMAP,
                               LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);

            ListView_SetImageList(ctlList, himl, LVSIL_SMALL);

            AddAccountsToList(hDlg, lpWED);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),FALSE);
        }
        break;

    case WM_CONTEXTMENU:
    case WM_HELP:
        return OnContextHelp(hDlg, msg, wParam, lParam, g_rgCtxWabExt);
        break;

    case WM_COMMAND:
        {
            switch(HIWORD(wParam))		// Notification code
            {
            case EN_CHANGE:
                {
                    if(LOWORD(wParam) == IDC_MSGR_ID_EDIT)
                    {
                        if(GetWindowTextLength(GetDlgItem(hDlg, IDC_MSGR_ID_EDIT)) > 0)
                        {
                            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),TRUE);
                            SendMessage(GetParent(hDlg), DM_SETDEFID, IDC_MSGR_ADD, 0);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),FALSE);
                            SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
                        }
                    }
                    break;
                }
            }

            switch(LOWORD(wParam))		// commands
            {
            case IDC_MSGR_BUTTON_SETDEFAULT:
                SetAsDefault(hDlg, lpWED);
                break;

            case IDC_MSGR_ADD:
                AddMsgrId(hDlg, lpWED);
                break;

            case IDC_SEND_INSTANT_MESSAGE:
                WabSendIMsg(hDlg, lpWED);
                break;

            default:
                break;
            }
        }
        break;

    case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {

            case PSN_APPLY:
                ::SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, TRUE);
                DeleteFonts();
                if(s_pMsgrList)
                    OE_CloseMsgrList(s_pMsgrList);

                break;

            case PSN_SETACTIVE:
                ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_USER_NAME));
                AddAccountsToList(hDlg, lpWED);
                break;

            case PSN_KILLACTIVE:
                AddMsgrId(hDlg, lpWED);
                SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
                return 1;
                break;

            case PSN_RESET:
                SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
                DeleteFonts();
                if(s_pMsgrList)
                    OE_CloseMsgrList(s_pMsgrList);
                break;

            case LVN_ITEMCHANGED:
                {
                int nItem = ListView_GetNextItem(::GetDlgItem(hDlg, IDC_USER_NAME), -1, LVIS_SELECTED);
                if((nItem != nDefault) && (nItem > -1))
                    EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),TRUE);
                else
                    EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);

                if(WabIsItemOnline(hDlg, nItem))
                    EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
                else
                    EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);

                }
                break;


            case NM_CUSTOMDRAW:
                switch(wParam)
                {
                case IDC_USER_NAME:
                    {
                        NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                        NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                        if(pnmcd->dwDrawStage==CDDS_PREPAINT)
                        {
                            SetLastError(0);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
                            dwError = GetLastError();
                            return TRUE;
                        }
                        else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
                        {
                            if(pnmcd->lItemlParam)
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, hBold);
                                SetLastError(0);
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                dwError = GetLastError();
                                return TRUE;
                            }
                            else
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, hNormal);
                                SetLastError(0);
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                dwError = GetLastError();
                                return TRUE;
                            }
                        }
                        SetLastError(0);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                        dwError = GetLastError();
                        return TRUE;
                    }
                    break;
                default:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                    break;
                }
                break;
            }
        }
        break;
    }
    return FALSE;	
}

void AddAccountsToList(HWND hDlg, LPWABEXTDISPLAY lpWED, LPTSTR lpszPendName)
{

    // LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLongPtr(hDlg, DWLP_USER);
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG i = 0;
    LPSPropValue lpPropEmail = NULL;
    LPSPropValue lpPropAddrType = NULL;
    LPSPropValue lpPropMVEmail = NULL;
    LPSPropValue lpPropMVAddrType = NULL;
    LPSPropValue lpPropDefaultIndex = NULL;
    LPSPropValue lpMsgrDevId = NULL;
    HWND ctlList = GetDlgItem(hDlg, IDC_USER_NAME);

    Assert(ctlList);

    Assert(PR_MSGR_DEF_ID);
    nDefault = -1;

    if(!lpWED)
    {
        Assert(FALSE);
        return;
    }

    if(!HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0,
        &ulcPropCount,
        &lpPropArray)))
    {
        if(ulcPropCount && lpPropArray)
        {
            for(i = 0; i < ulcPropCount; i++)
            {
                switch(lpPropArray[i].ulPropTag)
                {
                case PR_EMAIL_ADDRESS:
                    lpPropEmail = &(lpPropArray[i]);
                    break;
                case PR_ADDRTYPE:
                    lpPropAddrType = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_EMAIL_ADDRESSES:
                    lpPropMVEmail = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_ADDRTYPES:
                    lpPropMVAddrType = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                    lpPropDefaultIndex = &(lpPropArray[i]);
                    break;
                default:
                    if(lpPropArray[i].ulPropTag == PR_MSGR_DEF_ID)
                        lpMsgrDevId = &(lpPropArray[i]);
                    break;
                }
            }
            if(!lpPropEmail && !lpPropMVEmail)
                goto Error;

            if(lpPropMVEmail)
            {
                // we have a multiple emails
                //Assume, if this is present, so is MVAddrType, and defaultindex
                for(i = 0; i < lpPropMVEmail->Value.MVSZ.cValues; i++)
                {
                    AddCBEmailItem(ctlList,
                                    lpPropMVEmail->Value.MVSZ.LPPSZ[i],
                                    (lpMsgrDevId ?
                                    ((!lstrcmpi(lpPropMVEmail->Value.MVSZ.LPPSZ[i], lpMsgrDevId->Value.LPSZ)) ? TRUE : FALSE) : FALSE), lpszPendName);
                }
            }
            else
            {
                // we dont have multi-valued props yet - lets use the
                // single valued ones and tag a change so that the record is
                // updated ...
                AddCBEmailItem(ctlList,
                                    lpPropEmail->Value.LPSZ,
                                    (lpMsgrDevId ?
                                    ((!lstrcmpi(lpPropEmail->Value.LPSZ, lpMsgrDevId->Value.LPSZ)) ? TRUE : FALSE) : FALSE), lpszPendName);
            }
        }
    }

Error:
    if(nDefault == -1)
    {
        if(ListView_GetItemCount(ctlList) > 0)            // We have as min 1 item
        {
            // Select default item
            ListView_SetItemState(ctlList, 0,
                        LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),TRUE);
            // Enable "SendInstant Message only when contact is Online
            if(WabIsItemOnline(hDlg, 0))
                EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
            else
                EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);
        }
    }
    else
    {
        // Select default item
        ListView_SetItemState(ctlList, nDefault,
                        LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);
            // Enable "SendInstant Message only when contact is Online
        if(WabIsItemOnline(hDlg, nDefault))
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
        else
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
    }

    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);

    return;

}

// Set selected email address as default for Messenger
void SetAsDefault(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    TCHAR szName[CCHMAX_STRINGRES];
    Assert(ctlList);

    int iItem = ListView_GetNextItem(ctlList, -1, LVIS_SELECTED);
    if(iItem == -1)
        return;

    ListView_GetItemText(ctlList, iItem, 0,szName, CCHMAX_STRINGRES - 1);

    if(StrStr(szName, szDefault)) // already default
        return;

    SetDefaultID(szName, hDlg, lpWED);
}

// Add Messanger ID  to list
#define NOT_FOUND ((ULONG) -1)

void AddMsgrId(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    HWND hwndEdit = ::GetDlgItem(hDlg, IDC_MSGR_ID_EDIT);
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0;
    ULONG i = 0;

    ULONG nMVEmailAddress = NOT_FOUND, nMVAddrTypes = NOT_FOUND, nEmailAddress = NOT_FOUND;
    ULONG nAddrType = NOT_FOUND, nDefaultIndex = NOT_FOUND;
    TCHAR szName[CCHMAX_STRINGRES];
    HRESULT hr = S_OK;

    if(!::GetWindowText(hwndEdit, szName, CCHMAX_STRINGRES - 1))
        return;

    TCHAR *pch = NULL;
    if(!AsciiTrimSpaces(szName))
    {
        AthMessageBoxW(hDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsBAErrExtChars),
               NULL, MB_OK | MB_ICONSTOP);
        ::SetWindowText(hwndEdit, "");
        ::SetFocus(hwndEdit);
        return;
    }

    int nLen = lstrlen(szName);
    if(nLen <= 0)
        goto exi;

    nLen = lstrlen(szSMTP);
    if(nLen <= 0)
        goto exi;

    // Create a return prop array to pass back to the WAB
    if(HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0,
        &ulcPropCount,
        &lpPropArray)))
        return;

    if(ulcPropCount && lpPropArray)
    {
        for(i = 0; i < ulcPropCount; i++)
        {
            switch(lpPropArray[i].ulPropTag)
            {
            case PR_EMAIL_ADDRESS:
                nEmailAddress = i;
                break;
            case PR_ADDRTYPE:
                nAddrType = i;
                break;
            case PR_CONTACT_EMAIL_ADDRESSES:
                nMVEmailAddress = i;
                break;
            case PR_CONTACT_ADDRTYPES:
                nMVAddrTypes = i;
                break;
            case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                nDefaultIndex = i;
                break;
            }
        }

        // if no e-mail address, just add the given prop as e-mail address and in mv e-mail addresses
        if(nEmailAddress == NOT_FOUND)
        {
            SPropValue spv[5];

            spv[0].ulPropTag = PR_EMAIL_ADDRESS;
            spv[0].Value.LPSZ = szName;

            spv[1].ulPropTag = PR_ADDRTYPE;
            spv[1].Value.LPSZ = szSMTP;

            spv[2].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
            spv[2].Value.MVSZ.cValues = 1;
            spv[2].Value.MVSZ.LPPSZ = (char **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));

            if(spv[2].Value.MVSZ.LPPSZ)
                spv[2].Value.MVSZ.LPPSZ[0] = szName;

            spv[3].ulPropTag = PR_CONTACT_ADDRTYPES;
            spv[3].Value.MVSZ.cValues = 1;
            spv[3].Value.MVSZ.LPPSZ = (char **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));

            if(spv[3].Value.MVSZ.LPPSZ)
                spv[3].Value.MVSZ.LPPSZ[0] = szSMTP;

            spv[4].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            spv[4].Value.l = 0;

            hr = lpWED->lpPropObj->SetProps(5, (LPSPropValue)&spv, NULL);

            if(spv[2].Value.MVSZ.LPPSZ)
                LocalFree(spv[2].Value.MVSZ.LPPSZ);
            if(spv[3].Value.MVSZ.LPPSZ)
                LocalFree(spv[3].Value.MVSZ.LPPSZ);

        }
        else if(nMVEmailAddress == NOT_FOUND)
        {
            // we have an e-mail address but no contact-email-addresses
            // so we will need to create the contact e-mail addresses
            SPropValue spv[3];

            spv[0].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
            spv[0].Value.MVSZ.cValues = 2;
            spv[0].Value.MVSZ.LPPSZ = (char **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);

            if(spv[0].Value.MVSZ.LPPSZ)
            {
                spv[0].Value.MVSZ.LPPSZ[0] = lpPropArray[nEmailAddress].Value.LPSZ;
                spv[0].Value.MVSZ.LPPSZ[1] = szName;
            }

            spv[1].ulPropTag = PR_CONTACT_ADDRTYPES;
            spv[1].Value.MVSZ.cValues = 2;
            spv[1].Value.MVSZ.LPPSZ = (char **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);

            if(spv[1].Value.MVSZ.LPPSZ)
            {
                spv[1].Value.MVSZ.LPPSZ[0] = (nAddrType == NOT_FOUND) ? (LPTSTR)szSMTP : lpPropArray[nAddrType].Value.LPSZ;
                spv[1].Value.MVSZ.LPPSZ[1] = szSMTP;
            }

            spv[2].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            spv[2].Value.l = 0;

            hr = lpWED->lpPropObj->SetProps(3, (LPSPropValue)&spv, NULL);

            if(spv[0].Value.MVSZ.LPPSZ)
                LocalFree(spv[0].Value.MVSZ.LPPSZ);

            if(spv[1].Value.MVSZ.LPPSZ)
                LocalFree(spv[1].Value.MVSZ.LPPSZ);
        }
        else
        {
            // tag on the new props to the end of the existing contact_address_types
            if(HR_FAILED(hr = AddPropToMVPString(lpWED, lpPropArray,ulcPropCount, nMVEmailAddress, szName)))
                goto exi;

            if(HR_FAILED(hr = AddPropToMVPString(lpWED, lpPropArray, ulcPropCount, nMVAddrTypes, szSMTP)))
                goto exi;

            hr = lpWED->lpPropObj->SetProps(ulcPropCount, lpPropArray, NULL);
        }

        // Set this new data on the object
        //
        if(SUCCEEDED(hr))
        {
            lpWED->fDataChanged = TRUE;
            if(nDefault == -1)
                SetDefaultID(szName, hDlg, lpWED);
            else
            {
                // just refresh list, which will add buddy.6
                ListView_DeleteAllItems(::GetDlgItem(hDlg, IDC_USER_NAME));
                AddAccountsToList(hDlg, lpWED);
            }
            ::SetWindowText(hwndEdit, "");
        }
    }
exi:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
}

    //Set default ID in WAB
void SetDefaultID(TCHAR *szName, HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc = 0;

    if(s_pMsgrList)
    {
        s_pMsgrList->AddUser(szName); // Always ignore result
    }
    else
        return;

    // Create a return prop array to pass back to the WAB
    int nLen = lstrlen(szName);

    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(SPropValue),
        (LPVOID *)&lpPropArray);
    if (sc!=S_OK)
        goto out;

    if(nLen)
    {
        lpPropArray[Msgr_Index].ulPropTag = MsgrPropTags[Msgr_Index];
        sc = lpWED->lpWABObject->AllocateMore(nLen+1, lpPropArray,
            (LPVOID *)&(lpPropArray[Msgr_Index].Value.LPSZ));

        if (sc!=S_OK)
            goto out;

        StrCpyN(lpPropArray[Msgr_Index].Value.LPSZ, szName, nLen+1);
    }
    // Set this new data on the object
    //
    if(HR_FAILED(lpWED->lpPropObj->SetProps( 1, lpPropArray, NULL)))
        goto out;

    lpWED->fDataChanged = TRUE;
    ListView_DeleteAllItems(::GetDlgItem(hDlg, IDC_USER_NAME));
    AddAccountsToList(hDlg, lpWED, szName);

out:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
}


//$$//////////////////////////////////////////////////////////////////////////////
//
//  TrimSpaces - strips a string of leading and trailing blanks
//
//  szBuf - pointer to buffer containing the string we want to strip spaces off.
//  Also, check that characters are ASCII
//
////////////////////////////////////////////////////////////////////////////////
BOOL AsciiTrimSpaces(TCHAR * szBuf)
{
    register LPTSTR lpTemp = szBuf;
    DWORD cchBuf = lstrlen(szBuf)+1;

    if(!szBuf || !lstrlen(szBuf))
        return FALSE;

    // Trim leading spaces
    while (IsSpace(lpTemp)) {
        lpTemp = CharNext(lpTemp);
    }

    if (lpTemp != szBuf) {
        // Leading spaces to trim
        StrCpyN(szBuf, lpTemp, cchBuf);
        lpTemp = szBuf;
    }

    if (*lpTemp == '\0') {
        // empty string
        return(TRUE);
    }

    // Move to the end
    lpTemp += lstrlen(lpTemp);
    lpTemp--;

    // Walk backwards, triming spaces
    while (IsSpace(lpTemp) && lpTemp > szBuf) {
        *lpTemp = '\0';
        lpTemp = CharPrev(szBuf, lpTemp);
    }

   lpTemp = szBuf;

    while (*lpTemp)
    {
        // Internet addresses only allow pure ASCII.  No high bits!
        if (*lpTemp & 0x80)
           return(FALSE);
        lpTemp++;
    }

    return(TRUE);
}

/***************************************************************************

    Name      : AddPropToMVPString

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpszNew -> new data string

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array LPSZ to the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPString(
  LPWABEXTDISPLAY lpWED,
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPTSTR lpszNew) {

#ifdef UNICODE
    SWStringArray UNALIGNED * lprgszOld = NULL; // old SString array
#else
    SLPSTRArray UNALIGNED * lprgszOld = NULL;   // old SString array
#endif
    LPTSTR  *lppszNew = NULL;           // new prop array
    LPTSTR  *lppszOld = NULL;           // old prop array
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;
    ULONG cbNew;

    if (lpszNew) {
        cbNew = lstrlen(lpszNew) + 1;
    } else {
        cbNew = 0;
    }

    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_TSTRING, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgszOld = &(lpaProps[index].Value.MVSZ);
        lppszOld = lprgszOld->LPPSZ;

        cExisting = lprgszOld->cValues;
        cbMVP = cExisting * sizeof(LPTSTR);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(LPTSTR);    // room in the MVP for another string pointer


    // Allocate room for new MVP array
    if (sc = lpWED->lpWABObject->AllocateMore(cbMVP, lpaProps, (LPVOID *)&lppszNew)) {
        DebugTrace("AddPropToMVPString allocation (%u) failed %x\n", cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lppszNew[i] = lppszOld[i];
    }

    // Add the new property value
    // Allocate room for it
    if (cbNew) {
        if (sc = lpWED->lpWABObject->AllocateMore(cbNew, lpaProps, (LPVOID *)&(lppszNew[i]))) {
            DebugTrace("AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc);
            hResult = ResultFromScode(sc);
            return(hResult);
        }
        StrCpyN(lppszNew[i], lpszNew, cbNew);

        lpaProps[index].Value.MVSZ.LPPSZ= lppszNew;
        lpaProps[index].Value.MVSZ.cValues = cExisting + 1;

    } else {
        lppszNew[i] = NULL;
    }

    return(hResult);
}

// this function check if selected item is online
BOOL WabIsItemOnline(HWND hDlg, int nItem)
{
    TCHAR szName[CCHMAX_STRINGRES];
    TCHAR *pch = NULL;

    if(nItem < 0)
        return(FALSE);

    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    ListView_GetItemText(ctlList, nItem, 0,szName, CCHMAX_STRINGRES - 1);

    // Remove "(default)"
    pch = StrStr(szName, szDefault);
    if(pch != NULL)
        szName[pch - szName] = '\0';

    if(s_pMsgrList)
    {
        return(s_pMsgrList->IsContactOnline(szName, s_pMsgrList->GetFirstMsgrItem()));
    }
    return(FALSE);
}

// Send instant message to selected item
void WabSendIMsg(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    TCHAR szName[CCHMAX_STRINGRES];
    TCHAR *pch = NULL;

    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    int iItem = ListView_GetNextItem(ctlList, -1, LVIS_SELECTED);
    if(iItem == -1)
        return;

    ListView_GetItemText(ctlList, iItem, 0,szName, CCHMAX_STRINGRES - 1);

    // Remove "(default)"

    pch = StrStr(szName, szDefault);
    if(pch != NULL)
        szName[pch - szName] = '\0';

    if(s_pMsgrList)
    {
        s_pMsgrList->SendInstMessage(szName);
    }
}

BOOL InitFonts(void)
{
    LOGFONT lf;

    // Create the font
    if(SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
    {
        if(!hNormal)
            hNormal = CreateFontIndirect(&lf);
        lf.lfWeight = (lf.lfWeight < 700) ? 700 : 1000;
        if(!hBold)
            hBold = CreateFontIndirect(&lf);

    }
    return(TRUE);
}

void DeleteFonts(void)
{
    if(hNormal)
    {
        DeleteObject(hNormal);
        hNormal = NULL;
    }
    if(hBold)
    {
        DeleteObject(hBold);
        hBold = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\badata.h ===
// badata.h: interface for the CAddressBookData class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __BADATA_H_
#define __BADATA_H_

// Pull in the WAB header files
#include <wab.h>

class CMsgrAb;

typedef struct tagITEMINFO {
    LONG        lObjectType;
    LPENTRYID   pEntryID;
    ULONG       cbEntryID;
} ITEMINFO, *PITEMINFO;

typedef enum
{
    LPARAM_MENTRY = 1,
    LPARAM_ABENTRY,
    LPARAM_MABENTRY,
    LPARAM_ABGRPENTRY,
    MAX_LPARAM
} MABENUM;

// MAB types masks

#define  MAB_CONTACT    0x001
#define  MAB_GROUP      0x002
#define  MAB_BUDDY      0x004     
#define  MAB_CERT       0x008


class ATL_NO_VTABLE CAddressBookData
{
public:
	/////////////////////////////////////////////////////////////////////////
	// Constructor & Destructor
	//
	CAddressBookData();
	virtual ~CAddressBookData();

	/////////////////////////////////////////////////////////////////////////
	// WAB Functions
	//
	HRESULT OpenWabFile(void);
	HRESULT LoadWabContents(CContainedWindow& ctlList, CMsgrAb *pSink);
    HRESULT DoLDAPSearch(LPTSTR pszText, CContainedWindow& ctlList);
    HRESULT NewContact(HWND hwndParent);
    HRESULT AddRecipient(LPMIMEADDRESSTABLEW pAddrTable, LPSBinary pInfo, BOOL fGroup);
    HRESULT FreeListViewItem(LPSBinary pSB);
    HRESULT ShowDetails(HWND hwndParent, LPSBinary pSB);
    HRESULT AddAddress(LPWSTR pwszDisplay, LPSTR pszAddress);
    HRESULT GetDisplayName(LPSBinary pSB, LPTSTR pszDisplayName, int nMax);
    HRESULT DeleteItems(ENTRYLIST *pList);
    HRESULT Unadvise(void)
    {
        if (m_ulConnection)
           m_pAdrBook->Unadvise(m_ulConnection);
        return (S_OK);
    }
    HRESULT Find(HWND hwndParent);
    HRESULT AddressBook(HWND hwndParent);
    HRESULT NewGroup(HWND hwndParent);
    HRESULT AutoAddContact(TCHAR * pchName, TCHAR * pchID);
    HRESULT InitNamedProps(void);
    HRESULT SetDefaultMsgrID(LPSBinary pSB, LPTSTR pchID);
    BOOL CheckEmailAddr(LPSBinary pSB, LPTSTR szEmail);

    /////////////////////////////////////////////////////////////////////////
    // MAPI Utility Functions
    //
protected:
    void    _FreeProws(LPSRowSet prows);
    HRESULT	_MergeRowSets(LPSRowSet prows, LPSRowSet FAR *pprowsDst);
    HRESULT _QueryAllRows(LPMAPITABLE ptable, LPSPropTagArray ptaga, 
                          LPSRestriction pres, LPSSortOrderSet psos,
	                      LONG crowsMax, LPSRowSet FAR *pprows);
    HRESULT _FillListFromTable(CContainedWindow& ctlList, LPSRowSet pSRowSet,
                               BOOL bLDAP = FALSE);
    HRESULT _GetWABTemplateID(ULONG ulObjectType, ULONG *lpcbEID, LPENTRYID *lppEID);

    /////////////////////////////////////////////////////////////////////////
    // LDAP Routines
    //

    typedef struct _SortInfo
    {
        BOOL bSortAscending;
        BOOL bSortByLastName;
    } SORT_INFO, *LPSORT_INFO;

    HRESULT _GetLDAPContainer(ULONG *pcbEntryID, LPENTRYID *ppEntryID);
    HRESULT _GetLDAPSearchRestriction(LPTSTR pszText, LPSRestriction lpSRes);
    HRESULT _GetLDAPContentsList(ULONG cbContainerEID, LPENTRYID pContainerEID, 
                                 SORT_INFO rSortInfo, LPSRestriction pPropRes, 
                                 CContainedWindow& ctlList);

// Private member data
private:

	// WAB Stuff
	LPWABOBJECT m_pWABObject;
    HINSTANCE	m_hInstWAB;
    LPADRBOOK	m_pAdrBook; 
    ULONG       m_ulConnection;

    CMsgrAb * m_pAB;
};

void AddAccountsToList(HWND hDlg, int id, LPARAM lParam);

#endif  // __BADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\badata.cpp ===
// badata.cpp: implementation of the CAddressBook class.
// WAB & Messenger integration to OE
// Created 04/20/98 by YST
//
//////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include <shfusion.h>
#include "bactrl.h"
#include "badata.h"
#include "baui.h"
#include "baprop.h"
#include "ourguid.h"
#include "mapiguid.h"
#include "shlwapip.h" 
#include "ipab.h"
#include "multiusr.h"
#include "demand.h"
#include "secutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// Defines for the various MAPI Tables we request from the WAB
//////////////////////////////////////////////////////////////////////

#define MAX_QUERY_SIZE 1000

// Here are some private properties that the WAB stores.  If WAB ever
// changes any of these we're in trouble.

#define WAB_INTERNAL_BASE       0x6600
#define PR_WAB_LDAP_SERVER      PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 1)
#define PR_WAB_RESOLVE_FLAG     PROP_TAG(PT_BOOLEAN,    WAB_INTERNAL_BASE + 2)


// This BA's private GUID:
// {2BAD7EE0-36AB-11d1-9BAC-00A0C91F9C8B}
static const GUID WAB_ExtBAGuid = 
{ 0x2bad7ee0, 0x36ab, 0x11d1, { 0x9b, 0xac, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b } };

static const LPTSTR lpMsgrPropNames[] = 
{   
    "MsgrID"
};

enum _MsgrTags
{
    MsgrID = 0,
    msgrMax
};

ULONG MsgrPropTags[msgrMax];
ULONG PR_MSGR_DEF_ID = 0;


// These two define the table we request from the WAB when showing the
// contents of the local address book.

enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
    ieidPR_OBJECT_TYPE,
    ieidPR_MSGR_DEF_ID,
//    ieidPR_BUSINESS_TELEPHONE_NUMBER,
    ieidPR_EMAIL_ADDRESS, 
    ieidPR_USER_X509_CERTIFICATE,
    ieidPR_RECORD_KEY,
    ieidMax
};

static SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
        PR_MSGR_DEF_ID,
//        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_EMAIL_ADDRESS, 
        PR_USER_X509_CERTIFICATE,
        PR_RECORD_KEY
    }
};


// These two define the table we request to see which LDAP servers should
// be resolved against.
enum {
    irnPR_OBJECT_TYPE = 0,
    irnPR_WAB_RESOLVE_FLAG,
    irnPR_ENTRYID,
    irnPR_DISPLAY_NAME,
    irnMax
};

static const SizedSPropTagArray(irnMax, irnColumns) =
{
    irnMax,
    {
        PR_OBJECT_TYPE,
        PR_WAB_RESOLVE_FLAG,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
    }
};


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrPR_DEF_CREATE_DL,
    icrMax
};

const SizedSPropTagArray(icrMax, ptaCreate)=
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAddressBookData::CAddressBookData()
{
    m_pWABObject = NULL;
    m_hInstWAB = NULL;
    m_pAdrBook = NULL;
    m_ulConnection = 0;
}


CAddressBookData::~CAddressBookData()
{
    // Release the Address Book pointer
    if (m_pAdrBook)
        m_pAdrBook->Release();

    // Release the WAB object
    if (m_pWABObject)
        m_pWABObject->Release();

    if (m_hInstWAB)
        FreeLibrary(m_hInstWAB);
}



//
//  FUNCTION:   CAddressBookData::OpenWabFile()
//
//  PURPOSE:    Finds the WAB DLL, loads the DLL, and opens the WAB.
//
HRESULT CAddressBookData::OpenWabFile(void)
{
    TCHAR       szDll[MAX_PATH];
    TCHAR       szExpanded[MAX_PATH];
    DWORD       dwType = 0;
    LPTSTR      psz = szDll;
    ULONG       cbData = sizeof(szDll);
    HKEY        hKey = NULL;
    HRESULT     hr = E_FAIL;
    LPWABOPEN   lpfnWABOpen;

    // Initialize the path string
    *szDll = '\0';

    // First look under the default WAB DLL path location in the Registry.
    // WAB_DLL_PATH_KEY is defined in wabapi.h
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, _T(""), NULL, &dwType, (LPBYTE) szDll, &cbData))
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szDll, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }

        RegCloseKey(hKey);
    }

    // If the registry thing came up blank, then do a LoadLibrary on wab32.dll
    m_hInstWAB = LoadLibrary((lstrlen(psz)) ? (LPCTSTR) psz : (LPCTSTR) WAB_DLL_NAME);

    if (m_hInstWAB)
    {
        // If we've got the DLL, then get the entry point
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hInstWAB, "WABOpen");

        if (lpfnWABOpen)
        {
            WAB_PARAM       wp = {0};
            wp.cbSize = sizeof(WAB_PARAM);
            wp.guidPSExt = CLSID_OEBAControl;
            wp.ulFlags = (g_dwAthenaMode & MODE_NEWSONLY) ? WAB_ENABLE_PROFILES : WAB_ENABLE_PROFILES | WAB_USE_OE_SENDMAIL;
            hr = lpfnWABOpen(&m_pAdrBook, &m_pWABObject, &wp, 0);
        }
    }

    return (hr);
}



//
//  FUNCTION:   CAddressBookData::LoadWabContents()
//
//  PURPOSE:    Loads the contents of the WAB into the provided ListView control.
//
//  PARAMETERS: 
//      [in] ctlList - Pointer to the ListView control to load the WAB into.
//
HRESULT CAddressBookData::LoadWabContents(CContainedWindow& ctlList, CMsgrAb *pSink)
{
    ULONG       ulObjType = 0;
    LPMAPITABLE lpAB =  NULL;
    LPTSTR     *lppszArray = NULL;
    ULONG       cRows = 0;
    LPSRowSet   lpRow = NULL;
    LPSRowSet   lpRowAB = NULL;
    LPABCONT    lpContainer = NULL;
    int         cNumRows = 0;
    int         nRows = 0;
    HRESULT     hr = E_FAIL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;
    LPSRowSet   pSRowSet = NULL;

    Assert(m_pAdrBook);
    if (!m_pAdrBook)
        return E_UNEXPECTED;

    // Get the entryid of the root PAB container
    hr = m_pAdrBook->GetPAB(&lpcbEID, &lpEID);

    if(!PR_MSGR_DEF_ID)
        InitNamedProps();

    // Open the root PAB container.  This is where all the WAB contents reside.
    ulObjType = 0;
    hr = m_pAdrBook->OpenEntry(lpcbEID,
                               (LPENTRYID)lpEID,
                               NULL,
                               0,
                               &ulObjType,
                               (LPUNKNOWN *) &lpContainer);

    if(HR_FAILED(hr))
        goto exit;

    if(pSink)
        m_pAB = pSink;

    if (pSink && !m_ulConnection)
        m_pAdrBook->Advise(lpcbEID, lpEID, fnevObjectModified, (IMAPIAdviseSink *) pSink, &m_ulConnection);

    // Get a contents table of all the contents in the WABs root container.
    hr = lpContainer->GetContentsTable(WAB_PROFILE_CONTENTS /*0*/, &lpAB);
    if(HR_FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the ones we want
    // - which are mainly DisplayName, EntryID and ObjectType.  The table is 
    // guaranteed to set the columns in the order requested.
    Assert(PR_MSGR_DEF_ID);
    ptaEid.aulPropTag[ieidPR_MSGR_DEF_ID] = PR_MSGR_DEF_ID;
    hr = lpAB->SetColumns((LPSPropTagArray) &ptaEid, 0);
    if(HR_FAILED(hr))
        goto exit;

    // Reset to the beginning of the table
    hr = lpAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
    if(HR_FAILED(hr))
        goto exit;

    // If we got this far, we have a populated table.  We can query the rows
    // now.
    hr = _QueryAllRows(lpAB, NULL, NULL, NULL, MAX_QUERY_SIZE, &pSRowSet);
    if (FAILED(hr) || !pSRowSet)
        goto exit;
    
    // Fill the provided ListView with this table
    _FillListFromTable(ctlList, pSRowSet);

exit:
    if (lpEID)
        m_pWABObject->FreeBuffer(lpEID);

    if (pSRowSet)
        _FreeProws(pSRowSet);

    if (lpContainer)
        lpContainer->Release();

    if (lpAB)
        lpAB->Release();

    return hr;
}


HRESULT CAddressBookData::DoLDAPSearch(LPTSTR pszText, CContainedWindow& ctlList)
{
    // Build a restriction based on the given text
    SRestriction SRes;
    if (SUCCEEDED(_GetLDAPSearchRestriction(pszText, &SRes)))
    {
        // Figure out what the entry ID is for the LDAP container
        ULONG     cbEntryID = 0;
        LPENTRYID pEntryID = 0;

        if (SUCCEEDED(_GetLDAPContainer(&cbEntryID, &pEntryID)))
        {
            // Perform the search
            SORT_INFO si = {0, 0};
            _GetLDAPContentsList(cbEntryID, pEntryID, si, &SRes, ctlList);

            if (pEntryID)
                m_pWABObject->FreeBuffer(pEntryID);

        }

        if (SRes.res.resAnd.lpRes)
            m_pWABObject->FreeBuffer(SRes.res.resAnd.lpRes);
    }

    return (S_OK);
}
    
    
void CAddressBookData::_FreeProws(LPSRowSet prows)
{
    if (prows)
    {
        for (ULONG irow = 0; irow < prows->cRows; ++irow)
            m_pWABObject->FreeBuffer(prows->aRow[irow].lpProps);

        m_pWABObject->FreeBuffer(prows);
    }
}


//
//  FUNCTION:   CAddressBookData::_MergeRowSets()
//
//  PURPOSE:    Merges prows with *pprowsDst, reallocating *pprowsDst if 
//              necessary.  Destroys the container portion of prows (but not 
//              the individual rows it contains).
//
//  PARAMETERS: 
//      [in]       prows     - source set of rows
//      [in, out] *pprowsDst - set of rows to merge the prows into 
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CAddressBookData::_MergeRowSets(LPSRowSet prows, LPSRowSet FAR *pprowsDst)
{
    SCODE       sc = S_OK;
    LPSRowSet   prowsT;
    UINT        crowsSrc;
    UINT        crowsDst;

    _ASSERTE(!IsBadWritePtr(pprowsDst, sizeof(LPSRowSet)));
    _ASSERTE(prows);

    // If the table is completely empty we want to return this.
    if (!*pprowsDst || (*pprowsDst)->cRows == 0)
    {
        m_pWABObject->FreeBuffer(*pprowsDst);
        *pprowsDst = prows;
        prows = NULL;                           // Don't free it!
        goto exit;
    }

    if (prows->cRows == 0)
    {
        goto exit;
    }

    // OK, now we know there are rows in both rowsets, we have to do a real 
    // merge.
    crowsSrc = (UINT) prows->cRows;
    crowsDst = (UINT) (*pprowsDst)->cRows;      //  handle 0

    if (FAILED(sc = m_pWABObject->AllocateBuffer(CbNewSRowSet(crowsSrc + crowsDst), (LPVOID*) &prowsT)))
        goto exit;
    if (crowsDst)
        CopyMemory(prowsT->aRow, (*pprowsDst)->aRow, crowsDst * sizeof(SRow));
    CopyMemory(&prowsT->aRow[crowsDst], prows->aRow, crowsSrc * sizeof(SRow));
    prowsT->cRows = crowsSrc + crowsDst;

    m_pWABObject->FreeBuffer(*pprowsDst);
    *pprowsDst = prowsT;

exit:
    // if (prows)
    //     m_pWABObject->FreeBuffer(&prows);

    return ResultFromScode(sc);
}


/*
 -	HrQueryAllRows
 -	
 *	Purpose:
 *		Retrieves all rows from an IMAPITable interface up to a set
 *		maximum. It will optionally set the column set, sort order,
 *		and restriction on the table before querying.
 *	
 *		If the table is empty, an SRowSet with zero rows is
 *		returned (just like QueryRows).
 *	
 *		The seek position of the table is undefined both before and
 *		after this call.
 *	
 *		If the function fails with an error other than
 *		MAPI_E_NOT_ENOUGH_MEMORY, extended error information is
 *		available through the table interface.
 *	
 *	Arguments:
 *		ptable		in		the table interface to query
 *		ptaga		in		if not NULL, column set for the table
 *		pres		in		if not NULL, restriction to be applied
 *		psos		in		if not NULL, sort order to be applied
 *		crowsMax	in		if nonzero, limits the number of rows
 *							to be returned.
 *		pprows		out		all rows of the table
 *	
 *	Returns:
 *		HRESULT. Extended error information normally is in the
 *		table.
 *	
 *	Side effects:
 *		Seek position of table is undefined.
 *	
 *	Errors:
 *		MAPI_E_TABLE_TOO_BIG if the table contains more than
 *		cRowsMax rows.
 */
HRESULT CAddressBookData::_QueryAllRows(LPMAPITABLE ptable,
	                                LPSPropTagArray ptaga, 
                                    LPSRestriction pres, 
                                    LPSSortOrderSet psos,
	                                LONG crowsMax, 
                                    LPSRowSet FAR *pprows)
{
	HRESULT		hr;
	LPSRowSet	prows = NULL;
	UINT		crows = 0;
	LPSRowSet	prowsT=NULL;
	UINT		crowsT;

	*pprows = NULL;

	// Set up the table, if the corresponding setup parameter is present.
	if (ptaga && FAILED(hr = ptable->SetColumns(ptaga, TBL_BATCH)))
		goto exit;
	if (pres && FAILED(hr = ptable->Restrict(pres, TBL_BATCH)))
		goto exit;
	if (psos && FAILED(hr = ptable->SortTable(psos, TBL_BATCH)))
		goto exit;

	// Set position to beginning of the table.
	if (FAILED(hr = ptable->SeekRow(BOOKMARK_BEGINNING, 0, NULL)))
		goto exit;

	if (crowsMax == 0)
		crowsMax = 0xffffffff;

	for (;;)
	{
		prowsT = NULL;

		// Retrieve some rows. Ask for the limit.
		hr = ptable->QueryRows(crowsMax, 0, &prowsT);
		if (FAILED(hr))
		{
			// Note: the failure may actually have happened during one of the 
            // setup calls, since we set TBL_BATCH.
			goto exit;
		}
		_ASSERTE(prowsT->cRows <= 0xFFFFFFFF);
		crowsT = (UINT) prowsT->cRows;

		// Did we get more rows than caller can handle?
		if ((LONG) (crowsT + (prows ? prows->cRows : 0)) > crowsMax)
		{
			hr = ResultFromScode(MAPI_E_TABLE_TOO_BIG);
			//_FreeProws(prowsT);
			goto exit;
		}

		// Add the rows just retrieved into the set we're building.		
        //
        // NOTE: this handles boundary conditions including either row set is 
        // empty.
        // 
		// NOTE: the merge destroys prowsT.
		if (FAILED(hr = _MergeRowSets(prowsT, &prows)))
			goto exit;

		// Did we hit the end of the table? Unfortunately, we have to ask twice 
        // before we know.
		if (crowsT == 0)
			break;
	}

    if(prows->cRows != 0)
	    *pprows = prows;

exit:
    if (prowsT)
        _FreeProws(prowsT);

	if (FAILED(hr))
		_FreeProws(prows);

	return hr;
}


HRESULT CAddressBookData::_GetLDAPContainer(ULONG *pcbEntryID, LPENTRYID *ppEntryID)
{
    ULONG           ulObjectType = 0;
    IABContainer   *pRoot = 0;
    LPMAPITABLE     pRootTable = 0;
    HRESULT         hr = S_OK;

    // Get the root Address Book container
    hr = m_pAdrBook->OpenEntry(0, NULL, NULL, 0, &ulObjectType, (LPUNKNOWN *) &pRoot);
    if (FAILED(hr))
        goto exit;

    // From the address book container, get a table of it's contents
    hr = pRoot->GetContentsTable(0, &pRootTable);
    if (FAILED(hr))
        goto exit;

    // Set the columns
    pRootTable->SetColumns((LPSPropTagArray) &irnColumns, 0);

    // Build a restriction to only display LDAP servers that we're supposed
    // to resolve against.
    SRestriction resAnd[2];         // 0 = LDAP, 1 = ResolveFlag
    SRestriction resLDAPResolve;
    SPropValue   ResolveFlag;

    // Restrict: Only show LDAP containers with Resolve TRUE
    resAnd[0].rt = RES_EXIST;
    resAnd[0].res.resExist.ulReserved1 = 0;
    resAnd[0].res.resExist.ulReserved2 = 0;
    resAnd[0].res.resExist.ulPropTag = PR_WAB_LDAP_SERVER;

    ResolveFlag.ulPropTag = PR_WAB_RESOLVE_FLAG;
    ResolveFlag.Value.b = TRUE;

    resAnd[1].rt = RES_PROPERTY;
    resAnd[1].res.resProperty.relop = RELOP_EQ;
    resAnd[1].res.resProperty.ulPropTag = PR_WAB_RESOLVE_FLAG;
    resAnd[1].res.resProperty.lpProp = &ResolveFlag;

    resLDAPResolve.rt = RES_AND;
    resLDAPResolve.res.resAnd.cRes = 2;
    resLDAPResolve.res.resAnd.lpRes = resAnd;

    // Apply the restruction
    hr = pRootTable->Restrict(&resLDAPResolve, 0);
    if (HR_FAILED(hr))
        goto exit;

    // We're going to just blindly grab the first item in this table as the
    // LDAP container we're going to use.
    LPSRowSet pRowSet;
    hr = pRootTable->QueryRows(1, 0, &pRowSet);
    if (FAILED(hr))
        goto exit;

    // Grab the size of the entry id
    *pcbEntryID = pRowSet->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.cb;

    // Make a copy of the entry id
    hr = m_pWABObject->AllocateBuffer(*pcbEntryID, (LPVOID *) ppEntryID);
    if (FAILED(hr))
        goto exit;

    CopyMemory(*ppEntryID, pRowSet->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.lpb, 
               *pcbEntryID);

exit:
    if (pRootTable)
        pRootTable->Release();

    if (pRoot)
        pRoot->Release();

    if (pRowSet)
        _FreeProws(pRowSet);

    return (hr);
}


HRESULT CAddressBookData::_GetLDAPSearchRestriction(LPTSTR pszText, LPSRestriction lpSRes)
{
    SRestriction    SRes = { 0 };
    LPSRestriction  lpPropRes = NULL;
    ULONG           ulcPropCount = 0;
    HRESULT         hr = E_FAIL;
    ULONG           i = 0;
    SCODE           sc = ERROR_SUCCESS;
    LPSPropValue    lpPropArray = NULL;


    if (!lstrlen(pszText))
    {
        ATLTRACE(_T("No Search Props"));
        goto exit;
    }

    lpSRes->rt = RES_AND;
    lpSRes->res.resAnd.cRes = 1;

    // Allocate a buffer for the restriction
    lpSRes->res.resAnd.lpRes = NULL;
    sc = m_pWABObject->AllocateBuffer(1 * sizeof(SRestriction), 
                                      (LPVOID *) &(lpSRes->res.resAnd.lpRes));
    if (S_OK != sc || !(lpSRes->res.resAnd.lpRes))
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropRes = lpSRes->res.resAnd.lpRes;

    // Create the first part of the OR clause
    lpPropRes[0].rt = RES_PROPERTY;
    lpPropRes[0].res.resProperty.relop = RELOP_EQ;
    lpPropRes[0].res.resProperty.ulPropTag = PR_EMAIL_ADDRESS;

    lpPropRes[0].res.resProperty.lpProp = NULL;
    m_pWABObject->AllocateMore(sizeof(SPropValue), lpPropRes, (LPVOID*) &(lpPropRes[0].res.resProperty.lpProp));
    lpPropArray = lpPropRes[0].res.resProperty.lpProp;
    if (!lpPropArray)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropArray->ulPropTag = PR_EMAIL_ADDRESS;
    lpPropArray->Value.LPSZ = NULL;

    m_pWABObject->AllocateMore(lstrlen(pszText) + 1, lpPropRes, (LPVOID *) &(lpPropArray->Value.LPSZ));
    if (!lpPropArray->Value.LPSZ)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    StrCpyN(lpPropArray->Value.LPSZ, pszText, lstrlen(pszText) + 1);

#if 0
    // Add the second OR clause
    lpPropRes[1].rt = RES_PROPERTY;
    lpPropRes[1].res.resProperty.relop = RELOP_EQ;
    lpPropRes[1].res.resProperty.ulPropTag = PR_DISPLAY_NAME;

    lpPropRes[1].res.resProperty.lpProp = NULL;
    m_pWABObject->AllocateMore(sizeof(SPropValue), lpPropRes, (LPVOID*) &(lpPropRes[1].res.resProperty.lpProp));
    lpPropArray = lpPropRes[1].res.resProperty.lpProp;
    if (!lpPropArray)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropArray->ulPropTag = PR_DISPLAY_NAME;
    lpPropArray->Value.LPSZ = NULL;

    m_pWABObject->AllocateMore(lstrlen(pszText) + 1, lpPropRes, (LPVOID *) &(lpPropArray->Value.LPSZ));
    if (!lpPropArray->Value.LPSZ)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    StrCpyN(lpPropArray->Value.LPSZ, pszText, lstrlen(pszText) + 1);
#endif

    hr = S_OK;

exit:
    return hr;
}


HRESULT CAddressBookData::_GetLDAPContentsList(ULONG cbContainerEID,
                                           LPENTRYID pContainerEID,
                                           SORT_INFO rSortInfo,
                                           LPSRestriction pPropRes,
                                           CContainedWindow& ctlList)
{
    HRESULT          hr = S_OK;
    HRESULT          hrTemp;
    ULONG            ulObjectType = 0;
    LPMAPICONTAINER  pContainer = NULL;
    LPMAPITABLE      pContentsTable = NULL;
    LPSRowSet        pSRowSet = NULL;

    // Open the container object corresponding to pContainerEID
    hr = m_pAdrBook->OpenEntry(cbContainerEID, pContainerEID, NULL, 0, 
                               &ulObjectType, (LPUNKNOWN *) &pContainer);
    if (FAILED(hr))
        goto exit;

    // Get the contents table from this container
    hr = pContainer->GetContentsTable(0, &pContentsTable);
    if (FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the ones we want
    // - which are mainly DisplayName, EntryID and ObjectType.  The table is 
    // guaranteed to set the columns in the order requested.
    Assert(PR_MSGR_DEF_ID);
    ptaEid.aulPropTag[ieidPR_MSGR_DEF_ID] = PR_MSGR_DEF_ID;
    hr = pContentsTable->SetColumns((LPSPropTagArray) &ptaEid, 0);
    if(HR_FAILED(hr))
        goto exit;

    // Do the find
    hr = pContentsTable->FindRow(pPropRes, BOOKMARK_BEGINNING, 0);
    if (FAILED(hr))
        goto exit;

    // If this was a partial completion error, we want to continue but also
    // return this information to the caller
    if (MAPI_W_PARTIAL_COMPLETION == hr)
        hrTemp = hr;

    // If we got this far, we have a populated table.  We can query the rows
    // now.
    hr = _QueryAllRows(pContentsTable, NULL, NULL, NULL, MAX_QUERY_SIZE, &pSRowSet);
    if (FAILED(hr) || !pSRowSet)
        goto exit;

    // Fill in the ListView from the table
    _FillListFromTable(ctlList, pSRowSet, TRUE);

exit:
    if (pSRowSet)
        _FreeProws(pSRowSet);

    if (pContentsTable)
        pContentsTable->Release();

    if (pContainer)
        pContainer->Release();

    return (hr);
}


HRESULT CAddressBookData::_FillListFromTable(CContainedWindow& ctlList, LPSRowSet pSRowSet, BOOL bLDAP)
{
    LPSBinary lpSB;

    // Make sure the caller passed us a rowset
    Assert(pSRowSet);
    Assert(PR_MSGR_DEF_ID);

    // Loop through the rows in the rowset
    for (ULONG i = 0; i < pSRowSet->cRows; i++)
    {
        // Get the information out of the table that we need.  Right now we're 
        // grabbing the entry ID, the display name, and the business phone number.
        LPENTRYID lpEID = (LPENTRYID) pSRowSet->aRow[i].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
        ULONG     cbEID = pSRowSet->aRow[i].lpProps[ieidPR_ENTRYID].Value.bin.cb;
        DWORD     nFlag = (pSRowSet->aRow[i].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_DISTLIST) ? MAB_GROUP : MAB_CONTACT;
        LPTSTR    lpszID = NULL;
        LPTSTR    lpszName = NULL;
        
        if(nFlag == MAB_CONTACT)
        {
            if(pSRowSet->aRow[i].lpProps[ieidPR_USER_X509_CERTIFICATE].ulPropTag == PR_USER_X509_CERTIFICATE)
                nFlag |= MAB_CERT;
        }

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_MSGR_DEF_ID/*ieidPR_EMAIL_ADDRESS*/].ulPropTag) == PT_TSTRING )
        {
            nFlag = nFlag | MAB_BUDDY;
            lpszID = pSRowSet->aRow[i].lpProps[ieidPR_MSGR_DEF_ID/*ieidPR_EMAIL_ADDRESS*/].Value.lpszA;
        }
        else if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_EMAIL_ADDRESS].ulPropTag) == PT_TSTRING )
            lpszID = pSRowSet->aRow[i].lpProps[ieidPR_EMAIL_ADDRESS].Value.lpszA;
        else
            lpszID = NULL;

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_DISPLAY_NAME].ulPropTag) == PT_TSTRING )
            lpszName = pSRowSet->aRow[i].lpProps[ieidPR_DISPLAY_NAME].Value.lpszA;
        else
            lpszName = lpszID;
        
        // LPTSTR    lpszPhone = pSRowSet->aRow[i].lpProps[ieidPR_BUSINESS_TELEPHONE_NUMBER].Value.lpszA;

        // Allocate an ITEMINFO struct to store this information
        lpSB = NULL;
        m_pWABObject->AllocateBuffer(sizeof(SBinary), (LPVOID *) &lpSB);
        if (lpSB)
        {
            // Save the information we'll need later
            m_pWABObject->AllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb));
            if (!lpSB->lpb)
            {
                m_pWABObject->FreeBuffer(lpSB);
                continue;
            }

            CopyMemory(lpSB->lpb, lpEID, cbEID);
            lpSB->cb = cbEID;

            // Create an item to add to the list
            m_pAB->CheckAndAddAbEntry(lpSB, lpszID, lpszName, nFlag);

        }
    }

    // Let's make sure the first item is selected
//    ListView_SetItemState(ctlList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
   
    return (S_OK);
}

HRESULT CAddressBookData::NewContact(HWND hwndParent)
{    
    HRESULT     hr;
    ULONG       cbNewEntry;
    LPENTRYID   pNewEntry;
    ULONG           cbContainerID;
    LPENTRYID       pContainerID = 0;

    if(!m_pAdrBook)
        return E_FAIL;

    hr = m_pAdrBook->GetPAB(&cbContainerID, &pContainerID);
    if (FAILED(hr))
        return(hr);

    hr = m_pAdrBook->NewEntry((ULONG_PTR) hwndParent, /*CREATE_CHECK_DUP_STRICT*/ 0, cbContainerID, pContainerID, 0, NULL,
                              &cbNewEntry, &pNewEntry);

    return (hr);
}

// Add new (Msgr) contact to address book
HRESULT CAddressBookData::AutoAddContact(TCHAR * pchName, TCHAR * pchID)
{
    LPMAILUSER      lpMailUser = NULL;
    ULONG           ulcPropCount = 1;
    ULONG           ulIndex = 0;
    LPSPropValue    lpPropArray = NULL;
    SCODE           sc;
    LPWSTR          pwszName = NULL,
                    pwszID = NULL;
    HRESULT         hr = S_OK;

    if(!m_pAdrBook || !m_pWABObject)
        return(S_FALSE);

    // 1. Add entry to Address book
    pwszName = PszToUnicode(CP_ACP, pchName);
    if (!pwszName && (pchName && *pchName))
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

    pwszID = PszToUnicode(CP_ACP, pchID);
    if (!pwszID && (pchID && *pchID))
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

    hr = HrWABCreateEntry(m_pAdrBook,
                            m_pWABObject,
                            pwszName,
                            pwszID,
                            CREATE_CHECK_DUP_STRICT,
                            &lpMailUser, KEEP_OPEN_READWRITE);
    if(SUCCEEDED(hr))
    {
        // 2. Set custom property: default address for buddy
        
        // Create a return prop array to pass back to the WAB
        sc = m_pWABObject->AllocateBuffer(sizeof(SPropValue), 
                                            (LPVOID *)&lpPropArray);
        if (sc!=S_OK)
            goto out;

        int nLen = lstrlen(pchID);
        if(nLen)
        {
            lpPropArray[0].ulPropTag = MsgrPropTags[0];
            sc = m_pWABObject->AllocateMore(nLen+1, lpPropArray, 
                                    (LPVOID *)&(lpPropArray[0].Value.LPSZ));

            if (sc!=S_OK)
                goto out;
            StrCpyN(lpPropArray[0].Value.LPSZ, pchID, nLen+1);
        }
        // Set this new data on the object
        //
        if(lpMailUser)
        {
            hr = lpMailUser->SetProps(1, lpPropArray, NULL);
            if(SUCCEEDED(hr))
                hr = lpMailUser->SaveChanges(FORCE_SAVE);
        }
    }

out:
    MemFree(pwszName);
    MemFree(pwszID);
    if(lpPropArray)
        m_pWABObject->FreeBuffer(lpPropArray);

    if(lpMailUser)
        ReleaseObj(lpMailUser);

    return(hr);
}

// Unicode string property version of template array
SizedSPropTagArray(6, ptaAddr_W) =
{
    6,
    {
        PR_ADDRTYPE_W,
        PR_DISPLAY_NAME_W,
        PR_EMAIL_ADDRESS_W,
        PR_ENTRYID,
        PR_CONTACT_EMAIL_ADDRESSES_W,  //4
        PR_SEARCH_KEY
    }
};

// ANSI string property version of template array
SizedSPropTagArray(6, ptaAddr_A) =
{
    6,
    {
        PR_ADDRTYPE_A,
        PR_DISPLAY_NAME_A,
        PR_EMAIL_ADDRESS_A,
        PR_ENTRYID,
        PR_CONTACT_EMAIL_ADDRESSES_A,
        PR_SEARCH_KEY
    }
};

HRESULT CAddressBookData::AddRecipient(LPMIMEADDRESSTABLEW pAddrTable, LPSBinary pSB, BOOL fGroup)
{
    HRESULT     hr;
    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;
    ULONG       ulObjType = 0;
    LPMAPITABLE lpAB =  NULL;
    LPABCONT    lpContainer = NULL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;

    // Retrieve the item from the wab
    hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

    // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_W, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    // Set those badboys on the address table
    if(pPropArray[2].ulPropTag == PR_EMAIL_ADDRESS_W)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[2].Value.lpszW, NULL , NULL);
    else if(pPropArray[4].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES_W)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[4].Value.MVszW.lppszW[0], NULL , NULL);
    else if((pPropArray[1].ulPropTag == PR_DISPLAY_NAME_W) && fGroup)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[1].Value.lpszW, NULL , NULL);

    // Bug 34077 - they don't want to have a display name...
    /* else if(pPropArray[1].ulPropTag == PR_DISPLAY_NAME)
        pAddrTable->Append(IAT_TO, IET_DECODED, pPropArray[1].Value.lpszA, NULL , NULL);
    else
        Assert(FALSE); */
exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (hr);
}

HRESULT CAddressBookData::SetDefaultMsgrID(LPSBinary pSB, LPTSTR pchID)
{
    ULONG       ulType = 0;
    IMailUser  *lpMailUser = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &lpMailUser);
    if (FAILED(hr))
        goto exit;

    if(SUCCEEDED(hr))
    {
        // 2. Set custom property: default address for buddy
        
        // Create a return prop array to pass back to the WAB
        sc = m_pWABObject->AllocateBuffer(sizeof(SPropValue), 
                                            (LPVOID *)&lpPropArray);
        if (sc!=S_OK)
            goto exit;

        int nLen = lstrlen(pchID);
        if(nLen)
        {
            lpPropArray[0].ulPropTag = MsgrPropTags[0];
            sc = m_pWABObject->AllocateMore(nLen+1, lpPropArray, 
                                    (LPVOID *)&(lpPropArray[0].Value.LPSZ));

            if (sc!=S_OK)
                goto exit;

            StrCpyN(lpPropArray[0].Value.LPSZ, pchID, nLen+1);
        }
        // Set this new data on the object
        //
        if(lpMailUser)
        {
            hr = lpMailUser->SetProps(1, lpPropArray, NULL);
            if(SUCCEEDED(hr))
                hr = lpMailUser->SaveChanges(FORCE_SAVE);
        }
    }

exit:
    if(lpPropArray)
        m_pWABObject->FreeBuffer(lpPropArray);

    SafeRelease(lpMailUser);
    return (hr);
}

HRESULT CAddressBookData::GetDisplayName(LPSBinary pSB, LPTSTR szDisplayName, int nMax)
{

    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

        // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_A, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    StrCpyN(szDisplayName, pPropArray[1].Value.lpszA, nMax);
    szDisplayName[nMax - 1] = _T('\0');

exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (hr);

}

BOOL CAddressBookData::CheckEmailAddr(LPSBinary pSB, LPTSTR szEmail)
{
    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;
    LPSPropValue lpPropMVEmail = NULL;
    UINT i = 0;
    BOOL fRet = FALSE;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

        // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_A, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    // 4 element is PR_CONTACT_EMAIL_ADDRESSES in ptaAddr
    lpPropMVEmail = &(pPropArray[4]);
    if(lpPropMVEmail && (lpPropMVEmail->ulPropTag == PR_CONTACT_EMAIL_ADDRESSES))
    {
        // we have a multiple emails
        //Assume, if this is present, so is MVAddrType, and defaultindex
        for(i = 0; i < lpPropMVEmail->Value.MVszA.cValues; i++)
        {

            if(!lstrcmpi(lpPropMVEmail->Value.MVszA.lppszA[i], szEmail))
                fRet = TRUE;
        }
    }
exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (fRet);
}



HRESULT CAddressBookData::FreeListViewItem(LPSBinary pSB)
{
    if (pSB)
        m_pWABObject->FreeBuffer(pSB);
    return (S_OK);
}

HRESULT CAddressBookData::ShowDetails(HWND hwndParent, LPSBinary pSB)
{
    HRESULT hr;
    ULONG_PTR   ulUIParam = (ULONG_PTR) hwndParent;

    hr = m_pAdrBook->Details(&ulUIParam, NULL, NULL, pSB->cb, (LPENTRYID) pSB->lpb, 
                             NULL, NULL, NULL, 0);

    return (hr);
}

HRESULT CAddressBookData::AddAddress(LPWSTR pwszDisplay, LPSTR pszAddress)
{
    HRESULT         hr;
    LPABCONT        pABContainer = NULL;
    ULONG           cbContainerID,
        ul;
    LPENTRYID       pContainerID = 0;
    LPMAPIPROP      lpProps = 0;
    SPropValue      rgpv[3];
    SPropTagArray   ptaEID = { 1, { PR_ENTRYID } };
    LPSPropValue    ppvDefMailUser=0;
    SizedSPropTagArray(1, ptaDefMailUser) =
    { 1, { PR_DEF_CREATE_MAILUSER } };
    
    DWORD           cUsedValues;
    
    // Get the entry ID for the PAB
    hr = m_pAdrBook->GetPAB(&cbContainerID, &pContainerID);
    if (FAILED(hr))
        goto error;
    
    // Request the container
    hr = m_pAdrBook->OpenEntry(cbContainerID, pContainerID, NULL,
        0, &ul, (LPUNKNOWN *) &pABContainer);
    Assert(ul == MAPI_ABCONT);
    if (FAILED(hr))
        goto error;
    
    // Free the entry ID
    m_pWABObject->FreeBuffer(pContainerID);
    
    // Get the properties for the default mail template
    hr = pABContainer->GetProps((LPSPropTagArray) &ptaDefMailUser, 0, &ul, &ppvDefMailUser);
    if (FAILED(hr) || !ppvDefMailUser || ppvDefMailUser->ulPropTag != PR_DEF_CREATE_MAILUSER)
        goto error;
    
    // Create a new entry
    hr=pABContainer->CreateEntry(ppvDefMailUser->Value.bin.cb, 
        (LPENTRYID) ppvDefMailUser->Value.bin.lpb,
        CREATE_CHECK_DUP_STRICT, &lpProps);
    if (FAILED(hr))
        goto error;
    
    // Fill in the properties for the display name and address
    rgpv[0].ulPropTag   = PR_DISPLAY_NAME_W;
    rgpv[0].Value.lpszW = pwszDisplay;
    rgpv[1].ulPropTag   = PR_EMAIL_ADDRESS;
    rgpv[1].Value.lpszA = pszAddress;
    
    cUsedValues = 2;
    // Set those props on the entry
    hr = lpProps->SetProps(cUsedValues, rgpv, NULL);
    if (FAILED(hr))
        goto error;
    
    // Save 'em
    hr = lpProps->SaveChanges(KEEP_OPEN_READONLY);
    if (FAILED(hr))
        goto error;
    
error:
    ReleaseObj(lpProps);
    ReleaseObj(pABContainer);
    
    if (ppvDefMailUser)
        m_pWABObject->FreeBuffer(ppvDefMailUser);
    
    return hr;
}


HRESULT CAddressBookData::DeleteItems(ENTRYLIST *pList)
{
    ULONG       ulObjType = 0;
    LPABCONT    lpContainer = NULL;
    HRESULT     hr = E_FAIL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;

    // Get the entryid of the root PAB container
    hr = m_pAdrBook->GetPAB(&lpcbEID, &lpEID);

    // Open the root PAB container.  This is where all the WAB contents reside.
    ulObjType = 0;
    hr = m_pAdrBook->OpenEntry(lpcbEID,
                               (LPENTRYID)lpEID,
                               NULL,
                               0,
                               &ulObjType,
                               (LPUNKNOWN *) &lpContainer);

    m_pWABObject->FreeBuffer(lpEID);
    lpEID = NULL;

    // Delete those items
    lpContainer->DeleteEntries(pList, 0);

    lpContainer->Release();
    return (S_OK);
}

HRESULT CAddressBookData::Find(HWND hwndParent)
{
    m_pWABObject->Find(m_pAdrBook, hwndParent);
    return (S_OK);
}


HRESULT CAddressBookData::NewGroup(HWND hwndParent)
{
    HRESULT     hr;
    ULONG       cbNewEntry = 0;
    LPENTRYID   pNewEntry = 0;
    LPENTRYID   pTplEid;
    ULONG       cbTplEid;

    hr = _GetWABTemplateID(MAPI_DISTLIST, &cbTplEid, &pTplEid);
    if (SUCCEEDED(hr))
    {
        hr = m_pAdrBook->NewEntry((ULONG_PTR) hwndParent, 0, 0, NULL, cbTplEid, pTplEid, &cbNewEntry, &pNewEntry);
        Assert(pTplEid);
        m_pWABObject->FreeBuffer(pTplEid);
    }

    return (hr);
}

HRESULT CAddressBookData::AddressBook(HWND hwndParent)
{
    CWab *pWab = NULL;
    
    if (SUCCEEDED(HrCreateWabObject(&pWab)))
    {
        pWab->HrBrowse(hwndParent);
        pWab->Release();
    }
    else
    {
        AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsGeneralWabError), 
                      NULL, MB_OK | MB_ICONEXCLAMATION);
    }

    return (S_OK);
}


HRESULT CAddressBookData::_GetWABTemplateID(ULONG ulObjectType, ULONG *lpcbEID, LPENTRYID *lppEID)
{
    LPABCONT lpContainer = NULL;
    HRESULT  hr  = S_OK;
    SCODE    sc = ERROR_SUCCESS;
    ULONG    ulObjType = 0;
    ULONG    cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG    cNewProps;
    ULONG    nIndex;

    if ((!m_pAdrBook) || ((ulObjectType != MAPI_MAILUSER) && (ulObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpcbEID = 0;
    *lppEID  = NULL;

    if (FAILED(hr = m_pAdrBook->GetPAB(&cbWABEID, &lpWABEID)))
    {
        goto out;
    }

    if (HR_FAILED(hr = m_pAdrBook->OpenEntry(cbWABEID,     // size of EntryID to open
                                              lpWABEID,     // EntryID to open
                                              NULL,         // interface
                                              0,            // flags
                                              &ulObjType,
                                              (LPUNKNOWN *) &lpContainer)))
    {
        goto out;
    }

    // Get us the default creation entryids
    if (FAILED(hr = lpContainer->GetProps((LPSPropTagArray) &ptaCreate,
                                          0, &cNewProps, &lpCreateEIDs)))
    {
        goto out;
    }

    // Validate the properites
    if (lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
        lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        goto out;
    }

    if (ulObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;

    m_pWABObject->AllocateBuffer(*lpcbEID, (LPVOID *) lppEID);
    
    if (sc != S_OK)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);

out:
    if (lpCreateEIDs)
        m_pWABObject->FreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->Release();

    if (lpWABEID)
        m_pWABObject->FreeBuffer(lpWABEID);

    return hr;
}

/*//$$****************************************************************
//
// InitNamedProps
//
// Gets the PropTags for the Named Props this app is interested in
//
//********************************************************************/
HRESULT CAddressBookData::InitNamedProps(/*LPWABEXTDISPLAY lpWED*/)
{
    ULONG i;
    HRESULT hr = E_FAIL;
    LPSPropTagArray lptaMsgrProps = NULL;
    LPMAPINAMEID * lppMsgrPropNames;
    SCODE sc;
    // LPMAILUSER lpMailUser = NULL;
    WCHAR szBuf[msgrMax][MAX_PATH];

/*    if(!lpWED)
        goto err;

    lpMailUser = (LPMAILUSER) lpWED->lpPropObj;

    if(!lpMailUser)
        goto err; */

    sc = m_pWABObject->AllocateBuffer(sizeof(LPMAPINAMEID) * msgrMax, 
                                            (LPVOID *) &lppMsgrPropNames);
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    for(i=0;i<msgrMax;i++)
    {
        sc = m_pWABObject->AllocateMore(sizeof(MAPINAMEID), 
                                                lppMsgrPropNames, 
                                                (LPVOID *)&(lppMsgrPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppMsgrPropNames[i]->lpguid = (LPGUID) &WAB_ExtBAGuid;
        lppMsgrPropNames[i]->ulKind = MNID_STRING;

        *(szBuf[i]) = '\0';

        // Convert prop name to wide-char
        if ( !MultiByteToWideChar( GetACP(), 0, lpMsgrPropNames[i], -1, szBuf[i], ARRAYSIZE(szBuf[i]) ))
        {
            continue;
        }

        lppMsgrPropNames[i]->Kind.lpwstrName = (LPWSTR) szBuf[i];
    }

    hr = m_pAdrBook->GetIDsFromNames(   msgrMax, 
                                        lppMsgrPropNames,
                                        MAPI_CREATE, 
                                        &lptaMsgrProps);
    if(HR_FAILED(hr))
        goto err;

    if(lptaMsgrProps)
    {
        // Set the property types on the returned props
        MsgrPropTags[MsgrID] = PR_MSGR_DEF_ID = CHANGE_PROP_TYPE(lptaMsgrProps->aulPropTag[MsgrID], PT_TSTRING);
    }

err:
    if(lptaMsgrProps)
        m_pWABObject->FreeBuffer( lptaMsgrProps);

    if(lppMsgrPropNames)
        m_pWABObject->FreeBuffer( lppMsgrPropNames);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\logwatch\logwatch.cpp ===
// ----------------------------------------------------------------------------
// LogWatch.cpp
// ----------------------------------------------------------------------------
#include <pch.hxx>
#include <richedit.h>
#include "resource.h"

// ------------------------------------------------------------------------------------
// Prototypes
// ------------------------------------------------------------------------------------
INT_PTR CALLBACK LogWatchDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// ----------------------------------------------------------------------------
// WinMain
// ----------------------------------------------------------------------------
int _stdcall ModuleEntry(void)
{
    // Locals
    LPTSTR pszCmdLine;

    // Load RichEdit
    HINSTANCE hRichEdit = LoadLibrary("RICHED32.DLL");

    // Get the commandline
    pszCmdLine = GetCommandLine();

    // Fixup Command line
    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    // Launch the Dialog
    DialogBoxParam(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_LOGWATCH), NULL, LogWatchDlgProc, (LPARAM)pszCmdLine);

    // Free RichEdit
    if (hRichEdit)
        FreeLibrary(hRichEdit);

    // Done
    return 1;
}

// ------------------------------------------------------------------------------------
// LogWatchDlgProc
// ------------------------------------------------------------------------------------
INT_PTR CALLBACK LogWatchDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPSTR               pszFilePath;
    ULONG               cbRead;
    BYTE                rgb[4096];
    static HANDLE       s_hFile=INVALID_HANDLE_VALUE;
    static HWND         s_hwndEdit=NULL;
    
    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the file
        pszFilePath = (LPSTR)lParam;

        // No File
        if (NULL == pszFilePath || '\0' == *pszFilePath)
        {
            MessageBox(hwnd, "You must specify a file name on the command line.\r\n\r\nFor example: LogWatch.exe c:\\test.log", "Microsoft LogWatch", MB_OK | MB_ICONSTOP);
            EndDialog(hwnd, IDOK);
            return FALSE;
        }

        // Open the file
        s_hFile = CreateFile(pszFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        // Failure
        if (INVALID_HANDLE_VALUE == s_hFile)
        {
            wsprintf((LPSTR)rgb, "The file '%s' could not be opened by LogWatch. The file does not exist or is in use by another application.", pszFilePath);
            MessageBox(NULL, (LPSTR)rgb, "Microsoft LogWatch", MB_OK | MB_ICONSTOP);
            EndDialog(hwnd, IDOK);
            return FALSE;
        }

        // Set Title Batr
        wsprintf((LPSTR)rgb, "Microsoft LogWatch - %s", pszFilePath);
        SetWindowText(hwnd, (LPSTR)rgb);

        // Seek to the end of the file - 256 bytes
        SetFilePointer(s_hFile, (256 > GetFileSize(s_hFile, NULL)) ? 0 : - 256, NULL, FILE_END);

        // Create the RichEdit Control
        s_hwndEdit = GetDlgItem(hwnd, IDC_EDIT);

        // Read a Buffer
        ReadFile(s_hFile, rgb, sizeof(rgb) - 1, &cbRead, NULL);

        // Hide Selection
        SendMessage(s_hwndEdit, EM_HIDESELECTION , TRUE, TRUE);

        // Done
        if (cbRead)
        {
            // Append to end of text
            rgb[cbRead] = '\0';
            LPSTR psz = (LPSTR)rgb;
            while(*psz && '\n' != *psz)
                psz++;
            SendMessage(s_hwndEdit, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(s_hwndEdit, EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)psz);
            SendMessage(s_hwndEdit, EM_SCROLLCARET, 0, 0);
        }

        // Kick off the time
        SetTimer(hwnd, WM_USER + 1024, 2000, NULL);
        SetFocus(s_hwndEdit);

        // Done
        return FALSE;

    case WM_TIMER:
        if (wParam == (WM_USER + 1024))
        {
            // Read to end
            while(1)
            {
                // Read a Buffer
                ReadFile(s_hFile, rgb, sizeof(rgb) - 1, &cbRead, NULL);

                // Done
                if (!cbRead)
                    break;

                // Append to end of text
                rgb[cbRead] = '\0';
                SendMessage(s_hwndEdit, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
                SendMessage(s_hwndEdit, EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)rgb);
                SendMessage(s_hwndEdit, EM_SCROLLCARET, 0, 0);
            }
        }
        break;

    case WM_SIZE:
        SetWindowPos(s_hwndEdit,0,0,0, LOWORD(lParam), HIWORD(lParam),SWP_NOACTIVATE|SWP_NOZORDER);
        break;

#if 0
    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        }
        break;
#endif

    case WM_CLOSE:
        KillTimer(hwnd, WM_USER + 1024);
        EndDialog(hwnd, IDOK);
        break;

    case WM_DESTROY:
        if (INVALID_HANDLE_VALUE != s_hFile)
            CloseHandle(s_hFile);
        return FALSE;
    }

    // Done
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\baprop.h ===
// baprop.h
// WAB & Messenger integration to OE
// Created 06/23/98 by YST
//
//////////////////////////////////////////////////////////////////////

#ifndef __BAPROP_H_
#define __BAPROP_H_

#include "pch.hxx"
#include "badata.h"
#include "demand.h"

// Definitions
void AddCBEmailItem(HWND hWndCB, LPTSTR  lpszEmailAddress, BOOL fDefault, LPTSTR lpszPendName);
INT_PTR CALLBACK WabExtDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
void AddAccountsToList(HWND hDlg, LPWABEXTDISPLAY lpWED, LPTSTR lpszPendName = NULL);
void SetAsDefault(HWND hDlg, LPWABEXTDISPLAY lpWED);
void AddMsgrId(HWND hDlg, LPWABEXTDISPLAY lpWED);
void SetDefaultID(TCHAR *szName, HWND hdlg, LPWABEXTDISPLAY lpWED);
BOOL AsciiTrimSpaces(TCHAR * szBuf);
HRESULT AddPropToMVPString(LPWABEXTDISPLAY lpWED, LPSPropValue lpaProps, DWORD cProps, DWORD index, LPTSTR lpszNew);
void WabSendIMsg(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL InitFonts(void);
void DeleteFonts(void);
BOOL WabIsItemOnline(HWND hDlg, int iItem);

#endif // __BAPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\bllist.cpp ===
// bllist.cpp : Implementation of the CMsgrList
// Messenger integration to OE
// Created 05/07/98 by YST
// 

#include "pch.hxx"
#include "bllist.h"
#include "mdisp.h"
#include "util.h"
#include "blobevnt.h"
#include "demand.h"
#include <string.h>
#include <instance.h>
#include "menuutil.h"

static CMsgrList * sg_pMsgrList = NULL;     // global for buddy list

CMsgrList::CMsgrList()
{
    m_pblInfRoot = NULL;
    m_pblInfLast = NULL;
    m_pWndLRoot = NULL;
    m_pWndLLast = NULL;
    m_nRef = 1;
    m_spMsgrObject = NULL;
    m_pMsgrObjectEvents = NULL;
    m_MsgrCookie = 0xffffffff;
}


CMsgrList::~CMsgrList()
{
    Assert(m_nRef == 0);

    if(m_pblInfRoot)
    {
        FreeMsgrInfoList(m_pblInfRoot);
        m_pblInfRoot = NULL;
        m_pblInfLast = NULL;
    }

    if(m_pWndLRoot)
        FreeWndList(m_pWndLRoot);

    if(m_pMsgrObjectEvents)
    {
        m_pMsgrObjectEvents->DelListOfBuddies();
        if (m_MsgrCookie != 0xffffffff && m_spMsgrObject != NULL)
            m_spMsgrObject->UnadviseOE(m_MsgrCookie);
        m_pMsgrObjectEvents->Release();
        m_pMsgrObjectEvents = NULL;
    }
}

void CMsgrList::Release()
{
    Assert(m_nRef > 0);

    m_nRef--;
    if(m_nRef == 0)
    {
        DelAllEntries(NULL);
        delete this;
        sg_pMsgrList = NULL;
    }
}

// Check and Init Msgr
HRESULT CMsgrList::CheckAndInitMsgr()
{
    if(m_pblInfRoot)
        return(S_OK);
    else
    {
        // Do Initialization again
        if(!m_pMsgrObjectEvents)
        {
            if(HrInitMsgr() == S_OK)
                return(FillList());
            else
                return S_FALSE;
        }
        else
            return(FillList());
    }
    return S_FALSE;         //???
}

// Free list of client UI window
void CMsgrList::FreeWndList(LPMWNDLIST pWndEntry)
{
    if(pWndEntry->pNext)
        FreeWndList(pWndEntry->pNext);
    
    MemFree(pWndEntry);
    pWndEntry = NULL;
}

// Free list buddies
void CMsgrList::FreeMsgrInfoList(LPMINFO pEntry)
{
    if(pEntry == NULL)
        return;
    if(pEntry->pNext)
        FreeMsgrInfoList(pEntry->pNext);

    MemFree(pEntry->pchMsgrName);
    MemFree(pEntry->pchID);
    MemFree(pEntry);
    pEntry = NULL;
}

// Remove buddy from list
void CMsgrList::RemoveMsgrInfoEntry(LPMINFO pEntry)
{
    if(m_pblInfLast == pEntry)
        m_pblInfLast = pEntry->pPrev;

    if(m_pblInfRoot == pEntry)
        m_pblInfRoot = pEntry->pNext;

    MemFree(pEntry->pchMsgrName);
    MemFree(pEntry->pchID);

    if(pEntry->pPrev)
        (pEntry->pPrev)->pNext = pEntry->pNext;

    if(pEntry->pNext)
        (pEntry->pNext)->pPrev = pEntry->pPrev;

    MemFree(pEntry);
    pEntry = NULL;
}

// Check that item is Online starting point for search is pEntry
BOOL CMsgrList::IsContactOnline(TCHAR *pchID, LPMINFO pEntry)
{
    if(!pEntry)
        return(FALSE);

    if(!lstrcmpi(pEntry->pchID, pchID))
    {
        if((pEntry->nStatus != MSTATEOE_OFFLINE)  && (pEntry->nStatus != MSTATEOE_INVISIBLE))
            return(TRUE);
        else
            return(FALSE);
    }
    else if(pEntry->pNext)
        return(IsContactOnline(pchID, pEntry->pNext));
    else
        return(FALSE);
}

// Find entry with ID == szID and remove this from list
void CMsgrList::FindAndRemoveBlEntry(TCHAR *szID, LPMINFO pEntry)
{
    if(!pEntry)
        pEntry = m_pblInfRoot;

    if(!pEntry)
        return;

    if(!lstrcmpi(pEntry->pchID, szID))
    {
        RemoveMsgrInfoEntry(pEntry);
    }
    else if(pEntry->pNext)
        FindAndRemoveBlEntry(szID, pEntry->pNext);
}

// Send message to all registred client UI windows
void CMsgrList::SendMsgToAllUIWnd(UINT msg, WPARAM wParam, LPARAM lParam, LPMWNDLIST pWndEntry)
{
    if(!pWndEntry)
        pWndEntry = m_pWndLRoot;

    if(!pWndEntry)
        return;

    if(pWndEntry->pNext)
        SendMsgToAllUIWnd(msg, wParam, lParam, pWndEntry->pNext);

    ::SendMessage(pWndEntry->hWndUI, msg, wParam, lParam);
}

// Add client Window to list
void CMsgrList::AddWndEntry(HWND hWnd)
{
    if(m_pWndLLast == NULL)
    {
        // Really first entry
        Assert(!m_pWndLRoot);
        if (!MemAlloc((LPVOID *) &m_pWndLLast, sizeof(MsgrWndList)))
            return;
        m_pWndLRoot = m_pWndLLast;
        m_pWndLLast->pPrev = NULL;
    }
    else 
    {
        if (!MemAlloc((LPVOID *) &(m_pWndLLast->pNext), sizeof(MsgrWndList)))
            return;
        (m_pWndLLast->pNext)->pPrev = m_pWndLLast;
        m_pWndLLast = m_pWndLLast->pNext;

    }
    
    m_pWndLLast->pNext = NULL;
    m_pWndLLast->hWndUI = hWnd;

}

// remove entry from WND list
void CMsgrList::RemoveWndEntry(LPMWNDLIST pWndEntry)
{
    if(m_pWndLLast == pWndEntry)
        m_pWndLLast = pWndEntry->pPrev;

    if(m_pWndLRoot == pWndEntry)
        m_pWndLRoot = pWndEntry->pNext;

    if(pWndEntry->pPrev)
        (pWndEntry->pPrev)->pNext = pWndEntry->pNext;

    if(pWndEntry->pNext)
        (pWndEntry->pNext)->pPrev = pWndEntry->pPrev;

    MemFree(pWndEntry);
    pWndEntry = NULL;

}

// Find entry and remove it from list
void CMsgrList::FindAndDelEntry(HWND hWnd, LPMWNDLIST pWndEntry)
{
    if(!pWndEntry)
        pWndEntry = m_pWndLRoot;

    if(!pWndEntry)
        return;

    if(pWndEntry->hWndUI == hWnd)
    {
        RemoveWndEntry(pWndEntry);
    }
    else if(pWndEntry->pNext)
        FindAndDelEntry(hWnd, pWndEntry->pNext);
}

void  CMsgrList::DelAllEntries(LPMWNDLIST pWndEntry)
{
    if(pWndEntry == NULL)
        pWndEntry = m_pWndLRoot;                

    if(pWndEntry == NULL)
        return;

    if(pWndEntry->pNext)
        DelAllEntries(pWndEntry->pNext);

    RemoveWndEntry(pWndEntry);
}

HRESULT CMsgrList::HrInitMsgr(void)
{
	//create the COM server and connect to it
	HRESULT hr = S_OK;
    
    Assert(m_pMsgrObjectEvents == NULL);

    m_spMsgrObject = NULL;
	hr = CoCreateInstance(CLSID_MessengerApp, NULL,CLSCTX_LOCAL_SERVER, 
		                IID_IMsgrOE, (LPVOID *)&m_spMsgrObject);
    if(FAILED(hr))
    {
        return(hr);
    }

    m_pMsgrObjectEvents = new CMsgrObjectEvents();
    if (m_pMsgrObjectEvents == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
	    hr = m_spMsgrObject->AdviseOE(m_pMsgrObjectEvents, &m_MsgrCookie);
        //We, of course, have to release m_pMsgrObjectEvents when we are finished with it
        if(FAILED(hr))
        {
            m_pMsgrObjectEvents->Release();
            m_pMsgrObjectEvents = NULL;
        }
        else 
            m_pMsgrObjectEvents->SetListOfBuddies(this);
    }

    return(hr);
}

// Set new buddy status (online/ofline/etc. and redraw list view entry)
HRESULT CMsgrList::EventUserStateChanged(IMsgrUserOE * pUser)
{
    BSTR bstrID;
    HRESULT hr = pUser->get_LogonName(&bstrID);
    BOOL fFinded = FALSE;

    if (SUCCEEDED(hr))
    {
        MSTATEOE nState = MSTATEOE_UNKNOWN;
        if(SUCCEEDED(pUser->get_State(&nState)))
        {
            LPTSTR pszID;
            pszID = LPTSTRfromBstr(bstrID);
            if (pszID != NULL)
            {
                LPMINFO pInf = m_pblInfRoot;
                if(!pInf)
                {
                    MemFree(pszID);    
                    SysFreeString(bstrID);
                    return(hr);
                }

                // Find buddy in our list
                do
                {
                    if(!lstrcmpi(pInf->pchID, pszID))
                    {
                        fFinded = TRUE;
                        break;
                    }
                } while ((pInf = pInf->pNext) != NULL);

                if(fFinded)
                {
                    pInf->nStatus = nState;
                    SendMsgToAllUIWnd(WM_USER_STATUS_CHANGED, (WPARAM) nState, (LPARAM) pszID);
                }
                MemFree(pszID);
            }
        }
 
    }

    SysFreeString(bstrID);
    return(hr);
}

// Baddy was removed
HRESULT CMsgrList::EventUserRemoved(IMsgrUserOE * pUser)
{
    BSTR bstrID;
    HRESULT hr = pUser->get_LogonName(&bstrID);

    if (SUCCEEDED(hr))
    {
        Assert(m_nRef > 0);  
        LPTSTR pszID;

        pszID = LPTSTRfromBstr(bstrID);
        if (pszID != NULL)
        {
            SendMsgToAllUIWnd(WM_USER_MUSER_REMOVED, (WPARAM) 0, (LPARAM) pszID);
            FindAndRemoveBlEntry(pszID);
            MemFree(pszID);
        }
    }

    SysFreeString(bstrID);
    return(hr);
}

// Event: buddy name was changed
// Add buddy to our list and send message to UI windows about this.
HRESULT CMsgrList::EventUserNameChanged(IMsgrUserOE * pUser)
{
    BSTR bstrName;
    BSTR bstrID;
    BOOL fFinded = FALSE;

    HRESULT hr = pUser->get_LogonName(&bstrID);
    hr = pUser->get_FriendlyName(&bstrName);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszName;
        LPTSTR pszID;

        pszName = LPTSTRfromBstr(bstrName);
        if (pszName != NULL)
        {
            pszID = LPTSTRfromBstr(bstrID);
            if (pszID != NULL)
            {
                LPMINFO pInf = m_pblInfRoot;

                // Find buddy in our list
                do
                {
                    if(!lstrcmpi(pInf->pchID, pszID))
                    {
                        fFinded = TRUE;
                        break;
                    }
                } while ((pInf = pInf->pNext) != NULL);

                if(fFinded)
                {
                    if(pInf->pchMsgrName)
                        MemFree(pInf->pchMsgrName);       // Free prev name
                    pInf->pchMsgrName = pszName;
                    pszName = NULL;
                    SendMsgToAllUIWnd(WM_USER_NAME_CHANGED, (WPARAM) 0, (LPARAM) pInf);
                }

                MemFree(pszID);
            }

            SafeMemFree(pszName);
        }
    }

    SysFreeString(bstrName);
    SysFreeString(bstrID);
    return(hr);

}

// Event: buddy was added
// Add buddy to our list and send message to UI windows about this.

HRESULT CMsgrList::EventUserAdded(IMsgrUserOE * pUser)
{
    BSTR bstrName;
    BSTR bstrID;

    HRESULT hr = pUser->get_LogonName(&bstrID);
    hr = pUser->get_FriendlyName(&bstrName);
    if (SUCCEEDED(hr))
    {
        MSTATEOE nState = MSTATEOE_UNKNOWN;
        if(SUCCEEDED(pUser->get_State(&nState)))
        {
            LPTSTR pszName;
            LPTSTR pszID;

            pszName = LPTSTRfromBstr(bstrName);
            if (pszName != NULL)
            {
                pszID = LPTSTRfromBstr(bstrID);
                if (pszID != NULL)
                {
                    AddMsgrListEntry(pszName, pszID, nState);
                    SendMsgToAllUIWnd(WM_USER_MUSER_ADDED, (WPARAM) 0, (LPARAM) m_pblInfLast);

                    MemFree(pszID);
                }

                MemFree(pszName);
            }
        }
    }
    SysFreeString(bstrName);
    SysFreeString(bstrID);
    return(hr);
}

HRESULT CMsgrList::EventLogoff()
{
    SendMsgToAllUIWnd(WM_MSGR_LOGOFF, (WPARAM) 0, (LPARAM) 0);
    FreeMsgrInfoList(m_pblInfRoot);
    m_pblInfRoot = NULL;
    m_pblInfLast = NULL;
    return(S_OK);
    
}

HRESULT CMsgrList::EventAppShutdown()
{
    SendMsgToAllUIWnd(WM_MSGR_SHUTDOWN, (WPARAM) 0, (LPARAM) 0);
    return(S_OK);
    
}

HRESULT CMsgrList::EventLogonResult(long lResult)
{
    if(!m_pblInfRoot && SUCCEEDED(lResult))
        FillList();
    else if(SUCCEEDED(lResult))
    {
        EnterCriticalSection(&g_csMsgrList);
        FreeMsgrInfoList(m_pblInfRoot);
        m_pblInfRoot = NULL;
        m_pblInfLast = NULL;
        FillList();
        LeaveCriticalSection(&g_csMsgrList);
    }
    SendMsgToAllUIWnd(WM_MSGR_LOGRESULT, (WPARAM) 0, (LPARAM) lResult);
    return(S_OK);
}

// return number of buddies
long CMsgrList::GetCount()
{
    HRESULT hr = E_FAIL;
    long lCount = 0;
    CComPtr<IMsgrUsersOE> spBuddies;

    if (!m_spMsgrObject)
        goto Exit;

    hr = m_spMsgrObject->get_ContactList(&spBuddies);
    if( FAILED(hr) )
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Buddies() failed, hr = %s"), g_GetErrorString(hr));
        Assert(FALSE);
        goto Exit;
    }

    //Iterate through the MsgrList make sure that the buddy we wish to remove is effectively in the list
    hr = spBuddies->get_Count(&lCount);
    Assert(SUCCEEDED(hr));
Exit:
    return(lCount);
}

HRESULT CMsgrList::FillList()
{
    long lCount = 0;
	IMsgrUserOE* pUser = NULL;

	//process the Buddies list
	IMsgrUsersOE *pBuddies = NULL;

    if(!m_spMsgrObject)
        return S_FALSE;

	HRESULT hr = m_spMsgrObject->get_ContactList(&pBuddies);
    if(FAILED(hr))
    {
FilErr:
        if(m_pMsgrObjectEvents)
        {
            m_pMsgrObjectEvents->DelListOfBuddies();
            if (m_MsgrCookie != 0xffffffff)
            {
                if (m_spMsgrObject)
                    m_spMsgrObject->UnadviseOE(m_MsgrCookie);
                m_MsgrCookie = 0xffffffff;
            }
            m_pMsgrObjectEvents->Release();
            m_pMsgrObjectEvents = NULL;
        }
        return(hr);
    }

    //Check the current state (in case the client was already running and was 
	//not in the logoff state
	MSTATEOE lState = MSTATEOE_OFFLINE;
    if (m_spMsgrObject)
	    hr = m_spMsgrObject->get_LocalState(&lState);

    if(FAILED(hr) /*|| lState == MSTATEOE_OFFLINE  !(lState == MSTATEOE_ONLINE || lState == MSTATEOE_BUSY || lState == MSTATEOE_INVISIBLE)*/)
    {
Err2:
        pBuddies->Release();
        pBuddies = NULL;
        goto FilErr;
    }
    else if(lState == MSTATEOE_OFFLINE)
    {
        if(FAILED(AutoLogon()))
            goto Err2;
    }

    if(!SUCCEEDED(pBuddies->get_Count(&lCount)))
                    goto Err2;

    for (int i = 0; i < lCount; i++)
	{
	    hr = pBuddies->Item(i, &pUser);
		if(SUCCEEDED(hr))
		{
		    // EventUserAdded(pUser);
            BSTR bstrName;
            BSTR bstrID;

            hr = pUser->get_LogonName(&bstrID);
            hr = pUser->get_FriendlyName(&bstrName);
            if (SUCCEEDED(hr))
            {
                MSTATEOE nState = MSTATEOE_UNKNOWN;
                if(SUCCEEDED(pUser->get_State(&nState)))
                {
                    LPTSTR pszName;
                    LPTSTR pszID;

                    pszName = LPTSTRfromBstr(bstrName);
                    if (pszName != NULL)
                    {
                        pszID = LPTSTRfromBstr(bstrID);
                        if (pszID != NULL)
                        {
                            AddMsgrListEntry(pszName, pszID, nState);
                            MemFree(pszID);
                        }

                        MemFree(pszName);
                    }
                }
            }
            SysFreeString(bstrName);
            SysFreeString(bstrID);
            pUser->Release();
        }
    }
    pBuddies->Release();
    return(S_OK);
}

// Add entry to list of buddies
void CMsgrList::AddMsgrListEntry(TCHAR *szName, TCHAR *szID, int nState)
{
    if(m_pblInfLast == NULL)
    {
        // Really first entry
        Assert(!m_pblInfRoot);
        if (!MemAlloc((LPVOID *) &m_pblInfLast, sizeof(oeMsgrInfo)))
            return;
        m_pblInfRoot = m_pblInfLast;
        m_pblInfLast->pPrev = NULL;
    }
    else 
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pNext), sizeof(oeMsgrInfo)))
            return;
        (m_pblInfLast->pNext)->pPrev = m_pblInfLast;
        m_pblInfLast = m_pblInfLast->pNext;

    }
    
    m_pblInfLast->pNext = NULL;

    if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchMsgrName), lstrlen(szName) + 1))
        return;
    StrCpyN(m_pblInfLast->pchMsgrName, szName, lstrlen(szName)+1);

    if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchID), lstrlen(szID) + 1))
        return;
    StrCpyN(m_pblInfLast->pchID, szID, lstrlen(szID)+1);
    m_pblInfLast->nStatus = nState;

}

// register ui window in list
void CMsgrList::RegisterUIWnd(HWND hWndUI)
{
    CheckAndInitMsgr();
    AddWndEntry(hWndUI);
}

// remove UI window from list
void CMsgrList::UnRegisterUIWnd(HWND hWndUI)
{
    if(hWndUI)
        FindAndDelEntry(hWndUI);
}

// This call Messenger UI for instant message.
HRESULT CMsgrList::SendInstMessage(TCHAR *pchID)
{
    Assert(m_spMsgrObject);
    BSTRING bstrName(pchID);
    VARIANT var;
    var.bstrVal = bstrName;
    var.vt = VT_BSTR;

    HRESULT hr = S_OK;
    if(m_spMsgrObject)
        hr = m_spMsgrObject->LaunchIMUI(var);

    return(hr);
}

HRESULT CMsgrList::AutoLogon()
{
    if(m_spMsgrObject)
    {
        if(DwGetOption(OPT_BUDDYLIST_CHECK))
            m_spMsgrObject->AutoLogon();
    }
    else
        return(E_FAIL);

    return S_OK;

}

HRESULT CMsgrList::UserLogon()
{
    if(m_spMsgrObject)
        return(m_spMsgrObject->LaunchLogonUI());
    else
        return(S_FALSE);
}

// Logoff call
HRESULT CMsgrList::UserLogoff()
{
    if(!m_spMsgrObject)
        return E_UNEXPECTED;

    return(m_spMsgrObject->Logoff());
}

// Get/Set local states.
HRESULT CMsgrList::GetLocalState(MSTATEOE *pState)
{
    if(m_spMsgrObject && SUCCEEDED(m_spMsgrObject->get_LocalState(pState)))
        return(S_OK);
    else
        return(S_FALSE);
}

// Check name: this is local name?
BOOL CMsgrList::IsLocalName(TCHAR *pchName)
{
    CComBSTR cbstrID;
    HRESULT hr;
    BOOL fRes = FALSE;

    if(m_spMsgrObject)
    {
        hr = m_spMsgrObject->get_LocalLogonName(&cbstrID);
        if(FAILED(hr))
            return FALSE;
        TCHAR *pch = LPTSTRfromBstr(cbstrID);
        if(!lstrcmpi(pchName, pch))
            fRes = TRUE;

        MemFree(pch);
    }

    return(fRes);    
}

// Check current state
BOOL CMsgrList::IsLocalOnline(void)
{
    MSTATEOE State;
    if(m_spMsgrObject && SUCCEEDED(m_spMsgrObject->get_LocalState(&State)))
    {
        switch(State)
        {
            case MSTATEOE_ONLINE:
            case MSTATEOE_INVISIBLE:
            case MSTATEOE_BUSY:
            case MSTATEOE_BE_RIGHT_BACK:
            case MSTATEOE_IDLE:
            case MSTATEOE_AWAY:
            case MSTATEOE_ON_THE_PHONE:
            case MSTATEOE_OUT_TO_LUNCH:
                return(TRUE);

            default:
                return(FALSE);
        }
    }
    return(FALSE);
}

HRESULT CMsgrList::SetLocalState(MSTATEOE State)
{
    if(m_spMsgrObject && State != MSTATEOE_UNKNOWN)
    {
        m_spMsgrObject->put_LocalState(State);
        return S_OK;                        
    }
    else
        return S_FALSE;
}

HRESULT CMsgrList::NewOnlineContact()
{
    if(m_spMsgrObject)
        return(m_spMsgrObject-> LaunchAddContactUI(NULL));
    else
        return(S_FALSE); 

}

HRESULT CMsgrList::LaunchOptionsUI(void)
{
    if(m_spMsgrObject)
        return(m_spMsgrObject-> LaunchOptionsUI());
    else
        return(S_FALSE); 
}

//****************************************************************************
//
// void CMsgrList::DeleteUser
//
// This function finds
// the buddy to be removed in the MsgrList and then calls the Remove method.
//
//****************************************************************************

HRESULT CMsgrList::FindAndDeleteUser(TCHAR * pchID, BOOL fDelete) 
{
    USES_CONVERSION;

    HRESULT             hr = E_FAIL;
    INT                 i;
    LONG                lCount = 0;
    BOOL                bFound = FALSE;
    CComPtr<IMsgrUserOE>  spUser;
    CComPtr<IMsgrUsersOE> spBuddies;
    // BSTRING             bstrName(pchID);
    // get an interface pointer to the MsgrList, so we can call the method Remove after
    if (!m_spMsgrObject)
    {
        hr = E_FAIL;
        goto Exit;
    }
    hr = m_spMsgrObject->get_ContactList(&spBuddies);
    if( FAILED(hr) )
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Buddies() failed, hr = %s"), g_GetErrorString(hr));
        Assert(FALSE);
        goto Exit;
    }

    //Iterate through the MsgrList make sure that the buddy we wish to remove is effectively in the list
    hr = spBuddies->get_Count(&lCount);
    Assert(SUCCEEDED(hr));
    
    for(i = 0; ((i<lCount) && (!bFound)); i++)
    {
        CComBSTR    cbstrID;

        spUser.Release();
        hr = spBuddies->Item(i, &spUser);
        
        if (SUCCEEDED(hr))
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("Item : %i succeeded"), i);
            
            hr = spUser->get_LogonName(&cbstrID);
            Assert(SUCCEEDED(hr));
            TCHAR *pch = LPTSTRfromBstr(cbstrID);

            // BSTRING bstrName(pchID);
            
            // if (_tcsicmp( W2T((BSTR)cbstrID), W2T(bstrName)) == 0)
            if (lstrcmpi(pch, pchID) == 0)
                bFound = TRUE;

            MemFree(pch);

            if (bFound)
                break;
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("Item : %i failed, hr = %s"), i, g_GetErrorString(hr));
            Assert(FALSE);
        }
    }
    
    // if we found the buddy in the list
    if( bFound )
    {
        if(fDelete)
            //finally, make the request to remove the buddy to the MsgrList
            hr = spBuddies->Remove(spUser);
        else
            // just search
            hr = S_OK;
    }
    else // Not found
    
        hr = DISP_E_MEMBERNOTFOUND;
Exit:
//    SysFreeString(bstrName);
    return(hr);
}

HRESULT CMsgrList::AddUser(TCHAR * pchID) 
{
    CComPtr<IMsgrUserOE>  spUser;
    CComPtr<IMsgrUsersOE> spUsers;
    BSTRING             bstrName(pchID);

    HRESULT hr = FindAndDeleteUser(pchID, FALSE /*fDelete*/);
    if(hr != DISP_E_MEMBERNOTFOUND)
        return(hr);

    // if not found, add buddy

    // get an interface pointer to the MsgrList, so we can call the method Remove after
    if (!m_spMsgrObject)
        return E_FAIL;
    hr = m_spMsgrObject->LaunchAddContactUI(bstrName);

    return(hr);

}


// Global functions available for everybody

// Entrance to MsgrList
CMsgrList *OE_OpenMsgrList(void)
{
    if (g_dwHideMessenger == BL_HIDE)
        return(NULL);

    EnterCriticalSection(&g_csMsgrList);
    if(!sg_pMsgrList)     
    {
        // this first call, create class
        sg_pMsgrList = new(CMsgrList);
        if(sg_pMsgrList)
        {
            // Init of User List
            if(sg_pMsgrList->HrInitMsgr() == S_OK)
            {
                if(sg_pMsgrList->FillList() != S_OK)
                    goto ErrEx;
            }
            else
            {
ErrEx:
                sg_pMsgrList->Release();
                g_dwHideMessenger = g_dwHideMessenger | BL_NOTINST;
            }
        }

    }
    else
        sg_pMsgrList->AddRef();

    LeaveCriticalSection(&g_csMsgrList);

    return(sg_pMsgrList);
}

// Close entrance to MsgrList
void    OE_CloseMsgrList(CMsgrList *pCMsgrList)
{
    Assert(pCMsgrList == sg_pMsgrList);

    EnterCriticalSection(&g_csMsgrList);
    sg_pMsgrList->Release();
    LeaveCriticalSection(&g_csMsgrList);
}

HRESULT OE_Msgr_Logoff(void)
{
    MSTATEOE State;
    HRESULT hr = S_OK;
    
    if(!sg_pMsgrList)
    {
        EnterCriticalSection(&g_csMsgrList);
        sg_pMsgrList = new(CMsgrList);
        LeaveCriticalSection(&g_csMsgrList);

        if(!sg_pMsgrList)
            return(E_UNEXPECTED);

        // Init of User List
        if(FAILED(hr = sg_pMsgrList->HrInitMsgr()))
            goto logoff_end;

        else if(FAILED(hr = sg_pMsgrList->GetLocalState(&State)) || State == MSTATEOE_OFFLINE)
            goto logoff_end;
        else
            hr = sg_pMsgrList->UserLogoff();

    }
    else
    {
        return(sg_pMsgrList->UserLogoff());  // we cannot delete sg_pMsgrList in this case!
    }

logoff_end:
    if(sg_pMsgrList)
    {
        OE_CloseMsgrList(sg_pMsgrList);
    }
    return(hr);
}

HRESULT InstallMessenger(HWND hWnd)
{
    HRESULT         hr  = REGDB_E_CLASSNOTREG;
	uCLSSPEC classpec;
    TCHAR szBuff[CCHMAX_STRINGRES];
		
   	classpec.tyspec=TYSPEC_CLSID;
	classpec.tagged_union.clsid = CLSID_MessengerApp;
	
  	// See below for parameter definitions and return values
	hr = FaultInIEFeature(hWnd, &classpec, NULL, FIEF_FLAG_FORCE_JITUI);

	if (hr != S_OK) {
        if(hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            AthLoadString(idsJITErrDenied, szBuff, ARRAYSIZE(szBuff));
            AthMessageBox(hWnd, MAKEINTRESOURCE(idsAthena), szBuff,
                    NULL, MB_OK | MB_ICONSTOP);
        }
        else
        {
            AthLoadString(idsBAErrJITFail, szBuff, ARRAYSIZE(szBuff));
            MenuUtil_BuildMessengerString(szBuff, ARRAYSIZE(szBuff));
            AthMessageBox(hWnd, MAKEINTRESOURCE(idsAthena), szBuff,
                    NULL, MB_OK | MB_ICONSTOP);
        }
		hr = REGDB_E_CLASSNOTREG;
	}

        return hr;
}

#ifdef NEEDED
HRESULT OE_Msgr_Logon(void)
{
    if(!sg_pMsgrList)
        return S_FALSE;
    else
        return(sg_pMsgrList->UserLogon());

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\baui.h ===
// abui.h : Declaration of the CMsgrAb
// Messanger integration to OE
// Created 04/20/98 by YST

#ifndef __BAUI_H_
#define __BAUI_H_

class CFolderBar;
class CPaneFrame;

#include "resource.h"       // main symbols
#include "shfusion.h"
#include "badata.h"
#include "bactrl.h"
#include "instance.h"
#include "ourguid.h"
#include "ddfldbar.h"
#include <wab.h>
#include <mapiguid.h>
#include "bllist.h"
#include "menures.h"
#include <wabapi.h>
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
// Bitmap Indices
//

enum {
    IMAGE_NEW_MESSAGE = 0,
    IMAGE_DISTRIBUTION_LIST,
    IMAGE_ONLINE,
    IMAGE_OFFLINE,
    IMAGE_STOPSIGN,
    IMAGE_CLOCKSIGN,
    IMAGE_CERT,
    IMAGE_EMPTY,
    ABIMAGE_MAX
};

enum {
    BASORT_STATUS_ACSEND = 0,
    BASORT_STATUS_DESCEND,
    BASORT_NAME_ACSEND,
    BASORT_NAME_DESCEND
};

HRESULT CreateMsgrAbCtrl(IMsgrAb **pMsgrAb);

typedef struct _tag_MABEntry
{
    MABENUM     tag;
    TCHAR   *   pchWABName;
    TCHAR   *   pchWABID;
    LPSBinary   lpSB;
    LPMINFO     lpMsgrInfo;
    BOOL        fCertificate;
} mabEntry;

typedef mabEntry * LPMABENTRY;


/////////////////////////////////////////////////////////////////////////////
// CMsgrAb
class ATL_NO_VTABLE CMsgrAb : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMsgrAb, &CLSID_MsgrAb>,
    public CComControl<CMsgrAb>,
    public IDispatchImpl<IMsgrAb, &IID_IMsgrAb, &LIBID_MsgrAbLib>,
    public IProvideClassInfo2Impl<&CLSID_MsgrAb, NULL, &LIBID_MsgrAbLib>,
    public IPersistStreamInitImpl<CMsgrAb>,
    public IPersistStorageImpl<CMsgrAb>,
    public IQuickActivateImpl<CMsgrAb>,
    public IOleControlImpl<CMsgrAb>,
    public IOleObjectImpl<CMsgrAb>,
    public IOleInPlaceActiveObjectImpl<CMsgrAb>,
    public IViewObjectExImpl<CMsgrAb>,
    public IOleInPlaceObjectWindowlessImpl<CMsgrAb>,
    public IDataObjectImpl<CMsgrAb>,
    public IConnectionPointContainerImpl<CMsgrAb>,
    public ISpecifyPropertyPagesImpl<CMsgrAb>,
    public IDropTarget,
    public IOleCommandTarget,
    public IFontCacheNotify,
    public IInputObject,
    public IObjectWithSite,
    public IDropDownFldrBar,
    public IMAPIAdviseSink,
    public IWABExtInit,
    public IShellPropSheetExt
{
public:
    // Declare our own window class that doesn't have the CS_HREDRAW etc set
    static CWndClassInfo& GetWndClassInfo() 
    { 
        static CWndClassInfo wc = 
        { 
            { sizeof(WNDCLASSEX), 0, StartWindowProc, 
              0, 0, 0, 0, 0, 0 /*(HBRUSH) (COLOR_DESKTOP + 1) */, 0, "Outlook Express Address Book Control", 0 }, 
              NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
        }; 
        return wc; 
    }

    CMsgrAb();
    ~CMsgrAb();

    DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CMsgrAb)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IMsgrAb)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IDropTarget)
    COM_INTERFACE_ENTRY(IInputObject)
    COM_INTERFACE_ENTRY(IOleCommandTarget)
    COM_INTERFACE_ENTRY(IFontCacheNotify)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY_IID(IID_IDropDownFldrBar, IDropDownFldrBar)
    COM_INTERFACE_ENTRY(IMAPIAdviseSink)
    COM_INTERFACE_ENTRY(IWABExtInit)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CMsgrAb)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_CONNECTION_POINT_MAP(CMsgrAb)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(CMsgrAb)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_WININICHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_FONTCHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_PALETTECHANGED, OnSysParamsChange)
    MESSAGE_HANDLER(WM_USER_STATUS_CHANGED, OnUserStateChanged)
    MESSAGE_HANDLER(WM_USER_MUSER_REMOVED, OnUserRemoved)
    MESSAGE_HANDLER(WM_USER_MUSER_ADDED, OnUserAdded)
    MESSAGE_HANDLER(WM_USER_NAME_CHANGED, OnUserNameChanged)
    MESSAGE_HANDLER(WM_MSGR_LOGOFF, OnUserLogoffEvent)
    MESSAGE_HANDLER(WM_MSGR_SHUTDOWN, OnMsgrShutDown)
    MESSAGE_HANDLER(WM_MSGR_LOGRESULT, OnUserLogResultEvent)

    COMMAND_ID_HANDLER(ID_NEW_CONTACT, CmdNewContact)
    COMMAND_ID_HANDLER(ID_NEW_ONLINE_CONTACT, CmdNewOnlineContact)
    COMMAND_ID_HANDLER(ID_SET_ONLINE_CONTACT, CmdSetOnline)
//    COMMAND_ID_HANDLER(ID_NEW_MSG_DEFAULT, CmdNewMessage)
    COMMAND_ID_HANDLER(ID_PROPERTIES, CmdProperties)
    COMMAND_ID_HANDLER(ID_DELETE_CONTACT, CmdDelete)
    COMMAND_ID_HANDLER(ID_FIND_PEOPLE, CmdFind)
    COMMAND_ID_HANDLER(ID_ADDRESS_BOOK, CmdMsgrAb)
    COMMAND_ID_HANDLER(ID_NEW_GROUP, CmdNewGroup)
    COMMAND_ID_HANDLER(ID_SEND_INSTANT_MESSAGE, CmdNewIMsg)
    COMMAND_ID_HANDLER(ID_SEND_INSTANT_MESSAGE2, CmdNewMessage)
    COMMAND_ID_HANDLER(ID_SEND_MESSAGE, CmdNewEmaile)
    COMMAND_ID_HANDLER(ID_NEW_MSG_DEFAULT, CmdNewEmaile)

    NOTIFY_CODE_HANDLER(LVN_GETINFOTIP, NotifyGetInfoTip)
    NOTIFY_CODE_HANDLER(LVN_DELETEITEM, NotifyDeleteItem)
    NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, NotifyItemChanged)
    NOTIFY_CODE_HANDLER(LVN_ITEMACTIVATE, NotifyItemActivate)
    NOTIFY_CODE_HANDLER(LVN_GETDISPINFO, NotifyGetDisplayInfo)
    NOTIFY_CODE_HANDLER(NM_SETFOCUS, NotifySetFocus)

ALT_MSG_MAP(1)
#ifdef OLDTOOLTIPS
    MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST,  WM_MOUSELAST, OnListMouseEvent)
    MESSAGE_HANDLER(WM_MOUSEMOVE,           OnListMouseMove)
    MESSAGE_HANDLER(WM_MOUSELEAVE,          OnListMouseLeave)
#endif // OLDTOOLTIPS
ALT_MSG_MAP(2)

END_MSG_MAP()

// CComControlBase
    HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
    {
		return Create(hWndParent, rcPos, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 
                      WS_EX_CONTROLPARENT);
    }

// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

// IQuickActivate
    STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
    {
        // $REVIEW - Someone updated the size of QACONTAINER to add two
        //           new members, pOleControlSite and pServiceProvider.
        //           This causes ATL to assert in a big way, but to 
        //           avoid the assert we tweek the structure size.  This
        //           is a bad thing. -- steveser
        pQACont->cbSize = sizeof(QACONTAINER);
        return (IQuickActivateImpl<CMsgrAb>::QuickActivate(pQACont, pQACtrl));
    }

// IOleInPlaceActiveObjectImpl
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg)
    {
        if (lpmsg->message == WM_CHAR && lpmsg->wParam == VK_DELETE)
        {
            PostMessage(WM_COMMAND, ID_DELETE, 0);
            return (S_OK);
        }

        return (S_FALSE);
    }


// IMsgrAb
public:
    STDMETHOD(get_InstMsg)(/*[out, retval]*/ BOOL *pVal);
//	STDMETHOD(put_InstMsg)(/*[in]*/ BOOL newVal);
    HRESULT OnDraw(ATL_DRAWINFO& di);

// IDropTarget
    STDMETHOD(DragEnter)(THIS_ IDataObject *pDataObject, DWORD grfKeyState,
                         POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(THIS_ DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(THIS);
    STDMETHOD(Drop)(THIS_ IDataObject *pDataObject, DWORD grfKeyState,
                    POINTL pt, DWORD *pdwEffect);

//IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID    *pguidCmdGroup, 
                                          ULONG         cCmds, 
                                          OLECMD        rgCmds[], 
                                          OLECMDTEXT    *pCmdText);
    HRESULT STDMETHODCALLTYPE Exec(const GUID   *pguidCmdGroup, 
                                    DWORD       nCmdID, 
                                    DWORD       nCmdExecOpt, 
                                    VARIANTARG  *pvaIn, 
                                    VARIANTARG  *pvaOut);


// IInputObject
    STDMETHOD(HasFocusIO)(THIS);
    STDMETHOD(TranslateAcceleratorIO)(THIS_ LPMSG lpMsg);
    STDMETHOD(UIActivateIO)(THIS_ BOOL fActivate, LPMSG lpMsg);

/////////////////////////////////////////////////////////////////////////
// IFontCacheNotify
//
	STDMETHOD(OnPreFontChange)(void);
	STDMETHOD(OnPostFontChange)(void);

//IObjectWithSite
    STDMETHOD(SetSite)(IUnknown  *punksite);
    STDMETHOD(GetSite)(REFIID  riid, LPVOID *ppvSite);

//IDropDownFolderBar
    HRESULT RegisterFlyOut(CFolderBar *pFolderBar);
    HRESULT RevokeFlyOut();

// IMAPIAdviseSink
    STDMETHOD_(ULONG, OnNotify)(ULONG cNotif, LPNOTIFICATION pNotifications);

// IShellPropSheetExt interface
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IWABExtInit interface
    STDMETHOD(Initialize)(LPWABEXTDISPLAY lpWED);


    // STDMETHOD (EventUserStateChanged)(THIS_ IMsgrUserOE * pUser);

    LPMABENTRY AddBlabEntry(MABENUM tag, LPSBinary lpSB, LPMINFO lpMsgrInfo = NULL, TCHAR *pchMail = NULL, TCHAR *pchDisplayName = NULL, BOOL fCert = FALSE);
    void CheckAndAddAbEntry(LPSBinary lpSB, TCHAR *pchEmail, TCHAR *pchDisplayName, DWORD nFlag);

// Message Handlers
private:
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT  nMsg , WPARAM  wParam , LPARAM  lParam , BOOL&  bHandled );
    LRESULT OnSysParamsChange(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
    {
        m_ctlList.SendMessage(nMsg, wParam, lParam);

        return 0;
    }
    HRESULT OnMsgrShutDown(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserRemoved(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserLogoffEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserLogResultEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserAdded(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserNameChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);

    LRESULT CmdNewContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewOnlineContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewGroup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdMsgrAb(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewEmaile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewIMsg(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdSetOnline(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//    LRESULT CmdMsgrOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT NotifyGetInfoTip(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyItemActivate(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyGetDisplayInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
//     LRESULT NotifyColumnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifySetFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NewInstantMessage(LPMABENTRY pEntry);
    HRESULT OnListMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT OnListMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT OnListMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
// Utility Functions
    HRESULT _ResizeElements(LPCRECT prcPos = NULL, LPCRECT prcClip = NULL);
    void    _AutosizeColumns(void);
    void    _EnableCommands(void);
    HRESULT _DoDropMessage(LPMIMEMESSAGE pMessage);
    HRESULT _DoDropMenu(POINTL pt, LPMIMEMESSAGE pMessage);
    void    _ReloadListview(void);
    LRESULT SetUserIcon(LPMABENTRY pEntry, int nStatus, int * pImage);
    void AddMsgrListItem(LPMINFO lpMsgrInfo);
    HRESULT FillMsgrList();
    void RemoveBlabEntry(LPMABENTRY lpEntry);
    LPMABENTRY FindUserEmail(TCHAR *pchEmail, int *pIndex = NULL, BOOL fMsgrOnly = TRUE);
    BOOL    _UpdateViewTip(int x, int y);
    BOOL    _IsItemTruncated(int iItem, int iSubItem);
    LPMABENTRY GetSelectedEntry(void);
    LPMABENTRY GetEntryForSendInstMsg(LPMABENTRY pEntry = NULL);
    HRESULT PromptToGoOnline(void);
    void RemoveMsgrInfo(LPMINFO lpMsgrInfo);

// Member Data
private:
    // Address Book Object
    CAddressBookData  m_cAddrBook;

    // Child windows
    CContainedWindow m_ctlList;         // Displays the list of people

    // Trucated listview items Tooltips
    CContainedWindow        m_ctlViewTip;
    BOOL                    m_fViewTip;
    BOOL                    m_fViewTipVisible;
    BOOL                    m_fTrackSet;
    int                     m_iItemTip;
    int                     m_iSubItemTip;
    HIMAGELIST              m_himl;
    DWORD                   m_dwFontCacheCookie;        // For the Advise on the font cache
    POINT                   m_ptToolTip;
    CEmptyList              m_cEmptyList;
    TCHAR *                 m_szOnline;
    // TCHAR *                 m_szInvisible;
    TCHAR *                 m_szBusy;
    TCHAR *                 m_szBack;
    TCHAR *                 m_szAway;
    TCHAR *                 m_szOnPhone;
    TCHAR *                 m_szLunch;
    TCHAR *                 m_szOffline;
    TCHAR *                 m_szIdle;
    TCHAR *                 m_szEmptyList;
    BOOL                    m_fNoRemove;
    int                     m_delItem;

    // Drag & Drop stuff
    IDataObject     *m_pDataObject;
    CLIPFORMAT       m_cf;
    BOOL             m_fRight;
    BOOL             m_fLogged;

    // Properties
    //Site ptr
    IInputObjectSite *m_pObjSite;

    HWND             m_hwndParent;
    CFolderBar       *m_pFolderBar;

    int m_nSortType;
    CMsgrList *m_pCMsgrList;        // pointer to OE Msgr

    int             m_nChCount;

    // WAB extension
    UINT            m_cRefThisDll;     // Reference count for this DLL
    HPROPSHEETPAGE  m_hPage1; // Handle to the property sheet page

    LPWABEXTDISPLAY m_lpWED;

    LPWABEXTDISPLAY m_lpWEDContext;
    LPMAPIPROP      m_lpPropObj; // For context menu extensions, hang onto the prop obj

};

int CALLBACK BA_Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
INT_PTR CALLBACK WabExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#endif //__BAUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\mdispid.h ===
#ifndef _MDISPID_H_
#define _MDISPID_H_

//
// Dispatch IDs for DMsgrObjectEvents Dispatch Events.
//
#define DISPID_ONLOGONRESULT                  100
#define DISPID_ONLOGOFF                       101
#define DISPID_ONLISTADDRESULT                102
#define DISPID_ONLISTREMOVERESULT             103
#define DISPID_ONMESSAGEPRIVACYCHANGERESULT   104
#define DISPID_ONPROMPTCHANGERESULT           105
#define DISPID_ONUSERFRIENDLYNAMECHANGERESULT 106
#define DISPID_ONUSERSTATECHANGED             107
#define DISPID_ONTEXTRECEIVED                 108
#define DISPID_ONLOCALFRIENDLYNAMECHANGERESULT 109
#define DISPID_ONLOCALSTATECHANGERESULT       110
#define DISPID_ONAPPINVITERECEIVED            111
#define DISPID_ONAPPINVITEACCEPTED            112
#define DISPID_ONAPPINVITECANCELLED           113
#define DISPID_ONSENDRESULT                   114
#define DISPID_ONNEWERCLIENTAVAILABLE         115
#define DISPID_ONFINDRESULT                   116
#define DISPID_ONINVITEMAILRESULT             117
#define DISPID_ONREQUESTURLRESULT             118
#define DISPID_ONSESSIONSTATECHANGE           119
#define DISPID_ONUSERJOIN                     120
#define DISPID_ONUSERLEAVE                    121
#define DISPID_ONNEWSESSIONREQUEST            122
#define DISPID_ONINVITEUSER                   123
#define DISPID_ONSERVICELOGOFF                124
#define DISPID_ONPRIMARYSERVICECHANGED        125
#define DISPID_ONAPPSHUTDOWN                  126
#define DISPID_ONUNREADEMAILCHANGED           127
#define DISPID_ONUSERDROPPED                  128
#define DISPID_ONREQUESTURLPOSTRESULT         129
#define DISPID_ONNEWERSITESAVAILABLE          130
#define DISPID_ONTRUSTCHANGED                 131
#define DISPID_ONFILETRANSFERINVITERECEIVED   132
#define DISPID_ONFILETRANSFERINVITEACCEPTED   133
#define DISPID_ONFILETRANSFERINVITECANCELLED  134
#define DISPID_ONFILETRANSFERCANCELLED        135
#define DISPID_ONFILETRANSFERSTATUSCHANGE     136
#define DISPID_ONSPMESSAGERECEIVED            137
#define DISPID_ONLOCALPROPERTYCHANGERESULT    141
#define DISPID_ONBUDDYPROPERTYCHANGERESULT    142
#define DISPID_ONNOTIFICATIONRECEIVED         143
	
//
// Dispatch IDs for DMessengerAppEvents Dispatch Events.
// (don't overlap DMsgrObjectEvents ids)
//
#define DISPID_ONBEFORELAUNCHIMUI           20000
#define DISPID_ONSHOWIMUI		            20001
#define DISPID_ONDESTROYIMUI                20002
#define DISPID_ONINDICATEMESSAGERECEIVED	20003
#define DISPID_ONSTATUSTEXT					20004
#define DISPID_ONTITLEBARTEXT				20005
#define DISPID_ONINFOBARTEXT				20006
#define DISPID_ONSENDENABLED				20007
#define DISPID_ONTRANSLATEACCELERATOR		20008
#define DISPID_ONFILETRANSFER				20009
#define DISPID_ONVOICESESSIONSTATE			20010
#define DISPID_ONVOICEVOLUMECHANGED		    20011
#define DISPID_ONMICROPHONEMUTE			    20012

//
// Dispatch IDs for IMsgrObject.
//
#define DISPID_CREATEUSER                     100
#define DISPID_LOGON                          104
#define DISPID_LOGOFF                         105
#define DISPID_GETLIST                        0x60020003
#define DISPID_LOCALLOGONNAME                 0x60020004
#define DISPID_LOCALFRIENDLYNAME              0x60020005
#define DISPID_LOCALSTATE                     0x60020006
#define DISPID_MESSAGEPRIVACY                 0x60020008
#define DISPID_PROMPT                         0x6002000a
#define DISPID_SENDAPPINVITE                  108
#define DISPID_SENDAPPINVITEACCEPT            109
#define DISPID_SENDAPPINVITECANCEL            110
#define DISPID_LOCALOPTION                    0x6002000f
#define DISPID_FINDUSER                       111
#define DISPID_SENDINVITEMAIL                 112
#define DISPID_REQUESTURL                     113
#define DISPID_IMSESSIONS                     0x60020014
#define DISPID_CREATEIMSESSIONS               114
#define DISPID_SESSIONREQUESTACCEPT           115
#define DISPID_SESSIONREQUESTCANCEL           116
#define DISPID_SERVICES                       0x60020018
#define DISPID_UNREADEMAIL                    0x60020019
#define DISPID_SENDFILETRANSFERINVITE         117
#define DISPID_SENDFILETRANSFERINVITEACCEPT   118
#define DISPID_SENDFILETRANSFERINVITECANCEL   119
#define DISPID_CANCELFILETRANSFER             120
#define DISPID_FILETRANSFERSTATUS             121


//
// Dispatch IDs for IMessengerApp.
//
#define DISPID_APPLICATION                    0x60020000
#define DISPID_PARENT                         0x60020001
#define DISPID_QUIT                           100
#define DISPID_NAME                           0x60020003
#define DISPID_FULLNAME                       0x60020004
#define DISPID_PATH                           0x60020005
#define DISPID_LAUNCHLOGONUI                  200
#define DISPID_LAUNCHOPTIONSUI                201
#define DISPID_LAUNCHADDCONTACTUI             202
#define DISPID_LAUNCHFINDCONTACTUI            203
#define DISPID_LAUNCHIMUI                     210
#define DISPID_IMWINDOWS                      0x6002000b
#define DISPID_TOOLBAR                        0x6002000c
#define DISPID_STATUSBAR                      0x6002000e
#define DISPID_STATUSTEXT                     0x60020010
#define DISPID_GETHWND                        0x60020012
#define DISPID_LEFT                           0x60020013
#define DISPID_TOP                            0x60020015
#define DISPID_WIDTH                          0x60020017
#define DISPID_HEIGHT                         0x60020019
#define DISPID_MSGS_VISIBLE                   0x6002001b
#define DISPID_AUTOLOGON                      222
#define DISPID_FIRSTTIMECREDENTIONS           0x6002001e
#define DISPID_CACHEDPASSWORD                 0x6002001f
#define DISPID_REQUESTURLPOST                 223
#define DISPID_MSGS_TASKBARICON               224

//
// Dispatch IDs for IMsgrUser.
//
#define DISPID_USERFRIENDLYNAME               0x60020000
#define DISPID_USEREMAILADDRESS               0x60020002
#define DISPID_USERSTATE                      0x60020003
#define DISPID_USERLOGONNAME                  0x60020004
#define DISPID_USERSENDTEXT                   101
#define DISPID_USERSERVICE                    0x60020006

//
// Dispatch IDs for IMsgrUsers.
//
#define DISPID_USERSCOUNT                     0x60020000
#define DISPID_USERSADD                       100
#define DISPID_USERSREMOVE                    101

//
// Dispatch IDs for IMsgrService.
//
#define DISPID_SERVICESERVICENAME             0x60020000
#define DISPID_SERVICELOGONNAME               0x60020001
#define DISPID_SERVICEFRIENDLYNAME            0x60020002
#define DISPID_SERVICECAPABILITIES            0x60020004
#define DISPID_SERVICESTATUS                  0x60020005
#define DISPID_SERVICELOGOFF                  0x60020006
#define DISPID_SERVICEFINDUSER                0x60020007
#define DISPID_SERVICESENDINVITEMAIL          0x60020008
#define DISPID_SERVICEREQUESTURL              0x60020009
#define DISPID_SERVICEPROFILEFIELD            0x6002000a

//
// Dispatch IDs for IMsgrServices.
//
#define DISPID_SERVICESPRIMARYSERVICE         0x60020000
#define DISPID_SERVICESCOUNT                  0x60020002

#endif // ! _MDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\baui.cpp ===
// baui.cpp : Implementation of CMsgrAb
// Messenger integration to OE
// Created 04/20/98 by YST

#include "pch.hxx"
#include "bactrl.h"
#include "baprop.h"
#include "baui.h"
#include "mimeutil.h"
#include "menuutil.h"
#include "fldbar.h"
#include "bllist.h"
#include "inpobj.h"
#include "note.h"
#include "dllmain.h"
#include <wabapi.h>
#include "shlwapip.h"
#include "statnery.h"
#include "secutil.h"
#include "util.h"

// Load resource string once
#define RESSTRMAX   64

static const int BA_SortOrder[] =
{
    MSTATEOE_ONLINE,
    MSTATEOE_BE_RIGHT_BACK,
    MSTATEOE_OUT_TO_LUNCH,
    MSTATEOE_IDLE,
    MSTATEOE_AWAY,
    MSTATEOE_ON_THE_PHONE,
    MSTATEOE_BUSY,
    MSTATEOE_INVISIBLE,
    MSTATEOE_OFFLINE,
    MSTATEOE_UNKNOWN
};


static CAddressBookData  * st_pAddrBook = NULL;

// {BA9EE970-87A0-11d1-9ACF-00A0C91F9C8B}
// IMPLEMENT_OLECREATE(CMfcExt, "WABSamplePropExtSheet", 0xba9ee970, 0x87a0, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);

HRESULT CreateMsgrAbCtrl(IMsgrAb **ppMsgrAb)
{
    HRESULT         hr;
    IUnknown         *pUnknown;

    TraceCall("CreateMessageList");

    // Get the class factory for the MessageList object
    IClassFactory *pFactory = NULL;
    hr = _Module.GetClassObject(CLSID_MsgrAb, IID_IClassFactory,
                                (LPVOID *) &pFactory);

    // If we got the factory, then get an object pointer from it
    if (SUCCEEDED(hr))
    {
        hr = pFactory->CreateInstance(NULL, IID_IUnknown,
                                      (LPVOID *) &pUnknown);
        if (SUCCEEDED(hr))
        {
            hr = pUnknown->QueryInterface(IID_IMsgrAb, (LPVOID *) ppMsgrAb);
            pUnknown->Release();
        }
        pFactory->Release();
    }

    return (hr);
}

/////////////////////////////////////////////////////////////////////////////
// CMsgrAb
CMsgrAb::CMsgrAb():m_ctlList(_T("SysListView32"), this, 1),
               m_ctlViewTip(TOOLTIPS_CLASS, this, 2)
{
    m_bWindowOnly = TRUE;

    m_pDataObject = 0;
    m_cf = 0;

    m_pObjSite      = NULL;
    m_hwndParent    = NULL;
    m_pFolderBar    = NULL;
    m_nSortType = (int) DwGetOption(OPT_BASORT);
    m_pCMsgrList = NULL;

    m_fViewTip = TRUE;
    m_fViewTipVisible = FALSE;
    m_fTrackSet = FALSE;
    m_iItemTip = -1;
    m_iSubItemTip = -1;
    m_himl = NULL;

    m_ptToolTip.x = -1;
    m_ptToolTip.y = -1;
    m_fLogged = FALSE;
    m_dwFontCacheCookie = 0;
    m_nChCount = 0;

    m_lpWED = NULL;
    m_lpWEDContext = NULL;
    m_lpPropObj = NULL;

    m_szOnline = NULL;
    // m_szInvisible = NULL;
    m_szBusy = NULL;
    m_szBack = NULL;
    m_szAway = NULL;
    m_szOnPhone = NULL;
    m_szLunch = NULL;
    m_szOffline = NULL;
    m_szIdle = NULL;
    m_szEmptyList = NULL;
    m_fNoRemove = FALSE;
    m_delItem = 0;

    // Initialize the applicaiton
    g_pInstance->DllAddRef();

    // Raid-32933: OE: MSIMN.EXE doesn't always exit
    // g_pInstance->CoIncrementInit();
}

CMsgrAb::~CMsgrAb()
{
    // unregister from Msgr list
    if(m_pCMsgrList)
    {
        m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
        OE_CloseMsgrList(m_pCMsgrList);
    }

    SafeRelease(m_pObjSite);

    SafeMemFree(m_szOnline);
    // SafeMemFree(m_szInvisible);
    SafeMemFree(m_szBusy);
    SafeMemFree(m_szBack);
    SafeMemFree(m_szAway);
    SafeMemFree(m_szOnPhone);
    SafeMemFree(m_szLunch);
    SafeMemFree(m_szOffline);
    SafeMemFree(m_szIdle);
    SafeMemFree(m_szEmptyList);

    // Raid-32933: OE: MSIMN.EXE doesn't always exit
    // g_pInstance->CoDecrementInit();
    g_pInstance->DllRelease();
}

LRESULT CMsgrAb::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SetDwOption(OPT_BASORT, m_nSortType, 0, 0);
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);

    if (IsWindow(m_ctlViewTip))
    {
        m_ctlViewTip.SendMessage(TTM_POP, 0, 0);
        m_ctlViewTip.DestroyWindow();
    }

    if (m_dwFontCacheCookie && g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Unadvise(m_dwFontCacheCookie);
            pConnection->Release();
        }
    }

    m_cAddrBook.Unadvise();
    RevokeDragDrop(m_hWnd);

    if (m_himl != NULL)
        ImageList_Destroy(m_himl);
    return 0;
}

HRESULT CMsgrAb::OnDraw(ATL_DRAWINFO& di)
{
    RECT&   rc = *(RECT*)di.prcBounds;

#if 0
    int     patGray[4];
    HBITMAP hbm;
    HBRUSH  hbr;
    COLORREF cFg;
    COLORREF cBkg;

    // Initialize the pattern
    patGray[0] = 0x005500AA;
    patGray[1] = 0x005500AA;
    patGray[2] = 0x005500AA;
    patGray[3] = 0x005500AA;

    // Create a bitmap from the pattern
    hbm = CreateBitmap(8, 8, 1, 1, (LPSTR)patGray);

    if ((HBITMAP) NULL != hbm)
    {
        hbr = CreatePatternBrush(hbm);
        if (hbr)
        {
            // Select the right colors into the DC
            cFg = SetTextColor(di.hdcDraw, GetSysColor(COLOR_3DFACE));
            cBkg = SetBkColor(di.hdcDraw, RGB(255, 255, 255));

            // Fill the rectangle
            FillRect(di.hdcDraw, &rc, hbr);

            SetTextColor(di.hdcDraw, cFg);
            SetBkColor(di.hdcDraw, cBkg);

            DeleteObject(hbr);
        }

        DeleteObject(hbm);
    }
#endif

    // Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    return S_OK;
}

LRESULT CMsgrAb::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Define a bogus rectangle for the controls.  They will get resized in
    // our size handler.
    RECT rcPos = {0, 0, 100, 100};
    TCHAR        sz[CCHMAX_STRINGRES];

    // Create the various controls
    m_ctlList.Create(m_hWnd, rcPos, _T("Outlook Express Address Book ListView"),
                     WS_TABSTOP | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN |
                     LVS_REPORT | LVS_NOCOLUMNHEADER | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS /* | LVS_SORTASCENDING*/, 0);

    ListView_SetExtendedListViewStyleEx(m_ctlList, LVS_EX_INFOTIP | LVS_EX_LABELTIP, LVS_EX_INFOTIP | LVS_EX_LABELTIP);

    // Image List
    Assert(m_himl == NULL);
    m_himl = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbAddrBookHot), 16, 0,
                               RGB(255, 0, 255), IMAGE_BITMAP,
                               LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);

    ListView_SetImageList(m_ctlList, m_himl, LVSIL_SMALL);

    LVCOLUMN lvc;

    lvc.mask = LVCF_SUBITEM;
    lvc.iSubItem = 0;

    ListView_InsertColumn(m_ctlList, 0, &lvc);

    m_ctlList.SendMessage(WM_SETFONT, NULL, 0);
    SetListViewFont(m_ctlList, GetListViewCharset(), TRUE);

    if (g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Advise((IUnknown *)(IFontCacheNotify *) this, &m_dwFontCacheCookie);
            pConnection->Release();
        }
    }

    // Msgr Initialization
    m_pCMsgrList = OE_OpenMsgrList();
    // Register our control for Msgr list
    if(m_pCMsgrList)
    {
        m_pCMsgrList->RegisterUIWnd(m_hWnd);
        if(m_pCMsgrList->IsLocalOnline())
        {
            m_fLogged = TRUE;
            FillMsgrList();
        }
    }

    // Initialize the address book object too
    HRESULT hr = m_cAddrBook.OpenWabFile();
    if(hr == S_OK)
        m_cAddrBook.LoadWabContents(m_ctlList, this);

    st_pAddrBook = &m_cAddrBook;

    // Sort and Select the first item
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    ListView_SetItemState(m_ctlList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

    // Add the tooltip
    // Load Tooltip strings

    if(AthLoadString(idsBAOnline, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szOnline, lstrlen(sz) + 1))
            StrCpyN(m_szOnline, sz, lstrlen(sz) + 1);
    }

    /* if(AthLoadString(idsBAInvisible, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szInvisible, lstrlen(sz) + 1))
            StrCpyN(m_szInvisible, sz, lstrlen(sz) + 1);
    }*/

    if(AthLoadString(idsBABusy, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szBusy, lstrlen(sz) + 1))
            StrCpyN(m_szBusy, sz, lstrlen(sz) + 1);
    }

    if(AthLoadString(idsBABack, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szBack, lstrlen(sz) + 1))
            StrCpyN(m_szBack, sz, lstrlen(sz) + 1);
    }

    if(AthLoadString(idsBAAway, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szAway, lstrlen(sz) + 1))
            StrCpyN(m_szAway, sz, lstrlen(sz) + 1);
    }

    if(AthLoadString(idsBAOnPhone, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szOnPhone, lstrlen(sz) + 1))
            StrCpyN(m_szOnPhone, sz, lstrlen(sz) + 1);
    }

    if(AthLoadString(idsBALunch, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szLunch, lstrlen(sz) + 1))
            StrCpyN(m_szLunch, sz, lstrlen(sz) + 1);
    }

    if(AthLoadString(idsBAOffline, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szOffline, lstrlen(sz) + 1))
            StrCpyN(m_szOffline, sz,lstrlen(sz) + 1);
    }

    if(AthLoadString(idsBAIdle, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szIdle, lstrlen(sz) + 1))
            StrCpyN(m_szIdle, sz, lstrlen(sz) + 1);
    }

    if(AthLoadString(idsMsgrEmptyList, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szEmptyList, lstrlen(sz) + 1))
            StrCpyN(m_szEmptyList, sz, lstrlen(sz) + 1);
    }

    // Create the ListView tooltip
    if (m_fViewTip)
    {
        TOOLINFO ti = {0};
        m_ctlViewTip.Create(m_hWnd, rcPos, NULL, TTS_NOPREFIX);

        // Add the tool
        ti.cbSize   = sizeof(TOOLINFO);
        ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
        ti.hwnd     = m_hWnd;
        ti.uId      = (UINT_PTR)(HWND) m_ctlList;
        ti.lpszText = _TEXT(""); // LPSTR_TEXTCALLBACK;
        ti.lParam   = 0;

        m_ctlViewTip.SendMessage(TTM_ADDTOOL, 0, (LPARAM) &ti);
        m_ctlViewTip.SendMessage(TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM) 500);

        // m_ctlViewTip.SendMessage(TTM_SETTIPBKCOLOR, GetSysColor(COLOR_WINDOW), 0);
        // m_ctlViewTip.SendMessage(TTM_SETTIPTEXTCOLOR, GetSysColor(COLOR_WINDOWTEXT), 0);
    }

    m_ctlList.SetFocus();

    // Register ourselves as a drop target
    RegisterDragDrop(m_hWnd, (IDropTarget *) this);

    // Update the size of the listview columns
    _AutosizeColumns();

    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);

    // Finished
    return (0);
}

LRESULT CMsgrAb::OnSetFocus(UINT  nMsg , WPARAM  wParam , LPARAM  lParam , BOOL&  bHandled )
{
    CComControlBase::OnSetFocus(nMsg, wParam, lParam, bHandled);
    m_ctlList.SetFocus();
    if (m_pObjSite)
    {
        m_pObjSite->OnFocusChangeIS((IInputObject*) this, TRUE);
    }
    return 0;
}

LRESULT CMsgrAb::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    RECT rc;
    DWORD width = LOWORD(lParam);
    DWORD height = HIWORD(lParam);

    // Position the listview to fill the entire area
    RECT rcList;
    rcList.left   = 0;
    rcList.top    = 0;
    rcList.right  = width;
    rcList.bottom = height;

    m_ctlList.SetWindowPos(NULL, &rcList, SWP_NOACTIVATE | SWP_NOZORDER);

    // Update the size of the listview columns
    _AutosizeColumns();

    return (0);
}


void CMsgrAb::_AutosizeColumns(void)
{
    RECT rcList;
    m_ctlList.GetClientRect(&rcList);
    ListView_SetColumnWidth(m_ctlList, 0, rcList.right - 5);
}


//
//  FUNCTION:   CMessageList::OnPreFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache before it changes the fonts we're
//              using.  In response we tell the ListView to dump any custom
//              font's it's using.
//
STDMETHODIMP CMsgrAb::OnPreFontChange(void)
{
    m_ctlList.SendMessage(WM_SETFONT, 0, 0);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::OnPostFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache after it updates the font's we're
//              using.  In response, we set the new font for the current charset.
//
STDMETHODIMP CMsgrAb::OnPostFontChange(void)
{
    SetListViewFont(m_ctlList, GetListViewCharset(), TRUE);
    return (S_OK);
}

LRESULT CMsgrAb::CmdSetOnline(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if(g_dwHideMessenger == BL_NOTINST)
        return(InstallMessenger(m_hWnd));

    LPMABENTRY pEntry = GetSelectedEntry();

    if(!pEntry || (pEntry->tag == LPARAM_MENTRY) || !m_pCMsgrList)
        return S_FALSE;

    // m_cAddrBook.SetDefaultMsgrID(pEntry->lpSB, pEntry->pchWABID);
    if(PromptToGoOnline() == S_OK)
        m_pCMsgrList->AddUser(pEntry->pchWABID);

    return S_OK;
}

LRESULT CMsgrAb::CmdNewOnlineContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if(g_dwHideMessenger == BL_NOTINST)
        return(InstallMessenger(m_hWnd));

    else if(m_pCMsgrList)
    {
        if(PromptToGoOnline() == S_OK)
            m_pCMsgrList->NewOnlineContact();
    }

    return S_OK;
}

LRESULT CMsgrAb::CmdNewContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Tell the WAB to bring up it's new contact UI
    m_cAddrBook.NewContact(m_hWnd);
    return (0);
}

LRESULT CMsgrAb::NewInstantMessage(LPMABENTRY pEntry)
{
    if(((INT_PTR)  pEntry) == -1)
        return(m_pCMsgrList->SendInstMessage(NULL));
    else if(m_pCMsgrList)
    {
        if(PromptToGoOnline() == S_OK)
            return(m_pCMsgrList->SendInstMessage(pEntry->lpMsgrInfo->pchID));
    }

    return(S_OK);
}

LRESULT CMsgrAb::CmdNewEmaile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMIMEMESSAGE           pMessage = 0;
    LVITEM                  lvi;
    LPMIMEADDRESSTABLEW     pAddrTableW = NULL;
    LPMIMEADDRESSTABLE      pAddrTableA = NULL;
    LPMABENTRY              pEntry;
    BOOL                    fModal;
    BOOL                    fMail;
    FOLDERID                folderID;
    IUnknown                *pUnkPump;
    INIT_MSGSITE_STRUCT     initStruct = {0};
    DWORD                   dwCreateFlags = 0;

    // Create a new message
    if (FAILED(HrCreateMessage(&pMessage)))
        return (0);

    // Get the address table from the message
    if (FAILED(pMessage->GetAddressTable(&pAddrTableA)))
        goto exit;

    if (FAILED(pAddrTableA->QueryInterface(IID_IMimeAddressTableW, (LPVOID*)&pAddrTableW)))
        goto exit;

    // Loop through the selected items
    lvi.mask = LVIF_PARAM;
    lvi.iItem = -1;
    lvi.iSubItem = 0;

    while (-1 != (lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVIS_SELECTED)))
    {
        // We need to get the entry ID from the item
        ListView_GetItem(m_ctlList, &lvi);

        // Tell the data source to add this person to the message
        pEntry = (LPMABENTRY) lvi.lParam;
        Assert(pEntry);

        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY)
            m_cAddrBook.AddRecipient(pAddrTableW, pEntry->lpSB, FALSE);
        else if(pEntry->tag == LPARAM_ABGRPENTRY)
            m_cAddrBook.AddRecipient(pAddrTableW, pEntry->lpSB, TRUE);
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            Assert(pEntry->lpMsgrInfo);
            pAddrTableA->Append(IAT_TO, IET_DECODED, pEntry->lpMsgrInfo->pchID, NULL , NULL);
        }
        else
            Assert(FALSE);
    }

    fModal      = FALSE;
    fMail       = TRUE;
    folderID    = FOLDERID_INVALID;
    pUnkPump    = NULL;

    if (DwGetOption(OPT_MAIL_USESTATIONERY))
    {
        WCHAR   wszFile[MAX_PATH];
        *wszFile = 0;

        if (SUCCEEDED(GetDefaultStationeryName(TRUE, wszFile)) &&
            SUCCEEDED(HrNewStationery(m_hwndParent, 0, wszFile, fModal, fMail, folderID,
                                       FALSE, NSS_DEFAULT, pUnkPump, pMessage)))
        {
            goto exit;
        }
    }

    // If HrNewStationery fails, go ahead and try opening a blank note without stationery.

     initStruct.dwInitType  = OEMSIT_MSG;
     initStruct.folderID    = FOLDERID_INVALID;
     initStruct.pMsg        = pMessage;

     CreateAndShowNote(OENA_COMPOSE, dwCreateFlags, &initStruct, m_hwndParent, pUnkPump);

exit:
    ReleaseObj(pMessage);
    ReleaseObj(pAddrTableA);
    ReleaseObj(pAddrTableW);
    return (0);

}

LRESULT CMsgrAb::CmdNewIMsg(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(CmdNewMessage(wNotifyCode, ID_SEND_INSTANT_MESSAGE, hWndCtl, bHandled));
}

LRESULT CMsgrAb::CmdNewMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LVITEM                  lvi;
    LPMABENTRY             pEntry;

    pEntry = GetEntryForSendInstMsg();

    if(wID == ID_SEND_INSTANT_MESSAGE)
    {
        if(g_dwHideMessenger == BL_NOTINST)
            return(InstallMessenger(m_hWnd));

        if(pEntry)
            return(NewInstantMessage(pEntry));
        else
        {
            Assert(FALSE);
            return(-1);
        }
    }
    else if((((INT_PTR) pEntry) != -1) && pEntry)
        return(NewInstantMessage(pEntry));
    else
        return(CmdNewEmaile(wNotifyCode, wID, hWndCtl, bHandled));
}

LRESULT CMsgrAb::NotifyDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NMLISTVIEW *pnmlv = (NMLISTVIEW *) pnmh;
    LVITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = pnmlv->iItem;
    lvi.iSubItem = 0;

    ListView_GetItem(m_ctlList, &lvi);
    LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

    if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
        m_cAddrBook.FreeListViewItem(pEntry->lpSB);
    RemoveBlabEntry(pEntry);
    if(m_delItem > 0)
        m_delItem--;
    else
        Assert(FALSE);
    return (0);
}


LRESULT CMsgrAb::NotifyItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    ULONG       uChanged;
    NMLISTVIEW *pnmlv = (NMLISTVIEW *) pnmh;

    if (pnmlv->uChanged & LVIF_STATE)
    {
        uChanged = pnmlv->uNewState ^ pnmlv->uOldState;
        if (uChanged & LVIS_SELECTED)
            _EnableCommands();
    }

    return (0);
}

// Sort compare
int CALLBACK BA_Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LPMABENTRY pEntry1 = (LPMABENTRY) lParam1;
    LPMABENTRY pEntry2 = (LPMABENTRY) lParam2;

    TCHAR pchName1[MAXNAME];
    TCHAR pchName2[MAXNAME];

    int nIndex1 = 0;
    int nIndex2 = 0 ;

    if(!(pEntry1->lpMsgrInfo))
    {
        nIndex1 = sizeof(BA_SortOrder)/sizeof(int);
        if(pEntry1->tag == LPARAM_ABGRPENTRY)
            nIndex1++;
    }
    else
    {
        while((pEntry1->lpMsgrInfo) && (BA_SortOrder[nIndex1] != pEntry1->lpMsgrInfo->nStatus) && (BA_SortOrder[nIndex1] != MSTATEOE_UNKNOWN))
            nIndex1++;
    }

    if(!(pEntry2->lpMsgrInfo))
    {
        nIndex2 = sizeof(BA_SortOrder)/sizeof(int);
        if(pEntry2->tag == LPARAM_ABGRPENTRY)
            nIndex2++;
    }
    else
    {
        while((BA_SortOrder[nIndex2] != pEntry2->lpMsgrInfo->nStatus) && (BA_SortOrder[nIndex2] != MSTATEOE_UNKNOWN))
            nIndex2++;
    }

    if(pEntry1->tag == LPARAM_MENTRY)              // if no AB entry
        StrCpyN(pchName1, pEntry1->lpMsgrInfo->pchMsgrName, ARRAYSIZE(pchName1));
    else
        StrCpyN(pchName1, pEntry1->pchWABName, ARRAYSIZE(pchName1));
        // st_pAddrBook->GetDisplayName(pEntry1->lpSB, pchName1);
    pchName1[MAXNAME - 1] = _T('\0');

    if(pEntry2->tag == LPARAM_MENTRY)              // if no AB entry
        StrCpyN(pchName2, pEntry2->lpMsgrInfo->pchMsgrName, ARRAYSIZE(pchName2));
    else
        StrCpyN(pchName2, pEntry2->pchWABName, ARRAYSIZE(pchName2));
        // st_pAddrBook->GetDisplayName(pEntry2->lpSB, pchName2);
    pchName2[MAXNAME - 1] = _T('\0');

    switch(lParamSort)
    {
        case BASORT_NAME_ACSEND:
            return(lstrcmpi(pchName1, pchName2));

        case BASORT_NAME_DESCEND:
            return(lstrcmpi(pchName2, pchName1));

        default:
            if((pEntry1->lpMsgrInfo) && (pEntry2->lpMsgrInfo) && (pEntry1->lpMsgrInfo->nStatus == pEntry2->lpMsgrInfo->nStatus))
            {
                if(lParamSort == BASORT_STATUS_ACSEND)
                    return(lstrcmpi(pchName1, pchName2));
                else
                    return(lstrcmpi(pchName2, pchName1));
            }
            else
            {
                if(lParamSort == BASORT_STATUS_ACSEND)
                    return(nIndex1 - nIndex2);
                else
                    return(nIndex2 - nIndex1);
            }
    }

    Assert(FALSE);
    return(0);
}

void CMsgrAb::_EnableCommands(void)
{
    if(g_pBrowser)
        g_pBrowser->UpdateToolbar();
}


LRESULT CMsgrAb::NotifyItemActivate(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return (SendMessage(WM_COMMAND, ID_SEND_INSTANT_MESSAGE2, 0));
}


// GETDISPLAYINFO notification message
LRESULT CMsgrAb::NotifyGetDisplayInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LV_DISPINFO * plvdi = (LV_DISPINFO *)pnmh;
    LRESULT hr;

    if(plvdi->item.lParam)
    {
        LPMABENTRY pEntry = (LPMABENTRY) plvdi->item.lParam;
        LPMABENTRY pFindEntry = NULL;

        if (plvdi->item.mask &  LVIF_IMAGE)
        {
            if((hr = SetUserIcon(pEntry, (pEntry->lpMsgrInfo ? pEntry->lpMsgrInfo->nStatus : MSTATEOE_OFFLINE), &(plvdi->item.iImage) ) ) != S_OK)
                return(hr);
        }

        if (plvdi->item.mask &  LVIF_TEXT)
        {

            if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
            {
                // if((hr = m_cAddrBook.GetDisplayName(pEntry->lpSB, plvdi->item.pszText)) != S_OK)
                //    return(hr);
                Assert(pEntry->pchWABName);
                StrCpyN(plvdi->item.pszText, pEntry->pchWABName, plvdi->item.cchTextMax - 1);
                plvdi->item.pszText[plvdi->item.cchTextMax - 1] = '\0';
            }
            else if(pEntry->tag == LPARAM_MENTRY)
            {
                if((pEntry->lpMsgrInfo->nStatus == MSTATEOE_ONLINE) && lstrcmpi(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID))
                {
                    StrCpyN(plvdi->item.pszText, pEntry->lpMsgrInfo->pchMsgrName, plvdi->item.cchTextMax - 1);
                    plvdi->item.pszText[plvdi->item.cchTextMax - 1] = '\0';

                    // Don't need redraw now, do it later
                    hr = MAPI_E_COLLISION; // m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID);
                    if(hr == MAPI_E_COLLISION)      // already have a contact in AB
                    {
                        int Index = -1;
                        TCHAR *pchID = NULL;

                        if(MemAlloc((LPVOID *) &pchID, lstrlen(pEntry->lpMsgrInfo->pchID) + 1))
                        {
                            StrCpyN(pchID, pEntry->lpMsgrInfo->pchID, lstrlen(pEntry->lpMsgrInfo->pchID) + 1);
                            do
                            {
                                pFindEntry = FindUserEmail(pchID, &Index, FALSE);
                            }while((pFindEntry != NULL) && (pFindEntry->tag == LPARAM_MENTRY));

                            if(pFindEntry != NULL)
                            {
                                hr = m_cAddrBook.SetDefaultMsgrID(pFindEntry->lpSB, pchID);
                                if(hr == S_OK)
                                    _ReloadListview();
                            }
                            MemFree(pchID);
                        }
                    }
                    //if we not found...
                    if(hr != S_OK)
                    {
                        hr = m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID);
                        if(hr == S_OK)
                            _ReloadListview();
                    }

                }
                else
                {
                    StrCpyN(plvdi->item.pszText, pEntry->lpMsgrInfo->pchMsgrName, plvdi->item.cchTextMax - 1);
                    plvdi->item.pszText[plvdi->item.cchTextMax - 1] = '\0';
                    // plvdi->item.pszText = pEntry->lpMsgrInfo->pchMsgrName;
                }
            }
            else    // Unknown tag
                Assert(FALSE);
        }
    }

    return S_OK;
}


LRESULT CMsgrAb::NotifyGetInfoTip(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NMLVGETINFOTIP *plvgit = (NMLVGETINFOTIP *) pnmh;
    TCHAR         szText[CCHMAX_STRINGRES + MAXNAME + 1] = _T("");
    TCHAR         szName[MAXNAME];

    LVITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = plvgit->iItem;
    lvi.iSubItem = plvgit->iSubItem;

    ListView_GetItem(m_ctlList, &lvi);

    LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

#ifdef NEED
    if (pEntry->lpMsgrInfo != NULL)
    {
        StrCpyN(plvgit->pszText, pEntry->lpMsgrInfo->pchMsgrName, plvgit->cchTextMax);
        StrCatBuff(plvgit->pszText, m_szLeftBr, plvgit->cchTextMax);
        StrCatBuff(plvgit->pszText, pEntry->lpMsgrInfo->pchID, plvgit->cchTextMax);
        StrCatBuff(plvgit->pszText, m_szRightBr, plvgit->cchTextMax);

        LPCWSTR szStatus;

        switch(pEntry->lpMsgrInfo->nStatus)
        {
        case BIMSTATE_ONLINE:
            szStatus = m_szOnline;
            break;
        case BIMSTATE_BUSY:
            szStatus = m_szBusy;
            break;
        case BIMSTATE_BE_RIGHT_BACK:
            szStatus = m_szBack;
            break;
        case BIMSTATE_IDLE:
            szStatus = m_szIdle;
            break;
        case BIMSTATE_AWAY:
            szStatus = m_szAway;
            break;
        case BIMSTATE_ON_THE_PHONE:
            szStatus = m_szOnPhone;
            break;
        case BIMSTATE_OUT_TO_LUNCH:
            szStatus = m_szLunch;
            break;

        default:
            szStatus = m_szOffline;
            break;
        }

        StrCatBuff(plvgit->pszText, szStatus, plvgit->cchTextMax);
    }
#endif 
        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
        {
            Assert(pEntry->pchWABName != NULL);
            StrCpyN(szName, pEntry->pchWABName, ARRAYSIZE(szName));
            szName[MAXNAME - 1] =  _T('\0');
        }
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            StrCpyN(szName, pEntry->lpMsgrInfo->pchMsgrName, ARRAYSIZE(szName));
            szName[MAXNAME - 1] =  _T('\0');
        }
        else
            Assert(FALSE);

        StrCpyN(szText, szName, ARRAYSIZE(szText));

    if(pEntry->lpMsgrInfo)
        {
            switch(pEntry->lpMsgrInfo->nStatus)
            {
            case MSTATEOE_ONLINE:
                StrCatBuff(szText, m_szOnline, ARRAYSIZE(szText));
                break;
            case MSTATEOE_BUSY:
                StrCatBuff(szText, m_szBusy, ARRAYSIZE(szText));
                break;
            case MSTATEOE_BE_RIGHT_BACK:
                StrCatBuff(szText, m_szBack, ARRAYSIZE(szText));
                break;
            case MSTATEOE_IDLE:
                StrCatBuff(szText, m_szIdle, ARRAYSIZE(szText));
                break;
            case MSTATEOE_AWAY:
                StrCatBuff(szText, m_szAway, ARRAYSIZE(szText));
                break;
            case MSTATEOE_ON_THE_PHONE:
                StrCatBuff(szText, m_szOnPhone, ARRAYSIZE(szText));
                break;
            case MSTATEOE_OUT_TO_LUNCH:
                StrCatBuff(szText, m_szLunch, ARRAYSIZE(szText));
                break;

            default:
                StrCatBuff(szText, m_szOffline, ARRAYSIZE(szText));
                break;
            }
            StrCpyN(plvgit->pszText, szText, plvgit->cchTextMax);
        }


    else if (plvgit->dwFlags & LVGIT_UNFOLDED)
    {
        // If this is not a messenger item and the text
        // isn't truncated do not display a tooltip.

        plvgit->pszText[0] = L'\0';
    }

    return 0;
}

LRESULT CMsgrAb::SetUserIcon(LPMABENTRY pEntry, int nStatus, int * pImage)
{
    switch(pEntry->tag)
    {
    case LPARAM_MENTRY:
    case LPARAM_MABENTRY:
        {
            switch(nStatus)
            {
            case MSTATEOE_ONLINE:
                *pImage = IMAGE_ONLINE;
                break;

            case MSTATEOE_INVISIBLE:
                *pImage = IMAGE_STOPSIGN;
                break;

            case MSTATEOE_BUSY:
                *pImage = IMAGE_STOPSIGN;
                break;

            case MSTATEOE_BE_RIGHT_BACK:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_BE_RIGHT_BACK;
                break;

            case MSTATEOE_IDLE:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_IDLE;
                break;

            case MSTATEOE_AWAY:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_AWAY;
                break;

            case MSTATEOE_ON_THE_PHONE:
                *pImage = IMAGE_STOPSIGN; // IMAGE_ON_THE_PHONE;
                break;

            case MSTATEOE_OUT_TO_LUNCH:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_OUT_TO_LUNCH;
                break;

            default:
                *pImage = IMAGE_OFFLINE;
                break;

            }
        }
        break;

    case LPARAM_ABGRPENTRY:
        // WAB group
        *pImage = IMAGE_DISTRIBUTION_LIST;
        break;

    default:
        // Not a buddy...
        if(pEntry->fCertificate)
            *pImage = IMAGE_CERT;
        else
            *pImage = IMAGE_NEW_MESSAGE;
        break;
    }
    return(S_OK);

}

// Return MAB entry for first selected item
LPMABENTRY CMsgrAb::GetSelectedEntry()
{
    LVITEM lvi;

    // Get the focused item
    lvi.iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_SELECTED | LVNI_FOCUSED);

    // Get the lParam for that item
    if (lvi.iItem != -1)
    {
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;

        if(ListView_GetItem(m_ctlList, &lvi))
            return((LPMABENTRY) lvi.lParam);
    }
    return(NULL);   // unscucces
}


/*
LRESULT CMsgrAb::CmdMsgrOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(m_pCMsgrList->LaunchOptionsUI()); // (MOPTDLG_GENERAL_PAGE);

}
*/

// Exec for Properties command
LRESULT CMsgrAb::CmdProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();

    if(pEntry)
    {
        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
            m_cAddrBook.ShowDetails(m_hWnd, pEntry->lpSB);
    }
    return (0);
}

// Check entry for possibility to send Instant message
LPMABENTRY CMsgrAb::GetEntryForSendInstMsg(LPMABENTRY pEntry)
{
    if(ListView_GetSelectedCount(m_ctlList) == 1)
    {
        if(!pEntry)     // if we don'y have pEntry yet then get it
            pEntry = GetSelectedEntry();

        if(pEntry && (pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_MENTRY) &&
                    (pEntry->lpMsgrInfo->nStatus != MSTATEOE_OFFLINE) && (pEntry->lpMsgrInfo->nStatus != MSTATEOE_INVISIBLE) &&
                    !(m_pCMsgrList->IsLocalName(pEntry->lpMsgrInfo->pchID)))
            return(pEntry);
    }

    if(m_pCMsgrList)
    {
        if(m_pCMsgrList->IsLocalOnline() && (m_pCMsgrList->GetCount() > 0))
            return(NULL);   // should be /*return((LPMABENTRY) -1);*/ - temporary disabled (YST)
    }

    return(NULL);
}

// Display right-mouse click (context) menu
LRESULT CMsgrAb::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPMABENTRY pEntry;
    HMENU       hPopup = 0;
    HWND        hwndHeader;
    int         id = 0;
    POINT       pt = { (int)(short) LOWORD(lParam), (int)(short) HIWORD(lParam) };
    int n = -1;
    // Figure out if this came from the keyboard or not
    if (lParam == -1)
    {
        Assert((HWND) wParam == m_ctlList);
        int i = ListView_GetFirstSel(m_ctlList);
        if (i == -1)
            return (0);

        ListView_GetItemPosition(m_ctlList, i, &pt);
        m_ctlList.ClientToScreen(&pt);
    }

    LVHITTESTINFO lvhti;
    lvhti.pt = pt;
    m_ctlList.ScreenToClient(&lvhti.pt);
    ListView_HitTest(m_ctlList, &lvhti);

    if (lvhti.iItem == -1)
        return (0);

    // Load the context menu
    hPopup = LoadPopupMenu(IDR_BA_POPUP);
    if (!hPopup)
        goto exit;

    pEntry = GetSelectedEntry();
    pEntry = GetEntryForSendInstMsg(pEntry);

    if((pEntry == NULL) && (g_dwHideMessenger != BL_NOTINST))
        SetMenuDefaultItem(hPopup, ID_SEND_MESSAGE, FALSE);
    else if((g_dwHideMessenger == BL_NOTINST) || (((INT_PTR) pEntry) == -1))
        SetMenuDefaultItem(hPopup, ID_SEND_MESSAGE, FALSE);
    else
        SetMenuDefaultItem(hPopup, ID_SEND_INSTANT_MESSAGE, FALSE);

    if ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE))
    {
        DeleteMenu(hPopup, ID_SEND_INSTANT_MESSAGE, MF_BYCOMMAND);
        DeleteMenu(hPopup, ID_SET_ONLINE_CONTACT, MF_BYCOMMAND);
        DeleteMenu(hPopup, ID_NEW_ONLINE_CONTACT, MF_BYCOMMAND);
    }

    MenuUtil_EnablePopupMenu(hPopup, this);

    TrackPopupMenuEx(hPopup, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                     pt.x, pt.y, m_hWnd, NULL);

exit:
    if (hPopup)
        DestroyMenu(hPopup);

    return (0);
}


//
//  FUNCTION:   CMsgrAb::DragEnter()
//
//  PURPOSE:    This get's called when the user starts dragging an object
//              over our target area.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
STDMETHODIMP CMsgrAb::DragEnter(IDataObject* pDataObject, DWORD grfKeyState,
                                     POINTL pt, DWORD* pdwEffect)
{
    IEnumFORMATETC *pEnum;
    FORMATETC       fe;
    ULONG           celtFetched;

    // Verify we got this
    if (!pDataObject)
        return (S_OK);

    // Init
    ZeroMemory(&fe, sizeof(FORMATETC));

    // Set the default return value to be failure
    *pdwEffect = DROPEFFECT_NONE;

    // Get the FORMATETC enumerator for this data object
    if (SUCCEEDED(pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
    {
        // Walk through the data types to see if we can find the ones we're
        // interested in.
        pEnum->Reset();

        while (S_OK == pEnum->Next(1, &fe, &celtFetched))
        {
            Assert(celtFetched == 1);

            // The only format we care about is CF_INETMSG
            if ((fe.cfFormat == CF_INETMSG) /*|| (fe.cfFormat == CF_OEMESSAGES)*/)
            {
                *pdwEffect = DROPEFFECT_COPY;
                break;
            }
        }

        pEnum->Release();
    }

    // We we're going to allow the drop, then keep a copy of the data object
    if (*pdwEffect != DROPEFFECT_NONE)
    {
        m_pDataObject = pDataObject;
        m_pDataObject->AddRef();
        m_cf = fe.cfFormat;
        m_fRight = (grfKeyState & MK_RBUTTON);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMsgrAb::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
STDMETHODIMP CMsgrAb::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    // If we didn't cache a data object in IDropTarget::DragEnter(), we
    // blow this off.
    if (NULL == m_pDataObject)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return (S_OK);
    }

    // We always do a copy
    *pdwEffect = DROPEFFECT_COPY;
    return (S_OK);
}

//
//  FUNCTION:   CMsgrAb::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
STDMETHODIMP CMsgrAb::DragLeave(void)
{
    // Free everything up at this point.
    if (NULL != m_pDataObject)
    {
        m_pDataObject->Release();
        m_pDataObject = 0;
        m_cf = 0;
    }

    return (S_OK);
}


//
//  FUNCTION:   CMsgrAb::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
STDMETHODIMP CMsgrAb::Drop(IDataObject* pDataObject, DWORD grfKeyState,
                                POINTL pt, DWORD* pdwEffect)
{
    HRESULT             hr = S_OK;
    FORMATETC           fe;
    STGMEDIUM           stm;
    IMimeMessage        *pMessage = 0;

    // Get the stream from the DataObject
    ZeroMemory(&stm, sizeof(STGMEDIUM));
    SETDefFormatEtc(fe, CF_INETMSG, TYMED_ISTREAM);

    if (FAILED(hr = pDataObject->GetData(&fe, &stm)))
        goto exit;

    // Create a new message object
    if (FAILED(hr = HrCreateMessage(&pMessage)))
        goto exit;

    // Load the message from the stream
    if (FAILED(hr = pMessage->Load(stm.pstm)))
        goto exit;

    // If this was a right-drag, then we bring up a context menu etc.
    if (m_fRight)
        _DoDropMenu(pt, pMessage);
    else
        _DoDropMessage(pMessage);

exit:
    ReleaseStgMedium(&stm);
    SafeRelease(pMessage);

    m_pDataObject->Release();
    m_pDataObject = 0;
    m_cf = 0;

    return (hr);
}

HRESULT CMsgrAb::_DoDropMessage(LPMIMEMESSAGE pMessage)
{
    HRESULT     hr;
    ADDRESSLIST addrList = { 0 };
    ULONG       i;
    SECSTATE    secState = {0};
    BOOL        fSignTrusted = FALSE;

    if(FAILED(hr = HandleSecurity(m_hWnd, pMessage)))
        return hr;

    if (IsSecure(pMessage) && SUCCEEDED(HrGetSecurityState(pMessage, &secState, NULL)))
    {
        fSignTrusted = !!IsSignTrusted(&secState);
        CleanupSECSTATE(&secState);
    }

    // Get the address list from the message
    hr = pMessage->GetAddressTypes(IAT_FROM | IAT_SENDER, IAP_FRIENDLYW | IAP_EMAIL | IAP_ADRTYPE, &addrList);
    if (FAILED(hr))
        goto exit;

    // Loop through the addresses
    for (i = 0; i < addrList.cAdrs; i++)
    {
        m_cAddrBook.AddAddress(addrList.prgAdr[i].pszFriendlyW, addrList.prgAdr[i].pszEmail);
#ifdef DEAD
        TCHAR *pch = StrStr(CharUpper(addrList.prgAdr[i].pszEmail), szHotMail);
        if((pch != NULL) && m_pCMsgrList)
            m_pCMsgrList->AddUser(addrList.prgAdr[i].pszEmail);
#endif // DEAD
    }

    if(fSignTrusted)
    {
        FILETIME ftNull = {0};
        HrAddSenderCertToWab(NULL, pMessage, NULL, NULL, NULL, ftNull, WFF_CREATE);
    }

#ifdef NEEDED
    // Reload the table
    _ReloadListview();
#endif

exit:
    return (S_OK);

}

HRESULT CMsgrAb::_DoDropMenu(POINTL pt, LPMIMEMESSAGE pMessage)
{
    HRESULT     hr;
    ADDRESSLIST addrList = { 0 };
    ULONG       i;
    HMENU       hPopup = 0, hSubMenu = 0;
    UINT        id = 0;
    BOOL        fReload = FALSE;
    SECSTATE    secState = {0};
    BOOL        fSignTrusted = FALSE;

    // Get the address list from the message
    if(FAILED(hr = HandleSecurity(m_hWnd, pMessage)))
        return hr;

    if (IsSecure(pMessage) && SUCCEEDED(HrGetSecurityState(pMessage, &secState, NULL)))
    {
        fSignTrusted = !!IsSignTrusted(&secState);
        CleanupSECSTATE(&secState);
    }

    hr = pMessage->GetAddressTypes(IAT_KNOWN, IAP_FRIENDLYW | IAP_EMAIL | IAP_ADRTYPE, &addrList);
    if (FAILED(hr))
        goto exit;

    // Load the context menu
    hPopup = LoadPopupMenu(IDR_BA_DRAGDROP_POPUP);
    if (!hPopup)
        goto exit;

    // Bold the "Save All" item
    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STATE;
    if (GetMenuItemInfo(hPopup, ID_SAVE_ALL, FALSE, &mii))
    {
        mii.fState |= MFS_DEFAULT;
        SetMenuItemInfo(hPopup, ID_SAVE_ALL, FALSE, &mii);
    }

    // Create the "Save >" item
    hSubMenu = CreatePopupMenu();

    // Loop through the addresses
    for (i = 0; i < addrList.cAdrs; i++)
    {
        AppendMenuWrapW(hSubMenu, MF_STRING | MF_ENABLED, ID_SAVE_ADDRESS_FIRST + i, addrList.prgAdr[i].pszFriendlyW);
    }

    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = hSubMenu;
    SetMenuItemInfo(hPopup, ID_SAVE, FALSE, &mii);

    id = TrackPopupMenuEx(hPopup, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                          pt.x, pt.y, m_hWnd, NULL);

    if (id == ID_SAVE_ALL_ADDRESSES)
    {
        for (i = 0; i < addrList.cAdrs; i++)
        {
            m_cAddrBook.AddAddress(addrList.prgAdr[i].pszFriendlyW, addrList.prgAdr[i].pszEmail);
        }
        fReload = TRUE;
    }
    else if (id >= ID_SAVE_ADDRESS_FIRST && id < ID_SAVE_ADDRESS_LAST)
    {
        m_cAddrBook.AddAddress(addrList.prgAdr[id - ID_SAVE_ADDRESS_FIRST].pszFriendlyW,
                               addrList.prgAdr[id - ID_SAVE_ADDRESS_FIRST].pszEmail);
        fReload = TRUE;
    }

    if(fSignTrusted)
    {
        FILETIME ftNull = {0};
        HrAddSenderCertToWab(NULL, pMessage, NULL, NULL, NULL, ftNull, WFF_CREATE);
    }


    if (fReload)
    {
        // Reload the table
        _ReloadListview();
    }

exit:
    if (hSubMenu)
        DestroyMenu(hSubMenu);

    if (hPopup)
        DestroyMenu(hPopup);

    return (S_OK);
}


LRESULT CMsgrAb::CmdDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LVITEM lvi;
    ENTRYLIST rList;
    ULONG cValues;
    SBinary UNALIGNED *pEntryId;
    HRESULT hr = S_OK;
    BOOL fConfirm = TRUE;
    TCHAR szText[CCHMAX_STRINGRES + MAXNAME];
    TCHAR szBuff[CCHMAX_STRINGRES];

    if(m_delItem > 0)
    {
        MessageBeep(MB_OK);
        return(S_OK);
    }

    if(m_fNoRemove)
        m_fNoRemove = FALSE;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = -1;

    // Figure out how many items are selected
    cValues = ListView_GetSelectedCount(m_ctlList);
    m_delItem = cValues;
    if (cValues != 1)
    {
        // Remove only Msgr entry
        AthLoadString(idsBADelMultiple, szBuff, ARRAYSIZE(szBuff));
        wnsprintf(szText, ARRAYSIZE(szText), szBuff, cValues);

        if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
            NULL, MB_YESNO | MB_ICONEXCLAMATION))
            return (0);
        else if(m_fNoRemove)
            goto ErrBeep;
        else
            fConfirm = FALSE;

        //        Assert(FALSE);
        //        return (0);
    }
    while(cValues > 0)
    {
        lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVNI_SELECTED);

        if(lvi.iItem < 0)
        {
ErrBeep:
            MessageBeep(MB_OK);
            return(S_OK);
        }

        // Get the item from the ListView
        if(ListView_GetItem(m_ctlList, &lvi) == FALSE)
            goto ErrBeep;

        // Check buddy state
        LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;
        if(pEntry->tag == LPARAM_MENTRY)
        {
            if(m_pCMsgrList->IsLocalOnline())
            {
                // Remove only Msgr entry
                if(fConfirm)
                {
                    AthLoadString(idsBADelBLEntry, szBuff, ARRAYSIZE(szBuff));
                    wnsprintf(szText, ARRAYSIZE(szText), szBuff,  pEntry->lpMsgrInfo->pchMsgrName);


                    if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                        NULL, MB_YESNO | MB_ICONEXCLAMATION))
                    {
                        m_delItem = 0;
                        return (0);
                    }
                    else if(m_fNoRemove)
                        goto ErrBeep;

                }
                if(pEntry->lpMsgrInfo)
                {
                    m_delItem--;
                    hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
                }
                else
                {
                    m_delItem = 0;
                    return(S_OK);
                }
            }
            else
                goto ErrBeep;
        }
        else if(pEntry->tag == LPARAM_MABENTRY)
        {
            int nID = IDNO;
            if(fConfirm)
            {

                AthLoadString(idsBADelBLABEntry, szBuff, ARRAYSIZE(szBuff));
                wnsprintf(szText, ARRAYSIZE(szText), szBuff, pEntry->pchWABName);

                nID = AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                    NULL, MB_YESNOCANCEL | MB_ICONEXCLAMATION);
            }
            if(((nID == IDYES) || !fConfirm) && !m_fNoRemove)
            {
                if(m_pCMsgrList->IsLocalOnline())
                {
                    // Remove only Msgr & AB entry
                    if(pEntry->lpMsgrInfo)
                        hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
                    else
                    {
                        m_delItem = 0;
                        return(S_OK);
                    }

                    // Allocate a structure big enough for all of 'em
                    if (MemAlloc((LPVOID *) &(rList.lpbin), sizeof(SBinary)))
                    {
                        rList.cValues = 0;
                        pEntryId = rList.lpbin;

                        *pEntryId = *(pEntry->lpSB);
                        pEntryId++;
                        rList.cValues = 1;
                        // Tell the WAB to delete 'em
                        m_nChCount++;    // increase count of our notification messages from WAB
                        m_cAddrBook.DeleteItems(&rList);

                        // Free our array
                        MemFree(rList.lpbin);

                    }
                    // m_delItem++;
                    ListView_DeleteItem(m_ctlList, lvi.iItem);
                    lvi.iItem--;
                    ListView_SetItemState(m_ctlList, ((lvi.iItem >= 0) ? lvi.iItem : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                }
                else
                    MessageBeep(MB_OK);
            }
            else if((nID == IDNO) && !m_fNoRemove)
            {
                // Remove only Msgr entry
                m_delItem--;
                hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
            }
            else
            {
                // Remove nothing
                m_delItem--;
                hr = S_OK;
            }

        }
        else
        {
            // remove AN entry (group or contact)
            if(fConfirm)
            {
                AthLoadString(idsBADelABEntry, szBuff, ARRAYSIZE(szBuff));
                wnsprintf(szText, ARRAYSIZE(szText), szBuff, pEntry->pchWABName);

                if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                    NULL, MB_YESNO | MB_ICONEXCLAMATION))
                {
                    m_delItem = 0;
                    return(0);
                }
                else if(m_fNoRemove)
                    goto ErrBeep;

            }
            // Allocate a structure big enough for all of 'em
            if(pEntry->lpSB)
            {
                if (MemAlloc((LPVOID *) &(rList.lpbin), sizeof(SBinary)))
                {
                    rList.cValues = 0;
                    pEntryId = rList.lpbin;

                    *pEntryId = *(pEntry->lpSB);
                    pEntryId++;
                    rList.cValues = 1;
                    // Tell the WAB to delete 'em
                    m_nChCount++;    // increase count of our notification messages from WAB
                    m_cAddrBook.DeleteItems(&rList);

                    // Free our array
                    MemFree(rList.lpbin);
                }
            }
            // m_delItem++;
            ListView_DeleteItem(m_ctlList, lvi.iItem);
            lvi.iItem--;
        }
        cValues--;
    }

    if(ListView_GetItemCount(m_ctlList) > 0)
    {
        m_cEmptyList.Hide();
        ListView_SetItemState(m_ctlList, ((lvi.iItem >= 0) ? lvi.iItem : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    }
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);


    return (hr);
}

STDMETHODIMP CMsgrAb::get_InstMsg(BOOL * pVal)
{
    *pVal = (GetEntryForSendInstMsg() != NULL);
    return S_OK;
}

/* STDMETHODIMP CMsgrAb::put_InstMsg(BOOL newVal)
{
    return S_OK;
}  */

STDMETHODIMP CMsgrAb::HasFocusIO()
{
    if (GetFocus() == m_ctlList)
        return S_OK;
    else
        return S_FALSE;
}

STDMETHODIMP CMsgrAb::TranslateAcceleratorIO(LPMSG lpMsg)
{
#if 0
    if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_DELETE)
    {
        SendMessage(WM_COMMAND, ID_DELETE_CONTACT, 0);
        return (S_OK);
    }
#endif
    return (S_FALSE);
}

STDMETHODIMP CMsgrAb::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    if (!m_pObjSite)
        return E_FAIL;

    if (!IsWindow(m_hWnd))
    {
        IOleWindow  *pOleWnd;

        if (SUCCEEDED(m_pObjSite->QueryInterface(IID_IOleWindow, (LPVOID*)&pOleWnd)))
        {
            if(SUCCEEDED(pOleWnd->GetWindow(&m_hwndParent)))
            {
            //Will be resized by parent
            RECT    rect = {0};

            m_hWnd = CreateControlWindow(m_hwndParent, rect);
            if (!m_hWnd)
                return E_FAIL;
            }
        }
        pOleWnd->Release();
    }

    if (fActivate)
    {
        m_ctlList.SetFocus();
    }

    m_pObjSite->OnFocusChangeIS((IInputObject*) this, fActivate);
    return (S_OK);
}

STDMETHODIMP CMsgrAb::SetSite(IUnknown  *punksite)
{
    //If we already have a site, we release it
    SafeRelease(m_pObjSite);

    IInputObjectSite    *pObjSite;
    if ((punksite) && (SUCCEEDED(punksite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pObjSite))))
    {
        m_pObjSite = pObjSite;
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CMsgrAb::GetSite(REFIID  riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

HRESULT CMsgrAb::RegisterFlyOut(CFolderBar *pFolderBar)
{
    Assert(m_pFolderBar == NULL);
    m_pFolderBar = pFolderBar;
    m_pFolderBar->AddRef();

    return S_OK;
}

HRESULT CMsgrAb::RevokeFlyOut(void)
{
    if (m_pFolderBar)
    {
        m_pFolderBar->Release();
        m_pFolderBar = NULL;
    }
    return S_OK;
}


void CMsgrAb::_ReloadListview(void)
{
    // Turn off redrawing
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);
    SetWindowRedraw(m_ctlList, FALSE);
    int index = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);
    if(index == -1)
        index = 0;

    // Delete everything and reload
    SideAssert(ListView_DeleteAllItems(m_ctlList));
    FillMsgrList();                         // User list reload
    m_cAddrBook.LoadWabContents(m_ctlList, this);
    ListView_SetItemState(m_ctlList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    ListView_EnsureVisible(m_ctlList, index, FALSE);
    SetWindowRedraw(m_ctlList, TRUE);
//    Invalidate(TRUE); //

   if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);

    UpdateWindow(/*m_ctlList*/);
    return;
}


ULONG STDMETHODCALLTYPE CMsgrAb::OnNotify(ULONG cNotif, LPNOTIFICATION pNotifications)
{
    // Well something changed in WAB, but we don't know what.  We should reload.
    // Sometimes these changes from us and we should ignore it.
    if(m_nChCount > 0)
        m_nChCount--;
    else
        _ReloadListview();
    return (0);
}

LRESULT CMsgrAb::CmdFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_cAddrBook.Find(m_hWnd);
    return (0);
}

LRESULT CMsgrAb::CmdNewGroup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_cAddrBook.NewGroup(m_hWnd);
    return (0);
}

LRESULT CMsgrAb::CmdMsgrAb(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_cAddrBook.AddressBook(m_hWnd);
    return (0);
}

void CMsgrAb::AddMsgrListItem(LPMINFO lpMsgrInfo)
{
    LV_ITEM lvItem;

    m_cEmptyList.Hide(); // m,ust be sure that empty mesage is hide

    lvItem.iItem = ListView_GetItemCount(m_ctlList);
    lvItem.mask = LVIF_PARAM  | LVIF_IMAGE | LVIF_TEXT;
    lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_MENTRY, NULL, lpMsgrInfo, NULL, NULL, FALSE);
    lvItem.iSubItem = 0;
    lvItem.pszText = LPSTR_TEXTCALLBACK;
    lvItem.iImage = I_IMAGECALLBACK;
    // SetUserIcon(LPARAM_MENTRY, lpMsgrInfo->nStatus, &(lvItem.iImage));
    ListView_InsertItem(m_ctlList, &lvItem);

    return;
}

HRESULT CMsgrAb::FillMsgrList()
{
    LPMINFO pEntry = NULL;

    if(!m_pCMsgrList)
    {
        // Assert(FALSE); // Possible situation. See Bug 31262
        return(S_OK);
    }

    pEntry = m_pCMsgrList->GetFirstMsgrItem();

    while(pEntry)
    {
        AddMsgrListItem(pEntry);
        pEntry = m_pCMsgrList->GetNextMsgrItem(pEntry);
    }
    return S_OK;
}

// Add BLAB table entry
LPMABENTRY CMsgrAb::AddBlabEntry(MABENUM tag, LPSBinary lpSB, LPMINFO lpMsgrInfo, TCHAR *pchMail, TCHAR *pchDisplayName, BOOL fCert)
{
    TCHAR szName[MAXNAME];
    LPMABENTRY pEntry = NULL;
    TCHAR *pchName = NULL;
    if (!MemAlloc((LPVOID *) &pEntry, sizeof(mabEntry)))
        return(NULL);
    pEntry->tag = tag;
    pEntry->lpSB = lpSB;
    pEntry->pchWABName = NULL;
    pEntry->pchWABID = NULL;
    pEntry->fCertificate = fCert;

    if(lpSB != NULL)
    {
        if(!pchDisplayName)
        {
            m_cAddrBook.GetDisplayName(pEntry->lpSB, szName, MAXNAME);
            pchName = szName;
        }
        else
            pchName = pchDisplayName;

        if (!MemAlloc((LPVOID *) &(pEntry->pchWABName), lstrlen(pchName) + 1 ))
        {
            MemFree(pEntry);
            return(NULL);
        }
        StrCpyN(pEntry->pchWABName, pchName, lstrlen(pchName) + 1);

        if(pchMail != NULL)
        {
            if (MemAlloc((LPVOID *) &(pEntry->pchWABID), lstrlen(pchMail) + 1 ))
                StrCpyN(pEntry->pchWABID, pchMail, lstrlen(pchMail) + 1);
        }
    }

    if(lpMsgrInfo && MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo), sizeof(struct _tag_OEMsgrInfo)))
    {

        pEntry->lpMsgrInfo->nStatus = lpMsgrInfo->nStatus;
        pEntry->lpMsgrInfo->pPrev = NULL;
        pEntry->lpMsgrInfo->pNext = NULL;

        if(MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo->pchMsgrName), lstrlen(lpMsgrInfo->pchMsgrName) + 1))
            StrCpyN(pEntry->lpMsgrInfo->pchMsgrName, lpMsgrInfo->pchMsgrName, lstrlen(lpMsgrInfo->pchMsgrName) + 1);
        else
            pEntry->lpMsgrInfo->pchMsgrName = NULL;

        if(MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo->pchID), lstrlen(lpMsgrInfo->pchID) + 1))
            StrCpyN(pEntry->lpMsgrInfo->pchID, lpMsgrInfo->pchID, lstrlen(lpMsgrInfo->pchID) + 1);
        else
            pEntry->lpMsgrInfo->pchID = NULL;
    }
    else
        pEntry->lpMsgrInfo = NULL;

    return(pEntry);
}

void CMsgrAb::RemoveMsgrInfo(LPMINFO lpMsgrInfo)
{
    SafeMemFree(lpMsgrInfo->pchMsgrName);
    SafeMemFree(lpMsgrInfo->pchID);
    SafeMemFree(lpMsgrInfo);
}

// Remove BLAB table entry
void CMsgrAb::RemoveBlabEntry(LPMABENTRY lpEntry)
{
    if(lpEntry == NULL)
        return;

    if(lpEntry->pchWABName)
        MemFree(lpEntry->pchWABName);

    if(lpEntry->pchWABID)
        MemFree(lpEntry->pchWABID);

    if(lpEntry->lpMsgrInfo)
    {
        RemoveMsgrInfo(lpEntry->lpMsgrInfo);
        lpEntry->lpMsgrInfo = NULL;
    }

    MemFree(lpEntry);
    lpEntry = NULL;

    return;
}

// This function check buddy and if we have AB entry then set LPARAM_MABENTRY tag
void CMsgrAb::CheckAndAddAbEntry(LPSBinary lpSB, TCHAR *pchEmail, TCHAR *pchDisplayName, DWORD nFlag)
{
    TCHAR szName[MAXNAME];
    LPMABENTRY pEntry = NULL;

    LV_ITEM lvItem;

    lvItem.iItem = ListView_GetItemCount(m_ctlList);
    lvItem.mask = LVIF_PARAM  | LVIF_IMAGE | LVIF_TEXT;
    lvItem.iSubItem = 0;
    lvItem.pszText = LPSTR_TEXTCALLBACK;
    lvItem.iImage = I_IMAGECALLBACK;

    m_cEmptyList.Hide(); // m,ust be sure that empty mesage is hide

    if(!(nFlag & MAB_BUDDY))
    {
        lvItem.lParam = (LPARAM) AddBlabEntry((nFlag & MAB_GROUP) ? LPARAM_ABGRPENTRY : LPARAM_ABENTRY, lpSB, NULL, pchEmail,
                                    pchDisplayName, (nFlag & MAB_CERT));
        // SetUserIcon(LPARAM_ABGRPENTRY, 0, &(lvItem.iImage));

        ListView_InsertItem(m_ctlList, &lvItem);
        return;
    }

    if(pchEmail)
        pEntry = FindUserEmail(pchEmail, NULL, TRUE);

    if(pEntry)      // buddy found
    {
        // if we already linked this budyy to AN entry, add new list item)
        if(pEntry->tag == LPARAM_MABENTRY)
        {
            lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_MABENTRY, lpSB, pEntry->lpMsgrInfo, pchEmail, pchDisplayName, (nFlag & MAB_CERT));
            // SetUserIcon(LPARAM_MABENTRY, pEntry->lpMsgrInfo->nStatus, &(lvItem.iImage));
            ListView_InsertItem(m_ctlList, &lvItem);
        }
        else if(pEntry->tag == LPARAM_MENTRY)      // buddy was not linked to AB entry
        {
            pEntry->tag = LPARAM_MABENTRY;
            pEntry->lpSB = lpSB;
            Assert(lpSB);
            m_cAddrBook.GetDisplayName(pEntry->lpSB, szName, MAXNAME);
            pEntry->pchWABName = NULL;
            pEntry->pchWABID = NULL;

            if (MemAlloc((LPVOID *) &(pEntry->pchWABName), lstrlen(szName) + 1 ))
                StrCpyN(pEntry->pchWABName, szName, lstrlen(szName) + 1);

            if(MemAlloc((LPVOID *) &(pEntry->pchWABID), lstrlen(pchEmail) + 1 ))
                StrCpyN(pEntry->pchWABID, pchEmail, lstrlen(pchEmail) + 1);
        }
        else
            Assert(FALSE);      // something strange
    }
    else        // buddy not found, simple AB entry
    {
        lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_ABENTRY, lpSB, NULL, pchEmail, pchDisplayName, (nFlag & MAB_CERT));
        // SetUserIcon(LPARAM_ABENTRY, 0, &(lvItem.iImage));
        ListView_InsertItem(m_ctlList, &lvItem);
    }
}

LPMABENTRY CMsgrAb::FindUserEmail(TCHAR *pchEmail, int *pIndex, BOOL fMsgrOnly)
{
    LPMABENTRY pEntry = NULL;
    LVITEM             lvi;

    lvi.mask = LVIF_PARAM;
    if(pIndex != NULL)
        lvi.iItem = *pIndex;
    else
        lvi.iItem = -1;
    lvi.iSubItem = 0;

    while((lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVNI_ALL)) != -1)
    {
        ListView_GetItem(m_ctlList, &lvi);
        pEntry = (LPMABENTRY) lvi.lParam;
        if(pEntry)
        {
            if(fMsgrOnly)
            {
                if(pEntry->lpMsgrInfo)
                {
                    if((pEntry->lpMsgrInfo)->pchID)
                    {
                        if(!lstrcmpi((pEntry->lpMsgrInfo)->pchID, pchEmail))
                        {
                            if(pIndex != NULL)
                                *pIndex = lvi.iItem;
                            return(pEntry);
                        }
                    }
                }
            }
            else
            {
                if(pEntry->pchWABID)
                {
                    if(!lstrcmpi(pEntry->pchWABID, pchEmail))
                    {
                        if(pIndex != NULL)
                            *pIndex = lvi.iItem;
                        return(pEntry);
                    }
                }
                if(pEntry->lpSB)
                {
                    if(m_cAddrBook.CheckEmailAddr(pEntry->lpSB, pchEmail))
                    {
                        if(pIndex != NULL)
                            *pIndex = lvi.iItem;
                        return(pEntry);
                    }
                }

            }
        }
    }

    return(NULL);
}
// messenger want shutown. release messenger object
HRESULT CMsgrAb::OnMsgrShutDown(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    if(m_pCMsgrList)
    {
        m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
        OE_CloseMsgrList(m_pCMsgrList);
        m_pCMsgrList = NULL;
    }  
    _ReloadListview();
    return(S_OK);
    
}

// Set new buddy status (online/ofline/etc. and redraw list view entry)
HRESULT CMsgrAb::OnUserStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    LPMABENTRY  pEntry = NULL;
    int index = -1;

    while((pEntry = FindUserEmail((LPSTR) lParam, &index, TRUE)) != NULL)
    {
        pEntry->lpMsgrInfo->nStatus = (int) wParam;

#ifdef NEEDED
        // Check that buddy is in WAB
        if((pEntry->tag == LPARAM_MENTRY) && (pEntry->lpMsgrInfo->nStatus != MSTATEOE_OFFLINE) &&
                    (pEntry->lpMsgrInfo->nStatus != MSTATEOE_UNKNOWN) && (pEntry->lpMsgrInfo->nStatus != MSTATEOE_INVISIBLE))
        {
            // Add new contact to WAB, if we know ID and Display Name
            if(pEntry->lpMsgrInfo->pchID && pEntry->lpMsgrInfo->pchMsgrName && lstrcmpi(pEntry->lpMsgrInfo->pchID, pEntry->lpMsgrInfo->pchMsgrName))
            {
                 hr = m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID); // Don't need redraw now, do it later
//                _ReloadListview();
                return(hr);
            }
        }
#endif
        ListView_RedrawItems(m_ctlList, index, index+1);
    }
//    if(index < 0)

//    Assert(index > -1);
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    return(hr);
}

// Message: buddy was removed
HRESULT CMsgrAb::OnUserRemoved(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    int index = -1;
    LPMABENTRY  pEntry = NULL;

    while((pEntry = FindUserEmail((LPSTR) lParam, &index, TRUE)) != NULL)
    {
        // Not removed yet
        if(pEntry->tag == LPARAM_MABENTRY)
        {
            Assert(pEntry->lpMsgrInfo);
            if(pEntry->lpMsgrInfo)
            {
                RemoveMsgrInfo(pEntry->lpMsgrInfo);

                pEntry->lpMsgrInfo = NULL;
            }

            pEntry->tag = LPARAM_ABENTRY;
            ListView_RedrawItems(m_ctlList, index, index+1);
        }
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            int index1 = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);
            m_delItem++;
            ListView_DeleteItem(m_ctlList, index);
            if(index == index1)
            {
                index1--;
                ListView_SetItemState(m_ctlList, ((index1 >= 0) ? index1 : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            }
        }
        else
            index++;
    }

    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);

    return(hr);
}

// Event User was added => add buddy to our list.
HRESULT CMsgrAb::OnUserAdded(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    LPMINFO  pItem =  (LPMINFO) lParam;

    AddMsgrListItem(pItem);

#ifdef NEEDED
    TCHAR szText[CCHMAX_STRINGRES + RESSTRMAX];
    TCHAR szBuff[CCHMAX_STRINGRES];

        AthLoadString(idsBAAddedUser, szBuff, ARRAYSIZE(szBuff));
        wnsprintf(szText, ARRAYSIZE(szText), szBuff,  pItem->pchMsgrName ? pItem->pchMsgrName : pItem->pchID);

        if(IDYES == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                      NULL, MB_YESNO | MB_ICONEXCLAMATION))
            m_cAddrBook.AddContact(m_hWnd, pItem->pchMsgrName, pItem->pchID);
        else  // just update list
#endif //NEEDED
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);

    return(S_OK);
}

HRESULT CMsgrAb::OnUserNameChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
#ifdef NEEDED
    LPMINFO  pItem =  (LPMINFO) lParam;
    LPMABENTRY  pEntry = NULL;
    int index = -1;

    while((pEntry = FindUserEmail(pItem->pchID, &index, TRUE)) != NULL)
    {
        if((pEntry->tag == LPARAM_MENTRY) && lstrcmpi(pItem->pchID, pItem->pchMsgrName))
        {
            hr = m_cAddrBook.AutoAddContact(pItem->pchMsgrName, pItem->pchID);
            // _ReloadListview();
        }
        ListView_RedrawItems(m_ctlList, index, index+1);
    }
#endif
    _ReloadListview();
    return(hr);
}

HRESULT CMsgrAb::OnUserLogoffEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    if(!m_fLogged)
        return S_OK;
    else
        m_fLogged = FALSE;

    SetWindowRedraw(m_ctlList, FALSE);
    int index = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);

    // Delete everything and reload
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);
    ListView_DeleteAllItems(m_ctlList);
//     FillMsgrList();                         // User list reload
    m_cAddrBook.LoadWabContents(m_ctlList, this);
    ListView_SetItemState(m_ctlList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
     SetWindowRedraw(m_ctlList, TRUE);

    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);

    UpdateWindow(/*m_ctlList*/);

    return S_OK;

}

HRESULT CMsgrAb::OnUserLogResultEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    if(SUCCEEDED(lParam))
    {
        _ReloadListview();
        m_fLogged = TRUE;
    }
    return S_OK;
}

LRESULT CMsgrAb::NotifySetFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    UnkOnFocusChangeIS(m_pObjSite, (IInputObject*) this, TRUE);
    return (0);
}

HRESULT  STDMETHODCALLTYPE CMsgrAb::QueryStatus(const GUID *pguidCmdGroup,
                                                ULONG cCmds, OLECMD *prgCmds,
                                                OLECMDTEXT *pCmdText)
{
    int     nEnable;
    HRESULT hr;
    DWORD   cSelected = ListView_GetSelectedCount(m_ctlList);
    UINT    id;
    MSTATEOE  State;

    // Loop through all the commands in the array
    for ( ; cCmds > 0; cCmds--, prgCmds++)
    {
        // Only look at commands that don't have OLECMDF_SUPPORTED;
        if (prgCmds->cmdf == 0)
        {
            switch (prgCmds->cmdID)
            {
                // These commands are enabled if and only if one item is selected
                case ID_DELETE_CONTACT:
                    if (cSelected > 0)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SEND_MESSAGE:
                case ID_FIND_PEOPLE:
                case ID_ADDRESS_BOOK:
#ifdef GEORGEH
                case ID_NEW_MSG_DEFAULT:
#endif
                    if(HasFocusIO() == S_OK)
                       prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SEND_INSTANT_MESSAGE2:
                {
                    if(g_dwHideMessenger == BL_NOTINST)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else if (cSelected == 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_SORT_BY_STATUS:
                    if((g_dwHideMessenger & BL_NOTINST) || (g_dwHideMessenger & BL_HIDE))
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }
                    else if(ListView_GetItemCount(m_ctlList) > 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    if((m_nSortType == BASORT_STATUS_ACSEND) || (m_nSortType == BASORT_STATUS_DESCEND))
                        prgCmds->cmdf |= OLECMDF_NINCHED;
                    break;

                case ID_SORT_BY_NAME:
                    if((g_dwHideMessenger & BL_NOTINST) || (g_dwHideMessenger & BL_HIDE))
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }
                    else if(ListView_GetItemCount(m_ctlList) > 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    if((m_nSortType == BASORT_NAME_ACSEND) || (m_nSortType == BASORT_NAME_DESCEND))
                        prgCmds->cmdf |= OLECMDF_NINCHED;


                    break;

                // These commands are always enabled
                case ID_POPUP_NEW_ACCOUNT:
                case ID_NEW_HOTMAIL_ACCOUNT:
                case ID_NEW_ATT_ACCOUNT:
                case ID_NEW_CONTACT:
                case ID_POPUP_MESSENGER:
                    prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SET_ONLINE_CONTACT:
                    {
                        if(cSelected != 1)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                        LPMABENTRY pEntry = GetSelectedEntry();
                        if(!pEntry && m_pCMsgrList)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                        else if(pEntry && pEntry->tag != LPARAM_ABENTRY)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                    }
                case ID_NEW_ONLINE_CONTACT:
                    if(m_pCMsgrList)
                    {
                        if(m_pCMsgrList->IsLocalOnline())
                            prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                    }
                    else if(g_dwHideMessenger == BL_NOTINST)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    break;

                // Properties is only enabled if the input focus is in the
                // list view.  Otherwise, we don't mark it as supported at all.
                case ID_PROPERTIES:
                {
                    LPMABENTRY pEntry = GetSelectedEntry();
                    if(pEntry && pEntry->tag != LPARAM_MENTRY)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_MESSENGER_OPTIONS:

                    if (!m_pCMsgrList)
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                    break;

                // These depend on whether
                case ID_LOGIN_MESSENGER:
                case ID_LOGOFF_MESSENGER:
                case ID_MESSENGER_ONLINE:
                case ID_MESSENGER_INVISIBLE:
                case ID_MESSENGER_BUSY:
                case ID_MESSENGER_BACK:
                case ID_MESSENGER_AWAY:
                case ID_MESSENGER_ON_PHONE:
                case ID_MESSENGER_LUNCH:
                case ID_POPUP_MESSENGER_STATUS:
                {
                    // If messenger isn't installed, then none of these commands will
                    // be enabled.
                    if (!m_pCMsgrList)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }

                    if (FAILED(m_pCMsgrList->GetLocalState(&State)))
                        State = MSTATEOE_UNKNOWN;

                    // Convert the online state to a command ID
                    switch (State)
                    {
                        case MSTATEOE_ONLINE:
                        case MSTATEOE_IDLE:
                            id = ID_MESSENGER_ONLINE;
                            break;
                        case MSTATEOE_INVISIBLE:
                            id = ID_MESSENGER_INVISIBLE;
                            break;
                        case MSTATEOE_BUSY:
                            id = ID_MESSENGER_BUSY;
                            break;
                        case MSTATEOE_BE_RIGHT_BACK:
                            id = ID_MESSENGER_BACK;
                            break;
                        case MSTATEOE_AWAY:
                            id = ID_MESSENGER_AWAY;
                            break;
                        case MSTATEOE_ON_THE_PHONE:
                            id = ID_MESSENGER_ON_PHONE;
                            break;
                        case MSTATEOE_OUT_TO_LUNCH:
                            id = ID_MESSENGER_LUNCH;
                            break;
                        default:
                            id = 0xffff;
                    }

                    // Logon is handled a bit seperatly
                    if (prgCmds->cmdID == ID_LOGIN_MESSENGER)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id == 0xffff)
                            prgCmds->cmdf |= OLECMDF_ENABLED;
                    }
                    else if (prgCmds->cmdID == ID_LOGOFF_MESSENGER)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id != 0xffff)
                            prgCmds->cmdf |= OLECMDF_ENABLED;
                    }
                    else
                    {
                        // For all other commands, if we in a known state
                        // then the command is enabled.
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id != 0xffff)
                            prgCmds->cmdf = OLECMDF_ENABLED;

                        // If the command is the same as our state, it should be checked
                        if (id == prgCmds->cmdID)
                            prgCmds->cmdf |= OLECMDF_NINCHED;
                    }
                }
                break;

                case ID_SEND_INSTANT_MESSAGE:
                {
                    if (GetEntryForSendInstMsg() || (g_dwHideMessenger == BL_NOTINST))
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }
            }
        }
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMsgrAb::Exec(const GUID  *pguidCmdGroup,
                                                    DWORD        nCmdID,
                                                    DWORD        nCmdExecOpt,
                                                    VARIANTARG   *pvaIn,
                                                    VARIANTARG   *pvaOut)
{
    HRESULT     hr = OLECMDERR_E_NOTSUPPORTED;
    BOOL        bHandled = 0;
    MSTATEOE      State = MSTATEOE_UNKNOWN;

    switch (nCmdID)
    {
    case ID_SEND_INSTANT_MESSAGE2:
        CmdNewMessage(HIWORD(nCmdID), ID_SEND_INSTANT_MESSAGE2, m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_DELETE_CONTACT:
        hr = (HRESULT) CmdDelete(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;

    case ID_NEW_CONTACT:
//        if(HasFocusIO() == S_OK)
        CmdNewContact(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_SET_ONLINE_CONTACT:
        CmdSetOnline(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_NEW_ONLINE_CONTACT:
        CmdNewOnlineContact(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_PROPERTIES:
    {
        // Only if we have focus
        if (m_ctlList == GetFocus())
        {
            CmdProperties(0, 0, m_ctlList, bHandled);
            hr = S_OK;
        }
        break;
    }

#ifdef GEORGEH
    case ID_NEW_MSG_DEFAULT:
        if(HasFocusIO() == S_OK)
            hr = CmdNewMessage(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;
#endif // GEORGEH

    case ID_SEND_MESSAGE:
        if(HasFocusIO() == S_OK)
            hr = (HRESULT) CmdNewEmaile(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;

    case ID_SEND_INSTANT_MESSAGE:
        // Assert(m_pCMsgrList);
        CmdNewIMsg(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_MESSENGER_OPTIONS:
        hr = m_pCMsgrList->LaunchOptionsUI(); //CmdMsgrOptions();
        break;

    case ID_MESSENGER_ONLINE:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_ONLINE);
        break;

    case ID_MESSENGER_INVISIBLE:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_INVISIBLE);
        break;

    case ID_MESSENGER_BUSY:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_BUSY);
        break;

    case ID_MESSENGER_BACK:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_BE_RIGHT_BACK);
        break;

    case ID_MESSENGER_AWAY:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_AWAY);
        break;

    case ID_MESSENGER_ON_PHONE:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_ON_THE_PHONE);
        break;

    case ID_MESSENGER_LUNCH:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_OUT_TO_LUNCH);
        break;

    case ID_LOGIN_MESSENGER:
        Assert(m_pCMsgrList);
        if(!m_pCMsgrList->IsLocalOnline())
        {
            if(PromptToGoOnline() == S_OK)
                m_pCMsgrList->UserLogon();
        }
        hr = S_OK;
        break;

    case ID_LOGOFF_MESSENGER:
        Assert(m_pCMsgrList);
        if(m_pCMsgrList->IsLocalOnline())
        {
            m_pCMsgrList->UserLogoff();
        }
        hr = S_OK;
        break;

    case ID_SORT_BY_NAME:
        m_nSortType = BASORT_NAME_ACSEND;
        ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
        break;

    case ID_SORT_BY_STATUS:
        m_nSortType = BASORT_STATUS_ACSEND;
        ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
        break;

    default:
        break;
    }

    return hr;
}

#ifdef OLDTIPS
//
//  FUNCTION:   CMsgrAb::OnListMouseEvent()
//
//  PURPOSE:    Whenever we get our first mouse event in a series, we call
//              TrackMouseEvent() so we know when the mouse leaves the ListView.
//
HRESULT CMsgrAb::OnListMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // If we have the view tooltip, then we track all mouse events
    if (!m_fTrackSet && m_fViewTip && (uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST))
    {
        TRACKMOUSEEVENT tme;

        tme.cbSize = sizeof(tme);
        tme.hwndTrack = m_ctlList;
        tme.dwFlags = TME_LEAVE;
        tme.dwHoverTime = 1000;

        if (_TrackMouseEvent(&tme))
            m_fTrackSet = TRUE;
    }

    bHandled = FALSE;
    return (0);
}


//
//  FUNCTION:   CMsgrAb::OnListMouseMove()
//
//  PURPOSE:    If the ListView tooltips are turned on, we need to relay mouse
//              move messages to the tooltip control and update our cached
//              information about what the mouse is over.
//
HRESULT CMsgrAb::OnListMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LVHITTESTINFO lvhti;

    // If we're displaying view tips, then we need to figure out if the mouse is
    // over the same item or not.
    if (m_fViewTip && m_ctlViewTip)
        _UpdateViewTip(LOWORD(lParam), HIWORD(lParam));

    bHandled = FALSE;
    return (0);
}

//
//  FUNCTION:   HRESULT CMsgrAb::OnListMouseLeave()
//
//  PURPOSE:    When the mouse leaves the ListView window, we need to make
//              sure we hide the tooltip.
//
HRESULT CMsgrAb::OnListMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TOOLINFO ti = {0};
    if (m_fViewTip && m_ctlViewTip)
    {
        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = m_hWnd;
        ti.uId = (UINT_PTR)(HWND) m_ctlList;

        // Hide the tooltip
        m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
        m_fViewTipVisible = FALSE;

        // Reset our item / subitem
        m_iItemTip = -1;
        m_iSubItemTip = -1;

        // Tracking is no longer set
        m_fTrackSet = FALSE;
    }
    bHandled = FALSE;
    return (0);
}

// UpdateViewTip - update expand string in list view
// ported from msglist.cpp
BOOL CMsgrAb::_UpdateViewTip(int x, int y)
{
    LVHITTESTINFO lvhti = {0};
    TOOLINFO      ti = {0};
    FNTSYSTYPE    fntType;
    RECT          rc;
    MESSAGEINFO       rInfo;
    COLUMN_ID     idColumn;
    TCHAR         szText[CCHMAX_STRINGRES + MAXNAME + 1] = _T("");
    TCHAR         szName[MAXNAME];
    POINT         pt;
    LVITEM        lvi;

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
    ti.hwnd   = m_hWnd;
    ti.uId    = (UINT_PTR)(HWND) m_ctlList;

    // Get the item and subitem the mouse is currently over
    lvhti.pt.x = x;
    lvhti.pt.y = y;
    ListView_SubItemHitTest(m_ctlList, &lvhti);

    // If the item doesn't exist, then the above call returns the item -1.  If
    // we encounter -1, we break the loop and return FALSE.
    if (-1 == lvhti.iItem || !_IsItemTruncated(lvhti.iItem, lvhti.iSubItem) || !::IsChild(GetForegroundWindow(), m_ctlList))
    {
        // Hide the tip
        if (m_fViewTipVisible)
        {
            m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
            m_fViewTipVisible = FALSE;
        }

        // Reset the item / subitem
        m_iItemTip = -1;
        m_iSubItemTip = -1;

        return (FALSE);
    }

    // If the newly found item & subitem is different from what we're already
    // set up to show, then update the tooltip
    if (m_iItemTip != lvhti.iItem || m_iSubItemTip != lvhti.iSubItem)
    {
        // Update our cached item / subitem
        m_iItemTip = lvhti.iItem;
        m_iSubItemTip = lvhti.iSubItem;

        // Figure out if this column has an image
        lvi.mask = LVIF_PARAM;
        lvi.iItem = m_iItemTip;
        lvi.iSubItem = 0;
        ListView_GetItem(m_ctlList, &lvi);

        LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
        {
            Assert(pEntry->pchWABName != NULL);
            StrCpyN(szName, pEntry->pchWABName, ARRAYSIZE(szName));
            szName[MAXNAME - 1] =  _T('\0');
        }
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            StrCpyN(szName, pEntry->lpMsgrInfo->pchMsgrName, ARRAYSIZE(szName));
            szName[MAXNAME - 1] =  _T('\0');
        }
        else
            Assert(FALSE);

        StrCpyN(szText, szName, ARRAYSIZE(szText));

        if(pEntry->lpMsgrInfo)
        {
            switch(pEntry->lpMsgrInfo->nStatus)
            {
            case MSTATEOE_ONLINE:
                StrCatBuff(szText, m_szOnline, ARRAYSIZE(szText));
                break;
            case MSTATEOE_BUSY:
                StrCatBuff(szText, m_szBusy, ARRAYSIZE(szText));
                break;
            case MSTATEOE_BE_RIGHT_BACK:
                StrCatBuff(szText, m_szBack, ARRAYSIZE(szText));
                break;
            case MSTATEOE_IDLE:
                StrCatBuff(szText, m_szIdle, ARRAYSIZE(szText));
                break;
            case MSTATEOE_AWAY:
                StrCatBuff(szText, m_szAway, ARRAYSIZE(szText));
                break;
            case MSTATEOE_ON_THE_PHONE:
                StrCatBuff(szText, m_szOnPhone, ARRAYSIZE(szText));
                break;
            case MSTATEOE_OUT_TO_LUNCH:
                StrCatBuff(szText, m_szLunch, ARRAYSIZE(szText));
                break;

            default:
                StrCatBuff(szText, m_szOffline, ARRAYSIZE(szText));
                break;
            }
        }

        ti.lpszText = szText;
        m_ctlViewTip.SendMessage(TTM_UPDATETIPTEXT, 0, (LPARAM) &ti);

        // Figure out where to place the tip
        ListView_GetSubItemRect(m_ctlList, m_iItemTip, m_iSubItemTip, LVIR_LABEL, &rc);
        m_ctlList.ClientToScreen(&rc);

        // Update the tooltip
        m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
        m_fViewTipVisible = TRUE;

        // Do some voodoo to line up the tooltip
        pt.x = rc.left;
        pt.y = rc.top;

        // Update the tooltip position
        m_ctlViewTip.SendMessage(TTM_TRACKPOSITION, 0, MAKELPARAM(pt.x, pt.y));

        // Update the tooltip
        m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
        m_fViewTipVisible = TRUE;

        return (TRUE);
    }

    return (FALSE);
}

BOOL CMsgrAb::_IsItemTruncated(int iItem, int iSubItem)
{
    HDC     hdc = NULL;
    SIZE    size={0};
    BOOL    bRet = TRUE;
    LVITEM  lvi;
    TCHAR   szText[256] = _T("");
    int     cxEdge;
    BOOL    fBold;
    RECT    rcText;
    int     cxWidth;
    LPMABENTRY pEntry = NULL;
    HFONT   hf = NULL;;

    // Get the text of the specified item
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = iSubItem;
    lvi.pszText = szText;
    lvi.cchTextMax = ARRAYSIZE(szText);
    ListView_GetItem(m_ctlList, &lvi);

    // If there's no text, it's not truncated, eh?
    if (0 == *szText)
        return (FALSE);

    // if Msgr entry then always expend
    pEntry = (LPMABENTRY) lvi.lParam;
    if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_MENTRY)
        return(TRUE);

    // ListView uses this for padding
    cxEdge = GetSystemMetrics(SM_CXEDGE);

    // Get the sub item rect from the ListView
    ListView_GetSubItemRect(m_ctlList, iItem, iSubItem, LVIR_LABEL, &rcText);

    // Figure out the width
    cxWidth = rcText.right - rcText.left;
    cxWidth -= (6 * cxEdge);

    // Figure out the width of the string
    hdc = m_ctlList.GetDC();

    if(hdc)
    {
        hf = SelectFont(hdc, HGetCharSetFont(FNT_SYS_ICON, GetListViewCharset()));

        if(hf)
        {
            GetTextExtentPoint(hdc, szText, lstrlen(szText), &size);

            SelectFont(hdc, hf);
        }
        m_ctlList.ReleaseDC(hdc);
    }

    return (cxWidth < size.cx);
}

#endif // OLDTIPS
STDMETHODIMP CMsgrAb::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    TCHAR sz[CCHMAX_STRINGRES];
    if(m_lpWED->fReadOnly)
        return NOERROR;

    PROPSHEETPAGE psp;

    // hinstApp        = g_hInst;
    psp.dwSize      = sizeof(psp);   // no extra data
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USETITLE ;
    psp.hInstance   = g_hLocRes;
    psp.lParam      = (LPARAM) &(m_lpWED);
    psp.pcRefParent = (UINT *)&(m_cRefThisDll);

    psp.pszTemplate = MAKEINTRESOURCE(iddWabExt);

    psp.pfnDlgProc  = WabExtDlgProc;
    psp.pszTitle    = AthLoadString(idsWABExtTitle, sz, ARRAYSIZE(sz)); // Title for your tab AthLoadString(idsWABExtTitle, sz, ARRAYSIZE(sz))

    m_hPage1 = ::CreatePropertySheetPage(&psp);
    if (m_hPage1)
    {
        if (!lpfnAddPage(m_hPage1, lParam))
            ::DestroyPropertySheetPage(m_hPage1);
    }

    return NOERROR;
}


STDMETHODIMP CMsgrAb::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    Assert(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CMsgrAb::Initialize(LPWABEXTDISPLAY lpWABExtDisplay)
{

    if (lpWABExtDisplay == NULL)
    {
	    TRACE("CMsgrAb::Initialize() no data object");
	    return E_FAIL;
    }

    if(st_pAddrBook == NULL)
    {
	    TRACE("CMsgrAb::Initialize() - run from not OE - no st_pAddrbook");
	    return E_FAIL;
    }

    if(!m_pCMsgrList)
    {
        m_pCMsgrList = OE_OpenMsgrList();
        if(!m_pCMsgrList)
        {
    	    TRACE("CMsgrAb::Initialize() - Messeneger not installed");
	        return E_FAIL;
        }
        OE_CloseMsgrList(m_pCMsgrList);
        m_pCMsgrList = NULL;
    }

    // However if this is a context menu extension, we need to hang
    // onto the propobj till such time as InvokeCommand is called ..
    // At this point just AddRef the propobj - this will ensure that the
    // data in the lpAdrList remains valid till we release the propobj..
    // When we get another ContextMenu initiation, we can release the
    // older cached propobj - if we dont get another initiation, we
    // release the cached object at shutdown time
    if(lpWABExtDisplay->ulFlags & WAB_CONTEXT_ADRLIST) // this means a IContextMenu operation is occuring
    {
        if(m_lpPropObj)
        {
            m_lpPropObj->Release();
            m_lpPropObj = NULL;
        }

        m_lpPropObj = lpWABExtDisplay->lpPropObj;
        m_lpPropObj->AddRef();

        m_lpWEDContext = lpWABExtDisplay;
    }
    else
    {
        // For property sheet extensions, the lpWABExtDisplay will
        // exist for the life of the property sheets ..
        m_lpWED = lpWABExtDisplay;
    }

    return S_OK;
}

HRESULT CMsgrAb::PromptToGoOnline()
{
    HRESULT     hr;

    if (g_pConMan->IsGlobalOffline())
    {
        if (IDYES == AthMessageBoxW(m_hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                  0, MB_YESNO | MB_ICONEXCLAMATION ))
        {
            g_pConMan->SetGlobalOffline(FALSE);
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
        hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\clutil.cpp ===
//****************************************************************************
//
//  BLClient sample for Microsoft Messenger SDK
//
//  Module:     BLClient.exe
//  File:       clUtil.cpp
//  Content:    Usefull clases for COM and Connection points
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************


#include "pch.hxx"
#include "clUtil.h"
#include <instance.h>
#include "demand.h"


#define ASSERT _ASSERTE

//****************************************************************************
//
// CLASS RefCount
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

RefCount::RefCount(void)
{
    m_cRef = 1;
    
    Assert(NULL != g_pInstance);
    CoIncrementInit("RefCount::RefCount", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

//****************************************************************************
//
// Destructor
//
//****************************************************************************

RefCount::~RefCount(void)
{
    CoDecrementInit("RefCount::RefCount", NULL);    
}


//****************************************************************************
//
// ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
//
//****************************************************************************

ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   ASSERT(m_cRef >= 0);

   InterlockedIncrement(&m_cRef);

   return (ULONG) m_cRef;
}


//****************************************************************************
//
// ULONG STDMETHODCALLTYPE RefCount::Release(void)
//
//****************************************************************************

ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
    if (0 == InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    ASSERT(m_cRef > 0);
    return (ULONG) m_cRef;
}


//****************************************************************************
//
// CLASS CNotify
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

CNotify::CNotify() :
    m_pcnpcnt(NULL),
    m_pcnp(NULL),
    m_dwCookie(0),
    m_pUnk(NULL)
{
}


//****************************************************************************
//
// destructor
//
//****************************************************************************

CNotify::~CNotify()
{
    Disconnect(); // Make sure we're disconnected
}


//****************************************************************************
//
// HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
//
// Connects the sink to the container
//
//****************************************************************************

HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
{
    HRESULT hr;

    ASSERT(0 == m_dwCookie);

    // Get the connection container
    hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void **)&m_pcnpcnt);
    if (SUCCEEDED(hr))
    {
        // Find an appropriate connection point
        hr = m_pcnpcnt->FindConnectionPoint(riid, &m_pcnp);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != m_pcnp);
            // Connect the sink object
            hr = m_pcnp->Advise((IUnknown *)pUnkN, &m_dwCookie);
        }
    }

    if (FAILED(hr))
    {
        m_dwCookie = 0;
    }
    else
    {
        m_pUnk = pUnk; // keep around for caller
    }

    return hr;
}


//****************************************************************************
//
// HRESULT CNotify::Disconnect (void)
//
// Disconnects the sink from the container
//
//****************************************************************************

HRESULT CNotify::Disconnect (void)
{
    if (0 != m_dwCookie)
    {

        // Disconnect the sink object
        m_pcnp->Unadvise(m_dwCookie);
        m_dwCookie = 0;

        m_pcnp->Release();
        m_pcnp = NULL;

        m_pcnpcnt->Release();
        m_pcnpcnt = NULL;

        m_pUnk = NULL;
    }

    return S_OK;
}


//****************************************************************************
//
// CLASS BSTRING
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

// We don't support construction from an ANSI string in the Unicode build.
#ifndef UNICODE

BSTRING::BSTRING(LPCSTR lpcString)
{
    m_bstr = NULL;

    // Compute the length of the required BSTR, including the null
    int cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
    if (cWC <= 0)
        return;

    // Allocate the BSTR, including the null
    m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

    ASSERT(NULL != m_bstr);
    if (NULL == m_bstr)
    {
        return;
    }

    // Copy the string
    MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

    // Verify that the string is null terminated
    ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // #ifndef UNICODE


//****************************************************************************
//
// CLASS BTSTR
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

BTSTR::BTSTR(BSTR bstr)
{
    m_psz = LPTSTRfromBstr(bstr);
}


//****************************************************************************
//
// Destructor
//
//****************************************************************************

BTSTR::~BTSTR()
{
    if (NULL != m_psz)
        MemFree(m_psz);
}


//****************************************************************************
//
// LPTSTR LPTSTRfromBstr(BSTR bstr)
//
// Converts a BSTR to a LPTSTR
//
//****************************************************************************

LPTSTR LPTSTRfromBstr(BSTR bstr)
{
    if (NULL == bstr)
        return NULL;

    int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
    if (cch <= 0)
        return NULL;

    LPTSTR psz;

    if (!MemAlloc((void **)&psz, sizeof(TCHAR) * (cch+1)))
        return NULL;

#ifndef UNICODE
    WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, cch+1, NULL, NULL);
#else
    StrCpyN(psz, bstr, cch+1);
    wcscpy(psz, bstr);
#endif

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\bllist.h ===
// bllist.h : Declaration of the CMsgrList
// Messenger integration to OE
// Created 05/07/98 by YST
// 
#ifndef __BLLIST_H_
#define __BLLIST_H_

#include "mdisp.h"
#include "blobevnt.h"

#define MAXNAME 256

// message for all Msgr client windows
#define WM_USER_STATUS_CHANGED      (WM_USER + 1)
#define WM_MSGR_LOGOFF              (WM_USER + 2)
#define WM_MSGR_LOGRESULT           (WM_USER + 3)
#define WM_USER_MUSER_REMOVED       (WM_USER + 4)
#define WM_USER_MUSER_ADDED         (WM_USER + 5)
#define WM_USER_NAME_CHANGED        (WM_USER + 6)
#define WM_LOCAL_STATUS_CHANGED     (WM_USER + 7)
#define WM_MSGR_SHUTDOWN            (WM_USER + 8)

typedef struct _tag_OEMsgrInfo
{
    TCHAR   * pchMsgrName;
    TCHAR   * pchID;
    int     nStatus;
    struct _tag_OEMsgrInfo * pPrev;
    struct _tag_OEMsgrInfo * pNext;
} oeMsgrInfo;

typedef oeMsgrInfo * LPMINFO;

typedef struct _tag_MsgrWndList
{
    HWND hWndUI;
    struct _tag_MsgrWndList * pPrev;
    struct _tag_MsgrWndList * pNext;
} MsgrWndList;

typedef MsgrWndList * LPMWNDLIST;

class CMsgrList
{
public:

    CMsgrList();
    ~CMsgrList();

    void        AddWndEntry(HWND hWnd);
    void        FindAndDelEntry(HWND hWnd, LPMWNDLIST pWndEntry=NULL);
    LPMINFO     GetRootMsgrItem(void)    { return(m_pblInfRoot); }
    void        RegisterUIWnd(HWND hWndUI);
    void        UnRegisterUIWnd(HWND hWndUI);
    LPMINFO     GetFirstMsgrItem(void)                { CheckAndInitMsgr(); return (m_pblInfRoot); };
    LPMINFO     GetNextMsgrItem(LPMINFO pEntry)      { return(pEntry ? pEntry->pNext : NULL); }
    int         AddRef(void)                        { return(++m_nRef); }
    void        Release(void);                      /* { return(--m_nRef); } */
    HRESULT     CheckAndInitMsgr(void);
    HRESULT     SendInstMessage(TCHAR *pchID);
    HRESULT     EventUserStateChanged(IMsgrUserOE * pUser);
    HRESULT     EventUserRemoved(IMsgrUserOE * pUser);
    HRESULT     EventUserAdded(IMsgrUserOE * pUser);
    HRESULT     EventUserNameChanged(IMsgrUserOE * pUser);
    HRESULT     UserLogon(void);
    HRESULT     AutoLogon(void);
    HRESULT     GetLocalState(MSTATEOE *pState);
    HRESULT     SetLocalState(MSTATEOE State);
    HRESULT     EventLogoff(void);
    HRESULT     EventAppShutdown(void);
    HRESULT     EventLogonResult(long lResult);
    HRESULT     HrInitMsgr(void);
    HRESULT     FillList(void);
    HRESULT     UserLogoff(void);
    HRESULT     FindAndDeleteUser(TCHAR * pchID, BOOL fDelete);
    HRESULT     NewOnlineContact(void);
    HRESULT     LaunchOptionsUI(void);
    HRESULT     AddUser(TCHAR * pchID);
    void        DelAllEntries(LPMWNDLIST pWndEntry);
    long        GetCount(void);
    BOOL        IsLocalOnline(void);
    BOOL        IsLocalName(TCHAR *pchName);
    BOOL        IsContactOnline(TCHAR *pchID, LPMINFO pEntry);

private:
    void        FreeWndList(LPMWNDLIST pWndEntry);
    void        FreeMsgrInfoList(LPMINFO pEntry);
    void        RemoveMsgrInfoEntry(LPMINFO pEntry);
    void        RemoveWndEntry(LPMWNDLIST pWndEntry);
    void        SendMsgToAllUIWnd(UINT msg, WPARAM wParam, LPARAM lParam, LPMWNDLIST pWndEntry=NULL);
    void        AddMsgrListEntry(TCHAR *szName, TCHAR *szID, int nState);
    void        FindAndRemoveBlEntry(TCHAR *szID, LPMINFO pEntry=NULL);

private:
    LPMINFO         m_pblInfRoot;
    LPMINFO         m_pblInfLast;
    LPMWNDLIST      m_pWndLRoot;
    LPMWNDLIST      m_pWndLLast;
    int             m_nRef;

    // Smart pointer
    CComPtr<IMsgrOE>            m_spMsgrObject;
    CMsgrObjectEvents*          m_pMsgrObjectEvents;

    long            m_MsgrCookie;
};


// Global functions available for everybody
CMsgrList *   OE_OpenMsgrList(void);
void        OE_CloseMsgrList(CMsgrList *pCMsgrList);
HRESULT     OE_Msgr_Logoff(void);
HRESULT     InstallMessenger(HWND hWnd);

#ifdef NEEDED
HRESULT     OE_Msgr_Logon(void);
#endif // NEEDED

#endif // __BLLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\blobevnt.h ===
// File:       BLObEvn.h
// Messenger integration to OE
// Created 04/20/98 by YST
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//

#ifndef BLOBEVNT_H
#define BLOBEVNT_H

//****************************************************************************
//
// INCLUDES
//
//****************************************************************************

#include "clUtil.h"
#include "MDisp.h"

class CMsgrList;

//****************************************************************************
//
// DEFINES
//
//****************************************************************************


//****************************************************************************
//
// CLASS CMsgrObjectEvents
//
//****************************************************************************

class CMsgrObjectEvents :	public DMsgrOEEvents, 
						public RefCount
{

//****************************************************************************
//
// METHODS
//
//****************************************************************************

public:

	// Constructor/Destructor

	CMsgrObjectEvents(); 
	virtual ~CMsgrObjectEvents();


	//****************************************************************************
	//
	// IUnknown methods declaration
	//
	//****************************************************************************

	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObject);


	//****************************************************************************
	//
	// IDispatch methods declaration
	//
	//****************************************************************************

	STDMETHOD (GetTypeInfoCount) (UINT* pCountTypeInfo);
	STDMETHOD (GetTypeInfo) ( UINT iTypeInfo,
							  LCID,          // This object does not support localization.
							  ITypeInfo** ppITypeInfo);
	STDMETHOD (GetIDsOfNames) (  const IID& iid,
								 OLECHAR** arrayNames,
								 UINT countNames,
								 LCID,          // Localization is not supported.
								 DISPID* arrayDispIDs);
	STDMETHOD (Invoke) ( DISPID dispidMember,
    									 const IID& iid,
	    								 LCID,          // Localization is not supported.
		    							 WORD wFlags,
										 DISPPARAMS* pDispParams,
										 VARIANT* pvarResult,
										 EXCEPINFO* pExcepInfo,
										 UINT* pArgErr);

    STDMETHOD (SetListOfBuddies) (CMsgrList *pList);
    STDMETHOD (DelListOfBuddies) (void);

private:
    CMsgrList * m_pMsgrList;
    IMsgrOE   * m_pMsgr;
};


#endif //BLOBEVNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\blobevnt.cpp ===
//****************************************************************************
//
// BLObEvnt.cpp
// Messenger integration to OE
// Created 04/20/98 by YST
//
//  Copyright (c) Microsoft Corporation 1997-1998
//


#include "pch.hxx"
#include "bactrl.h"
#include "MDispid.h"
#include "BLObEvnt.h"
#include "demand.h"
#include "bllist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define ASSERT _ASSERTE

#define STR_MAX     256

//****************************************************************************
//
// CLASS CMsgrObjectEvents
//
//****************************************************************************

//****************************************************************************
//
// Construction/Destruction
//
//****************************************************************************

CMsgrObjectEvents::CMsgrObjectEvents() 
{
    // m_pBlAbCtrl = NULL;
    // lLocalState = MSTATEOE_OFFLINE;
}

CMsgrObjectEvents::~CMsgrObjectEvents()
{

}


//****************************************************************************
//
// Methods from IUnknown
//
//****************************************************************************

//****************************************************************************
//
// STDMETHODIMP_(ULONG) CMsgrObjectEvents::AddRef()
//
// Purpose : increment the object's reference count,
// Entry   : None
// Exit    : current count
//
//****************************************************************************

STDMETHODIMP_ (ULONG) CMsgrObjectEvents::AddRef()
{
	return RefCount::AddRef();
}


//****************************************************************************
//
// STDMETHODIMP_(ULONG) CMsgrObjectEvents::Release()
//
// Purpose : decrement the object's reference count
// Entry   : None
// Exit    : returns new count
//
//****************************************************************************

STDMETHODIMP_ (ULONG) CMsgrObjectEvents::Release()
{
	return RefCount::Release();
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::QueryInterface(REFIID iid, LPVOID *ppv)
//
// returns a pointer to the requested interface on the same object
// Purpose: To retrieve a pointer to requested interface
// Entry  : iid -- GUID of requested interface
// Exit   : ppv -- pointer to requested interface (if one exists)
//          return value : HRESULT
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::QueryInterface (REFIID riid, LPVOID *ppv)
{
	*ppv = NULL;
	HRESULT hr = E_NOINTERFACE;

	if (riid == IID_IUnknown)
	 	*ppv = (LPVOID) this;
    else if (riid == DIID_DMsgrOEEvents) 
    	*ppv = (LPVOID) this;
	else if (riid == IID_IDispatch) 
    	*ppv = (LPVOID) this;
              
    if (*ppv) 
    {
	 	((LPUNKNOWN)*ppv)->AddRef();
		hr = S_OK;
	}
	return hr;
}

//****************************************************************************
//
// IDispatch implementation
//
//****************************************************************************


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetTypeInfoCount(UINT* pcTypeInfo)
//
// Set pcTypeInfo to 0 because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetTypeInfoCount(UINT* pcTypeInfo)
{
//	g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfoCount call succeeded"));

	*pcTypeInfo = 0 ;
	return NOERROR ;
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetTypeInfo(
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetTypeInfo(
	UINT iTypeInfo,
	LCID,          // This object does not support localization.
	ITypeInfo** ppITypeInfo)
{    
	*ppITypeInfo = NULL ;

	if(iTypeInfo != 0)
	{
		// g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfo call failed -- bad iTypeInfo index"));

		return DISP_E_BADINDEX ; 
	}
	else
	{
		 //g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfo call succeeded"));

		return E_NOTIMPL;
	}
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetIDsOfNames(  
//												const IID& iid,
//												OLECHAR** arrayNames,
//												UINT countNames,
//												LCID,          // Localization is not supported.
//												DISPID* arrayDispIDs)
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetIDsOfNames(  
	const IID& iid,
	OLECHAR** arrayNames,
	UINT countNames,
	LCID,          // Localization is not supported.
	DISPID* arrayDispIDs)
{
	HRESULT hr;
	if (iid != IID_NULL)
	{
		// g_AddToLog(LOG_LEVEL_COM, _T("GetIDsOfNames call failed -- bad IID"));

		return DISP_E_UNKNOWNINTERFACE ;
	}

	// g_AddToLog(LOG_LEVEL_COM, _T("GetIDsOfNames call succeeded"));

	hr = E_NOTIMPL;

	return hr ;
}

// Set BLAB control for CMsgrObjectEvents
STDMETHODIMP CMsgrObjectEvents::SetListOfBuddies(CMsgrList *pList)
{
    m_pMsgrList = pList;
    return S_OK;

}

// Set BLAB control for CMsgrObjectEvents
STDMETHODIMP CMsgrObjectEvents::DelListOfBuddies()
{
    m_pMsgrList = NULL;
    return S_OK;

}

//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::Invoke(   
//										  DISPID dispidMember,
//										  const IID& iid,
//										  LCID,          // Localization is not supported.
//										  WORD wFlags,
//										  DISPPARAMS* pDispParams,
//										  VARIANT* pvarResult,
//										  EXCEPINFO* pExcepInfo,
//										  UINT* pArgErr)
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::Invoke(   
      DISPID dispidMember,
      const IID& iid,
      LCID,          // Localization is not supported.
      WORD wFlags,
      DISPPARAMS* pDispParams,
      VARIANT* pvarResult,
      EXCEPINFO* pExcepInfo,
      UINT* pArgErr)
{   
	// g_AddToLog(LOG_LEVEL_FUNCTIONS, _T("CMsgrObjectEvents::Invoke entered"));
	// g_AddToLog(LOG_LEVEL_NOTIFICATIONS, _T("Dispid passed : %s"), g_GetStringFromDISPID(dispidMember));
	
	HRESULT hr;
    HRESULT hrRet;

    if (iid != IID_NULL)
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Invoke call failed -- bad IID"));
        return DISP_E_UNKNOWNINTERFACE ;
    }

    ::SetErrorInfo(0, NULL) ;

    CComPtr<IMsgrUserOE>   spUser;
    CComPtr<IMsgrUsersOE> spBuddies;
        
    switch (dispidMember) 
    {
    case DISPID_ONLOGONRESULT:
        //we should only have one parameter, the result, and that it is a long
        ASSERT(pDispParams->cArgs == 1);
        ASSERT(pDispParams->rgvarg->vt == VT_I4);
        // g_AddToLog(LOG_LEVEL_NOTIFICATIONS, _T("Result passed : %s"), g_GetStringFromLogonResult(pDispParams->rgvarg->lVal));

        if(m_pMsgrList)
            hrRet = m_pMsgrList->EventLogonResult(pDispParams->rgvarg->lVal);
        break;

    case DISPID_ONUSERFRIENDLYNAMECHANGERESULT :
        _ASSERTE(pDispParams->cArgs == 3);
        _ASSERTE(pDispParams->rgvarg[2].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_DISPATCH);

        //if(lLocalState >= MSTATEOE_LOCAL_FINDING_SERVER)
        //    break;

        hr = pDispParams->rgvarg[1].pdispVal->QueryInterface(IID_IMsgrUserOE, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if(m_pMsgrList)
                hrRet = m_pMsgrList->EventUserNameChanged(spUser);
        }

        break;

    case DISPID_ONLOGOFF:
        if(m_pMsgrList)
            hrRet = m_pMsgrList->EventLogoff();
        break;
        
     case DISPID_ONAPPSHUTDOWN:
        if(m_pMsgrList)
            hrRet = m_pMsgrList->EventAppShutdown();
        break;

   case DISPID_ONLISTADDRESULT:
        // we should have two parameter, HRESULT, and the pMsgrUser
        //

        // WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
        // The parameters are inversed. This means that the las parameter in the
        // prototype of the function is the first one in the array received, and so on

        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_DISPATCH);

        hrRet = V_I4(&pDispParams->rgvarg[1]);
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IMsgrUserOE, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if( SUCCEEDED(hrRet) )
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was added sucessfully."));

                if(m_pMsgrList)
                    hrRet = m_pMsgrList->EventUserAdded(spUser);
            }
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("QueryInterface for IID_IMsgrUserOE failed"));
        }

        break;

    case DISPID_ONLISTREMOVERESULT:
        // we should have two parameter, HRESULT, and the pMsgrUser
        //
        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_DISPATCH);

        hrRet = V_I4(&pDispParams->rgvarg[1]);
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IMsgrUserOE, (LPVOID *)&spUser);

        if (SUCCEEDED(hr))
        {
            if( SUCCEEDED(hrRet) )
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was removed sucessfully."));
                if(m_pMsgrList)
                    hrRet = m_pMsgrList->EventUserRemoved(spUser);
            }
            else
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was not removed due to error %s."), g_GetErrorString(hrRet));
            }
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("QueryInterface for IID_IMsgrUserOE failed"));
        }

        break;

    case DISPID_ONUSERSTATECHANGED:
        //we should only have two parameters, the previousState and the pMsgrUser 
        ASSERT(pDispParams->cArgs == 2);
        ASSERT(pDispParams->rgvarg[1].vt == VT_DISPATCH);
        ASSERT(pDispParams->rgvarg[0].vt == VT_I4);

        // if(lLocalState >= MSTATEOE_LOCAL_FINDING_SERVER)
        //    break;

        hr = pDispParams->rgvarg[1].pdispVal->QueryInterface(IID_IMsgrUserOE, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if(m_pMsgrList)
                hrRet = m_pMsgrList->EventUserStateChanged(spUser);
        }

        break;

    case DISPID_ONLOCALSTATECHANGERESULT:
        //we should only have two parameters, hr and the LocalState
#if 0
        _ASSERTE(pDispParams->cArgs >== 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_I4);
#endif // 0
        // lLocalState = pDispParams->rgvarg[0].lVal;
        // hrRet = pBlCLientDlg->EventLocalStateChanged(pDispParams->rgvarg[0].lVal);
        break;
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\build\browse.inc ===
mailnews.rc : $(R)\res\mailnews.rc
    copy $** $@

mailnews.bsc: objd\i386\mailnews.bsc
    move objd\i386\mailnews.bsc .

objd\i386\*.sbr :
    move $(R)\inc\objd\i386\*.sbr objd\i386
    move $(R)\common\objd\i386\*.sbr objd\i386
    move $(R)\imap\objd\i386\*.sbr objd\i386
    move $(R)\mail\objd\i386\*.sbr objd\i386
    move $(R)\mime\objd\i386\*.sbr objd\i386
    move $(R)\news\objd\i386\*.sbr objd\i386
    move $(R)\proptree\objd\i386\*.sbr objd\i386
    move $(R)\shell\objd\i386\*.sbr objd\i386
    move $(R)\store\objd\i386\*.sbr objd\i386
    move $(R)\fechrcnv\objd\i386\*.sbr objd\i386
	move $(R)\http\objd\i386\*.sbr objd\i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\build\dummy16.cpp ===
// bogus file for 16bit

void aaa()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\bactrl\clutil.h ===
//****************************************************************************
//
//  BLClient sample for Microsoft Messenger SDK
//
//  Module:     BLClient.exe
//  File:       clUtil.h
//  Content:    Usefull clases for COM and Connection points
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _CL_UTIL_H_
#define _CL_UTIL_H_


//****************************************************************************
//
// CLASS RefCount
//
//****************************************************************************

class RefCount
{
private:
   LONG m_cRef;

public:
   RefCount();
   // Virtual destructor defers destruction to destructor of derived class.
   virtual ~RefCount();

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};



//****************************************************************************
//
// CLASS CNotify
//
// Notification sink
//
//****************************************************************************

class CNotify
{
private:
    DWORD  m_dwCookie;
	IUnknown * m_pUnk;
    IConnectionPoint           * m_pcnp;
    IConnectionPointContainer  * m_pcnpcnt;
public:
    CNotify(void);
    ~CNotify();

    HRESULT Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN);
    HRESULT Disconnect(void);

    IUnknown * GetPunk() {return m_pUnk;}
};



//****************************************************************************
//
// CLASS BSTRING
//
//****************************************************************************

class BSTRING
{
private:
	BSTR   m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#ifndef UNICODE
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // #ifndef UNICODE

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}
	inline LPBSTR GetLPBSTR(void);
};

BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		m_bstr = SysAllocString(lpcwString);
		// ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	// This function is intended to be used to set the BSTR value for
	// objects that are initialized to NULL.  It should not be called
	// on objects which already have a non-NULL BSTR.
	// ASSERT(NULL == m_bstr);

	return &m_bstr;
}



//****************************************************************************
//
// CLASS BTSTR
//
//****************************************************************************

class BTSTR
{
private:
	LPTSTR m_psz;

public:
	BTSTR(BSTR bstr);
	~BTSTR();

	// Cast to BSTR
	operator LPTSTR() {return (NULL == m_psz) ? TEXT("<null>") : m_psz;}
};

LPTSTR LPTSTRfromBstr(BSTR bstr);

#endif  // _CL_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\about.cpp ===
//
// about.cpp
//
// About dialog box
//

#include "pch.hxx"
#include "resource.h"
#include "strconst.h"
#include <demand.h>     // must be last!

// Please keep this list in alphabetical order
static const TCHAR *rgszDll[] = 
{
    "acctres.dll",
    "comctl32.dll",
    "csapi3t1.dll",
    "directdb.dll",
    "inetcomm.dll",
    "inetres.dll",
    "mapi32.dll",
    "mshtml.dll",
    "msident.dll",
    "msoe.dll",
    "msoeacct.dll",
    "msoeres.dll",
    "msoert2.dll",
    "oeimport.dll",
    "ole32.dll",
    "riched20.dll",
    "riched32.dll",
    "wab32.dll",
    "wab32res.dll",
    "wldap32.dll",
};

static const TCHAR *rgszVer[] = {
//     "FileDescription",
    "FileVersion",
    "LegalCopyright",
};


#define NUM_DLLS (sizeof(rgszDll)/sizeof(char *))         

INT_PTR CALLBACK AboutAthena(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
        {
        case WM_INITDIALOG:
            {
            RECT        rcOwner, rc;
            char        szGet[MAX_PATH];
            TCHAR       szPath[MAX_PATH], szRes[CCHMAX_STRINGRES], szRes2[CCHMAX_STRINGRES];
            DWORD       dwVerInfoSize, dwVerHnd;
            LPSTR       lpInfo, lpVersion, lpszT;
            LPWORD      lpwTrans;
            UINT        uLen;
            int         i,j, cItems = 0;
            LV_ITEM     lvi;
            LV_COLUMN   lvc;
            HWND        hwndList;
            HMODULE     hDll;
            LPTSTR      pszFileName;

            // If the caller passed an icon id in the LPARAM, use it
            // SendDlgItemMessage(hdlg, idcStatic1, STM_SETICON, 
            //                   (WPARAM) LoadIcon(g_hLocRes, MAKEINTRESOURCE(lp)), 0);

            // center dialog
            GetWindowRect(GetWindowOwner(hdlg), &rcOwner);
            GetWindowRect(hdlg, &rc);
            SetWindowPos(hdlg, 
                         NULL, 
                         (rcOwner.left+rcOwner.right-(rc.right-rc.left))/2, 
                         (rcOwner.top+rcOwner.bottom-(rc.bottom-rc.top))/2,
                         0, 
                         0, 
                         SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);

            // Do some groovy color things
            COLORMAP cm[] = 
            {
                { RGB(255, 0, 255), GetSysColor(COLOR_BTNFACE) }
            };

            HBITMAP hbm;
            hbm = CreateMappedBitmap(g_hLocRes, idbOELogo, 0, cm, ARRAYSIZE(cm));
            if (hbm)
                SendDlgItemMessage(hdlg, IDC_OE_LOGO, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hbm);

            hbm = CreateMappedBitmap(g_hLocRes, idbWindowsLogo, 0, cm, ARRAYSIZE(cm));
            if (hbm)
                SendDlgItemMessage(hdlg, IDC_WINDOWS_LOGO, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hbm);


            // Load some descriptive text for the build (Beta X)
            //AthLoadString(idsBeta2BuildStr, szRes, ARRAYSIZE(szRes));

            // Get version information from our .exe stub
            if (GetExePath(c_szMainExe, szPath, sizeof(szPath), FALSE))
                {
                if (dwVerInfoSize = GetFileVersionInfoSize(szPath, &dwVerHnd))
                    {
                    if (lpInfo = (LPSTR)GlobalAlloc(GPTR, dwVerInfoSize))
                        {
                        if (GetFileVersionInfo(szPath, dwVerHnd, dwVerInfoSize, lpInfo))
                            {
                            if (VerQueryValue(lpInfo, "\\VarFileInfo\\Translation", (LPVOID *)&lpwTrans, &uLen) &&
                                uLen >= (2 * sizeof(WORD)))
                                {
                                // set up buffer for calls to VerQueryValue()
                                wnsprintf(szGet, ARRAYSIZE(szGet), "\\StringFileInfo\\%04X%04X\\", lpwTrans[0], lpwTrans[1]);
                                lpszT = szGet + lstrlen(szGet);    
                                // Walk through the dialog items that we want to replace:
                                for (i = IDC_VERSION_STAMP; i <= IDC_MICROSOFT_COPYRIGHT; i++) 
                                    {
                                    j = i - IDC_VERSION_STAMP;
                                    StrCpyN(lpszT, rgszVer[j], ARRAYSIZE(szGet)-lstrlen(szGet));
                                    if (VerQueryValue(lpInfo, szGet, (LPVOID *)&lpVersion, &uLen) && uLen)
                                        {
                                        // DON'T overwrite their lpVersion buffer
                                        StrCpyN(szRes2, lpVersion, ARRAYSIZE(szRes2));

                                        // Special case, append string explaining build number
#ifdef DEBUG
                                        if (0 == j)
                                            StrCatBuff(szRes2, " [DEBUG]", ARRAYSIZE(szRes2));
#endif
#if defined(RELEASE_BETA)
                                        if (1 == j)
                                            StrCatBuff(szRes2, szRes, ARRAYSIZE(szRes2));
#endif
                                        SetDlgItemText(hdlg, i, szRes2);

                                        }
                                    }
                                }
                            }
                        GlobalFree((HGLOBAL)lpInfo);
                        }
                    }
                }
            else
                AssertSz(FALSE, "Probable setup issue: Couldn't find our App Path");

            hwndList = GetDlgItem(hdlg, IDC_COMPONENT_LIST);

            // setup columns
            lvc.mask = LVCF_TEXT;
            lvc.pszText = szRes;
            lvc.iSubItem = 0;
            AthLoadString(idsFile, szRes, ARRAYSIZE(szRes));
            ListView_InsertColumn(hwndList, 0, &lvc);
            lvc.iSubItem = 1;
            AthLoadString(idsVersion, szRes, ARRAYSIZE(szRes));
            ListView_InsertColumn(hwndList, 1, &lvc);
            lvc.iSubItem = 2;
            AthLoadString(idsFullPath, szRes, ARRAYSIZE(szRes));
            ListView_InsertColumn(hwndList, 2, &lvc);
            
            lvi.mask = LVIF_TEXT;

            // Process each dll
            for (i=0; i<NUM_DLLS; i++)
                {

                // Always display the name
                lvi.iItem = cItems;
                lvi.iSubItem = 0;
                lvi.pszText = (LPTSTR)rgszDll[i];
                ListView_InsertItem(hwndList, &lvi);

                // Path Info
                if ((hDll = GetModuleHandle(rgszDll[i])) && (GetModuleFileName(hDll, szPath, MAX_PATH)))
                    pszFileName = lvi.pszText = szPath;
                else
                    {
                    pszFileName = lvi.pszText = (LPTSTR)rgszDll[i];
                    }
                lvi.iSubItem = 2;
                ListView_SetItem(hwndList, &lvi);                

                // Version Info
                szRes[0] = NULL;

                if (dwVerInfoSize = GetFileVersionInfoSize(pszFileName, &dwVerHnd))
                    {
                    if (lpInfo = (LPSTR)GlobalAlloc(GPTR, dwVerInfoSize))
                        {
                        if (GetFileVersionInfo((LPTSTR)pszFileName, dwVerHnd, dwVerInfoSize, lpInfo))
                            {
                            if (VerQueryValue(lpInfo, "\\VarFileInfo\\Translation", (LPVOID *)&lpwTrans, &uLen) && 
                                uLen >= (2 * sizeof(WORD)))
                                {
                                // set up buffer for calls to VerQueryValue()
                                wnsprintf(szGet, ARRAYSIZE(szGet), "\\StringFileInfo\\%04X%04X\\FileVersion", lpwTrans[0], lpwTrans[1]);
                                if (VerQueryValue(lpInfo, szGet, (LPVOID *)&lpVersion, &uLen) && uLen)
                                    {
                                    StrCpyN(szRes, lpVersion, ARRAYSIZE(szRes));
                                    }
                                }
                            }
                        GlobalFree((HGLOBAL)lpInfo);
                        }
                    }

                // Version Info
                lvi.iSubItem = 1;
                if (NULL == szRes[0])
                    {
                    AthLoadString(idsUnknown, szRes, ARRAYSIZE(szRes));
                    }
                lvi.pszText = szRes;
                ListView_SetItem(hwndList, &lvi);
                
                cItems++;
                }

            if (cItems)
                {
                ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);
                ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE);
                ListView_SetColumnWidth(hwndList, 2, LVSCW_AUTOSIZE);
                }            
            }
            break;

        case WM_COMMAND:
            if (GET_WM_COMMAND_ID(wp,lp) == IDOK || GET_WM_COMMAND_ID(wp,lp) == IDCANCEL)
                {
                EndDialog(hdlg, TRUE);
                return TRUE;
                }
            break;

        case WM_SYSCOLORCHANGE:
            {
            // Do some groovy color things
            COLORMAP cm[] = 
            {
                { RGB(255, 0, 255), GetSysColor(COLOR_BTNFACE) }
            };

            HBITMAP hbm;
            hbm = CreateMappedBitmap(g_hLocRes, idbOELogo, 0, cm, ARRAYSIZE(cm));
            if (hbm)
                SendDlgItemMessage(hdlg, IDC_OE_LOGO, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hbm);

            hbm = CreateMappedBitmap(g_hLocRes, idbWindowsLogo, 0, cm, ARRAYSIZE(cm));
            if (hbm)
                SendDlgItemMessage(hdlg, IDC_WINDOWS_LOGO, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hbm);
            break;
            }
            
        }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\acctcach.h ===
/*
 *  a c c t c a c h . h
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Runtime store for cached account properties.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef _ACCTCACH_H
#define _ACCTCACH_H

typedef enum tagCACHEDACCOUNTPROP
{
    CAP_HTTPMAILMSGFOLDERROOT,
    CAP_HTTPMAILSENDMSG,
    CAP_HTTPNOMESSAGEDELETES,
    CAP_PASSWORD,
    CAP_HTTPAUTOSYNCEDFOLDERS,
    CAP_LAST
} CACHEDACCOUNTPROP;

void FreeAccountPropCache(void);

HRESULT HrCacheAccountPropStrA(LPSTR pszAccountId, CACHEDACCOUNTPROP cap, LPCSTR pszProp);
BOOL GetAccountPropStrA(LPSTR pszAccountId, CACHEDACCOUNTPROP cap, LPSTR *ppszProp);

void AccountCache_AccountChanged(LPSTR pszAccountId);
void AccountCache_AccountDeleted(LPSTR pszAccountId); 

#endif // _ACCTCACH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\build\makefile.inc ===
mailnews.bsc: $O\mailnews.bsc
    move $O\mailnews.bsc .

$O\*.sbr :
    move $(R)\inc\$O\*.sbr $O
    move $(R)\store\$O\*.sbr $O
    move $(R)\rules\$O\*.sbr $O
    move $(R)\common\$O\*.sbr $O
    move $(R)\om\$O\*.sbr $O
    move $(R)\bactrl\$O\*.sbr $O
    move $(R)\mail\$O\*.sbr $O
    move $(R)\news\$O\*.sbr $O
    move $(R)\shell\$O\*.sbr $O
    move $(R)\view\$O\*.sbr $O
    move $(R)\spooler\$O\*.sbr $O
    move $(R)\imap\$O\*.sbr $O
    move $(R)\http\$O\*.sbr $O


ATHENA_RC_DEPENDS = $(O)\selfreg.inf 	    \
                    ..\inc\$(O)\msoeobj.tlb

$(O)\msoe.res : $(ATHENA_RC_DEPENDS)

selfreg.src : reg.src strings.src

$(O)\selfreg.inx : selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\acctcach.cpp ===
/*
 *  a c c t c a c h . c p p
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Runtime store for cached account properties.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "acctcach.h"
#include "tmap.h"
#include "simpstr.h"

// explicit template instantiations
template class TMap<CACHEDACCOUNTPROP, CSimpleString>;
template class TPair<CACHEDACCOUNTPROP, CSimpleString>;

typedef TMap<CACHEDACCOUNTPROP, CSimpleString>  CAccountPropMap;
typedef TPair<CACHEDACCOUNTPROP, CSimpleString> CAccountPropPair;

template class TMap<CSimpleString, CAccountPropMap*>;
template class TPair<CSimpleString, CAccountPropMap*>;

typedef TMap<CSimpleString, CAccountPropMap*>  CAccountCacheMap;
typedef TPair<CSimpleString, CAccountPropMap*>  CAccountCachePair;

static CAccountCacheMap     *g_pAccountCache;

// REVIEW!!! We are leaking the prop arrays right now!!!
// the map template needs to be able to take a pair free func

//----------------------------------------------------------------------
// Internal Functions
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// _FreeAccountCachePair
//----------------------------------------------------------------------
static void __cdecl _FreeAccountCachePair(CAccountCachePair *pPair)
{
    if (NULL != pPair)
    {
        delete pPair->m_value;
        delete pPair;
    }
}

//----------------------------------------------------------------------
// _HrInitAccountPropCache
//----------------------------------------------------------------------
static HRESULT _HrInitAccountPropCache(void)
{
    HRESULT hr = S_OK;

    Assert(NULL == g_pAccountCache);

    if (NULL != g_pAccountCache)
        return E_FAIL;
    
    g_pAccountCache = new CAccountCacheMap();
    if (NULL == g_pAccountCache)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    g_pAccountCache->SetPairFreeFunction(_FreeAccountCachePair);

exit:
    return S_OK;
}

//----------------------------------------------------------------------
// _HrFindAccountPropertyMap
//----------------------------------------------------------------------
static HRESULT _HrFindAccountPropertyMap(LPSTR pszAccountId, 
                                         CAccountPropMap **ppm,
                                         BOOL fCreate)
{
    HRESULT             hr = S_OK;
    CSimpleString       ss;
    CAccountCachePair   *pPair = NULL;
    CAccountPropMap     *pMap = NULL;

    Assert(NULL != ppm);

    *ppm = NULL;

    if (NULL == g_pAccountCache)
    {
        if (fCreate)
            hr = _HrInitAccountPropCache();

        if (NULL == g_pAccountCache)
            goto exit;
    }

    if (FAILED(hr = ss.SetString(pszAccountId)))
        goto exit;

    pPair = g_pAccountCache->Find(ss);
    if (NULL != pPair)
        *ppm = pPair->m_value;
    else if (fCreate)
    {
        pMap = new CAccountPropMap();
        if (NULL == pMap)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        if (FAILED(hr = g_pAccountCache->Add(ss, pMap)))
        {
            delete pMap;
            goto exit;
        }

        *ppm = pMap;
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// FreeAccountPropCache
//----------------------------------------------------------------------
void FreeAccountPropCache(void)
{
    EnterCriticalSection(&g_csAccountPropCache);
    
    if (NULL != g_pAccountCache)
    {
        delete g_pAccountCache;
        g_pAccountCache = NULL;
    }
    
    LeaveCriticalSection(&g_csAccountPropCache);
}

//----------------------------------------------------------------------
// HrCacheAccountPropStrA
//----------------------------------------------------------------------
HRESULT HrCacheAccountPropStrA(LPSTR pszAccountId, 
                               CACHEDACCOUNTPROP cap, 
                               LPCSTR pszProp)
{
    HRESULT             hr = S_OK;
    CAccountPropMap     *pMap = NULL;
    CAccountPropPair    *pPair = NULL;
    CSimpleString       ssProp;

    if (NULL == pszAccountId || NULL == pszProp)
        return E_INVALIDARG;

    EnterCriticalSection(&g_csAccountPropCache);
    
    // find the account property map. create one if it doesn't exist
    if (FAILED(hr = _HrFindAccountPropertyMap(pszAccountId, &pMap, TRUE)))
        goto exit;

    if (FAILED(hr = ssProp.SetString(pszProp)))
        goto exit;

    // look for the property in the map
    pPair = pMap->Find(cap);
    if (NULL == pPair)
        hr = pMap->Add(cap, ssProp);
    else
        pPair->m_value = ssProp;

exit:
    LeaveCriticalSection(&g_csAccountPropCache);

    return hr;
}

//----------------------------------------------------------------------
// CacheAccountPropStrA
//----------------------------------------------------------------------
BOOL GetAccountPropStrA(LPSTR pszAccountId, 
                             CACHEDACCOUNTPROP cap, 
                             LPSTR *ppszProp)
{
    HRESULT             hr = S_OK;
    CAccountPropMap     *pMap = NULL;
    CAccountPropPair    *pPair = NULL;
    BOOL                fResult = FALSE;

    Assert(NULL != pszAccountId && NULL != ppszProp);

    if (NULL == g_pAccountCache)
        return FALSE;

    if (NULL == pszAccountId || NULL == ppszProp)
        return FALSE;

    *ppszProp = NULL;

    EnterCriticalSection(&g_csAccountPropCache);

    // find the account property map. don't create one if it doesn't exist
    if (FAILED(hr = _HrFindAccountPropertyMap(pszAccountId, &pMap, FALSE)))
        goto exit;

    if (NULL == pMap)
        goto exit;

    pPair = pMap->Find(cap);
    if (NULL != pPair)
    {
        Assert(!pPair->m_value.IsNull());
        if (!pPair->m_value.IsNull())
        {
            *ppszProp = PszDupA(pPair->m_value.GetString());
            if (NULL != *ppszProp)
                fResult = TRUE;
        }
    }

exit:
    LeaveCriticalSection(&g_csAccountPropCache);

    return fResult;
}

//----------------------------------------------------------------------
// AccountCache_AccountChanged
//----------------------------------------------------------------------
void AccountCache_AccountChanged(LPSTR pszAccountId)
{
    // delete the data associated with the account that was changed
    EnterCriticalSection(&g_csAccountPropCache);

    if (NULL != g_pAccountCache)
    {
        CSimpleString ss;
        if (SUCCEEDED(ss.SetString(pszAccountId)))
            g_pAccountCache->Remove(ss);
    }
    
    LeaveCriticalSection(&g_csAccountPropCache);
}

//----------------------------------------------------------------------
// AccountCache_AccountDeleted
//----------------------------------------------------------------------
void AccountCache_AccountDeleted(LPSTR pszAccountId)
{
    AccountCache_AccountChanged(pszAccountId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\acctutil.cpp ===
// --------------------------------------------------------------------------------
// Acctutil.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "goptions.h"
#include "imnact.h"
#include "acctutil.h"
#include "strconst.h"
#include "error.h"
#include "resource.h"
#include <storfldr.h>
#include <notify.h>
#include "conman.h"
#include "shlwapip.h" 
#include "browser.h"
#include "instance.h"
#include "menures.h"
#include "subscr.h"
#include "msident.h"
#include "acctcach.h"
#include <demand.h>     // must be last!

CNewAcctMonitor *g_pNewAcctMonitor = NULL;

HRESULT IsValidSendAccount(LPSTR pszAccount);

CImnAdviseAccount::CImnAdviseAccount(void)
{
    m_cRef = 1;
    m_pNotify = NULL;
}

CImnAdviseAccount::~CImnAdviseAccount(void)
{
    if (m_pNotify != NULL)
        m_pNotify->Release();
}

HRESULT CImnAdviseAccount::Initialize()
    {
    HRESULT hr;

    hr = CreateNotify(&m_pNotify);
    if (SUCCEEDED(hr))
        hr = m_pNotify->Initialize((TCHAR *)c_szMailFolderNotify);

    return(hr);
    }

STDMETHODIMP CImnAdviseAccount::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

	// IID_IImnAccountManager
	if (IID_IImnAdviseAccount == riid)
		*ppv = (IImnAdviseAccount *)this;

    // IID_IUnknown
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;

    // If not null, addref it and return
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TRAPHR(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

STDMETHODIMP_(ULONG) CImnAdviseAccount::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CImnAdviseAccount::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

STDMETHODIMP CImnAdviseAccount::AdviseAccount(DWORD dwAdviseType, ACTX *pactx)
{
    Assert(pactx != NULL);

    if (pactx->AcctType == ACCT_DIR_SERV)
        return(S_OK);

    if (g_pBrowser)
        g_pBrowser->AccountsChanged();

    if (dwAdviseType == AN_DEFAULT_CHANGED)
        return(S_OK);

    HandleAccountChange(pactx->AcctType, dwAdviseType, pactx->pszAccountID, pactx->pszOldName, pactx->dwServerType);
    if (g_pNewAcctMonitor != NULL)
        g_pNewAcctMonitor->OnAdvise(pactx->AcctType, dwAdviseType, pactx->pszAccountID);

    // No matter what the notification, we need to tell the connection manager
    if (g_pConMan)
        g_pConMan->AdviseAccount(dwAdviseType, pactx);

    return S_OK;
}

void CImnAdviseAccount::HandleAccountChange(ACCTTYPE AcctType, DWORD dwAN, LPTSTR pszID, LPTSTR pszOldName, DWORD dwSrvTypesOld)
    {
    HRESULT      hr;
    IImnAccount  *pAccount;
    char         szName[CCHMAX_ACCOUNT_NAME];
    FOLDERID     id;

    Assert(pszID != NULL);

    switch (dwAN)
    {
        case AN_ACCOUNT_DELETED:
            AccountCache_AccountDeleted(pszID);
            if (!!(dwSrvTypesOld & (SRV_IMAP | SRV_NNTP | SRV_HTTPMAIL)))
            {
                hr = g_pStore->FindServerId(pszID, &id);
                if (SUCCEEDED(hr))
                {
                    HCURSOR hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    hr = g_pStore->DeleteFolder(id, DELETE_FOLDER_RECURSIVE | DELETE_FOLDER_NOTRASHCAN, (IStoreCallback *)g_pBrowser);
                    Assert(SUCCEEDED(hr));
                    SetCursor(hCursor);
                }
            }

            if (g_pBrowser != NULL)
                g_pBrowser->UpdateToolbar();
            break;

        case AN_ACCOUNT_ADDED:
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszID, &pAccount)))
            {
                hr = g_pStore->CreateServer(pAccount, NOFLAGS, &id);
                Assert(SUCCEEDED(hr));

                if (g_pBrowser != NULL)
                    g_pBrowser->UpdateToolbar();

                pAccount->Release();
            }
            break;

        case AN_ACCOUNT_CHANGED:
            AccountCache_AccountChanged(pszID);
            if (pszOldName != NULL)
            {
                hr = g_pStore->FindServerId(pszID, &id);
                if (SUCCEEDED(hr))
                {
                    if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszID, &pAccount)))
                    {
                        hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szName, ARRAYSIZE(szName));
                        Assert(SUCCEEDED(hr));

                        hr = g_pStore->RenameFolder(id, szName, NOFLAGS, NOSTORECALLBACK);
                        Assert(SUCCEEDED(hr));

                        pAccount->Release();
                    }
                }
            }
            break;
    }
}

// -----------------------------------------------------------------------------
// AcctUtil_HrCreateAccountMenu
// -----------------------------------------------------------------------------
#define CCHMAX_RES 255
HRESULT AcctUtil_HrCreateAccountMenu(ACCOUNTMENUTYPE type, HMENU hPopup, UINT uidmPopup, 
    HMENU *phAccounts, LPACCTMENU *pprgAccount, ULONG *pcAccounts, LPSTR pszThisAccount, BOOL fMail)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               cAccounts=0;
    IImnEnumAccounts   *pEnum=NULL;
    IImnAccount        *pAccount=NULL;
    CHAR                szDefault[CCHMAX_ACCOUNT_NAME];
    CHAR                szAccount[CCHMAX_ACCOUNT_NAME];
    CHAR                szQuoted[CCHMAX_ACCOUNT_NAME + CCHMAX_ACCOUNT_NAME + CCHMAX_RES];
    LPACCTMENU          prgAccount=NULL;
    HMENU               hAccounts=NULL;
    MENUITEMINFO        mii;
    UINT                uPos=0;
    ULONG               iAccount=0;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szRes1[CCHMAX_RES];
    CHAR                szRes2[CCHMAX_RES];
    UINT                idmFirst;
    CHAR                szTitle[CCHMAX_RES + CCHMAX_RES + CCHMAX_ACCOUNT_NAME];
    BOOL                fNeedUsingMenu = FALSE;

    // Check Parameters
    Assert(g_pAcctMan && phAccounts && pprgAccount && pcAccounts);

    // Init
    *szDefault = '\0';
    *pprgAccount = NULL;
    *pcAccounts = 0;
    *phAccounts = NULL;

    if (type == ACCTMENU_SENDLATER)
        idmFirst = ID_SEND_LATER_ACCOUNT_FIRST;
    else
        idmFirst = ID_SEND_NOW_ACCOUNT_FIRST;

    // Verify Default SMTP Account
    CHECKHR(hr = g_pAcctMan->ValidateDefaultSendAccount());

    // Get the default
    CHECKHR(hr = hr = g_pAcctMan->GetDefaultAccountName(ACCT_MAIL, szDefault, ARRAYSIZE(szDefault)));

    // Enumerate through the server types
    CHECKHR(hr = g_pAcctMan->Enumerate(((ACCTMENU_SEND == type || ACCTMENU_SENDLATER == type) ? SRV_SMTP : SRV_SMTP | SRV_POP3), &pEnum));

    // sort the accoutns
    CHECKHR(hr = pEnum->SortByAccountName());

    // Get Count
    CHECKHR(hr = pEnum->GetCount(&cAccounts));

    // No Accounts
    if (cAccounts == 0)
        goto exit;

    // Exceeded menu ids...
    Assert(cAccounts <= 50);

    // Add one if ACCTMENU_SENDRECV
    if (ACCTMENU_SENDRECV == type)
        cAccounts++;

    // Allocate prgAccount
    CHECKALLOC(prgAccount = (LPACCTMENU)g_pMalloc->Alloc(cAccounts * sizeof(ACCTMENU)));

    // Zero Init
    ZeroMemory(prgAccount, cAccounts * sizeof(ACCTMENU));

    // Only one account
    if (((ACCTMENU_SENDRECV == type) && (cAccounts == 2)) ||
        (cAccounts == 1) || !fMail)
    {
        // Return default Account
        prgAccount[iAccount].fDefault = TRUE;
        prgAccount[iAccount].fThisAccount = TRUE;
        StrCpyN(prgAccount[iAccount].szAccount, szDefault, ARRAYSIZE(prgAccount[iAccount].szAccount));

        // Return Everything
        *pprgAccount = prgAccount;
        prgAccount = NULL;
        *pcAccounts = cAccounts;

        // Done
        goto exit;
    }

    // Create a Menu
    CHECKALLOC(hAccounts = CreatePopupMenu());

    // if not using a specific account or the account is illegal, then let's default to the default-account
    if (pszThisAccount==NULL || *pszThisAccount == NULL || IsValidSendAccount(pszThisAccount)!=S_OK)
        pszThisAccount = szDefault;

    // Lets insert the default item
    if ((ACCTMENU_SENDLATER == type || ACCTMENU_SEND == type) && !FIsEmptyA(szDefault))
    {
        // Load String
        StrCpyN(szTitle, pszThisAccount, ARRAYSIZE(szTitle));

        prgAccount[iAccount].fDefault = lstrcmpi(pszThisAccount, szDefault)==0;

        // if this is the default, flag it.
        if (prgAccount[iAccount].fDefault)
            {
            AthLoadString(idsDefaultAccount, szRes1, ARRAYSIZE(szRes1));
            StrCatBuff(szTitle, " ", ARRAYSIZE(szTitle));
            StrCatBuff(szTitle, szRes1, ARRAYSIZE(szTitle));
            }

        if (((ACCTMENU_SEND == type && DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline()) ||
           (ACCTMENU_SENDLATER == type && (!DwGetOption(OPT_SENDIMMEDIATE) || g_pConMan->IsGlobalOffline()))))
            {
            // if this menu is the default action add the 'Alt+S' accelerator string
            AthLoadString(idsSendMsgAccelTip, szRes, ARRAYSIZE(szRes));
            StrCatBuff(szTitle, "\t", ARRAYSIZE(szTitle));
            StrCatBuff(szTitle, szRes, ARRAYSIZE(szTitle));
            }

        // Get mii ready
        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.fState = MFS_DEFAULT;       // first item is the default verb
        mii.dwTypeData = PszEscapeMenuStringA(szTitle, szQuoted, sizeof(szQuoted) / sizeof(char));
        mii.cch = lstrlen(szQuoted);
        mii.wID = idmFirst + uPos;

        // Set acctmenu item
        prgAccount[iAccount].fThisAccount= TRUE;
        prgAccount[iAccount].uidm = mii.wID;
        StrCpyN(prgAccount[iAccount].szAccount, pszThisAccount, ARRAYSIZE(prgAccount[iAccount].szAccount));
        iAccount++;

        // Insert the item
        if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
        {
            uPos++;
            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_SEPARATOR;
            if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
                uPos++;
        }
    }

    // Otherwise Send & Receive
    else if (ACCTMENU_SENDRECV == type)
    {
        // Setup Menu
        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.fState = MFS_DEFAULT;
        AthLoadString(idsPollAllAccounts, szRes, ARRAYSIZE(szRes));
        mii.dwTypeData = szRes;
        mii.cch = lstrlen(szRes);
        mii.wID = idmFirst + uPos;

        // Set acctmenu item
        prgAccount[iAccount].fDefault = TRUE;
        prgAccount[iAccount].uidm = mii.wID;
        *prgAccount[iAccount].szAccount = '\0';
        iAccount++;

        // Insert the item
        if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
        {
            uPos++;
            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_SEPARATOR;
            if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
                uPos++;
        }
    }

    // Standard
    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE | MIIM_ID;
    mii.fType = MFT_STRING;

    // Loop accounts
    while(SUCCEEDED(pEnum->GetNext(&pAccount)))
    {
        // Get Account Name
        CHECKHR(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount)));

        // Skip the 'This' account. Note for the send & receive menu this will always be the default
        if (lstrcmpi(pszThisAccount, szAccount) == 0)
        {
            // We've already added this account
            if (ACCTMENU_SEND == type || ACCTMENU_SENDLATER == type)
            {
                SafeRelease(pAccount);
                continue;
            }

            // Otherwise, Account (Default)
            else
            {
                // for send a recieve menu pszThisAccount should == szDefault
                Assert (pszThisAccount == szDefault);
                // Load String
                AthLoadString(idsDefaultAccount, szRes, ARRAYSIZE(szRes));

                // Make String - Saranac (Default)
                wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s %s", szAccount, szRes);

                // Setup the menu item name
                mii.dwTypeData = PszEscapeMenuStringA(szTitle, szQuoted, sizeof(szQuoted) / sizeof(char));
                mii.cch = lstrlen(szQuoted);
                prgAccount[iAccount].fDefault = TRUE;
            }
        }

        else
        {
            *szTitle=0;

            // this might be the default
            prgAccount[iAccount].fDefault = lstrcmpi(szAccount, szDefault)==0;

            // build the string on the fly as any one of these accounts might be the 'default'
            PszEscapeMenuStringA(szAccount, szTitle, sizeof(szTitle) / sizeof(char));

            // if this is the default, flag it.
            if (prgAccount[iAccount].fDefault)
                {
                AthLoadString(idsDefaultAccount, szRes1, ARRAYSIZE(szRes1));
                StrCatBuff(szTitle, " ", ARRAYSIZE(szTitle));
                StrCatBuff(szTitle, szRes1, ARRAYSIZE(szTitle));
                }


            // Setup the menu item name
            mii.dwTypeData = szTitle;
            mii.cch = lstrlen(szTitle);
        }

        // Insert into menu
        mii.wID = idmFirst + uPos;
        if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
            uPos++;

        // Set acctmenu item
        Assert(iAccount < cAccounts);
        prgAccount[iAccount].uidm = mii.wID;
        StrCpyN(prgAccount[iAccount].szAccount, szAccount, ARRAYSIZE(prgAccount[iAccount].szAccount));
        iAccount++;

        // Release Account
        SafeRelease(pAccount);
    }

    // Return Everything
    *phAccounts = hAccounts;
    hAccounts = NULL;
    *pprgAccount = prgAccount;
    prgAccount = NULL;
    *pcAccounts = cAccounts;

exit:
    // Lets Setup the Accounts Menu
    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(MENUITEMINFO);
    fNeedUsingMenu = (cAccounts <= 1) || !fMail;
    if (ACCTMENU_SEND == type)
    {
        mii.fMask = MIIM_SUBMENU | MIIM_TYPE;

        if (fNeedUsingMenu)
            {
            AthLoadString(idsSendMsgOneAccount, szRes, ARRAYSIZE(szRes));
            AthLoadString(idsSendMsgAccelTip, szRes1, ARRAYSIZE(szRes1));
        
            // If send now is default, add the Alt + S at the end
            if (DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline())
                wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s\t%s", szRes, szRes1);
            else
                wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s", szRes);
            }
        else
            AthLoadString(idsSendMsgUsing, szTitle, ARRAYSIZE(szTitle));

        mii.fType = MFT_STRING;
        mii.dwTypeData = szTitle;
        mii.cch = lstrlen(szTitle);
        mii.hSubMenu = fNeedUsingMenu ? NULL : *phAccounts;
    }
    else if (ACCTMENU_SENDLATER == type)
    {
        if (fNeedUsingMenu)
            {
            AthLoadString(idsSendLaterOneAccount, szRes, ARRAYSIZE(szRes));
            AthLoadString(idsSendMsgAccelTip, szRes1, ARRAYSIZE(szRes1));
        
            // If send now is default, add the Alt + S at the end
            if (!DwGetOption(OPT_SENDIMMEDIATE) || g_pConMan->IsGlobalOffline())
                wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s\t%s", szRes, szRes1);
            else
                wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s", szRes);
            }
        else
            AthLoadString(idsSendLaterUsing, szTitle, ARRAYSIZE(szTitle));

        mii.fMask = MIIM_SUBMENU | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.dwTypeData = szTitle;
        mii.cch = lstrlen(szTitle);
        mii.hSubMenu = fNeedUsingMenu ? NULL : *phAccounts;
    }
    else
    {
        mii.fMask = MIIM_SUBMENU | MIIM_TYPE;
        AthLoadString(fNeedUsingMenu ? idsSendRecvOneAccount : idsSendRecvUsing, szRes, ARRAYSIZE(szRes));
        mii.fType = MFT_STRING;
        mii.dwTypeData = szRes;
        mii.cch = lstrlen(szRes);
        mii.hSubMenu = fNeedUsingMenu ? NULL : *phAccounts;
    }

    // Set the menu item
    SideAssert(SetMenuItemInfo(hPopup, uidmPopup, FALSE, &mii));

    // Cleanup
    SafeRelease(pEnum);
    SafeRelease(pAccount);
    SafeMemFree(prgAccount);
    if (hAccounts)
        DestroyMenu(hAccounts);

    // Done
    return hr;
}

HRESULT AcctUtil_GetServerCount(DWORD dwSrvTypes, DWORD *pcSrv)
{
    HRESULT hr;
    IImnEnumAccounts *pEnum;

    Assert(dwSrvTypes != 0);
    Assert(pcSrv != NULL);

    hr = g_pAcctMan->Enumerate(dwSrvTypes, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->GetCount(pcSrv);
        Assert(SUCCEEDED(hr));

        pEnum->Release();
    }

    return(hr);
}

/////////////////////////////////////////////////////////////////////////////
// CNewAcctMonitor
//

CNewAcctMonitor::CNewAcctMonitor()
    {
    m_cRef = 1;
    m_rgAccounts = NULL;
    m_cAlloc = 0;
    m_cAccounts = 0;
    m_fMonitor = FALSE;
    }

CNewAcctMonitor::~CNewAcctMonitor()
    {
    Assert(m_rgAccounts == NULL);
    }

ULONG CNewAcctMonitor::AddRef(void)
    {
    return (++m_cRef);
    }

ULONG CNewAcctMonitor::Release(void)
    {
    ULONG cRefT = --m_cRef;

    if (0 == m_cRef)
        delete this;

    return (cRefT);
    }

void CNewAcctMonitor::OnAdvise(ACCTTYPE atType, DWORD dwNotify, LPCSTR pszAcctId)
    {
    UINT i;
    IImnAccount *pAccount;
    DWORD dwSrvTypes;
    HRESULT hr;
    FOLDERTYPE type;

    if (atType == ACCT_DIR_SERV)
        return;

    switch (dwNotify)
        {
        case AN_ACCOUNT_ADDED:
            if (atType == ACCT_MAIL)
            {
                if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAcctId, &pAccount)))
                    break;

                hr = pAccount->GetServerTypes(&dwSrvTypes);
                Assert(SUCCEEDED(hr));

                pAccount->Release();

                if (!!(dwSrvTypes & SRV_IMAP))
                    type = FOLDER_IMAP;
                else if (!!(dwSrvTypes & SRV_HTTPMAIL))
                    type = FOLDER_HTTPMAIL;
                else
                    break;
            }
            else
            {
                Assert(atType == ACCT_NEWS);
                type = FOLDER_NEWS;
            }

            // Check to see if we need to grow our array
            if ((1 + m_cAccounts) >= m_cAlloc)
                {                
                if (!MemRealloc((LPVOID *)&m_rgAccounts, sizeof(NEWACCTINFO) * (10 + m_cAlloc)))
                    break;

                m_cAlloc += 10;
                }

            m_rgAccounts[m_cAccounts].pszAcctId = PszDupA(pszAcctId);
            m_rgAccounts[m_cAccounts].type = type;
            m_cAccounts++;
            break; 

        case AN_ACCOUNT_DELETED:
            // Check to see if we've already added this to our list.
            for (i = 0; i < m_cAccounts; i++)
                {
                if (0 == lstrcmpi(pszAcctId, m_rgAccounts[i].pszAcctId))
                    {
                    // We found it.  We need to remove it, and adjust our array
                    MemFree(m_rgAccounts[i].pszAcctId);
                    m_cAccounts--;
                    for (; i < m_cAccounts; i++)
                        m_rgAccounts[i] = m_rgAccounts[i + 1];
                    break;
                    }
                }
            break;
        }
    }

void CNewAcctMonitor::StartMonitor(void)
    {
    Assert(m_rgAccounts == NULL);
    Assert(m_cAccounts == NULL);
    Assert(m_fMonitor == FALSE);

    m_fMonitor = TRUE;
    }

void CNewAcctMonitor::StopMonitor(HWND hwndParent)
    {
    FOLDERID id;
    HRESULT hr;
    UINT i;

    Assert(m_fMonitor == TRUE);

    // If we have any new newsgroups left, ask if the user want's to display
    // the subscription dialog.
    if (m_cAccounts != 0)
    {
        int     ResId;
        BOOL    fOffline = (g_pConMan  && g_pConMan->IsGlobalOffline());

        if (m_rgAccounts[0].type == FOLDER_NEWS)
        {
            ResId = fOffline ? idsDisplayNewsSubDlgOffline : idsDisplayNewsSubDlg;
        }
        else
        {
            ResId = fOffline ? idsDisplayImapSubDlgOffline : idsDisplayImapSubDlg;
        }

        if (IDYES == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(ResId), 0, MB_ICONEXCLAMATION  | MB_YESNO))
        {
            hr = g_pStore->FindServerId(m_rgAccounts[0].pszAcctId, &id);
            if (SUCCEEDED(hr))
            {
                if (fOffline)
                    g_pConMan->SetGlobalOffline(FALSE);

                if (FOLDER_HTTPMAIL == m_rgAccounts[0].type)
                    DownloadNewsgroupList(hwndParent, id);
                else
                    DoSubscriptionDialog(hwndParent, m_rgAccounts[0].type == FOLDER_NEWS, id);
            }
        }
    }   

    for (i = 0; i < m_cAccounts; i++)
    {
        if (m_rgAccounts[i].pszAcctId != NULL)
            MemFree(m_rgAccounts[i].pszAcctId);
    }
    m_cAccounts = 0;
    m_cAlloc = 0;

    SafeMemFree(m_rgAccounts);
    m_fMonitor = FALSE;
    }


void CheckIMAPDirty(LPSTR pszAccountID, HWND hwndParent, FOLDERID idServer,
                    DWORD dwFlags)
{
    HRESULT         hr;
    IImnAccount    *pAcct = NULL;
    DWORD           dw;

    TraceCall("CheckIMAPDirty");

    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccountID, &pAcct);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pAcct->GetPropDw(AP_IMAP_DIRTY, &dw);
    if (FAILED(hr) || 0 == dw)
    {
        TraceError(hr);
        goto exit;
    }

    // IMAP is dirty, deal with each dirty flag
    if ((dw & IMAP_OE4MIGRATE_DIRTY) && FOLDERID_INVALID != idServer && NULL != g_pStore)
    {
        IEnumerateFolders  *pEnum;
        BOOL                fSentItems = FALSE;
        BOOL                fDrafts = FALSE;
        BOOL                fInbox = FALSE;

        Assert(0 == (dw & IMAP_OE4MIGRATE_DIRTY) || (dw & IMAP_FLDRLIST_DIRTY));

        // We may or may not be dirty. Check if all IMAP special fldrs already present
        hr = g_pStore->EnumChildren(idServer, FALSE, &pEnum);
        TraceError(hr);
        if (SUCCEEDED(hr))
        {
            FOLDERINFO  fiFolderInfo;

            while (S_OK == pEnum->Next(1, &fiFolderInfo, NULL))
            {
                switch (fiFolderInfo.tySpecial)
                {
                    case FOLDER_INBOX:
                        fInbox = TRUE;
                        break;

                    case FOLDER_SENT:
                        fSentItems = TRUE;
                        break;

                    case FOLDER_DRAFT:
                        fDrafts = TRUE;
                        break;
                }

                g_pStore->FreeRecord(&fiFolderInfo);
            }

            pEnum->Release();
        }

        if (fInbox && fSentItems && fDrafts)
        {
            // All special folders present: remove dirty flags
            dw &= ~(IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY);
        }
    }


    if (dw & IMAP_FLDRLIST_DIRTY)
    {
        int     iResult;

        // Ask user if he would like to reset his folderlist
        if (0 == (dwFlags & CID_NOPROMPT))
        {
            UINT    uiReasonStrID;

            AssertSz(0 == (dwFlags & CID_RESETLISTOK), "If I have permission to reset, why prompt?");

            // Figure out why we are asking to refresh the folderlist
            if (dw & IMAP_OE4MIGRATE_DIRTY)
                uiReasonStrID = idsOE5IMAPSpecialFldrs;
            else
                uiReasonStrID = idsYouMadeChanges;

            iResult = AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena),
                MAKEINTRESOURCEW(uiReasonStrID), MAKEINTRESOURCEW(idsRefreshFolderListPrompt),
                MB_ICONEXCLAMATION  | MB_YESNO);
        }
        else
            iResult = (dwFlags & CID_RESETLISTOK) ? IDYES : IDNO;

        if (IDYES == iResult)
        {
            if (FOLDERID_INVALID == idServer)
            {
                hr = g_pStore->FindServerId(pszAccountID, &idServer);
                TraceError(hr);
            }

            if (FOLDERID_INVALID != idServer)
            {
                //The user wants to download the list of newsgroups, so if we are offline, go online
                if (g_pConMan)
                    g_pConMan->SetGlobalOffline(FALSE);

                hr = DownloadNewsgroupList(hwndParent, idServer);
                TraceError(hr);
                if (SUCCEEDED(hr))
                {
                    // The sent items and drafts folders should not be dirty any longer
                    dw &= ~(IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY);
                }
            }
        }

        // Regardless of yes or no, reset dirty flag
        dw &= ~(IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY);
    }


    if (dw & (IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY))
    {
        IEnumerateFolders  *pEnum;
        char                szSentItems[MAX_PATH];
        char                szDrafts[MAX_PATH];
        DWORD               dwIMAPSpecial = 0;
        BOOL                fSetSentItems = FALSE;
        BOOL                fSetDrafts = FALSE;

        // Remove all affected special folder types from cache. If new path is
        // found in folderlist, set its special folder type
        szSentItems[0] = '\0';
        szDrafts[0] = '\0';
        hr = pAcct->GetPropDw(AP_IMAP_SVRSPECIALFLDRS, &dwIMAPSpecial);
        if (SUCCEEDED(hr) && dwIMAPSpecial)
        {
            if (dw & IMAP_SENTITEMS_DIRTY)
            {
                hr = pAcct->GetPropSz(AP_IMAP_SENTITEMSFLDR, szSentItems, ARRAYSIZE(szSentItems));
                TraceError(hr);
            }

            if (dw & IMAP_DRAFTS_DIRTY)
            {
                hr = pAcct->GetPropSz(AP_IMAP_DRAFTSFLDR, szDrafts, ARRAYSIZE(szDrafts));
                TraceError(hr);
            }
        }

        hr = g_pStore->EnumChildren(idServer, FALSE, &pEnum);
        TraceError(hr);
        if (SUCCEEDED(hr))
        {
            FOLDERINFO  fiFolderInfo;

            while (S_OK == pEnum->Next(1, &fiFolderInfo, NULL))
            {
                BOOL    fUpdate = FALSE;

                if (dw & IMAP_SENTITEMS_DIRTY)
                {
                    if (0 == lstrcmp(szSentItems, fiFolderInfo.pszName))
                    {
                        fiFolderInfo.tySpecial = FOLDER_SENT;
                        fUpdate = TRUE;
                        fSetSentItems = TRUE;

                        // IE5 Bug #62765: if new special folder is unsubscribed, we need to subscribe it
                        if (0 == (fiFolderInfo.dwFlags & FOLDER_SUBSCRIBED))
                            fiFolderInfo.dwFlags |= FOLDER_SUBSCRIBED | FOLDER_CREATEONDEMAND;
                    }
                    else if (FOLDER_SENT == fiFolderInfo.tySpecial)
                    {
                        // Ignore FOLDER_HIDDEN. I'm assuming it's no big deal to leave a tombstone
                        fiFolderInfo.tySpecial = FOLDER_NOTSPECIAL;
                        fUpdate = TRUE;
                    }
                }

                if (dw & IMAP_DRAFTS_DIRTY)
                {
                    if (0 == lstrcmp(szDrafts, fiFolderInfo.pszName))
                    {
                        fiFolderInfo.tySpecial = FOLDER_DRAFT;
                        fUpdate = TRUE;
                        fSetDrafts = TRUE;

                        // IE5 Bug #62765: if new special folder exists and is unsubscribed, we must subscribe it
                        if (0 == (fiFolderInfo.dwFlags & FOLDER_SUBSCRIBED))
                            fiFolderInfo.dwFlags |= FOLDER_SUBSCRIBED | FOLDER_CREATEONDEMAND;
                    }
                    else if (FOLDER_DRAFT == fiFolderInfo.tySpecial)
                    {
                        // Ignore FOLDER_HIDDEN. I'm assuming it's no big deal to leave a tombstone
                        fiFolderInfo.tySpecial = FOLDER_NOTSPECIAL;
                        fUpdate = TRUE;
                    }
                }

                if (fUpdate)
                {
                    hr = g_pStore->UpdateRecord(&fiFolderInfo);
                    TraceError(hr);
                }

                g_pStore->FreeRecord(&fiFolderInfo);
            } // while

            pEnum->Release();
        } // if (SUCCEEDED(EnumChildren))

        // If the new special folder path(s) not found in folderlist, need to create placeholder folder
        if (dwIMAPSpecial && (dw & IMAP_SENTITEMS_DIRTY) && FALSE == fSetSentItems && '\0' != szSentItems[0])
        {
            FOLDERINFO fiFolderInfo;
            BOOL       bHierarchy = 0xFF; // Invalid hierarchy char

            hr = g_pStore->GetFolderInfo(idServer, &fiFolderInfo);
            if (SUCCEEDED(hr))
            {
                bHierarchy = fiFolderInfo.bHierarchy;
                g_pStore->FreeRecord(&fiFolderInfo);
            }

            ZeroMemory(&fiFolderInfo, sizeof(fiFolderInfo));
            fiFolderInfo.idParent = idServer;
            fiFolderInfo.pszName = szSentItems;
            fiFolderInfo.dwFlags = FOLDER_HIDDEN | FOLDER_SUBSCRIBED | FOLDER_CREATEONDEMAND;
            fiFolderInfo.tySpecial = FOLDER_SENT;
            fiFolderInfo.tyFolder = FOLDER_IMAP;
            fiFolderInfo.bHierarchy = (BYTE)bHierarchy;

            hr = g_pStore->CreateFolder(CREATE_FOLDER_LOCALONLY, &fiFolderInfo, NULL);
            TraceError(hr);
        }

        if (dwIMAPSpecial && (dw & IMAP_DRAFTS_DIRTY) && FALSE == fSetDrafts && '\0' != szDrafts[0])
        {
            FOLDERINFO fiFolderInfo;
            BOOL       bHierarchy = 0xFF; // Invalid hierarchy char

            hr = g_pStore->GetFolderInfo(idServer, &fiFolderInfo);
            if (SUCCEEDED(hr))
            {
                bHierarchy = fiFolderInfo.bHierarchy;
                g_pStore->FreeRecord(&fiFolderInfo);
            }

            ZeroMemory(&fiFolderInfo, sizeof(fiFolderInfo));
            fiFolderInfo.idParent = idServer;
            fiFolderInfo.pszName = szDrafts;
            fiFolderInfo.dwFlags = FOLDER_HIDDEN | FOLDER_SUBSCRIBED | FOLDER_CREATEONDEMAND;
            fiFolderInfo.tySpecial = FOLDER_DRAFT;
            fiFolderInfo.tyFolder = FOLDER_IMAP;
            fiFolderInfo.bHierarchy = (BYTE)bHierarchy;

            hr = g_pStore->CreateFolder(CREATE_FOLDER_LOCALONLY, &fiFolderInfo, NULL);
            TraceError(hr);
        }

        // Regardless of error, reset dirty flag
        dw &= ~(IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY);

    } // if (dw & (IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY))

    AssertSz(0 == dw, "Unhandled IMAP dirty flag");

    // Reset IMAP dirty property
    hr = pAcct->SetPropDw(AP_IMAP_DIRTY, dw);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Save changes
    hr = pAcct->SaveChanges();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (NULL != pAcct)
        pAcct->Release();
}


void CheckAllIMAPDirty(HWND hwndParent)
{
    HRESULT             hrResult;
    IImnEnumAccounts   *pAcctEnum = NULL;
    IImnAccount        *pAcct = NULL;
    BOOL                fPromptedUser = FALSE;
    BOOL                fPermissionToReset = FALSE;

    TraceCall("CheckAllIMAPDirty");

    if (NULL == g_pAcctMan)
        return;

    hrResult = g_pAcctMan->Enumerate(SRV_IMAP, &pAcctEnum);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Enumerate through ALL IMAP accounts (even if user denied permission to reset list)
    hrResult = pAcctEnum->GetNext(&pAcct);
    while(SUCCEEDED(hrResult))
    {
        DWORD       dwIMAPDirty;

        // Is this IMAP account dirty?
        hrResult = pAcct->GetPropDw(AP_IMAP_DIRTY, &dwIMAPDirty);
        if (FAILED(hrResult))
            dwIMAPDirty = 0;

        if (dwIMAPDirty & IMAP_FLDRLIST_DIRTY)
        {
            // Prompt user only once to see if he would like to refresh folder list
            if (FALSE == fPromptedUser)
            {
                int iResult;

                iResult = AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsYouMadeChangesOneOrMore),
                    MAKEINTRESOURCEW(idsRefreshFolderListPrompt),
                    MB_ICONEXCLAMATION | MB_YESNO);
                if (IDYES == iResult)
                    fPermissionToReset = TRUE;

                fPromptedUser = TRUE;
            } // if (FALSE == fPromptedUser)

        }

        if (dwIMAPDirty)
        {
            FOLDERID    idServer;
            char        szAccountID[CCHMAX_ACCOUNT_NAME];

            hrResult = pAcct->GetPropSz(AP_ACCOUNT_ID, szAccountID, ARRAYSIZE(szAccountID));
            TraceError(hrResult);
            if (SUCCEEDED(hrResult))
            {
                hrResult = g_pStore->FindServerId(szAccountID, &idServer);
                TraceError(hrResult);
                if (SUCCEEDED(hrResult))
                {
                    CheckIMAPDirty(szAccountID, hwndParent, idServer,
                        CID_NOPROMPT | (fPermissionToReset ? CID_RESETLISTOK : 0));
                }
            }
        }

        // Load in the next IMAP account
        SafeRelease(pAcct);
        hrResult = pAcctEnum->GetNext(&pAcct);

    } // while

exit:
    SafeRelease(pAcctEnum);
    SafeRelease(pAcct);
}



void DoAccountListDialog(HWND hwnd, ACCTTYPE type)
    {
    ACCTLISTINFO ali;

    // Create the monitor
    if (NULL == g_pNewAcctMonitor)
        g_pNewAcctMonitor = new CNewAcctMonitor();

    if (g_pNewAcctMonitor)
        g_pNewAcctMonitor->StartMonitor();

    Assert(g_pAcctMan != NULL);

    ali.cbSize = sizeof(ACCTLISTINFO);
    ali.AcctTypeInit = type;

    if (g_dwAthenaMode & MODE_NEWSONLY)
        ali.dwAcctFlags = ACCT_FLAG_NEWS | ACCT_FLAG_DIR_SERV;
    else if (g_dwAthenaMode & MODE_MAILONLY)
        ali.dwAcctFlags = ACCT_FLAG_MAIL | ACCT_FLAG_DIR_SERV;
    else
        ali.dwAcctFlags = ACCT_FLAG_ALL;

    ali.dwFlags = ACCTDLG_SHOWIMAPSPECIAL | ACCTDLG_OE;

    //Account wizard uses this flag to distinguish between OE and outlook.
    ali.dwFlags |= (ACCTDLG_INTERNETCONNECTION | ACCTDLG_HTTPMAIL);

    // Revocation checking flag
    if((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline())
        ali.dwFlags |= ACCTDLG_REVOCATION;

    g_pAcctMan->AccountListDialog(hwnd, &ali);

    if (g_pNewAcctMonitor)
        {
        g_pNewAcctMonitor->StopMonitor(hwnd);
        g_pNewAcctMonitor->Release();
        g_pNewAcctMonitor = 0;
        }

    // Look for any dirty IMAP accounts
    CheckAllIMAPDirty(hwnd);
    }

HRESULT IsValidSendAccount(LPSTR pszAccount)
{
    IImnAccount  *pAccount;
    DWORD        dwSrvTypes=0;

    if (g_pAcctMan &&
        g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pszAccount, &pAccount)==S_OK)
        {
        pAccount->GetServerTypes(&dwSrvTypes);
        pAccount->Release();
        return dwSrvTypes & SRV_SMTP ? S_OK : S_FALSE;
        }

    return S_FALSE;
}


HRESULT AcctUtil_CreateSendReceieveMenu(HMENU hMenu, DWORD *pcItems)
{
    IImnAccount        *pAccount;
    TCHAR               szDefaultAccount[CCHMAX_ACCOUNT_NAME];
    HRESULT             hr;
    IImnEnumAccounts   *pEnum;
    DWORD               cAccounts = 0;
    TCHAR               szTitle[CCHMAX_ACCOUNT_NAME + 30];
    TCHAR               szAccountQuoted[CCHMAX_ACCOUNT_NAME + 60];
    TCHAR               szDefaultString[CCHMAX_STRINGRES];
    TCHAR               szAccount[CCHMAX_ACCOUNT_NAME];
    TCHAR               szTruncAcct[128];
    MENUITEMINFO        mii;
    DWORD               iAccount = 0;
    LPTSTR              pszAccount;
    LPSTR               pszAcctID;
    
    // Get the default account's ID.  If this fails we just go on.
    if (SUCCEEDED(hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount)))
    {
        // Get the account ID from the default account
        pAccount->GetPropSz(AP_ACCOUNT_NAME, szDefaultAccount, ARRAYSIZE(szDefaultAccount));
        pAccount->Release();
    }

    if (!(g_dwAthenaMode & MODE_NEWSONLY))
    {
        // Enumerate through the servers
        if (SUCCEEDED(hr = g_pAcctMan->Enumerate(SRV_SMTP | SRV_POP3 | SRV_HTTPMAIL, &pEnum)))
        {
            // Sort the accounts.  If this fails, we just go on.
            pEnum->SortByAccountName();

            // Get the number of accounts we'll be enumerating
            if (SUCCEEDED(hr = pEnum->GetCount(&cAccounts)))
            {
                // If there are zero accounts, there's nothing to do.
                if (0 != cAccounts)
                {
                    // Make sure we have enough ID's reserved for this
                    Assert(cAccounts < ID_ACCOUNT_LAST - ID_ACCOUNT_FIRST);

                    // Set this struct up before we start
                    ZeroMemory(&mii, sizeof(MENUITEMINFO));
                    mii.cbSize = sizeof(MENUITEMINFO);
                    mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
                    mii.fType = MFT_STRING;

                    // Loop through the accounts
                    while (SUCCEEDED(pEnum->GetNext(&pAccount)))
                    {
                        if (MemAlloc((LPVOID *) &pszAcctID, sizeof(TCHAR) * CCHMAX_ACCOUNT_NAME))
                        {
                            // Get the name of the account
                            pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, CCHMAX_ACCOUNT_NAME);
                            pAccount->GetPropSz(AP_ACCOUNT_ID, pszAcctID, CCHMAX_ACCOUNT_NAME);

                            // If this account is the default account, we need to append
                            // "(Default)" to the end.  Limit the string to 80 since Win95 seems 
                            // to have some problems with really really long menus.
                            if (0 == lstrcmp(szAccount, szDefaultAccount))
                            {
                                AthLoadString(idsDefaultAccount, szDefaultString, ARRAYSIZE(szDefaultString));
                                StrCpyN(szTruncAcct, szAccount, 80);
                                wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s %s", szTruncAcct, szDefaultString);
                            }
                            else
                            {
                                StrCpyN(szTitle, szAccount, 80);
                            }

                            // For account names with "&" characters like AT&T, we need to 
                            // quote the "&".
                            PszEscapeMenuStringA(szTitle, szAccountQuoted, ARRAYSIZE(szAccountQuoted));

                            // Fill in the struct
                            mii.wID = ID_ACCOUNT_FIRST + iAccount; 
                            mii.dwItemData = (DWORD_PTR) pszAcctID;
                            mii.dwTypeData = szAccountQuoted;

                            // Append the item
                            InsertMenuItem(hMenu, -1, TRUE, &mii);

                            // Increment the count
                            iAccount++;
                        }
                        // Release the account pointer
                        pAccount->Release();
                    }
                }
            }

            // Release the enumerator
            pEnum->Release();

            Assert(iAccount == cAccounts);
        }
    }
    else
    {
        //Remove Seperator in NEWSONLY mode.
        int     ItemCount;

        ItemCount = GetMenuItemCount(hMenu);
        if (ItemCount != -1)
        {
            DeleteMenu(hMenu, ItemCount - 1, MF_BYPOSITION);
        }
    }

    //iAccount could be less than cAccounts if we are in news only mode.
    if (pcItems)
        *pcItems = cAccounts;

    return (S_OK);
}


HRESULT AcctUtil_FreeSendReceieveMenu(HMENU hMenu, DWORD cItems)
{
    DWORD i;
    MENUITEMINFO mii;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA;

    for (i = 0; i < cItems; i++)
    {
        mii.dwItemData = 0;
        if (GetMenuItemInfo(hMenu, ID_ACCOUNT_FIRST + i, FALSE, &mii))
        {
            if (mii.dwItemData)
                MemFree((LPTSTR) mii.dwItemData);

            DeleteMenu(hMenu, ID_ACCOUNT_FIRST + i, MF_BYCOMMAND);
        }
    }

    return (S_OK);
}

HRESULT AcctUtil_CreateAccountManagerForIdentity(GUID *puidIdentity, IImnAccountManager2 **ppAccountManager)
{
    HRESULT hr;
    IImnAccountManager *pAccountManager = NULL;
    IImnAccountManager2 *pAccountManager2 = NULL;

    *ppAccountManager = NULL;

    if (FAILED(hr = HrCreateAccountManager(&pAccountManager)))
        goto exit;
    
    if (FAILED(hr = pAccountManager->QueryInterface(IID_IImnAccountManager2, (LPVOID *)&pAccountManager2)))
        goto exit;

    // The *puidIdentity does not result in a new GUID object being created (formal param is by reference)
    if (FAILED(hr = pAccountManager2->InitUser(NULL, *puidIdentity, 0)))
        goto exit;

    *ppAccountManager = pAccountManager2;
    pAccountManager2 = NULL;
    
exit:
    SafeRelease(pAccountManager);
    SafeRelease(pAccountManager2);

    return hr;
}

void InitNewAcctMenu(HMENU hmenu)
{
    HKEY    hkey, hkeyT;
    LONG    lResult;
    DWORD   cServices, cb, i, type, cItem, dwMsn;
    char    szKey[MAX_PATH], sz[512], szQuoted[512];
    HMENU   hsubmenu;
    MENUITEMINFO mii;
    LPSTR   pszKey;
    BOOL    fHideHotmail = HideHotmail();

    cItem = 0;
    hsubmenu = NULL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szHTTPMailServiceRoot, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, &cServices, NULL, NULL, NULL, NULL, NULL, NULL, NULL) &&
            cServices > 0)
        {
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
            mii.fType = MFT_STRING;
            
            hsubmenu = CreatePopupMenu();
            if (hsubmenu != NULL)
            {
                // Start Enumerating the keys
                for (i = 0; i < cServices; i++)
                {
                    // Enumerate Friendly Names
                    cb = sizeof(szKey);
                    lResult = RegEnumKeyEx(hkey, i, szKey, &cb, 0, NULL, NULL, NULL);
    
                    // No more items
                    if (lResult == ERROR_NO_MORE_ITEMS)
                        break;
    
                    // Error, lets move onto the next account
                    if (lResult != ERROR_SUCCESS)
                    {
                        Assert(FALSE);
                        continue;
                    }
    
                    if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szKey, 0, KEY_QUERY_VALUE, &hkeyT))
                    {

                        cb = sizeof(dwMsn);
                        if (!fHideHotmail ||
                            ERROR_SUCCESS != RegQueryValueEx(hkeyT, c_szHTTPMailDomainMSN, 0, NULL, (LPBYTE)&dwMsn, &cb) ||
                            dwMsn == 0)

                        {
                            cb = sizeof(sz);
                            if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szHTTPMailSignUp, NULL, &type, (LPBYTE)sz, &cb) &&
                                *sz != 0)
                            {
                                cb = sizeof(sz);
                                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szHTTPMailServiceName, NULL, &type, (LPBYTE)sz, &cb) &&
                                    *sz != 0)
                                {
                                    pszKey = PszDup(szKey);
                                    if (pszKey != NULL)
                                    {
                                        PszEscapeMenuStringA(sz, szQuoted, ARRAYSIZE(szQuoted));

                                        // Fill in the struct
                                        mii.wID = ID_NEW_ACCT_FIRST + cItem; 
                                        mii.dwItemData = (DWORD_PTR)pszKey;
                                        mii.dwTypeData = szQuoted;
                                    
                                        // Append the item
                                        InsertMenuItem(hsubmenu, -1, TRUE, &mii);

                                        cItem++;
                                    }
                                }
                            }
                        }

                        RegCloseKey(hkeyT);
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    if (cItem == 0)
    {
        if (hsubmenu != NULL)
            DestroyMenu(hsubmenu);

        DeleteMenu(hmenu, ID_POPUP_NEW_ACCT, MF_BYCOMMAND);
    }
    else
    {
        Assert(hsubmenu != NULL);
        mii.fMask = MIIM_SUBMENU;
        mii.hSubMenu = hsubmenu;
        SetMenuItemInfo(hmenu, ID_POPUP_NEW_ACCT, FALSE, &mii);
    }
}

void FreeNewAcctMenu(HMENU hmenu)
{
    int i, cItem;
    MENUITEMINFO mii;
    HMENU hsubmenu;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = NULL;

    if (GetMenuItemInfo(hmenu, ID_POPUP_NEW_ACCT, FALSE, &mii) &&
        mii.hSubMenu != NULL)
    {
        hsubmenu = mii.hSubMenu;
        cItem = GetMenuItemCount(hsubmenu);

        mii.fMask = MIIM_DATA;

        for (i = 0; i < cItem; i++)
        {
            mii.dwItemData = 0;
            if (GetMenuItemInfo(hsubmenu, ID_NEW_ACCT_FIRST + i, FALSE, &mii))
            {
                if (mii.dwItemData)
                    MemFree((LPSTR)mii.dwItemData);
            }
        }

        DestroyMenu(hsubmenu);
    }
}

HRESULT HandleNewAcctMenu(HWND hwnd, HMENU hmenu, int id)
{
    MENUITEMINFO mii;
    char    szKey[MAX_PATH], szUrl[512];
    HKEY    hkey;
    DWORD   type, cb, dwUseWizard;
    TCHAR   rgch[MAX_PATH];
    BOOL    bFoundUrl = TRUE;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA|MIIM_TYPE;
    mii.dwItemData = 0;
    mii.dwTypeData = rgch;
    mii.cch = ARRAYSIZE(rgch);

    if (GetMenuItemInfo(hmenu, id, FALSE, &mii) && mii.dwItemData != 0)
    {
        wnsprintf(szKey, ARRAYSIZE(szKey), c_szPathFileFmt, c_szHTTPMailServiceRoot, (LPSTR)mii.dwItemData);
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkey))
        {
            // look for a config url
            cb = sizeof(szUrl);
            if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szHTTPMailConfig, NULL, &type, (LPBYTE)szUrl, &cb))
            {
                // config url wasn't found. fall back to sign up url
                cb = sizeof(szUrl);
                if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szHTTPMailSignUp, NULL, &type, (LPBYTE)szUrl, &cb))
                    bFoundUrl = FALSE;
            }

            if (bFoundUrl)
            {
                cb = sizeof(DWORD);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szHTTPMailUseWizard, NULL, &type, (LPBYTE)&dwUseWizard, &cb) && 
                    dwUseWizard != 0)
                    DoHotMailWizard(GetTopMostParent(hwnd), szUrl, rgch, NULL, NULL);
                else
                    ShellExecute(hwnd, "open", szUrl, NULL, NULL, SW_SHOWNORMAL);
            }
            RegCloseKey(hkey);
        }
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\acctutil.h ===
// --------------------------------------------------------------------------------
// Acctutil.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __ACCTUTIL_H
#define __ACCTUTIL_H

interface INotify;

// --------------------------------------------------------------------------------
// Depends On
// --------------------------------------------------------------------------------
#include "imnact.h"

// --------------------------------------------------------------------------------
// IImnAdviseAccount
// --------------------------------------------------------------------------------
class CImnAdviseAccount : public IImnAdviseAccount
{
private:
    ULONG               m_cRef;
    ULONG               m_cNNTP;

    INotify             *m_pNotify;

public:
    CImnAdviseAccount(void);
    ~CImnAdviseAccount(void);

    HRESULT Initialize(void);

    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP AdviseAccount(DWORD dwAdviseType, ACTX *pactx);

    void HandleAccountChange(ACCTTYPE AcctType, DWORD dwAN, LPTSTR pszAccount, LPTSTR pszOldName, DWORD dwServerTypes);
};

// -----------------------------------------------------------------------------
// Account Menu
// -----------------------------------------------------------------------------
typedef struct tagACCTMENU
{
    BOOL        fDefault,
                fThisAccount;
    UINT        uidm;
    TCHAR       szAccount[CCHMAX_ACCOUNT_NAME];

} ACCTMENU, *LPACCTMENU;

typedef enum tagACCOUNTMENUTYPE {
    ACCTMENU_SEND,
    ACCTMENU_SENDRECV,
    ACCTMENU_SENDLATER
} ACCOUNTMENUTYPE;

HRESULT AcctUtil_HrCreateAccountMenu(ACCOUNTMENUTYPE type, HMENU hPopup, UINT uidmPopup, 
    HMENU *phAccounts, LPACCTMENU *pprgMenu, ULONG *pcMenu, LPSTR pszThisAccount, BOOL fMail);

HRESULT HrConnectAccount(HWND hwnd, IImnAccount *pAccount);
HRESULT HrDisconnectAccount(HWND hwnd, BOOL fShutdown);
HRESULT AcctUtil_GetServerCount(DWORD dwSrvTypes, DWORD *pcSrv);

typedef struct tagNEWACCTINFO
{
    FOLDERTYPE type;
    LPSTR pszAcctId;
} NEWACCTINFO;

class CNewAcctMonitor 
    {
public:
    CNewAcctMonitor();
    ~CNewAcctMonitor();

    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    void OnAdvise(ACCTTYPE atType, DWORD dwNotify, LPCSTR pszAcctId);
    void StartMonitor(void);
    void StopMonitor(HWND hwndParent);

private:
    ULONG    m_cRef;
    BOOL     m_fMonitor;

    NEWACCTINFO *m_rgAccounts;
    ULONG    m_cAlloc;
    ULONG    m_cAccounts;
    };

extern CNewAcctMonitor *g_pNewAcctMonitor;


void CheckIMAPDirty(LPSTR pszAccountID, HWND hwndParent, FOLDERID idServer, DWORD dwFlags);
const DWORD CID_NOPROMPT    = 0x00000001; // For CheckIMAPDirty dwFlags: do not prompt to reset list
const DWORD CID_RESETLISTOK = 0x00000002; // For CheckIMAPDirty dwFlags: user gave permission to reset list

void DoAccountListDialog(HWND hwnd, ACCTTYPE type);
HRESULT AcctUtil_CreateSendReceieveMenu(HMENU hMenu, DWORD *pcItems);
HRESULT AcctUtil_FreeSendReceieveMenu(HMENU hMenu, DWORD cItems);
HRESULT AcctUtil_CreateAccountManagerForIdentity(GUID *puidIdentity, IImnAccountManager2 **ppAccountManager);
void InitNewAcctMenu(HMENU hmenu);
void FreeNewAcctMenu(HMENU hmenu);
HRESULT HandleNewAcctMenu(HWND hwnd, HMENU hmenu, int id);

#endif // __ACCTUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\attman.cpp ===
// ==============================================================================
// 3/2/96 - Attachment Manager Class Implementation (sbailey & brents)
// ==============================================================================
#include "pch.hxx"
#include "strconst.h"
#include <mimeole.h>
#include "mimeutil.h"
#include "mimeolep.h"
#include "attman.h"
#include <error.h>
#include <resource.h>
#include "header.h"
#include "note.h"
#include <thormsgs.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include "fonts.h"
#include "secutil.h"
#include <mailnews.h>
#include <multiusr.h>
#include <menures.h>
#include <menuutil.h>
#include <demand.h>     // must be last!
#include "mirror.h"

// for dialog idc's
#include "fexist.h"


/*
 *  c o n s t a n t s
 */
#define CNUMICONSDEFAULT        10
#define CACHE_GROW_SIZE         10
#define MAX_ATTACH_PIXEL_HEIGHT 100

/*
 *  m a c r o s
 */

/*
 *  t y p e s
 *
 */

/*
 *  c o n s t a n t s
 *
 */

/*
 *  g l o b a l s
 *
 */

/*
 *  p r o t o t y p e s
 *
 */

// ==============================================================================
// CAttMan::CAttMan
// ==============================================================================
CAttMan::CAttMan ()
{
    DOUT ("CAttMan::CAttMan");
    m_pMsg = NULL;
    m_himlSmall = NULL;
    m_himlLarge = NULL;
    m_cRef = 1;
    m_hwndList = NULL;
    m_hwndParent=NULL;
    m_cfAccept = CF_NULL;
    m_dwDragType = 0;
    m_grfKeyState = 0;
    m_dwEffect = 0;
    m_cxMaxText = 0;
    m_cyHeight = 0;
    m_fReadOnly = 0;
    m_fDirty = FALSE;
    m_fDragSource = FALSE;
    m_fDropTargetRegister=FALSE;
    m_fShowingContext = 0;
    m_fRightClick = 0;
    m_fWarning = 1;
    m_fSafeOnly = TRUE;
    m_rgpAttach=NULL;
    m_cAttach=0;
    m_cAlloc=0;
    m_iVCard = -1;
    m_fDeleteVCards = FALSE;
    m_szUnsafeAttachList = NULL;
    m_cUnsafeAttach = 0;
}

// ==============================================================================
// CAttMan::~CAttMan
// ==============================================================================
CAttMan::~CAttMan ()
{
    DOUT ("CAttMan::~CAttMan");

    if (m_himlSmall)
        ImageList_Destroy (m_himlSmall);

    if (m_himlLarge)
        ImageList_Destroy (m_himlLarge);

    if (m_szUnsafeAttachList != NULL)
        SafeMemFree(m_szUnsafeAttachList);

    SafeRelease (m_pMsg);
}

// ==============================================================================
// CAttMan::AddRef
// ==============================================================================
ULONG CAttMan::AddRef()
{
    DOUT ("CAttMan::AddRef () Ref Count=%d", m_cRef);
    return ++m_cRef;
}

// ==============================================================================
// CAttMan::Release
// ==============================================================================
ULONG CAttMan::Release()
{
    ULONG ulCount = --m_cRef;
    DOUT ("CAttMan::Release () Ref Count=%d", ulCount);
    if (!ulCount)
        delete this;
    return ulCount;
}

HRESULT STDMETHODCALLTYPE CAttMan::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*)this;
//    else if (IsEqualIID(riid, IID_IDropTarget))
//        *ppvObj = (void*)(IDropTarget*)this;
    else if (IsEqualIID(riid, IID_IDropSource))
        *ppvObj = (void*)(IDropSource*)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CAttMan::HrGetAttachCount(ULONG *pcAttach)
{
    Assert(pcAttach);
    //*pcAttach = m_cAttach;
    *pcAttach = ListView_GetItemCount(m_hwndList);

    return S_OK;
}

ULONG CAttMan::GetUnsafeAttachCount()
{
    return m_cUnsafeAttach;
}

LPTSTR CAttMan::GetUnsafeAttachList()
{
    return m_szUnsafeAttachList;
}

HRESULT CAttMan::HrUnload()
{
    HRESULT     hr;

    SafeRelease (m_pMsg);

    if (m_hwndList)
        ListView_DeleteAllItems(m_hwndList);

    hr=HrFreeAllData();
    if (FAILED(hr))
        goto error;

error:
    return hr;
}

HRESULT CAttMan::HrInit(HWND hwnd, BOOL fReadOnly, BOOL fDeleteVCards, BOOL fAllowUnsafe)
{
    m_fReadOnly = !!fReadOnly;
    m_hwndParent = hwnd;
    m_fDeleteVCards = !!fDeleteVCards;
    m_fSafeOnly = !fAllowUnsafe;

    return HrCreateListView(hwnd);
}

HRESULT CAttMan::HrClearDirtyFlag()
{
    m_fDirty=FALSE;
    return S_OK;
}

HRESULT CAttMan::HrIsDirty()
{
    return m_fDirty?S_OK:S_FALSE;
}

HRESULT CAttMan::GetTabStopArray(HWND *rgTSArray, int *pcArrayCount)
{
    Assert(rgTSArray);
    Assert(pcArrayCount);
    Assert(*pcArrayCount > 0);

    *rgTSArray = m_hwndList;
    *pcArrayCount = 1;
    return S_OK;
}

HRESULT CAttMan::HrCreateListView(HWND hwnd)
{
    HRESULT     hr;
    DWORD       dwFlags;

    dwFlags = 0;//DwGetOption(OPT_ATTACH_VIEW_STYLE);
    dwFlags |= WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|LVS_AUTOARRANGE|
               LVS_SMALLICON|LVS_NOSCROLL|LVS_SHAREIMAGELISTS;

    m_hwndList = CreateWindowExWrapW(WS_EX_CLIENTEDGE,
                                     WC_LISTVIEWW,
                                     L"",
                                     dwFlags,
                                     0,0,0,0,
                                     hwnd,
                                     (HMENU)idwAttachWell,
                                     g_hInst,
                                     NULL);

    if(!m_hwndList)
        return E_OUTOFMEMORY;
 
    // Init image list
    hr=HrInitImageLists();
    if(FAILED(hr))
        goto error;


#if 0
    // if we're not readonly, register ourselves as a drop target...
    if(!m_fReadOnly)
        {
        hr=CoLockObjectExternal((LPDROPTARGET)this, TRUE, FALSE);
        if (FAILED(hr))
            goto error;

        hr=RegisterDragDrop(m_hwndList, (LPDROPTARGET)this);
        if (FAILED(hr))
            goto error;

        m_fDropTargetRegister=TRUE;
        }
#endif

error:
    return hr;
}

HRESULT CAttMan::HrBuildAttachList()
{
    HRESULT     hr = S_OK;
    ULONG       cAttach=0,
                uAttach;
    LPHBODY     rghAttach=0;

    Assert(m_pMsg != NULL);

    // secure receipt is not attachment and we don't need to show .DAT file as attachment.
    if(CheckSecReceipt(m_pMsg) == S_OK)
        return hr;

    //GetAttachmentCount(m_pMsg, &cAttach);
    hr=m_pMsg->GetAttachments(&cAttach, &rghAttach);
    if (FAILED(hr))
        goto error;

    for(uAttach=0; uAttach<cAttach; uAttach++)
    {
        hr=HrAddData(rghAttach[uAttach]);
        if (FAILED(hr))
            goto error;
    }
    
error:
    SafeMimeOleFree(rghAttach);
    return hr;
}


// Only expected to be used during initialization with original m_pMsg
HRESULT CAttMan::HrFillListView()
{
    HRESULT     hr;
    ULONG       uAttach;
    CComBSTR    bstrUnsafeAttach;

    Assert (m_hwndList && IsWindow(m_hwndList) && m_pMsg);

    hr = HrCheckVCard();
    if (FAILED(hr))
        goto error;

    if (m_cAttach==0)         // nothing to do
        return NOERROR;

    if(m_iVCard >= 0)
        ListView_SetItemCount(m_hwndList, m_cAttach - 1);
    else
        ListView_SetItemCount(m_hwndList, m_cAttach);

    if (m_szUnsafeAttachList != NULL)
        SafeMemFree(m_szUnsafeAttachList);
    m_cUnsafeAttach = 0;

    // walk the attachment data list and add them to the listview
    for(uAttach=0; uAttach<m_cAlloc; uAttach++)
    {
        // if there is one and only one vcare in the read note, don't add it to list view,
        // header will show it as a stamp.
        if (m_rgpAttach[uAttach] && uAttach!=(ULONG)m_iVCard)
        {
            hr=HrAddToList(m_rgpAttach[uAttach], TRUE);
            if (hr == S_FALSE)
            {
                if (bstrUnsafeAttach.Length() > 0)
                    bstrUnsafeAttach.Append(L",");
                bstrUnsafeAttach.Append(m_rgpAttach[uAttach]->szFileName);
                m_cUnsafeAttach++;
            }
            if (FAILED(hr))
                goto error;
        }
    }

error:
    if (m_cUnsafeAttach)
        m_szUnsafeAttachList = PszToANSI(CP_ACP, bstrUnsafeAttach.m_str);

#ifdef DEBUG
    if(m_iVCard >= 0)
        AssertSz(m_cAttach-1==(ULONG)ListView_GetItemCount(m_hwndList)+m_cUnsafeAttach, "Something failed creating the attachmentlist");
    else
        AssertSz(m_cAttach==(ULONG)ListView_GetItemCount(m_hwndList)+m_cUnsafeAttach, "Something failed creating the attachmentlist");
#endif
    return hr;
}


// tells the note header if there is a vcard it wants.
HRESULT CAttMan::HrFVCard()
{
    return (m_iVCard >= 0) ? S_OK : S_FALSE;
}

// note header needs this function to show the property of the vcard 
// which is shown as a stamp on the header.
HRESULT CAttMan::HrShowVCardProp()
{
    Assert(m_iVCard >= 0);

    return HrDoVerb(m_rgpAttach[m_iVCard], ID_OPEN);
}


// checks if we have one and only one vcard in the attachment.
HRESULT CAttMan::HrCheckVCard()
{
    HRESULT     hr = NOERROR;
    ULONG       uAttach;

    m_iVCard = -1;

    // this is only for read note. Since preview doesn't call this function,
    // we can check m_fReadOnly to see if it's a read note.
    if(!m_fReadOnly)
        return hr;

    for(uAttach=0; uAttach<m_cAlloc; uAttach++)
    {
        if (m_rgpAttach[uAttach])
        {
            if(StrStrIW(PathFindExtensionW((m_rgpAttach[uAttach])->szFileName), L".vcf"))
            {
                if(m_iVCard >= 0)
                {
                    // there are more than one vcards, we quit.
                    m_iVCard = -1;
                    break;
                }
                else
                    m_iVCard = uAttach;
            }
        }
    }

    return hr;
}


HRESULT CAttMan::HrCheckVCardExists(BOOL fMail)
{
    HRESULT     hr = S_FALSE;
    ULONG       uAttach;
    TCHAR       szVCardName[MAX_PATH];
    LPWSTR      szVCardNameW = NULL;

    if(m_fReadOnly)
        return hr;

    *szVCardName = 0;

    if(fMail)
        GetOption(OPT_MAIL_VCARDNAME, szVCardName, MAX_PATH);
    else
        GetOption(OPT_NEWS_VCARDNAME, szVCardName, MAX_PATH);

    if (*szVCardName != '\0')
    {
        szVCardNameW = PszToUnicode(CP_ACP, szVCardName);
        if (szVCardNameW)
        {
            for(uAttach=0; uAttach<m_cAlloc; uAttach++)
            {
                if (m_rgpAttach[uAttach])
                {    
                    if(0 == StrCmpNIW((m_rgpAttach[uAttach])->szFileName, szVCardNameW, lstrlenW(szVCardNameW)))
                    {
                        hr = S_OK;
                        break;
                    }
                }
            }
            MemFree(szVCardNameW);
        }
        else
            TraceResult(hr = E_OUTOFMEMORY);
    }

    return hr;
}

/*
 *
 *  HrInitImageLists
 *
 *  Create an image list and assign it to our listview.
 *  to contain iicons number of icons
 *
 */
HRESULT CAttMan::HrInitImageLists()
{
    UINT flags = ILC_MASK;
    Assert(m_hwndList && IsWindow(m_hwndList));
    Assert(!m_himlLarge);
    Assert(!m_himlSmall);

    if(IS_WINDOW_RTL_MIRRORED(m_hwndList))
    {
        flags |= ILC_MIRROR ;
    }
    m_himlLarge = ImageList_Create( GetSystemMetrics(SM_CXICON),     
                                    GetSystemMetrics(SM_CYICON), 
                                    flags, CNUMICONSDEFAULT, 0);
    if(!m_himlLarge)
        return E_OUTOFMEMORY;
    
    m_himlSmall = ImageList_Create( GetSystemMetrics(SM_CXSMICON), 
                                    GetSystemMetrics(SM_CYSMICON),
                                    flags, CNUMICONSDEFAULT, 0);
    if(!m_himlSmall)
        return E_OUTOFMEMORY;
    
    ListView_SetImageList(m_hwndList, m_himlSmall, LVSIL_SMALL);
    ListView_SetImageList(m_hwndList, m_himlLarge, LVSIL_NORMAL);
    return NOERROR;
}

//
// HrAddToList
//
// adds an attachment to the LV, 
// if count was 0 then send a message to parent
// to redraw.
//
HRESULT CAttMan::HrAddToList(LPATTACHDATA pAttach, BOOL fIniting)
{
    LV_ITEMW        lvi ={0}; 
    INT             iPos;    
    HICON           hIcon=0;
    RECT            rc;

    Assert(m_hwndList != NULL);
    Assert(pAttach != NULL);
    Assert(m_himlSmall != NULL);
    Assert(m_himlLarge != NULL);

    // don't show attachments which are deemed unsafe
    if (m_fReadOnly && m_fSafeOnly && !(pAttach->fSafe))
        return S_FALSE;

    // if this is the first item
    // we need to send a message to parent
    lvi.mask        = LVIF_PARAM|LVIF_TEXT|LVIF_IMAGE|LVIF_STATE;
    lvi.stateMask   = 0;
    lvi.pszText     = L"";
    lvi.lParam      = (LPARAM)pAttach;

    // get icons for image list
    if (fIniting)
    {
        SideAssert(HrGetAttachIcon(m_pMsg, pAttach->hAttach, FALSE, &hIcon)==S_OK);
        lvi.iImage = ImageList_AddIcon(m_himlSmall, hIcon);
        DestroyIcon(hIcon);
        SideAssert(HrGetAttachIcon(m_pMsg, pAttach->hAttach, TRUE, &hIcon)==S_OK);
        ImageList_AddIcon(m_himlLarge, hIcon);
        DestroyIcon(hIcon);
    }
    else
    {
        SideAssert(HrGetAttachIconByFile(pAttach->szFileName, FALSE, &hIcon)==S_OK);
        lvi.iImage = ImageList_AddIcon(m_himlSmall, hIcon);
        DestroyIcon(hIcon);
        SideAssert(HrGetAttachIconByFile(pAttach->szFileName, TRUE, &hIcon)==S_OK);
        ImageList_AddIcon(m_himlLarge, hIcon);
        DestroyIcon(hIcon);
    }
    
    lvi.pszText     = pAttach->szDisplay;

    iPos = (INT) SendMessage(m_hwndList, LVM_INSERTITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi));
    if (-1 == iPos)
        return E_FAIL;

    // Must set to LVS_ICON then reset to LVS_SMALLICON
    // to get SMALLICONs to come up arranged.
    DWORD dwStyle = GetWindowStyle(m_hwndList);
    if ((dwStyle & LVS_TYPEMASK) == LVS_SMALLICON)
    {
        SetWindowLong(m_hwndList, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK)|LVS_ICON);
        SetWindowLong(m_hwndList, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK)|LVS_SMALLICON);
    }

    return S_OK;
}

BOOL CAttMan::WMNotify(int idFrom, NMHDR *pnmhdr)
{
    DOUTLL( DOUTL_ATTMAN, 2, "CAttMan :: WMNotify( ), %d", idFrom );

    if (idFrom!=idwAttachWell)
        return FALSE;

    switch (pnmhdr->code)
    {
        case LVN_KEYDOWN:
        {                                               
            LV_KEYDOWN *pnkd = ((LV_KEYDOWN *)pnmhdr); 
            switch (pnkd->wVKey)
            {
                case VK_DELETE:
                    if (!m_fReadOnly)
                        HrRemoveAttachments();
                    break;
                
                case VK_INSERT:
                    if (!m_fReadOnly)
                        HrInsertFile();
                    break;
                
                case VK_RETURN:
                case VK_EXECUTE:
                    HrExecFile(ID_OPEN);
                    break;
                
            }
            break;
        }

        case LVN_BEGINDRAG:
        case LVN_BEGINRDRAG:
            m_dwDragType = (pnmhdr->code==LVN_BEGINDRAG?MK_LBUTTON:MK_RBUTTON);
            HrBeginDrag();
            return TRUE;

        case NM_DBLCLK:
            HrDblClick(idFrom, pnmhdr);
            return TRUE;
    }   

    return FALSE;
}

//================================================================
//
//  BOOL CAttMan :: OnBeginDrag( )
//
//  Purpose: We have received a message that a drag has begun.
//================================================================
HRESULT CAttMan::HrBeginDrag()
{
    DWORD           dwEffect;
    IDataObject    *pDataObj=0;
    PDATAOBJINFO    pdoi = 0;
    HRESULT         hr;

    Assert(m_hwndList);
    
    // BROKEN: this is busted. Creating the tempfile on a dragstart is broken, we should package these better.
    hr=HrBuildHDrop(&pdoi);
    if (FAILED(hr))
        goto error;

    hr = CreateDataObject(pdoi, 1, (PFNFREEDATAOBJ)FreeAthenaDataObj, &pDataObj);
    if (FAILED(hr))
    {
        SafeMemFree(pdoi);
        goto error;
    }

    if (m_fReadOnly)
        dwEffect = DROPEFFECT_COPY;
    else
        dwEffect = DROPEFFECT_MOVE|DROPEFFECT_COPY;

    // prevent source drags in the body...

    m_fDragSource = TRUE;

    hr=DoDragDrop((LPDATAOBJECT)pDataObj, (LPDROPSOURCE)this, dwEffect, &dwEffect);

    m_fDragSource = FALSE;

    if (FAILED(hr))
        goto error;
    
    
    // ok, now lets see if the operation was a move, if so we need to
    // delete the source.
    if( !m_fReadOnly && (dwEffect & DROPEFFECT_MOVE))
        hr=HrRemoveAttachments();

error:
    ReleaseObj(pDataObj);
    return hr;
}

//================================================================
//
//  BOOL CAttMan :: WMContextMenu( )
//
//  Displays one of two menus for the lisview.
//  Menu is selected depending if items are highlighted.
//
//  returns: TRUE => success.
//
//================================================================

BOOL CAttMan::WMContextMenu( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    HMENU       hMenu=NULL;
    INT         cSel;
    BOOL        fEnable,
                fRet = FALSE;
    LV_ITEMW    lvi;
    WCHAR       szCommand[MAX_PATH];
    DWORD       dwPos;

    // was it for us?
    if ((HWND)wParam != m_hwndList)
        goto cleanup;

    Assert(m_hwndList);

    cSel = ListView_GetSelectedCount(m_hwndList);

    hMenu = LoadPopupMenu(IDR_ATTACHMENT_POPUP);
    if(!hMenu)
        goto cleanup;

    // commands that are enabled if only one attachment is selected
    fEnable = (cSel == 1);

    EnableMenuItem(hMenu, ID_PRINT, MF_BYCOMMAND | (fEnable? MF_ENABLED:MF_GRAYED));
    EnableMenuItem(hMenu, ID_QUICK_VIEW, MF_BYCOMMAND | (fEnable? MF_ENABLED:MF_GRAYED));

    // enabled in readonly mode and if there is only one attach selected
    EnableMenuItem(hMenu, ID_SAVE_ATTACH_AS, MF_BYCOMMAND | ((fEnable && m_fReadOnly)? MF_ENABLED:MF_GRAYED));

    // enabled if any attachments selected
    EnableMenuItem(hMenu, ID_OPEN, MF_BYCOMMAND | (cSel > 0? MF_ENABLED:MF_GRAYED));

    // enabled only in readonly mode
    EnableMenuItem(hMenu, ID_SAVE_ATTACHMENTS, MF_BYCOMMAND | (m_fReadOnly? MF_ENABLED:MF_GRAYED));

    // enabled only in compose mode
    EnableMenuItem(hMenu, ID_ADD, MF_BYCOMMAND | (!m_fReadOnly? MF_ENABLED:MF_GRAYED));

    // enabled only in compose mode if there is a valid selection
    EnableMenuItem(hMenu, ID_REMOVE, MF_BYCOMMAND | (!m_fReadOnly && cSel > 0? MF_ENABLED:MF_GRAYED));

    if ((fIsNT5()) || (IsOS(OS_MILLENNIUM)))
    {
        // On Both these platforms, Quick View is not supported.
        DeleteMenu(hMenu, ID_QUICK_VIEW, MF_BYCOMMAND);
    }
    else
    {
        // Disable Quick View if QVIEW.EXE does not exist
        GetSystemDirectoryWrapW(szCommand, ARRAYSIZE(szCommand));
        StrCatBuffW(szCommand, L"\\VIEWERS\\QUIKVIEW.EXE", ARRAYSIZE(szCommand));

        if ((UINT)GetFileAttributesWrapW(szCommand) == (UINT)-1)
        {
            EnableMenuItem (hMenu, ID_QUICK_VIEW, MF_GRAYED);
        }
    }

    // bold the first non-grey item
    MenuUtil_SetPopupDefault(hMenu, ID_OPEN);

    // RAID $2129: disable print verb for .eml files
    // $49436 - also disable for .lnks
    if (cSel==1)
    {
        LPWSTR pszExt;
        
        lvi.iItem = ListView_GetSelFocused(m_hwndList);
        lvi.mask = LVIF_PARAM;
        if (SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
        {
            pszExt = PathFindExtensionW(((LPATTACHDATA)lvi.lParam)->szFileName);
            if (pszExt && (StrCmpIW(pszExt, c_wszEmlExt)==0 ||
                           StrCmpIW(pszExt, c_wszNwsExt)==0 ||
                           StrCmpIW(pszExt, L".lnk")==0))
                EnableMenuItem( hMenu, ID_PRINT, MF_GRAYED);
        }
    }
    

    dwPos=GetMessagePos();
    
    fRet = TrackPopupMenuEx( 
                    hMenu,
                    TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                    LOWORD(dwPos),
                    HIWORD(dwPos),
                    hwnd,
                    NULL);
cleanup:
    if(hMenu)
        DestroyMenu(hMenu);

    return fRet;
}

HRESULT CAttMan::HrDblClick(int idFrom, NMHDR *pnmhdr)
{
    DWORD           dwPos;
    POINT           pt;
    LV_HITTESTINFO  lvhti;
    LV_ITEMW        lvi;
        
    Assert(m_hwndList);

    // Find out where the cursor was
    dwPos = GetMessagePos();
    pt.x  = LOWORD(dwPos);
    pt.y  = HIWORD(dwPos);
    ScreenToClient( m_hwndList, &pt);
           
    lvhti.pt = pt;            
    if(ListView_HitTest(m_hwndList, &lvhti) != -1)
    {
        // return 1 here, we passed the HitTest
        lvi.iItem = lvhti.iItem;
        lvi.mask = LVIF_PARAM;
        if (SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
            return HrDoVerb((LPATTACHDATA)lvi.lParam, ID_OPEN);
    }
    return S_OK;
}

HRESULT CAttMan::HrGetHeight(INT cxWidth, ULONG *pcy)
{
    DWORD   dwDims;
    LONG    cCount;

    if (!pcy || cxWidth<=0)
        return E_INVALIDARG;

    *pcy=0;

    cCount = ListView_GetItemCount(m_hwndList);
    if (0 == cCount)
        *pcy = 0;
    else
    {
        dwDims = ListView_ApproximateViewRect(m_hwndList, cxWidth, 0, cCount);
        *pcy = HIWORD(dwDims);
    }
    
    return S_OK;
}

HRESULT CAttMan::HrSwitchView(DWORD dwView)
{
    DWORD       dwStyle = GetWindowStyle(m_hwndList);
    WORD        ToolbarStyleLookup[]= { LVS_ICON, 
                                        LVS_REPORT,
                                        LVS_SMALLICON, 
                                        LVS_LIST };

    Assert(m_hwndList);
    
    // convert index into lisview style
    dwView = ToolbarStyleLookup[dwView];

    if ((LVS_ICON != dwView) && (LVS_SMALLICON != dwView))
        dwView = LVS_ICON;

    // don't change to the same view
    if ((dwStyle & LVS_TYPEMASK) != dwView)
    {
        SetWindowLong(m_hwndList, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK)|dwView);
        HrResizeParent();
        SetDwOption(OPT_ATTACH_VIEW_STYLE, dwView, NULL, 0); 
    }
    
    return S_OK;
}

HRESULT CAttMan::HrSetSize(RECT *prc)
{
    Assert(IsWindow( m_hwndList ));
    Assert(prc);
    
    DWORD   dwStyle = GetWindowStyle(m_hwndList),
            dwPosFlags;
    ULONG   cAttMan = 0;

    HrGetAttachCount(&cAttMan);
    if (cAttMan == 1)
        SetWindowLong(m_hwndList, GWL_STYLE, dwStyle | LVS_NOSCROLL);
    else
        SetWindowLong(m_hwndList, GWL_STYLE, dwStyle & ~LVS_NOSCROLL);

    dwPosFlags = (cAttMan > 0) ? SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_SHOWWINDOW:
                                 SWP_HIDEWINDOW;

    SetWindowPos(m_hwndList, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, dwPosFlags);

    return S_OK;
}

BOOL CAttMan::WMCommand(HWND hwndCmd, INT id, WORD wCmd)
{
    // verbs depending on listview mode
    if (m_hwndList)
    {
        switch(id)
        {
            case ID_SELECT_ALL:
                if(GetFocus()!=m_hwndList)
                    return FALSE;
            
                ListView_SelectAll(m_hwndList);
                return TRUE;
            
            case ID_ADD:
                HrInsertFile();
                return TRUE;
            
            case ID_REMOVE:
                HrRemoveAttachments();
                return TRUE;
            
            case ID_OPEN:
            case ID_QUICK_VIEW:
            case ID_PRINT:
            case ID_SAVE_ATTACH_AS:
                HrExecFile(id);
                return TRUE;
            
            case ID_INSERT_ATTACHMENT:
                HrInsertFile();
                return TRUE;
        }
    }
    return FALSE;
}

//===================================================
//
//    HrRemoveAttachment
//
//    Purpose:
//        Removes an attachment from the ListView
//
//    Arguments:
//      ili            - index of attachment in listview to remove
//      fDelete        - should we remove it from list
//
//    Returns:
///
//===================================================
HRESULT CAttMan::HrRemoveAttachment(int ili)
{
    LV_ITEMW        lvi;
    LPATTACHDATA    lpAttach=0;    
    HRESULT         hr=S_OK;
    ULONG           uAttach;

    Assert( m_hwndList );

    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem    = ili;

    if (!SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
    {
        AssertSz(0, "Attempting to remove an item that is not there");
        return E_FAIL;    // item does not exist!!!!
    }
    
    lpAttach = (LPATTACHDATA)lvi.lParam;
    if(!lpAttach)
        return E_FAIL;

    // find it and kill it from the list
    for (uAttach=0; uAttach<m_cAlloc; uAttach++)
    {
        if (m_rgpAttach[uAttach]==lpAttach)
        {
            HrFreeAttachData(m_rgpAttach[uAttach]);
            m_rgpAttach[uAttach] = NULL;
            break;
        }
    }

    // if we actually removed the attachment, make sure we're dirty
    m_fDirty = TRUE;

    ListView_DeleteItem(m_hwndList, ili);

    return hr;
}

/*
 *  CAttMan::HrDeleteAttachments
 *
 *  Purpose:
 *      Prompts user to confirm deletion, if IDYES -> blow them away
 *
 */

HRESULT CAttMan::HrDeleteAttachments()
{
    if (AthMessageBoxW( m_hwndParent,
                        MAKEINTRESOURCEW(idsAthena),
                        MAKEINTRESOURCEW(idsAttConfirmDeletion),
                        NULL, MB_YESNO|MB_ICONEXCLAMATION )==IDNO)

        return NOERROR;


    return HrRemoveAttachments();
}

/*
 *  CAttMan ::  HrRemoveAttachments
 *
 *  Purpose:
 *      Removes all selected attachments from the Well.
 *
 *  Arguments:
 *
 */

HRESULT CAttMan::HrRemoveAttachments()
{
    HRESULT     hr=NOERROR;
    HWND        hwnd;
    int         ili,
                iNext,
                nPos,
                nCount;
    
    Assert(m_hwndList);
    
    while ((ili=ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED|LVNI_ALL))!=-1)
    {
        iNext = ili;
        hr=HrRemoveAttachment(ili);
        if (FAILED(hr))
            goto error;
    }
    
    if ((nCount=ListView_GetItemCount(m_hwndList))==0)
    {
        // if there are no attachments left, we need to size the well to 0. and setfocus
        // to someother control
        m_cyHeight = 0;
        HrResizeParent();
        
        if (hwnd = GetNextDlgTabItem(m_hwndParent, m_hwndList, TRUE))
            SetFocus(hwnd);
    }
    else
    {
        HrResizeParent();
        if (iNext<nCount)
            nPos = (iNext?iNext-1:iNext);
        else
            nPos = nCount - 1;
        
        ListView_SelectItem(m_hwndList, nPos);
    }
error:
    return hr;
}


HRESULT CAttMan::HrResizeParent()
{
    RECT    rc;
    NMHDR   nmhdr;

    Assert(m_hwndList);
    nmhdr.hwndFrom=m_hwndList;
    nmhdr.idFrom=GetDlgCtrlID(m_hwndList);
    nmhdr.code=ATTN_RESIZEPARENT;
    SendMessage(GetParent(m_hwndList), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
    return S_OK;
}

HRESULT GetLastAttachmentPath(LPWSTR pszDefaultDir, DWORD cchSize)
{
    HRESULT hr = S_OK;
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszDefaultDir[0]));

    pszDefaultDir[0] = 0;
    DWORD dwError = SHGetValueW(MU_GetCurrentUserHKey(), NULL, L"Attachment Path", &dwType, (void *) pszDefaultDir, &cbSize);

    hr = HRESULT_FROM_WIN32(dwError);
    return hr;
}


HRESULT SetLastAttachmentPath(LPCWSTR pszDefaultDir)
{
    HRESULT hr = S_OK;
    DWORD cbSize = ((lstrlenW(pszDefaultDir)+1) * sizeof(pszDefaultDir[0]));

    DWORD dwError = SHSetValueW(MU_GetCurrentUserHKey(), NULL, L"Attachment Path", REG_SZ, (void *) pszDefaultDir, cbSize);

    hr = HRESULT_FROM_WIN32(dwError);
    return hr;
}

#define CCH_INSERTFILE  4096

typedef struct tagATTMANCUSTOM {
    BOOL    fShortcut;
    WCHAR   szFiles[CCH_INSERTFILE];
    WORD    nFileOffset;
} ATTMANCUSTOM;

HRESULT CAttMan::HrInsertFile()
{
    OPENFILENAMEW   ofn;
    HRESULT         hr;
    WCHAR           rgch[MAX_PATH],
                    pszOpenFileName[CCH_INSERTFILE],
                    szDefaultDir[MAX_PATH];
    ATTMANCUSTOM    rCustom;

    Assert(m_hwndList);

    *pszOpenFileName = 0;

    ZeroMemory(&ofn, sizeof(ofn));
    AthLoadStringW(idsAllFilesFilter, rgch, MAX_PATH);
    ReplaceCharsW(rgch, _T('|'), _T('\0'));

    ofn.lStructSize     = sizeof(OPENFILENAME);
    ofn.hwndOwner       = m_hwndParent;
    ofn.hInstance       = g_hLocRes;
    ofn.lpstrFilter     = rgch;
    ofn.nFilterIndex    = 1;
    ofn.lpstrFile       = pszOpenFileName;
    ofn.nMaxFile        = CCH_INSERTFILE;
    ofn.lpstrInitialDir = szDefaultDir; //current dir
    ofn.Flags           = OFN_HIDEREADONLY |
                          OFN_EXPLORER |
                          OFN_ALLOWMULTISELECT |
                          OFN_FILEMUSTEXIST |
                          OFN_NOCHANGEDIR |
                          OFN_ENABLEHOOK |
                          OFN_ENABLETEMPLATE |
                          OFN_NODEREFERENCELINKS;
    ofn.lpTemplateName  = MAKEINTRESOURCEW(iddInsertFile);
    ofn.lpfnHook        = (LPOFNHOOKPROC)InsertFileDlgHookProc;
    ofn.lCustData       = (LONG_PTR)&rCustom;

    if (FAILED(GetLastAttachmentPath(szDefaultDir, ARRAYSIZE(szDefaultDir))) ||
        !PathFileExistsW(szDefaultDir))
    {
        ofn.lpstrInitialDir = NULL;
    }

    rCustom.szFiles[0] = 0;
    rCustom.fShortcut = FALSE;
    rCustom.nFileOffset = 0;

    // NB: OK button in dialog hook take's care of inserting the attachment.
    hr = HrAthGetFileNameW(&ofn, TRUE);
    if (SUCCEEDED(hr))
    {
        WCHAR   sz[MAX_PATH];
        LPWSTR  pszT;
        BOOL    fShortCut = rCustom.fShortcut,
                fUseCustom = (rCustom.szFiles[0]),
                fSingleAttach;

        // We only generate custom stuff if we have more than one file
        fSingleAttach = fUseCustom ? FALSE : (ofn.nFileOffset < lstrlenW(pszOpenFileName));
        if (fSingleAttach)
        {
            StrCpyNW(szDefaultDir, pszOpenFileName, ARRAYSIZE(szDefaultDir));
            PathRemoveFileSpecW(szDefaultDir);
            SetLastAttachmentPath(szDefaultDir);

            // in single-file case, no null between path and filename
            hr = HrAddAttachment(pszOpenFileName, NULL, fShortCut);
        }
        else
        {
            LPWSTR pszPath;
            if (fUseCustom)
            {
                pszPath = rCustom.szFiles;
                pszT = pszPath + rCustom.nFileOffset;
            }
            else
            {
                pszPath = pszOpenFileName;
                pszT = pszPath + ofn.nFileOffset;
            }

            SetLastAttachmentPath(pszPath);

            while (TRUE)
            {
                PathCombineW(sz, pszPath, pszT);
        
                hr = HrAddAttachment(sz, NULL, fShortCut);
                if (hr != S_OK)
                    break;
        
                pszT = pszT + lstrlenW(pszT) + 1;
                if (*pszT == 0)
                    break;
            }
        }
    }

    return(hr);
}

/*
 * HrAddAttachment
 *
 * adds a file attachment to the list from a stream or filename
 *
 *
 */

HRESULT CAttMan::HrAddAttachment(LPWSTR lpszPathName, LPSTREAM pstm, BOOL fShortCut)
{
    ULONG           cbSize=0;
    HRESULT         hr = S_OK;
    HBODY           hAttach=0;
    LPATTACHDATA    pAttach;
    WCHAR           szLinkPath[MAX_PATH];
    LPWSTR          pszFileNameToUse;

    *szLinkPath = 0;

    if(fShortCut)
    {
        hr = CreateNewShortCut(lpszPathName, szLinkPath, ARRAYSIZE(szLinkPath));
        if (FAILED(hr))
            return hr;    
    }

    pszFileNameToUse = *szLinkPath ? szLinkPath : lpszPathName;

    hr=HrAddData(pszFileNameToUse, pstm, &pAttach);

    if (FAILED(hr))
        return hr;

    hr=HrAddToList(pAttach, FALSE);
    if (FAILED(hr))
        goto error;           

    if (ListView_GetItemCount(m_hwndList) == 1)
    {
        // if we went from 0->1 then select the first item
        ListView_SelectItem(m_hwndList, 0);
    }
    // Adding a new attachment makes us dirty
    m_fDirty = TRUE;

    HrResizeParent();
error:
    return hr;
}

/*
 *
 *  HRESULT CAttMan::HrExecFile
 *
 *  handles one of these verbs against an attachment:
 *  
 *      ID_OPEN:          - Launch use m_lpMsg
 *      ID_QUICK_VIEW:     - NYI
 *      ID_PRINT:         - NYI
 *      ID_SAVE_AS:          - NYI
 *
 *  returns 1 if handled.
 *
 */

HRESULT CAttMan::HrExecFile(int iVerb)
{
    LV_ITEMW    lvi;
    HRESULT     hr=E_FAIL;

    if (!ListView_GetSelectedCount(m_hwndList))
        return NOERROR; // nothing to do...

    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem    = -1;
 
    // cycle through all the selected attachments
    while ((lvi.iItem = ListView_GetNextItem(m_hwndList, lvi.iItem, LVNI_SELECTED | LVNI_ALL)) != -1)
    {
        SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi));
        
        switch(iVerb)
        {
            case ID_SAVE_ATTACH_AS:
            case ID_OPEN:
            case ID_PRINT:
            case ID_QUICK_VIEW:
                return HrDoVerb((LPATTACHDATA)lvi.lParam, iVerb);
            
            default:
                AssertSz(0, "Verb not supported");
        }
    }

    return hr;
}

// ==============================================================================
//
//  FUNCTION:   CAttMan :: FDropFiles()
//
//  Purpose:    this method is called with a HDROP, the files
//              have been droped. This method assumes
//
// ==============================================================================

HRESULT CAttMan::HrDropFiles(HDROP hDrop, BOOL fMakeLinks)
{
    WCHAR   wszFile[_MAX_PATH];
    UINT    cFiles;
    UINT    iFile;
    HCURSOR hcursor;
    BOOL    fFirstDirectory = TRUE,
            fLinkDirectories = FALSE;
    HRESULT hr = S_OK;
        
    hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Let's work through the files given to us
    cFiles = DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0);
    for (iFile = 0; iFile < cFiles; ++iFile)
    {
        DragQueryFileWrapW(hDrop, iFile, wszFile, _MAX_PATH);
        if (!fMakeLinks && PathIsDirectoryW(wszFile))
        {
            // can link to a directory, but not drop one.
            if (fFirstDirectory)
            {
                int id;
                // Tell the user that he's been a bad user
                id = AthMessageBoxW(m_hwndParent,
                                    MAKEINTRESOURCEW(idsAthena),                                      
                                    MAKEINTRESOURCEW(idsDropLinkDirs), 
                                    NULL,
                                    MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_YESNOCANCEL);
                if (id==IDCANCEL)
                    return E_FAIL;

                if (id == IDYES)
                    fLinkDirectories = TRUE;

                fFirstDirectory = FALSE;
            }
            if (fLinkDirectories)
                hr = HrAddAttachment(wszFile, NULL, TRUE);
        }
        else
            hr = HrAddAttachment(wszFile, NULL, fMakeLinks);
    }

    if (FAILED(hr))
    {
        AthMessageBoxW(m_hwndParent,
                       MAKEINTRESOURCEW(idsAthena),                                      
                       MAKEINTRESOURCEW(idsErrDDFileNotFound), 
                       NULL, MB_ICONEXCLAMATION|MB_SETFOREGROUND|MB_OK);
    }

    SetCursor(hcursor);
    return S_OK;
}

HRESULT CAttMan::HrDropFileDescriptor(LPDATAOBJECT pDataObj, BOOL fLink)
{
    HCURSOR                 hcursor;
    BOOL                    fFirstDirectory = TRUE,
                            fLinkDirectories = FALSE,
                            fUnicode = TRUE,
                            fIsDirectory;
    SCODE                   sc = S_OK;
    LPWSTR                  pwszFileName = NULL;
    HRESULT                 hr = S_OK;
    STGMEDIUM               stgmedDesc;
    FILEGROUPDESCRIPTORA   *pfgdA = NULL;
    FILEDESCRIPTORA        *pfdA = NULL;
    FILEGROUPDESCRIPTORW   *pfgdW = NULL;
    FILEDESCRIPTORW        *pfdW = NULL;
    UINT                    uiNumFiles,
                            uiCurrFile;
    FORMATETC               fetcFileDescA =
                                {(CLIPFORMAT)(CF_FILEDESCRIPTORA), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC               fetcFileDescW =
                                {(CLIPFORMAT)(CF_FILEDESCRIPTORW), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC               fetcFileContents =
                                {(CLIPFORMAT)(CF_FILECONTENTS), NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM|
                                                                                TYMED_HGLOBAL};
    hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    ZeroMemory(&stgmedDesc, sizeof(STGMEDIUM));

    hr = pDataObj->GetData(&fetcFileDescW, &stgmedDesc);
    if (SUCCEEDED(hr))
    {
        pfgdW = (LPFILEGROUPDESCRIPTORW)GlobalLock(stgmedDesc.hGlobal);
        uiNumFiles = pfgdW->cItems;
        pfdW = &pfgdW->fgd[0];
    }
    else
    {
        IF_FAILEXIT(hr = pDataObj->GetData(&fetcFileDescA, &stgmedDesc));

        fUnicode = FALSE;
        pfgdA = (LPFILEGROUPDESCRIPTORA)GlobalLock(stgmedDesc.hGlobal);
        uiNumFiles = pfgdA->cItems;
        pfdA = &pfgdA->fgd[0];
    }

    // Loop through the contents
    for (uiCurrFile = 0; uiCurrFile < uiNumFiles; ++uiCurrFile)
    {
        if (fUnicode)
        {
            fIsDirectory = (pfdW->dwFlags & FD_ATTRIBUTES) && 
                           (pfdW->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
            IF_NULLEXIT(pwszFileName = PszDupW(pfdW->cFileName));

            ++pfdW;
        }
        else
        {
            fIsDirectory = (pfdA->dwFlags & FD_ATTRIBUTES) && 
                           (pfdA->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
            IF_NULLEXIT(pwszFileName = PszToUnicode(CP_ACP, pfdA->cFileName));

            ++pfdA;
        }

        // if we have a directory, there's no contents for it, just filename, so let's
        // see if the user wants us to make a link...
        if (!fLink && fIsDirectory)
        {
            if(fFirstDirectory)
            {
                int id;
                // Tell the user that he's been a bad user
                id=AthMessageBoxW(m_hwndParent,
                                  MAKEINTRESOURCEW(idsAthena), 
                                  MAKEINTRESOURCEW(idsDropLinkDirs), 
                                  NULL, 
                                  MB_ICONEXCLAMATION|MB_SETFOREGROUND|MB_YESNOCANCEL);
                
                if(id==IDCANCEL)
                {
                    hr=NOERROR;
                    goto exit;
                }
                fLinkDirectories = (id == IDYES);
                fFirstDirectory = FALSE;
            }
            if(fLinkDirectories)
                hr=HrInsertFileFromStgMed(pwszFileName, NULL, TRUE);
        }
        else
        {
            // Since we have the UNICODE filename with pwszFileName, we don't
            // need to worry about making sure stgmedContents is UNICODE.
            STGMEDIUM stgmedContents;
            ZeroMemory(&stgmedContents, sizeof(STGMEDIUM));
        
            fetcFileContents.lindex = uiCurrFile;
            IF_FAILEXIT(hr = pDataObj->GetData(&fetcFileContents, &stgmedContents));
        
            switch (stgmedContents.tymed)
            {
                case TYMED_HGLOBAL:
                case TYMED_ISTREAM:
                    hr=HrInsertFileFromStgMed(pwszFileName, &stgmedContents, fLink);
                    break;
            
                default:
                    AssertSz(FALSE, "Unexpected TYMED");
                    break;
            }
            ReleaseStgMedium(&stgmedContents);
        }
        SafeMemFree(pwszFileName);
    }


exit:
    SetCursor(hcursor);

    if (pfgdA || pfgdW)
        GlobalUnlock(stgmedDesc.hGlobal);

    MemFree(pwszFileName);
    ReleaseStgMedium(&stgmedDesc);

    return hr;
}

static const HELPMAP g_rgCtxMapMailGeneral[] = {
    {chx2, IDH_INSERT_ATTACHMENT_MAKE_SHORTCUT},
    {0,0}};

BOOL CALLBACK CAttMan::InsertFileDlgHookProc(HWND hwnd, UINT msg, WPARAM wParam,LPARAM lParam)
{
    char szTemp[MAX_PATH];
    HRESULT hr;
    
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            HWND hwndParent = GetParent(hwnd);
            
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)(((LPOPENFILENAME)lParam)->lCustData)); 
            
            // Bug 1073: Replace the "Open" button with "Attach"
            if (AthLoadString(idsAttach, szTemp, ARRAYSIZE(szTemp)))
                SetDlgItemText(hwndParent, IDOK, szTemp);
            
            if (AthLoadString(idsInsertAttachment, szTemp, ARRAYSIZE(szTemp)))
                SetWindowText(hwndParent, szTemp);
        
            CenterDialog( hwnd );
            return TRUE;
        }
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgCtxMapMailGeneral);

        case WM_NOTIFY:
            {
                if (CDN_FILEOK == ((LPNMHDR)lParam)->code)
                {
                    AssertSz(sizeof(OPENFILENAMEW) == sizeof(OPENFILENAMEA), "Win9x will give us OPENFILENAMEA");
                    OPENFILENAMEW  *pofn = ((OFNOTIFYW*)lParam)->lpOFN;
                    AssertSz(pofn, "Why didn't we get a OPENFILENAMEA struct???");
                    ATTMANCUSTOM   *pCustom = (ATTMANCUSTOM*)(pofn->lCustData);

                    pCustom->fShortcut = IsDlgButtonChecked(hwnd, chx2);

                    // If we are ANSI and we have mutiple files, then we need to 
                    // convert the entire filepath and pass it back up to our 
                    // caller since shlwapi doesn't handle multiple files during conversion
                    if (!IsWindowUnicode(hwnd))
                    {
                        LPSTR   pszSrc = (LPSTR)pofn->lpstrFile;
                        LPWSTR  pszDest = pCustom->szFiles;
                        WORD    nFilePathLen = (WORD) lstrlen(pszSrc);
                        if (pofn->nFileOffset > nFilePathLen)
                        {
                            pCustom->nFileOffset = nFilePathLen + 1;
                            int nChars = ARRAYSIZE(pCustom->szFiles);
                            while (*pszSrc && (nChars>0))
                            {
                                DWORD cLenAndNull = lstrlen(pszSrc) + 1;
                                DWORD cchWideAndNull = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, 
                                                                            pszSrc, cLenAndNull, 
                                                                            pszDest, nChars);
                                // Since the original buffers (custom and lpstrFile) were both static
                                // sized arrays of the same length, we know that pszDest will never be
                                // accessed beyond its end.
                                pszSrc += cLenAndNull;
                                pszDest += cchWideAndNull;
                                nChars -= cchWideAndNull;
                            }

                            //bobn: 75453 not copying second null
                            *pszDest=0;
                        }
                    }

                    return TRUE;
                }
            }        
    }
    return FALSE;
}

HRESULT CAttMan::HrUpdateToolbar(HWND hwndToolbar)
{
    if (GetFocus() == m_hwndList)
    {
        // if we have focus, kill the edit cut|copy paste btns
        EnableDisableEditToolbar(hwndToolbar, 0);
    }
    return S_OK;
}


HRESULT CAttMan::HrInsertFileFromStgMed(LPWSTR pwszFileName, LPSTGMEDIUM pstgmed, BOOL fMakeLinks)
{
    HRESULT     hr=NOERROR;
    LPSTREAM    pStmToFree = NULL,
                pAttachStm = NULL;
    
    if(!pstgmed)
    {
        AssertSz(fMakeLinks, "this should always be true if there is no stgmedium!");
        fMakeLinks = TRUE;
    }
    else
        switch (pstgmed->tymed)
        {
            case TYMED_HGLOBAL:
                hr=CreateStreamOnHGlobal(pstgmed->hGlobal, TRUE, &pStmToFree);
                if(SUCCEEDED(hr))
                {
                    // NULL out the hglobal do it doesn't get free'd
                    pstgmed->hGlobal=NULL;
                    pAttachStm = pStmToFree;
                }
                break;
        
            case TYMED_ISTREAM:
                pAttachStm = pstgmed->pstm;
                break;
        
            default:
                AssertSz(FALSE, "unexpected tymed");
                hr =  E_UNEXPECTED;
                break;
        }

    if (SUCCEEDED(hr))
        hr = HrAddAttachment(pwszFileName, pAttachStm, fMakeLinks);

    ReleaseObj(pStmToFree);

    return hr;
}
    
    

HRESULT CAttMan::HrBuildHDrop(PDATAOBJINFO *ppdoi)
{
    LPDROPFILES     lpDrop=0;
    LPWSTR         *rgpwszTemp=NULL,
                    pwszPath;
    LPSTR          *rgpszTemp=NULL,
                    pszPath;
    int             cFiles,
                    i;
    LV_ITEMW        lvi;
    ULONG           cb;
    HRESULT         hr = S_OK;
    LPATTACHDATA    lpAttach;

    // Since win9x can't handle unicode names, the fWide parameter in the 
    // DROPFILES struct is ignored. So in the win9x case, we need to do
    // special conversions here when building the HDROP. One thing to note,
    // the temp files that are generated on win9x will already be safe for 
    // the system code page. The temp file names might differ from the actual
    // file name, but the temp file name will be ok.
    BOOL            fWinNT = (VER_PLATFORM_WIN32_NT == g_OSInfo.dwPlatformId);
        
    if(!ppdoi)
        return TraceResult(E_INVALIDARG);

    *ppdoi=NULL;

    cFiles=ListView_GetSelectedCount(m_hwndList);
    if(!cFiles)
        return TraceResult(E_FAIL);    // nothing to build

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem=-1;
    
    // Walk the list and find out how much space we need.
    if (fWinNT)
    {
        IF_NULLEXIT(MemAlloc((LPVOID *)&rgpwszTemp, sizeof(LPWSTR)*cFiles));
        ZeroMemory(rgpwszTemp, sizeof(LPWSTR)*cFiles);
    }
    else
    {
        IF_NULLEXIT(MemAlloc((LPVOID *)&rgpszTemp, sizeof(LPSTR)*cFiles));
        ZeroMemory(rgpszTemp, sizeof(LPSTR)*cFiles);
    }
     
    cFiles = 0;
    cb = sizeof(DROPFILES);

    while(((lvi.iItem=ListView_GetNextItem(m_hwndList, lvi.iItem, 
                                                LVNI_SELECTED|LVNI_ALL))!=-1))
    {
        if (!SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
        {
            hr=E_FAIL;
            goto exit;
        }
                    
        if (!(lpAttach=(LPATTACHDATA)lvi.lParam))
        {
            hr=E_FAIL;
            goto exit;
        }

        IF_FAILEXIT(hr = HrGetTempFile(lpAttach));

        if (fWinNT)
        {
            rgpwszTemp[cFiles] = lpAttach->szTempFile;
            cb+=(lstrlenW(rgpwszTemp[cFiles++]) + 1)*sizeof(WCHAR);
        }
        else
        {
            rgpszTemp[cFiles] = PszToANSI(CP_ACP, lpAttach->szTempFile);
            cb+=(lstrlen(rgpszTemp[cFiles++]) + 1)*sizeof(CHAR);
        }
    }

    //double-null term at end.
    if (fWinNT)
        cb+=sizeof(WCHAR);
    else
        cb+=sizeof(CHAR);
    
    // Allocate the buffer and fill it in.
    IF_NULLEXIT(MemAlloc((LPVOID*) &lpDrop, cb));
    ZeroMemory(lpDrop, cb);

    lpDrop->pFiles = sizeof(DROPFILES);
    lpDrop->fWide = fWinNT;

    // Fill in the path names.
    if (fWinNT)
    {
        pwszPath = (LPWSTR)((BYTE *)lpDrop + sizeof(DROPFILES));
        PWSTR pwszEnd = (LPWSTR)((BYTE *)lpDrop + cb);
        for(i=0; i<cFiles; i++)
        {
            StrCpyNW(pwszPath, rgpwszTemp[i], (DWORD)(pwszEnd-pwszPath));
            pwszPath += lstrlenW(rgpwszTemp[i])+1;
        }
    }
    else
    {
        pszPath = (LPSTR)((BYTE *)lpDrop + sizeof(DROPFILES));
        PSTR pszEnd = (LPSTR)((BYTE *)lpDrop + cb);
        for(i=0; i<cFiles; i++)
        {
            StrCpyN(pszPath, rgpszTemp[i], (DWORD)(pszEnd-pszPath));
            pszPath += lstrlen(rgpszTemp[i])+1;
        }
    }


    // Now allocate the DATAOBJECTINFO struct 
    IF_NULLEXIT(MemAlloc((LPVOID*) ppdoi, sizeof(DATAOBJINFO)));
    
    SETDefFormatEtc((*ppdoi)->fe, CF_HDROP, TYMED_HGLOBAL);
    (*ppdoi)->pData = (LPVOID) lpDrop;
    (*ppdoi)->cbData = cb;
    
    // Don't free the dropfiles struct
    lpDrop = NULL;

exit:
    MemFree(lpDrop);
    MemFree(rgpwszTemp);
    if (rgpszTemp)
    {
        for(i=0; i<cFiles; i++)
            MemFree(rgpszTemp[i]);
        MemFree(rgpszTemp);
    }
    return TraceResult(hr);
}

/*
 * IDropSource::
 */
HRESULT CAttMan::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
    DOUTL(8, "IDS::QueryContDrag()");
    if(fEscapePressed)
        return ResultFromScode(DRAGDROP_S_CANCEL);

    if(!(grfKeyState & m_dwDragType))
        return ResultFromScode(DRAGDROP_S_DROP);
    
    return NOERROR;
}

HRESULT CAttMan::GiveFeedback(DWORD dwEffect)
{
    DOUTL(8, "IDS::GiveFeedback()");
    return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}


/*
 * HrGetRequiredAction()
 * 
 * Purpose:    this method is called in response to a
 *             drag with the right mouse clicked rather 
 *             than the left.  A context menu is displayed
 */

HRESULT CAttMan::HrGetRequiredAction(DWORD *pdwEffect, POINTL pt)
{
    // Pop up the context menu.
    //
    HMENU       hMenu;
    UINT        idCmd;
    HRESULT     hr = E_FAIL;
    
    *pdwEffect = DROPEFFECT_NONE;

    Assert(m_hwndList);

    hMenu = LoadPopupMenu(IDR_ATTACHMENT_DRAGDROP_POPUP);
    if (!hMenu)
        goto cleanup;

    MenuUtil_SetPopupDefault(hMenu, ID_MOVE);

    idCmd = TrackPopupMenuEx(hMenu, TPM_RETURNCMD|TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
                                pt.x, pt.y, m_hwndList, NULL);

    switch(idCmd)
    {
        case ID_MOVE:
            *pdwEffect = DROPEFFECT_MOVE;
            break;
        case ID_COPY:
            *pdwEffect = DROPEFFECT_COPY;
            break;
        case ID_CREATE_SHORTCUT:
            *pdwEffect = DROPEFFECT_LINK;
            break;
        default:
            // cancelled
            goto cleanup;
    }

    hr = S_OK;

cleanup:
    if(hMenu)
        DestroyMenu(hMenu);

    return hr;
}

/*
 * It is critical that any client of the Attman calls HrClose to drop it's refcounts.
 *
 */
HRESULT CAttMan::HrClose()
{
    HrUnload();

#if 0
    if(m_fDropTargetRegister)
        {
        Assert(m_hwndList && IsWindow(m_hwndList));
        RevokeDragDrop(m_hwndList);
        CoLockObjectExternal((LPUNKNOWN)(LPDROPTARGET)this, FALSE, TRUE);
        }
#endif

    return S_OK;
}

//Adds a new attach to m_rgpAttach and places the new attach in a proper hole
HRESULT CAttMan::HrAllocNewEntry(LPATTACHDATA pAttach)
{
    ULONG           uAttach;

    if (m_cAlloc==m_cAttach)
    {
        DOUTL(4, "HrGrowAttachStruct:: Growing Table");

        // grow time!!
        m_cAlloc+=CACHE_GROW_SIZE;

        if (!MemRealloc((LPVOID *)&m_rgpAttach, sizeof(LPATTACHDATA)*m_cAlloc))
            return E_OUTOFMEMORY;

        // zeroinit new memory
        ZeroMemory(&m_rgpAttach[m_cAttach], sizeof(LPATTACHDATA)*CACHE_GROW_SIZE);
    }

    // find a hole to put the new data into
    for (uAttach=0; uAttach<m_cAlloc; uAttach++)
        if (m_rgpAttach[uAttach]==NULL)
        {
            m_rgpAttach[uAttach]=pAttach;
            break;
        }

    AssertSz(uAttach!=m_cAlloc, "Woah! we went off the end!");
    m_cAttach++;
    return S_OK;
}

// Only used when the function is adding attachs from a IMimeMessage
HRESULT CAttMan::HrAddData(HBODY hAttach)
{
    LPATTACHDATA    pAttach=0;
    LPMIMEBODY      pBody=0;
    HRESULT         hr;

    Assert(hAttach);
    Assert(m_pMsg);

    hr = HrAttachDataFromBodyPart(m_pMsg, hAttach, &pAttach);
    if (!FAILED(hr))
    {
        if (m_fDeleteVCards && StrStrIW(PathFindExtensionW(pAttach->szFileName), L".vcf"))
            return S_OK;

        hr = HrAllocNewEntry(pAttach);
        if (!FAILED(hr))
            return S_OK;        // don't free pAttach as it's owned by the table now
        MemFree(pAttach);
    }
    return S_OK;
}

// Only used when the function is adding attachs from outside of an IMimeMessage
HRESULT CAttMan::HrAddData(LPWSTR lpszPathName, LPSTREAM pstm, LPATTACHDATA *ppAttach)
{
    LPATTACHDATA    pAttach;
    HRESULT         hr;

    hr = HrAttachDataFromFile(pstm, lpszPathName, &pAttach);
    if (!FAILED(hr))
    {
        hr = HrAllocNewEntry(pAttach);    
        if (!FAILED(hr))
        {
            if (ppAttach)
                *ppAttach=pAttach;
            return S_OK;                // don't free pAttach as it's owned by the table now
        }
        MemFree(pAttach);
    }
    return hr;
}

HRESULT CAttMan::HrFreeAllData()
{
    ULONG   uAttach;

    for (uAttach=0; uAttach<m_cAlloc; uAttach++)
        if (m_rgpAttach[uAttach])
        {
            HrFreeAttachData(m_rgpAttach[uAttach]);
            m_rgpAttach[uAttach] = NULL;
        }

    SafeMemFree(m_rgpAttach);
    m_cAlloc=0;
    m_cAttach=0;
    m_iVCard = -1;
    if (m_szUnsafeAttachList != NULL)
        SafeMemFree(m_szUnsafeAttachList);
    m_cUnsafeAttach = 0;

    return NOERROR;
}



HRESULT CAttMan::HrDoVerb(LPATTACHDATA lpAttach, INT nVerb)
{
    HRESULT     hr;
    ULONG       uVerb = AV_MAX;

    if (!lpAttach)
        return E_INVALIDARG;

    switch (nVerb)
    {
        case ID_SAVE_ATTACH_AS:
            uVerb = AV_SAVEAS;
            break;

        case ID_OPEN:
            uVerb = AV_OPEN;
            break;

        case ID_PRINT:
            uVerb = AV_PRINT;
            break;

        case ID_QUICK_VIEW:
            uVerb = AV_QUICKVIEW;
            break;
        
        default:
            AssertSz(0, "BAD ARGUMENT");
            return E_INVALIDARG;
    }

    hr = HrDoAttachmentVerb(m_hwndParent, uVerb, m_pMsg, lpAttach);
    
    if (FAILED(hr) && hr!=hrUserCancel)
        AthMessageBoxW(m_hwndParent,  
                       MAKEINTRESOURCEW(idsAthena),  
                       MAKEINTRESOURCEW(idsErrCmdFailed), 
                       NULL, MB_OK|MB_ICONEXCLAMATION);

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistMime::Load
HRESULT CAttMan::Load(LPMIMEMESSAGE pMsg)
{
    HRESULT hr;

    if(!pMsg)
        return E_INVALIDARG;

    HrUnload();

    ReplaceInterface(m_pMsg, pMsg);

    hr=HrBuildAttachList();
    if (FAILED(hr))
        goto error;


    hr=HrFillListView();
    if (ListView_GetItemCount(m_hwndList) > 0)
    {
        // if we went from 0->1 then select the first item
        ListView_SelectItem(m_hwndList, 0);
    }

    HrResizeParent();

    m_fDirty = FALSE;
error:
    return hr;
}

HRESULT CAttMan::CheckAttachNameSafeWithCP(CODEPAGEID cpID)
{
    LPATTACHDATA *currAttach = m_rgpAttach;
    HRESULT hr = S_OK;

    for (ULONG uAttach = 0; uAttach<m_cAlloc; uAttach++, currAttach++)
    {
        if (*currAttach)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP((*currAttach)->szFileName, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }
    }

exit:
    return hr;
}

// IPersistMime::Save
HRESULT CAttMan::Save(LPMIMEMESSAGE pMsg, DWORD dwFlags)
{
    ULONG   uAttach;
    LPATTACHDATA *currAttach = m_rgpAttach;
    HRESULT hr = S_OK;

    for (uAttach=0; uAttach<m_cAlloc; uAttach++)
    {
        if (*currAttach)
        {
            HBODY           currHAttach = (*currAttach)->hAttach;
            LPMIMEMESSAGEW  pMsgW = NULL;
            LPWSTR          pszFileName = (*currAttach)->szFileName;
            LPSTREAM        lpStrmPlaceHolder = (*currAttach)->pstm,
                            lpstrm = NULL;
            BOOL            fAttachFile = TRUE;

            if (SUCCEEDED(pMsg->QueryInterface(IID_IMimeMessageW, (LPVOID*)&pMsgW)))
            {
                //If attachment at load time (i.e. from m_pMsg)
                if (currHAttach)
                {
                    LPMIMEBODY pBody = NULL;
                    if (S_OK == m_pMsg->BindToObject(currHAttach, IID_IMimeBody, (LPVOID *)&pBody))
                    {
                        if (pBody->GetData(IET_INETCSET, &lpstrm)==S_OK)
                            lpStrmPlaceHolder = lpstrm;
                        else
                            fAttachFile = FALSE;

                        ReleaseObj(pBody);
                    }
                }

                //If attachment was added after load time
                if (!fAttachFile || FAILED(pMsgW->AttachFileW(pszFileName, lpStrmPlaceHolder, NULL)))
                    hr = E_FAIL;

                ReleaseObj(lpstrm);
                ReleaseObj(pMsgW);
            }
            else
                hr = E_FAIL;
        }
        currAttach++;
    }

    if (FAILED(hr))
    {
        if (AthMessageBoxW( m_hwndParent,
                            MAKEINTRESOURCEW(idsAthena),
                            MAKEINTRESOURCEW(idsSendWithoutAttach),
                            NULL, MB_YESNO|MB_ICONEXCLAMATION )==IDYES)
            hr = S_OK;
        else
            hr = MAPI_E_USER_CANCEL;
    }
    return hr;
}


// IPersist::GetClassID
HRESULT CAttMan::GetClassID(CLSID *pClsID)
{
    //TODO: If ever expose, should return a valid ID
	return E_NOTIMPL;
}


HRESULT CAttMan::HrSaveAs(LPATTACHDATA lpAttach)
{
    HRESULT         hr = S_OK;
    OPENFILENAMEW   ofn;
    WCHAR           szTitle[CCHMAX_STRINGRES],
                    szFilter[CCHMAX_STRINGRES],
                    szFile[MAX_PATH];

    *szFile=0;
    *szFilter=0;
    *szTitle=0;

    Assert (*lpAttach->szFileName);
    StrCpyNW(szFile, lpAttach->szFileName, MAX_PATH);

    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = m_hwndParent;
    AthLoadStringW(idsFilterAttSave, szFilter, ARRAYSIZE(szFilter));
    ReplaceCharsW(szFilter, _T('|'), _T('\0'));
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = ARRAYSIZE(szFile);
    AthLoadStringW(idsSaveAttachmentAs, szTitle, ARRAYSIZE(szTitle));
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    // Show SaveAs Dialog
    if (HrAthGetFileNameW(&ofn, FALSE) != S_OK)
    {
        hr = hrUserCancel;
        goto error;
    }

    // Verify the Attachment's Stream
    hr=HrSave(lpAttach->hAttach, szFile);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}


HRESULT CAttMan::HrGetTempFile(LPATTACHDATA lpAttach)
{
    HRESULT         hr;

    if (*lpAttach->szTempFile)
        return S_OK;

    // Since win9x can't handle filenames very well, let's try to handle this
    // by converting the temp names to something workable in win9x.
    if (VER_PLATFORM_WIN32_NT == g_OSInfo.dwPlatformId)
    {
        if (!FBuildTempPathW(lpAttach->szFileName, lpAttach->szTempFile, ARRAYSIZE(lpAttach->szTempFile), FALSE))
        {
            hr = E_FAIL;
            goto error;
        }
    }
    else
    {
        // Since we are on win95, the temp path will never be bad ANSI. Don't need to bother
        // converting to ANSI and back to UNICODE 
        BOOL fSucceeded = FBuildTempPathW(lpAttach->szFileName, lpAttach->szTempFile, ARRAYSIZE(lpAttach->szTempFile), FALSE);
        if (!fSucceeded)
        {
            hr = E_FAIL;
            goto error;
        }
    }

    if (lpAttach->hAttach == NULL && lpAttach->pstm)
    {
        // if no attachment, but just stream data
        hr = WriteStreamToFileW(lpAttach->pstm, lpAttach->szTempFile, CREATE_NEW, GENERIC_WRITE);
    }
    else
    {
        hr=HrSave(lpAttach->hAttach, lpAttach->szTempFile);
    }

    if (FAILED(hr))
        goto error;

error:
    if (FAILED(hr))
    {
        // Null out temp file as we didn't really create it
        *(lpAttach->szTempFile)=0;
    }
    return hr;
}


HRESULT CAttMan::HrCleanTempFile(LPATTACHDATA lpAttach)
{

    if ((lpAttach->szTempFile) && ('\0' != lpAttach->szTempFile[0]))
    {
        // If the file was launched, don't delete the temp file if the process still has it open
        if (lpAttach->hProcess)
        {
            DWORD dwState = WaitForSingleObject (lpAttach->hProcess, 0);
            if (dwState == WAIT_OBJECT_0)
                DeleteFileWrapW(lpAttach->szTempFile);
        }
        else
            DeleteFileWrapW(lpAttach->szTempFile);
    }

    *lpAttach->szTempFile = NULL;
    lpAttach->hProcess=NULL;
    return NOERROR;
}


HRESULT CAttMan::HrSave(HBODY hAttach, LPWSTR lpszFileName)
{
    IMimeBodyW     *pBody = NULL;
    HRESULT         hr;

    hr = m_pMsg->BindToObject(hAttach, IID_IMimeBodyW, (LPVOID *)&pBody);

    if (SUCCEEDED(hr))
        hr = pBody->SaveToFileW(IET_INETCSET, lpszFileName);

    ReleaseObj(pBody);
    return hr;
}


HRESULT CAttMan::HrCmdEnabled(UINT idm, LPBOOL pbEnable)
{
    Assert (pbEnable);
    return S_FALSE;
}


HRESULT CAttMan::HrIsDragSource()
{
    return (m_fDragSource ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\columns.cpp ===
#include "pch.hxx"
#include <shlwapi.h>
#include "resource.h"
#include "msoeobj.h"
#include "strconst.h"
#include "columns.h"
#include "error.h"
#include "imagelst.h"
#include "msgview.h"
#include "shlwapip.h" 
#include "goptions.h"
#include "demand.h"
#include "menures.h"

const COLUMN_DATA c_rgColumnData[COLUMN_MAX] =
{
    /*  COLUMN_TO           */  { idsTo,            155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_FROM         */  { idsFrom,          155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_SUBJECT      */  { idsSubject,       280, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_RECEIVED     */  { idsReceived,      110, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_SENT         */  { idsSent,          110, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_SIZE         */  { idsSize,           75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_FOLDER       */  { idsFolder,        155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_TOTAL        */  { idsTotal,          75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_UNREAD       */  { idsUnread,         75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_NEW          */  { idsNew,            75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_DESCRIPTION  */  { idsDescription,   250, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_LAST_UPDATED */  { idsLastUpdated,   155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_WASTED_SPACE */  { idsWastedSpace,    75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_ACCOUNT      */  { idsAccount,       155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_LINES        */  { idsColLines,       75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_PRIORITY     */  { idsColPriority,    19, LVCFMT_LEFT,  iiconHeaderPri },    
    /*  COLUMN_ATTACHMENT   */  { idsColAttach,      22, LVCFMT_LEFT,  iiconHeaderAttach }, 
    /*  COLUMN_SHOW         */  { idsShow,           39, LVCFMT_LEFT,  IICON_TEXTHDR },
    /*  COLUMN_DOWNLOAD     */  { idsColDownload,   155, LVCFMT_LEFT,  0 }, 
    /*  COLUMN_NEWSGROUP    */  { idsNewsgroup,     155, LVCFMT_LEFT,  0 }, 
    /*  COLUMN_FLAG         */  { idsFlag,           25, LVCFMT_LEFT,  iiconHeaderFlag },
    /*  COLUMN_SUBSCRIBE    */  { idsSubscribe,      59, LVCFMT_LEFT,  IICON_TEXTHDR },
    /*  COLUMN_DOWNLOADMSG  */  { idsColDownloadMsg, 23, LVCFMT_LEFT,  iiconHeaderDownload },
    /*  COLUMN_THREADSTATE  */  { idsColThreadState, 29, LVCFMT_LEFT,  iiconHeaderThreadState }
};


const COLUMN_SET c_rgColDefaultMail[] =
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FLAG,          COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_RECEIVED,      COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_SENT,          0, -1 },
    { COLUMN_TO,            0, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 }
};


const COLUMN_SET c_rgColDefaultOutbox[] = 
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_TO,            COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_SENT,          COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_FROM,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_RECEIVED,      0, -1 },
    { COLUMN_FLAG,          COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 }
};


const COLUMN_SET c_rgColDefaultNews[] =
{
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SENT,          COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_SIZE,          COLFLAG_VISIBLE, -1 },
    { COLUMN_FLAG,          COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_LINES,         0, -1 }
};


const COLUMN_SET c_rgColDefaultIMAP[] =
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE, -1 },
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FLAG,          COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_RECEIVED,      COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_SENT,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_TO,            0, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 }
};


const COLUMN_SET c_rgColDefaultIMAPOutbox[] = 
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_TO,            COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_SENT,          COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_FROM,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_RECEIVED,      0, -1 },
    { COLUMN_FLAG,          COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_FIXED_WIDTH, -1 }
};


const COLUMN_SET c_rgColDefaultFind[] =
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FLAG,          COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_RECEIVED,      COLFLAG_VISIBLE, -1 },
    { COLUMN_FOLDER,        COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       0, -1 },
    { COLUMN_SENT,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_TO,            0, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_LINES,         0, -1 }
};


const COLUMN_SET c_rgColDefaultNewsAccount[] =
{
    { COLUMN_NEWSGROUP,     COLFLAG_VISIBLE, -1 },
    { COLUMN_UNREAD,        COLFLAG_VISIBLE, -1 },
    { COLUMN_TOTAL,         COLFLAG_VISIBLE, -1 },
    { COLUMN_DOWNLOAD,      COLFLAG_VISIBLE, -1 },
};


const COLUMN_SET c_rgColDefaultIMAPAccount[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
    { COLUMN_UNREAD,        COLFLAG_VISIBLE, -1 },
    { COLUMN_TOTAL,         COLFLAG_VISIBLE, -1 },
    { COLUMN_DOWNLOAD,      COLFLAG_VISIBLE, -1 },
};


const COLUMN_SET c_rgColDefaultLocalStore[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
    { COLUMN_UNREAD,        COLFLAG_VISIBLE, -1 },
    { COLUMN_TOTAL,         COLFLAG_VISIBLE, -1 },
};


const COLUMN_SET c_rgColDefaultNewsSub[] =
{
    { COLUMN_NEWSGROUP,     COLFLAG_VISIBLE, -1 },
    { COLUMN_DESCRIPTION,   COLFLAG_VISIBLE, -1 },
};


const COLUMN_SET c_rgColDefaultImapSub[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
};

const COLUMN_SET c_rgColDefaultOffline[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
    { COLUMN_DOWNLOAD,      COLFLAG_VISIBLE, -1 },
};

const COLUMN_SET c_rgColDefaultPickGrp[] =
{
    { COLUMN_NEWSGROUP,     COLFLAG_VISIBLE, -1 },
};

const COLUMN_SET c_rgColDefaultHTTPMail[] =
{
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_RECEIVED,      COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 }
};

const COLUMN_SET c_rgColDefaultHTTPMailAccount[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
    { COLUMN_UNREAD,        COLFLAG_VISIBLE, -1 },
    { COLUMN_TOTAL,         COLFLAG_VISIBLE, -1 },
    { COLUMN_DOWNLOAD,      COLFLAG_VISIBLE, -1 },
};

const COLUMN_SET c_rgColDefaultHTTPMailOutbox[] =
{
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_TO,            COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_SENT,          COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_FROM,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_RECEIVED,      0, -1 },
    { COLUMN_FLAG,          COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_FIXED_WIDTH, -1 }
};

// NOTE - Keep this in the same order as COLUMN_SET_TYPE enumeration. 
const COLUMN_SET_INFO c_rgColumnSetInfo[COLUMN_SET_MAX] =
{
    { COLUMN_SET_MAIL,              ARRAYSIZE(c_rgColDefaultMail),              c_rgColDefaultMail,             c_szRegMailColsIn,          TRUE },
    { COLUMN_SET_OUTBOX,            ARRAYSIZE(c_rgColDefaultOutbox),            c_rgColDefaultOutbox,           c_szRegMailColsOut,         TRUE },
    { COLUMN_SET_NEWS,              ARRAYSIZE(c_rgColDefaultNews),              c_rgColDefaultNews,             c_szRegNewsCols,            TRUE },
    { COLUMN_SET_IMAP,              ARRAYSIZE(c_rgColDefaultIMAP),              c_rgColDefaultIMAP,             c_szRegIMAPCols,            TRUE },
    { COLUMN_SET_IMAP_OUTBOX,       ARRAYSIZE(c_rgColDefaultIMAPOutbox),        c_rgColDefaultIMAPOutbox,       c_szRegIMAPColsOut,         TRUE },
    { COLUMN_SET_FIND,              ARRAYSIZE(c_rgColDefaultFind),              c_rgColDefaultFind,             c_szRegFindPopCols,         TRUE },
    { COLUMN_SET_NEWS_ACCOUNT,      ARRAYSIZE(c_rgColDefaultNewsAccount),       c_rgColDefaultNewsAccount,      c_szRegAccountNewsCols,     FALSE },
    { COLUMN_SET_IMAP_ACCOUNT,      ARRAYSIZE(c_rgColDefaultIMAPAccount),       c_rgColDefaultIMAPAccount,      c_szRegAccountIMAPCols,     FALSE },
    { COLUMN_SET_LOCAL_STORE,       ARRAYSIZE(c_rgColDefaultLocalStore),        c_rgColDefaultLocalStore,       c_szRegLocalStoreCols,      FALSE },
    { COLUMN_SET_NEWS_SUB,          ARRAYSIZE(c_rgColDefaultNewsSub),           c_rgColDefaultNewsSub,          c_szRegNewsSubCols,         FALSE },
    { COLUMN_SET_IMAP_SUB,          ARRAYSIZE(c_rgColDefaultImapSub),           c_rgColDefaultImapSub,          c_szRegImapSubCols,         FALSE },
    { COLUMN_SET_OFFLINE,           ARRAYSIZE(c_rgColDefaultOffline),           c_rgColDefaultOffline,          c_szRegOfflineCols,         FALSE },
    { COLUMN_SET_PICKGRP,           ARRAYSIZE(c_rgColDefaultPickGrp),           c_rgColDefaultPickGrp,          NULL,                       FALSE },
    { COLUMN_SET_HTTPMAIL,          ARRAYSIZE(c_rgColDefaultHTTPMail),          c_rgColDefaultHTTPMail,         c_szRegHTTPMailCols,        TRUE },
    { COLUMN_SET_HTTPMAIL_ACCOUNT,  ARRAYSIZE(c_rgColDefaultHTTPMailAccount),   c_rgColDefaultHTTPMailAccount,  c_szRegHTTPMailAccountCols, FALSE },
    { COLUMN_SET_HTTPMAIL_OUTBOX,   ARRAYSIZE(c_rgColDefaultHTTPMailOutbox),    c_rgColDefaultHTTPMailOutbox,   c_szRegHTTPMailColsOut,     TRUE },
};


/////////////////////////////////////////////////////////////////////////////
// CColumns
//

CColumns::CColumns() 
{
    m_cRef = 1;
    m_fInitialized = FALSE;
    m_pColumnSet = NULL;
    m_cColumns = 0;
    m_idColumnSort = COLUMN_SUBJECT;
    m_fAscending = TRUE;
}

CColumns::~CColumns()
{
    SafeMemFree(m_pColumnSet);
}


//
//  FUNCTION:   CColumns::Init()
//
//  PURPOSE:    Initializes the class with the listview and column set type
//              that will be used later.
//
//  PARAMETERS: 
//      [in] hwndList - Handle of the ListView window that we will manage 
//                      columns for.
//      [in] type     - Type of column set to apply to this window.
//
//  RETURN VALUE:
//      S_OK - The data was groovy
//      E_INVALIDARG - The data was heinous
//
HRESULT CColumns::Initialize(HWND hwndList, COLUMN_SET_TYPE type)
{
    // Verify what was given to us
    if (!IsWindow(hwndList))
    {
        AssertSz(!IsWindow(hwndList), "CColumns::Init() - Called with an invalid window handle.");
        return (E_INVALIDARG);
    }

    if (type >= COLUMN_SET_MAX)
    {
        AssertSz(type >= COLUMN_SET_MAX, "CColumns::Init() - Called with an invalid column set type.");
        return (E_INVALIDARG);
    }

    // Save the information for later
    m_wndList.Attach(hwndList);
    m_type = type;
    m_hwndHdr = ListView_GetHeader(m_wndList);
    m_fInitialized = TRUE;

    return (S_OK);
}


//
//  FUNCTION:   CColumns::ApplyColumns()
//
//  PURPOSE:    Takes the current column set and applies it to the ListView
//              that was provided in the call to Init().
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CColumns::ApplyColumns(COLUMN_LOAD_TYPE type, LPBYTE pb, DWORD cb)
{   
    HKEY hkey;
    DWORD cbSize, dwType;
    LPBYTE pbT = NULL;
    COLUMN_PERSIST_INFO *pInfo = (COLUMN_PERSIST_INFO *) pb;
    const COLUMN_SET *rgColumns = NULL;
    DWORD             cColumns = 0;

    // Verify that we have been initialized first
    if (!m_fInitialized)
    {
        AssertSz(m_fInitialized, "CColumns::ApplyColumns() - Class has not yet been initialized.");
        return (E_UNEXPECTED);
    }

    // Double check the listview didn't go away
    Assert(IsWindow(m_wndList));

    // Check to see what we're supposed to do
    if (type == COLUMN_LOAD_REGISTRY)
    {
        Assert(pInfo == NULL);

        if (ERROR_SUCCESS == AthUserOpenKey(c_szRegPathColumns, KEY_READ, &hkey))
        {
            cbSize = 0;
            if (c_rgColumnSetInfo[m_type].pszRegValue != NULL &&
                ERROR_SUCCESS == RegQueryValueEx(hkey, c_rgColumnSetInfo[m_type].pszRegValue, NULL, &dwType, NULL, &cbSize) &&
                dwType == REG_BINARY &&
                cbSize > 0)
            {
                if (MemAlloc((void **)&pbT, cbSize))
                {
                    if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_rgColumnSetInfo[m_type].pszRegValue, NULL, &dwType, pbT, &cbSize))
                        pInfo = (COLUMN_PERSIST_INFO *) pbT;
                }
            }

            RegCloseKey(hkey);
        }

        if (pInfo != NULL)
            type = COLUMN_LOAD_BUFFER;
        else
            type = COLUMN_LOAD_DEFAULT;
    }

    if (type == COLUMN_LOAD_BUFFER)
    {
        Assert(pInfo);
        if (pInfo->dwVersion == COLUMN_PERSIST_VERSION)
        {
            rgColumns = pInfo->rgColumns;
            cColumns = pInfo->cColumns;
        }
        else
        {
            // Do the default
            type = COLUMN_LOAD_DEFAULT;
        }
    }

    if (type == COLUMN_LOAD_DEFAULT)
    {
        // Verify some person didn't mess up the c_rgColumnSetInfo array.
        Assert(c_rgColumnSetInfo[m_type].type == m_type);

        // We couldn't load from the registry, so instead use the defaults.
        rgColumns = c_rgColumnSetInfo[m_type].rgColumns;
        cColumns = c_rgColumnSetInfo[m_type].cColumns;
    }

    // Update the listview to use these new columns
    _SetListViewColumns(rgColumns, cColumns);

    if (pbT != NULL)
        MemFree(pbT);

    return (S_OK);
}


HRESULT CColumns::Save(LPBYTE pBuffer, DWORD *pcb)
{
    HRESULT hr = S_OK;
    COLUMN_PERSIST_INFO *pInfo;
    DWORD dwSize;

    // Collect the information needed to get a COLUMN_PERSIST_INFO struct put
    // together.  First allocate a struct big enough.
    dwSize = sizeof(COLUMN_PERSIST_INFO) + (sizeof(COLUMN_SET) * (m_cColumns - 1));

    IF_NULLEXIT(pInfo = (COLUMN_PERSIST_INFO *) new BYTE[dwSize]);
      
    ZeroMemory( pInfo, dwSize);

    // Set the basic information
    pInfo->dwVersion = COLUMN_PERSIST_VERSION;
    pInfo->cColumns = m_cColumns;

    // We want to save the _ordered_ version of the columns
    DWORD rgOrder[COLUMN_MAX] = {0};

    // Get the count of columns in the header.  Make sure that matches
    // what we think we have.
#ifdef DEBUG
    DWORD cOrder;
    cOrder = Header_GetItemCount(m_hwndHdr);
    Assert(m_cColumns == cOrder);
#endif

    // The columns might have been reordered by the user, so get the order 
    // arrray from the ListView
    if (0 == (Header_GetOrderArray(m_hwndHdr, m_cColumns, rgOrder)))
        return (E_FAIL);

    // Now loop through out current column set and copy it to the structure
    COLUMN_SET *pColumnDst;
    DWORD       iColumn;
    for (iColumn = 0, pColumnDst = pInfo->rgColumns; iColumn < m_cColumns; iColumn++, pColumnDst++)
    {
        Assert(rgOrder[iColumn] < m_cColumns);

        *pColumnDst = m_pColumnSet[rgOrder[iColumn]];
        if (pColumnDst->id == m_idColumnSort)
        {
            // Clear out any old flags
            pColumnDst->flags &= ~(COLFLAG_SORT_ASCENDING | COLFLAG_SORT_DESCENDING);

            // Add the new one
            pColumnDst->flags |= (m_fAscending ? COLFLAG_SORT_ASCENDING : COLFLAG_SORT_DESCENDING);
        }
        else
        {
            pColumnDst->flags &= ~(COLFLAG_SORT_ASCENDING | COLFLAG_SORT_DESCENDING);
        }
    }

    if (pBuffer == NULL)
    {
        Assert(pcb == NULL);

        LRESULT lRes = AthUserSetValue(c_szRegPathColumns, c_rgColumnSetInfo[m_type].pszRegValue, REG_BINARY, (LPBYTE) pInfo, dwSize);

        Assert( lRes == ERROR_SUCCESS);

        if (lRes != ERROR_SUCCESS)
        {
            hr = E_FAIL;
        }
    }
    else if (dwSize <= *pcb)
    {
        CopyMemory(pBuffer, (LPBYTE) pInfo, dwSize);
        *pcb = dwSize;
    }
    else
    {
        hr = E_INVALIDARG;
    }
exit:

    SafeDelete(pInfo);

    return hr;
}


//
//  FUNCTION:   CColumns::_SetListViewColumns()
//
//  PURPOSE:    Takes the column set provided and inserts those columns into
//              the ListView.
//
//  PARAMETERS: 
//      [in] rgColumns - Array of columns to insert into the ListView
//      [in] cColumns  - Number of columns in rgColumns
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CColumns::_SetListViewColumns(const COLUMN_SET *rgColumns, DWORD cColumns)
{
    LV_COLUMN lvc;
    TCHAR     sz[CCHMAX_STRINGRES];

    // Set up the LV_COLUMN structure
    lvc.pszText = sz;

    // Remove any existing columns
    while (ListView_DeleteColumn(m_wndList, 0))
        ;

    // Reset this
    m_idColumnSort = COLUMN_MAX;

    // Loop through all of the columns in the provided rgColumns looking for
    // any that have an icon and is visible.  
    //
    // We have to do this because the listview requires that column zero have
    // text.  If the user doesn't want column zero to have text, ie attachment
    // column, then we insert that column as column 1, and use  
    // ListView_SetColumnOrderArray later to make it appear as if column zero
    // was the image-only column. -- steveser

    DWORD iColumn;
    DWORD iColumnSkip = cColumns;
    DWORD iInsertPos = 0;
    const COLUMN_SET *pColumn;

    for (iColumn = 0, pColumn = rgColumns; iColumn < cColumns; iColumn++, pColumn++)
    {
        if ((0 == c_rgColumnData[pColumn->id].iIcon) && (pColumn->flags & COLFLAG_VISIBLE))
        {
            iColumnSkip = iColumn;            

            // Insert this column into the ListView as column zero
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.iSubItem = 0;
            lvc.fmt = c_rgColumnData[pColumn->id].format;

            LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName, 
                       sz, ARRAYSIZE(sz));

            // If the column width provided is -1, then it hasn't been 
            // customized yet so use the default.
            if (pColumn->cxWidth == -1)
                lvc.cx = c_rgColumnData[pColumn->id].cxWidth;
            else
                lvc.cx = pColumn->cxWidth;

            // Insert the column
            ListView_InsertColumn(m_wndList, 0, &lvc);

            // Up the count for the next column position
            iInsertPos++;

            // Check to see if this is the sort column
            if ((pColumn->flags & COLFLAG_SORT_ASCENDING) || 
                (pColumn->flags & COLFLAG_SORT_DESCENDING))
            {
                m_idColumnSort = pColumn->id;
                m_fAscending = COLFLAG_SORT_ASCENDING == (pColumn->flags & COLFLAG_SORT_ASCENDING); 
            }

            // Bail out of this loop
            break;
        }
    }

    // Now insert the rest of the columns, skipping over the column we inserted
    // previously (stored in iColumnSkip).
    for (iColumn = 0, pColumn = rgColumns; iColumn < cColumns; iColumn++, pColumn++)
    {
        // If this column is visible and it's not the one we skipped over
        if ((pColumn->flags & COLFLAG_VISIBLE) && (iColumn != iColumnSkip))
        {
            // Figure out what the mask is and load the icon or string
            if (c_rgColumnData[pColumn->id].iIcon <= 0)
            {
                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName, 
                           sz, ARRAYSIZE(sz));                
            }
            else
            {
                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_IMAGE | LVCF_SUBITEM;
                lvc.iImage = c_rgColumnData[pColumn->id].iIcon;
            }

            lvc.iSubItem = iInsertPos;
            lvc.fmt = c_rgColumnData[pColumn->id].format;
            
            // If the column width provided is -1, then it hasn't been 
            // customized yet so use the default.
            if (pColumn->cxWidth == -1)
                lvc.cx = c_rgColumnData[pColumn->id].cxWidth;
            else
                lvc.cx = pColumn->cxWidth;

            // Check to see if this is the sort column
            if ((pColumn->flags & COLFLAG_SORT_ASCENDING) || 
                (pColumn->flags & COLFLAG_SORT_DESCENDING))
            {
                // Save the info
                m_idColumnSort = pColumn->id;
                m_fAscending = COLFLAG_SORT_ASCENDING == (pColumn->flags & COLFLAG_SORT_ASCENDING); 
            }

            // Insert this column
            ListView_InsertColumn(m_wndList, iInsertPos, &lvc);
      
            iInsertPos++;
        }
    }

    // If we had to skip over a column, the we need to set the column order
    // array so it appears correctly to the user.
    if (iColumnSkip > 0 && iColumnSkip < cColumns)
    {
        DWORD cColumnOrder = 0;
        int rgOrder[COLUMN_MAX];

        // Add all of the columns to the order array in order up to iColumnSkip
        for (iColumn = 1; iColumn <= iColumnSkip; iColumn++)
        {
            if (rgColumns[iColumn].flags & COLFLAG_VISIBLE)
                rgOrder[cColumnOrder++] = iColumn;
        }

        // Add the skipped column
        rgOrder[cColumnOrder++] = 0;

        // Add the rest of the columns
        for (iColumn = iColumnSkip + 1; iColumn < cColumns; iColumn++)
        {
            if (rgColumns[iColumn].flags & COLFLAG_VISIBLE)
                rgOrder[cColumnOrder++] = iColumn;
        }

        // Update the ListView
        ListView_SetColumnOrderArray(m_wndList, cColumnOrder, rgOrder);

        // Reorder the rgColumns passed in to match the order in the ListView
        // and keep a copy of it.
        if (m_pColumnSet)
            g_pMalloc->Free(m_pColumnSet);
        m_pColumnSet = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * cColumns);
        for (iColumn = 0; iColumn < cColumnOrder; iColumn++)
            m_pColumnSet[rgOrder[iColumn]] = rgColumns[iColumn];
        m_cColumns = cColumnOrder;
    }
    else
    {
        // We still need to keep a copy of the column array ordering for 
        // filling in the virtual ListView later.
        if (m_pColumnSet)
            g_pMalloc->Free(m_pColumnSet);
        m_pColumnSet = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * cColumns);
        CopyMemory(m_pColumnSet, rgColumns, sizeof(COLUMN_SET) * cColumns);
        m_cColumns = iInsertPos;
    }

    // If we _still_ don't have sort information, then we pick the first sortable
    // column.
    if (m_idColumnSort == COLUMN_MAX)
    {
        m_idColumnSort = m_pColumnSet[0].id;
        m_fAscending = TRUE;
    }

    // Make sure the arrow is drawn correctly
    SetSortInfo(m_idColumnSort, m_fAscending);

    return (S_OK);
}


HRESULT CColumns::GetColumnInfo(COLUMN_SET_TYPE* pType, COLUMN_SET** prgColumns, DWORD *pcColumns)
{
    COLUMN_SET  rgColumns[COLUMN_MAX];
    DWORD       cColumns = COLUMN_MAX;
    HRESULT     hr;

    // This one is easy
    if (pType)
        *pType = m_type;

    // Update our list of columns from the ListView
    if (FAILED(hr = _GetListViewColumns(rgColumns, &cColumns)))
    {
        // If we failed, we should return the default information
        cColumns = c_rgColumnSetInfo[m_type].cColumns;
        CopyMemory(rgColumns, c_rgColumnSetInfo[m_type].rgColumns, sizeof(COLUMN_SET) * cColumns);
    }

    if (prgColumns)
    {
        // Need to allocate an array for this
        *prgColumns = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * cColumns);
        CopyMemory(*prgColumns, rgColumns, sizeof(COLUMN_SET) * cColumns);
    }

    if (pcColumns)
        *pcColumns = cColumns;

    return (S_OK);
}


HRESULT CColumns::_GetListViewColumns(COLUMN_SET* rgColumns, DWORD* pcColumns)
{
    DWORD rgOrder[COLUMN_MAX];
    DWORD iColumn;

    *pcColumns = m_cColumns;

    // The columns might have been reordered by the user, so get the order 
    // arrray from the ListView
    if (!Header_GetOrderArray(m_hwndHdr, m_cColumns, rgOrder))
    {
        // If this fails, we're pretty much out of luck.
        return (E_UNEXPECTED);
    }

    // Duplicate the stored column set
    COLUMN_SET rgColumnsTemp[COLUMN_MAX];
    CopyMemory(rgColumnsTemp, m_pColumnSet, sizeof(COLUMN_SET) * m_cColumns);

    // Reorder the array
    for (iColumn = 0; iColumn < m_cColumns; iColumn++)
    {
        rgColumns[iColumn] = rgColumnsTemp[rgOrder[iColumn]];
        rgColumns[iColumn].flags &= ~(COLFLAG_SORT_ASCENDING | COLFLAG_SORT_DESCENDING);
        if (m_idColumnSort == rgColumns[iColumn].id)
            rgColumns[iColumn].flags |= (m_fAscending ? COLFLAG_SORT_ASCENDING : COLFLAG_SORT_DESCENDING);
    }

#ifdef DEBUG
    // Dump the array to make sure it's in the right order
    COLUMN_SET* pColumn;
    for (iColumn = 0, pColumn = rgColumns; iColumn < m_cColumns; iColumn++, pColumn++)
    {
        TCHAR sz[CCHMAX_STRINGRES];
        LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName,
                   sz, ARRAYSIZE(sz));                                           
        TRACE("Column %d: %s", iColumn, sz);
    }
#endif

    // Return 'em
    return (S_OK);
}


HRESULT CColumns::SetColumnInfo(COLUMN_SET* rgColumns, DWORD cColumns)
{
    Assert(rgColumns != NULL);
    Assert(cColumns > 0);

    // Update the ListView
    _SetListViewColumns(rgColumns, cColumns);

    return (S_OK);
}



//
//  FUNCTION:   CColumns::FillSortMenu()
//
//  PURPOSE:    Fills the provided menu with the list of columns in the ListView
//              and checks the item that is already sorted on.
//
//  PARAMETERS: 
//      [in]  hMenu   - Handle of the menu to insert items into
//      [in]  idBase  - Base ID for the command IDs
//      [out] pcItems - Number of items that were inserted by this function 
//
//  RETURN VALUE:
//      S_OK - Everything succeeded
//
HRESULT CColumns::FillSortMenu(HMENU hMenu, DWORD idBase, DWORD *pcItems, DWORD *pidCurrent)
{
    TCHAR sz[CCHMAX_STRINGRES];
    int   ids;
    DWORD iItemChecked = -1;
    BOOL  fAscending = TRUE;
    COLUMN_SET rgColumns[COLUMN_MAX];
    DWORD cColumns;

    // Update our snapshot of the columns in the ListView
    _GetListViewColumns(rgColumns, &cColumns);

    // If there aren't any columns yet, bail
    if (cColumns == 0)
        return (E_UNEXPECTED);

    // Clear any items that were already on the menu
    while ((WORD) -1 != (WORD) GetMenuItemID(hMenu, 0))
        DeleteMenu(hMenu, 0, MF_BYPOSITION);

    // Loop through and insert a menu item for each column 
    COLUMN_SET *pColumn = rgColumns;
    DWORD       iColumn;
    for (iColumn = 0; iColumn < cColumns; iColumn++, pColumn++)
    {
        // Load the string resource for this column
        LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName,
                   sz, ARRAYSIZE(sz));

        // Insert the menu
        InsertMenu(hMenu, iColumn, MF_BYPOSITION | MF_STRING | MF_ENABLED,
                   idBase + iColumn, sz);

        // Check to see if this is the column we're currently sorted on
        if (pColumn->id == m_idColumnSort)
        {
            if (pidCurrent)
                *pidCurrent = idBase + iColumn;

            iItemChecked = iColumn;
            fAscending = m_fAscending;
        }
    }

    // Check the item that is sorted on
    CheckMenuRadioItem(hMenu, 0, iColumn - 1, iItemChecked, MF_BYPOSITION);

    // Check ascending or descending
    CheckMenuRadioItem(hMenu, ID_SORT_ASCENDING, ID_SORT_DESCENDING, 
                       fAscending ? ID_SORT_ASCENDING : ID_SORT_DESCENDING, MF_BYCOMMAND);

    // If the caller cares, return the number of items we've added
    if (pcItems)
        *pcItems = iColumn;

    return (S_OK);
}


HRESULT CColumns::ColumnsDialog(HWND hwndParent)
{
    CColumnsDlg cDialog;
    cDialog.Init(this);
    cDialog.DoModal(hwndParent);
    return (S_OK);
}


DWORD CColumns::GetCount(void)
{
    return (m_cColumns);
}


HRESULT CColumns::GetSortInfo(COLUMN_ID *pidColumn, BOOL *pfAscending)
{
    if (pidColumn)
        *pidColumn = m_idColumnSort;
    if (pfAscending)
        *pfAscending = m_fAscending;

    return (S_OK);
}


HRESULT CColumns::SetSortInfo(COLUMN_ID idColumn, BOOL fAscending)
{
    LV_COLUMN   lvc;
    COLUMN_SET *pColumn;
    DWORD       iColumn;

    // Loop through the column array and verify this column is visible
    for (iColumn = 0, pColumn = m_pColumnSet; iColumn < m_cColumns; iColumn++, pColumn++)
    {
        if (pColumn->id == idColumn)
        {
            // Remove the sort arrow from the previously sorted column
            if (c_rgColumnSetInfo[m_type].fSort && c_rgColumnData[m_idColumnSort].iIcon == 0)
            {
                lvc.mask = LVCF_FMT;
                lvc.fmt = c_rgColumnData[m_idColumnSort].format;
                lvc.fmt &= ~(LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT);
                ListView_SetColumn(m_wndList, GetColumn(m_idColumnSort), &lvc);
            }            

            // Update our cached information
            m_idColumnSort = idColumn;
            m_fAscending = fAscending;

            // Update the ListView with a new sort column unless the sort column
            // already has an image
            if (c_rgColumnSetInfo[m_type].fSort && c_rgColumnData[idColumn].iIcon <= 0)
            {
                lvc.fmt = LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT | c_rgColumnData[idColumn].format;
                lvc.mask = LVCF_IMAGE | LVCF_FMT;
                lvc.iImage = fAscending ? iiconSortAsc : iiconSortDesc;
                ListView_SetColumn(m_wndList, iColumn, &lvc);
            }

            return (S_OK);
        }
    }

    return (E_INVALIDARG);
}


COLUMN_ID CColumns::GetId(DWORD iColumn)
{
    DWORD rgOrder[COLUMN_MAX];

    if (iColumn > m_cColumns)
        return COLUMN_MAX;

    // The columns might have been reordered by the user, so get the order 
    // arrray from the ListView
    if (0 == Header_GetOrderArray(m_hwndHdr, m_cColumns, rgOrder))
        return (COLUMN_MAX);

    return (m_pColumnSet[iColumn].id);
}


DWORD CColumns::GetColumn(COLUMN_ID id)
{
    COLUMN_SET *pColumn;
    DWORD       iColumn;

    for (iColumn = 0, pColumn = m_pColumnSet; iColumn < m_cColumns; iColumn++, pColumn++)
    {
        if (pColumn->id == id)
            return (iColumn);
    }
    return (-1);
}

HRESULT CColumns::SetColumnWidth(DWORD iColumn, DWORD cxWidth)
{
    if (iColumn > m_cColumns)
        return (E_INVALIDARG);

    m_pColumnSet[iColumn].cxWidth = cxWidth;
    return (S_OK);
}


HRESULT CColumns::InsertColumn(COLUMN_ID id, DWORD iInsertBefore)
{
    COLUMN_SET  rgOld[COLUMN_MAX];
    DWORD       cColumns = COLUMN_MAX;

    // Update our list of columns from the ListView
    _GetListViewColumns(rgOld, &cColumns);

    // Allocate an array big enough for all of the possible columns
    COLUMN_SET *rgColumns = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * (cColumns + 1));
    if (!rgColumns)
        return (E_OUTOFMEMORY);

    // Insert the requested flag first
    rgColumns->id = id;
    rgColumns->flags = COLFLAG_VISIBLE;
    rgColumns->cxWidth = -1;

    // Now copy the rest
    CopyMemory(&(rgColumns[1]), rgOld, sizeof(COLUMN_SET) * cColumns);

    // Set the updated column structure into the ListView
    SetColumnInfo(rgColumns, cColumns + 1);
    g_pMalloc->Free(rgColumns);

    return (S_OK);
}


HRESULT CColumns::IsColumnVisible(COLUMN_ID id, BOOL *pfVisible)
{
    if (0 == pfVisible)
        return E_INVALIDARG;

    // Just do a quick run through the column array to see if the requested 
    // column is visible
    COLUMN_SET *pColumn = m_pColumnSet;

    for (DWORD i = 0; i < m_cColumns; i++, pColumn++)
    {
        if (pColumn->id == id)
        {
            *pfVisible = !!(pColumn->flags & COLFLAG_VISIBLE);
            return (S_OK);
        }
    }

    *pfVisible = FALSE;
    return (E_UNEXPECTED);
}


/////////////////////////////////////////////////////////////////////////////
// CColumnsDlg
//

CColumnsDlg::CColumnsDlg() : m_ctlEdit(NULL, this, 1)
{
    /*
	m_dwTitleID = idsColumnDlgTitle;
	m_dwHelpFileID = 0;
	m_dwDocStringID = idsColumnDlgTitle;
    */
    m_type = COLUMN_SET_MAIL;
    m_iItemWidth = -1;
    m_pColumnInfo = 0;
    m_rgColumns = 0;
}

CColumnsDlg::~CColumnsDlg()
{
    SafeRelease(m_pColumnInfo);
    if (m_rgColumns)
        g_pMalloc->Free(m_rgColumns);
}

#undef SubclassWindow
LRESULT CColumnsDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_hwndList = GetDlgItem(IDC_COLUMN_LIST);
    m_ctlEdit.SubclassWindow(GetDlgItem(IDC_WIDTH));

    // Set the extended styles on the ListView
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);

    // Retrieve some information about the column set we're supposed to be 
    // displaying.
    COLUMN_SET* pColumns;
    DWORD       cColumns;
    m_pColumnInfo->GetColumnInfo(&m_type, &pColumns, &cColumns);

    // Allocate an array to hold our column info
    DWORD foo = c_rgColumnSetInfo[m_type].cColumns;

    Assert(m_rgColumns == NULL);
    m_rgColumns = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * c_rgColumnSetInfo[m_type].cColumns);
    CopyMemory(m_rgColumns, pColumns, sizeof(COLUMN_SET) * cColumns);

    g_pMalloc->Free(pColumns);
    m_cColumns = cColumns;

    // Add a single column to the ListView
    RECT rcClient;
    ::GetClientRect(m_hwndList, &rcClient);

    LV_COLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.cx = rcClient.right - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;

    ListView_InsertColumn(m_hwndList, 0, &lvc);

    // Load the state image bitmap
    HIMAGELIST himlState = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st),
                                                16, 0, RGB(255, 0, 255));
    ListView_SetImageList(m_hwndList, himlState, LVSIL_STATE);

    // Fill the ListView
    _FillList(m_rgColumns, m_cColumns);

    // Set the first item to be focused
    ListView_SetItemState(m_hwndList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

    // Everything is clean
    SetDirty(FALSE);

	return 1;  // Let the system set the focus
}

static const HELPMAP g_rgCtxMapColumns[] = {
    {IDC_COLUMN_LIST, 50400},
    {IDC_MOVEUP, 50405},
    {IDC_MOVEDOWN, 50410},
    {IDC_SHOW, 50415},
    {IDC_HIDE, 50420},
    {IDC_WIDTH, 50425},
    {IDC_RESET_COLUMNS, 353507},
    {0, 0}
};

LRESULT CColumnsDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return(OnContextHelp(m_hWnd, uMsg, wParam, lParam, g_rgCtxMapColumns));
}

HRESULT CColumnsDlg::Apply(void)
{
    HRESULT hr = S_OK;

	TRACE(_T("CColumnsDlg::Apply\n"));

    // Build a column set array from the data in the ListView.  Only include 
    // visible columns.
    int cItems = ListView_GetItemCount(m_hwndList);

    // Allocate an array big enough for all of the possible columns
    COLUMN_SET *rgColumns = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * cItems);
    DWORD       cColumns = 0;
    if (!rgColumns)
        return (E_OUTOFMEMORY);

    LV_ITEM lvi;
    
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_SELECTED;
    lvi.iSubItem = 0;

    // Loop through the listview
    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
    {
        // Check to see if this one is visible
        if (_IsChecked(lvi.iItem))
        {
            // If so, then retrieve the cached column info pointer
            ListView_GetItem(m_hwndList, &lvi);

            // And copy the structure into our new array
            rgColumns[cColumns] = *((COLUMN_SET *) lvi.lParam);

            // If this item was selected, then we should grab the column width
            // from the edit box.
            if (lvi.state & LVIS_SELECTED)
                rgColumns[cColumns].cxWidth = GetDlgItemInt(IDC_WIDTH, NULL, FALSE);

            // Make sure the flag sayz visible
            rgColumns[cColumns++].flags |= COLFLAG_VISIBLE;
        }
    }

    // Make sure there's at least one column
    if (!cColumns)
    {
        AthMessageBoxW(m_hWnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrSelectOneColumn),
                      0, MB_ICONEXCLAMATION | MB_OK);
        hr = E_UNEXPECTED;
    }
    else
    {
        // Set the updated column structure into the ListView
        if (SUCCEEDED(m_pColumnInfo->SetColumnInfo(rgColumns, cColumns)))
        {
	        SetDirty(FALSE);
	        hr = S_OK;
        }
        else
            hr = E_UNEXPECTED;
    }

    g_pMalloc->Free(rgColumns);
    return (hr);
}


LRESULT CColumnsDlg::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    DWORD dwPos;
    LV_HITTESTINFO lvhti;

    // Double check this
    Assert(idCtrl == IDC_COLUMN_LIST);

    // Figure out where the cursor was
    dwPos = GetMessagePos();
    lvhti.pt.x = (int)(short) LOWORD(dwPos);
    lvhti.pt.y = (int)(short) HIWORD(dwPos);
    ::ScreenToClient(m_hwndList, &(lvhti.pt));

    // Ask the ListView where this is
    if (-1 == ListView_HitTest(m_hwndList, &lvhti))
        return 0;

    // If this was on a state image area, toggle the check
    if (lvhti.flags == LVHT_ONITEMSTATEICON || pnmh->code == NM_DBLCLK)
    {
        _SetCheck(lvhti.iItem, !_IsChecked(lvhti.iItem));
    }

    return (0);
}


LRESULT CColumnsDlg::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    Assert(idCtrl == IDC_COLUMN_LIST);

    // The only change we're looking for is when a new item is selected.
    NMLISTVIEW* pnmlv = (NMLISTVIEW *) pnmh;
    COLUMN_SET* pColumn = ((COLUMN_SET *) pnmlv->lParam);    
    DWORD cxWidth = pColumn->cxWidth == -1 ? c_rgColumnData[pColumn->id].cxWidth : pColumn->cxWidth;

    // Narrow it down to state changes
    if (pnmlv->uChanged & LVIF_STATE)
    {
        _UpdateButtonState(pnmlv->iItem);

        // If the new state contains selected, and the old state does not, then 
        // we have a new selected item.
        if ((pnmlv->uNewState & LVIS_SELECTED) && (pnmlv->uNewState & LVIS_FOCUSED) 
             && (0 == (pnmlv->uOldState & LVIS_SELECTED)))
        {
            LV_ITEM lvi;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;

            // If there was a previously selected item
            if (m_iItemWidth != -1)
            {
                lvi.iItem = m_iItemWidth;
                ListView_GetItem(m_hwndList, &lvi);

                // Save the width
                ((COLUMN_SET *) lvi.lParam)->cxWidth = GetDlgItemInt(IDC_WIDTH, NULL, FALSE);
            }

            // Set the column width edit box
            SetDlgItemInt(IDC_WIDTH, cxWidth, FALSE);
            m_iItemWidth = pnmlv->iItem;
        }
    }

    return (0);
}


BOOL CColumnsDlg::_IsChecked(DWORD iItem)
{
    DWORD state;

    // Get the state from the selected item
    state = ListView_GetItemState(m_hwndList, iItem, LVIS_STATEIMAGEMASK);

    return (state & INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1));
}


void CColumnsDlg::_SetCheck(DWORD iItem, BOOL fChecked)
{
    ListView_SetItemState(m_hwndList, iItem, 
                          INDEXTOSTATEIMAGEMASK(1 + iiconStateUnchecked + fChecked),
                          LVIS_STATEIMAGEMASK);
    SetDirty(TRUE);
}


void CColumnsDlg::_FillList(const COLUMN_SET *rgColumns, DWORD cColumns)
{
    LV_ITEM           lvi;
    TCHAR             sz[CCHMAX_STRINGRES];
    COLUMN_SET       *pColumn;
    BOOL              fChecked;

    // Set the basic fields in the item struct
    lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.pszText = sz;
    lvi.stateMask = LVIS_STATEIMAGEMASK;

    // Loop through the columns in rgColumns, adding each in order to the 
    // ListView.
    for (lvi.iItem = 0, pColumn = (COLUMN_SET *) rgColumns; lvi.iItem < (int) cColumns; lvi.iItem++, pColumn++)
    {
        // Load the string for the column
        LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName,
                   sz, ARRAYSIZE(sz));

        // Set the checkbox state
        fChecked = !!(pColumn->flags & COLFLAG_VISIBLE);
        lvi.state = INDEXTOSTATEIMAGEMASK(1 + iiconStateUnchecked + fChecked);

        // Save the width in the lParam
        if (pColumn->cxWidth == -1)
            pColumn->cxWidth = c_rgColumnData[pColumn->id].cxWidth;
        lvi.lParam = (LPARAM) pColumn;

        // Insert this item into the list
        ListView_InsertItem(m_hwndList, &lvi);
    }

    // Check to see if the columns we just added were the default columns
    if (lvi.iItem != (int) c_rgColumnSetInfo[m_type].cColumns)
    {
        // Now we need to go through and add the columns that are not currently in 
        // the column set, but could be.    
        DWORD i, j;
        BOOL fInsert;
        for (i = 0, pColumn = (COLUMN_SET *) c_rgColumnSetInfo[m_type].rgColumns; 
             i < c_rgColumnSetInfo[m_type].cColumns; 
             i++, pColumn++)
        {
            fInsert = TRUE;
            for (j = 0; j < cColumns; j++)
            {
                if (pColumn->id == m_rgColumns[j].id)
                {
                    fInsert = FALSE;
                    break;
                }
            }

            // If it wasn't found in m_rgColumns, then insert it
            if (fInsert)
            {
                // Copy the struct
                m_rgColumns[lvi.iItem] = *pColumn;
                m_rgColumns[lvi.iItem].cxWidth = c_rgColumnData[pColumn->id].cxWidth;
                m_rgColumns[lvi.iItem].flags &= ~COLFLAG_VISIBLE;

                // Load the string for the column
                LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName,
                           sz, ARRAYSIZE(sz));

                // Set the checkbox state.  These are _always_ unchecked.
                lvi.state = INDEXTOSTATEIMAGEMASK(1 + iiconStateUnchecked);

                // Save the width in the lParam
                lvi.lParam = (LPARAM) &m_rgColumns[lvi.iItem]; 

                // Insert this item into the list
                ListView_InsertItem(m_hwndList, &lvi);

                // Increment the position
                lvi.iItem++;                
            }
        }
    }

    m_cColumns = ListView_GetItemCount(m_hwndList);
}


LRESULT CColumnsDlg::OnShowHide(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int iItem = -1;

    // Loop through the selected items and make them checked
    while (-1 != (iItem = ListView_GetNextItem(m_hwndList, iItem, LVNI_SELECTED)))
    {
        _SetCheck(iItem, wID == IDC_SHOW);
    }

    return (0);
}


LRESULT CColumnsDlg::OnReset(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Remove all of the columns from the ListView
    ListView_DeleteAllItems(m_hwndList);

    // Fill the array of columns with the default column information
    CopyMemory(m_rgColumns, c_rgColumnSetInfo[m_type].rgColumns, sizeof(COLUMN_SET) * c_rgColumnSetInfo[m_type].cColumns);

    // Reset the list to contain the default column information
    _FillList(m_rgColumns, m_cColumns);

    // Set the first item to be focused
    ListView_SetItemState(m_hwndList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

    SetDirty(TRUE);
    return (0);
}


void CColumnsDlg::_UpdateButtonState(DWORD iItemSel)
{
    HWND hwnd;
    BOOL fChecked = _IsChecked(iItemSel);
    DWORD dwItems = ListView_GetItemCount(m_hwndList);
    DWORD dwSel = ListView_GetSelectedCount(m_hwndList);

    hwnd = GetFocus();

    ::EnableWindow(GetDlgItem(IDC_MOVEUP), (iItemSel != 0) && dwSel);
    ::EnableWindow(GetDlgItem(IDC_MOVEDOWN), (iItemSel != (dwItems - 1)) && dwSel);
    ::EnableWindow(GetDlgItem(IDC_SHOW), (!fChecked && dwSel));
    ::EnableWindow(GetDlgItem(IDC_HIDE), fChecked && dwSel);    

    // don't disable button that has the focus
    if (!::IsWindowEnabled(hwnd))
    {
        hwnd = GetNextDlgTabItem(hwnd, FALSE);
        ::SetFocus(hwnd);
    }
}


LRESULT CColumnsDlg::OnMove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    COLUMN_SET *pColumn = 0;

    // Make sure this is reset
    m_iItemWidth = -1;

    // Figure out which one is selected
    DWORD iItem = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);

    // Get the item from the ListView
    LV_ITEM lvi;
    TCHAR   sz[CCHMAX_STRINGRES];

    lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED | LVIS_STATEIMAGEMASK;
    lvi.pszText = sz;
    lvi.cchTextMax = ARRAYSIZE(sz);
    
    ListView_GetItem(m_hwndList, &lvi);

    // Insert this item to the position one up or down from where it is
    lvi.iItem += (wID == IDC_MOVEUP) ? -1 : 2;
    
    // Update the column width
    pColumn = (COLUMN_SET *) lvi.lParam;
    pColumn->cxWidth = GetDlgItemInt(IDC_WIDTH, NULL, FALSE);    

    ListView_InsertItem(m_hwndList, &lvi);

    // Force a redraw of the new item and make sure it's visible
    ListView_EnsureVisible(m_hwndList, lvi.iItem, FALSE);
    ListView_RedrawItems(m_hwndList, lvi.iItem, lvi.iItem);

    // Delete the old item
    m_iItemWidth = -1;
    ListView_DeleteItem(m_hwndList, iItem + (wID == IDC_MOVEUP));

    SetDirty(TRUE);
    return (0);
}


LRESULT CColumnsDlg::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    if (SUCCEEDED(Apply()))
        SetWindowLong(DWLP_MSGRESULT, PSNRET_NOERROR);
    else
        SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\columns.h ===
#ifndef __COLUMNS_H_
#define __COLUMNS_H_

#include "ourguid.h"
#include "resource.h"

// 
// This defines all the available columns in Athena.  It maps the column ID,
// the name of the column, the default width, and the format (alignment).
//

#define IICON_TEXTHDR       -1

typedef struct tagCOLUMN_DATA {
    UINT        idsColumnName;      // Name of the column
    UINT        cxWidth;            // Default width for this column
    UINT        format;             // Format for the column (LVCFMT enum)
    int         iIcon;              // Icon for the column header
} COLUMN_DATA, *PCOLUMN_DATA;

// 
// This structure is used to define the column set for a particular 
// folder type.  
//

#define COLFLAG_VISIBLE         0x00000001  // This column is on by default
#define COLFLAG_SORT_ASCENDING  0x00000002  // This column is the sort column, and it's sorted ascending
#define COLFLAG_SORT_DESCENDING 0x00000004  // This column is the sort column, and it's sorted descending
#define COLFLAG_FIXED_WIDTH     0x00000008  // This column is a fixed width, it won't resize dynamically


typedef struct tagCOLUMN_SET {
    COLUMN_ID           id;         // Id of the column
    DWORD               flags;      // Combination of the COLUMN_ flags above
    DWORD               cxWidth;    // Width of the column.  If -1, then use the default.  
} COLUMN_SET, *PCOLUMN_SET;

// 
// This enumeration lists all the different column sets we currently have
// defined.
//
typedef enum tagCOLUMN_SET_TYPE
{
    COLUMN_SET_MAIL = 0,
    COLUMN_SET_OUTBOX,
    COLUMN_SET_NEWS,
    COLUMN_SET_IMAP,
    COLUMN_SET_IMAP_OUTBOX,
    COLUMN_SET_FIND,
    COLUMN_SET_NEWS_ACCOUNT,
    COLUMN_SET_IMAP_ACCOUNT,
    COLUMN_SET_LOCAL_STORE,
    COLUMN_SET_NEWS_SUB,
    COLUMN_SET_IMAP_SUB,
    COLUMN_SET_OFFLINE,
    COLUMN_SET_PICKGRP,
    COLUMN_SET_HTTPMAIL,
    COLUMN_SET_HTTPMAIL_ACCOUNT,
    COLUMN_SET_HTTPMAIL_OUTBOX,
    COLUMN_SET_MAX
} COLUMN_SET_TYPE;

//
// This struct maps the different column set types to the default column set
// and the place where this information is persisted.
//
typedef struct tagCOLUMN_SET_INFO {
    COLUMN_SET_TYPE     type;
    DWORD               cColumns;
    const COLUMN_SET   *rgColumns;
    LPCTSTR             pszRegValue;
    BOOL                fSort;
} COLUMN_SET_INFO;

//
// This structure defines what is saved when we persist the columns
//

#define COLUMN_PERSIST_VERSION 0x00000010

typedef struct tagCOLUMN_PERSIST_INFO {
    DWORD       dwVersion;              // Version stamp for this structure
    DWORD       cColumns;               // Number of entries in rgColumns
    COLUMN_SET  rgColumns[1];           // Actual array of visible columns
} COLUMN_PERSIST_INFO, *PCOLUMN_PERSIST_INFO;


/////////////////////////////////////////////////////////////////////////////
// Defines for the control ID's in the dialog
//

#define IDC_COLUMN_LIST                 20000
#define IDC_MOVEUP                      20001
#define IDC_MOVEDOWN                    20002
#define IDC_SHOW                        20003
#define IDC_HIDE                        20004
#define IDC_RESET_COLUMNS               20005
#define IDC_WIDTH                       20006

/////////////////////////////////////////////////////////////////////////////
// IColumnsInfo
//

typedef enum 
{
    COLUMN_LOAD_DEFAULT = 0,
    COLUMN_LOAD_BUFFER,
    COLUMN_LOAD_REGISTRY,
    COLUMN_LOAD_MAX
} COLUMN_LOAD_TYPE;

interface IColumnInfo : public IUnknown 
{
    // Initializes the object and tells it which ListView it will be using
    // and which column set should be applied.
    STDMETHOD(Initialize)(/*[in]*/ HWND hwndList, 
                          /*[in]*/ COLUMN_SET_TYPE type) PURE;

    // Tells the class to configure the columns in the ListView.  The user
    // can either tell the class to use the default columns or use a set
    // that was persisted by the caller.
    STDMETHOD(ApplyColumns)(/*[in]*/ COLUMN_LOAD_TYPE type,
                            /*[in, optional]*/ LPBYTE pBuffer,
                            /*[in]*/ DWORD cb) PURE;

    // Saves the current column configuration into the buffer provided by the
    // caller.  pcb should have the size of pBuffer when the function is called,
    // and will be updated to contain the number of bytes written into the 
    // buffer if the function succeeds.
    // if both params are null, it saves to registry
    STDMETHOD(Save)(/*[in, out]*/ LPBYTE pBuffer,
                    /*[in, out]*/ DWORD *pcb) PURE;

    // Returns the total number of columns in the ListView.
    STDMETHOD_(DWORD, GetCount)(void) PURE;

    // Returns the column ID for the specified column index.
    STDMETHOD_(COLUMN_ID, GetId)(/*[in]*/ DWORD iColumn) PURE;

    // Returns the index for the specified column ID.
    STDMETHOD_(DWORD, GetColumn)(/*[in]*/ COLUMN_ID id) PURE;

    // Set's the width of the specified column index.
    STDMETHOD(SetColumnWidth)(/*[in]*/ DWORD iColumn, 
                              /*[in]*/ DWORD cxWidth) PURE;

    // Allows the caller to ask for the column that we're sorted by and/or
    // the direction of the sort.  If the caller doesn't care about one of
    // those pieces of information, they can pass in NULL for that 
    // parameter.
    STDMETHOD(GetSortInfo)(/*[out, optional]*/ COLUMN_ID *pidColumn, 
                           /*[out, optional]*/ BOOL *pfAscending) PURE;

    // Allows the caller to update the column and direction of the current
    // sort.
    STDMETHOD(SetSortInfo)(/*[in]*/ COLUMN_ID idColumn,
                           /*[in]*/ BOOL fAscending) PURE;

    STDMETHOD(GetColumnInfo)(COLUMN_SET_TYPE* pType, COLUMN_SET** prgColumns, DWORD *pcColumns) PURE;
    STDMETHOD(SetColumnInfo)(COLUMN_SET* rgColumns, DWORD cColumns) PURE;

    // Displays a dialog that allows users to configure the columns.
    STDMETHOD(ColumnsDialog)(/*[in]*/ HWND hwndParent) PURE;

    // Fills the provided menu with the columns visible and the sort info.
    STDMETHOD(FillSortMenu)(/*[in]*/  HMENU  hMenu,
                            /*[in]*/  DWORD  idBase,
                            /*[out]*/ DWORD *pcItems,
                            /*[out]*/ DWORD *pidCurrent) PURE;

    // Inserts a column into the current column array
    STDMETHOD(InsertColumn)(/*[in]*/ COLUMN_ID id,
                            /*[in]*/ DWORD     iInsertBefore) PURE;

    // Checks to see if the specified column is visible
    STDMETHOD(IsColumnVisible)(/*[in]*/ COLUMN_ID id,
                               /*[out]*/ BOOL *pfVisible) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// CColumns
//
class CColumns : public IColumnInfo
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction, Initialization, and Destruction
    //
    CColumns();
    ~CColumns();

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHOD_(ULONG, AddRef)(void)
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHOD_(ULONG, Release)(void)
    {
        InterlockedDecrement(&m_cRef);
        if (0 == m_cRef)
        {
            delete this;
            return (0);
        }
        return (m_cRef);
    }

    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj)
    {
        *ppvObj = NULL;
        if (IsEqualIID(riid, IID_IUnknown))
            *ppvObj = (LPVOID) (IUnknown *) this;
        if (IsEqualIID(riid, IID_IColumnInfo))
            *ppvObj = (LPVOID) this;

        if (*ppvObj)
        {
            AddRef();
            return (S_OK);
        }

        return (E_NOINTERFACE);
    }        
    
    /////////////////////////////////////////////////////////////////////////
    // IColumnInfo
    //
    STDMETHODIMP Initialize(HWND hwndList, COLUMN_SET_TYPE type);
    STDMETHODIMP ApplyColumns(COLUMN_LOAD_TYPE type, LPBYTE pBuffer, DWORD cb);
    STDMETHODIMP Save(LPBYTE pBuffer, DWORD *pcb);
    DWORD STDMETHODCALLTYPE GetCount(void);
    COLUMN_ID STDMETHODCALLTYPE GetId(DWORD iColumn);
    DWORD STDMETHODCALLTYPE GetColumn(COLUMN_ID id);
    STDMETHODIMP SetColumnWidth(DWORD iColumn, DWORD cxWidth);
    STDMETHODIMP GetSortInfo(COLUMN_ID *pidColumn, BOOL *pfAscending);
    STDMETHODIMP SetSortInfo(COLUMN_ID idColumn, BOOL fAscending);
    STDMETHODIMP GetColumnInfo(COLUMN_SET_TYPE* pType, COLUMN_SET** prgColumns, DWORD *pcColumns);
    STDMETHODIMP SetColumnInfo(COLUMN_SET* rgColumns, DWORD cColumns);
    STDMETHODIMP ColumnsDialog(HWND hwndParent);
    STDMETHODIMP FillSortMenu(HMENU hMenu, DWORD idBase, DWORD *pcItems, DWORD *pidCurrent);
    STDMETHODIMP InsertColumn(COLUMN_ID id, DWORD iInsertBefore);
    STDMETHODIMP IsColumnVisible(COLUMN_ID id, BOOL *pfVisible);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions
    //
protected:
    HRESULT _GetListViewColumns(COLUMN_SET* rgColumns, DWORD *pcColumns);
    HRESULT _SetListViewColumns(const COLUMN_SET *rgColumns, DWORD cColumns);

private:
    /////////////////////////////////////////////////////////////////////////
    // Class data
    //
    LONG                    m_cRef;
    BOOL                    m_fInitialized;
    CWindow                 m_wndList;
    HWND                    m_hwndHdr;
    COLUMN_SET_TYPE         m_type;
    COLUMN_SET             *m_pColumnSet;
    DWORD                   m_cColumns;
    COLUMN_ID               m_idColumnSort;
    BOOL                    m_fAscending;
    };


/////////////////////////////////////////////////////////////////////////////
// CColumnsDlg
//
class CColumnsDlg : public CDialogImpl<CColumnsDlg>
{
public:

	enum {IDD = iddColumns};

BEGIN_MSG_MAP(CColumnsDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnHelp)

    COMMAND_ID_HANDLER(IDC_SHOW, OnShowHide)
    COMMAND_ID_HANDLER(IDC_HIDE, OnShowHide)
    COMMAND_ID_HANDLER(IDC_RESET_COLUMNS, OnReset)
    COMMAND_ID_HANDLER(IDC_MOVEUP, OnMove)
    COMMAND_ID_HANDLER(IDC_MOVEDOWN, OnMove)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)

    NOTIFY_HANDLER(IDC_COLUMN_LIST, NM_CLICK, OnClick)
    NOTIFY_HANDLER(IDC_COLUMN_LIST, NM_DBLCLK, OnClick)
    NOTIFY_HANDLER(IDC_COLUMN_LIST, LVN_ITEMCHANGED, OnItemChanged)

ALT_MSG_MAP(1)
    // Here's our edit control subclass
    MESSAGE_HANDLER(WM_CHAR, OnChar)

END_MSG_MAP()

    /////////////////////////////////////////////////////////////////////////
    // Construction, Initialization, and Destruction
    //
    CColumnsDlg();
    ~CColumnsDlg();
    HRESULT Init(IColumnInfo *pColumnInfo)
    {
        m_pColumnInfo = pColumnInfo;
        m_pColumnInfo->AddRef();
        return (S_OK);
    }

    /////////////////////////////////////////////////////////////////////////
    // Overrides of the standard interface implementations
    //
	STDMETHOD(Apply)(void);

    /////////////////////////////////////////////////////////////////////////
    // Message Handlers
    // 
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnChar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        SetDirty(TRUE);
        bHandled = FALSE;
        return (0);
    }

    LRESULT OnShowHide(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnReset(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnMove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (SUCCEEDED(Apply()))
            EndDialog(0);

        return (0);
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(0);

        return (0);
    }

    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    void _FillList(const COLUMN_SET *rgColumns, DWORD cColumns);
    BOOL _IsChecked(DWORD iItem);
    void _SetCheck(DWORD iItem, BOOL fChecked);
    void _UpdateButtonState(DWORD iItemSel);

    void SetDirty(BOOL fDirty)
    {
        ::SendMessage(GetParent(), fDirty ? PSM_CHANGED : PSM_UNCHANGED, 
                      (WPARAM) m_hWnd, 0);
    }

private:
    CContainedWindow    m_ctlEdit;
    COLUMN_SET_TYPE     m_type;
    COLUMN_SET         *m_rgColumns;
    DWORD               m_cColumns;
    HWND                m_hwndList;
    UINT                m_iItemWidth;
    IColumnInfo        *m_pColumnInfo;
};








#endif //__COLUMNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\conman.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     conman.cpp
//
//  PURPOSE:    Defines the CConnectionManager object for Athena.
//

#include "pch.hxx"
#include "conman.h"
#include "error.h"
#include "strconst.h"
#include "rasdlgsp.h"
#include "resource.h"
#include "xpcomm.h"
#include "goptions.h"
#include "thormsgs.h"
#include "wininet.h"
#include "shlwapip.h" 
#include "demand.h"
#include "dllmain.h"
#include "browser.h"
#include <urlmon.h>
#include "menures.h"
#include "workoff.h" 
#include <sync.h>

ASSERTDATA

#define DEF_HANGUP_WAIT            10 // Seconds

static const TCHAR s_szRasDlgDll[] = "RASDLG.DLL";
#ifdef UNICODE
static const TCHAR s_szRasDialDlg[] = "RasDialDlgW";
static const TCHAR s_szRasEntryDlg[] = "RasEntryDlgW";
#else
static const TCHAR s_szRasDialDlg[] = "RasDialDlgA";
static const TCHAR s_szRasEntryDlg[] = "RasEntryDlgA";
#endif

BOOL FIsPlatformWinNT();

//
//  FUNCTION:   CConnectionManager::CConnectionManager()
//
//  PURPOSE:    Constructor
//
CConnectionManager::CConnectionManager()
    {
    m_cRef = 1;
    
    // Synchronization Objects
    InitializeCriticalSection(&m_cs);
    m_hMutexDial = INVALID_HANDLE_VALUE;
    
    m_pAcctMan = 0;
    
    m_fSavePassword = 0;
    m_fRASLoadFailed = 0;
    m_fOffline = 0;

    m_dwConnId = 0;
    ZeroMemory(&m_rConnInfo, sizeof(CONNINFO));
    m_rConnInfo.state = CIS_REFRESH;

    *m_szConnectName = 0;
    ZeroMemory(&m_rdp, sizeof(RASDIALPARAMS));
    
    m_hInstRas = NULL;
    m_hInstRasDlg = NULL;

    m_pNotifyList = NULL;
    m_pConnListHead = NULL;

    m_hInstSensDll = NULL;
    m_fMobilityPackFailed = FALSE;
    m_pIsDestinationReachable = NULL;
    m_pIsNetworkAlive   = NULL;
    
    m_fTryAgain = FALSE;
    m_fDialerUI = FALSE;
    }

//
//  FUNCTION:   CConnectionManager::~CConnectionManager()
//
//  PURPOSE:    Destructor
//
CConnectionManager::~CConnectionManager()
    {
    SafeRelease(m_pAcctMan);

    FreeNotifyList();

    EnterCriticalSection(&m_cs);

    if (m_hInstRas)
        FreeLibrary(m_hInstRas);

    if (m_hInstRasDlg)
        FreeLibrary(m_hInstRasDlg);

    if (m_hInstSensDll)
        FreeLibrary(m_hInstSensDll);

    CloseHandle(m_hMutexDial);


    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);

    EmptyConnList();

    }
    

//
//  FUNCTION:   CConnectionManager::HrInit()
//
//  PURPOSE:    Initalizes the connection manager by attempting to load RAS
//              and storing a pointer to the Account Manager object that is 
//              passed in.
//
//  PARAMETERS:
//      <in> pAcctMan - Pointer to the account manager object that we will 
//                      use to retrieve account information and register for
//                      account changes.
//
//  RETURN VALUE:
//      S_OK                Everything is hunky-dorie
//      HR_E_ALREADYEXISTS  We already exist, can't do it twice.
//      HR_S_RASNOTLOADED   The system doesn't have RAS installed.
//
HRESULT CConnectionManager::HrInit(IImnAccountManager *pAcctMan)
    {
    HRESULT hr = S_OK;

    // Make a copy of the account manager pointer
    if (NULL == pAcctMan)
        {
        AssertSz(pAcctMan, _T("CConnectionManager::HrInit() - Requires an IAccountManager pointer."));
        return (E_INVALIDARG);
        }

    m_pAcctMan = pAcctMan;
    m_pAcctMan->AddRef();
    
    // Register a window class for our advise handling
    WNDCLASS wc;
    wc.style = 0;
    wc.lpfnWndProc = NotifyWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hIcon = 0;
    wc.hCursor = 0;
    wc.hbrBackground = 0;
    wc.lpszMenuName = 0;
    wc.lpszClassName = NOTIFY_HWND;

    RegisterClass(&wc);

    m_hMutexDial = CreateMutex(NULL, FALSE, NULL);
    if (NULL == m_hMutexDial)
        return (E_FAIL);

    return (S_OK);
    }
    

HRESULT STDMETHODCALLTYPE CConnectionManager::QueryInterface(REFIID riid, LPVOID *ppvObject)
    {
    if (!ppvObject)
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = (LPVOID) (IUnknown*) this;
    else if (IsEqualIID(riid, IID_IImnAdviseAccount))
        *ppvObject = (LPVOID) (IImnAdviseAccount*) this;
    else
        *ppvObject = NULL;

    if (*ppvObject)
        {
        AddRef();
        return (S_OK);
        }
    else
        return (E_NOINTERFACE); 
    }

ULONG STDMETHODCALLTYPE CConnectionManager::AddRef(void)
    {
    return (++m_cRef);
    }


ULONG STDMETHODCALLTYPE CConnectionManager::Release(void)
    {
    ULONG cRef = --m_cRef;
    
    if (m_cRef == 0)
        {
        delete this;
        return (0);
        }

    return (cRef);
    }

HRESULT STDMETHODCALLTYPE CConnectionManager::AdviseAccount(DWORD dwAdviseType, 
                                                            ACTX *pactx)
{
    IImnAccount *pAccount;
    DWORD       dwConnection;

    // SendAdvise(CONNNOTIFY_RASACCOUNTSCHANGED, 0);
    switch (dwAdviseType)
    {
        case AN_ACCOUNT_DELETED:
        {   
            if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_ID, pactx->pszAccountID, &pAccount)))
            {
                if (SUCCEEDED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
                {
                    if (dwConnection == CONNECTION_TYPE_RAS)
                    {
                        TCHAR szConnection[CCHMAX_CONNECTOID];
                        *szConnection = '\0';
                        if (SUCCEEDED(pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnection, 
                                                            ARRAYSIZE(szConnection))) && *szConnection)
                        {
                            RemoveFromConnList(szConnection);
                        }
                    }
                }
            }
            break;
        }
    }

    return (S_OK);
}


void CConnectionManager::EmptyConnList()
{
    ConnListNode    *pCur;

    //Delete all the nodes
    while (m_pConnListHead != NULL)
    {
        pCur = m_pConnListHead;
        m_pConnListHead = m_pConnListHead->pNext;
        delete pCur;
    }
    m_pConnListHead = NULL;
}

void CConnectionManager::RemoveFromConnList(LPTSTR  pszRasConn)
{    
    ConnListNode    *prev = NULL,
                    *Cur  = m_pConnListHead;
    LPTSTR          pRasConn;


    while (Cur != NULL)
    {
        if (0 == lstrcmpi(pszRasConn, Cur->pszRasConn))
        {
            if (prev == NULL)
            {
                m_pConnListHead = Cur->pNext;
            }
            else
            {
                prev->pNext = Cur->pNext;
            }
            delete Cur;
        }
        else
        {
            prev = Cur;
            Cur  = Cur->pNext;
        }
    }
    
}

HRESULT CConnectionManager::AddToConnList(LPTSTR  pszRasConn)
{
    //We don't have to make sure that this is not already in the list because once 
    //it is in the list, that means its already connected and so we don't land up in this 
    //situation after that
    ConnListNode    *pnext;
    HRESULT         hres;
    IImnAccount     *pAccount;

    pnext = m_pConnListHead;
    m_pConnListHead = new ConnListNode;
    if (m_pConnListHead != NULL)
    {
        m_pConnListHead->pNext = pnext;
        StrCpyN(m_pConnListHead->pszRasConn, pszRasConn, ARRAYSIZE(m_pConnListHead->pszRasConn));
        hres = S_OK;
    }
    else
        hres = E_FAIL;

    return hres;
}

HRESULT CConnectionManager::SearchConnList(LPTSTR  pszRasConn)
{
    ConnListNode    *pCur = m_pConnListHead;
    
    while (pCur != NULL)
    {
        if (0 == lstrcmpi(pszRasConn, pCur->pszRasConn))
            return S_OK;
        pCur = pCur->pNext;
    }
    return E_FAIL;
}

//
//  FUNCTION:   CConnectionManager::CanConnect()
//
//  PURPOSE:    Determines if the caller can connect to the given account
//              using the existing connection.
//
//  PARAMETERS:
//      <in> pAccount - Pointer to the account object the caller wants to 
//                      connect to.
//
//  RETURN VALUE:
//      S_OK    - The caller can connect using the existing connection
//      S_FALSE - There is no existing connection, so there is no reason the
//                caller can't connect.
//      E_FAIL  - The existing connection is different from the account's 
//                connection.  The user must hang up and dial again to connect
//
HRESULT CConnectionManager::CanConnect(IImnAccount *pAccount)
    {
    HRESULT hr;
    DWORD   dwConnection;
    IImnAccount *pDefault = 0;
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
    BOOL        fFound = 0;

    // Check to see if we're working offline
    if (IsGlobalOffline())
        return (HR_E_OFFLINE);
    
    // If the connection the user is looking for is not RAS, then we just 
    // return success.
    if (FAILED(hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
    {
        // If we didn't get the connection information, then we look for the
        // connection from the default server of this type
        if (FAILED(hr = GetDefaultConnection(pAccount, &pDefault)))
        {
            // Bug #36071 - If we haven't set up any accounts of this type yet,
            //              we'd fail.  As a result, if you fire a URL to a server
            //              we'd never try to connect and download.  I'm going
            //              to change this to succeed and we'll see what type
            //              of bugs that creates.
            return (S_OK);
        }
        
        // We're going to use the default from now on
        pAccount = pDefault;
        if (FAILED(hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
        {
            // Bug #36071 - If we haven't set up any accounts of this type yet,
            //              we'd fail.  As a result, if you fire a URL to a server
            //              we'd never try to connect and download.  I'm going
            //              to change this to succeed and we'll see what type
            //              of bugs that creates.
            return (S_OK);
        }
    }

    hr = OEIsDestinationReachable(pAccount, dwConnection);

    //I don't think we should be doing this here. Review again
    /*
    if ((hr == S_OK) && (dwConnection == CONNECTION_TYPE_RAS || dwConnection == CONNECTION_TYPE_INETSETTINGS))
    {
        m_rConnInfo.fConnected = TRUE;
    }
    */

//exit:
    SafeRelease(pDefault);
    return (hr);    
    }    


//
//  FUNCTION:   CConnectionManager::CanConnect()
//
//  PURPOSE:    Determines if the caller can connect to the given account
//              using the existing connection.
//
//  PARAMETERS:
//      <in> pszAccount - Pointer to the name of the account the caller wants 
//                        to connect to.
//
//  RETURN VALUE:
//      S_OK    - The caller can connect using the existing connection
//      S_FALSE - There is no existing connection, so there is no reason the
//                caller can't connect.
//      E_FAIL  - The existing connection is different from the account's 
//                connection.  The user must hang up and dial again to connect
//      E_INVALIDARG - The account doesn't exist
//
HRESULT CConnectionManager::CanConnect(LPTSTR pszAccount)
{
    IImnAccount *pAccount = NULL;
    HRESULT      hr;
    
    // Check to see if we're working offline
    if (IsGlobalOffline())
        return (HR_E_OFFLINE);

    // Look up the account name in the account manager to get the account 
    // object.
    Assert(m_pAcctMan);

    if (lstrcmpi(pszAccount, STR_LOCALSTORE) == 0)
        return(S_OK);
    
    if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccount, &pAccount)))
        {
        // Call through to the polymorphic version of us
        hr = CanConnect(pAccount);
        pAccount->Release();
        }
    else
        {
        // Bug #36071 - If we haven't set up any accounts of this type yet,
        //              we'd fail.  As a result, if you fire a URL to a server
        //              we'd never try to connect and download.  I'm going
        //              to change this to succeed and we'll see what type
        //              of bugs that creates.
        hr = S_OK;
        }
    
    return (hr);    
}


BOOL CConnectionManager::IsAccountDisabled(LPTSTR pszAccount)
{
    IImnAccount *pAccount = NULL;
	DWORD dw;
    // Look up the account name in the account manager to get the account 
    // object.
    Assert(m_pAcctMan);

    if (lstrcmpi(pszAccount, STR_LOCALSTORE) == 0)
        return(FALSE);
    
    if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccount, &pAccount)))
	{
		if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
		{
			if(HideHotmail())
				return(TRUE);
		}
		return(FALSE);
	}
	return(TRUE);
}


//
//  FUNCTION:   CConnectionManager::Connect()
//
//  PURPOSE:    Attempts to establish a connection for the account specified.
//
//  PARAMETERS:
//      <in> pAccount - Pointer to the account object to connect to.
//      <in> hwnd     - Handle of the window to show UI over.  Only needed if 
//                      fShowUI is TRUE.
//      <in> fShowUI  - TRUE if the functions are allowed to display UI.
//
//  RETURN VALUE:
//      S_OK         - We're connected
//      E_UNEXPECTED - There wasn't enough information in pAccount to figure
//                     figure out which connection to use.
//
HRESULT CConnectionManager::Connect(IImnAccount *pAccount, HWND hwnd, BOOL fShowUI)
{
    HRESULT     hr = S_OK;
    DWORD       dwConnection;
    IImnAccount *pDefault = 0;

    if (!m_fDialerUI)
    {
        m_fDialerUI = TRUE;
        // Check to see if we're working offline
        if (IsGlobalOffline())
        {
            if (fShowUI)
            {
                if (IDNO == AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                          0, MB_YESNO | MB_ICONEXCLAMATION ))
                {
                    m_fDialerUI = FALSE;
                    return (HR_E_OFFLINE);
                }
                else
                    g_pConMan->SetGlobalOffline(FALSE);
            }
            else
            {
                m_fDialerUI = FALSE;
                return (HR_E_OFFLINE);
            }
        }
        m_fDialerUI = FALSE;
    }

    if (CanConnect(pAccount) == S_OK)
    {
        return S_OK;
    }

    // If the connection the user is looking for is not RAS, then we just 
    // return success.
    if (FAILED(hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
    {
        // If we didn't get the connection information, then we look for the
        // connection from the default server of this type
        if (FAILED(hr = GetDefaultConnection(pAccount, &pDefault)))
        {
            // Bug #36071 - If we haven't set up any accounts of this type yet,
            //              we'd fail.  As a result, if you fire a URL to a server
            //              we'd never try to connect and download.  I'm going
            //              to change this to succeed and we'll see what type
            //              of bugs that creates.
            return (S_OK);
        }
        
        // We're going to use the default from now on
        pAccount = pDefault;
        if (FAILED(hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
        {
            // Bug #36071 - If we haven't set up any accounts of this type yet,
            //              we'd fail.  As a result, if you fire a URL to a server
            //              we'd never try to connect and download.  I'm going
            //              to change this to succeed and we'll see what type
            //              of bugs that creates.
            hr = S_OK;
            goto exit;
        }
    }


    if (dwConnection == CONNECTION_TYPE_INETSETTINGS)
    {
        hr = ConnectUsingIESettings(hwnd, fShowUI);
        goto exit;
    }

    if (dwConnection == CONNECTION_TYPE_LAN)
    {
        //CanConnect already told us that Lan is not present
        hr = E_FAIL;
        goto exit;
    }

    if (dwConnection != CONNECTION_TYPE_RAS)
    {
        hr = S_OK;
        goto exit;
    }

    // Get the name of the connection while we're at it.
    TCHAR szConnection[CCHMAX_CONNECTOID];
    if (FAILED(hr = pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnection, 
                                        ARRAYSIZE(szConnection))))
    {
        AssertSz(FALSE, _T("CConnectionManager::Connect() - No connection name."));
        hr = E_UNEXPECTED;
        goto exit;
    }

    hr = ConnectActual(szConnection, hwnd, fShowUI);

exit:
    SafeRelease(pDefault);

    return (hr);
}    


//
//  FUNCTION:   CConnectionManager::Connect()
//
//  PURPOSE:    Attempts to establish a connection for the account specified.
//
//  PARAMETERS:
//      <in> pszAccount - Name of the account to connect to.
//      <in> hwnd     - Handle of the window to show UI over.  Only needed if 
//                      fShowUI is TRUE.
//      <in> fShowUI  - TRUE if the functions are allowed to display UI.
//
//  RETURN VALUE:
//      <???>
//
HRESULT CConnectionManager::Connect(LPTSTR pszAccount, HWND hwnd, BOOL fShowUI)
{
    IImnAccount *pAccount = NULL;
    HRESULT      hr;
    
    // Check to see if we're working offline

    if (!m_fDialerUI)
    {
        m_fDialerUI = TRUE;
        // Check to see if we're working offline
        if (IsGlobalOffline())
        {
            if (fShowUI)
            {
                if (IDNO == AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                          0, MB_YESNO | MB_ICONEXCLAMATION ))
                {
                    m_fDialerUI = FALSE;
                    return (HR_E_OFFLINE);
                }
                else
                    g_pConMan->SetGlobalOffline(FALSE);
            }
            else
            {
                m_fDialerUI = FALSE;
                return (HR_E_OFFLINE);
            }
        }

        m_fDialerUI = FALSE;
    }


    // Look up the account name in the account manager to get the account 
    // object.
    Assert(m_pAcctMan);
    
//    if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pszAccount, &pAccount)))
    if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccount, &pAccount)))
    {
        // Call through to the polymorphic version of us
        hr = Connect(pAccount, hwnd, fShowUI);
        pAccount->Release();
    }
    else
    {
        // Bug #36071 - If we haven't set up any accounts of this type yet,
        //              we'd fail.  As a result, if you fire a URL to a server
        //              we'd never try to connect and download.  I'm going
        //              to change this to succeed and we'll see what type
        //              of bugs that creates.
        hr = S_OK;
    }
    
    return (hr);    
}    


//
//  FUNCTION:   CConnectionManager::Connect()
//
//  PURPOSE:    Attempts to establish a connection for the account specified.
//
//  PARAMETERS:
//      <in> hMenu - Handle of the menu that was used to select the account
//                   to connect to.
//      <in> cmd   - Cmd ID from the menu that says which account to use.
//      <in> hwnd  - Handle to display UI over.
//
//  RETURN VALUE:
//      <???>
//
HRESULT CConnectionManager::Connect(HMENU hMenu, DWORD cmd, HWND hwnd)
{
    MENUITEMINFO mii;

    Assert(hMenu && cmd);
    Assert(cmd >= (DWORD) ID_CONNECT_FIRST && cmd < ((DWORD) ID_CONNECT_FIRST + GetMenuItemCount(hMenu)));

    // Get the account pointer from the menu item
    mii.cbSize     = sizeof(MENUITEMINFO);
    mii.fMask      = MIIM_DATA;
    mii.dwItemData = 0;

    if (GetMenuItemInfo(hMenu, cmd, FALSE, &mii))
    {
        Assert(mii.dwItemData);
        if (mii.dwItemData)
        {
            return (Connect((IImnAccount *) mii.dwItemData, hwnd, TRUE));
        }
    }

    return (E_UNEXPECTED);
}


HRESULT CConnectionManager::ConnectDefault(HWND hwnd, BOOL fShowUI)
{
    IImnEnumAccounts   *pEnum = NULL;
    IImnAccount        *pAcct = NULL;
    DWORD               dwConn = 0;
    TCHAR               szAcct[CCHMAX_ACCOUNT_NAME];
    TCHAR               szConn[CCHMAX_CONNECTOID];
    HRESULT             hr = E_UNEXPECTED;

    // Get the enumerator from the account manager
    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
    {
        pEnum->Reset();

        // Walk through all the accounts
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            // Get the connection type for this account
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
            {
                // If the account is a RAS account, ask for the connectoid name
                // and the account name.
                if (dwConn == CONNECTION_TYPE_RAS || dwConn == CONNECTION_TYPE_INETSETTINGS)
                {
                    break;
                }
            }
            SafeRelease(pAcct);
        }
        SafeRelease(pEnum);
    }

    if (pAcct)
    {
        hr = Connect(pAcct, hwnd, fShowUI);
        SafeRelease(pAcct);
    }

    return (hr);
}

//
//  FUNCTION:   CConnectionManager::Disconnect()
//
//  PURPOSE:    Brings down the current RAS connection.
//
//  PARAMETERS:
//      <in> hwnd      - Handle of the window to display UI over.
//      <in> fShowUI   - Allows to caller to determine if UI will be displayed 
//                       while disconnecting.
//      <in> fForce    - Forces the connection down even if we didn't create it.
//      <in> fShutdown - TRUE if we're dropping because we're shutting down.
//
//  RETURN VALUE:
//      S_OK - Everything worked.
//      E_FAIL - We didn't create it
//
HRESULT CConnectionManager::Disconnect(HWND hwnd, BOOL fShowUI, BOOL fForce,
                                       BOOL fShutdown)
{
    HRESULT hr;
    TCHAR szRes[CCHMAX_STRINGRES];
    TCHAR szBuf[CCHMAX_STRINGRES];
    int   idAnswer = IDYES;

    // RefreshConnInfo
    hr = RefreshConnInfo(FALSE);
    if (FAILED(hr))
        return hr;
    
    // See if we even have a RAS connection active
    if (!m_rConnInfo.hRasConn)
        return (S_OK);
    
    /*
    if (!(*m_rConnInfo.szCurrentConnectionName))
        return S_OK;
    */

    // The autodialer has it's own shutdown prompt.  
    if (fShutdown && m_rConnInfo.fAutoDial)
        return (S_OK);

    if (fShutdown && !m_rConnInfo.fIStartedRas)
        return (S_OK);

    if (fShutdown)
    {
        AthLoadString(idsRasPromptDisconnect, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, m_rConnInfo.szCurrentConnectionName);
        
        idAnswer = AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szBuf, 
                                 0, MB_YESNO | MB_ICONEXCLAMATION );
    }
    
    // Hang up
    if (idAnswer == IDYES)
    {
        SendAdvise(CONNNOTIFY_DISCONNECTING, NULL);

        if (S_FALSE == DoAutoDial(hwnd, m_rConnInfo.szCurrentConnectionName, FALSE))
        {
            InternetHangUpAndWait(m_dwConnId, DEF_HANGUP_WAIT);
            /*
            RasHangupAndWait(m_rConnInfo.hRasConn, DEF_HANGUP_WAIT);
            */
        }

        EnterCriticalSection(&m_cs);

        ZeroMemory(&m_rConnInfo, sizeof(CONNINFO));
        m_rConnInfo.state = CIS_CLEAN;
        m_dwConnId = 0;

        LeaveCriticalSection(&m_cs);
        
        EmptyConnList();

        SendAdvise(CONNNOTIFY_DISCONNECTED, NULL);
        return (S_OK);
    }
        
    return (E_FAIL);    
}

//
//  FUNCTION:   CConnectionManager::IsConnected()
//
//  PURPOSE:    Allows the client to query whether or not there is an active
//              RAS connection that we established.
//
//  RETURN VALUE:
//      TRUE - We're connected, FALSE - we're not.
//
BOOL CConnectionManager::IsConnected(void)
{
    BOOL f=FALSE;

    EnterCriticalSection(&m_cs);

    RefreshConnInfo();

    if (m_rConnInfo.hRasConn)
    {
        f = (NULL == m_rConnInfo.hRasConn) ? FALSE : TRUE;
    }

    LeaveCriticalSection(&m_cs);
    return f;
}
    

//
//  FUNCTION:   CConnectionManager::Advise()
//
//  PURPOSE:    Allows the user to register to be notified whenever connection
//              status changes.
//
//  PARAMETERS:
//      <in> pNotify - Pointer to the IConnectionNotify interface the client 
//                     would like called when events happen.
//
//  RETURN VALUE:
//      S_OK          - Added ok.
//      E_OUTOFMEMORY - Couldn't realloc the array
//
HRESULT CConnectionManager::Advise(IConnectionNotify *pNotify)
{
    HRESULT hr = S_OK; 

    if (!pNotify)
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);

    // Check to see if we already have a notify window for this thread
    NOTIFYHWND *pTemp = m_pNotifyList;
    DWORD dwThread = GetCurrentThreadId();

    while (pTemp)
    {
        if (pTemp->dwThreadId == dwThread)
            break;

        pTemp = pTemp->pNext;
    }

    // If we didn't find a notify window for this thread, create one
    if (NULL == pTemp)
    {
        HWND hwndTemp = CreateWindow(NOTIFY_HWND, NULL, WS_OVERLAPPED, 10, 10, 10, 10,
                                     NULL, (HMENU) 0, g_hInst, (LPVOID) this);
        if (!hwndTemp)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        if (!MemAlloc((LPVOID*) &pTemp, sizeof(NOTIFYHWND)))
        {
            RemoveProp(hwndTemp, NOTIFY_HWND);
            DestroyWindow(hwndTemp);
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pTemp->dwThreadId = dwThread;
        pTemp->hwnd = hwndTemp;
        pTemp->pNext = m_pNotifyList;
        m_pNotifyList = pTemp;        
    }

    // Allocate a NOTIFYLIST node for this caller
    NOTIFYLIST *pListTemp;
    if (!MemAlloc((LPVOID*) &pListTemp, sizeof(NOTIFYLIST)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pListTemp->pNotify = pNotify;

    // Get the current list for this thread and insert this node at the 
    // beginning
    pListTemp->pNext = (NOTIFYLIST *) GetWindowLongPtr(pTemp->hwnd, GWLP_USERDATA);

    // Set this new list to the window
    SetWindowLongPtr(pTemp->hwnd, GWLP_USERDATA, (LONG_PTR)pListTemp);

exit:
    LeaveCriticalSection(&m_cs);
    return (hr);
}    

    
//
//  FUNCTION:   CConnectionManager::Unadvise()
//
//  PURPOSE:    Allows a client that has previously registered for notifications
//              to unregister itself.
//
//  PARAMETERS:
//      <in> pNotify - Pointer to the interface that is being called upon 
//                     notifications.
//
//  RETURN VALUE:
//      E_INVALIDARG - pNotify was not found in the list
//      S_OK         - Everything's OK
//
HRESULT CConnectionManager::Unadvise(IConnectionNotify *pNotify)
{
    DWORD index = 0;
    HRESULT hr = S_OK;
  
    EnterCriticalSection(&m_cs);    

    // Loop through the notify windows we own
    NOTIFYHWND *pTemp = m_pNotifyList;
    NOTIFYHWND *pHwndPrev = NULL;
    while (pTemp)
    {
        // Get the list of notify callbacks for this window
          NOTIFYLIST *pList = (NOTIFYLIST *)GetWindowLongPtr(pTemp->hwnd, GWLP_USERDATA);
        if (pList)
        {
            // Loop through the callbacks looking for this one
            NOTIFYLIST *pListT = pList;
            NOTIFYLIST *pPrev;
    
            // Check to see if it's the first one
            if (pListT->pNotify == pNotify)
            {
                pList = pListT->pNext;
                if (pList)
                {
                    SetWindowLongPtr(pTemp->hwnd, GWLP_USERDATA, (LONG_PTR)pList);
                }
                else
                {
                    Assert(GetCurrentThreadId() == GetWindowThreadProcessId(pTemp->hwnd, NULL));
                    RemoveProp(pTemp->hwnd, NOTIFY_HWND);
                    DestroyWindow(pTemp->hwnd);
                    if (pHwndPrev)
                        pHwndPrev->pNext = pTemp->pNext;
                    else
                        m_pNotifyList = pTemp->pNext;
                    MemFree(pTemp);
                }
                SafeMemFree(pListT);
                hr = S_OK;
                goto exit;
            }
            else
            {
                pPrev = pList;
                pListT = pList->pNext;

                while (pListT)
                {
                    if (pListT->pNotify == pNotify)
                    {
                        pPrev->pNext = pListT->pNext;
                        SafeMemFree(pListT);
                        hr = S_OK;
                        goto exit;
                    }

                    pListT = pListT->pNext;
                    pPrev = pPrev->pNext;
                }
            }
        }

        pHwndPrev = pTemp;
        pTemp = pTemp->pNext;
    }

exit:
    LeaveCriticalSection(&m_cs);
    return (hr);    
}    
    
    
//
//  FUNCTION:   CConnectionManager::RasAccountsExist()
//
//  PURPOSE:    Allows the client to ask whether or not we have any accounts
//              configured that require a RAS connection.
//
//  RETURN VALUE:
//      S_OK    - Accounts exist that require RAS
//      S_FALSE - No accounts exist that require RAS
//
HRESULT CConnectionManager::RasAccountsExist(void)
    {
    IImnEnumAccounts    *pEnum = NULL;
    IImnAccount         *pAcct = NULL;
    DWORD                dwConn;
    BOOL                 fFound = FALSE;

    // If no RAS, no accounts
#ifdef SLOWDOWN_STARTUP_TIME
    if (FAILED(VerifyRasLoaded()))
        return (S_FALSE);
#endif

    // We need to walk through the accounts in the Account Manager to see if
    // any of them have a connect type of RAS.  As soon as we find one, we can
    // return success.
    Assert(m_pAcctMan);

    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
        {
        pEnum->Reset();

        while (!fFound && SUCCEEDED(pEnum->GetNext(&pAcct)))
            {
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
                {
                if (dwConn == CONNECTION_TYPE_RAS)
                    {
                    fFound = TRUE;
                    }
                }
            SafeRelease(pAcct);
            }

        SafeRelease(pEnum);
        }

    return (fFound ? S_OK : S_FALSE);
    }


//
//  FUNCTION:   CConnectionManager::GetConnectMenu()
//
//  PURPOSE:    Returns a menu that has all the accounts that require RAS
//              connections listed.  A pointer to the IImnAccount for each
//              account is stored in the menu item's dwItemData parameter.
//              As a result, the client MUST call FreeConnectMenu() when then
//              menu is no longer being used.
//
//  PARAMETERS:
//      <out> phMenu - Returns the menu handle
//
//  RETURN VALUE:
//      S_OK - phMenu contains the menu
//      E_FAIL - Something unfortunate happend.  
//
HRESULT CConnectionManager::GetConnectMenu(HMENU *phMenu)
    {
    HMENU               hMenu = NULL;
    IImnEnumAccounts   *pEnum = NULL;
    IImnAccount        *pAcct = NULL;
    DWORD               dwConn = 0;
    TCHAR               szAcct[CCHMAX_ACCOUNT_NAME];
    TCHAR               szConn[CCHMAX_CONNECTOID];
    TCHAR               szConnQuoted[CCHMAX_CONNECTOID + 2], szBuf[CCHMAX_CONNECTOID + 2];
    TCHAR               szMenu[CCHMAX_ACCOUNT_NAME + CCHMAX_CONNECTOID];
    MENUITEMINFO        mii;
    DWORD               cAcct = 0;
    
    // Create a menu and add all the RAS based accounts to it
    Assert(m_pAcctMan);
    hMenu = CreatePopupMenu();
    
    // Get the enumerator from the account manager
    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
        {
        pEnum->Reset();

        // Walk through all the accounts
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
            {
            // Get the connection type for this account
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
                {
                // If the account is a RAS account, ask for the connectoid name
                // and the account name.
                if (dwConn == CONNECTION_TYPE_RAS)
                    {
                    pAcct->GetPropSz(AP_RAS_CONNECTOID, szConn, ARRAYSIZE(szConn));
                    pAcct->GetPropSz(AP_ACCOUNT_NAME, szAcct, ARRAYSIZE(szAcct));
                    wnsprintf(szMenu, ARRAYSIZE(szMenu), _T("%s (%s)"), PszEscapeMenuStringA(szAcct, szBuf, sizeof(szBuf) / sizeof(TCHAR)), PszEscapeMenuStringA(szConn, szConnQuoted, sizeof(szConnQuoted) / sizeof(TCHAR)));
                    
                    // Insert the menu item into the menu
                    ZeroMemory(&mii, sizeof(MENUITEMINFO));
                    mii.cbSize     = sizeof(MENUITEMINFO);
                    mii.fMask      = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
                    mii.fType      = MFT_STRING | MFT_RADIOCHECK;
                    mii.fState     = MFS_ENABLED;
                    mii.wID        = ID_CONNECT_FIRST + cAcct;
                    mii.dwItemData = (DWORD_PTR) pAcct;
                    mii.dwTypeData = szMenu;
                    pAcct->AddRef();                    

                    SideAssert(InsertMenuItem(hMenu, cAcct, TRUE, &mii));
                    cAcct++;
                    }
                }
            SafeRelease(pAcct);
            }

        SafeRelease(pEnum);
        }

    if (hMenu)
        if(GetMenuItemCount(hMenu))
            {
            *phMenu = hMenu;
            return (S_OK);
            }
        else
            {
            DestroyMenu(hMenu);
            return (E_FAIL);
            }
    else
        return (E_FAIL);
    }


//
//  FUNCTION:   CConnectionManager::FreeConnectMenu()
//
//  PURPOSE:    Frees the item data stored with the menu returned from 
//              GetConnectMenu().
//
//  PARAMETERS:
//      <in> hMenu - Handle of the menu to free.
//
void CConnectionManager::FreeConnectMenu(HMENU hMenu)
    {
    // Walk through the items on this menu and free the pointers stored in
    // the item data.
    MENUITEMINFO mii;
    int          cItems = 0;

    Assert(hMenu);

    cItems = GetMenuItemCount(hMenu);
    for (int i = 0; i < cItems; i++)
        {
        mii.cbSize      = sizeof(MENUITEMINFO);
        mii.fMask       = MIIM_DATA;
        mii.dwItemData  = 0;

        if (GetMenuItemInfo(hMenu, i, TRUE, &mii))
            {
            Assert(mii.dwItemData);

            if (mii.dwItemData)
                ((IImnAccount *) mii.dwItemData)->Release();
            }
        }

    DestroyMenu(hMenu);
    }


//
//  FUNCTION:   CConnectionManager::OnActivate()
//
//  PURPOSE:    Called whenever the browser receives a WM_ACTIVATE message.
//              In response, we check the current state of our RAS connection
//              to see if we are still connected / disconnected.
void CConnectionManager::OnActivate(BOOL fActive)
    {
    BOOL fOfflineChanged = FALSE;
    BOOL fOffline = FALSE;

    if (fActive)
        {
        EnterCriticalSection(&m_cs);
        m_rConnInfo.state = CIS_REFRESH;

        // Check to see if we've gone offline
        if (m_fOffline != IsGlobalOffline())
            {
            fOffline = m_fOffline = (!m_fOffline);
            fOfflineChanged = TRUE;
            }

        LeaveCriticalSection(&m_cs);

        // Do this outside of the critsec
        if (fOfflineChanged)
            SendAdvise(CONNNOTIFY_WORKOFFLINE, (LPVOID) IntToPtr(fOffline));
        }
    }

//
//  FUNCTION:   CConnectionManager::FillRasCombo()
//
//  PURPOSE:    This function enumerates the accounts in the account manager
//              and builds a list of the RAS connections those accounts use.
//              The function then inserts those connections in to the provided
//              combobox.
//
//  PARAMETERS:
//      <in> hwndCombo - Handle of the combobox to fill
//      <in> fIncludeNone - Inserts a string at the top "Don't dial a connection"
//
//  RETURN VALUE:
//      BOOL
//
BOOL CConnectionManager::FillRasCombo(HWND hwndCombo, BOOL fIncludeNone)
    {
    IImnEnumAccounts   *pEnum = NULL;
    IImnAccount        *pAcct = NULL;
    DWORD               dwConn = 0;
    LPTSTR             *rgszConn = NULL;
    TCHAR               szConn[CCHMAX_CONNECTOID];
    ULONG               cAcct = 0;
    ULONG               cConn = 0;
    BOOL                fSucceeded = FALSE;
    ULONG               ul;

    LPRASENTRYNAME      pEntry=NULL;
    DWORD               dwSize,
                        cEntries,
                        dwError;

    HRESULT             hr = S_OK;
    int                 i;

    EnterCriticalSection(&m_cs);
#ifdef NEVER

    // Find out how many accounts exist
    m_pAcctMan->GetAccountCount(ACCT_NEWS, &cAcct);
    m_pAcctMan->GetAccountCount(ACCT_MAIL, &ul);
    cAcct += ul;
    m_pAcctMan->GetAccountCount(ACCT_DIR_SERV, &ul);
    cAcct += ul;
        
    if (cAcct == 0)
        {
        fSucceeded = TRUE;
        goto exit;
        }

    // Allocate an array to hold the connection list
    if (!MemAlloc((LPVOID*) &rgszConn, cAcct * sizeof(LPTSTR)))
        goto exit;
    ZeroMemory(rgszConn, cAcct * sizeof(LPTSTR));
    
    // Get the enumerator from the account manager
    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
        {
        pEnum->Reset();

        // Walk through all the accounts
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
            {
            // Get the connection type for this account
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
                {
                // If the account is a RAS account, ask for the connectoid name
                // and the account name.
                if (dwConn == CONNECTION_TYPE_RAS)
                    {
                    pAcct->GetPropSz(AP_RAS_CONNECTOID, szConn, ARRAYSIZE(szConn));

                    // Check to see if this connection has already been inserted into
                    // our list
                    for (ULONG k = 0; k < cConn; k++)
                        {
                        if (0 == lstrcmpi(szConn, rgszConn[k]))
                            break;
                        }

                    // If we didn't find it, we insert it
                    if (k >= cConn)
                        {
                        rgszConn[cConn] = StringDup(szConn);
                        cConn++;
                        }
                    }
                }
            SafeRelease(pAcct);
            }

        SafeRelease(pEnum);
        }

        // Sort the list
    int i, j, min;
    LPTSTR pszT;
    for (i = 0; i < (int) cConn; i++)
        {
        min = i;
        for (j = i + 1; j < (int) cConn; j++)
            if (0 > lstrcmpi(rgszConn[j], rgszConn[min]))
                min = j;

        pszT = rgszConn[min];
        rgszConn[min] = rgszConn[i];
        rgszConn[i] = pszT;
        }

    // Insert the items into the combo box
    if (fIncludeNone)
        {
        AthLoadString(idsConnNoDial, szConn, ARRAYSIZE(szConn));
        ComboBox_AddString(hwndCombo, szConn);
        }

    for (i = 0; i < (int) cConn; i++)
        ComboBox_AddString(hwndCombo, rgszConn[i]);

#endif NEVER

    // Make sure the RAS DLL is loaded before we try this
    CHECKHR(hr = VerifyRasLoaded());

    // Allocate RASENTRYNAME
    dwSize = sizeof(RASENTRYNAME);
    CHECKHR(hr = HrAlloc((LPVOID*)&pEntry, dwSize));
    
    // Ver stamp the entry
    pEntry->dwSize = sizeof(RASENTRYNAME);
    cEntries = 0;
    dwError = RasEnumEntries(NULL, NULL, pEntry, &dwSize, &cEntries);
    if (dwError == ERROR_BUFFER_TOO_SMALL)
    {
        SafeMemFree(pEntry);
        CHECKHR(hr = HrAlloc((LPVOID *)&pEntry, dwSize));
        pEntry->dwSize = sizeof(RASENTRYNAME);
        cEntries = 0;
        dwError = RasEnumEntries(NULL, NULL, pEntry, &dwSize, &cEntries);        
    }

    // Error ?
    if (dwError)
    {
        hr = TrapError(IXP_E_RAS_ERROR);
        goto exit;
    }

    // Insert the items into the combo box
    if (fIncludeNone)
        {
        AthLoadString(idsConnNoDial, szConn, ARRAYSIZE(szConn));
        ComboBox_AddString(hwndCombo, szConn);
        }

    for (i = 0; i < (int) cEntries; i++)
        ComboBox_AddString(hwndCombo, pEntry[i].szEntryName);

    fSucceeded = TRUE;

exit:
    if (rgszConn)
        {
        for (i = 0; i < (int) cConn; i++)
            SafeMemFree(rgszConn[i]);
        MemFree(rgszConn);
        }

    SafeMemFree(pEntry);

    LeaveCriticalSection(&m_cs);
    return (fSucceeded);
    }


//
//  FUNCTION:   CConnectionManager::DoStartupDial()
//
//  PURPOSE:    This function checks to see what the user's startup options 
//              are with respect to RAS and performs the actions required 
//              (dial, dialog, nada)
//  PARAMETERS:
//      <in> hwndParent - Handle to parent a dialog to
//
void CConnectionManager::DoStartupDial(HWND hwndParent)
{
    DWORD       dwStart;
    DWORD       dw;
    DWORD       dwReturn;
    TCHAR       szConn[CCHMAX_CONNECTOID];
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
    DWORD       dwDialFlags = 0;
    DWORD       dwLanFlags = 0;

    // The first thing to do is figure out what the user's startup option if
    dw = DwGetOption(OPT_DIALUP_START);

    // If the user want's to do nothing, we're done
    if (dw == START_NO_CONNECT)
        return;

    //ConnectUsingIESettings(hwndParent, TRUE);
    
    if (!m_fDialerUI)
    {
        m_fDialerUI = TRUE;
        // Check to see if we're working offline
        if (IsGlobalOffline())
        {
            if (IDYES == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                      0, MB_YESNO | MB_ICONEXCLAMATION ))
            {
                g_pConMan->SetGlobalOffline(FALSE);
            }
            else
            {
                goto DialerExit;
            }
        }

        //We do not dial if there is an active connection already existing. Even if it is not the connection
        //InternetDial would have dialed, if we had called. Heres why:
        //1)We don't want to look into the registry to get the default connectoid.
        //Thats why we call InternetDial with NULL and it dials the def connectoid if there is one set
        //Otherwise it dials the first connectoid in the list.
        //Since InternetDial figures out which connectoid to dial, we don't want to do all the work of figuring
        //out if we are already connected to the connectoid we are going to dial.
        //So we just do not dial even if there is one active connection.

        if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)))
        {
            if (cConnections > 0)
                goto DialerExit;
        }

        dwDialFlags = INTERNET_AUTODIAL_FORCE_ONLINE;

        if (VerifyMobilityPackLoaded() == S_OK)
        {
            if (!IsNetworkAlive(&dwLanFlags) || (!(dwLanFlags & NETWORK_ALIVE_LAN)))
                dwDialFlags |= INTERNET_DIAL_SHOW_OFFLINE;
        }

        // Only one caller can be dialing the phone at a time.
        if (WAIT_TIMEOUT == WaitForSingleObject(m_hMutexDial, 0))
        {
            goto DialerExit;
        }

        dwReturn = InternetDialA(hwndParent, NULL, dwDialFlags, &m_dwConnId, 0);
        if (dwReturn == 0)
        {
           m_rConnInfo.fConnected = TRUE;
           m_rConnInfo.fIStartedRas = TRUE;
           m_rConnInfo.fAutoDial = FALSE;
           m_rConnInfo.hRasConn  = (HRASCONN)m_dwConnId;
           SendAdvise(CONNNOTIFY_CONNECTED, NULL);
        }
        else
        {
            if (dwReturn == ERROR_USER_DISCONNECTION)
            {
                SendAdvise(CONNNOTIFY_USER_CANCELLED, NULL);
                
                if (!!(dwDialFlags & INTERNET_DIAL_SHOW_OFFLINE))
                    SetGlobalOffline(TRUE);
            }
            else
            {
                DebugTrace("Error dialing: %d\n", GetLastError());
                DebugTrace("InternetDial returned: %d\n", dwReturn);
            }
        }

DialerExit:
        m_fDialerUI = FALSE;
        SafeMemFree(pConnections);
    }

    ReleaseMutex(m_hMutexDial);
}

HRESULT CConnectionManager::GetDefConnectoid(LPTSTR  szConn, DWORD  dwSize)
{
    HRESULT     hr = E_FAIL;
    DWORD       dwType;
    DWORD       dwerr;

    *szConn = '\0';

    if ((dwerr = SHGetValue(HKEY_CURRENT_USER, c_szDefConnPath, c_szRegDefaultConnection, &dwType, szConn, &dwSize)) 
        == ERROR_SUCCESS)
    {
        hr = S_OK;
    }
    return hr;
}

//
//  FUNCTION:   CConnectionManager::VerifyRasLoaded()
//
//  PURPOSE:    Checks to see if this object has already loaded the RAS DLL.  
//              If not, then the DLL is loaded and the function pointers are
//              fixed up.
//
//  RETURN VALUE:
//      S_OK             - Loaded and ready, sir.
//      hrRasInitFailure - Failed to load.
//
HRESULT CConnectionManager::VerifyRasLoaded(void)
    {
    // Locals
    UINT uOldErrorMode;

    // Protected
    EnterCriticalSection(&m_cs);

    // Check to see if we've tried this before
    if (m_fRASLoadFailed)
        goto failure;

    // Bug #20573 - Let's do a little voodoo here.  On NT, it appears that they
    //              have a key in the registry to show which protocols are 
    //              supported by RAS service.  AKA - if this key doesn't exist,
    //              then RAS isn't installed.  This may enable us to avoid some
    //              special bugs when RAS get's uninstalled on NT.
    if (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
        HKEY hKey;
        const TCHAR c_szRegKeyRAS[] = _T("SOFTWARE\\Microsoft\\RAS");

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyRAS, 0, KEY_READ, &hKey))
            {
            goto failure;
            }

        RegCloseKey(hKey);
        }

    // If dll is loaded, lets verify all of my function pointers
    if (!m_hInstRas)
        {
        // Try loading Ras.        
        uOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
        m_hInstRas = LoadLibrary(szRasDll);
        SetErrorMode(uOldErrorMode);

        // Failure ?
        if (!m_hInstRas)
            goto failure;

        // Did we load it
        m_pRasDial = (RASDIALPROC)GetProcAddress(m_hInstRas, szRasDial);
        m_pRasEnumConnections = (RASENUMCONNECTIONSPROC)GetProcAddress(m_hInstRas, szRasEnumConnections);                    
        m_pRasEnumEntries = (RASENUMENTRIESPROC)GetProcAddress(m_hInstRas, szRasEnumEntries);                    
        m_pRasGetConnectStatus = (RASGETCONNECTSTATUSPROC)GetProcAddress(m_hInstRas, szRasGetConnectStatus);                    
        m_pRasGetErrorString = (RASGETERRORSTRINGPROC)GetProcAddress(m_hInstRas, szRasGetErrorString);                    
        m_pRasHangup = (RASHANGUPPROC)GetProcAddress(m_hInstRas, szRasHangup);                    
        m_pRasSetEntryDialParams = (RASSETENTRYDIALPARAMSPROC)GetProcAddress(m_hInstRas, szRasSetEntryDialParams);                    
        m_pRasGetEntryDialParams = (RASGETENTRYDIALPARAMSPROC)GetProcAddress(m_hInstRas, szRasGetEntryDialParams);
        m_pRasEditPhonebookEntry = (RASEDITPHONEBOOKENTRYPROC)GetProcAddress(m_hInstRas, szRasEditPhonebookEntry);    
        m_pRasGetEntryProperties = (RASGETENTRYPROPERTIES) GetProcAddress(m_hInstRas, szRasGetEntryProperties);
        }

    if (!m_hInstRasDlg && FIsPlatformWinNT())
        {
        // Try loading Ras.        
        uOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
        m_hInstRasDlg = LoadLibrary(s_szRasDlgDll);
        SetErrorMode(uOldErrorMode);

        // Failure ?
        if (!m_hInstRasDlg)
            goto failure;

        m_pRasDialDlg = (RASDIALDLGPROC)GetProcAddress(m_hInstRasDlg, s_szRasDialDlg);
        m_pRasEntryDlg = (RASENTRYDLGPROC)GetProcAddress(m_hInstRasDlg, s_szRasEntryDlg);

        if (!m_pRasDialDlg || !m_pRasEntryDlg)
            goto failure;
        }

    // Make sure all functions have been loaded
    if (m_pRasDial                      &&
        m_pRasEnumConnections           &&
        m_pRasEnumEntries               &&
        m_pRasGetConnectStatus          &&
        m_pRasGetErrorString            &&
        m_pRasHangup                    &&
        m_pRasSetEntryDialParams        &&
        m_pRasGetEntryDialParams        &&
        m_pRasEditPhonebookEntry)
        {
        // Protected
        LeaveCriticalSection(&m_cs);

        // Success
        return S_OK;
        }

failure:
    m_fRASLoadFailed = TRUE;

    // Protected
    LeaveCriticalSection(&m_cs);

    // Otherwise, were hosed
    return (hrRasInitFailure);
    }


//
//  FUNCTION:   CConnectionManager::EnumerateConnections()
//
//  PURPOSE:    Asks RAS for the list of active RAS connections.
//
//  PARAMETERS:
//      <out> ppRasConn     - Returns an array of RASCONN structures for the
//                            list of active connections.
//      <out> pcConnections - Number of structures in ppRasCon.
//
//  RETURN VALUE:
//      S_OK - The data in ppRasConn and pcConnections is valid
//
HRESULT CConnectionManager::EnumerateConnections(LPRASCONN *ppRasConn, 
                                                 ULONG *pcConnections)
    {
    // Locals
    DWORD       dw, 
                dwSize;
    BOOL        fResult=FALSE;
    HRESULT     hr;

    // Check Params
    Assert(ppRasConn && pcConnections);

    // Make sure RAS is loaded
    if (FAILED(hr = VerifyRasLoaded()))
        return (hr);

    // Init
    *ppRasConn = NULL;
    *pcConnections = 0;

    // Sizeof my buffer
    dwSize = sizeof(RASCONN) * 2;

    // Allocate enough for 1 ras connection info object
    if (!MemAlloc((LPVOID *)ppRasConn, dwSize))
        {
        TRAPHR(hrMemory);
        return (E_OUTOFMEMORY);
        }

    ZeroMemory(*ppRasConn, dwSize);

    // Buffer size
    //(*ppRasConn)->dwSize = dwSize;
    (*ppRasConn)->dwSize = sizeof(RASCONN);

    // Enumerate ras connections
    dw = RasEnumConnections(*ppRasConn, &dwSize, pcConnections);

    // Not enough memory ?
    if ((dw == ERROR_BUFFER_TOO_SMALL) || (dw == ERROR_NOT_ENOUGH_MEMORY))
        {
        // Reallocate
        if (!MemRealloc((LPVOID *)ppRasConn, dwSize))
            {
            TRAPHR(hrMemory);
            goto exit;
            }

        // Call enumerate again
        *pcConnections = 0;
        (*ppRasConn)->dwSize = sizeof(RASCONN);
        dw = RasEnumConnections(*ppRasConn, &dwSize, pcConnections);
        }

    // If still failed
    if (dw)
        {
        AssertSz(FALSE, "RasEnumConnections failed");
        return E_FAIL;
        }   
    // Success
    hr = S_OK;
exit:
    // Done
    return S_OK;
    }


//
//  FUNCTION:   CConnectionManager::StartRasDial()
//
//  PURPOSE:    Called when the client actually wants to establish a RAS 
//              connection.
//
//  PARAMETERS:
//      <in> hwndParent    - Handle of the window to parent any UI
//      <in> pszConnection - Name of the connection to establish
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CConnectionManager::StartRasDial(HWND hwndParent, LPTSTR pszConnection)
    {
    HRESULT       hr = S_OK;

    // Refresh ConnInfo
    CHECKHR(hr = RefreshConnInfo());
    
    // Check to see if we need to ask the user for information or credentials
    // before we attempt to dial
    CHECKHR (hr = RasLogon(hwndParent, pszConnection, FALSE));

    // If we can use a system dialog for this, do so.
    if (m_pRasDialDlg)
        {
        RASDIALDLG rdd = {0};
        BOOL       fRet;

        rdd.dwSize     = sizeof(rdd);
        rdd.hwndOwner  = hwndParent;

#if (WINVER >= 0x401)
        rdd.dwSubEntry = m_rdp.dwSubEntry;
#else
        rdd.dwSubEntry = 0;
#endif

        fRet = RasDialDlg(NULL, m_rdp.szEntryName, 
                          lstrlen(m_rdp.szPhoneNumber) ? m_rdp.szPhoneNumber : NULL, 
                          &rdd);
        if (fRet)
            {
            // Need to get the current connection handle
            LPRASCONN   pConnections = NULL;
            ULONG       cConnections = 0;

            if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)))
                {
                for (UINT i = 0; i < cConnections; i++)
                    {
                    if (0 == lstrcmpi(pConnections[i].szEntryName, m_rdp.szEntryName))
                        {
                        EnterCriticalSection(&m_cs);
                        m_rConnInfo.hRasConn = pConnections[i].hrasconn;
                        LeaveCriticalSection(&m_cs);
                        break;
                        }
                    }

                SafeMemFree(pConnections);
                }

            hr = S_OK;
            }
        else
            hr = E_FAIL;
        }
    else
        {
        // We need to use our own RAS UI.
        hr = (HRESULT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRasProgress), 
                            hwndParent, RasProgressDlgProc, 
                            (LPARAM) this);
        }

exit:
    // Done
    return hr;
    }
    

//
//  FUNCTION:   CConnectionManager::RasLogon()
//
//  PURPOSE:    Attempts to load the RAS phonebook entry for the requested
//              connection.  If it doesn't exist or there isn't enough info,
//              we present UI to the user to request that information.
//
//  PARAMETERS:
//      <in>  hwnd          - Handle to display UI over.
//      <in>  pszConnection - Name of the connection to load info for.
//      <in>  fForcePrompt  - Forces the UI to be displayed.
//
//  RETURN VALUE:
//      S_OK                  - prdp contains the requested information
//      hrGetDialParmasFailed - Couldn't get the phonebook entry from RAS
//      hrUserCancel          - User canceled
//
//
HRESULT CConnectionManager::RasLogon(HWND hwnd, LPTSTR pszConnection, 
                                     BOOL fForcePrompt)
    {
    // Locals
    HRESULT         hr = S_OK;
    DWORD           dwRasError;

    // Do we need to prompt for logon information first ?
    ZeroMemory(&m_rdp, sizeof(RASDIALPARAMS));
    m_rdp.dwSize = sizeof(RASDIALPARAMS);
    StrCpyN(m_rdp.szEntryName, pszConnection, ARRAYSIZE(m_rdp.szEntryName));

    // See if we can get the information from RAS
    dwRasError = RasGetEntryDialParams(NULL, &m_rdp, &m_fSavePassword);
    if (dwRasError)
        {
        TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
        AthLoadString(idshrGetDialParamsFailed, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, pszConnection);
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsRasError), szBuf, 0, MB_OK | MB_ICONSTOP);
        hr = TRAPHR(hrGetDialParamsFailed);
        goto exit;
        }

    // NT Supports the UI we need to display.  If this exists, then
    // RasDialDlg will take it from here
    if (m_pRasDialDlg)
        {         
        goto exit;
        }

    // Do we need to get password / account information?
    if (fForcePrompt || m_fSavePassword == FALSE || 
        FIsStringEmpty(m_rdp.szUserName) || FIsStringEmpty(m_rdp.szPassword))
        {
        // RAS Logon
        hr = (HRESULT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRasLogon), hwnd, 
                            RasLogonDlgProc, (LPARAM) this);
        if (hr == hrUserCancel)
            {
            DisplayRasError(hwnd, hrUserCancel, 0);
            hr = hrUserCancel;
            goto exit;
            }
        }

exit:
    // Done
    return hr;
    }


//
//  FUNCTION:   CConnectionManager::DisplayRasError()
//
//  PURPOSE:    Displays a message box describing the error that occured while
//              dealing with connections etc.
//
//  PARAMETERS:
//      <in> hwnd       - Handle of the window to display UI over
//      <in> hrRasError - HRESULT to display the error for
//      <in> dwRasError - Error code returned from RAS to display the error for
//
void CConnectionManager::DisplayRasError(HWND hwnd, HRESULT hrRasError,
                                         DWORD dwRasError)
    {
    // Locals
    TCHAR       szRasError[256];
    BOOL        fRasError = FALSE;

    // No Error
    if (SUCCEEDED(hrRasError))
        return;

    // Look up RAS error
    if (dwRasError)
        {
        if (RasGetErrorString(dwRasError, szRasError, sizeof(szRasError)) == 0)
            fRasError = TRUE;
        else
            *szRasError = _T('\0');
        }

    // General Error
    switch (hrRasError)
        {
        case hrUserCancel:
            break;

        case hrMemory:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(idsMemory), 0, MB_OK | MB_ICONSTOP);
            break;

        case hrRasInitFailure:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrRasInitFailure), 0, MB_OK | MB_ICONSTOP);
            break;

        case hrRasDialFailure:
            if (fRasError)
                CombinedRasError(hwnd, HR_CODE(hrRasDialFailure), szRasError, dwRasError);
            else
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrRasDialFailure), 0, MB_OK | MB_ICONSTOP);
            break;

        case hrRasServerNotFound:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrRasServerNotFound), 0, MB_OK | MB_ICONSTOP);
            break;

        case hrGetDialParamsFailed:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrGetDialParamsFailed), 0, MB_OK | MB_ICONSTOP);
            break;

        case E_FAIL:
        default:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(idsRasErrorGeneral), 0, MB_OK | MB_ICONSTOP);
            break;
        }

    }
        

//
//  FUNCTION:   CConnectionManager::PromptCloseConn()
//
//  PURPOSE:    Asks the user if they want to close the current connection or
//              try to use it.
//
//  PARAMETERS:
//      <in> hwnd - Parent for the dialog
//
//  RETURN VALUE:
//      Returns the button that closed the dialog
//
UINT CConnectionManager::PromptCloseConnection(HWND hwnd)
    {
    RefreshConnInfo();

    if (DwGetOption(OPT_DIALUP_WARN_SWITCH))
        {
        if (0 == lstrcmpi(m_rConnInfo.szCurrentConnectionName, m_szConnectName))
            return (idrgUseCurrent);
        else
            return (UINT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRasCloseConn), hwnd, 
                                  RasCloseConnDlgProc, (LPARAM) this);
        }
    else
        return (idrgDialNew);
    }
    
INT_PTR CALLBACK CConnectionManager::RasCloseConnDlgProc(HWND hwnd, UINT uMsg, 
                                                      WPARAM wParam, LPARAM lParam)
    {
    // Locals
    CConnectionManager *pThis = NULL;
    TCHAR szRes[255],
          szMsg[255+RAS_MaxEntryName+1];
    TCHAR szConn[CCHMAX_CONNECTOID + 2];

    switch(uMsg)
        {
        case WM_INITDIALOG:
            // The LPARAM contains our this pointer
            pThis = (CConnectionManager*) lParam;
            if (!pThis)
                {
                Assert(pThis);
                EndDialog(hwnd, E_FAIL);
                return (TRUE);
                }

            // Center
            CenterDialog(hwnd);

            // Refresh Connection Info
            pThis->RefreshConnInfo();

            // Set Text
            GetWindowText(GetDlgItem(hwnd, idcCurrentMsg), szRes, sizeof(szRes)/sizeof(TCHAR));
            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, PszEscapeMenuStringA(pThis->m_rConnInfo.szCurrentConnectionName, szConn, sizeof(szConn) / sizeof(TCHAR)));
            SetWindowText(GetDlgItem(hwnd, idcCurrentMsg), szMsg);

            // Set control
            GetWindowText(GetDlgItem(hwnd, idrgDialNew), szRes, sizeof(szRes)/sizeof(TCHAR));
            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, PszEscapeMenuStringA(pThis->m_szConnectName, szConn, sizeof(szConn) / sizeof(TCHAR)));
            SetWindowText(GetDlgItem(hwnd, idrgDialNew), szMsg);

            // Set Default
            CheckDlgButton(hwnd, idrgDialNew, TRUE);
            return (TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                case IDOK:
                    {
                    if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, idcDontWarnCheck)))
                        {
                        // If the user has this checked, we reset the "Warn before..." option
                        SetDwOption(OPT_DIALUP_WARN_SWITCH, 0, NULL, 0);
                        }
                    EndDialog(hwnd, IsDlgButtonChecked(hwnd, idrgDialNew) ? idrgDialNew : idrgUseCurrent);
                    return (TRUE);    
                    }

                case IDCANCEL:
                    EndDialog(hwnd, IDCANCEL);
                    return (TRUE);    
                }
            return (TRUE);    
        }
        
    return (FALSE);
    }


//
//  FUNCTION:   CConnectionMAanger::CombinedRasError()
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
void CConnectionManager::CombinedRasError(HWND hwnd, UINT unids, 
                                          LPTSTR pszRasError, DWORD dwRasError)
    {
    // Locals
    TCHAR           szRes[255],
                    sz[30];
    LPTSTR          pszError=NULL;

    // Load string
    AthLoadString(unids, szRes, sizeof(szRes));

    // Allocate memory for errors
    DWORD cc = lstrlen(szRes) + lstrlen(pszRasError) + 100;
    pszError = SzStrAlloc(cc);

    // Out of Memory ?
    if (!pszError)
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsRasError), szRes, 0, MB_OK | MB_ICONSTOP);

    // Build Error message
    else
        {
        AthLoadString(idsErrorText, sz, sizeof(sz));
        wnsprintf(pszError, cc, "%s\n\n%s %d: %s", szRes, sz, dwRasError, pszRasError);
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsRasError), pszError, 0, MB_OK | MB_ICONSTOP);
        MemFree(pszError);
        }
    }    
    

//
//  FUNCTION:   CConnectionManager::RasHangupAndWait()
//
//  PURPOSE:    Hangs up on a RAS connection and waits for it to finish before
//              returning.
//
//  PARAMETERS:
//      <in> hRasConn         - Handle of the connection to hang up.
//      <in> dwMaxWaitSeconds - Amount of time to wait.
//
//  RETURN VALUE:
//      TRUE if we disconnected, FALSE otherwise.
//
BOOL CConnectionManager::RasHangupAndWait(HRASCONN hRasConn, DWORD dwMaxWaitSeconds)
    {
    // Locals
    RASCONNSTATUS   rcs;
    DWORD           dwTicks=GetTickCount();

    // Check Params
    if (!hRasConn)
        return 0;

    // Make sure RAS is loaded
    if (FAILED (VerifyRasLoaded()))
        return FALSE;

    // Call Ras hangup
    if (RasHangup(hRasConn))
        return FALSE;

    // Wait for connection to really close
    ZeroMemory(&rcs, sizeof(RASCONNSTATUS));
    rcs.dwSize = sizeof(RASCONNSTATUS);
    while (RasGetConnectStatus(hRasConn, &rcs) != ERROR_INVALID_HANDLE && rcs.rasconnstate != RASCS_Disconnected)
        {
        // Wait timeout
        if (GetTickCount() - dwTicks >= dwMaxWaitSeconds * 1000)
            break;

        // Sleep and yields
        Sleep(0);
        }

    // Wait 2 seconds for modem to reset
    Sleep(2000);

    // Done
    return TRUE;
    }
    
DWORD CConnectionManager::InternetHangUpAndWait(DWORD_PTR   hRasConn, DWORD dwMaxWaitSeconds)
{
    // Locals
    RASCONNSTATUS   rcs;
    DWORD           dwTicks=GetTickCount();
    DWORD           dwret;

    // Check Params
    if (!hRasConn)
        return 0;

    // Make sure RAS is loaded
    if (FAILED (VerifyRasLoaded()))
        return FALSE;

    dwret = InternetHangUp(m_dwConnId, 0);
    if (dwret)
    {
        DebugTrace("InternetHangup failed: %d\n", dwret);
        goto exit;
    }

    // Wait for connection to really close
    ZeroMemory(&rcs, sizeof(RASCONNSTATUS));
    rcs.dwSize = sizeof(RASCONNSTATUS);
    while (RasGetConnectStatus((HRASCONN)hRasConn, &rcs) != ERROR_INVALID_HANDLE && rcs.rasconnstate != RASCS_Disconnected)
        {
        // Wait timeout
        if (GetTickCount() - dwTicks >= dwMaxWaitSeconds * 1000)
            break;

        // Sleep and yields
        Sleep(0);
        }

    // Wait 2 seconds for modem to reset
    Sleep(2000);

exit:
    return dwret;
}

INT_PTR CALLBACK CConnectionManager::RasLogonDlgProc(HWND hwnd, UINT uMsg, 
                                                  WPARAM wParam, LPARAM lParam)
    {
    // Locals
    TCHAR           sz[255],
                    szText[255 + RAS_MaxEntryName + 1];
    DWORD           dwRasError;
    CConnectionManager *pThis = (CConnectionManager *)GetWndThisPtr(hwnd);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get lparam
            pThis = (CConnectionManager *)lParam;
            if (!pThis)
                {
                Assert (FALSE);
                EndDialog(hwnd, E_FAIL);
                return (TRUE);
                }

            // Center the window
            CenterDialog(hwnd);

            // Get Window Title
            GetWindowText(hwnd, sz, sizeof(sz));
            wnsprintf(szText, ARRAYSIZE(szText), sz, pThis->m_szConnectName);
            SetWindowText(hwnd, szText);

            // Word Default
            AthLoadString(idsDefault, sz, sizeof(sz));
            
            // Set Fields
            Edit_LimitText(GetDlgItem(hwnd, ideUserName), UNLEN);
            Edit_LimitText(GetDlgItem(hwnd, idePassword), PWLEN);
            Edit_LimitText(GetDlgItem(hwnd, idePhone), RAS_MaxPhoneNumber);
            
            SetDlgItemText(hwnd, ideUserName, pThis->m_rdp.szUserName);
            SetDlgItemText(hwnd, idePassword, pThis->m_rdp.szPassword);

            if (FIsStringEmpty(pThis->m_rdp.szPhoneNumber))
                SetDlgItemText(hwnd, idePhone, sz);
            else
                SetDlgItemText(hwnd, idePhone, pThis->m_rdp.szPhoneNumber);

            CheckDlgButton(hwnd, idchSavePassword, pThis->m_fSavePassword);

            // Save pRas
            SetWndThisPtr(hwnd, pThis);
            return 1;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
                {
                case idbEditConnection:
                    pThis->EditPhonebookEntry(hwnd, (pThis->m_szConnectName));
                    return 1;

                case IDCANCEL:
                    EndDialog(hwnd, hrUserCancel);
                    return 1;

                case IDOK:
                    AthLoadString(idsDefault, sz, sizeof(sz));

                    // Set Fields
                    GetDlgItemText(hwnd, ideUserName, pThis->m_rdp.szUserName, UNLEN+1);
                    GetDlgItemText(hwnd, idePassword, pThis->m_rdp.szPassword, PWLEN+1);

                    GetDlgItemText(hwnd, idePhone, pThis->m_rdp.szPhoneNumber, RAS_MaxPhoneNumber+1);
                    if (lstrcmp(pThis->m_rdp.szPhoneNumber, sz) == 0)
                        *pThis->m_rdp.szPhoneNumber = _T('\0');
                    
                    pThis->m_fSavePassword = IsDlgButtonChecked(hwnd, idchSavePassword);

                    // Save Dial Parameters
                    dwRasError = (pThis->m_pRasSetEntryDialParams)(NULL, &(pThis->m_rdp), !(pThis->m_fSavePassword));
                    if (dwRasError)
                    {
                        pThis->DisplayRasError(hwnd, hrSetDialParamsFailed, dwRasError);
                        return 1;
                    }
                    EndDialog(hwnd, S_OK);
                    return 1;
                }
            break;

        case WM_DESTROY:
            SetWndThisPtr (hwnd, NULL);
            break;
        }
    return 0;
    }
    

INT_PTR CALLBACK CConnectionManager::RasProgressDlgProc(HWND hwnd, UINT uMsg, 
                                                     WPARAM wParam, LPARAM lParam)
    {
    // Locals
    CConnectionManager *pThis = (CConnectionManager *) GetWndThisPtr(hwnd);
    TCHAR           szText[255+RAS_MaxEntryName+1],
                    sz[255];
    static TCHAR    s_szCancel[40];
    static UINT     s_unRasEventMsg=0;
    static BOOL     s_fDetails=FALSE;
    static RECT     s_rcDialog;
    static BOOL     s_fAuthStarted=FALSE;
    DWORD           dwRasError,
                    cyDetails;
    RASCONNSTATUS   rcs;
    RECT            rcDetails,
                    rcDlg;
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get lparam
            pThis = (CConnectionManager *)lParam;
            if (!pThis)
            {
                Assert (FALSE);
                EndDialog(hwnd, E_FAIL);
                return 1;
            }

            // Save this pointer
            SetWndThisPtr (hwnd, pThis);

            // Save Original Size of the dialog
            GetWindowRect (hwnd, &s_rcDialog);

            // Refresh Connection Info
            pThis->RefreshConnInfo();

            // Details enabled
            s_fDetails = DwGetOption(OPT_RASCONNDETAILS);

            // Hide details drop down
            if (s_fDetails == FALSE)
            {
                // Hid
                GetWindowRect (GetDlgItem (hwnd, idcSplitter), &rcDetails);

                // Height of details
                cyDetails = s_rcDialog.bottom - rcDetails.top;
        
                // Re-size
                MoveWindow (hwnd, s_rcDialog.left, 
                                  s_rcDialog.top, 
                                  s_rcDialog.right - s_rcDialog.left, 
                                  s_rcDialog.bottom - s_rcDialog.top - cyDetails - 1,
                                  FALSE);
            }
            else
            {
                AthLoadString (idsHideDetails, sz, sizeof (sz));
                SetWindowText (GetDlgItem (hwnd, idbDet), sz);
            }

            // Get registered RAS event message id
            s_unRasEventMsg = RegisterWindowMessageA(RASDIALEVENT);
            if (s_unRasEventMsg == 0)
                s_unRasEventMsg = WM_RASDIALEVENT;

            // Center the window
            CenterDialog (hwnd);
            SetForegroundWindow(hwnd);

            // Get Window Title
            GetWindowText(hwnd, sz, sizeof(sz));
            wnsprintf(szText, ARRAYSIZE(szText), sz, pThis->m_szConnectName);
            SetWindowText(hwnd, szText);

            // Dialog Xxxxxxx.....
            if (pThis->m_rdp.szPhoneNumber[0])
                {
                AthLoadString(idsRas_Dialing_Param, sz, sizeof(sz)/sizeof(TCHAR));
                wnsprintf(szText, ARRAYSIZE(szText), sz, pThis->m_rdp.szPhoneNumber);
                }
            else
                AthLoadString(idsRas_Dialing, szText, ARRAYSIZE(szText));

            SetWindowText(GetDlgItem(hwnd, ideProgress), szText);

            // Get Cancel Text
            GetWindowText(GetDlgItem(hwnd, IDCANCEL), s_szCancel, sizeof(s_szCancel));

            // Give the list box and hscroll
            SendMessage(GetDlgItem(hwnd, idlbDetails), LB_SETHORIZONTALEXTENT, 600, 0);

            // Dial the connection
            pThis->m_rConnInfo.hRasConn = NULL;
            dwRasError = (pThis->m_pRasDial)(NULL, NULL, &(pThis->m_rdp), 0xFFFFFFFF, hwnd, &(pThis->m_rConnInfo.hRasConn));
            if (dwRasError)
            {
                pThis->FailedRasDial(hwnd, hrRasDialFailure, dwRasError);
                if (!pThis->LogonRetry(hwnd, s_szCancel))
                {
                    SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDCANCEL,IDCANCEL), NULL);
                    return 1;
                }
            }
            return 1;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam,lParam))
            {
            case IDCANCEL:
                SetDwOption(OPT_RASCONNDETAILS, s_fDetails, NULL, 0);
                EnableWindow(GetDlgItem(hwnd, IDCANCEL), FALSE);
                if (pThis)
                    pThis->FailedRasDial(hwnd, hrUserCancel, 0);
                EndDialog(hwnd, hrUserCancel);
                return 1;

            case idbDet:
                // Get current location of the dialog
                GetWindowRect (hwnd, &rcDlg);

                // If currently hidden
                if (s_fDetails == FALSE)
                {
                    // Re-size
                    MoveWindow (hwnd, rcDlg.left, 
                                      rcDlg.top, 
                                      s_rcDialog.right - s_rcDialog.left, 
                                      s_rcDialog.bottom - s_rcDialog.top,
                                      TRUE);

                    AthLoadString (idsHideDetails, sz, sizeof (sz));
                    SetWindowText (GetDlgItem (hwnd, idbDet), sz);
                    s_fDetails = TRUE;
                }

                else
                {
                    // Size of details
                    GetWindowRect (GetDlgItem (hwnd, idcSplitter), &rcDetails);
                    cyDetails = rcDlg.bottom - rcDetails.top;
                    MoveWindow (hwnd, rcDlg.left, 
                                      rcDlg.top, 
                                      s_rcDialog.right - s_rcDialog.left, 
                                      s_rcDialog.bottom - s_rcDialog.top - cyDetails - 1,
                                      TRUE);

                    AthLoadString (idsShowDetails, sz, sizeof (sz));
                    SetWindowText (GetDlgItem (hwnd, idbDet), sz);
                    s_fDetails = FALSE;
                }
                break;
            }
            break;

        case WM_DESTROY:
            SetWndThisPtr (hwnd, NULL);
            break;

        case CM_INTERNALRECONNECT:
            if (!pThis->LogonRetry(hwnd, s_szCancel))
                {
                SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDCANCEL,IDCANCEL), NULL);
                return 1;
                }
            break;
    

        default:
            if (!pThis)
                break;

            pThis->RefreshConnInfo();

            if (uMsg == s_unRasEventMsg)
            {
                HWND hwndLB = GetDlgItem(hwnd, idlbDetails);

                // Error ?
                if (lParam)
                {
                    // Disconnected
                    AthLoadString(idsRASCS_Disconnected, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);

                    // Log Error
                    TCHAR szRasError[512];
                    if ((pThis->m_pRasGetErrorString)((UINT) lParam, szRasError, sizeof(szRasError)) == 0)
                    {
                        TCHAR szError[512 + 255];
                        AthLoadString(idsErrorText, sz, sizeof(sz));
                        wnsprintf(szError, ARRAYSIZE(szError), "%s %d: %s", sz, lParam, szRasError);
                        ListBox_AddString(hwndLB, szError);
                    }

                    // Select last item
                    SendMessage(hwndLB, LB_SETCURSEL, ListBox_GetCount(hwndLB)-1, 0);

                    // Show Error
                    pThis->FailedRasDial(hwnd, hrRasDialFailure, (DWORD) lParam);

                    // Re logon
                    PostMessage(hwnd, CM_INTERNALRECONNECT, 0, 0);

                }

                // Otherwise, process RAS event
                else
                {
                    switch(wParam)
                    {
                    case RASCS_OpenPort:
                        AthLoadString(idsRASCS_OpenPort, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_PortOpened:
                        AthLoadString(idsRASCS_PortOpened, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_ConnectDevice:
                        rcs.dwSize = sizeof(RASCONNSTATUS);                    
                        if (pThis->m_rConnInfo.hRasConn && (pThis->m_pRasGetConnectStatus)(pThis->m_rConnInfo.hRasConn, &rcs) == 0)
                        {
                            AthLoadString(idsRASCS_ConnectDevice, sz, sizeof(sz)/sizeof(TCHAR));
                            wnsprintf(szText, ARRAYSIZE(szText), sz, rcs.szDeviceName, rcs.szDeviceType);
                            ListBox_AddString(hwndLB, szText);
                        }
                        break;

                    case RASCS_DeviceConnected:
                        rcs.dwSize = sizeof(RASCONNSTATUS);                    
                        if (pThis->m_rConnInfo.hRasConn && (pThis->m_pRasGetConnectStatus)(pThis->m_rConnInfo.hRasConn, &rcs) == 0)
                        {
                            AthLoadString(idsRASCS_DeviceConnected, sz, sizeof(sz)/sizeof(TCHAR));
                            wnsprintf(szText, ARRAYSIZE(szText), sz, rcs.szDeviceName, rcs.szDeviceType);
                            ListBox_AddString(hwndLB, szText);
                        }
                        break;

                    case RASCS_AllDevicesConnected:
                        AthLoadString(idsRASCS_AllDevicesConnected, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_Authenticate:
                        if (s_fAuthStarted == FALSE)
                        {
                            AthLoadString(idsRas_Authentication, sz, sizeof(sz)/sizeof(TCHAR));
                            SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                            ListBox_AddString(hwndLB, sz);
                            s_fAuthStarted = TRUE;
                        }
                        break;

                    case RASCS_AuthNotify:
                        rcs.dwSize = sizeof(RASCONNSTATUS);                    
                        if (pThis->m_rConnInfo.hRasConn && (pThis->m_pRasGetConnectStatus)(pThis->m_rConnInfo.hRasConn, &rcs) == 0)
                        {
                            AthLoadString(idsRASCS_AuthNotify, sz, sizeof(sz)/sizeof(TCHAR));
                            wnsprintf(szText, ARRAYSIZE(szText), sz, rcs.dwError);
                            ListBox_AddString(hwndLB, szText);
                            if (rcs.dwError)
                            {
                                pThis->FailedRasDial(hwnd, hrRasDialFailure, rcs.dwError);
                                PostMessage(hwnd, CM_INTERNALRECONNECT, 0, 0);
                            }
                        }
                        break;

                    case RASCS_AuthRetry:
                        AthLoadString(idsRASCS_AuthRetry, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthCallback:
                        AthLoadString(idsRASCS_AuthCallback, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthChangePassword:
                        AthLoadString(idsRASCS_AuthChangePassword, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthProject:
                        AthLoadString(idsRASCS_AuthProject, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthLinkSpeed:
                        AthLoadString(idsRASCS_AuthLinkSpeed, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthAck:
                        AthLoadString(idsRASCS_AuthAck, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_ReAuthenticate:
                        AthLoadString(idsRas_Authenticated, sz, sizeof(sz)/sizeof(TCHAR));
                        SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                        AthLoadString(idsRASCS_Authenticated, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_PrepareForCallback:
                        AthLoadString(idsRASCS_PrepareForCallback, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_WaitForModemReset:
                        AthLoadString(idsRASCS_WaitForModemReset, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_WaitForCallback:
                        AthLoadString(idsRASCS_WaitForCallback, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_Projected:
                        AthLoadString(idsRASCS_Projected, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_Disconnected:
                        AthLoadString(idsRASCS_Disconnected, sz, sizeof(sz)/sizeof(TCHAR));
                        SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                        ListBox_AddString(hwndLB, sz);
                        pThis->FailedRasDial(hwnd, hrRasDialFailure, 0);
                        PostMessage(hwnd, CM_INTERNALRECONNECT, 0, 0);
                        break;

                    case RASCS_Connected:
                        SetDwOption(OPT_RASCONNDETAILS, s_fDetails, NULL, 0);
                        AthLoadString(idsRASCS_Connected, sz, sizeof(sz)/sizeof(TCHAR));
                        SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                        ListBox_AddString(hwndLB, sz);
                        EndDialog(hwnd, S_OK);
                        break;
                    }

                    // Select last lb item
                    SendMessage(hwndLB, LB_SETCURSEL, ListBox_GetCount(hwndLB)-1, 0);
                }
                return 1;
            }
            break;
        }

    // Done
    return 0;
    }


BOOL CConnectionManager::LogonRetry(HWND hwnd, LPTSTR pszCancel)
    {
    // Locals
    DWORD       dwRasError;

    // Refresh
    RefreshConnInfo();

    // Reset Cancel button
    SetWindowText(GetDlgItem(hwnd, IDCANCEL), pszCancel);

    // Empty the listbox
    ListBox_ResetContent(GetDlgItem(hwnd, idlbDetails));

    while(1)
        {
        // If failed...
        if (FAILED(RasLogon(hwnd, m_szConnectName, TRUE)))
            return FALSE;

        // Dial the connection
        m_rConnInfo.hRasConn = NULL;
        dwRasError = RasDial(NULL, NULL, &m_rdp, 0xFFFFFFFF, hwnd, &m_rConnInfo.hRasConn);
        if (dwRasError)
            {
            FailedRasDial(hwnd, hrRasDialFailure, dwRasError);
            continue;
            }

        // Success
        break;
        }

    // Done
    return TRUE;
    }

// =====================================================================================
// CConnectionManager::FailedRasDial
// =====================================================================================
VOID CConnectionManager::FailedRasDial(HWND hwnd, HRESULT hrRasError, DWORD dwRasError)
    {
    // Locals
    TCHAR           sz[255];

    // Refresh
    RefreshConnInfo();

    // Hangup the connection
    if (m_rConnInfo.hRasConn)
        RasHangupAndWait(m_rConnInfo.hRasConn, DEF_HANGUP_WAIT);

    // Disconnected
    AthLoadString(idsRASCS_Disconnected, sz, sizeof(sz)/sizeof(TCHAR));
    SetWindowText(GetDlgItem(hwnd, ideProgress), sz);

    // Save dwRasError
    DisplayRasError(hwnd, hrRasError, dwRasError);

    // NULL it
    m_rConnInfo.hRasConn = NULL;

    // Change dialog button to OK
    AthLoadString(idsOK, sz, sizeof(sz)/sizeof(TCHAR));
    SetWindowText(GetDlgItem(hwnd, IDCANCEL), sz);
    }

DWORD CConnectionManager::EditPhonebookEntry(HWND hwnd, LPTSTR pszEntryName)
    {
    if (FAILED(VerifyRasLoaded()))
        return (DWORD)E_FAIL;

    if (FIsPlatformWinNT() && m_hInstRasDlg && m_pRasEntryDlg)
    {
        RASENTRYDLG info;

        ZeroMemory(&info, sizeof(RASENTRYDLG));
        info.dwSize = sizeof(RASENTRYDLG);
        info.hwndOwner = hwnd;

        m_pRasEntryDlg(NULL, pszEntryName, &info);
        return info.dwError;
    }
    else
    {
        return RasEditPhonebookEntry(hwnd, NULL, pszEntryName);
    }
    }


//
//  FUNCTION:   CConnectionNotify::SendAdvise()
//
//  PURPOSE:    Sends the specified notification to all the clients that have
//              requested notifications.
//
//  PARAMETERS:
//      <in> nCode - Notification code to send.
//      <in> pvData - Data to send with the notificaiton.  Can be NULL.
//
void CConnectionManager::SendAdvise(CONNNOTIFY nCode, LPVOID pvData)
    {
    if (nCode == CONNNOTIFY_CONNECTED)
        DoOfflineTransactions();

    // Loop through each interface and send the notification

    EnterCriticalSection(&m_cs);

    NOTIFYHWND *pTemp = m_pNotifyList;
    while (pTemp)
        {
        Assert(IsWindow(pTemp->hwnd));
        DWORD dwThread = GetCurrentThreadId();
        PostMessage(pTemp->hwnd, CM_NOTIFY, (WPARAM) nCode, (LPARAM) pvData);
        pTemp = pTemp->pNext;
        }

    LeaveCriticalSection(&m_cs);
    }


void CConnectionManager::FreeNotifyList(void)
    {
    // Loop through the notify windows we own
    NOTIFYHWND *pTemp;

    while (m_pNotifyList)
        {
        // Get the list of notify callbacks for this window
        if (IsWindow(m_pNotifyList->hwnd))
            {
            NOTIFYLIST *pList = (NOTIFYLIST *) GetWindowLongPtr(m_pNotifyList->hwnd, GWLP_USERDATA);
            NOTIFYLIST *pListT;

            // Loop through the callbacks freeing each one

            while (pList)
                {
                pListT = pList->pNext;
                SafeMemFree(pList);
                pList = pListT;
                }

            SetWindowLong(m_pNotifyList->hwnd, GWLP_USERDATA, NULL);

            RemoveProp(m_pNotifyList->hwnd, NOTIFY_HWND);
                
            if (GetCurrentThreadId() == GetWindowThreadProcessId(m_pNotifyList->hwnd, NULL))
            {
                DestroyWindow(m_pNotifyList->hwnd);
            }
            else
                PostMessage(m_pNotifyList->hwnd, WM_CLOSE, 0, 0L);
            }

        pTemp = m_pNotifyList;
        m_pNotifyList = m_pNotifyList->pNext;
        SafeMemFree(pTemp);
        }
    }


LRESULT CALLBACK CConnectionManager::NotifyWndProc(HWND hwnd, UINT uMsg, 
                                                   WPARAM wParam, LPARAM lParam)
{
    //CConnectionManager *pThis = (CConnectionManager *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    CConnectionManager  *pThis = (CConnectionManager *)GetProp(hwnd, NOTIFY_HWND);

    // If we're idle, then we should not process any notifications
    if (uMsg != WM_NCCREATE && !pThis)
        return (DefWindowProc(hwnd, uMsg, wParam, lParam));

    switch (uMsg)
        {
        case WM_NCCREATE:            
            pThis = (CConnectionManager *) ((LPCREATESTRUCT) lParam)->lpCreateParams;

            //SetWindowLong(hwnd, GWLP_USERDATA, (LONG) pThis);
            SetProp(hwnd, NOTIFY_HWND, (HANDLE)pThis);
            return (TRUE);
        
        case CM_NOTIFY:
            // This doesn't need to be critsec'd since the message is sent from
            // within a critsec.
            NOTIFYLIST *pList = (NOTIFYLIST *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            while (pList)
                {
                pList->pNotify->OnConnectionNotify((CONNNOTIFY) wParam, (LPVOID) lParam, pThis);
                pList = pList->pNext;
                }

            return (0);
        }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


HRESULT CConnectionManager::GetDefaultConnection(IImnAccount *pAccount,
                                                 IImnAccount **ppDefault)
    {
    TCHAR szDefault[CCHMAX_ACCOUNT_NAME];
    ACCTTYPE acctType;
    HRESULT hr = S_OK;

    // Get the type of account from the original account
    if (FAILED(hr = pAccount->GetAccountType(&acctType)))
        {
        // How can an account have no account type?
        Assert(FALSE);
        return (hr);
        }

    // Ask the account manager for the default account of this type
    if (FAILED(hr = g_pAcctMan->GetDefaultAccount(acctType, ppDefault)))
        {
        // No default account of this type?
        Assert(FALSE);
        return (hr);
        }

    return (S_OK);
    }

BOOL CConnectionManager::IsConnectionUsed(LPTSTR pszConn)
    {
    IImnEnumAccounts   *pEnum = NULL;
    IImnAccount        *pAcct = NULL;
    DWORD               dwConn = 0;
    TCHAR               szConn[CCHMAX_CONNECTOID];
    BOOL                fFound = FALSE;

    // Get the enumerator from the account manager
    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
        {
        pEnum->Reset();

        // Walk through all the accounts
        while (!fFound && SUCCEEDED(pEnum->GetNext(&pAcct)))
            {
            // Get the connection type for this account
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
                {
                // If the account is a RAS account, ask for the connectoid name
                // and the account name.
                if (dwConn == CONNECTION_TYPE_RAS)
                    {
                    pAcct->GetPropSz(AP_RAS_CONNECTOID, szConn, ARRAYSIZE(szConn));

                    // Check to see if this connection matches
                    if (0 == lstrcmpi(szConn, pszConn))
                        {
                        fFound = TRUE;
                        }
                    }
                }
            SafeRelease(pAcct);
            }
        SafeRelease(pEnum);
        }

    return (fFound);
    }


HRESULT CConnectionManager::ConnectActual(LPTSTR pszRasConn, HWND hwndParent, BOOL fShowUI)
{
    HRESULT hr;

    StrCpyN(m_szConnectName, pszRasConn, ARRAYSIZE(m_szConnectName));

    // RefreshConnInfo
    CHECKHR(hr = RefreshConnInfo());
    
    // Make sure the RAS DLL is loaded before we try this
    if (FAILED(VerifyRasLoaded()))    
    {
        hr = HR_E_UNINITIALIZED;
        goto exit;
    }
    
    // Check to see if we even can connect
    hr = CanConnectActual(pszRasConn);
        
    // If we can connect using the current connection, return success
    if (S_OK == hr)
    {
        m_rConnInfo.fConnected = TRUE;
        hr = S_OK;
        goto exit;
    }

    // There is another connection already established ask the user if they 
    // want to change.
    if (!m_fDialerUI)
    {
        m_fDialerUI = TRUE;

        if (E_FAIL == hr)
        {        
            UINT        uAnswer;

            uAnswer = idrgUseCurrent;

            // Check to see if this a voodoo Connection Manager autodialer thing
            if (!ConnectionManagerVoodoo(pszRasConn))
            {
                if (fShowUI)
                    uAnswer = PromptCloseConnection(hwndParent);
        
                // The user canceled from the dialog.  Therefore we give up.
                if (IDCANCEL == uAnswer || IDNO == uAnswer)
                {
                    hr = hrUserCancel;
                    goto exit;
                }
        
                // The user said they wanted to hang up and dial a new connection.
                else if (idrgDialNew == uAnswer || IDYES == uAnswer)
                {
                    Disconnect(hwndParent, fShowUI, TRUE, FALSE);
                }
        
                // The user said to try to use the current connection.
                else if (idrgUseCurrent == uAnswer)    
                {
                    // Who are we to tell the user what to do...

                    //Save the conn info so we can return true for this connection in CanConnectActual
                    AddToConnList(pszRasConn);

                    // Send a connect notification since we are getting connected and then return
                    hr = S_OK;
                    goto NotifyAndExit;
                }
            }
        }
        else
        {
            //I don't see any reason as to why this is there.
            // If we started RAS, then we can close it on a whim.
            Disconnect(hwndParent, fShowUI, FALSE, FALSE);
        }

        // Only one caller can be dialing the phone at a time.
        if (WAIT_TIMEOUT == WaitForSingleObject(m_hMutexDial, 0))
        {
            hr  = HR_E_DIALING_INPROGRESS;
            goto exit;
        }

        if (S_FALSE == (hr = DoAutoDial(hwndParent, pszRasConn, TRUE)))
        {
            DWORD   dwReturn;
            DWORD   dwLanFlags = 0;
            DWORD   dwDialFlags = 0;

            dwDialFlags = INTERNET_AUTODIAL_FORCE_ONLINE;

            if (VerifyMobilityPackLoaded() == S_OK)
            {
                if (!IsNetworkAlive(&dwLanFlags) || (!(dwLanFlags & NETWORK_ALIVE_LAN)))
                    dwDialFlags |= INTERNET_DIAL_SHOW_OFFLINE;
            }

            dwReturn = InternetDialA(hwndParent, pszRasConn, dwDialFlags,
                                        &m_dwConnId, 0);
            /*
            // Dial the new connection
            if (SUCCEEDED(hr = StartRasDial(hwndParent, pszRasConn)))
            */
            if (dwReturn == 0)
            {
                m_rConnInfo.fConnected = TRUE;
                m_rConnInfo.fIStartedRas = TRUE;
                m_rConnInfo.fAutoDial = FALSE;
                m_rConnInfo.hRasConn = (HRASCONN)m_dwConnId;
                StrCpyN(m_rConnInfo.szCurrentConnectionName, pszRasConn, ARRAYSIZE(m_rConnInfo.szCurrentConnectionName));
                hr = S_OK;
            }
            else
            {
                if (dwReturn == ERROR_USER_DISCONNECTION)
                {
                    hr = HR_E_USER_CANCEL_CONNECT;
                    if (!!(dwDialFlags & INTERNET_DIAL_SHOW_OFFLINE))
                        SetGlobalOffline(TRUE);
                }
                else
                {
                    DebugTrace("Error dialing: %d\n", GetLastError());
                    hr = E_FAIL;
                }
            }
        }

        ReleaseMutex(m_hMutexDial);

NotifyAndExit:
        // Send the advise after we leave the critsec to make sure we don't deadlock
        if (hr == S_OK)
        {
            SendAdvise(CONNNOTIFY_CONNECTED, NULL);
        }
exit:
        m_fDialerUI = FALSE;
    }

    return (hr);
}

HRESULT CConnectionManager::CanConnectActual(LPTSTR pszRasConn)
{
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
    BOOL        fFound = 0;
    HRESULT     hr = E_FAIL;
    TCHAR       pszCurConn[CCHMAX_CONNECTOID];
    DWORD       dwFlags;    
    
    //Look in our Conection list first
    hr = SearchConnList(pszRasConn);
    if (hr == S_OK)
        return hr;
    
    // Make sure the RAS DLL is loaded before we try this
    if (FAILED(VerifyRasLoaded()))    
    {
        hr = HR_E_UNINITIALIZED;
        goto exit;
    }


    // Find out what we're currently connected to
    if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)))
    {
        // If no connections exist, then just exit
        if (0 == cConnections)
        {
            SafeMemFree(pConnections);
            hr = S_FALSE;
            goto exit;
        }
        
        // Walk through the existing connections and see if we can find the
        // one we're looking for.
        for (ULONG i = 0; i < cConnections; i++)
        {
            if (0 == lstrcmpi(pszRasConn, pConnections[i].szEntryName))
            {
                // Found it.  Return success.
                fFound = TRUE;
                break;
            }
        }
        
        // Free the list of connections returned from the enumerator
        SafeMemFree(pConnections);
        
        hr = (fFound ? S_OK : E_FAIL);
        goto exit;
    }
        
exit:

        if ((hr != S_OK) && (m_fDialerUI))
            hr = HR_E_DIALING_INPROGRESS;

    return (hr);    
}


INT_PTR CALLBACK CConnectionManager::RasStartupDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    // Locals
    CConnectionManager *pThis = (CConnectionManager *) GetWndThisPtr(hwnd);
    TCHAR  szConn[CCHMAX_CONNECTOID];
    DWORD  dwOpt = OPT_DIALUP_LAST_START;
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            pThis = (CConnectionManager *)lParam;
            if (!pThis)
                {
                Assert (FALSE);
                EndDialog(hwnd, E_FAIL);
                return 1;
                }

            // Save this pointer
            SetWndThisPtr (hwnd, pThis);

            // Fill in the combo box
            pThis->FillRasCombo(GetDlgItem(hwnd, idcDialupCombo), TRUE);

            // If there are no RAS connections, then don't show the dialog
            if (ComboBox_GetCount(GetDlgItem(hwnd, idcDialupCombo)) <= 1)
                {
                EndDialog(hwnd, 0);
                return (TRUE);
                }

            // If the reason that we're in this dialog is because the user usually autodial's 
            // on startup but is now offline, then we should display the normal autodial 
            // connectoid
            if (START_CONNECT == DwGetOption(OPT_DIALUP_START))
                dwOpt = OPT_DIALUP_CONNECTION;

            // Initialize the combo box to the last connection
            *szConn = 0;
            GetOption(dwOpt, szConn, ARRAYSIZE(szConn));
            if (0 != *szConn)
                {
                // If we can't find it any longer, then according to the spec, we're
                // supposed to default to the "Ask me" option
                if (CB_ERR == ComboBox_SelectString(GetDlgItem(hwnd, idcDialupCombo), -1, szConn))
                    {
                    ComboBox_SetCurSel(GetDlgItem(hwnd, idcDialupCombo), 0);
                    }
                }
            else
                ComboBox_SetCurSel(GetDlgItem(hwnd, idcDialupCombo), 0);
            
            CenterDialog(hwnd);
            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    // Get the connection name from the combo box
                    ComboBox_GetText(GetDlgItem(hwnd, idcDialupCombo), szConn, ARRAYSIZE(szConn));
                    
                    // Check to see if it's the "Don't dial..." string
                    TCHAR szRes[CCHMAX_STRINGRES];
                    AthLoadString(idsConnNoDial, szRes, ARRAYSIZE(szRes));

                    if (0 == lstrcmp(szRes, szConn))
                        {
                        // It's the don't dial string, so clear the history in the registry
                        SetOption(OPT_DIALUP_LAST_START, _T(""), sizeof(TCHAR), NULL, 0);

                        // See if the user checked the "Set as default..."
                        if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, idcDefaultCheck)))
                            {
                            // If don't dial is set as default, we clear the startup prompt option
                            SetDwOption(OPT_DIALUP_START, START_NO_CONNECT, NULL, 0);
                            }
                        }
                    else
                        {
                        // Save this connection in the history
                        SetOption(OPT_DIALUP_LAST_START, szConn, lstrlen(szConn) + 1, NULL, 0);
                        if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, idcDefaultCheck)))
                            {
                            // If the user want's this as default, then we change the startup
                            // option to auto connect to this connection.
                            SetDwOption(OPT_DIALUP_START, START_CONNECT, NULL, 0);
                            SetOption(OPT_DIALUP_CONNECTION, szConn, lstrlen(szConn) + 1, NULL, 0);
                            }

                        // Dial the phone
                        pThis->ConnectActual(szConn, hwnd, FALSE);
                        }

                    EndDialog(hwnd, 0);
                    return (TRUE);

                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    return (TRUE);
                }
            break;
            
        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0);
            return (TRUE);
        }

    return (FALSE);
    }


//-------------------------------------------------------------------------------------------
// Function:  FIsPlatformWinNT() - checks if we are running on NT or Win95
//-------------------------------------------------------------------------------------------
BOOL FIsPlatformWinNT()
{
    return (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
}


HRESULT CConnectionManager::RefreshConnInfo(BOOL fSendAdvise)
{
    // Locals
    HRESULT     hr=S_OK;
    LPRASCONN   pConnections=NULL;
    ULONG       cConnections=0;
    BOOL        fFound=FALSE;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Refresh needed
    if (CIS_REFRESH != m_rConnInfo.state)
        goto exit;

    // Set this here to prevent an infinite loop and thus a stack fault.
    m_rConnInfo.state = CIS_CLEAN;

    // Make sure the RAS DLL is loaded before we try this
    CHECKHR(hr = VerifyRasLoaded());

    // Find out what we're currently connected to
    CHECKHR(hr = EnumerateConnections(&pConnections, &cConnections));

    // Walk through the existing connections and see if we can find the
    // one we're looking for.
    for (i = 0; i < cConnections; i++)
    {
//        if (m_rConnInfo.hRasConn == pConnections[i].hrasconn)
        //To get around a problem in ConnectActual when we dial using InternetDial
          if (lstrcmp(m_rConnInfo.szCurrentConnectionName, pConnections[i].szEntryName) == 0)
            {
            // Found it.  Return success.
            fFound = TRUE;
            m_rConnInfo.fConnected = TRUE;
            m_rConnInfo.fIStartedRas = TRUE;
            m_rConnInfo.hRasConn = pConnections[0].hrasconn;
            m_dwConnId = (DWORD_PTR) m_rConnInfo.hRasConn;

            break;
            }
    }

    // If we didn't find our connection
    if (!fFound)
    {
        // The user hung up.  We need to put ourselves in a disconnected
        // state.
        if (cConnections == 0)
        {
            Disconnect(NULL, FALSE, TRUE, FALSE);
        }
        else
        {
            StrCpyN(m_rConnInfo.szCurrentConnectionName, pConnections[0].szEntryName, ARRAYSIZE(m_rConnInfo.szCurrentConnectionName));
            m_rConnInfo.fConnected = TRUE;
            m_rConnInfo.fIStartedRas = FALSE;
            m_rConnInfo.hRasConn = pConnections[0].hrasconn;
            m_dwConnId = (DWORD_PTR) m_rConnInfo.hRasConn;

            if (fSendAdvise)
                SendAdvise(CONNNOTIFY_CONNECTED, NULL);
        }            
    }
   
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Free the list of connections returned from the enumerator
    SafeMemFree(pConnections);

    // Done
    return hr;
}



//
//  FUNCTION:   CConnectionManager::IsGlobalOffline()
//
//  PURPOSE:    Checks the state of the WININET global offline setting.  
//              Note - this is copied from shdocvw
//
//  PARAMETERS: 
//      void
//
//  RETURN VALUE:
//      BOOL 
//
BOOL CConnectionManager::IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
                             &dwSize))
    {
        if (dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }
    
    return (fRet);
}


//
//  FUNCTION:   CConnectionManager::SetGlobalOffline()
//
//  PURPOSE:    Sets the global offline state for Athena and IE.  Note - this
//              function is copied from shdocvw.
//
//  PARAMETERS: 
//      <in> fOffline - TRUE to disconnect, FALSE to allow connections.
//
//  RETURN VALUE:
//      void 
//
void CConnectionManager::SetGlobalOffline(BOOL fOffline, HWND hwndParent)
{
    DWORD dwReturn;

    if (fOffline)
    {
        if (hwndParent)
        {
            //Offer to hangup
            RefreshConnInfo(FALSE);
            if (m_rConnInfo.hRasConn)
            {
                dwReturn = AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), 
                                         MAKEINTRESOURCEW(idsWorkOfflineHangup), 0, 
                                         MB_YESNOCANCEL);

                if (dwReturn == IDCANCEL)
                    return;

                if (dwReturn == IDYES)
                {
                    Disconnect(hwndParent, FALSE, TRUE, FALSE);
                }
            }
        }
    }
    
    SetShellOfflineState(fOffline);

    m_fOffline = fOffline;

    if (!m_fOffline)
        DoOfflineTransactions();

    SendAdvise(CONNNOTIFY_WORKOFFLINE, (LPVOID) IntToPtr(fOffline));
}


typedef BOOL (WINAPI *PFNINETDIALHANDLER)(HWND,LPCSTR, DWORD, LPDWORD);

HRESULT CConnectionManager::DoAutoDial(HWND hwndParent, LPTSTR pszConnectoid, BOOL fDial)
    {
    TCHAR   szAutodialDllName[MAX_PATH];
    TCHAR   szAutodialFcnName[MAX_PATH];
    HRESULT hr = S_FALSE;
    UINT    uError;
    HINSTANCE hInstDialer = 0;
    PFNINETDIALHANDLER pfnDialHandler = NULL;
    DWORD   dwRasError = 0;
    BOOL    f = 0;
    TCHAR   szRegPath[MAX_PATH];
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
    DWORD   dwDialFlags = fDial ? INTERNET_CUSTOMDIAL_CONNECT : INTERNET_CUSTOMDIAL_DISCONNECT;


    // Check to see if this connectoid has the autodial values
    if (FAILED(LookupAutoDialHandler(pszConnectoid, szAutodialDllName, szAutodialFcnName)))
        goto exit;

    // If we were able to load those two values, then we're going to let the 
    // autodialer take care of dialing the phone.
    uError = SetErrorMode(SEM_NOOPENFILEERRORBOX);

    // Try to load the library that contains the autodialer
    hInstDialer = LoadLibrary(szAutodialDllName);
    SetErrorMode(uError);

    if (!hInstDialer)
        {
        goto exit;
        }

    // Try to load the function address
    pfnDialHandler = (PFNINETDIALHANDLER) GetProcAddress(hInstDialer, 
                                                         szAutodialFcnName);
    if (!pfnDialHandler)
        goto exit;

    // Call the dialer
    f = (*pfnDialHandler)(hwndParent, pszConnectoid, dwDialFlags, 
                          &dwRasError);

    hr = f ? S_OK : E_FAIL;
    m_rConnInfo.fConnected = fDial && f;
    m_rConnInfo.fIStartedRas = TRUE;
    m_rConnInfo.fAutoDial = TRUE;

    if (f && fDial)
        {
        // Need to get the current connection handle
        if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)))
            {
            for (UINT i = 0; i < cConnections; i++)
                {
                if (0 == lstrcmpi(pConnections[i].szEntryName, pszConnectoid))
                    {
                    EnterCriticalSection(&m_cs);
                    m_rConnInfo.hRasConn = pConnections[i].hrasconn;
                    m_rConnInfo.state = CIS_REFRESH;    // new connection, must refresh conn info
                    LeaveCriticalSection(&m_cs);
                    break;
                    }
                }

            SafeMemFree(pConnections);
            }
        }

exit:
    if (hInstDialer)
        FreeLibrary(hInstDialer);

    return (hr);
    }


HRESULT CConnectionManager::LookupAutoDialHandler(LPTSTR pszConnectoid, LPTSTR pszAutodialDllName,
                                                  LPTSTR pszAutodialFcnName)
    {
    HRESULT     hr = E_FAIL;
    DWORD       dwEntryInfoSize = 0;
    LPRASENTRY  pRasEntry = NULL;

    *pszAutodialDllName = 0;
    *pszAutodialFcnName = 0;

    if (m_pRasGetEntryProperties)
    {
        // Find out how big the struct we need to pass in should be
        RasGetEntryProperties(NULL, pszConnectoid, NULL, &dwEntryInfoSize, NULL, NULL);
        if (dwEntryInfoSize)
        {
            // Allocate a buffer big enough for this structure
            if (!MemAlloc((LPVOID*) &pRasEntry, dwEntryInfoSize))
                return (E_OUTOFMEMORY);

            // Request the RASENTRY properties
            pRasEntry->dwSize = sizeof(RASENTRY);
            if (0 != RasGetEntryProperties(NULL, pszConnectoid, pRasEntry, &dwEntryInfoSize, NULL, NULL))
                goto exit;

            // Copy the autodial info to the provided buffers
            if (pRasEntry->szAutodialDll[0])
                StrCpyN(pszAutodialDllName, pRasEntry->szAutodialDll, MAX_PATH);

            if (pRasEntry->szAutodialFunc[0])
                StrCpyN(pszAutodialFcnName, pRasEntry->szAutodialFunc, MAX_PATH);

            // If we got here, we have all the data we need
            if (*pszAutodialDllName && *pszAutodialFcnName)
                hr = S_OK;
        }
    }
exit:
    SafeMemFree(pRasEntry);
    return (hr);
    }


// If the current connection is a CM connection, and the target connection is
// a CM connection, then we let the CM do whatever it is that they do.
BOOL CConnectionManager::ConnectionManagerVoodoo(LPTSTR pszConnection)
    {
    TCHAR   szAutodialDllName[MAX_PATH];
    TCHAR   szAutodialFcnName[MAX_PATH];

    // Check to see if the target is a CM connectoid
    if (FAILED(LookupAutoDialHandler(pszConnection, szAutodialDllName, szAutodialFcnName)))
        return (FALSE);

    // Find out if the current connection is a CM connectoid
    if (FAILED(LookupAutoDialHandler(m_rConnInfo.szCurrentConnectionName, szAutodialDllName, 
                                     szAutodialFcnName)))
        return (FALSE);

    return (TRUE);
    }

HRESULT CConnectionManager::OEIsDestinationReachable(IImnAccount *pAccount, DWORD dwConnType)
{
    char        szServerName[256];
    HRESULT     hr = S_FALSE;

    /*
    if ((VerifyMobilityPackLoaded() == S_OK) &&
        (GetServerName(pAccount, szServerName, ARRAYSIZE(szServerName)) == S_OK))
    {
        if (IsDestinationReachable(szServerName, NULL) &&
            (GetLastError() == 0))
        {
            hr = S_OK;
        }
    }
    else
    {
    */
	DWORD dw;
	if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
	{
		if(HideHotmail())
			return(hr);
	}
	

        hr = IsInternetReachable(pAccount, dwConnType);
    /*
    }
    */
    return hr;
}

HRESULT CConnectionManager::IsInternetReachable(IImnAccount *pAccount, DWORD dwConnType)
{

    TCHAR    szConnectionName[CCHMAX_CONNECTOID];
    HRESULT  hr = S_FALSE;
    DWORD    dwFlags;

    switch (dwConnType)
    {
        case CONNECTION_TYPE_RAS:
        {
            if (FAILED(hr = pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnectionName, ARRAYSIZE(szConnectionName))))
            {
                AssertSz(FALSE, _T("CConnectionManager::Connect() - No connection name."));
                break;
            }

            hr = CanConnectActual(szConnectionName);
            break;
        }

        case CONNECTION_TYPE_LAN:
        {
             if (VerifyMobilityPackLoaded() == S_OK)
             {
                if (IsNetworkAlive(&dwFlags) && (!!(dwFlags & NETWORK_ALIVE_LAN)))
                {
                     hr = S_OK;
                }
             }
             else
             {
                  //If Mobility pack is not loaded we can't figure out if lan indeed present, so like
                 //everywhere else we just assume that lan is present
                 hr = S_OK;
             }
             break;
        }

        case CONNECTION_TYPE_INETSETTINGS:
        default:
        {
            if (InternetGetConnectedStateExA(&dwFlags, szConnectionName, ARRAYSIZE(szConnectionName), 0))
                hr = S_OK;

            break;
        }
    }

    return hr;
}

HRESULT CConnectionManager::GetServerName(IImnAccount *pAcct, LPSTR  pServerName, DWORD size)
{
    HRESULT     hr = E_FAIL;
    DWORD       dwSrvrType;
    ACCTTYPE    accttype;

    //This function will be called only for LAN accounts to avoid confusion with POP accounts having two servers
    // an incoming and an outgoing.
    if (SUCCEEDED(pAcct->GetAccountType(&accttype)))
    {
        switch (accttype)
        {
            case ACCT_MAIL:
                dwSrvrType = AP_IMAP_SERVER;
                break;

            case ACCT_NEWS:
                dwSrvrType = AP_NNTP_SERVER;
                break;

            case ACCT_DIR_SERV:
                dwSrvrType = AP_LDAP_SERVER;
                break;

            default:
                Assert(FALSE);
                goto exit;
        }

        if ((hr = pAcct->GetPropSz(dwSrvrType, pServerName, size)) != S_OK)
        {
            //If the account type is MAIL, we try to get the name of POP server
            //For POP accounts we just try to ping the POP3 server as in most of the cases
            //POP server and SMTP servers are the same. Even if they are not, we assume that if 
            //one is reachable the connection is dialed and ISPs network is reachable and hence the other 
            //server is reachable too.
            if (accttype == ACCT_MAIL)
            {
                hr = pAcct->GetPropSz(AP_POP3_SERVER, pServerName, size);
                
                // look for an httpmail server
                if (FAILED(hr))
                    hr = pAcct->GetPropSz(AP_HTTPMAIL_SERVER, pServerName, size);
            }
        }
    }

exit:
    return hr;
}

BOOLEAN CConnectionManager::IsSameDestination(LPSTR  pszConnectionName, LPSTR pszServerName)
{
    //We need to find an account with pszConnectionName as the connectoid and pszServerName
    //Return TRUE if we find one FALSE otherwise
    IImnAccount     *pAcct;
    BOOLEAN         fret = FALSE;

    if (g_pAcctMan && (g_pAcctMan->FindAccount(AP_RAS_CONNECTOID, pszConnectionName, &pAcct) == S_OK))
    {
        //Now check if its server name is what we want.
        //Althoug findAccount finds first account that satisfies the searchdata, this should work fine for a 
        //typical OE user. Even if there are two accounts with same connectoids and different servers and if 
        //we miss to find the one we want,at the most we will be putting up a connect dialog.

        char    myServerName[MAX_PATH];
        if (SUCCEEDED(GetServerName(pAcct, myServerName, sizeof(myServerName))))
        {
            if (lstrcmp(myServerName, pszServerName) == 0)
            {
                fret = TRUE;
            }
        }
    }

    return fret;
}


HRESULT  CConnectionManager::VerifyMobilityPackLoaded()
{
    HRESULT     hr  = REGDB_E_CLASSNOTREG; 
    uCLSSPEC    classpec; 

    if (!m_fMobilityPackFailed)
    {
        HWND    hwnd;
        if (!m_hInstSensDll)
        {
            // figure out struct and flags 
            classpec.tyspec = TYSPEC_CLSID; 
            classpec.tagged_union.clsid = CLSID_MobilityFeature; 
    
            // call jit code 
            if (!g_pBrowser)
            {
                goto exit;
            }
            IOleWindow  *pOleWnd;
            if (FAILED(g_pBrowser->QueryInterface(IID_IAthenaBrowser, (LPVOID*)&pOleWnd)))
            {
                goto exit;
            }
            pOleWnd->GetWindow(&hwnd);

            hr = FaultInIEFeature(hwnd, &classpec, NULL, FIEF_FLAG_PEEK); 
            pOleWnd->Release();

            if(S_OK == hr) 
            { 
                // Mobile pack is installed 
                m_hInstSensDll = LoadLibrary(szSensApiDll);
                if (m_hInstSensDll)
                {
                    m_pIsDestinationReachable = (ISDESTINATIONREACHABLE)GetProcAddress(m_hInstSensDll, szIsDestinationReachable);
                    m_pIsNetworkAlive         = (ISNETWORKALIVE)GetProcAddress(m_hInstSensDll, szIsNetworkAlive);
                }

                if (!m_hInstSensDll || !m_pIsDestinationReachable || !m_pIsNetworkAlive)
                {
                    m_fMobilityPackFailed = TRUE;
                }
                else
                {
                    m_fMobilityPackFailed = FALSE;
                    hr = S_OK;
                }
            } 
        }
        else
            hr = S_OK;
    }
    return hr;
exit:
    m_fMobilityPackFailed = TRUE;
    return hr;
}


void CConnectionManager::DoOfflineTransactions()
{
    char szId[CCHMAX_ACCOUNT_NAME];
    IImnEnumAccounts *pEnum;
    HRESULT hr;
    FOLDERID id, *pid;
    ULONG iAcct, cAcct;
    IImnAccount *pAccount;
    DWORD dwConnection;
    HWND hwnd;
    DWORD cRecords;

    pid = NULL;
    iAcct = 0;

    // If this is getting hit through a news article URL, we won't have a browser and
    // should not play back.
    if (!g_pBrowser || !g_pSync)
        return;

    // Get Record Count
    g_pSync->GetRecordCount(&cRecords);

    // sbailey: perf. fix. - prevent doing that expensive stuff below if there are no transactions.
    if (0 == cRecords)
        return;

    hr = g_pAcctMan->Enumerate(SRV_NNTP | SRV_IMAP | SRV_HTTPMAIL, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->GetCount(&cAcct);
        if (SUCCEEDED(hr) &&
            cAcct > 0 &&
            MemAlloc((void **)&pid, cAcct * sizeof(FOLDERID)))
        {
            while (SUCCEEDED(pEnum->GetNext(&pAccount)))
            {
                hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection);
                if (SUCCEEDED(hr))
                {
                    hr = OEIsDestinationReachable(pAccount, dwConnection);
                    if (hr == S_OK)
                    {
                        hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szId, ARRAYSIZE(szId));
                        if (SUCCEEDED(hr))
                        {
                            hr = g_pStore->FindServerId(szId, &id);
                            if (SUCCEEDED(hr))
                            {
                                pid[iAcct] = id;
                                iAcct++;
                            }
                        }
                    }
                }

                pAccount->Release();
            }
        }

        pEnum->Release();
    }

    if (iAcct > 0)
    {
        g_pBrowser->GetWindow(&hwnd);
        g_pBrowser->GetCurrentFolder(&id);
        g_pSync->DoPlayback(hwnd, pid, iAcct, id);
    }

    if (pid != NULL)
        MemFree(pid);
}

HRESULT     CConnectionManager::ConnectUsingIESettings(HWND     hwndParent, BOOL fShowUI)
{
    TCHAR           lpConnection[CCHMAX_CONNECTOID];
    DWORD           dwFlags = 0;
    DWORD           dwReturn;
    HRESULT         hr = E_FAIL;

    if (InternetGetConnectedStateExA(&dwFlags, lpConnection, ARRAYSIZE(lpConnection), 0))
    {
        m_fTryAgain = FALSE;
        return S_OK;
    }

    // Only one caller can be dialing the phone at a time.
    if (WAIT_TIMEOUT == WaitForSingleObject(m_hMutexDial, 0))
    {
        return (HR_E_DIALING_INPROGRESS);
    }

    if (!!(dwFlags & INTERNET_CONNECTION_MODEM) && (*lpConnection))
    {
        if (!m_fDialerUI)
        {
            m_fDialerUI = TRUE;
            //A DEF CONNECTOID IS SET. Dial that one
            if (IsGlobalOffline())
            {
                if (fShowUI)
                {
                    if (IDNO == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                              0, MB_YESNO | MB_ICONEXCLAMATION ))
                    {
                        hr = HR_E_OFFLINE;
                        goto DialExit;
                    }
                    else
                        g_pConMan->SetGlobalOffline(FALSE);
                }
                else
                {
                    hr = HR_E_OFFLINE;
                    //m_fDialerUI = FALSE;
                    goto DialExit;
                }
            }

            if ((hr = PromptCloseConnection(lpConnection, fShowUI, hwndParent)) != S_FALSE)
                goto DialExit;

            {
                DWORD           dwDialFlags = 0;
                DWORD           dwLanFlags = 0;

                dwDialFlags = INTERNET_AUTODIAL_FORCE_ONLINE;

                if (VerifyMobilityPackLoaded() == S_OK)
                {
                    if (!IsNetworkAlive(&dwLanFlags) || (!(dwLanFlags & NETWORK_ALIVE_LAN)))
                        dwDialFlags |= INTERNET_DIAL_SHOW_OFFLINE;
                }

                dwReturn = InternetDialA(hwndParent, lpConnection, dwDialFlags,
                                    &m_dwConnId, 0);
                if (dwReturn == 0)
                {
                    m_rConnInfo.fConnected = TRUE;
                    m_rConnInfo.fIStartedRas = TRUE;
                    m_rConnInfo.fAutoDial = FALSE;
                    m_rConnInfo.hRasConn = (HRASCONN)m_dwConnId;
                    StrCpyN(m_rConnInfo.szCurrentConnectionName, lpConnection, ARRAYSIZE(m_rConnInfo.szCurrentConnectionName));
                    SendAdvise(CONNNOTIFY_CONNECTED, NULL);
                    hr = S_OK;
                }
                else
                {
                    if (dwReturn == ERROR_USER_DISCONNECTION)
                    {
                        hr = HR_E_USER_CANCEL_CONNECT;
                        if (!!(dwDialFlags & INTERNET_DIAL_SHOW_OFFLINE))
                        {
                            SetGlobalOffline(TRUE);
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                        DebugTrace("Error dialing: %d\n", GetLastError());
                    }
                }
            }
DialExit:
            m_fDialerUI = FALSE;
        }
        else
        {
            hr = HR_E_USER_CANCEL_CONNECT;
        }
    }
    else
    {
        if (!m_fTryAgain)
        {
            int err = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddOfferOffline), hwndParent, 
                                      OfferOfflineDlgProc, (LPARAM)this); 
            
            if (err == -1)
            {
                DWORD   dwerr = GetLastError();
                hr = S_OK;
            }
            if (!IsGlobalOffline())
                hr = S_OK;
            else
                hr = HR_E_OFFLINE;
        }
        else
            hr = S_OK;
    }
    
    ReleaseMutex(m_hMutexDial);

    return hr;
}


void CConnectionManager::SetTryAgain(BOOL   bval)
{
    m_fTryAgain = bval;
}

INT_PTR   CALLBACK  CConnectionManager::OfferOfflineDlgProc(HWND   hwnd, UINT  uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    retval = 1;
    CConnectionManager      *pThis = (CConnectionManager*)GetWndThisPtr(hwnd);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            // Get lparam
            pThis = (CConnectionManager *)lParam;
            if (!pThis)
            {
                Assert (FALSE);
                EndDialog(hwnd, E_FAIL);
                goto exit;
            }
        
            // Save this pointer
            SetWndThisPtr (hwnd, pThis);
            break;
        }

        case WM_COMMAND:
        {
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDWorkOffline:
                pThis->SetGlobalOffline(TRUE, NULL);
            break;

            case IDTryAgain:
                pThis->SetGlobalOffline(FALSE);
                pThis->SetTryAgain(TRUE);
            break;
            }
            EndDialog(hwnd, S_OK);
            break;
        }

        case WM_CLOSE:
            pThis->SetGlobalOffline(TRUE, NULL);
            EndDialog(hwnd, S_OK);
            break;

        case WM_DESTROY:
            SetWndThisPtr(hwnd, NULL);
            break;

        default:
            retval = 0;
            break;
    }

exit:
    return retval;
}

HRESULT CConnectionManager::PromptCloseConnection(LPTSTR    pszRasConn, BOOL fShowUI, HWND hwndParent)
{
    HRESULT     hr = S_FALSE;
    UINT        uAnswer;
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
        
    uAnswer = idrgDialNew;

    // Make sure the RAS DLL is loaded before we try this
    if (FAILED(VerifyRasLoaded()))    
        {
        hr = HR_E_UNINITIALIZED;
        goto exit;
        }

    StrCpyN(m_szConnectName, pszRasConn, ARRAYSIZE(m_szConnectName));

    // RefreshConnInfo
    CHECKHR(hr = RefreshConnInfo());

    if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)) && (cConnections > 0))
    {
    
        if (fShowUI)
            uAnswer = PromptCloseConnection(hwndParent);

        // The user canceled from the dialog.  Therefore we give up.
        if (IDCANCEL == uAnswer || IDNO == uAnswer)
        {
            hr = HR_E_USER_CANCEL_CONNECT;
            goto exit;
        }

        // The user said they wanted to hang up and dial a new connection.
        else if (idrgDialNew == uAnswer || IDYES == uAnswer)
        {
            Disconnect(hwndParent, fShowUI, TRUE, FALSE);
            hr = S_FALSE;
            goto exit;
        }

        // The user said to try to use the current connection.
        else if (idrgUseCurrent == uAnswer)    
        {
            //Save the conn info so we can return true for this connection in CanConnectActual
            AddToConnList(pszRasConn);

            hr = S_OK;
            SendAdvise(CONNNOTIFY_CONNECTED, NULL);
            goto exit;
        }
    }
    else
    {
        Disconnect(NULL, FALSE, TRUE, FALSE);
        hr = S_FALSE;
    }
exit:
    SafeMemFree(pConnections);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\conman.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     conman.h
//
//  PURPOSE:    Defines the CConnectionManager object for Athena.
//
                                                    
#ifndef __CONMAN_H__
#define __CONMAN_H__

#ifndef WIN16   // No RAS support in Win16

#include <ras.h>
#include <raserror.h>
#include <rasdlg.h>
#include <sensapi.h>

#include "imnact.h"

// Forward Reference
class CConnectionManager;

typedef enum {
    CONNNOTIFY_CONNECTED = 0,
    CONNNOTIFY_DISCONNECTING,           // pvData is the name of the connection comming down
    CONNNOTIFY_DISCONNECTED,
    CONNNOTIFY_RASACCOUNTSCHANGED,
    CONNNOTIFY_WORKOFFLINE,
    CONNNOTIFY_USER_CANCELLED
} CONNNOTIFY;

typedef enum CONNINFOSTATE {
    CIS_REFRESH,
    CIS_CLEAN
} CONNINFOSTATE;

typedef struct CONNINFO {
    CONNINFOSTATE       state;
    HRASCONN            hRasConn;
    TCHAR               szCurrentConnectionName[RAS_MaxEntryName + 1];
    BOOL                fConnected;
    BOOL                fIStartedRas;
    BOOL                fAutoDial;
} CONNINFO, *LPCONNINFO;

typedef struct TagConnListNode
{
    TagConnListNode  *pNext;
    TCHAR            pszRasConn[RAS_MaxEntryName + 1];
}ConnListNode;

// This interface is implemented by clients of the connection manager that 
// care when a new RAS connection is established or an existing connection
// is destroyed.
DECLARE_INTERFACE_(IConnectionNotify, IUnknown)
    {
    // *** IUnknown Methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IConnectionNotify ***

    // OnConnectionNotify
    //
    // <in> nCode   - Tells the function which event happened
    // <in> pvData  - Pointer to extra data for the notification
    // <in> pConMan - Pointer to the CConnectionManager object that sent the
    //                notification.  The recipient can use this to find out
    //                if they can connect to a server based on the new state
    //                of the RAS connection.
    STDMETHOD(OnConnectionNotify) (THIS_ 
                                   CONNNOTIFY nCode, 
                                   LPVOID pvData, 
                                   CConnectionManager *pConMan) PURE;
    };


/////////////////////////////////////////////////////////////////////////////
// API Typedefs
// 
typedef DWORD (APIENTRY *RASDIALPROC)(LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN);
typedef DWORD (APIENTRY *RASENUMCONNECTIONSPROC)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASENUMENTRIESPROC)(LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASGETCONNECTSTATUSPROC)(HRASCONN, LPRASCONNSTATUS);
typedef DWORD (APIENTRY *RASGETERRORSTRINGPROC)(UINT, LPTSTR, DWORD);
typedef DWORD (APIENTRY *RASHANGUPPROC)(HRASCONN);
typedef DWORD (APIENTRY *RASSETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL);
typedef DWORD (APIENTRY *RASGETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL*);
typedef DWORD (APIENTRY *RASEDITPHONEBOOKENTRYPROC)(HWND, LPTSTR, LPTSTR);                                                    
typedef BOOL  (APIENTRY *RASDIALDLGPROC)(LPSTR, LPSTR, LPSTR, LPRASDIALDLG);
typedef BOOL  (APIENTRY *RASENTRYDLGPROC)(LPSTR, LPSTR, LPRASENTRYDLG);
typedef DWORD (APIENTRY *RASGETENTRYPROPERTIES)(LPTSTR, LPTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD);


//Mobility Pack
typedef BOOLEAN (APIENTRY *ISDESTINATIONREACHABLE)(LPCSTR  lpwstrDestination, LPQOCINFO lpqocinfo);
typedef BOOLEAN (APIENTRY *ISNETWORKALIVE)(LPDWORD  lpdwflags);

#define CONNECTION_RAS          0x00000001
#define CONNECTION_LAN          0x00000002
#define CONNECTION_MANUAL       0x00000004
#define MAX_RAS_ERROR           256
#define NOTIFY_PROP             _T("NotifyInfoProp")
#define NOTIFY_HWND             _T("ConnectionNotify")

// This is the name of our mutex that we use to make sure just one 
// instance of this object ever get's created.
const TCHAR c_szConManMutex[] = _T("ConnectionManager");

typedef struct tagNOTIFYHWND
    {
    DWORD               dwThreadId;
    HWND                hwnd;
    struct tagNOTIFYHWND  *pNext;
    } NOTIFYHWND;

typedef struct tagNOTIFYLIST 
    {
    IConnectionNotify  *pNotify;
    struct tagNOTIFYLIST  *pNext;
    } NOTIFYLIST;


class CConnectionManager : public IImnAdviseAccount
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, Destructor
    // 
    CConnectionManager();
    ~CConnectionManager();
    
    /////////////////////////////////////////////////////////////////////////
    // Initialization
    //
    HRESULT HrInit(IImnAccountManager *pAcctMan);
    
    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);
    
    /////////////////////////////////////////////////////////////////////////
    // IImnAdviseAccount
    //
    HRESULT STDMETHODCALLTYPE AdviseAccount(DWORD dwAdviseType, 
                                            ACTX *pactx);
    
    /////////////////////////////////////////////////////////////////////////
    // Connection APIs
    
    // CanConnect
    // 
    // Allows the caller to determine if they can talk to the specified
    // account using the current connection.
    //
    // Return Values:
    //   S_OK    - The caller can connect using the existing connection
    //   S_FALSE - There is no existing connection.  The caller must first
    //             connect.
    //   E_FAIL  - There is a connection that is active, but it is not the 
    //             connection for this account.  
    //
    HRESULT CanConnect(IImnAccount *pAccount);
    HRESULT CanConnect(LPTSTR pszAccount);
    
	BOOL IsAccountDisabled(LPTSTR pszAccount);

    // Connect
    //
    // If the specified account requires a RAS connection, then connect 
    // attempts to establish that connection.  Otherwise, we simply
    // return success for manual or LAN connections.
    //
    // <in> pAccount / pszAccount - Name or pointer to the account to connect
    // <in> fShowUI - TRUE if the connection manager is allowed to display
    //                UI while trying to connect.
    //    
    HRESULT Connect(IImnAccount *pAccount, HWND hwnd, BOOL fShowUI);
    HRESULT Connect(LPTSTR pszAccount, HWND hwnd, BOOL fShowUI);
    HRESULT Connect(HMENU hMenu, DWORD cmd, HWND hwnd);

    HRESULT ConnectDefault(HWND hwnd, BOOL fShowUI);
    
    // Disconnect
    //
    // If there is a RAS connection in effect and we established that
    // connection, then we bring the connection down without asking any
    // questions.  If we didn't establish the connection, then we explain
    // the conundrum to the user and ask if they still want to.  If it's
    // a LAN connection, then we just return success.
    //
    HRESULT Disconnect(HWND hwnd, BOOL fShowUI, BOOL fForce, BOOL fShutdown);
    
    // IsConnected
    //
    // The client can call this to determine if there is currently an active
    // connection.  
    //
    BOOL IsConnected(void); 

    // IsRasLoaded
    //
    // In our shutdown code we call this before calling IsConnected since
    // IsConnected causes RAS to be loaded. We don't want to load RAS on
    // shutdown.
    //
    BOOL IsRasLoaded(void) {
        EnterCriticalSection(&m_cs);
        BOOL f = (NULL == m_hInstRas) ? FALSE : TRUE;
        LeaveCriticalSection(&m_cs);
        return f;
    }

    // IsGlobalOffline
    //
    // Checks the state of the global WININET offline option
    //
    BOOL IsGlobalOffline(void);

    // SetGlobalOffline
    //
    // Sets the global offline state for Athena and IE
    //
    void SetGlobalOffline(BOOL fOffline, HWND   hwndParent = NULL);
    
    // Notifications
    // 
    // A client can call Advise() to register itself to receive
    // notifications of connection changes.
    //    
    HRESULT Advise(IConnectionNotify *pNotify);
    HRESULT Unadvise(IConnectionNotify *pNotify);
    
    /////////////////////////////////////////////////////////////////////////
    // UI Related APIs
    //
    
    // RasAccountsExist
    //
    // A client can call this to determine if there are any configured 
    // accounts that exist that require a RAS connection.
    //
    // Returns:
    //   S_OK    - At least one account exists that uses RAS
    //   S_FALSE - No accounts exist that use RAS
    //
    HRESULT RasAccountsExist(void);
    
    // GetConnectMenu
    // 
    // A client can call this to retrieve the current list of items that
    // we can currently connect to.  The client must call DestroyMenu() to
    // free the menu when the client is done.
    //
    HRESULT GetConnectMenu(HMENU *phMenu);

    // FreeConnectMenu
    //
    // After the client is done with the menu returned from GetConnectMenu(),
    // they need to call FreeConnectMenu() to free item data stored in the 
    // menu and to destroy the menu resource.
    void FreeConnectMenu(HMENU hMenu);

    // OnActivate
    //
    // This should be called by the browser whenever our window receives an
    // WM_ACTIVATE message.  When we receive the message, we check to see
    // what the current state of the RAS Connection is.
    void OnActivate(BOOL fActive);

    // FillRasCombo
    //
    // This function takes a handle to a combo box and inserts the list of
    // RAS connections used by accounts in Athena.
    BOOL FillRasCombo(HWND hwndCombo, BOOL fIncludeNone);

    // DoStartupDial
    // 
    // This function checks to see what the user's startup options are with
    // respect to RAS and performs the actions required (dial, dialog, nada)
    void DoStartupDial(HWND hwndParent);

    // RefreshConnInfo - Defer checking of current connection information
    HRESULT RefreshConnInfo(BOOL fSendAdvise = TRUE);

//    HRESULT HandleConnStuff(BOOLEAN  fShowUI, LPSTR  pszAccountName, HWND hwnd);

    void    DoOfflineTransactions(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // These are private.  Stop looking at them you pervert.
    //
    HRESULT VerifyRasLoaded(void);
    HRESULT EnumerateConnections(LPRASCONN *ppRasConn, ULONG *pcConnections);
    HRESULT StartRasDial(HWND hwndParent, LPTSTR pszConnection);
    HRESULT RasLogon(HWND hwnd, LPTSTR pszConnection, BOOL fForcePrompt);
    HRESULT GetDefaultConnection(IImnAccount *pAccout, IImnAccount **ppDefault);
    HRESULT ConnectActual(LPTSTR pszRasConn, HWND hwnd, BOOL fShowUI);
    HRESULT CanConnectActual(LPTSTR pszRasConn);

    void DisplayRasError(HWND hwnd, HRESULT hrRasError, DWORD dwRasError);
    void CombinedRasError(HWND hwnd, UINT unids, LPTSTR pszRasError, 
                          DWORD dwRasError);
    UINT    PromptCloseConnection(HWND hwnd);
    HRESULT PromptCloseConnection(LPTSTR    pszRasConn, BOOL fShowUI, HWND hwndParent);

    static INT_PTR CALLBACK RasCloseConnDlgProc(HWND hwnd, UINT uMsg, 
                                             WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RasLogonDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                         LPARAM lParam);
    static INT_PTR CALLBACK RasProgressDlgProc(HWND hwnd, UINT uMsg, 
                                            WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RasStartupDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                           LPARAM lParam);

                                             
                                             
    BOOL  RasHangupAndWait(HRASCONN hRasConn, DWORD dwMaxWaitSeconds);
    DWORD InternetHangUpAndWait(DWORD_PTR hRasConn, DWORD dwMaxWaitSeconds);
    BOOL  LogonRetry(HWND hwnd, LPTSTR pszCancel);
    void  FailedRasDial(HWND hwnd, HRESULT hrRasError, DWORD dwRasError);
    DWORD EditPhonebookEntry(HWND hwnd, LPTSTR pszEntryName);


    void SendAdvise(CONNNOTIFY nCode, LPVOID pvData);
    void FreeNotifyList(void);
    static LRESULT CALLBACK NotifyWndProc(HWND, UINT, WPARAM, LPARAM);
    BOOL IsConnectionUsed(LPTSTR pszConn);

    // Autodialer functions
    HRESULT DoAutoDial(HWND hwndParent, LPTSTR pszConnectoid, BOOL fDial);
    HRESULT LookupAutoDialHandler(LPTSTR pszConnectoid, LPTSTR pszAutodialDllName,
                                  LPTSTR pszAutodialFcnName);
    BOOL ConnectionManagerVoodoo(LPTSTR pszConnection);
    
    
    HRESULT AddToConnList(LPTSTR  pszRasConn);
    void    RemoveFromConnList(LPTSTR  pszRasConn);
    void    EmptyConnList();
    HRESULT SearchConnList(LPTSTR pszRasConn);
    HRESULT OEIsDestinationReachable(IImnAccount  *pAccount, DWORD dwConnType);
    BOOLEAN IsSameDestination(LPSTR  pszConnectionName, LPSTR pszServerName);
    HRESULT GetServerName(IImnAccount *pAcct, LPSTR  pServerName, DWORD size);
    HRESULT IsInternetReachable(IImnAccount*, DWORD);
    HRESULT IsInternetReachable(LPTSTR pszRasConn);
    HRESULT VerifyMobilityPackLoaded();

    HRESULT ConnectUsingIESettings(HWND     hwndParent, BOOL fShowUI);
    void    SetTryAgain(BOOL   bval);
    static  INT_PTR CALLBACK  OfferOfflineDlgProc(HWND   hwnd, UINT  uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT GetDefConnectoid(LPTSTR szConn, DWORD   dwSize);

private:
    /////////////////////////////////////////////////////////////////////////
    // Private Class Data
    ULONG               m_cRef;             // Ref count
    
    CRITICAL_SECTION    m_cs;
    HANDLE              m_hMutexDial;

    IImnAccountManager *m_pAcctMan;
    
    /////////////////////////////////////////////////////////////////////////////
    // State
    BOOL                m_fSavePassword;
    BOOL                m_fRASLoadFailed;
    BOOL                m_fOffline;
    
    /////////////////////////////////////////////////////////////////////////////
    // Current Connection Information
    DWORD_PTR           m_dwConnId;
    CONNINFO            m_rConnInfo;
    TCHAR               m_szConnectName[RAS_MaxEntryName + 1];
    RASDIALPARAMS       m_rdp;

    /////////////////////////////////////////////////////////////////////////////
    // RAS DLL Handles
    //
    HINSTANCE           m_hInstRas;
    HINSTANCE           m_hInstRasDlg;

    //For Mobility Pack
    HINSTANCE           m_hInstSensDll;
    BOOL                m_fMobilityPackFailed;

    /////////////////////////////////////////////////////////////////////////////
    // Notifications
    NOTIFYHWND         *m_pNotifyList;

    /////////////////////////////////////////////////////////////////////////////
    // Ras Dial Function Pointers
    //
    RASDIALPROC                 m_pRasDial;
    RASENUMCONNECTIONSPROC      m_pRasEnumConnections;
    RASENUMENTRIESPROC          m_pRasEnumEntries;
    RASGETCONNECTSTATUSPROC     m_pRasGetConnectStatus;
    RASGETERRORSTRINGPROC       m_pRasGetErrorString;
    RASHANGUPPROC               m_pRasHangup;
    RASSETENTRYDIALPARAMSPROC   m_pRasSetEntryDialParams;
    RASGETENTRYDIALPARAMSPROC   m_pRasGetEntryDialParams;
    RASEDITPHONEBOOKENTRYPROC   m_pRasEditPhonebookEntry;
    RASDIALDLGPROC              m_pRasDialDlg;
    RASENTRYDLGPROC             m_pRasEntryDlg;
    RASGETENTRYPROPERTIES       m_pRasGetEntryProperties;

    //Mobility Pack
    ISDESTINATIONREACHABLE          m_pIsDestinationReachable;
    ISNETWORKALIVE              m_pIsNetworkAlive;

    ConnListNode                *m_pConnListHead;
    BOOL                        m_fTryAgain;
    BOOL                        m_fDialerUI;
    };


    
/////////////////////////////////////////////////////////////////////////////
// Make our code look prettier
//
#undef RasDial
#undef RasEnumConnections
#undef RasEnumEntries
#undef RasGetConnectStatus
#undef RasGetErrorString
#undef RasHangup
#undef RasSetEntryDialParams
#undef RasGetEntryDialParams
#undef RasEditPhonebookEntry
#undef RasDialDlg
#undef RasGetEntryProperties

#define RasDial                    (*m_pRasDial)
#define RasEnumConnections         (*m_pRasEnumConnections)
#define RasEnumEntries             (*m_pRasEnumEntries)
#define RasGetConnectStatus        (*m_pRasGetConnectStatus)
#define RasGetErrorString          (*m_pRasGetErrorString)
#define RasHangup                  (*m_pRasHangup)
#define RasSetEntryDialParams      (*m_pRasSetEntryDialParams)
#define RasGetEntryDialParams      (*m_pRasGetEntryDialParams)
#define RasEditPhonebookEntry      (*m_pRasEditPhonebookEntry)
#define RasDialDlg                 (*m_pRasDialDlg)
#define RasGetEntryProperties      (*m_pRasGetEntryProperties)

//Mobility Pack
#undef IsDestinationReachable
#define IsDestinationReachable  (*m_pIsDestinationReachable)

#undef IsNetworkAlive
#define IsNetworkAlive          (*m_pIsNetworkAlive)

// Dialog Control IDs
#define idbDet                          1000
#define idlbDetails                     1001
#define ideProgress                     1002
#define idcSplitter                     1003
#define idchSavePassword                1004
#define ideUserName                     1005
#define idePassword                     1006
#define idePhone                        1007
#define idbEditConnection               1009
#define idrgUseCurrent                  1010
#define idrgDialNew                     1011
#define idcCurrentMsg                   1012
#define idcDialupCombo                  1013
#define idcDefaultCheck                 1014
#define idcDontWarnCheck                1015

#endif  // !WIN16
    
#endif // __CONMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\attman.h ===
// ==============================================================================
// MIMEOLE'd Attachment Manger v2. - brettm
// ==============================================================================
#ifndef __ATTMAN_H
#define __ATTMAN_H

// ==============================================================================
// Depends On
// ==============================================================================
#include "mimeolep.h"

#define ATTN_RESIZEPARENT        10000

// from common\dragdrop.h
typedef struct tagDATAOBJINFO *PDATAOBJINFO;

// ==============================================================================
// Defines
// ==============================================================================
//#define BASE_ATTACH_CMD_ID       (ULONG)(WM_USER + 1)

// ==============================================================================
// CAttMan Definition
// ==============================================================================
class CAttMan :
    public IDropSource,
    public IPersistMime
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // *** IDropSource methods ***
    HRESULT STDMETHODCALLTYPE QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState);
    HRESULT STDMETHODCALLTYPE GiveFeedback(DWORD dwEffect);

    // IPersistMime
    HRESULT STDMETHODCALLTYPE Load(LPMIMEMESSAGE pMsg);
    HRESULT STDMETHODCALLTYPE Save(LPMIMEMESSAGE pMsg, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    CAttMan ();
    ~CAttMan ();

    // Load function, unload and close
    HRESULT HrInit (HWND hwnd, BOOL fReadOnly, BOOL fDeleteVCards, BOOL fAllowUnsafe);
    HRESULT HrUnload();
    HRESULT HrClose();

    HRESULT HrIsDragSource();

    HRESULT HrGetAttachCount(ULONG *pcAttach);
    HRESULT HrIsDirty();
    HRESULT HrClearDirtyFlag();

    LPTSTR GetUnsafeAttachList();
    ULONG GetUnsafeAttachCount();

    // handling of windows messages
    BOOL WMCommand(HWND hwndCmd, INT id, WORD wCmd);
    BOOL WMNotify(int idFrom, NMHDR *pnmhdr);
    BOOL WMContextMenu (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    static BOOL CALLBACK InsertFileDlgHookProc(HWND, UINT, WPARAM, LPARAM);

    // handlign of WM_DROPFILE
    HRESULT HrDropFiles(HDROP hDrop, BOOL fMakeLinks);

    // toobar and menu update
    HRESULT HrUpdateToolbar(HWND);

    // external sizing
    HRESULT HrGetHeight(INT cxWidth, ULONG *pcy);
    HRESULT HrSetSize (RECT *prc);

    HWND Hwnd() {return m_hwndList;};

    // enable flags for the browser menus
    HRESULT HrCmdEnabled(UINT idm, LPBOOL pbEnable);
    HRESULT HrFVCard();
    HRESULT HrShowVCardProp();
    HRESULT HrCheckVCardExists(BOOL fMail);
    HRESULT GetTabStopArray(HWND *rgTSArray, int *pcArrayCount);
    HRESULT HrAddAttachment (LPWSTR lpszPathName, LPSTREAM pstm, BOOL fShortCut);
    HRESULT HrSwitchView(DWORD dwView);
    HRESULT HrGetRequiredAction(DWORD *pdwEffect, POINTL pt);
    HRESULT HrDropFileDescriptor(LPDATAOBJECT pDataObj, BOOL fLink);
    HRESULT CheckAttachNameSafeWithCP(CODEPAGEID cpID);

private:
    LPMIMEMESSAGE   m_pMsg;
    HIMAGELIST      m_himlSmall;
    HIMAGELIST      m_himlLarge;
    ULONG           m_cRef;
    HWND            m_hwndList,
                    m_hwndParent;   // we stuff this for UI when there's no m_hwndList
    CLIPFORMAT      m_cfAccept;
    DWORD           m_dwDragType,
                    m_grfKeyState,
                    m_dwEffect;
    int             m_cxMaxText,
                    m_cyHeight;
    BOOL            m_fReadOnly             :1,
                    m_fDirty                :1,
                    m_fDragSource           :1,
                    m_fDropTargetRegister   :1,
                    m_fShowingContext       :1,
                    m_fRightClick           :1,
                    m_fModal                :1,
                    m_fDeleteVCards         :1,
                    m_fWarning              :1,
                    m_fSafeOnly             :1;
    LPATTACHDATA    *m_rgpAttach;
    ULONG           m_cAttach,
                    m_cAlloc,
                    m_cUnsafeAttach;
    HMENU           m_hMenuSaveAttach;
    INT             m_iVCard;
    LPTSTR          m_szUnsafeAttachList;


    // Listview stuff
    HRESULT HrInitImageLists();
    HRESULT HrFillListView();
    HRESULT HrCreateListView(HWND hwnd);
    HRESULT HrAddToList(LPATTACHDATA pAttach, BOOL fIniting);
    HRESULT HrBuildAttachList();

    // menu stuff
    HRESULT HrGetAttMenu(HMENU *phMenu, BOOL fContextMenu);
    HRESULT HrCleanMenu(HMENU hMenu);
    HRESULT HrGetAttachmentById(HMENU hMenu, ULONG id, HBODY *phBody);
    HRESULT HrGetItemTextExtent(HWND hwnd, LPSTR szDisp, LPSIZE pSize);
    HRESULT HrAttachFromMenuID(int idm, LPATTACHDATA *ppAttach);

    HRESULT HrInsertFile();
    HRESULT HrRemoveAttachments();
    HRESULT HrRemoveAttachment(int ili);
    HRESULT HrDeleteAttachments();

    HRESULT HrExecFile(int iVerb);

    HRESULT HrInsertFileFromStgMed(LPWSTR pwszFileName, LPSTGMEDIUM pstgmed, BOOL fLink);
    
    HRESULT HrBeginDrag();
    HRESULT HrBuildHDrop(PDATAOBJINFO *ppdoi);

    HRESULT HrResizeParent();
    HRESULT HrDblClick(int idFrom, NMHDR *pnmhdr);

    HRESULT HrCheckVCard();

    // data table
    HRESULT HrFreeAllData();
    HRESULT HrAddData(HBODY hAttach);
    HRESULT HrAddData(LPWSTR lpszPathName, LPSTREAM pstm, LPATTACHDATA *ppAttach);
    HRESULT HrAllocNewEntry(LPATTACHDATA pAttach);

    // Attachment commands
    HRESULT HrDoVerb(LPATTACHDATA pAttach, INT nVerb);
    HRESULT HrSaveAs(LPATTACHDATA lpAttach);
    HRESULT HrGetTempFile(LPATTACHDATA lpAttach);
    HRESULT HrCleanTempFile(LPATTACHDATA lpAttach);
    HRESULT HrSave(HBODY hAttach, LPWSTR lpszFileName);

};

typedef CAttMan *LPATTMAN;

#endif __ATTMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\cererdlg.cpp ===
/*
**  c e r e r d l g . c p p
**   
**  Purpose:
**      Handles the certificate error dialog box
**
**  History
**      2/17/97: (t-erikne) Created.
**   
**    Copyright (C) Microsoft Corp. 1997.
*/

///////////////////////////////////////////////////////////////////////////
// 
// Depends on
//

#include "pch.hxx"
#include <resource.h>
#include <mimeole.h>
#include "demand.h"
#include "secutil.h"

// from globals.h
//N why didn't this work?
//extern IMimeAllocator  *g_pMoleAlloc;

///////////////////////////////////////////////////////////////////////////
// 
// Prototypes
//

INT_PTR CALLBACK CertErrorDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
static void FillListView(HWND hwndList, IMimeAddressTable *pAdrTable);
static void InitListView(HWND hwndList);

///////////////////////////////////////////////////////////////////////////
// 
// Functions
//

INT_PTR CALLBACK CertErrorDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    CERTERRPARAM   * pCertErrParam = NULL;
    IMimeAddressTable *pAdrTable = NULL;
    TCHAR szText[CCHMAX_STRINGRES];

    switch (message)
        {
        case WM_INITDIALOG:
            HWND hwndList;

            CenterDialog(hwnd);

            // save our cookie pointer
            Assert(pAdrTable == NULL);
            pCertErrParam = (CERTERRPARAM *) lParam;
            pAdrTable = pCertErrParam->pAdrTable;
            Assert(pAdrTable != NULL);
            //N not needed right now
            //SetWindowLong(hwnd, DWL_USER, (LONG)pAdrTable);

            // set initial state of controls
            hwndList = GetDlgItem(hwnd, idcCertList);
            if (hwndList)
                {
                InitListView(hwndList);
                FillListView(hwndList, pAdrTable);
                }

            // Force Encryption change static text and disable OK button)
            if(pCertErrParam->fForceEncryption)
            {   
                szText[0] = _T('\0');
                AthLoadString(idsSecPolicyForceEncr,
                            szText, ARRAYSIZE(szText));
                SetDlgItemText(hwnd, idcErrStat, szText);
                EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);
            }
            return(TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            //return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapMailRead);
            return FALSE;  // BUGBUG: should no doubt do something else here

        case WM_COMMAND:
            // remember to bail if the cookie is null

            switch (LOWORD(wParam))
                {
                case IDOK:
                    {
                    }
                    // fall through...
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return(TRUE);

                    break;
                }

            break; // wm_command

        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
            return (TRUE);

        } // message switch
    return(FALSE);
}


void InitListView(HWND hwndList)
{
    LV_COLUMN   lvc;
    RECT        rc;

    // Set up the columns.  The first column will be for the person's
    // name and the second for the certificate error

    GetClientRect(hwndList, &rc);

    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right / 2;

    ListView_InsertColumn(hwndList, 0, &lvc);
    ListView_InsertColumn(hwndList, 1, &lvc);
}

void FillListView(HWND hwndList, IMimeAddressTable *pAdrTable)
{
    IMimeEnumAddressTypes   *pEnum;
    const ULONG             numToGet = 1;
    ADDRESSPROPS            rAddress;
    LV_ITEM                 lvi;
    TCHAR                   szText[CCHMAX_STRINGRES];

    Assert(g_pMoleAlloc && hwndList && pAdrTable);

    if (FAILED(pAdrTable->EnumTypes(IAT_ALL, IAP_ADRTYPE | IAP_CERTSTATE | IAP_FRIENDLY, &pEnum)))
        return;

    lvi.mask = LVIF_TEXT;
    lvi.iItem = 0;
    lvi.stateMask = 0;

    while(S_OK == pEnum->Next(numToGet, &rAddress, NULL))
        {
        if (CERTIFICATE_OK != rAddress.certstate)
            {
            // if this is the sender and the problem is that the cert
            // is missing, ignore it.  We handle that elsewhere
            if (IAT_FROM == rAddress.dwAdrType &&
                FMissingCert(rAddress.certstate))
                {
                continue;
                }

            // we have a body worthy of viewing
            if (NULL != rAddress.pszFriendly)
                {
                lvi.iSubItem = 0;
                lvi.pszText = rAddress.pszFriendly;
                if (-1 == ListView_InsertItem(hwndList, &lvi))
                    goto freecont;

                // now compute the actual certificate error text
                // subtract one becuse the enum is zero-based
                AthLoadString(idsSecurityCertMissing+(UINT)rAddress.certstate-1,
                    szText, ARRAYSIZE(szText));

                lvi.iSubItem = 1;
                lvi.pszText = szText;
                ListView_SetItem(hwndList, &lvi);
                }
            }
freecont:
        g_pMoleAlloc->FreeAddressProps(&rAddress);
        }

    ReleaseObj(pEnum);
    return;
}


INT_PTR CALLBACK CertWarnDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    ERRIDS *pErrIds = NULL;
    TCHAR szRes[CCHMAX_STRINGRES];

    switch (message)
        {
        case WM_INITDIALOG:

            CenterDialog(hwnd);

            // save our cookie pointer
            Assert(pErrIds == NULL);
            pErrIds = (ERRIDS *)lParam;

            Assert(pErrIds != NULL);
            //N not needed right now
            //SetWindowLong(hwnd, DWL_USER, (LONG)pAdrTable);

            // set initial state of controls
            AthLoadString(pErrIds->idsText1, szRes, sizeof(szRes));
            SetDlgItemText(hwnd, idcStatic1, szRes);
            
            AthLoadString(pErrIds->idsText2, szRes, sizeof(szRes));
            SetDlgItemText(hwnd, idcStatic2, szRes);

            return(TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            //return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapMailRead);
            return FALSE;  // BUGBUG: should no doubt do something else here

        case WM_COMMAND:
            // remember to bail if the cookie is null

            switch (LOWORD(wParam))
                {
                case IDOK:
                    // fall through...
                case IDC_DONTSIGN:
                    // fall through...
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return(TRUE);

                    break;
                }

            break; // wm_command

        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
            return (TRUE);

        } // message switch
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\ddfldbar.h ===
#ifndef __DDFLDBAR_H__
#define __DDFLDBAR_H__

/*
This file defines the interface for communication between InfoColumn and its bands when the InfoColumn is 
shown as a drop down window from the Folder Bar. Add any functions that the InfoColumn needs to call when its in 
the drop down mode, here.
*/

/*
interface IDropDownFldrBar
{
    STDMETHOD(RegisterFlyOut) (THIS_ CFolderBar *pFolderBar) PURE;
    STDMETHOD(RevokeFlyOut) (THIS) PURE;
};
*/

class IDropDownFldrBar : public IUnknown
{
public:
    virtual HRESULT   RegisterFlyOut(CFolderBar *pFolderBar) = 0;
    virtual HRESULT   RevokeFlyOut() = 0;
};


#endif //__DDFLDBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\dragdrop.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     DragDrop.cpp
//
//  PURPOSE:    Implements some common IDropTarget derived interfaces
//

#include "pch.hxx"
#include "dragdrop.h"
#include "dllmain.h"
#include "shlobj.h"
#include <storutil.h>
#include <storecb.h>
#include "instance.h"
#include "demand.h"
#include "mimeutil.h"
#include "storecb.h"
#include "bodyutil.h"
#include "imsgsite.h"
#include "note.h"
#include "shlwapip.h"
#include "secutil.h"

BOOL FIsFileInsertable(HDROP hDrop, LPSTREAM *ppStream, BOOL* fHTML);
HRESULT HrAttachHDrop(HWND hwnd, IMimeMessage *pMessage, HDROP hDrop, BOOL fMakeLinks);
HRESULT HrAddAttachment(IMimeMessage *pMessage, LPWSTR pszName, LPSTREAM pStream, BOOL fLink);


//
//  FUNCTION:   CDropTarget::CDropTarget
//
//  PURPOSE:    Simple constructor, initializes everything to NULL or zero.
//
CDropTarget::CDropTarget()
{
    m_cRef = 1;

    m_hwndOwner = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_fOutbox = FALSE;

    m_pDataObject = NULL;
    m_cf = 0;

    m_hwndDlg = 0;
    m_hDrop = 0;
    m_cFiles = 0;
    m_iFileCur = 0;
    m_pFolder = 0;
    m_pStoreCB = 0;
}


//
//  FUNCTION:   CDropTarget::~CDropTarget
//
//  PURPOSE:    Cleans up any leftover data.
//
CDropTarget::~CDropTarget()
{
    SafeRelease(m_pDataObject);
}


//
//  FUNCTION:   CDropTarget::Initialize()
//
//  PURPOSE:    Initializes the drop target with the ID of the folder that will
//              be the target and a window handle that can parent any UI we
//              need to display.
//
//  PARAMETERS: 
//      [in] hwndOwner - Handle of a window we can parent UI to.
//      [in] idFolder  - ID of the folder that will be the target.
//
//  RETURN VALUE:
//      E_INVALIDARG - Bogus parameter passed in
//      S_OK         - Happiness abounds 
//
HRESULT CDropTarget::Initialize(HWND hwndOwner, FOLDERID idFolder)
{
    TraceCall("CDropTarget::Initialize");

    if (!IsWindow(hwndOwner) || idFolder == FOLDERID_INVALID)
        return (E_INVALIDARG);

    m_hwndOwner = hwndOwner;
    m_idFolder = idFolder;

    FOLDERINFO fi;

    if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &fi)))
    {
        m_fOutbox = (fi.tySpecial == FOLDER_OUTBOX);
        g_pStore->FreeRecord(&fi);
    }

    return (S_OK);
}


//
//  FUNCTION:   CDropTarget::QueryInterface()
//
//  PURPOSE:    Returns a the requested interface if supported.
//
HRESULT CDropTarget::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown*)(IDropTarget*) this;
    else if (IsEqualIID(riid, IID_IDropTarget))
        *ppvObj = (LPVOID) (IDropTarget*) this;
    else
        *ppvObj = NULL;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CBaseDropTarget::AddRef()
//
//  PURPOSE:    Increments the object reference count.
//
ULONG CDropTarget::AddRef(void)
{
    return (++m_cRef);
}


//
//  FUNCTION:   CDropTarget::Release()
//
//  PURPOSE:    Decrements the object's ref count. If the ref count hit's zero
//              the object is freed.
//
ULONG CDropTarget::Release(void)
{
    m_cRef--;

    if (m_cRef == 0)
    {
        delete this;
        return (0);
    }

    return (m_cRef);
}

//
//  FUNCTION:   CDropTarget::DragEnter()
//
//  PURPOSE:    This get's called when the user starts dragging an object
//              over our target area.
//
//  PARAMETERS:
//      [in]  pDataObject - Pointer to the data object being dragged
//      [in]  grfKeyState - Pointer to the current key states
//      [in]  pt          - Point in screen coordinates of the mouse
//      [out] pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT CDropTarget::DragEnter(IDataObject* pDataObject, DWORD grfKeyState, 
                               POINTL pt, DWORD* pdwEffect)
{
    IEnumFORMATETC *pEnum;
    FORMATETC       fe;
    ULONG           celtFetched;
    DWORD           dwEffectOut = DROPEFFECT_NONE;
    
    Assert(m_pDataObject == NULL);
    
    // Get the FORMATETC enumerator for this object
    if (SUCCEEDED(pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
    {
        // Walk through the data types available to see if there is one we
        // understand
        pEnum->Reset();
        
        while (S_OK == pEnum->Next(1, &fe, &celtFetched))
        {
            Assert(celtFetched == 1);
            if (_ValidateDropType(fe.cfFormat, pDataObject))
            {
                // Figure out what the right drag effect is
                dwEffectOut = _DragEffectFromFormat(pDataObject, *pdwEffect, fe.cfFormat, grfKeyState);
                break;
            }
        }
        
        pEnum->Release();
    }
    
    // If we allow this to be dropped on us, then keep a copy of the data object
    if (dwEffectOut != DROPEFFECT_NONE)
    {
        m_pDataObject = pDataObject;
        m_pDataObject->AddRef();
        m_cf = fe.cfFormat;
    }

    *pdwEffect = dwEffectOut;
    
    return (S_OK);
}


//
//  FUNCTION:   CDropTarget::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      [in]  grfKeyState - Pointer to the current key states
//      [in]  pt          - Point in screen coordinates of the mouse
//      [out] pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT CDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    // If we don't have a stored data object from CMDT::DragEnter(), then this
    // isn't a data object we have any interest in.
    if (NULL == m_pDataObject)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return (S_OK);
    }
    
    // We don't care about _where_ the drop happens, just what type of effect
    // should be displayed.
    *pdwEffect = _DragEffectFromFormat(m_pDataObject, *pdwEffect, m_cf, grfKeyState);
    
    return (S_OK);
}


//
//  FUNCTION:   CDropTarget::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
HRESULT CDropTarget::DragLeave(void)
{
    // Free everything up at this point.
    if (NULL != m_pDataObject)
    {
        m_pDataObject->Release();
        m_pDataObject = 0;
        m_cf = 0;
    }
    
    return (S_OK);
}


//
//  FUNCTION:   CDropTarget::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.
//
//  PARAMETERS:
//      [in]  pDataObject - Pointer to the data object being dragged
//      [in]  grfKeyState - Pointer to the current key states
//      [in]  pt          - Point in screen coordinates of the mouse
//      [out] pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
HRESULT CDropTarget::Drop(IDataObject* pDataObject, DWORD grfKeyState, 
                          POINTL pt, DWORD* pdwEffect)
{
    IEnumFORMATETC *pEnum;
    FORMATETC       fe;
    ULONG           celtFetched;
    HRESULT         hr;
    
    if (!pDataObject)
        return (E_INVALIDARG);
    
    *pdwEffect = _DragEffectFromFormat(pDataObject, *pdwEffect, m_cf, grfKeyState);
    hr = _HandleDrop(m_pDataObject, *pdwEffect, m_cf, grfKeyState);
    
    SafeRelease(m_pDataObject);
    return (hr);
}


//
//  FUNCTION:  CDropTarget::_CheckRoundtrip()
//
//  PURPOSE:   Checks to see if the source and the target are the same.
//
//  PARAMETERS:
//      [in] pDataObject - Object being dragged over us
//
//  RETURNS:
//      TRUE if the source and destination are the same, FALSE otherwise.
//
BOOL CDropTarget::_CheckRoundtrip(IDataObject *pDataObject)
{
    AssertSz(FALSE, "CDropTarget::_CheckRoundtrip() - NYI");
    return (FALSE);
}


//
//  FUNCTION:   CDropTarget::_ValidateDropType()
//
//  PURPOSE:    Examines the the specified clipboard format to see if we can
//              accept this data type.
//
//  PARAMETERS:
//      <in> cf - Clipboard format
//
//  RETURN VALUE:
//      TRUE if we understand, FALSE otherwise.
//
BOOL CDropTarget::_ValidateDropType(CLIPFORMAT cf, IDataObject *pDataObject)
{
    if (!pDataObject)
        return (FALSE);

    // OE Folders
    if (cf == CF_OEFOLDER)
        return (_IsValidOEFolder(pDataObject));

    // Messages
    if (cf == CF_OEMESSAGES)
        return (_IsValidOEMessages(pDataObject));

    // Files
    if (cf == CF_HDROP && !m_fOutbox)
        return (TRUE);

    // Text
    if ((cf == CF_TEXT || cf == CF_HTML || cf == CF_UNICODETEXT) && !m_fOutbox)
        return (TRUE);

    return (FALSE);
}



//
//  FUNCTION:   CDropTarget::_IsValidOEFolder()
//
//  PURPOSE:    Checks to see if the data object contains valid OE Folder 
//              information for this target.
//
//  PARAMETERS: 
//      [in] pDataObject - Data Object to check
//
//  RETURN VALUE:
//      Returns TRUE if it's OK to drop this here, FALSE otherwise.
//
BOOL CDropTarget::_IsValidOEFolder(IDataObject *pDataObject)
{
    FORMATETC  fe;
    STGMEDIUM  stm = {0};
    FOLDERID  *pidFolder;
    FOLDERINFO rInfoSrc = {0};
    FOLDERINFO rInfoDest = {0};
    BOOL       fReturn = FALSE;

    TraceCall("CDropTarget::_IsValidOEFolder");

    // Get the folder information from the object
    SETDefFormatEtc(fe, CF_OEFOLDER, TYMED_HGLOBAL);
    if (FAILED(pDataObject->GetData(&fe, &stm)))
        return (FALSE);
    pidFolder = (FOLDERID *) GlobalLock(stm.hGlobal);

    // Moving a folder onto itself would be bad
    if (*pidFolder == m_idFolder)
        goto exit;

    // Figure out the store type of the folder
    if (FAILED(g_pStore->GetFolderInfo(*pidFolder, &rInfoSrc)))
        goto exit;

    // You simply cannot move news or special folders
    if (rInfoSrc.tyFolder == FOLDER_NEWS || rInfoSrc.tySpecial != FOLDER_NOTSPECIAL)
        goto exit;

    // If it's not news, we need information about the destination
    if (FAILED(g_pStore->GetFolderInfo(m_idFolder, &rInfoDest)))
        goto exit;

    // Local to Local OK
    if (rInfoSrc.tyFolder == FOLDER_LOCAL && rInfoDest.tyFolder == FOLDER_LOCAL)
    {
        fReturn = TRUE;
        goto exit;
    }

    // According to Ray, IMAP folders can't be moved.  I don't know about HTTP.
    if (rInfoSrc.tyFolder == FOLDER_IMAP || rInfoSrc.tyFolder == FOLDER_HTTPMAIL)
        goto exit;

exit:
    if (rInfoDest.pAllocated)
        g_pStore->FreeRecord(&rInfoDest);
    if (rInfoSrc.pAllocated)
        g_pStore->FreeRecord(&rInfoSrc);

    GlobalUnlock(stm.hGlobal);
    ReleaseStgMedium(&stm);
   
    return (fReturn);
}


//
//  FUNCTION:   CDropTarget::_IsValidOEMessages()
//
//  PURPOSE:    Checks to see if the data object contains OE Messages that can
//              be dropped here.
//
//  PARAMETERS: 
//      [in] pDataObject - Data object to verify.
//
//  RETURN VALUE:
//      Returns TRUE if the object contains data that can be dropped here.
//
BOOL CDropTarget::_IsValidOEMessages(IDataObject *pDataObject)
{
    FORMATETC  fe;
    STGMEDIUM  stm;
    FOLDERID  *pidFolder;
    FOLDERINFO rInfoDest = {0};
    BOOL       fReturn = FALSE;

    TraceCall("CDropTarget::_IsValidOEMessages");

    // We don't allow dropping messages on the outbox, on server nodes,
    // or on the root.
    if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rInfoDest)))
    {
        fReturn = (0 == (rInfoDest.dwFlags & FOLDER_SERVER)) &&
                  (FOLDERID_ROOT != m_idFolder) &&
                  (FOLDER_OUTBOX != rInfoDest.tySpecial) &&
                  (FOLDER_NEWS != GetFolderType(m_idFolder));

        g_pStore->FreeRecord(&rInfoDest);
    }

    return (fReturn);
}


//
//  FUNCTION:   CDropTarget::_DragEffectFromFormat()
//
//  PURPOSE:    Examines the keyboard state and the specified clipboard format
//              and determines what the right drag effect would be.
//
//  PARAMETERS:
//      <in> cf          - Clipboard format
//      <in> grfKeyState - State of the keyboard
//
//  RETURN VALUE:
//      Returns one of the drag effects defined by OLE, ie DRAGEFFECT_COPY, etc.
//
DWORD CDropTarget::_DragEffectFromFormat(IDataObject *pDataObject, DWORD dwEffectOk, 
                                         CLIPFORMAT cf, DWORD grfKeyState)
{
    FORMATETC  fe;
    STGMEDIUM  stm;
    BOOL       fRoundTrip = FALSE;
    FOLDERID  *pidFolder;

    // Folders are always a move
    if (cf == CF_OEFOLDER)
        return (DROPEFFECT_MOVE);

    // Messages move or copy
    if (cf == CF_OEMESSAGES)
    {
        SETDefFormatEtc(fe, CF_OEMESSAGES, TYMED_HGLOBAL);
        if (SUCCEEDED(pDataObject->GetData(&fe, &stm)))
        {
            pidFolder = (FOLDERID *) GlobalLock(stm.hGlobal);
        
            fRoundTrip =  (*pidFolder == m_idFolder);

            GlobalUnlock(stm.hGlobal);
            ReleaseStgMedium(&stm);
        }

        if (fRoundTrip)
            return (DROPEFFECT_NONE);
        else if ((dwEffectOk & DROPEFFECT_MOVE) && !(grfKeyState & MK_CONTROL))
            return (DROPEFFECT_MOVE);
        else
            return (DROPEFFECT_COPY);
    }

    // Files
    if (cf == CF_HDROP)
    {
        if (grfKeyState & MK_SHIFT && grfKeyState & MK_CONTROL)
            return (DROPEFFECT_LINK);
        else
            return (DROPEFFECT_COPY);
    }

    // If it's text or HTML, create a new note with the body filled with the
    // contents
    if (CF_TEXT == cf || CF_HTML == cf || CF_UNICODETEXT == cf)
        return (DROPEFFECT_COPY);

    return (DROPEFFECT_NONE);
}


//
//  FUNCTION:   CDropTarget::_HandleDrop()
//
//  PURPOSE:    Takes the dropped object and get's the data out of it that
//              we care about.
//
//  PARAMETERS:
//      <in> pDataObject - Object being dropped on us.
//      <in> cf          - Format to render
//      <in> grfKeyState - Keyboard state when the object was dropped.
//
//  RETURN VALUE:
//      S_OK if we jam on it.
//
HRESULT CDropTarget::_HandleDrop(IDataObject *pDataObject, DWORD dwEffectOk,
                                 CLIPFORMAT cf, DWORD grfKeyState)
{
    DWORD dw;

    if (cf == CF_OEFOLDER)
        return (_HandleFolderDrop(pDataObject));

    if (cf == CF_OEMESSAGES)
    {
        dw = _DragEffectFromFormat(pDataObject, dwEffectOk, cf, grfKeyState);
        Assert(dw == DROPEFFECT_MOVE || dw == DROPEFFECT_COPY);

        return (_HandleMessageDrop(pDataObject, dw == DROPEFFECT_MOVE));
    }

    if (cf == CF_HDROP)
        return (_HandleHDrop(pDataObject, cf, grfKeyState));

    if (cf == CF_TEXT || cf == CF_HTML || cf == CF_UNICODETEXT)
        return (_CreateMessageFromDrop(m_hwndOwner, pDataObject, grfKeyState));

    return (DV_E_FORMATETC);
}


HRESULT CDropTarget::_HandleFolderDrop(IDataObject *pDataObject)
{
    FORMATETC  fe;
    STGMEDIUM  stm;
    FOLDERID  *pidFolder;
    HRESULT    hr = E_UNEXPECTED;

    if (!pDataObject)
        return (E_INVALIDARG);

    // Get the data from the data object
    SETDefFormatEtc(fe, CF_OEFOLDER, TYMED_HGLOBAL);
    if (SUCCEEDED(pDataObject->GetData(&fe, &stm)))
    {
        pidFolder = (FOLDERID *) GlobalLock(stm.hGlobal);

        // Tell the store to move
        hr = MoveFolderProgress(m_hwndOwner, *pidFolder, m_idFolder);
        
        GlobalUnlock(stm.hGlobal);
        ReleaseStgMedium(&stm);
    }

    return (hr);
}

HRESULT CDropTarget::_HandleMessageDrop(IDataObject *pDataObject, BOOL fMove)
{
    FORMATETC fe;
    STGMEDIUM stm;
    OEMESSAGES *pMsgs = 0;
    HRESULT hr = E_UNEXPECTED;

    // Get the data from the data object
    SETDefFormatEtc(fe, CF_OEMESSAGES, TYMED_HGLOBAL);
    if (SUCCEEDED(hr = pDataObject->GetData(&fe, &stm)))
    {
        pMsgs = (OEMESSAGES *) GlobalLock(stm.hGlobal);

        hr = CopyMoveMessages(m_hwndOwner, pMsgs->idSource, m_idFolder, &pMsgs->rMsgIDList, fMove ? COPY_MESSAGE_MOVE : 0);
        if (FAILED(hr))
            AthErrorMessageW(m_hwndOwner, MAKEINTRESOURCEW(idsAthena), fMove ? MAKEINTRESOURCEW(idsErrMoveMsgs) : MAKEINTRESOURCEW(idsErrCopyMsgs), hr); 

        if (NULL != g_pInstance)
        {
            HRESULT     hrTemp;
            FOLDERINFO  fiFolderInfo;

            hrTemp = g_pStore->GetFolderInfo(pMsgs->idSource, &fiFolderInfo);
            if (SUCCEEDED(hrTemp))
            {
                if (FOLDER_INBOX == fiFolderInfo.tySpecial)
                    g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);

                g_pStore->FreeRecord(&fiFolderInfo);
            }
        }

        GlobalUnlock(stm.hGlobal);
        ReleaseStgMedium(&stm);
    }

    return (hr);
}


//
//  FUNCTION:   CDropTarget::_HandleHDrop()
//
//  PURPOSE:    Examines the contents of the drop to see if these are just files
//              or are they .eml or .nws files.
//
//  PARAMETERS: 
//      [in] pDataObject
//      [in] cf
//      [in] grfKeyState
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CDropTarget::_HandleHDrop(IDataObject *pDataObject, CLIPFORMAT cf, DWORD grfKeyState)
{
    FORMATETC   fe;
    STGMEDIUM   stg = {0};
    HDROP       hDrop;
    HRESULT     hr;
    BOOL        fRelease = FALSE;
    UINT        cFiles;
    BOOL        fMessages = TRUE;
    UINT        i;

    TraceCall("CDropTarget::_HandleHDrop");

    // Get the data from the object
    SETDefFormatEtc(fe, CF_HDROP, TYMED_HGLOBAL);

    if (FAILED(hr = pDataObject->GetData(&fe, &stg)))
    {
        AssertSz(SUCCEEDED(hr), "CDropTarget::_HandleHDrop() - GetData() failed.");
        goto exit;
    }

    fRelease = TRUE;
    hDrop = (HDROP) GlobalLock(stg.hGlobal);

    if (FOLDER_NEWS != GetFolderType(m_idFolder) && (FOLDERID_ROOT != m_idFolder) && 
        (FOLDERID_LOCAL_STORE != m_idFolder) && !(FOLDER_IMAP == GetFolderType(m_idFolder) && FFolderIsServer(m_idFolder)))
    {
        // Look inside the data to see if any of the files are .eml or .nws
        cFiles = DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0);
        for (i = 0; i < cFiles; i++)
        {
            WCHAR       wszFile[MAX_PATH];
            LPWSTR      pwszExt;
            // Get the name of the i'th file in the drop
            DragQueryFileWrapW(hDrop, i, wszFile, ARRAYSIZE(wszFile));

            // Get the extension for the file
            pwszExt = PathFindExtensionW(wszFile);
            if (*pwszExt)
            {
                // Once we find the first file that isn't one of our messages, we
                // can give up.
                if (0 != StrCmpIW(pwszExt, c_wszEmlExt) && 0 != StrCmpIW(pwszExt, c_wszNwsExt))
                {
                    fMessages = FALSE;
                    break;
                }
            }
        }
    }
    else
    {
        fMessages = FALSE;
    }

    // If all of the messages were news or mail messages, we can just copy them
    // into our store.  If even one were normal files, then we create a new message
    // with everything attached.
    if (fMessages)
        hr = _InsertMessagesInStore(hDrop);
    else
        hr = _CreateMessageFromDrop(m_hwndOwner, pDataObject, grfKeyState);

exit:
    if (fRelease)
        ReleaseStgMedium(&stg);

    return (hr);
}


//
//  FUNCTION:   CDropTarget::_InsertMessagesInStore()
//
//  PURPOSE:    When the user drops messages that are stored as .nws or .eml files
//              onto us, we need to integrate those files into our store.
//
//  PARAMETERS: 
//      [in] hDrop - Contains the information needed to get the files
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CDropTarget::_InsertMessagesInStore(HDROP hDrop)
{
    HRESULT hr;

    TraceCall("CDropTarget::_InsertMessagesInStore");

    // Open the folder we're saving into
    if (FAILED(hr = g_pStore->OpenFolder(m_idFolder, NULL, 0, &m_pFolder)))
        return (hr);

    if (0 == (m_pStoreCB = new CStoreDlgCB()))
    {
        m_pFolder->Release();
        return (E_OUTOFMEMORY);
    }

    // Get the count of files
    m_cFiles = DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0);
    m_hDrop = hDrop;
    m_iFileCur = 0;

    // Do the dialog
    DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddCopyMoveMessages), m_hwndOwner,
                   _ProgDlgProcExt, (LPARAM) this);

    // Free some stuff up
    m_cFiles = 0;
    m_hDrop = 0;
    m_pFolder->Release();
    m_pStoreCB->Release();

    return (S_OK);
}

INT_PTR CALLBACK CDropTarget::_ProgDlgProcExt(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CDropTarget *pThis;

    if (msg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CDropTarget*) lParam;
    }
    else
        pThis = (CDropTarget*) GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return pThis->_ProgDlgProc(hwnd, msg, wParam, lParam);

    return FALSE;
}


//
//  FUNCTION:   CDropTarget::DlgProc()
//
//  PURPOSE:    Groovy dialog proc.
//
INT_PTR CDropTarget::_ProgDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndT;

    switch (msg)
    {
        case WM_INITDIALOG:
            return (BOOL)HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, _OnInitDialog);
        
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, _OnCommand);
            return TRUE;

        case WM_STORE_COMPLETE:
            m_iFileCur++;
            _SaveNextMessage();
            return (TRUE);

        case WM_STORE_PROGRESS:
            return (TRUE);
        
    }
    return FALSE;
}



//
//  FUNCTION:   CDropTarget::_OnInitDialog()
//
//  PURPOSE:    Initializes the progress dialog
//
BOOL CDropTarget::_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Assert(m_pStoreCB);

    m_hwndDlg = hwnd;
    m_pStoreCB->Initialize(hwnd);
    m_pStoreCB->Reset();

    // Open and save the first message
    _SaveNextMessage();

    return (TRUE);
}


//
//  FUNCTION:   CDropTarget::_OnCommand()
//
//  PURPOSE:    Handle the cancel button
//
void CDropTarget::_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    // User's have been known to press cancel once in a while
    if (id == IDCANCEL)
    {
        m_pStoreCB->Cancel();
    }
}


//
//  FUNCTION:   CDropTarget::_SaveNextMessage()
//
//  PURPOSE:    Opens the next message in the drop and saves it.
//
void CDropTarget::_SaveNextMessage()
{
    WCHAR           wszFile[MAX_PATH],
                    wszRes[CCHMAX_STRINGRES], 
                    wszBuf[CCHMAX_STRINGRES + MAX_PATH];
    HRESULT         hr;
    IMimeMessage   *pMsg = 0;

    TraceCall("CDropTarget::_SaveNextMessage");

    // See if we're done
    if (m_iFileCur >= m_cFiles)
    {
        EndDialog(m_hwndDlg, 0);
        return;
    }

    // Get the name of the i'th file in the drop
    DragQueryFileWrapW(m_hDrop, m_iFileCur, wszFile, ARRAYSIZE(wszFile));

    // Create a new, empty message.
    if (FAILED(hr = HrCreateMessage(&pMsg)))
    {
        AthErrorMessageW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsMemory), E_OUTOFMEMORY);
        EndDialog(m_hwndDlg, 0);
    }

    // Load the message from the file
    hr = HrLoadMsgFromFileW(pMsg, wszFile);
    if (FAILED(hr))
    {
        AthLoadStringW(IDS_ERROR_FILE_NOEXIST, wszRes, ARRAYSIZE(wszRes));
        wnsprintfW(wszBuf, ARRAYSIZE(wszBuf), wszRes, wszFile);

        AthErrorMessageW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), wszBuf, hr);
        PostMessage(m_hwndDlg, WM_STORE_COMPLETE, 0, 0);
        goto exit;
    }

    // Progress
    AthLoadStringW(idsSavingFmt, wszRes, ARRAYSIZE(wszRes));
    wnsprintfW(wszBuf, ARRAYSIZE(wszBuf), wszRes, wszFile);
    SetDlgItemTextWrapW(m_hwndDlg, idcStatic1, wszBuf);

    // Tell the store to save it
    hr = m_pFolder->SaveMessage(NULL, SAVE_MESSAGE_GENID, ARF_READ, 0, pMsg, m_pStoreCB);
    if (SUCCEEDED(hr))
    {
        PostMessage(m_hwndDlg, WM_STORE_COMPLETE, 0, 0);
        goto exit;
    }

    if (FAILED(hr) && E_PENDING != hr)
    {
        AthErrorMessageW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsUnableToSaveMessage), hr);
        PostMessage(m_hwndDlg, WM_STORE_COMPLETE, 0, 0);
    }

exit:
    SafeRelease(pMsg);
}



//
//  FUNCTION:   CDropTarget::_CreateMessageFromDrop()
//
//  PURPOSE:    This function takes an IDataObject which was dropped on Athena
//              and creates a new mail message from that dropped object.  If
//              the dropped object supports either CF_TEXT or CF_HTML, then
//              that will be streamed into the body of the message.  Otherwise,
//              if it supports CF_HDROP we'll add it as an attachment.
//
//  PARAMETERS:
//      <in> pDataObject -
//      <in> pStore      -
//      <in> grfKeyState -
//      <in> pidl        -
//
//  RETURN VALUE:
//      E_INVALIDARG -
//
//  COMMENTS:
//      <???>
//
HRESULT CDropTarget::_CreateMessageFromDrop(HWND hwnd, IDataObject *pDataObject, 
                                            DWORD grfKeyState)
{
    IEnumFORMATETC *pEnum = NULL;
    FORMATETC       fe;
    DWORD           celtFetched;
    CLIPFORMAT      cf = 0;
    DWORD           tymed = 0;
    IMimeMessage   *pMessage = NULL;
    HRESULT         hr = S_OK;
    STGMEDIUM       stg;
    IStream        *pStream = NULL;
    BOOL            fRelease = TRUE;
    BOOL            fIsRealCFHTML=FALSE;
    
    ZeroMemory(&stg, sizeof(STGMEDIUM));
    
    if (!pDataObject)
    {
        Assert(pDataObject);
        return (E_INVALIDARG);
    }
    
    // Enumerate the formats this object supports to decide which if any we
    // are going to use.
    if (SUCCEEDED(pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
    {
        pEnum->Reset();
        while (S_OK == pEnum->Next(1, &fe, &celtFetched))
        {
            // HTML is the richest format we understand.  If we find that, then
            // we can stop looking.
            if (fe.cfFormat == CF_HTML &&
                (fe.tymed & TYMED_HGLOBAL || fe.tymed & TYMED_ISTREAM))
            {
                DOUTL(32, _T("HrNewMailFromDrop() - Accepting CF_HTML."));
                cf = (CLIPFORMAT) CF_HTML;
                tymed = fe.tymed;
                break;
            }

            // UNICODETEXT is great, but only if we can't find anything richer.  So we
            // accept this, but keep looking.
            else if (fe.cfFormat == CF_UNICODETEXT &&
                (fe.tymed & TYMED_HGLOBAL || fe.tymed & TYMED_ISTREAM))
            {
                DOUTL(32,_T("HrNewMailFromDrop() - Accepting CF_UNICODETEXT."));
                cf = CF_UNICODETEXT;
                tymed = fe.tymed;
            }

            // TEXT is cool, but only if we can't find anything richer.  So we
            // accept this, but keep looking.
            else if (fe.cfFormat == CF_TEXT && cf != CF_UNICODETEXT &&
                (fe.tymed & TYMED_HGLOBAL || fe.tymed & TYMED_ISTREAM))
            {
                DOUTL(32,_T("HrNewMailFromDrop() - Accepting CF_TEXT."));
                cf = CF_TEXT;
                tymed = fe.tymed;
            }

            // If we find HDROP, then we can create an attachment.  However, we
            // want to find something richer so we only accept this if we haven't
            // found anything else we like.
            else if (fe.cfFormat == CF_HDROP && cf == 0 && fe.tymed & TYMED_HGLOBAL)
            {
                cf = CF_HDROP;
                tymed = fe.tymed;
            }
        }
        
        pEnum->Release();
    }
    
    // Make sure we found something useful
    if (0 == cf)
    {
        AssertSz(cf, _T("HrNewMailFromDrop() - Did not find an acceptable data")
            _T(" format to create a message from."));
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    // Set the preferred TYMED to ISTREAM and set the FORMATETC struct up to
    // retrieve the data type we determined above.
    if (tymed & TYMED_ISTREAM)
        tymed = TYMED_ISTREAM;
    else
        tymed = TYMED_HGLOBAL;
    SETDefFormatEtc(fe, cf, tymed);
    
    // Get the data from the object
    if (FAILED(hr = pDataObject->GetData(&fe, &stg)))
    {
        AssertSz(SUCCEEDED(hr), _T("HrNewMailFromDrop() - pDataObject->GetData() failed."));
        goto exit;
    }
    
    // Create the Message Object
    hr = HrCreateMessage(&pMessage);
    if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsMemory),
            0, MB_ICONSTOP | MB_OK);
        goto exit;
    }
    
    // Set the body appropriately
    if (cf == CF_HTML || cf == CF_TEXT || cf == CF_UNICODETEXT)
    {
        if (fe.tymed == TYMED_HGLOBAL)
        {
            if (FAILED(hr = CreateStreamOnHGlobal(stg.hGlobal, TRUE, &pStream)))
            {
                AssertSz(FALSE, _T("HrNewMailFromDrop() - Failed CreateStreamOnHGlobal()"));
                goto exit;
            }
            
            // Bug #24846 - Need to find the actual size of the stream instead of the size
            //              of the HGLOBAL.
            LPBYTE pb = (LPBYTE) GlobalLock(stg.hGlobal);
            ULARGE_INTEGER uliSize;
            uliSize.QuadPart = 0;

            // Raid 77624: OE mishandles CF_UNICODETEXT / TYMED_GLOBAL
            if (cf == CF_TEXT || cf == CF_HTML)
                uliSize.QuadPart = lstrlen((LPSTR)pb);
            else if (cf == CF_UNICODETEXT)
                uliSize.QuadPart = (lstrlenW((LPWSTR)pb) * sizeof(WCHAR));

            GlobalUnlock(stg.hGlobal);
            pStream->SetSize(uliSize);
            
            fRelease = FALSE;
        }
        else
            pStream = stg.pstm;
        
        if (cf == CF_HTML && FAILED(hr = HrStripHTMLClipboardHeader(pStream, &fIsRealCFHTML)))
            goto exit;
        
        // Set Unicode Text Body
        if (cf == CF_UNICODETEXT)
        {
            HCHARSET hCharset;

            if (SUCCEEDED(MimeOleFindCharset("UTF-8", &hCharset)))
            {
                pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
            }

            pMessage->SetTextBody(TXT_PLAIN, IET_UNICODE, NULL, pStream, NULL);
        }

        // Set HTML Text Body
        else if (cf == CF_HTML)
        {
            // Real CF_HTML, or OE's version of CF_HTML?
            if (fIsRealCFHTML)
            {
                // Locals
                HCHARSET hCharset;

                // Map to HCHARSET - Real CF_HTML is always UTF-8
                if (SUCCEEDED(MimeOleFindCharset("utf-8", &hCharset)))
                {
                    // Set It
                    pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
                }
            }

            // Otherwise...
            else
            {
                // Locals
                LPSTR pszCharset=NULL;

                // Sniff the charset
                if (SUCCEEDED(GetHtmlCharset(pStream, &pszCharset)))
                {
                    // Locals
                    HCHARSET hCharset;

                    // Map to HCHARSET
                    if (SUCCEEDED(MimeOleFindCharset(pszCharset, &hCharset)))
                    {
                        // Set It
                        pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
                    }

                    // Cleanup
                    SafeMemFree(pszCharset);
                }
            }

            // We should sniff the charset from the html document and call pMessage->SetCharset
            pMessage->SetTextBody(TXT_HTML, IET_INETCSET, NULL, pStream, NULL);
        }

        // Set plain text, non-unicode text body
        else
            pMessage->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pStream, NULL);
    }
    
    // If there is a single file and the content is text/plain or text/html, then
    // we insert the contents of the message as the body.  Otherwise, we add each
    // file as an attachment.
    if (cf == CF_HDROP)
    {
        HDROP    hDrop = (HDROP) GlobalLock(stg.hGlobal);
        BOOL     fHTML = FALSE,
                 fSetCharset = FALSE,
                 fUnicode = FALSE,
                 fLittleEndian;
        
        if (FIsFileInsertable(hDrop, &pStream, &fHTML))
        {
            if(fHTML)
            {
                LPSTR pszCharset = NULL;                

                // Sniff the charset
                if (FAILED(GetHtmlCharset(pStream, &pszCharset)) && (S_OK == HrIsStreamUnicode(pStream, &fLittleEndian)))
                    pszCharset = StrDupA("utf-8");

                if(pszCharset)
                {
                    HCHARSET hCharset = NULL;

                    // Map to HCHARSET
                    if (SUCCEEDED(MimeOleFindCharset(pszCharset, &hCharset)))
                    {
                        // Set It
                        if(SUCCEEDED(pMessage->SetCharset(hCharset, CSET_APPLY_ALL)))
                            fSetCharset = TRUE;
                    }

                    // Cleanup
                    SafeMemFree(pszCharset);
                }

            }
            else if(S_OK == HrIsStreamUnicode(pStream, &fLittleEndian))
            {
                HCHARSET hCharset;

                if (SUCCEEDED(MimeOleFindCharset("UTF-8", &hCharset)))
                {
                    pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
                }
                
                fUnicode = TRUE;                
            }

            pMessage->SetTextBody((fHTML ? TXT_HTML : TXT_PLAIN),
                (fSetCharset ? IET_INETCSET : (fUnicode ? IET_UNICODE : IET_DECODED)),
                NULL, pStream, NULL);
            SafeRelease(pStream);
        }
        else
        {
            // Get the drop handle and add it's contents to the message
            hr = HrAttachHDrop(hwnd, pMessage, hDrop, grfKeyState & MK_CONTROL && grfKeyState & MK_SHIFT);
        }
        
        GlobalUnlock(stg.hGlobal);
    }
    
    // Last step is to instantiate the send note
    INIT_MSGSITE_STRUCT initStruct;
    BOOL fNews;
    fNews = FALSE;
    
    initStruct.dwInitType = OEMSIT_MSG;
    initStruct.folderID = 0;
    initStruct.pMsg = pMessage;
    
    if (FOLDER_NEWS == GetFolderType(m_idFolder))
    {
        FOLDERINFO fi = {0};
        TCHAR      sz[1024];

        fNews = TRUE;

        if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &fi)))
        {
            // Set some news-specific fields on the message
            if ((FOLDER_SERVER & fi.dwFlags) == 0)
                MimeOleSetBodyPropA(pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, fi.pszName);

            FOLDERINFO fiServer = {0};

            if (SUCCEEDED(GetFolderServer(m_idFolder, &fiServer)))
            {
                HrSetAccount(pMessage, fiServer.pszName);
                g_pStore->FreeRecord(&fiServer);
            }

            g_pStore->FreeRecord(&fi);
        }
    }
    
    CreateAndShowNote(OENA_COMPOSE, fNews ? OENCF_NEWSFIRST : 0, &initStruct, m_hwndOwner);
    
exit:
    SafeRelease(pMessage);
    
    if (fRelease)
        ReleaseStgMedium(&stg);
    
    return (hr);
}
    



//
//  FUNCTION:   CBaseDataObject::CBaseDataObject
//
//  PURPOSE:    Simple constructor, initializes everything to NULL or zero.
//
CBaseDataObject::CBaseDataObject()
{    
    m_cRef = 1;

    ZeroMemory(m_rgFormatEtc, sizeof(m_rgFormatEtc));
    m_cFormatEtc = 0;
}


//
//  FUNCTION:   CBaseDataObject::~CBaseDataObject
//
//  PURPOSE:    Cleans up any leftover data.
//
CBaseDataObject::~CBaseDataObject()
{
    Assert(m_cRef == 0);    
}


//
//  FUNCTION:   CBaseDataObject::QueryInterface()
//
//  PURPOSE:    Returns a the requested interface if supported.
//
STDMETHODIMP CBaseDataObject::QueryInterface(REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (LPVOID)(IUnknown*) this;
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = (LPVOID)(IDataObject*) this;

    if (NULL == *ppv)
        return (E_NOINTERFACE);

    AddRef();
    return (S_OK);
}


//
//  FUNCTION:   CBaseDataObject::AddRef()
//
//  PURPOSE:    Increments the object reference count.
//
STDMETHODIMP_(ULONG) CBaseDataObject::AddRef(void)
{
    return (++m_cRef);
}


//
//  FUNCTION:   CBaseDataObject::Release()
//
//  PURPOSE:    Decrements the object's ref count. If the ref count hit's zero 
//              the object is freed.
//
STDMETHODIMP_(ULONG) CBaseDataObject::Release(void)
{
    m_cRef--;

    if (0 == m_cRef)
    {
        delete this;
        return (0);
    }

    return (m_cRef);
}


//
//  FUNCTION:   CBaseDataObject::GetDataHere
//
//  PURPOSE:    Returns the object's data in a requested format on the storage
//              the caller allocated.
//
//  PARAMETERS:
//      pFE        - Pointer to the FORMATETC structure that specifies the
//                   format the data is requested in.
//      pStgMedium - Pointer to the STGMEDIUM structure that contains the
//                   medium the caller allocated and the object provides the
//                   data on.
//
//  RETURN VALUE:
//      Returns an HRESULT indicating success or failure.
//
STDMETHODIMP CBaseDataObject::GetDataHere (LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    return E_NOTIMPL;
}


//
//  FUNCTION:   CBaseDataObject::GetCanonicalFormatEtc
//
//  PURPOSE:    Communicates to the caller which FORMATETC data structures
//              produce the same output data.
//
//  PARAMETERS:
//      pFEIn  - Points to the FORMATETC in which the caller wants the returned
//               data.
//      pFEOut - Points to the FORMATETC which is the canonical equivalent of
//               pFEIn.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
STDMETHODIMP CBaseDataObject::GetCanonicalFormatEtc(LPFORMATETC pFEIn,
                                                    LPFORMATETC pFEOut)
{
    if (NULL == pFEOut)
        return (E_INVALIDARG);

    pFEOut->ptd = NULL;
    return (DATA_S_SAMEFORMATETC);
}


//
//  FUNCTION:   CBaseDataObject::EnumFormatEtc
//
//  PURPOSE:    Provides an interface the caller can use to enumerate the
//              FORMATETC's that the data object supports.
//
//  PARAMETERS:
//      dwDirection - DATADIR_GET if the caller wants to enumerate the formats
//                    he can get, or DATADIR_SET if he wants to enumerate the
//                    formats he can set.
//      ppEnum      - Points to the enumerator the caller can use to enumerate.
//
//  RETURN VALUE:
//      Returns S_OK if ppEnum contains the enumerator, or E_NOTIMPL if the
//      direction dwDirection is not supported.
//
STDMETHODIMP CBaseDataObject::EnumFormatEtc(DWORD dwDirection,
                                            IEnumFORMATETC** ppEnum)
{
    LPFORMATETC pFE = 0;
    ULONG       cFE = 0;
    
    if (DATADIR_GET == dwDirection)
    {
        // Create the enumerator and give it our list of formats      
        if (SUCCEEDED(_BuildFormatEtc(NULL, NULL)))
        {
            if (SUCCEEDED(CreateEnumFormatEtc(this, m_cFormatEtc, NULL, m_rgFormatEtc, ppEnum)))
                return (S_OK);
        }
        
        *ppEnum = NULL;
        return (E_FAIL);    
    }
    else
    {
        *ppEnum = NULL;
        return (E_NOTIMPL);
    }
}


//
//  FUNCTION:   CBaseDataObject::SetData
//
//  PURPOSE:    pStgMedium contains data that the caller wants us to store.
//              This data object does not support a caller changing our data.
//
STDMETHODIMP CBaseDataObject::SetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium,
                                      BOOL fRelease)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CBaseDataObject::DAdvise
//
//  PURPOSE:    Creates a connection between the data-transfer object and an
//              advisory sink through which the sink can be informed when the
//              object's data changes.  This object does not support advises.
STDMETHODIMP CBaseDataObject::DAdvise(LPFORMATETC pFE, DWORD advf,
                                      IAdviseSink* ppAdviseSink,
                                      LPDWORD pdwConnection)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CBaseDataObject::DUnadvise
//
//  PURPOSE:    Deletes an advisory connect previously established via DAdvise.
//              This object doesn't support advises.
//
STDMETHODIMP CBaseDataObject::DUnadvise(DWORD dwConnection)
{
    return (E_NOTIMPL);
}

//
//  FUNCTION:   CBaseDataObject::EnumDAdvise
//
//  PURPOSE:    Enumerates the advisory connections previously established via
//              DAdvise.  This object doesn't support advises.
//
STDMETHODIMP CBaseDataObject::EnumDAdvise(IEnumSTATDATA** ppEnumAdvise)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CFolderDataObject::GetData
//
//  PURPOSE:    Returns the object's data in a requested format in the
//              specified storage medium which the object allocates.
//
//  PARAMETERS:
//      pFE        - Pointer to the FORMATETC structure that specifies the
//                   format the data is requested in.
//      pStgMedium - Pointer to the STGMEDIUM structure that contains the
//                   medium the object allocates and provides the data on.
//
//  RETURN VALUE:
//      Returns an HRESULT indicating success or failure.
//
STDMETHODIMP CFolderDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    HRESULT hr;

    // Initialize this
    ZeroMemory(pStgMedium, sizeof(STGMEDIUM));

    if (CF_OEFOLDER == pFE->cfFormat)
        return (_RenderOEFolder(pFE, pStgMedium));
    else if ((CF_TEXT == pFE->cfFormat) || (CF_SHELLURL == pFE->cfFormat))
        return (_RenderTextOrShellURL(pFE, pStgMedium));
    else if ((CF_FILEDESCRIPTORW == pFE->cfFormat) || 
             (CF_FILECONTENTS == pFE->cfFormat) || 
             (CF_FILEDESCRIPTORA == pFE->cfFormat))
    {
        AssertSz(FALSE, "These cases not implemented");
        return (E_NOTIMPL);
    }
    else
        return (DV_E_FORMATETC);   
}


//
//  FUNCTION:   CFolderDataObject::QueryGetData
//
//  PURPOSE:    Determines if a call to GetData() would succeed if it were
//              passed pFE.
//
//  PARAMETERS:
//      pFE - Pointer to the FORMATETC structure to check to see if the data
//            object supports a particular format.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
STDMETHODIMP CFolderDataObject::QueryGetData(LPFORMATETC pFE)
{
    // Make sure this is already built
    _BuildFormatEtc(NULL, NULL);

    // Loop through our formats until we find a match
    for (UINT i = 0; i < m_cFormatEtc; i++)
    {
        if (pFE->cfFormat == m_rgFormatEtc[i].cfFormat && 
            pFE->tymed & m_rgFormatEtc[i].tymed)
        {
            return (S_OK);
        }
    }

    return (DV_E_FORMATETC);
}


//
//  FUNCTION:   CFolderDataObject::_RenderOEFolder()
//
//  PURPOSE:    Renders the data into the CF_OEFOLDER format
//
HRESULT CFolderDataObject::_RenderOEFolder(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    TraceCall("CFolderDataObject::_RenderOEFolder");

    HGLOBAL   hGlobal;
    FOLDERID *pFolderID;

    // We only support HGLOBALs
    if (pFE->tymed & TYMED_HGLOBAL)
    {
        // I just love allocating 4 bytes
        hGlobal = GlobalAlloc(GHND, sizeof(FOLDERID));
        if (NULL == hGlobal)
            return (E_OUTOFMEMORY);

        // Local the memory
        pFolderID = (FOLDERID *) GlobalLock(hGlobal);

        // Set the value
        *pFolderID = m_idFolder;

        // Unlock
        GlobalUnlock(hGlobal);

        // Set up the return value
        pStgMedium->hGlobal = hGlobal;
        pStgMedium->pUnkForRelease = 0;
        pStgMedium->tymed = TYMED_HGLOBAL;

        return (S_OK);
    }

    return (DV_E_TYMED);
}


//
//  FUNCTION:   CFolderDataObject::_RenderShellURL()
//
//  PURPOSE:    Renders the data into the CF_SHELLURL format
//
HRESULT CFolderDataObject::_RenderTextOrShellURL(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    TraceCall("CFolderDataObject::_RenderOEFolder");

    HGLOBAL     hGlobal;
    FOLDERID   *pFolderID;
    FOLDERINFO  rInfo = { 0 };
    TCHAR       szNewsPrefix[] = _T("news://");
    LPTSTR      pszURL;
    DWORD       cch;
    HRESULT     hr;

    // We only support HGLOBALs
    if (!(pFE->tymed & TYMED_HGLOBAL))
    {
        hr = DV_E_TYMED;
        goto exit;
    }

    // Get information about the source folder
    Assert(g_pStore);
    if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rInfo)))
    {
        cch = lstrlen(rInfo.pszName) + lstrlen(szNewsPrefix) + 2;

        // Allocate a buffer for the generated URL
        hGlobal = GlobalAlloc(GHND, sizeof(TCHAR) * cch);
        if (!hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        // Double check that our source file is indeed a newsgroup
        if (pFE->cfFormat == CF_SHELLURL)
        {
            if (!(rInfo.tyFolder == FOLDER_NEWS && !(rInfo.dwFlags & FOLDER_SERVER)))
            {
                hr = E_UNEXPECTED;
                goto exit;
            }

            // Generate a URL from the newsgroup name
            pszURL = (LPTSTR) GlobalLock(hGlobal);
            wnsprintf(pszURL, cch, TEXT("%s%s"), szNewsPrefix, rInfo.pszName);
            GlobalUnlock(hGlobal);
        }
        else if (pFE->cfFormat == CF_TEXT)
        {
            // Copy the folder name to the buffer
            pszURL = (LPTSTR) GlobalLock(hGlobal);
            StrCpyN(pszURL, rInfo.pszName, cch);
            GlobalUnlock(hGlobal);
        }
        else
        {
            AssertSz(FALSE, "CFolderDataObject::_RenderTextOrShellURL() - How did we get here?");
            hr = DV_E_FORMATETC;
            goto exit;
        }

        // Set up the return value
        pStgMedium->hGlobal = hGlobal;
        pStgMedium->pUnkForRelease = 0;
        pStgMedium->tymed = TYMED_HGLOBAL;

        hr = S_OK;
    }

exit:
    if (rInfo.pAllocated)
        g_pStore->FreeRecord(&rInfo);

    return (hr);
}


//
//  FUNCTION:   CMsgDataObject::HrBuildFormatEtc()
//
//  PURPOSE:    Builds the list of FORMATETC structs that this object will 
//              support.  This list is stored in m_rgFormatEtc[].
//
//  PARAMTERS:
//      [out] ppFE  - Returns the arrray of FORMATETC structures
//      [out] pcElt - Returns the size of ppFE
//
//  RETURN VALUE:
//      S_OK
//
HRESULT CFolderDataObject::_BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt)
{
    BOOL        fNews = FALSE;
    FOLDERINFO  rInfo = { 0 };

    // If we haven't built our format list yet, do so first.
    if (FALSE == m_fBuildFE)
    {
        ZeroMemory(&m_rgFormatEtc, sizeof(m_rgFormatEtc));
        m_cFormatEtc = 0;

        // Figure out if this is a news group first
        if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rInfo)))
        {
            fNews = rInfo.tyFolder == FOLDER_NEWS && !(rInfo.dwFlags & FOLDER_SERVER);
            g_pStore->FreeRecord(&rInfo);
        }

        if (fNews)
        {
            SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_SHELLURL, TYMED_HGLOBAL);
            m_cFormatEtc++;
        }

        // Since you can't move a newsgroup, we don't support this format
        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_OEFOLDER, TYMED_HGLOBAL);
        m_cFormatEtc++;

        /*
        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILEDESCRIPTOR, TYMED_HGLOBAL);
        m_cFormatEtc++;
        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILECONTENTS, TYMED_HGLOBAL);
        m_cFormatEtc++;
        */

        m_fBuildFE = TRUE;
    }

    // Return what we have if the caller cares
    if (ppFE && pcElt)
    {
        *ppFE = m_rgFormatEtc;
        *pcElt = m_cFormatEtc;
    }

    return (S_OK);
}


CMessageDataObject::CMessageDataObject()
{
    m_pMsgIDList = NULL;
    m_idSource = FOLDERID_INVALID;
    m_fBuildFE = FALSE;
    m_fDownloaded = FALSE;
}

CMessageDataObject::~CMessageDataObject()
{
}


HRESULT CMessageDataObject::Initialize(LPMESSAGEIDLIST pMsgs, FOLDERID idSource)
{
    IMessageFolder *pFolder = 0;
    HRESULT         hr;
    DWORD           i;
    MESSAGEINFO     rInfo;
    DWORD           cDownloaded = 0;

    m_pMsgIDList = pMsgs;
    m_idSource = idSource;
 
    // Open the folder that contains the message
    if (SUCCEEDED(hr = g_pStore->OpenFolder(m_idSource, NULL, NOFLAGS, &pFolder)))
    {
        // See if they have bodies or not.  All must.
        for (i = 0; i < m_pMsgIDList->cMsgs; i++)
        {
            if (SUCCEEDED(GetMessageInfo(pFolder, m_pMsgIDList->prgidMsg[i], &rInfo)))
            {
                if (rInfo.dwFlags & ARF_HASBODY)
                    cDownloaded++;

                pFolder->FreeRecord(&rInfo);
            }
        }

        pFolder->Release();
    }

    m_fDownloaded = (cDownloaded == m_pMsgIDList->cMsgs);

    return (S_OK);
}



//
//  FUNCTION:   CMessageDataObject::GetData()
//
//  PURPOSE:    Called by the drop target to get the data from the data object.
//
//  PARAMETERS: 
//      LPFORMATETC pFE
//      LPSTGMEDIUM pStgMedium
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    HRESULT hr = DV_E_FORMATETC;

    TraceCall("CMessageDataObject::GetData");

    if (pFE->cfFormat == CF_OEMESSAGES)
        return (_RenderOEMessages(pFE, pStgMedium));

    if (m_fDownloaded)
    {
        IMimeMessage *pMsg = NULL;

        if ((CF_FILEDESCRIPTORW == pFE->cfFormat) ||
            (CF_FILEDESCRIPTORA == pFE->cfFormat))
            return (_RenderFileGroupDescriptor(pFE, pStgMedium));

        if (CF_FILECONTENTS == pFE->cfFormat)
            return (_RenderFileContents(pFE, pStgMedium));

        // Otherwise, do the default action
        if (m_pMsgIDList->cMsgs == 1)
        {
            if (SUCCEEDED(_LoadMessage(0, &pMsg, NULL)))
            {
                IDataObject  *pDataObject = NULL;
                if (SUCCEEDED(pMsg->QueryInterface(IID_IDataObject, (LPVOID *) &pDataObject)))
                {
                    hr = pDataObject->GetData(pFE, pStgMedium);
                    pDataObject->Release();
                }

                pMsg->Release();
            }
        }
    }

    return (hr);
}


//
//  FUNCTION:   CMessageDataObject::QueryGetData
//
//  PURPOSE:    Determines if a call to GetData() would succeed if it were
//              passed pFE.
//
//  PARAMETERS:
//      pFE - Pointer to the FORMATETC structure to check to see if the data
//            object supports a particular format.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
HRESULT CMessageDataObject::QueryGetData(LPFORMATETC pFE)
{
    IMimeMessage *pMsg = 0;
    IDataObject  *pDataObject = 0;
    HRESULT       hr = DV_E_FORMATETC;

    // Walk through the formats we support to see if any match
    if (SUCCEEDED(_BuildFormatEtc(NULL, NULL)))
    {
        for (UINT i = 0; i < m_cFormatEtc; i++)
        {
            if (pFE->cfFormat == m_rgFormatEtc[i].cfFormat &&
                pFE->tymed == m_rgFormatEtc[i].tymed)
            {
                hr = S_OK;
                goto exit;
            }
        }

        // If we have a message object, then ask it for it's formats as well.
        if (m_pMsgIDList->cMsgs == 1)
        {
            if (SUCCEEDED(_LoadMessage(0, &pMsg, NULL)))
            {
                if (SUCCEEDED(pMsg->QueryInterface(IID_IDataObject, (LPVOID *) &pDataObject)))
                {
                    hr = pDataObject->QueryGetData(pFE);
                    pDataObject->Release();
                }

                pMsg->Release();
            }
        }
    }

exit:
    return (hr);
}


HRESULT CMessageDataObject::_BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt)
{
    IEnumFORMATETC *pEnum = 0;
    FORMATETC       fe;
    ULONG           celtFetched;
    IMimeMessage   *pMessage = 0;
    HRESULT         hr = S_OK;

    // Only build our internal list of formats once
    if (FALSE == m_fBuildFE)
    {
        m_cFormatEtc = 0;

        // We always support these formats
        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_OEMESSAGES, TYMED_HGLOBAL);
        m_cFormatEtc++;

        // We support these if the messages are downloaded
        if (m_fDownloaded)
        {
            SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILEDESCRIPTORA, TYMED_HGLOBAL);
            m_cFormatEtc++;
            SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILEDESCRIPTORW, TYMED_HGLOBAL);
            m_cFormatEtc++;
            SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILECONTENTS, TYMED_ISTREAM);
            m_cFormatEtc++;
        }

        // If we're holding just one message, then have the message add it's
        // own formats too.
        if (m_fDownloaded && m_pMsgIDList->cMsgs == 1 && SUCCEEDED(_LoadMessage(0, &pMessage, NULL)))
        {
            IDataObject *pDataObject = 0;

            // Get the data object interface from the message
            if (SUCCEEDED(hr = pMessage->QueryInterface(IID_IDataObject, (LPVOID *) &pDataObject)))
            {
                if (SUCCEEDED(hr = pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
                {
                    pEnum->Reset();
                    while (S_OK == pEnum->Next(1, &fe, &celtFetched))
                    {
                        m_rgFormatEtc[m_cFormatEtc] = fe;
                        m_cFormatEtc++;
                    }

                    pEnum->Release();
                }

                pDataObject->Release();
            }

            pMessage->Release();
        }
    }

    // Return what we have
    if (ppFE && pcElt)
    {
        *ppFE = m_rgFormatEtc;
        *pcElt = m_cFormatEtc;
    }

    return (hr);
}



//
//  FUNCTION:   CMessageDataObject::_LoadMessage()
//
//  PURPOSE:    This function loads the specified message from the store.
//
//  PARAMETERS: 
//      iMsg       - Index into m_rgMsgs of the message desired
//      ppMsg      - Returns a pointer to the message
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageDataObject::_LoadMessage(DWORD iMsg, IMimeMessage **ppMsg, LPWSTR pwszFileExt)
{
    TraceCall("CMessageDataObject::_LoadMessage");

    IMessageFolder    *pFolder = NULL;
    IDataObject       *pDataObj = NULL;
    HRESULT            hr;
    
    // Open the folder that contains the message
    *ppMsg = NULL;
    hr = g_pStore->OpenFolder(m_idSource, NULL, NOFLAGS, &pFolder);
    if (FAILED(hr))
        goto exit;

    // Open the message from the folder
    hr = pFolder->OpenMessage(m_pMsgIDList->prgidMsg[iMsg], 
                              OPEN_MESSAGE_SECURE | OPEN_MESSAGE_CACHEDONLY, 
                              ppMsg, NOSTORECALLBACK);
    if (FAILED(hr))
        goto exit;
                 
    if (pwszFileExt)
    {
        LPTSTR pszNewsgroups = NULL;

        if (SUCCEEDED(MimeOleGetBodyPropA(*ppMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &pszNewsgroups)))
        {
            MemFree(pszNewsgroups);
            AthLoadStringW(idsDefNewsExt, pwszFileExt, 32);
        }
        else
            AthLoadStringW(idsDefMailExt, pwszFileExt, 32);

    }

exit:
    SafeRelease(pFolder);

    if (FAILED(hr))
        SafeRelease((*ppMsg));
        
    return (hr);
}


//
//  FUNCTION:   CMessageDataObject::_RenderOEMessages()
//
//  PURPOSE:    Renders the data from our object into the CF_OEMESSAGES format.
//
//  PARAMETERS: 
//      pFE
//      pStgMedium
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageDataObject::_RenderOEMessages(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    TraceCall("CMessageDataObject::_RenderOEMessages");

    // Make sure the caller want's an HGLOBAL
    if (pFE->tymed != TYMED_HGLOBAL)
        return (DV_E_TYMED);

    // Figure out how much memory to allocate for our returned information
    DWORD cb = sizeof(OEMESSAGES) + (sizeof(MESSAGEID) * m_pMsgIDList->cMsgs);
    
    // Allocate the memory
    HGLOBAL hGlobal = GlobalAlloc(GHND | GMEM_SHARE, cb);
    if (NULL == hGlobal)
        return (E_OUTOFMEMORY);

    OEMESSAGES *pOEMessages = (OEMESSAGES *) GlobalLock(hGlobal);

    // Fill in the basic fields
    pOEMessages->idSource = m_idSource;
    pOEMessages->rMsgIDList = *m_pMsgIDList;
    pOEMessages->rMsgIDList.prgidMsg = (MESSAGEID *) ((LPBYTE) pOEMessages + sizeof(OEMESSAGES));

    // Copy the message ID's
    CopyMemory(pOEMessages->rMsgIDList.prgidMsg, m_pMsgIDList->prgidMsg, sizeof(MESSAGEID) * m_pMsgIDList->cMsgs);
    GlobalUnlock(hGlobal);

    // Fill out the return value info
    pStgMedium->tymed = TYMED_HGLOBAL;
    pStgMedium->hGlobal = hGlobal;
    pStgMedium->pUnkForRelease = 0;

    return (S_OK);
}


//
//  FUNCTION:   CMessageDataObject::_RenderFileContents()
//
//  PURPOSE:    Takes the data that this object contains and renders it into an
//              IStream.
//
//  PARAMETERS:
//      <in>  pFE        - Pointer to the FORMATETC struct that describes the 
//                         type of data requested.
//      <out> pStgMedium - Pointer to where we should return the rendered data.
//
//  RETURN VALUE:
//      DV_E_TYMED - A tymed was requested that we don't support
//      E_OUTOFMEMORY - not enough memory
//      S_OK - Everything succeeded
//
HRESULT CMessageDataObject::_RenderFileContents(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    IMimeMessage *pMsg = 0;
    IDataObject  *pDataObject = 0;
    FORMATETC     feMsg;    
    HRESULT       hr = E_FAIL;
    DWORD               dwFlags = 0;
    
    Assert(pFE->lindex < (int) m_pMsgIDList->cMsgs);
    
    // Get the IDataObject for the specific message
    if (SUCCEEDED(_LoadMessage(pFE->lindex, &pMsg, NULL)))
    {
        // prevent save to file message with label
        pMsg->GetFlags(&dwFlags);
    
        if (IMF_SECURE & dwFlags)
        {
            hr = HandleSecurity(NULL, pMsg);
            if(FAILED(hr))
                goto exit;

            SafeRelease(pMsg);
            if (FAILED(_LoadMessage(pFE->lindex, &pMsg, NULL)))
                goto exit;
        }

        if (SUCCEEDED(pMsg->QueryInterface(IID_IDataObject, (LPVOID *)&pDataObject)))
        {
            SETDefFormatEtc(feMsg, CF_INETMSG, TYMED_ISTREAM);
            hr = pDataObject->GetData(&feMsg, pStgMedium);
        }
    }

exit:
    // Cleanup
    SafeRelease(pMsg);
    SafeRelease(pDataObject);
    
    return (hr);    
}


//
//  FUNCTION:   CMessageDataObject::_RenderFileGroupDescriptor()
//
//  PURPOSE:    Takes the data that this object contains and renders it into a
//              FILEGROUPDESCRIPTOR struct.
//
//  PARAMETERS:
//      <in>  pFE        - Pointer to the FORMATETC struct that describes the 
//                         type of data requested.
//      <out> pStgMedium - Pointer to where we should return the rendered data.
//
//  RETURN VALUE:
//      DV_E_TYMED    - A tymed was requested that we don't support
//      E_OUTOFMEMORY - not enough memory
//      S_OK          - Everything succeeded
//
HRESULT CMessageDataObject::_RenderFileGroupDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    HGLOBAL                 hGlobal = 0;
    FILEGROUPDESCRIPTORA   *pFileGDA = NULL;
    FILEGROUPDESCRIPTORW   *pFileGDW = NULL;
    IMimeMessage           *pMsg = 0;
    PROPVARIANT             pv;
    DWORD                   cMsgs = m_pMsgIDList->cMsgs;
    BOOL                    fWide = (CF_FILEDESCRIPTORW == pFE->cfFormat);
    WCHAR                   wszFileExt[32];
    UINT                    cbDescSize = 0;
    LPWSTR                  pwszSubject = NULL;
    LPSTR                   pszSubject = NULL,
                            pszFileExt = NULL;
    HRESULT                 hr = S_OK;
    UINT                    i = 0;
    
    // Allocate a FILEGROUPDESCRIPTOR struct large enough to contain the names
    // of all the messages we contain.

    cbDescSize = (fWide ? (sizeof(FILEGROUPDESCRIPTORW) + (sizeof(FILEDESCRIPTORW) * (cMsgs - 1))) :
                          (sizeof(FILEGROUPDESCRIPTORA) + (sizeof(FILEDESCRIPTORA) * (cMsgs - 1))));
    IF_NULLEXIT(hGlobal = GlobalAlloc(GHND, cbDescSize));

    pFileGDA = (FILEGROUPDESCRIPTORA *) GlobalLock(hGlobal);
    pFileGDA->cItems = cMsgs;
    pFileGDW = (FILEGROUPDESCRIPTORW *)pFileGDA;
    
    // Copy the file names one at a time into the pFileGDA struct
    for (; i < cMsgs; i++)
    {
        if (SUCCEEDED(_LoadMessage(i, &pMsg, wszFileExt)))
        {
            if (fWide)
            {
                if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pwszSubject)) && pwszSubject && *pwszSubject)
                {
                    wnsprintfW(pFileGDW->fgd[i].cFileName, ARRAYSIZE(pFileGDW->fgd[i].cFileName), L"%.180s.%s", pwszSubject, wszFileExt);
                }
                else
                {
                    WCHAR wszBuf[CCHMAX_STRINGRES];
                    AthLoadStringW(idsMessageFileName, wszBuf, ARRAYSIZE(wszBuf));
                    wnsprintfW(pFileGDW->fgd[i].cFileName, ARRAYSIZE(pFileGDW->fgd[i].cFileName), wszBuf, i + 1, wszFileExt);
                }
            }
            else
            {
                IF_NULLEXIT(pszFileExt = PszToANSI(CP_ACP, wszFileExt));
            
                if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pwszSubject)) && pwszSubject && *pwszSubject)
                {
                    IF_NULLEXIT(pszSubject = PszToANSI(CP_ACP, pwszSubject));
                    wnsprintf(pFileGDA->fgd[i].cFileName, ARRAYSIZE(pFileGDW->fgd[i].cFileName), TEXT("%.180s.%s"), pszSubject, pszFileExt);
                }
                else
                {
                    TCHAR szBuf[CCHMAX_STRINGRES];
                    AthLoadString(idsMessageFileName, szBuf, ARRAYSIZE(szBuf));
                    wnsprintf(pFileGDA->fgd[i].cFileName, ARRAYSIZE(pFileGDW->fgd[i].cFileName), szBuf, i + 1, pszFileExt);
                }
            }
            SafeMemFree(pszSubject);
            SafeMemFree(pwszSubject);
            SafeMemFree(pszFileExt);
            
            if (fWide)
            {
                pFileGDW->fgd[i].dwFlags = FD_FILESIZE | FD_WRITESTIME;
                pFileGDW->fgd[i].nFileSizeHigh = 0;
                pMsg->GetMessageSize(&pFileGDW->fgd[i].nFileSizeLow, 0);
                pv.vt = VT_FILETIME;
                pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &pv);
                pFileGDW->fgd[i].ftLastWriteTime = pv.filetime;

                CleanupFileNameInPlaceW(pFileGDW->fgd[i].cFileName);
            }
            else
            {
                pFileGDA->fgd[i].dwFlags = FD_FILESIZE | FD_WRITESTIME;
                pFileGDA->fgd[i].nFileSizeHigh = 0;
                pMsg->GetMessageSize(&pFileGDA->fgd[i].nFileSizeLow, 0);
                pv.vt = VT_FILETIME;
                pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &pv);
                pFileGDA->fgd[i].ftLastWriteTime = pv.filetime;

                CleanupFileNameInPlaceA(CP_ACP, pFileGDA->fgd[i].cFileName);    
            }
            SafeRelease(pMsg);
        }
    }
    
exit:
    // Put the structure into the STGMEDIUM
    if (hGlobal)
        GlobalUnlock(hGlobal);

    if (SUCCEEDED(hr))
    {
        pStgMedium->hGlobal = hGlobal;
        pStgMedium->pUnkForRelease = NULL;
        pStgMedium->tymed = TYMED_HGLOBAL;
    }

    MemFree(pszSubject);
    MemFree(pwszSubject);
    MemFree(pszFileExt);

    return hr;
}



//
//  FUNCTION:   CShortcutDataObject::GetData
//
//  PURPOSE:    Returns the object's data in a requested format in the
//              specified storage medium which the object allocates.
//
//  PARAMETERS:
//      pFE        - Pointer to the FORMATETC structure that specifies the
//                   format the data is requested in.
//      pStgMedium - Pointer to the STGMEDIUM structure that contains the
//                   medium the object allocates and provides the data on.
//
//  RETURN VALUE:
//      Returns an HRESULT indicating success or failure.
//
STDMETHODIMP CShortcutDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    HRESULT hr;

    // Initialize this
    ZeroMemory(pStgMedium, sizeof(STGMEDIUM));

    // Loop through the format array to see if any of the elements are the
    // same as pFE.
    if (pFE->cfFormat == CF_OESHORTCUT)
        return (_RenderOEShortcut(pFE, pStgMedium));

    else
        return (DV_E_FORMATETC);   
        
}


//
//  FUNCTION:   CShortcutDataObject::QueryGetData
//
//  PURPOSE:    Determines if a call to GetData() would succeed if it were
//              passed pFE.
//
//  PARAMETERS:
//      pFE - Pointer to the FORMATETC structure to check to see if the data
//            object supports a particular format.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
STDMETHODIMP CShortcutDataObject::QueryGetData(LPFORMATETC pFE)
{
    // Make sure this is already built
    _BuildFormatEtc(NULL, NULL);

    // Loop through our formats until we find a match
    for (UINT i = 0; i < m_cFormatEtc; i++)
    {
        if (pFE->cfFormat == m_rgFormatEtc[i].cfFormat && 
            pFE->tymed & m_rgFormatEtc[i].tymed)
        {
            return (S_OK);
        }
    }

    return (DV_E_FORMATETC);
}


//
//  FUNCTION:   CShortcutDataObject::_RenderOEFolder()
//
//  PURPOSE:    Renders the data into the CF_OESHORTCUT format
//
HRESULT CShortcutDataObject::_RenderOEShortcut(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    TraceCall("CShortcutDataObject::_RenderOEShortcut");

    HGLOBAL   hGlobal;
    UINT     *piPos;

    // We only support HGLOBALs
    if (pFE->tymed & TYMED_HGLOBAL)
    {
        // I just love allocating 4 bytes
        hGlobal = GlobalAlloc(GHND, sizeof(FOLDERID));
        if (NULL == hGlobal)
            return (E_OUTOFMEMORY);

        // Local the memory
        piPos = (UINT *) GlobalLock(hGlobal);

        // Set the value
        *piPos = m_iPos;

        // Unlock
        GlobalUnlock(hGlobal);

        // Set up the return value
        pStgMedium->hGlobal = hGlobal;
        pStgMedium->pUnkForRelease = 0;
        pStgMedium->tymed = TYMED_HGLOBAL;

        return (S_OK);
    }

    return (DV_E_TYMED);
}

//
//  FUNCTION:   CShortcutDataObject::HrBuildFormatEtc()
//
//  PURPOSE:    Builds the list of FORMATETC structs that this object will 
//              support.  This list is stored in m_rgFormatEtc[].
//
//  PARAMTERS:
//      [out] ppFE  - Returns the arrray of FORMATETC structures
//      [out] pcElt - Returns the size of ppFE
//
//  RETURN VALUE:
//      S_OK
//
HRESULT CShortcutDataObject::_BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt)
{
    BOOL        fNews = FALSE;
    FOLDERINFO  rInfo = { 0 };

    // If we haven't built our format list yet, do so first.
    if (FALSE == m_fBuildFE)
    {
        ZeroMemory(&m_rgFormatEtc, sizeof(m_rgFormatEtc));
        m_cFormatEtc = 0;

        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_OESHORTCUT, TYMED_HGLOBAL);
        m_cFormatEtc++;

        m_fBuildFE = TRUE;
    }

    // Return what we have if the caller cares
    if (ppFE && pcElt)
    {
        *ppFE = m_rgFormatEtc;
        *pcElt = m_cFormatEtc;
    }

    return (S_OK);
}


//
//  FUNCTION:   FIsFileInsertable()
//
//  PURPOSE:    If there is a single file in the specified HDROP, then we check
//              the mime content type of the file to see if it's text/html or
//              text/plain.  If so, we open the file and return an IStream on
//              that file.
//
//  PARAMETERS:
//      <in>  hDrop    - HDROP handle to check.
//      <out> ppStream - If not NULL and the checks listed above succeed, then
//                       this returns a stream pointer on the file.
//
//  RETURN VALUE:
//      TRUE if the file is insertable as the body of a message
//      FALSE otherwise.
//
BOOL FIsFileInsertable(HDROP hDrop, LPSTREAM *ppStream, BOOL* fHTML)
{
    WCHAR   wszFile[MAX_PATH];
    LPWSTR  pwszCntType = 0,
            pwszCntSubType = 0,
            pwszCntDesc = 0,
            pwszFName = 0;
    BOOL   fReturn = FALSE;
    
    // If there is more than one file then we attach instead
    if (1 == DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0))
    {
        // Get the file name
        DragQueryFileWrapW(hDrop, 0, wszFile, ARRAYSIZE(wszFile));
        
        // Find out it's content type
        MimeOleGetFileInfoW(wszFile, &pwszCntType, &pwszCntSubType, &pwszCntDesc,
            &pwszFName, NULL);
        
        // See if the content is text/plain or text/html
        if ((0 == StrCmpIW(pwszCntType, L"text")) &&
            ((0 == StrCmpIW(pwszCntSubType, L"plain")) ||
             (0 == StrCmpIW(pwszCntSubType, L"html"))))
        {
            if (ppStream)
            {
                // Get a stream on that file
                if (SUCCEEDED(CreateStreamOnHFileW(wszFile, GENERIC_READ, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                    0, ppStream)))
                {
                    fReturn = TRUE;
                    *fHTML = !StrCmpIW(pwszCntSubType, L"html");
                }
            }
        }
    }
    
    MemFree(pwszCntType);
    MemFree(pwszCntSubType);
    MemFree(pwszCntDesc);
    MemFree(pwszFName);
    
    return (fReturn);
}

//
//  FUNCTION:   HrAttachHDrop()
//
//  PURPOSE:    Takes an HDROP handle and attaches the files specified by the
//              HDROP to the specified message object.
//
//  PARAMETERS:
//      <in> pAttList   - Pointer to the attachment list of the object we want
//                        to attach to.
//      <in> hDrop      - HDROP handle with the file information.
//      <in> fMakeLinks - TRUE if the caller wants us to create shortcuts.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT HrAttachHDrop(HWND hwnd, IMimeMessage *pMessage, HDROP hDrop, BOOL fMakeLinks)
{
    HRESULT     hr = S_OK;
    WCHAR       szFile[MAX_PATH];
    UINT        cFiles;
    BOOL        fFirstDirectory = TRUE;
    HCURSOR     hCursor;
    int         id;
    
    // This might take a bit of time
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    // Walk through the drop information
    cFiles = DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0);
    for (UINT i = 0; i < cFiles; i++)
    {
        // Get the name of the i'th file in the drop
        DragQueryFileWrapW(hDrop, i, szFile, ARRAYSIZE(szFile));
        
        // We don't allow the user to attach an entire directory, only link.
        if (!fMakeLinks && PathIsDirectoryW(szFile))
        {
            // Only show this error once
            if (fFirstDirectory)
            {
                id = AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsDropLinkDirs), 0,
                    MB_ICONEXCLAMATION | MB_YESNOCANCEL);
                if (id == IDCANCEL)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                
                // If we can create a link to directories, then add one now.
                if (id == IDYES)
                    HrAddAttachment(pMessage, szFile, NULL, TRUE);
                fFirstDirectory = FALSE;
            }
            
        }
        else
            HrAddAttachment(pMessage, szFile, NULL, fMakeLinks);

    }
    
exit:
    SetCursor(hCursor);
    return (hr);
}


//
//  FUNCTION:   HrAddAttachment()
//
//  PURPOSE:    Adds a file or stream as an attachment to a message object.
//
//  PARAMETERS:
//      <in> pAttList - Attachment list for the message to add to.
//      <in> pszName  - Name of the file to attach.  This is used if pStream
//                      is NULL.
//      <in> pStream  - Stream to add to the message as an attachment.
//      <in> fLink    - TRUE if the caller wants to attach the file as a
//                      shortcut.
//
//  RETURN VALUE:
//      S_OK - The file/stream was attached OK.
//
HRESULT HrAddAttachment(IMimeMessage *pMessage, LPWSTR pszName, LPSTREAM pStream, BOOL fLink)
{
    HRESULT     hr;
    HBODY       hBody;
    IMimeBodyW *pBody = NULL;
    ULONG       cbSize = 0;
    WCHAR       szLinkPath[MAX_PATH];
    LPWSTR      pszFileNameToUse;

    *szLinkPath = 0;

    // If we need to create a link, then call off and do that
    if(fLink)
        CreateNewShortCut(pszName, szLinkPath, ARRAYSIZE(szLinkPath));

    pszFileNameToUse = *szLinkPath ? szLinkPath : pszName;
    
    // Add the attachment based on whether it's a stream or file
    if (pStream)
    {
        hr = pMessage->AttachObject(IID_IStream, (LPVOID)pStream, &hBody);
        if (FAILED(hr))
            return hr;
    }
    else
    {
        LPMIMEMESSAGEW pMsgW = NULL;
        hr = pMessage->QueryInterface(IID_IMimeMessageW, (LPVOID*)&pMsgW);

        if (SUCCEEDED(hr))
            hr = pMsgW->AttachFileW(pszFileNameToUse, NULL, &hBody);

        ReleaseObj(pMsgW);
        if (FAILED(hr))
            return hr;
    }
    
    // Set the display name...
    Assert(hBody);
    hr = pMessage->BindToObject(hBody, IID_IMimeBodyW, (LPVOID *)&pBody);
    if (FAILED(hr))
        return hr;
    
    pBody->SetDisplayNameW(pszFileNameToUse);
    pBody->Release();
    
    // Done
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\envfact.h ===
#ifndef _ENVFACT_H
#define _ENVFACT_H

HRESULT Envelope_WMCommand(HWND hwndCmd, INT id, WORD wCmd);
HRESULT Envelope_AddHostMenu(HMENU hMenuPopup, int iPos);
HRESULT Envelope_FreeGlobals();

#endif //_ENVFACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\dragdrop.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1999  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     dragdrop.h
//
//  PURPOSE:    Contains the definitions for all of Outlook Express's 
//              Drag Drop code.
//

#pragma once

class CStoreDlgCB;

/////////////////////////////////////////////////////////////////////////////
// Data Formats, Types, and Clipboard Formats
//

typedef struct tagOEMESSAGES {
    FOLDERID        idSource;
    MESSAGEIDLIST   rMsgIDList;
} OEMESSAGES;

/////////////////////////////////////////////////////////////////////////////
// Drop Target Class
//

class CDropTarget : public IDropTarget
{
    /////////////////////////////////////////////////////////////////////////
    // Constructors and Destructor
    //
public:
    CDropTarget();
    ~CDropTarget();

    /////////////////////////////////////////////////////////////////////////
    // Initialization
    //
    HRESULT Initialize(HWND hwndOwner, FOLDERID idFolder);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    /////////////////////////////////////////////////////////////////////////
    // IDropTarget
    //
    STDMETHODIMP DragEnter(IDataObject *pDataObject, DWORD grfKeyState,
                           POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pDataObject, DWORD grfKeyState,
                      POINTL pt, DWORD *pdwEffect);

private:
    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    BOOL    _CheckRoundtrip(IDataObject *pDataObject);
    BOOL    _ValidateDropType(CLIPFORMAT cf, IDataObject *pDataObject);
    DWORD   _DragEffectFromFormat(IDataObject *pDataObject, DWORD dwEffectOk, CLIPFORMAT cf, DWORD grfKeyState);
    HRESULT _HandleDrop(IDataObject *pDataObject, DWORD dwEffect, CLIPFORMAT cf, DWORD grfKeyState);
    HRESULT _HandleFolderDrop(IDataObject *pDataObject);
    HRESULT _HandleMessageDrop(IDataObject *pDataObject, BOOL fMove);
    HRESULT _HandleHDrop(IDataObject *pDataObject, CLIPFORMAT cf, DWORD grfKeyState);
    HRESULT _InsertMessagesInStore(HDROP hDrop);
    HRESULT _CreateMessageFromDrop(HWND hwnd, IDataObject *pDataObject, DWORD grfKeyState);

    BOOL    _IsValidOEFolder(IDataObject *pDataObject);
    BOOL    _IsValidOEMessages(IDataObject *pDataObject);

    /////////////////////////////////////////////////////////////////////////
    // Progress Dialog
    static INT_PTR CALLBACK _ProgDlgProcExt(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK _ProgDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL _OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void _SaveNextMessage(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // Object Data
    //
    ULONG           m_cRef;

    HWND            m_hwndOwner;
    FOLDERID        m_idFolder;

    IDataObject    *m_pDataObject;
    CLIPFORMAT      m_cf;

    BOOL            m_fOutbox;

    // Progress Dialog Stuff
    HWND            m_hwndDlg;
    HDROP           m_hDrop;
    DWORD           m_cFiles;
    DWORD           m_iFileCur;
    IMessageFolder *m_pFolder;
    CStoreDlgCB    *m_pStoreCB;
};


/////////////////////////////////////////////////////////////////////////////
// Data Object Classes
//

class CBaseDataObject : public IDataObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //
    CBaseDataObject();
    virtual ~CBaseDataObject();
    
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    //
    STDMETHODIMP         QueryInterface(REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    /////////////////////////////////////////////////////////////////////////
    // IDataObject Interface members
    //
    STDMETHODIMP GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium) = 0;
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE) = 0;
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium,   
                         BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC** ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD advf, 
                         IAdviseSink* ppAdviseSink, LPDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA** ppEnumAdvise);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
protected:
    virtual HRESULT _BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt) = 0;
    
    /////////////////////////////////////////////////////////////////////////
    // Object Attributes
    //
private:
    ULONG           m_cRef;             // Object reference count    

protected:
    FORMATETC       m_rgFormatEtc[10];  // Array of FORMATETC's we support
    ULONG           m_cFormatEtc;       // Number of elements in m_rgFormatEtc
};



class CFolderDataObject : public CBaseDataObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //
    CFolderDataObject(FOLDERID idFolder) : m_idFolder(idFolder), m_fBuildFE(0) {};
    ~CFolderDataObject() {};

    /////////////////////////////////////////////////////////////////////////
    // IDataObject - Overridden from CBaseDataObject2
    //
    STDMETHODIMP GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
protected:
    HRESULT _BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt);
    HRESULT _RenderOEFolder(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    HRESULT _RenderTextOrShellURL(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    
    /////////////////////////////////////////////////////////////////////////
    // Object Attributes
    //
private:
    FOLDERID    m_idFolder;
    BOOL        m_fBuildFE;
};


class CMessageDataObject : public CBaseDataObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //
    CMessageDataObject();
    ~CMessageDataObject();

    HRESULT Initialize(LPMESSAGEIDLIST pMsgs, FOLDERID idSource);

    /////////////////////////////////////////////////////////////////////////
    // IDataObject - Overridden from CBaseDataObject2
    //
    STDMETHODIMP GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
protected:
    HRESULT _BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt);
    HRESULT _LoadMessage(DWORD iMsg, IMimeMessage **ppMsg, LPWSTR pwszFileExt);
    HRESULT _RenderOEMessages(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    HRESULT _RenderFileContents(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    HRESULT _RenderFileGroupDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);

    /////////////////////////////////////////////////////////////////////////
    // Object Attributes
    //
private:
    LPMESSAGEIDLIST     m_pMsgIDList;
    FOLDERID            m_idSource;
    BOOL                m_fBuildFE;
    BOOL                m_fDownloaded;
};

class CShortcutDataObject : public CBaseDataObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //
    CShortcutDataObject(UINT iPos) : m_iPos(iPos), m_fBuildFE(0) {};
    ~CShortcutDataObject() {};

    /////////////////////////////////////////////////////////////////////////
    // IDataObject - Overridden from CBaseDataObject2
    //
    STDMETHODIMP GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
private:
    HRESULT _BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt);
    HRESULT _RenderOEShortcut(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    
    /////////////////////////////////////////////////////////////////////////
    // Object Attributes
    //
private:
    UINT        m_iPos;
    BOOL        m_fBuildFE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\find.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     find.h
//
//  PURPOSE:    
//

#pragma once

#include "mru.h"

#define CCHMAX_FIND 128

class CMessageView;

/////////////////////////////////////////////////////////////////////////////
// Call this to create a finder
//
HRESULT DoFind(HWND hwnd, FOLDERID idFolder);

/////////////////////////////////////////////////////////////////////////////
// Thread entry point for the finder
//

typedef struct tagFINDPARAMS 
{
    FOLDERID idFolder;
} FINDPARAMS, *PFINDPARAMS;

unsigned int __stdcall FindThreadProc2(LPVOID lpvUnused);

/////////////////////////////////////////////////////////////////////////////
// Types used by the class
//

enum 
{
    PAGE_GENERAL = 0,
    PAGE_DATESIZE,
    PAGE_ADVANCED,
    PAGE_MAX
};

typedef struct tagPAGEINFO 
{
    LPTSTR  pszTemplate;
    DLGPROC pfn;            // Pointer to the callback for this page
    int     idsTitle;       // Title for this page
} PAGEINFO, *PPAGEINFO;


/////////////////////////////////////////////////////////////////////////////
// Class CFinder
//

class CFinder : public IOleCommandTarget                
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CFinder();
    ~CFinder();

    HRESULT Show(FINDPARAMS *pFindParams);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    
    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget
    //
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText); 
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

    /////////////////////////////////////////////////////////////////////////
    // Dialog & message handling stuff
    //
    static BOOL CALLBACK GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK DateSizeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK AdvancedDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    static INT_PTR CALLBACK FindDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);
    void OnPaint(HWND hwnd);
    void OnClose(HWND hwnd);
    void OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi);
    UINT OnNCHitTest(HWND hwnd, int x, int y);

//    void OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu);

    HRESULT CmdStop(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdClose(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    /////////////////////////////////////////////////////////////////////////
    // Individual pages
    //
    BOOL CALLBACK _GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL General_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void General_OnSize(HWND hwnd, UINT state, int cx, int cy);
    void General_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    HRESULT _InitMainResizingInfo(HWND hwnd);
    HRESULT _SelectPage(DWORD dwPage);

    /////////////////////////////////////////////////////////////////////////
    // Private class information
    //
private:
    // General Info
    ULONG           m_cRef;                 // Object reference count
    HWND            m_hwnd;                 // Handle of the main finder window
    HWND            m_rgPages[PAGE_MAX];    // Array of handles to the various pages in the dialog
    DWORD           m_dwPageCurrent;        // Currently visible page

    HACCEL          m_hAccel;               // Handle of the accelerator table used for the finder
    HICON           m_hIconTitle;           // Icon for the title bar of the dialog

    CMessageView   *m_pMsgView;

    // State
    BOOL            m_fInProgress;          // TRUE if there is currently a find happening
    BOOL            m_fShowResults;         // TRUE if the dialog is expanded to show results

    // These will be handy to keep around
    HWND            m_hwndTabs;             // Handle of the tab control
    HWND            m_hwndFindNow;          // Handle of the Find Now button
    HWND            m_hwndNewSearch;        // Handle of the New Search button
    HWND            m_hwndFindAni;          // Handle of the Find animation

    // Resizing Info
    RECT            m_rcTabs;               // Position and size of the tab control
    RECT            m_rcFindNow;            // Position and size of the Find Now button
    RECT            m_rcNewSearch;          // Position and size of the New Search button
    RECT            m_rcFindAni;            // Position and size of the Find Animation
    POINT           m_ptDragMin;            // Minimum size of the dialog
    POINT           m_ptWndDefault;         // Default size of the dialog
    DWORD           m_cyDlgFull;            // Full height of the dialog
};


/////////////////////////////////////////////////////////////////////////////
// Find / Find Next utility
//

interface IFindNext : public IUnknown 
{
    STDMETHOD(Show)(THIS_ HWND hwndParent, HWND *pHwnd) PURE;
    STDMETHOD(Close)(THIS) PURE;
    STDMETHOD(TranslateAccelerator)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(GetFindString)(THIS_ LPTSTR psz, DWORD cchMax, BOOL *pfBodies) PURE;
};


class CFindNext : public IFindNext
{
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
public:
    CFindNext();
    ~CFindNext();

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IFindNext
    //
    STDMETHODIMP Show(HWND hwndParent, HWND *phWnd);
    STDMETHODIMP Close(void);
    STDMETHODIMP TranslateAccelerator(LPMSG pMsg);
    STDMETHODIMP GetFindString(LPTSTR psz, DWORD cchMax, BOOL *pfBodies); 

    /////////////////////////////////////////////////////////////////////////
    // Dialog Callback goo
    //
    static INT_PTR CALLBACK FindDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    void OnFindNow(void);

    /////////////////////////////////////////////////////////////////////////
    // Private class information
    //
private:
    ULONG           m_cRef;                 // Object reference count
    HWND            m_hwnd;                 // Handle of the find dialog
    HWND            m_hwndParent;           // Handle of the window that should get notifications
    CMRUList        m_cMRUList;             // MRU List
    BOOL            m_fBodies;              // Body Search
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\finder.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     find.h
//
//  PURPOSE:    
//

#pragma once


/////////////////////////////////////////////////////////////////////////////
// Forward Definitions
//

#include "storutil.h"
#include "msident.h"

class CStatusBar;
class CViewMenu;
interface IMessageList;

/////////////////////////////////////////////////////////////////////////////
// Types
//

typedef struct tagFINDMSG
{
    ULONG    flags;
    LPTSTR   pszFromHeader;
    LPTSTR   pszSubject;
    LPTSTR   pszRecip;
    LPTSTR   pszBody;
    FILETIME ftDateFrom;
    FILETIME ftDateTo;
} FINDMSG;

/////////////////////////////////////////////////////////////////////////////
// FINDERPARAMS
//
// Used to provide initialization information to the finder class
//
typedef struct tagFINDERPARAMS
{
    FOLDERTYPE     ftType;
    FOLDERID       idFolder;       // Currently Selected Folder
} FINDERPARAMS, * PFINDERPARAMS;

/////////////////////////////////////////////////////////////////////////////
// Public Functions 
//

HRESULT DoFindMsg(FOLDERID idFolder, FOLDERTYPE ftFolder);
HRESULT CopyFindInfo(FINDINFO *pFindSrc, FINDINFO *pFindDst);
void    FreeFindInfo(FINDINFO *pFindInfo);
void CloseFinderTreads(void);

/////////////////////////////////////////////////////////////////////////////
// Class CPumpRefCount
//
class CPumpRefCount : public IUnknown
{
public:
    CPumpRefCount() {m_cRef = 1;}
    ~CPumpRefCount() {PostQuitMessage(0);}

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

private:
    ULONG       m_cRef;
};

/////////////////////////////////////////////////////////////////////////////
// Class CFindDlg
//
class CFindDlg : public IDispatch, 
                 public IOleCommandTarget,
                 public IStoreCallback,
                 public ITimeoutCallback,
                 public IIdentityChangeNotify
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CFindDlg();
    ~CFindDlg();

    void Show(PFINDERPARAMS pfindparams);
    void HandleMessage(LPMSG lpmsg);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IDispatch
    //
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return (E_NOTIMPL); }
    STDMETHODIMP GetTypeInfo(unsigned int iTInfo, LCID lcid, ITypeInfo **ppTInfo) { return (E_NOTIMPL); }
    STDMETHODIMP GetTypeInfoCount(unsigned int FAR* pctinfo) { return (E_NOTIMPL); }
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
                        DISPPARAMS* pDispParams, VARIANT* pVarResult,
                        EXCEPINFO* pExcepInfo, unsigned int* puArgErr);

    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget
    //
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                             OLECMDTEXT *pCmdText); 
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                      VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback methods
    //
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, LPSTOREOPERATIONINFO pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback
    //
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

    /////////////////////////////////////////////////////////////////////////
    // IIdentityChangeNotify
    //
    STDMETHODIMP QuerySwitchIdentities();
    STDMETHODIMP SwitchIdentities();
    STDMETHODIMP IdentityInformationChanged(DWORD dwType);

private:
    /////////////////////////////////////////////////////////////////////////
    // Message Handling
    //
    INT_PTR DlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu);
    void OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi);
    void OnWinIniChange(HWND hwnd, LPCTSTR lpszSectionName);
    void OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags);
    void OnDestroy(HWND hwnd);
    void OnPaint(HWND hwnd);
    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);

    HRESULT CmdOpen(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdOpenFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdReplyForward(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCancelMessage(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdFindNow(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdStop(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdReset(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdBrowseForFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdBlockSender(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCreateRule(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCombineAndDecode(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    static INT_PTR CALLBACK ExtFindMsgDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    BOOL    _IsFindEnabled(HWND hwnd);
    void    _ShowResults(HWND hwnd);
    void    _OnFindNow(HWND hwnd);
    FOLDERID _GetCurSel(HWND hwnd);
    void    _StartFind(FOLDERID idFolder, BOOL fSubFolders);

    BOOL    _GetFindValues(HWND hwnd, FINDINFO *pfi);
    void    _SetFindValues(HWND hwnd, FINDINFO *pfi);
    void    _FreeFindInfo(FINDINFO *pfi);
    void    _SetFindIntlFont(HWND hwnd);

    void    _InitSizingInfo(HWND hwnd);

    /////////////////////////////////////////////////////////////////////////
    // Private Class Information
    //
private:
    // Basic Information
    ULONG               m_cRef;
    HWND                m_hwnd;
    FINDINFO            m_rFindInfo;
    HWND                m_hwndList;
    HTIMEOUT            m_hTimeout;
    HACCEL              m_hAccel;

    // Groovy Interface Pointers
    CStatusBar         *m_pStatusBar;    
    IMessageList       *m_pMsgList;
    IOleCommandTarget  *m_pMsgListCT;
    IOperationCancel   *m_pCancel;
    CPumpRefCount      *m_pPumpRefCount;
    HWNDLIST            m_hlDisabled;

    // Sizing information
    int                 m_xBtn;
    int                 m_yBrowse;
    int                 m_dxBtnGap;
    int                 m_dxBtn;
    int                 m_yBtn;
    int                 m_dyBtn;
    int                 m_cxEdit;
    int                 m_xEdit;
    int                 m_cyEdit;
    int                 m_yView;
    int                 m_cxDlgDef;
    int                 m_cyDlgFull;
    int                 m_xIncSub;
    int                 m_yIncSub;
    int                 m_cxFolder;
    int                 m_cxStatic;

    // State
    BOOL                m_fShowResults;
    BOOL                m_fAbort;
    BOOL                m_fClose;
    BOOL                m_fInProgress;
    ULONG               m_ulPct;
    BOOL                m_fFindComplete;

    POINT               m_ptDragMin;
    HICON               m_hIcon,
                        m_hIconSm;

    DWORD               m_dwCookie;
    BOOL                m_fProgressBar,
                        m_fInternal;
    DWORD               m_dwIdentCookie;
    
    // For View.Current View menu
    CViewMenu          *m_pViewMenu;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\find.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     find.cpp
//
//  PURPOSE:    
//

#include "pch.hxx"
#include "find.h"
#include "findres.h"
#include "menures.h"
#include "instance.h"
#include "msgview.h"
#include "menuutil.h"
#include "finder.h"
#include "shlwapip.h"

// These will be handy
inline _width(RECT rc) { return (rc.right - rc.left); }
inline _height(RECT rc) { return (rc.bottom - rc.top); }
inline UINT _GetTextLength(HWND hwnd, DWORD id) { return (UINT) SendDlgItemMessage(hwnd, id, WM_GETTEXTLENGTH, 0, 0); }

/////////////////////////////////////////////////////////////////////////////
// CFindNext
//

CFindNext::CFindNext()
{
    m_cRef = 1;
    m_hwnd = NULL;
    m_hwndParent = NULL;
}


CFindNext::~CFindNext()
{
    Assert(!IsWindow(m_hwnd));
    SetDwOption(OPT_SEARCH_BODIES, m_fBodies, 0, 0);
}


//
//  FUNCTION:   CFindNext::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CFindNext::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CFindNext::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (LPVOID) (IOleCommandTarget *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CFindNext::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CFindNext::AddRef(void)
{
    TraceCall("CFindNext::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CFindNext::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CFindNext::Release(void)
{
    TraceCall("CFindNext::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


//
//  FUNCTION:   CFindNext::Show()
//
//  PURPOSE:    Causes the dialog to be created and displayed
//
//  PARAMETERS: 
//      [in]  hwndParent - Handle of the parent for the dialog 
//      [out] phWnd - Returns the handle of the new dialog window
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindNext::Show(HWND hwndParent, HWND *phWnd)
{
    int iReturn;

    TraceCall("CFindNext::Show");

    if (!IsWindow(hwndParent))
        return (E_INVALIDARG);

    // Create the dialog box
    iReturn = (int) DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(IDD_FIND_NEXT), hwndParent,
                             FindDlgProc, (LPARAM) this);
    return (iReturn ? S_OK : E_FAIL);
}


//
//  FUNCTION:   CFindNext::Close()
//
//  PURPOSE:    Causes the find dialog to be closed.
//
HRESULT CFindNext::Close(void)
{
    TraceCall("CFindNext::Close");

    if (IsWindow(m_hwnd))
    {
        EndDialog(m_hwnd, 0);
        m_hwnd = NULL;
    }

    return (S_OK);
}


//
//  FUNCTION:   CFindNext::TranslateAccelerator()
//
//  PURPOSE:    Called by the parent to allow us to translate our own 
//              messages.
//
//  PARAMETERS: 
//      LPMSG pMsg
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindNext::TranslateAccelerator(LPMSG pMsg)
{
    if ((pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_F3))
        OnFindNow();
    else if (IsDialogMessageWrapW(m_hwnd, pMsg))
        return (S_OK);

    return (S_FALSE);
}


//
//  FUNCTION:   CFindNext::GetFindString()
//
//  PURPOSE:    Get's the current search string from the dialog
//
//  PARAMETERS: 
//      [in, out] psz - Buffer to copy the string into
//      [in] cchMax - Size of psz.
//
HRESULT CFindNext::GetFindString(LPTSTR psz, DWORD cchMax, BOOL *pfBodies)
{
    TraceCall("CFindNext::GetFindString");

    if (!psz || !cchMax || !pfBodies)
        return (E_INVALIDARG);

    // Get the current contents of the combo box
    m_cMRUList.EnumList(0, psz, cchMax);
    if (pfBodies)
        *pfBodies = m_fBodies;

    return (S_OK);
}


//
//  FUNCTION:   CFindNext::FindDlgProc()
//
//  PURPOSE:    Static callback for the dialog proc.  Does the work of finding
//              the correct this pointer and sending the messages to that 
//              callback.
//
INT_PTR CALLBACK CFindNext::FindDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CFindNext *pThis;

    if (uMsg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CFindNext *) lParam;
    }
    else
        pThis = (CFindNext *) GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return (pThis->DlgProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);
}

static const HELPMAP g_rgCtxMapFindNext[] = {
    {IDC_FIND_HISTORY, 50300},
    {IDC_ALL_TEXT, 50310},
    {IDC_FIND_NOW, 50305},
    {IDC_ADVANCED, 50315},
    {0, 0}
};

INT_PTR CALLBACK CFindNext::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, OnInitDialog);

        case WM_COMMAND:
            return (BOOL) HANDLE_WM_COMMAND(hwnd, wParam, lParam, OnCommand);     

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapFindNext);
    }

    return (FALSE);
}


//
//  FUNCTION:   CFindNext::OnInitDialog()
//
//  PURPOSE:    Initializes the UI for the dialog.
//
//  PARAMETERS: 
//      [in] hwnd - Handle of the dialog being created
//      [in] hwndFocus - Handle of the control that should have focus
//      [in] lParam - Initialization data.
//
//  RETURN VALUE:
//      Returns TRUE to let windows set the focus
//
BOOL CFindNext::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR sz[256];
    UINT  nItem = 0;

    TraceCall("CFindNext::OnInitDialog");
    
    m_hwnd = hwnd;
    SendDlgItemMessage(hwnd, IDC_FIND_HISTORY, CB_LIMITTEXT, CCHMAX_FIND, 0);
    SetIntlFont(GetDlgItem(hwnd, IDC_FIND_HISTORY));

    m_fBodies = DwGetOption(OPT_SEARCH_BODIES);
    if (m_fBodies)
        SendDlgItemMessage(hwnd, IDC_ALL_TEXT, BM_SETCHECK, 1, 0);

    // Got's to load the find history
    m_cMRUList.CreateList(10, 0, c_szRegFindHistory);    

    while (-1 != m_cMRUList.EnumList(nItem++, sz, ARRAYSIZE(sz)))
    {
        SendDlgItemMessage(hwnd, IDC_FIND_HISTORY, CB_ADDSTRING, 0, (LPARAM) sz);
    }

    // Disable the Find button
    EnableWindow(GetDlgItem(hwnd, IDC_FIND_NOW), FALSE);
    CenterDialog(m_hwnd);

    return (TRUE);
}


//
//  FUNCTION:   CFindNext::OnCommand()
//
//  PURPOSE:    Handles command messages that are sent from the various 
//              controls in the dialog.
//
void CFindNext::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    TraceCall("CFindNext::OnCommand");

    switch (id)
    {
        case IDC_FIND_HISTORY:
        {
            switch (codeNotify)
            {
                case CBN_EDITCHANGE:
                    EnableWindow(GetDlgItem(m_hwnd, IDC_FIND_NOW),
                                 _GetTextLength(m_hwnd, IDC_FIND_HISTORY));
                    break;

                case CBN_SELCHANGE:
                    EnableWindow(GetDlgItem(m_hwnd, IDC_FIND_NOW), TRUE);
                    break;
            }

            break;
        }

        case IDC_ALL_TEXT:
        {
            m_fBodies = (BST_CHECKED == IsDlgButtonChecked(m_hwnd, IDC_ALL_TEXT));
            break;
        }

        case IDC_FIND_NOW:
        {
            if (codeNotify == BN_CLICKED)
            {
                OnFindNow();
            }

            break;
        }

        case IDC_ADVANCED:
        {
            if (codeNotify == BN_CLICKED)
            {
                DoFindMsg(FOLDERID_ROOT, 0);
            }

            break;
        }

        case IDCANCEL:
        case IDCLOSE:
            EndDialog(hwnd, 0);
            break;
    }
}


void CFindNext::OnFindNow(void)
{
    TCHAR sz[CCHMAX_STRINGRES];
    int   i;

    // Get the current string
    GetWindowText(GetDlgItem(m_hwnd, IDC_FIND_HISTORY), sz, ARRAYSIZE(sz));

    // Add this string to our history 
    i = m_cMRUList.AddString(sz);

    // Reload the combo box
    UINT  nItem = 0;
    HWND hwndCombo = GetDlgItem(m_hwnd, IDC_FIND_HISTORY);
    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);

    while (-1 != m_cMRUList.EnumList(nItem++, sz, ARRAYSIZE(sz)))
    {
        SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM) sz);
    }
    SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);

    EndDialog(m_hwnd, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\envfact.cpp ===
/*
 *    e n v f a c t . c p p
 *    
 *    Purpose:
 *        Office-Envelope Host factory
 *    
 *    Owner:
 *        brettm.
 *
 *  History:
 *      July '95: Created
 *    
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */
#include <pch.hxx>
#include <mimeole.h>
#include <envelope.h>
#include <mso.h>
#include <envguid.h>
#include "envfact.h"
#include "regutil.h"
#include "demand.h"
#include "menures.h"

class CEnvFactory
{
public:

    CEnvFactory();
    virtual ~CEnvFactory();

    ULONG AddRef();
    ULONG Release();

    HRESULT Init();
    HRESULT OnWMCommand(HWND hwndCmd, INT id, WORD wCmd);
    HRESULT AddEnvHostMenu(HMENU hMenuPopup, int iPos);

private:
    ULONG   m_cRef;
    HMENU   m_hMenu;

    HRESULT BuildPopupMenu();
    HRESULT CreateEnvHost(HWND hwnd, LPSTR pszCLSID);
    HRESULT DestroyMenu(HMENU hMenu);
};


static CEnvFactory *g_pEnvFactory=0;

HRESULT EnsureEnvFactory();

CEnvFactory::CEnvFactory()
{
    m_cRef = 1;
    m_hMenu = NULL;
}

CEnvFactory::~CEnvFactory()
{
    if (m_hMenu)
        {
        Assert(IsMenu(m_hMenu));
        DestroyMenu(m_hMenu);
        }
}


ULONG CEnvFactory::AddRef()
{
    return ++m_cRef;
}

ULONG CEnvFactory::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


HRESULT CEnvFactory::Init()
{
    return S_OK;
}


HRESULT CEnvFactory::BuildPopupMenu()
{
    HKEY            hKey,
                    hKeyHost;
    int             i;
    ULONG           cb;
    TCHAR           rgch[MAX_PATH];
    TCHAR           rgchCLSID[MAX_PATH];
    LONG            lResult;
    HMENU           hMenu;
    MENUITEMINFO    mii;
    HRESULT         hr=E_FAIL;
    int             idm = ID_ENVELOPE_HOST_FIRST;
    DWORD           dwType;

    hMenu = CreatePopupMenu();
    if (!hMenu)
        return E_OUTOFMEMORY;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA|MIIM_TYPE|MIIM_ID;
    mii.fType = MFT_STRING;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szEnvHostClientPath, 0, KEY_READ, &hKey))
        {
        cb = sizeof(rgch);

        // Enumerate through the keys
        for (i = 0; ; i++)
            {
            // Enumerate Friendly Names
            cb = sizeof(rgch);
            lResult = RegEnumKeyEx(hKey, i, rgch, &cb, 0, NULL, NULL, NULL);

            // No more items
            if (lResult == ERROR_NO_MORE_ITEMS)
                break;

            // Error, lets move onto the next account
            if (lResult != ERROR_SUCCESS)
                break;

            // Lets open they server key
            if (RegOpenKeyEx(hKey, rgch, 0, KEY_READ, &hKeyHost) != ERROR_SUCCESS)
                continue;

            cb = sizeof(rgch);
            if (ERROR_SUCCESS == RegQueryValueEx(hKeyHost, NULL, 0, &dwType, (LPBYTE)rgch, &cb) && cb)
                {
                cb = sizeof(rgchCLSID);
                if (GetCLSIDFromSubKey(hKeyHost, rgchCLSID, &cb)==S_OK)
                    {
                    mii.dwTypeData = rgch;
                    mii.cch = lstrlen(rgch);
                    mii.dwItemData = (DWORD_PTR)PszDupA(rgchCLSID);
                    mii.wID = idm++;
                    if (InsertMenuItem(hMenu, 0, TRUE, &mii))
                        hr = S_OK;
                    }
                }
            RegCloseKey(hKeyHost);
            }
        RegCloseKey(hKey);
        }

    if (!FAILED(hr))
        m_hMenu = hMenu;
    else
        DestroyMenu(hMenu);

    return hr;
}

HRESULT CEnvFactory::OnWMCommand(HWND hwndCmd, INT id, WORD wCmd)
{
    MENUITEMINFO    mii;

    if (id >= ID_ENVELOPE_HOST_FIRST && id <= ID_ENVELOPE_HOST_LAST)
        {
        Assert (m_hMenu && IsMenu(m_hMenu));
        mii.fMask = MIIM_DATA;
        mii.cbSize = sizeof(MENUITEMINFO);
        SideAssert(GetMenuItemInfo(m_hMenu, id, FALSE, &mii));
        CreateEnvHost(hwndCmd, (LPSTR)mii.dwItemData);
        return S_OK;
        }

    return S_FALSE;
}

HRESULT CEnvFactory::DestroyMenu(HMENU hMenu)
{
    ULONG           uItem,
                    cItems;
    MENUITEMINFO    mii;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA;
    cItems = GetMenuItemCount(hMenu);
    
    for (uItem = 0; uItem < cItems; uItem++)
        {
        if (GetMenuItemInfo(hMenu, uItem, TRUE, &mii) && mii.dwItemData)
            MemFree((LPVOID)mii.dwItemData);
        }

    ::DestroyMenu(hMenu);
    return S_OK;
}


HRESULT CEnvFactory::CreateEnvHost(HWND hwnd, LPSTR pszCLSID)
{
    IMsoEnvelopeHost   *pHost = NULL;
    HRESULT             hr = S_OK;
    TCHAR               rgch[CCHMAX_STRINGRES];
    TCHAR               rgchErr[CCHMAX_STRINGRES+50];
    CLSID               clsid;
    UINT                idsErr = idsErrEnvHostCreateNote;
    LPWSTR              pwszCLSID;
    

    IF_NULLEXIT(pwszCLSID = PszToUnicode(CP_ACP, pszCLSID));

    IF_FAILEXIT(hr = CLSIDFromString(pwszCLSID, &clsid));

    IF_FAILEXIT(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER|CLSCTX_LOCAL_SERVER, 
                                      IID_IMsoEnvelopeHost, (LPVOID *)&pHost));

    idsErr = idsErrEnvHostCoCreate;

    IF_FAILEXIT(hr = pHost->CreateNote(NULL, CLSID_OEEnvelope, NULL, NULL, NULL, 0));
    
exit:
    if (FAILED(hr))
    {
        LoadString(g_hLocRes, idsErr, rgch, ARRAYSIZE(rgch));
        wnsprintf(rgchErr, ARRAYSIZE(rgchErr), "%s\nhr=0x%x", rgch, hr);
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), rgchErr, NULL, MB_OK);
    }

    ReleaseObj(pHost);
    MemFree(pwszCLSID);
    return hr;
}




HRESULT CEnvFactory::AddEnvHostMenu(HMENU hMenuPopup, int iPos)
{
    MENUITEMINFO    mii;
    TCHAR           rgch[CCHMAX_STRINGRES];

    if (!m_hMenu)
        BuildPopupMenu();

    if (m_hMenu)
        {
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE|MIIM_SUBMENU|MIIM_ID;
        mii.fType = MFT_STRING;
        mii.wID = ID_POPUP_ENVELOPE_HOST;
        LoadString(g_hLocRes, idsCreateEnvHostPoupMenu, rgch, ARRAYSIZE(rgch));
        mii.dwTypeData = rgch;
        mii.cch = lstrlen(rgch);
        mii.hSubMenu = m_hMenu;
        InsertMenuItem(hMenuPopup, iPos, TRUE, &mii);
        }
    return S_OK;
}




HRESULT Envelope_WMCommand(HWND hwndCmd, INT id, WORD wCmd)
{
    if (EnsureEnvFactory() != S_OK)
        return E_FAIL;

    return g_pEnvFactory->OnWMCommand(hwndCmd, id, wCmd);
}

HRESULT Envelope_AddHostMenu(HMENU hMenuPopup, int iPos)
{
    if (EnsureEnvFactory() != S_OK)
        return E_FAIL;

    return g_pEnvFactory->AddEnvHostMenu(hMenuPopup, iPos);
}


HRESULT EnsureEnvFactory()
{
    HRESULT hr = S_OK;

    if (!g_pEnvFactory)
        {
        g_pEnvFactory = new CEnvFactory();
        if (!g_pEnvFactory)
            return E_OUTOFMEMORY;

        hr = g_pEnvFactory->Init();
        }
    return hr;
}

HRESULT Envelope_FreeGlobals()
{
    SafeRelease(g_pEnvFactory);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\flagconv.cpp ===
//
//  Flag conversion routines...
//  One wishes we didn't need these
//

#include <pch.hxx>
#include "imsgcont.h"
#include "imnxport.h"

DWORD DwConvertSCFStoARF(DWORD dwSCFS)
{
    register DWORD dwRet = 0;

    if (dwSCFS & SCFS_NOSECUI)
        dwRet |= ARF_NOSECUI;
    return dwRet;
}

//***************************************************************************
// Function: DwConvertARFtoIMAP
//
// Purpose:
//   This function takes ARF_* message flags (such as ARF_READ) and maps
// them to IMAP_MSG_FLAGS such as IMAP_MSG_SEEN.
//
// Arguments:
//   DWORD dwARFFlags [in] - ARF_* flags to convert.
//
// Returns:
//   DWORD with the appropriate IMAP_MSG_FLAGS set.
//***************************************************************************
DWORD DwConvertARFtoIMAP(DWORD dwARFFlags)
{
    DWORD dwIMAPFlags = 0;

    Assert(0x0000001F == IMAP_MSG_ALLFLAGS); // Update this function if we get new IMAP flags

    if (dwARFFlags & ARF_REPLIED)
        dwIMAPFlags |= IMAP_MSG_ANSWERED;

    if (dwARFFlags & ARF_FLAGGED)
        dwIMAPFlags |= IMAP_MSG_FLAGGED;

    if (dwARFFlags & ARF_ENDANGERED)
        dwIMAPFlags |= IMAP_MSG_DELETED;

    if (dwARFFlags & ARF_READ)
        dwIMAPFlags |= IMAP_MSG_SEEN;

    if (dwARFFlags & ARF_UNSENT)
        dwIMAPFlags |= IMAP_MSG_DRAFT;

    return dwIMAPFlags;
} // DwConvertARFtoIMAP



//***************************************************************************
// Function: DwConvertIMAPtoARF
//
// Purpose:
//   This function takes IMAP message flags (such as IMAP_MSG_DELETED) and
// maps them to flags suitable for storing in the proptree cache
// (eg, ARF_ENDANGERED).
//
// Arguments:
//   DWORD dwIMAPFlags [in] - IMAP message flags (IMAP_MSGFLAGS) to convert.
//
// Returns:
//   DWORD with appropriate ARF flags set.
//***************************************************************************
DWORD DwConvertIMAPtoARF(DWORD dwIMAPFlags)
{
    DWORD dwARFFlags = 0;

    Assert(0x0000001F == IMAP_MSG_ALLFLAGS); // Update this function if we get more IMAP flags

    if (dwIMAPFlags & IMAP_MSG_ANSWERED)
        dwARFFlags |= ARF_REPLIED;

    if (dwIMAPFlags & IMAP_MSG_FLAGGED)
        dwARFFlags |= ARF_FLAGGED;

    if (dwIMAPFlags & IMAP_MSG_DELETED)
        dwARFFlags |= ARF_ENDANGERED;

    if (dwIMAPFlags & IMAP_MSG_SEEN)
        dwARFFlags |= ARF_READ;

    if (dwIMAPFlags & IMAP_MSG_DRAFT)
        dwARFFlags |= ARF_UNSENT;

    return dwARFFlags;
} // DwConvertIMAPtoARF



DWORD DwConvertIMAPMboxToFOLDER(DWORD dwImapMbox)
{
    DWORD dwRet = 0;

    AssertSz(IMAP_MBOX_ALLFLAGS == 0x0000000F, "This function needs updating!");

    if (IMAP_MBOX_NOINFERIORS & dwImapMbox)
        dwRet |= FOLDER_NOCHILDCREATE;

    if (IMAP_MBOX_NOSELECT & dwImapMbox)
        dwRet |= FOLDER_NOSELECT;

    return dwRet;
} // DwConvertIMAPMboxToFOLDER



MESSAGEFLAGS ConvertIMFFlagsToARF(DWORD dwIMFFlags)
{
    MESSAGEFLAGS    mfResult = 0;

    // IMF_ATTACHMENTS
    if (ISFLAGSET(dwIMFFlags, IMF_ATTACHMENTS))
        FLAGSET(mfResult, ARF_HASATTACH);

    // IMF_SIGNED
    if (ISFLAGSET(dwIMFFlags, IMF_SIGNED))
        FLAGSET(mfResult, ARF_SIGNED);

    // IMF_ENCRYPTED
    if (ISFLAGSET(dwIMFFlags, IMF_ENCRYPTED))
        FLAGSET(mfResult, ARF_ENCRYPTED);

    // IMF_VOICEMAIL
    if (ISFLAGSET(dwIMFFlags, IMF_VOICEMAIL))
        FLAGSET(mfResult, ARF_VOICEMAIL);

    // IMF_NEWS
    if (ISFLAGSET(dwIMFFlags, IMF_NEWS))
        FLAGSET(mfResult, ARF_NEWSMSG);

    return mfResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\flagconv.h ===
//
//  Flag conversion routines...
//

// Bring in only once
#pragma once

DWORD DwConvertSCFStoARF(DWORD dwSCFS);
DWORD DwConvertARFtoIMAP(DWORD dwARFFlags);
DWORD DwConvertIMAPtoARF(DWORD dwIMAPFlags);
DWORD DwConvertIMAPMboxToFOLDER(DWORD dwImapMbox);
MESSAGEFLAGS ConvertIMFFlagsToARF(DWORD dwIMFFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\finder.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     finder.cpp
//
//  PURPOSE:    
//

#include "pch.hxx"
#include <process.h>
#include "resource.h"
#include "error.h"
#include "finder.h"
#include "goptions.h"
#include "menuutil.h"
#include "statbar.h"
#include "imnact.h"
#include "note.h"
#include "mailutil.h"
#include "statnery.h"
#include "instance.h"
#include "msoeobj.h"
#include "msglist.h"
#include "storutil.h"
#include "menures.h"
#include "findres.h"
#include "multiusr.h"
#include "newsutil.h"
#include "ruleutil.h"
#include "instance.h"
#include "shlwapip.h"
#include "demand.h"
#include "dllmain.h"
#include "order.h"

ASSERTDATA

#define MF_ENABLEFLAGS(b)   (MF_BYCOMMAND|(b ? MF_ENABLED : MF_GRAYED | MF_DISABLED))


typedef struct _ThreadList
{
    DWORD                   dwThreadID;
    struct _ThreadList   *  pPrev;
    struct _ThreadList   *  pNext;
} OETHREADLIST;

OETHREADLIST * g_pOEThrList = NULL;

// Add thread to list
OETHREADLIST * AddThreadToList(DWORD uiThreadId, OETHREADLIST * pThrList)
{
    if(!pThrList)
    {
        if(MemAlloc((LPVOID *) &pThrList, sizeof(OETHREADLIST)))
        {

            pThrList->pPrev = NULL;
            pThrList->pNext = NULL;
            pThrList->dwThreadID = uiThreadId;
        }
    }    
    else 
        pThrList->pNext = AddThreadToList(uiThreadId, pThrList->pNext);

    return(pThrList);
}

// Remove thread from list
OETHREADLIST * DelThreadToList(DWORD uiThreadId, OETHREADLIST * pThrList)
{
    OETHREADLIST * pLst = NULL;

    if(!pThrList)
        return(NULL);
    else if(pThrList->dwThreadID == uiThreadId)
    {
        if(pThrList->pPrev)
        {
            pThrList->pPrev->pNext = pThrList->pNext;
            pLst = pThrList->pPrev; 
        }
        if(pThrList->pNext)
        {
            pThrList->pNext->pPrev = pThrList->pPrev;
            if(!pLst)
                pLst = pThrList->pNext;
        }

        MemFree(pThrList);
        pThrList = NULL;
    }
    else 
        pThrList->pNext = DelThreadToList(uiThreadId, pThrList->pNext);

    return pLst;
}

// Close all Finder windows
void CloseAllFindWnds(HWND hwnd, OETHREADLIST * pThrList)
{
    while(pThrList)
    {
        CloseThreadWindows(hwnd, pThrList->dwThreadID);
        pThrList = pThrList->pNext;
    }
}


void CloseFinderTreads()
{
    CloseAllFindWnds(NULL, g_pOEThrList);
}

/////////////////////////////////////////////////////////////////////////////
// Thread entry point for the finder
//
unsigned int __stdcall FindThreadProc(LPVOID lpvUnused);


HRESULT CPumpRefCount::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CPumpRefCount::QueryInterface");
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *)this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


ULONG CPumpRefCount::AddRef(void)
{
    TraceCall("CPumpRefCount::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


ULONG CPumpRefCount::Release(void)
{
    TraceCall("CPumpRefCount::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


//
//  FUNCTION:   FreeFindInfo
//
void FreeFindInfo(FINDINFO *pFindInfo)
{
    SafeMemFree(pFindInfo->pszFrom);
    SafeMemFree(pFindInfo->pszSubject);
    SafeMemFree(pFindInfo->pszTo);
    SafeMemFree(pFindInfo->pszBody);
    ZeroMemory(pFindInfo, sizeof(FINDINFO));
}

//
//  FUNCTION:   CopyFindInfo
//
HRESULT CopyFindInfo(FINDINFO *pFindSrc, FINDINFO *pFindDst)
{
    // Locals
    HRESULT     hr=S_OK;

    // Zero
    ZeroMemory(pFindDst, sizeof(FINDINFO));

    // Duplicate
    pFindDst->mask = pFindSrc->mask;
    pFindDst->ftDateFrom = pFindSrc->ftDateFrom;
    pFindDst->ftDateTo = pFindSrc->ftDateTo;
    pFindDst->fSubFolders = pFindSrc->fSubFolders;

    // pszFrom
    if (pFindSrc->pszFrom)
    {
        // Duplicate the String
        IF_NULLEXIT(pFindDst->pszFrom = PszDupA(pFindSrc->pszFrom));
    }

    // pszTo
    if (pFindSrc->pszTo)
    {
        // Duplicate the String
        IF_NULLEXIT(pFindDst->pszTo = PszDupA(pFindSrc->pszTo));
    }

    // pszSubject
    if (pFindSrc->pszSubject)
    {
        // Duplicate the String
        IF_NULLEXIT(pFindDst->pszSubject = PszDupA(pFindSrc->pszSubject));
    }

    // pszBody
    if (pFindSrc->pszBody)
    {
        // Duplicate the String
        IF_NULLEXIT(pFindDst->pszBody = PszDupA(pFindSrc->pszBody));
    }

exit:
    // Done
    return hr;
}


//
//  FUNCTION:   DoFindMsg()
//
//  PURPOSE:    Instantiates the finder object on a separate thread.
//
//  PARAMETERS: 
//      [in] pidl - Folder to default the search in
//      [in] ftType - Type of folders being searched
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT DoFindMsg(FOLDERID idFolder, FOLDERTYPE ftType)
{
    HRESULT         hr = S_OK;
    HTHREAD         hThread = NULL;
    DWORD           uiThreadId = 0;
    FINDERPARAMS *  pFindParams = NULL;
    
    // Allocate a structure to hold the initialization information that we can
    // pass to the other thread.

    IF_NULLEXIT(pFindParams = new FINDERPARAMS);

    // Initialzie the find
    pFindParams->idFolder = idFolder;
    pFindParams->ftType = ftType;
    
    // Create another thread to do the search on
    hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)FindThreadProc, (LPVOID) pFindParams, 0, &uiThreadId);
    if (NULL == hThread)
        IF_FAILEXIT(hr = E_FAIL);

    // NULL this out so we don't free it later.  The other thread owns freeing 
    // this.
    pFindParams = NULL;        
    hr = S_OK;
    
exit:
    // Close the thread handle
    if (NULL != hThread)
        CloseHandle(hThread);

    // Free the find parameters if we still have a pointer to them.
    if (NULL != pFindParams)
        delete pFindParams;
    return hr;
}


unsigned int __stdcall LOADDS_16 FindThreadProc(LPVOID lpv)
{
    CFindDlg       *pFindDlg = NULL;
    MSG             msg;
    FINDERPARAMS   *pFindParams = (FINDERPARAMS *) lpv;
    DWORD uiThreadId = 0;

    // Make sure this new thread has all the initialization performed 
    // correctly.
    OleInitialize(0);
    CoIncrementInit("FindThreadProc", MSOEAPI_START_SHOWERRORS, NULL, NULL);

    EnterCriticalSection(&g_csThreadList);

    uiThreadId = GetCurrentThreadId();
    g_pOEThrList = AddThreadToList(uiThreadId, g_pOEThrList );

    LeaveCriticalSection(&g_csThreadList);

    // Create the finder
    pFindDlg = new CFindDlg();
    if (pFindDlg)
    {
        // Show the find dialog.  This function will return when the user is
        // done.
        pFindDlg->Show(pFindParams);

        // Message Loop 
        while (GetMessageWrapW(&msg, NULL, 0, 0))
            pFindDlg->HandleMessage(&msg);

        pFindDlg->Release();
    }    

    // Free this information
    if (NULL != pFindParams)
        delete pFindParams;

    // Uninitialize the thread
    EnterCriticalSection(&g_csThreadList);

    g_pOEThrList = DelThreadToList(uiThreadId, g_pOEThrList);

    LeaveCriticalSection(&g_csThreadList);

    CoDecrementInit("FindThreadProc", NULL);
    OleUninitialize();
    return 0;
}


CFindDlg::CFindDlg()
{    
    m_cRef = 1;
    m_hwnd = NULL;
    ZeroMemory(&m_rFindInfo, sizeof(m_rFindInfo));
    m_hwndList = NULL;
    m_hTimeout = NULL;
    m_hAccel = NULL;

    m_pStatusBar = NULL;
    m_pMsgList = NULL;
    m_pMsgListCT = NULL;
    m_pCancel = NULL;
    m_pPumpRefCount = NULL;
    ZeroMemory(&m_hlDisabled, sizeof(HWNDLIST));

    m_fShowResults = FALSE;
    m_fAbort = FALSE;
    m_fClose = FALSE;
    m_fInProgress = FALSE;
    m_ulPct = 0;
    m_fFindComplete = FALSE;

    m_hIcon = NULL;
    m_hIconSm = NULL;

    m_dwCookie = 0;
    m_fProgressBar = FALSE;
    m_fInternal = 0;
    m_dwIdentCookie = 0;

    m_pViewMenu = NULL;
}


CFindDlg::~CFindDlg()
{
    SafeRelease(m_pViewMenu);
    _FreeFindInfo(&m_rFindInfo);
    SafeRelease(m_pStatusBar);
    SafeRelease(m_pMsgList);
    SafeRelease(m_pMsgListCT);
    SafeRelease(m_pCancel);
    AssertSz(!m_pPumpRefCount, "This should have been freed");

    if (m_hIcon)
        SideAssert(DestroyIcon(m_hIcon));

    if (m_hIconSm)
        SideAssert(DestroyIcon(m_hIconSm));

    CallbackCloseTimeout(&m_hTimeout);
}


//
//  FUNCTION:   CFindDlg::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CFindDlg::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CFindDlg::QueryInterface");
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) (IDispatch *) this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *ppvObj = (LPVOID) (IDispatch *) this;
    else if (IsEqualIID(riid, DIID__MessageListEvents))
        *ppvObj = (LPVOID) (IDispatch *) this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (LPVOID) (IStoreCallback *) this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (LPVOID) (ITimeoutCallback *) this;
    else if (IsEqualIID(riid, IID_IIdentityChangeNotify))
        *ppvObj = (LPVOID) (IIdentityChangeNotify *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (LPVOID) (IOleCommandTarget *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CFindDlg::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CFindDlg::AddRef(void)
{
    TraceCall("CFindDlg::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CFindDlg::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CFindDlg::Release(void)
{
    TraceCall("CFindDlg::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}



//
//  FUNCTION:   CFindDlg::Show()
//
//  PURPOSE:    Shows the finder dialog and provides a message pump for this
//              new thread.
//
void CFindDlg::Show(PFINDERPARAMS pFindParams)
{
    // Validate this
    if (NULL == pFindParams)
        return;

    // Load the acclereator table for the finder
    if (NULL == m_hAccel)
        m_hAccel = LoadAcceleratorsWrapW(g_hLocRes, MAKEINTRESOURCEW(IDA_FIND_ACCEL));

    // Create the finder dialog
    m_hwnd = CreateDialogParamWrapW(g_hLocRes, MAKEINTRESOURCEW(IDD_FIND),
                               NULL, ExtFindMsgDlgProc, (LPARAM) this);
    if (NULL == m_hwnd)
        return;

    // Create the message list
    HRESULT hr = CreateMessageList(NULL, &m_pMsgList);
    if (FAILED(hr))
        return;

    // Get some interfaces pointers from the message list that we'll need
    // later
    m_pMsgList->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pMsgListCT);
    AtlAdvise(m_pMsgList, (IUnknown *) (IDispatch *) this, DIID__MessageListEvents, &m_dwCookie);

    // Display the message list
    if (FAILED(m_pMsgList->CreateList(m_hwnd, (IDispatch *) this, &m_hwndList)))
        return;
    ShowWindow(m_hwndList, SW_HIDE);

    // Have the dialog redraw once or twice
    UpdateWindow(m_hwnd);

    // Fill in the folder list
    if (FAILED(InitFolderPickerEdit(GetDlgItem(m_hwnd, IDC_FOLDER), pFindParams->idFolder)))
        return;

    // Will be released in the WM_NCDESTROY message
    m_pPumpRefCount = new CPumpRefCount;
    if (!m_pPumpRefCount)
        return;
}


void CFindDlg::HandleMessage(LPMSG lpmsg)
{
    HWND hwndTimeout;

    CNote *pNote = GetTlsGlobalActiveNote();

    // Give it to the active note if a note has focus, call it's XLateAccelerator...
    if (pNote && pNote->TranslateAccelerator(lpmsg) == S_OK)
        return;

    if (pNote && (pNote->IsMenuMessage(lpmsg) == S_OK))
        return;

    // Get Timeout Window for this thread
    hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);

    // Check for Is modeless timeout dialog window message
    if (hwndTimeout && TRUE == IsDialogMessageWrapW(hwndTimeout, lpmsg))
        return;

    if (m_hwnd)
    {
        // We have to do a little voodoo to get some keystrokes down to the 
        // message list before IsDialogMessage() get's 'em
        if (lpmsg->message == WM_KEYDOWN)
        {
            if ((lpmsg->wParam == VK_DELETE) && m_pMsgList && (S_OK != m_pMsgList->HasFocus()))
            {
                if (!IsDialogMessageWrapW(m_hwnd, lpmsg))
                {
                    TranslateMessage(lpmsg);
                    DispatchMessageWrapW(lpmsg);
                }
                return;
            }
            if ((lpmsg->wParam == VK_RETURN) && m_pMsgList && (S_OK == m_pMsgList->HasFocus()))
            {
                if (!TranslateAcceleratorWrapW(m_hwnd, m_hAccel, lpmsg))
                {
                    TranslateMessage(lpmsg);
                    DispatchMessageWrapW(lpmsg);
                }
        
                return;
            }
        }

        if (m_hAccel && TranslateAcceleratorWrapW(m_hwnd, m_hAccel, lpmsg))
            return; 
        
        if (IsDialogMessageWrapW(m_hwnd, lpmsg))
            return;
    }

    TranslateMessage(lpmsg);
    DispatchMessageWrapW(lpmsg);
}



//
//  FUNCTION:   CFindDlg::Invoke()
//
//  PURPOSE:    Called by the message list to pass us progress and other 
//              status / error messages.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                         WORD wFlags, DISPPARAMS* pDispParams, 
                         VARIANT* pVarResult, EXCEPINFO* pExcepInfo, 
                         unsigned int* puArgErr)
{
    switch (dispIdMember)
    {
        // Fired whenever the selection in the ListView changes
        case DISPID_LISTEVENT_SELECTIONCHANGED:
        {
            break;
        }

        // Fired when the number of messages or unread messages changes
        case DISPID_LISTEVENT_COUNTCHANGED:
        {
            if (!m_fProgressBar && m_pStatusBar)
            {
                TCHAR szStatus[CCHMAX_STRINGRES + 20];
                TCHAR szFmt[CCHMAX_STRINGRES];
                DWORD ids;

                if (m_fFindComplete)
                {
                    AthLoadString(idsXMsgsYUnreadFind, szFmt, ARRAYSIZE(szFmt));
                    wnsprintf(szStatus, ARRAYSIZE(szStatus), szFmt, pDispParams->rgvarg[0].lVal, pDispParams->rgvarg[1].lVal);
                }
                else
                {
                    AthLoadString(idsXMsgsYUnread, szFmt, ARRAYSIZE(szFmt));
                    wnsprintf(szStatus, ARRAYSIZE(szStatus), szFmt, pDispParams->rgvarg[0].lVal, pDispParams->rgvarg[1].lVal);
                }

                m_pStatusBar->SetStatusText(szStatus);
            }
            break;
        }

        // Fired when the user double clicks an item in the ListView
        case DISPID_LISTEVENT_ITEMACTIVATE:
        {
            CmdOpen(ID_OPEN, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            break;
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::QueryStatus()
//
//  PURPOSE:    Called by the browser to determine if a list of commands should
//              should be enabled or disabled.
//
//  PARAMETERS: 
//      [in] pguidCmdGroup - Group the commands are part of (unused)
//      [in] cCmds - Number of commands to be evaluated
//      [in] prgCmds - List of commands
//      [out] pCmdText - Description text for a command
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                              OLECMDTEXT *pCmdText) 
{
    DWORD   cSel;
    HRESULT hr;
    DWORD  *rgSelected = 0;
    DWORD   cFocus;

    MenuUtil_NewMessageIDsQueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText, TRUE);

    // Up front some work
    m_pMsgList->GetSelected(&cFocus, &cSel, &rgSelected);

    // Now loop through the commands in the prgCmds array looking for ones the 
    // sub objects didn't handle.
    for (UINT i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            // If this command is from the language menu
            if (prgCmds[i].cmdID >= ID_LANG_FIRST && prgCmds[i].cmdID <= ID_LANG_LAST)
            {
                // Enable only the supported languages
                if (prgCmds[i].cmdID < (UINT) (ID_LANG_FIRST + GetIntlCharsetLanguageCount()))
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                else
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                continue;
            }

            // if the command id from the View.Current View menu
            if ((ID_VIEW_FILTER_FIRST <= prgCmds[i].cmdID) && (ID_VIEW_FILTER_LAST >= prgCmds[i].cmdID))
            {
                if (NULL == m_pViewMenu)
                {
                    // Create the view menu
                    HrCreateViewMenu(VMF_FINDER, &m_pViewMenu);
                }
            
                if (NULL != m_pViewMenu)
                {
                    m_pViewMenu->QueryStatus(m_pMsgList, &(prgCmds[i]));
                }

                continue;
            }
            
            // Look to see if it's a command we provide
            switch (prgCmds[i].cmdID)
            {
                case ID_OPEN:
                {
                    // Enabled only if the focus is in the ListView and there 
                    // is at least one item selected.
                    m_pMsgList->GetSelectedCount(&cSel);
                    if (cSel)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_OPEN_CONTAINING_FOLDER:
                {
                    if (cSel == 1)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_REPLY:
                case ID_REPLY_ALL:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is only one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->dwFlags & ARF_HASBODY)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }

                    break;
                }

                case ID_FORWARD:
                case ID_FORWARD_AS_ATTACH:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is only one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel > 0)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        // Default to success
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        for (DWORD iItem = 0; iItem < cSel && (prgCmds[i].cmdf & OLECMDF_ENABLED); iItem++)
                        {
                            if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[iItem], &pInfo)))
                            {
                                if (0 == (pInfo->dwFlags & ARF_HASBODY))
                                {
                                    prgCmds[i].cmdf &= ~OLECMDF_ENABLED;
                                }

                                m_pMsgList->FreeMessageInfo(pInfo);
                            }
                        }
                    }

                    break;
                }

                case ID_REPLY_GROUP:
                {
                    // Enabled only if there is one news message selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if ((pInfo->dwFlags & ARF_HASBODY) && (pInfo->dwFlags & ARF_NEWSMSG))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }

                case ID_POPUP_FILTER:
                case ID_COLUMNS:
                case ID_POPUP_NEXT:
                case ID_POPUP_SORT:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | (m_fShowResults ? OLECMDF_ENABLED : 0);
                    break;
                }

                case ID_POPUP_NEW:
                case ID_CLOSE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
                }

                case ID_REFRESH:
                {
                    if (m_fShowResults && IsWindowEnabled(GetDlgItem(m_hwnd, IDC_FIND_NOW)))
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_BLOCK_SENDER:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    // Enabled only if there is only one item selected and
                    // we have access to the from address
                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (((NULL != pInfo->pszEmailFrom) && ('\0' != pInfo->pszEmailFrom[0])) || (0 != pInfo->faStream))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                } 
                
                case ID_CREATE_RULE_FROM_MESSAGE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    // Enabled only if there is only one item selected
                    if (cSel == 1)
                    {
                        // Make sure we have a message info
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            
                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }

                case ID_COMBINE_AND_DECODE:
                {
                    // Enabled only if the focus is in the ListView and there 
                    // is at least one item selected.
                    if (cSel > 1)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_CANCEL_MESSAGE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (DwGetOption(OPT_CANCEL_ALL_NEWS))
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    else
                    {
                        if (cSel == 1)
                        {
                            FOLDERID idFolder;
                            LPMESSAGEINFO pInfo;

                            if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                            {
                                if (SUCCEEDED(m_pMsgList->GetRowFolderId(rgSelected[0], &idFolder)))
                                {
                                    if (NewsUtil_FCanCancel(idFolder, pInfo))
                                    {
                                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                    }
                                }

                                m_pMsgList->FreeMessageInfo(pInfo);
                            }
                        }
                    }
                    break;
                }
            }
        }
    }

    MemFree(rgSelected);

    // Let the sub objects look last, so we can get ID_REFRESH before them
    if (m_pMsgListCT)
    {
        hr = m_pMsgListCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::Exec()
//
//  PURPOSE:    Called to execute a verb that this view supports
//
//  PARAMETERS: 
//      [in]  pguidCmdGroup - unused
//      [in]  nCmdID - ID of the command to execute
//      [in]  nCmdExecOpt - Options that define how the command should execute
//      [in]  pvaIn - Any arguments for the command
//      [out] pvaOut - Any return values for the command
//
//  RETURN VALUE:
//       
//
HRESULT CFindDlg::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                       VARIANTARG *pvaIn, VARIANTARG *pvaOut) 
{
    // If the sub objects didn't support the command, then we should see if
    // it's one of ours

    // Language menu first
    if (nCmdID >= ID_LANG_FIRST && nCmdID <= ID_LANG_LAST)
    {
        // $REVIEW - Not implemented
        // SwitchLanguage(nCmdID, TRUE);
        return (S_OK);
    }

    // Handle the View.Current View menu
    if ((ID_VIEW_FILTER_FIRST <= nCmdID) && (ID_VIEW_FILTER_LAST >= nCmdID))
    {
        if (NULL == m_pViewMenu)
        {
            // Create the view menu
            HrCreateViewMenu(VMF_FINDER, &m_pViewMenu);
        }
        
        if (NULL != m_pViewMenu)
        {
            if (SUCCEEDED(m_pViewMenu->Exec(m_hwnd, nCmdID, m_pMsgList, pvaIn, pvaOut)))
            {
                return (S_OK);
            }
        }
    }
    
    if (MenuUtil_HandleNewMessageIDs(nCmdID, m_hwnd, FOLDERID_INVALID, TRUE, FALSE, (IUnknown *) (IDispatch *) this))
        return S_OK;


    // Go through the rest of the commands
    switch (nCmdID)
    {
        case ID_OPEN:
            return CmdOpen(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_OPEN_CONTAINING_FOLDER:
            return CmdOpenFolder(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_REPLY:
        case ID_REPLY_ALL:
        case ID_FORWARD:
        case ID_FORWARD_AS_ATTACH:
        case ID_REPLY_GROUP:
            return CmdReplyForward(nCmdID, nCmdExecOpt, pvaIn, pvaOut);    
            
        case ID_REFRESH:
        case IDC_FIND_NOW:
            return CmdFindNow(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case IDC_STOP:
            return CmdStop(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case IDC_BROWSE_FOLDER:
            return CmdBrowseForFolder(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case IDC_RESET:
            return CmdReset(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_BLOCK_SENDER:
            return CmdBlockSender(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_CREATE_RULE_FROM_MESSAGE:
            return CmdCreateRule(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_COMBINE_AND_DECODE:
            return CmdCombineAndDecode(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_CLOSE:
        case IDCANCEL:
        {
            if (m_fInProgress)
            {
                CmdStop(ID_STOP, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                m_fClose = TRUE;
            }
            else
            {
                DestroyWindow(m_hwnd);
            }
            return (S_OK);
        }

        case ID_CANCEL_MESSAGE:
            return CmdCancelMessage(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
    }

    // See if our message list wants the command
    if (m_pMsgListCT)
    {
        if (OLECMDERR_E_NOTSUPPORTED != m_pMsgListCT->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut))
            return (S_OK);
    }
    
    return (OLECMDERR_E_NOTSUPPORTED);
}


//
//  FUNCTION:   CFindDlg::OnBegin()
//
//  PURPOSE:    Called whenever the store is about to start some operation.
//
HRESULT CFindDlg::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, 
                          IOperationCancel *pCancel)
{
    TraceCall("CFindDlg::OnBegin");

    Assert(pCancel != NULL);
    Assert(m_pCancel == NULL);
    
    m_pCancel = pCancel;
    m_pCancel->AddRef();

    if (m_fAbort)
        m_pCancel->Cancel(CT_CANCEL);

    return(S_OK);
}


//
//  FUNCTION:   CFindDlg::OnProgress()
//
//  PURPOSE:    Called during the find, download, etc.
//
HRESULT CFindDlg::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, 
                             DWORD dwMax, LPCSTR pszStatus)
{
    MSG msg;

    TraceCall("CFindDlg::OnProgress");

    // If we had a timeout dialog up, we can close it since data just became
    // available.
    CallbackCloseTimeout(&m_hTimeout);

    // If it's find, show progress
    if (SOT_SEARCHING == tyOperation)
    {
        if (m_pStatusBar && pszStatus)
        {
            TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
            AthLoadString(idsSearching, szRes, ARRAYSIZE(szRes));
            wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, pszStatus);
            m_pStatusBar->SetStatusText((LPTSTR) szBuf);
        }

        if (!m_fProgressBar && m_pStatusBar)
        {
            m_pStatusBar->ShowProgress(dwMax);
            m_fProgressBar = TRUE;
        }

        if (m_pStatusBar && dwMax)
        {
            m_pStatusBar->SetProgress(dwCurrent);
        }
    }

    // Pump messages a bit so the UI is responsive.
    while (PeekMessageWrapW(&msg, NULL, 0, 0, PM_REMOVE))
        HandleMessage(&msg);

    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::OnComplete()
//
//  PURPOSE:    Called when the store operation is complete
//
HRESULT CFindDlg::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) 
{
    TraceCall("CFindDlg::OnComplete");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Display an Error on Failures
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwnd, hrComplete, pErrorInfo);
    }

    if (SOT_SEARCHING == tyOperation)
    {
        // Hide the status bar
        if (m_fProgressBar && m_pStatusBar)
        {
            m_pStatusBar->HideProgress();
            m_fProgressBar = FALSE;
            m_fFindComplete = TRUE;
        }

        Assert(m_pCancel != NULL);
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // Update the status text
    IOEMessageList *pList;
    if (SUCCEEDED(m_pMsgList->QueryInterface(IID_IOEMessageList, (LPVOID *) &pList)))
    {
        long  lCount, lUnread;
        TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

        pList->get_Count(&lCount);
        pList->get_UnreadCount(&lUnread);
        AthLoadString(idsXMsgsYUnreadFind, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szRes, lCount, lUnread);
        m_pStatusBar->SetStatusText(szBuf);

        pList->Release();
    }

    // Select the first row
    IListSelector *pSelect;
    if (SUCCEEDED(m_pMsgList->GetListSelector(&pSelect)))
    {
        pSelect->SetActiveRow(0);
        pSelect->Release();
    }

    return(S_OK); 
}


STDMETHODIMP CFindDlg::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{ 
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

STDMETHODIMP CFindDlg::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{ 
    // Call into general CanConnect Utility
    return CallbackCanConnect(pszAccountId, m_hwnd, FALSE);
}

STDMETHODIMP CFindDlg::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) 
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwnd, pServer, ixpServerType);
}

STDMETHODIMP CFindDlg::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

STDMETHODIMP CFindDlg::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{ 
    *phwndParent = m_hwnd;
    return(S_OK);
}

STDMETHODIMP CFindDlg::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}


INT_PTR CALLBACK CFindDlg::ExtFindMsgDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CFindDlg *pThis;

    if (msg == WM_INITDIALOG)
        {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CFindDlg*)lParam;
        }
    else
        pThis = (CFindDlg*)GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return pThis->DlgProc(hwnd, msg, wParam, lParam);
    return FALSE;
}


//
//  FUNCTION:   CFindDlg::DlgProc()
//
//  PURPOSE:    Groovy dialog proc.
//
INT_PTR CFindDlg::DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndActive;

    switch (msg)
    {
        case WM_INITDIALOG:
            return (BOOL)HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, OnInitDialog);
        
        case WM_PAINT:
            HANDLE_WM_PAINT(hwnd, wParam, lParam, OnPaint);
            return TRUE;

        case WM_SIZE:
            HANDLE_WM_SIZE(hwnd, wParam, lParam, OnSize);
            return TRUE;
        
        case WM_GETMINMAXINFO:
            HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, OnGetMinMaxInfo);
            return TRUE;
        
        case WM_INITMENUPOPUP:
            HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, OnInitMenuPopup);
            return TRUE;

        case WM_MENUSELECT:
            // HANDLE_WM_MENUSELECT() has a bug in it, don't use it.
            if (LOWORD(wParam) >= ID_STATIONERY_RECENT_0 && LOWORD(wParam) <= ID_STATIONERY_RECENT_9)
                m_pStatusBar->ShowSimpleText(MAKEINTRESOURCE(idsRSListGeneralHelp));
            else
                HandleMenuSelect(m_pStatusBar, wParam, lParam);
            return TRUE;
        
        case WM_WININICHANGE:
            HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, OnWinIniChange);
            return TRUE;

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, OnCommand);
            return TRUE;
        
        case WM_NOTIFY:
            HANDLE_WM_NOTIFY(hwnd, wParam, lParam, OnNotify);
            return TRUE;

        case WM_DESTROY:
        // case WM_CLOSE:
            HANDLE_WM_DESTROY(hwnd, wParam, lParam, OnDestroy);
            return TRUE;
        
        case WM_NCDESTROY:
            m_pPumpRefCount->Release();
            m_pPumpRefCount = NULL;
            m_hwnd = 0;
            break;

        case WM_ENABLE:
            if (!m_fInternal)
            {
                Assert (wParam || (m_hlDisabled.cHwnd == NULL && m_hlDisabled.rgHwnd == NULL));
                EnableThreadWindows(&m_hlDisabled, (NULL != wParam), ETW_OE_WINDOWS_ONLY, hwnd);
                g_hwndActiveModal = wParam ? NULL : hwnd;
            }
            break;

        case WM_ACTIVATEAPP:
            if (wParam && g_hwndActiveModal && g_hwndActiveModal != hwnd && 
                !IsWindowEnabled(hwnd))
            {
                // $MODAL
                // if we are getting activated, and are disabled then
                // bring our 'active' window to the top
                Assert (IsWindow(g_hwndActiveModal));
                PostMessage(g_hwndActiveModal, WM_OE_ACTIVATETHREADWINDOW, 0, 0);
            }
            break;

        case WM_OE_ACTIVATETHREADWINDOW:
            hwndActive = GetLastActivePopup(hwnd);
            if (hwndActive && IsWindowEnabled(hwndActive) && IsWindowVisible(hwndActive))
                ActivatePopupWindow(hwndActive);
            break;

        case WM_OE_ENABLETHREADWINDOW:
            m_fInternal = 1;
            EnableWindow(hwnd, (BOOL)wParam);
            m_fInternal = 0;
            break;

    }
    return FALSE;
}


//
//  FUNCTION:   CFindDlg::OnInitDialog()
//
//  PURPOSE:    Initializes the UI in the dialog box.  Also prep's the sizing 
//              info so the dialog can be resized.
//
BOOL CFindDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    RECT            rc, rcClient;
    RECT            rcEdit;
    WINDOWPLACEMENT wp;
    HMENU           hMenu;

    TraceCall("CFindDlg::OnInitDialog");

    // We do this so we can enable and disable correctly when modal windows
    // are visible
    SetProp(hwnd, c_szOETopLevel, (HANDLE)TRUE);

    // Get some sizing info
    _InitSizingInfo(hwnd);

    // Hide the status bar until we've been expanded
    ShowWindow(GetDlgItem(hwnd, IDC_STATUS_BAR), SW_HIDE);

    // Set the title bar icon
    Assert (m_hIconSm == NULL && m_hIcon == NULL);
    m_hIcon = (HICON)LoadImage(g_hLocRes, MAKEINTRESOURCE(idiFind), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);
    SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
    m_hIconSm = (HICON)LoadImage(g_hLocRes, MAKEINTRESOURCE(idiFind), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
    SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

    // Set the dialog template fonts correctly
    _SetFindIntlFont(hwnd);

    // Initialize the find information
    _SetFindValues(hwnd, &m_rFindInfo);

    // Disable the find and stop buttons 
    EnableWindow(GetDlgItem(hwnd, IDC_FIND_NOW), _IsFindEnabled(hwnd));
    EnableWindow(GetDlgItem(hwnd, IDC_STOP), FALSE);
    CheckDlgButton(hwnd, IDC_INCLUDE_SUB, BST_CHECKED);

    // Create a status bar object for our status bar
    m_pStatusBar = new CStatusBar();
    if (m_pStatusBar)
        m_pStatusBar->Initialize(hwnd, SBI_HIDE_SPOOLER | SBI_HIDE_CONNECTED | SBI_HIDE_FILTERED);

    // We have menus on this window
    hMenu = LoadMenu(g_hLocRes, MAKEINTRESOURCE(IDR_FIND_MENU));
    MenuUtil_ReplaceNewMsgMenus(hMenu);
    SetMenu(hwnd, hMenu);

    // Register with identity manager
    if (m_dwIdentCookie == 0)
        SideAssert(SUCCEEDED(MU_RegisterIdentityNotifier((IUnknown *)(IAthenaBrowser *)this, &m_dwIdentCookie)));

    SetForegroundWindow(hwnd);

    return TRUE;
}


//
//  FUNCTION:   CFindDlg::OnSize()
//
//  PURPOSE:    When the dialog get's sized, we have to move a whole bunch 
//              of stuff around.  Don't try this at home.
//
void CFindDlg::OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    HDWP hdwp;
    HWND hwndStatus;
    HWND hwndTo;
    int  dx;

    // If we're minimized, don't do anything
    if (state == SIZE_MINIMIZED)
        return;

    // This is the delta for our horizontal size.
    dx = cx - m_cxDlgDef;

    // Make sure the status bar get's updated 
    hwndStatus = GetDlgItem(hwnd, IDC_STATUS_BAR);
    SendMessage(hwndStatus, WM_SIZE, 0, 0L);

    if (m_pStatusBar)
        m_pStatusBar->OnSize(cx, cy);    

    // Do all the sizing updates at once to make everything smoother
    hdwp = BeginDeferWindowPos(15);
    if (hdwp)
    {
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_FOLDER),        NULL, 0, 0, (dx + m_cxFolder), m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_INCLUDE_SUB),   NULL, m_xIncSub + dx, m_yIncSub, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_BROWSE_FOLDER), NULL, m_xBtn + dx, m_yBrowse, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, idcStatic1),        NULL, 0, 0, m_cxStatic + dx, 2, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_FIND_NOW),      NULL, m_xBtn + dx, m_yBtn, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_STOP),          NULL, m_xBtn + dx, m_yBtn + m_dyBtn, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_RESET),         NULL, m_xBtn + dx, m_yBtn + 2 * m_dyBtn, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_FROM),          NULL, 0, 0, m_cxEdit + dx, m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_TO),            NULL, 0, 0, m_cxEdit + dx, m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_SUBJECT),       NULL, 0, 0, m_cxEdit + dx, m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_BODY),          NULL, 0, 0, m_cxEdit + dx, m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        // ALERT:
        // if you add more controls here be sure to UP the value passed
        // to BeginDeferWindowPos otherwise user will REALLOC and passback
        // a new value to hdwp
        EndDeferWindowPos(hdwp);
    }
    // If the bottom is exposed (oh my) resize the message list to fit between the 
    // bottom of the dialog and the top of the status bar.
    if (m_fShowResults)
    {
        RECT rcStatus;
        GetClientRect(hwndStatus, &rcStatus);
        MapWindowRect(hwndStatus, hwnd, &rcStatus);

        rcStatus.bottom = rcStatus.top - m_yView;
        rcStatus.top = m_yView;
        rcStatus.right -= rcStatus.left;
        m_pMsgList->SetRect(rcStatus);
    }
}


//
//  FUNCTION:   CFindDlg::OnPaint()
//
//  PURPOSE:    All this just to paint a separator line between the menu bar
//              and the rest of the menu.
//
void CFindDlg::OnPaint(HWND hwnd)
{
    PAINTSTRUCT ps;
    RECT        rc;

    // If we're not minimized
    if (!IsIconic(hwnd))
    {
        // Draw that lovely line
        BeginPaint(hwnd, &ps);
        GetClientRect(hwnd, &rc);
        DrawEdge(ps.hdc, &rc, EDGE_ETCHED, BF_TOP);
        EndPaint(hwnd, &ps);
    }
}


//
//  FUNCTION:   CFindDlg::OnGetMinMaxInfo()
//
//  PURPOSE:    Called by Windows when we're resizing to see what our minimum 
//              and maximum sizes are.
//
void CFindDlg::OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi)
{
    TraceCall("CFindDlg::OnGetMinMaxInfo");

    // Let Window's do most of the work
    DefWindowProcWrapW(hwnd, WM_GETMINMAXINFO, 0, (LPARAM)lpmmi);

    // Override the minimum track size to be the size or our template
    lpmmi->ptMinTrackSize = m_ptDragMin;

    // Make sure to adjust for the height of the message list
    if (!m_fShowResults)
        lpmmi->ptMaxTrackSize.y = m_ptDragMin.y;
}


//
//  FUNCTION:   CFindDlg::OnInitMenuPopup()
//
//  PURPOSE:    Called before the menus are displayed.
//
void CFindDlg::OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu)
{
    MENUITEMINFO    mii;
    UINT            uIDPopup;
    HMENU           hMenu = GetMenu(hwnd);

    TraceCall("CFindDlg::OnInitMenuPopup");

    ZeroMemory(&mii, sizeof(mii));

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;

    // make sure we recognize the popup as one of ours
    if (hMenu == NULL || !GetMenuItemInfo(hMenu, uPos, TRUE, &mii) || (hmenuPopup != mii.hSubMenu))
    {
        HMENU   hMenuDrop = NULL;
        int     ulIndex = 0;
        int     cMenus = 0;

        cMenus = GetMenuItemCount(hMenu);
        
        // Try to fix up the top level popups
        for (ulIndex = 0; ulIndex < cMenus; ulIndex++)
        {
            // Get the drop down menu
            hMenuDrop = GetSubMenu(hMenu, ulIndex);
            if (NULL == hMenuDrop)
            {
                continue;
            }
            
            // Initialize the menu info
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_ID | MIIM_SUBMENU;

            if (FALSE == GetMenuItemInfo(hMenuDrop, uPos, TRUE, &mii))
            {
                continue;
            }

            if (hmenuPopup == mii.hSubMenu)
            {
                break;
            }
        }

        // Did we find anything?
        if (ulIndex >= cMenus)
        {
            goto exit;
        }
    }

    uIDPopup = mii.wID;

    // Must have stationery
    switch (uIDPopup)
    {
        case ID_POPUP_MESSAGE:
            AddStationeryMenu(hmenuPopup, ID_POPUP_NEW_MSG, ID_STATIONERY_RECENT_0, ID_STATIONERY_MORE);
            break;
            
        case ID_POPUP_FILE:
            DeleteMenu(hmenuPopup, ID_SEND_INSTANT_MESSAGE, MF_BYCOMMAND);
            break;

        case ID_POPUP_VIEW:
            if (NULL == m_pViewMenu)
            {
                // Create the view menu
                HrCreateViewMenu(VMF_FINDER, &m_pViewMenu);
            }
            
            if (NULL != m_pViewMenu)
            {
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU;
                
                if (FALSE == GetMenuItemInfo(hmenuPopup, ID_POPUP_FILTER, FALSE, &mii))
                {
                    break;
                }
                
                // Remove the old filter submenu
                if(IsMenu(mii.hSubMenu))
                    DestroyMenu(mii.hSubMenu);

                // Replace the view menu
                if (FAILED(m_pViewMenu->HrReplaceMenu(0, hmenuPopup)))
                {
                    break;
                }
            }
            break;
        
        case ID_POPUP_FILTER:
            if (NULL != m_pViewMenu)
            {
                m_pViewMenu->UpdateViewMenu(0, hmenuPopup, m_pMsgList);
            }
            break;
    }
    
    // Let the message list initialize it
    if (m_pMsgList)
        m_pMsgList->OnPopupMenu(hmenuPopup, uIDPopup);

    // now enable/disable the items
    MenuUtil_EnablePopupMenu(hmenuPopup, this);
    
exit:
    return;
}


//
//  FUNCTION:   CFindDlg::OnMenuSelect()
//
//  PURPOSE:    Puts the menu help text on the status bar.
//
void CFindDlg::OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags)
{
    if (m_pStatusBar)
    {
        // If this is the stationery menu, special case it
        if (item >= ID_STATIONERY_RECENT_0 && item <= ID_STATIONERY_RECENT_9)
            m_pStatusBar->ShowSimpleText(MAKEINTRESOURCE(idsRSListGeneralHelp));
        else
            HandleMenuSelect(m_pStatusBar, MAKEWPARAM(item, flags), hmenu ? (LPARAM) hmenu : (LPARAM) hmenuPopup);
    }
}


//
//  FUNCTION:   CFindDlg::OnWinIniChange()
//
//  PURPOSE:    Handles updates of fonts, colors, etc.
//
void CFindDlg::OnWinIniChange(HWND hwnd, LPCTSTR lpszSectionName)
{
    // Forward this off to our date picker controls
    FORWARD_WM_WININICHANGE(GetDlgItem(hwnd, IDC_DATE_FROM), lpszSectionName, SendMessage);
    FORWARD_WM_WININICHANGE(GetDlgItem(hwnd, IDC_DATE_TO), lpszSectionName, SendMessage);
}
       

//
//  FUNCTION:   CFindDlg::OnCommand()
//
//  PURPOSE:    Handles commands generated by the finder.
//
void CFindDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    HRESULT         hr = S_OK;

    // We need to grab some of the notifications sent to us first
    if ((codeNotify == EN_CHANGE) || 
        (codeNotify == BN_CLICKED && (id == IDC_HAS_FLAG || id == IDC_HAS_ATTACH)))
    {
        EnableWindow(GetDlgItem(hwnd, IDC_FIND_NOW), _IsFindEnabled(hwnd) && !m_fInProgress);
        return;
    }

    // If this is from a menu, then first see if the message list wants
    // to handle it.
    if (NULL == hwndCtl)
    {
        // Check to see if the command is even enabled
        if (id >= ID_FIRST)
        {
            OLECMD cmd;
            cmd.cmdID = id;
            cmd.cmdf = 0;

            hr = QueryStatus(&CMDSETID_OutlookExpress, 1, &cmd, NULL);
            if (FAILED(hr) || (0 == (cmd.cmdf & OLECMDF_ENABLED)))
                return;
        }

        if (m_pMsgListCT)
        {
            hr = m_pMsgListCT->Exec(&CMDSETID_OEMessageList, id, OLECMDEXECOPT_DODEFAULT,
                                    NULL, NULL);
            if (S_OK == hr)
                return;
        }
    }

    // Otherwise, it goes to the command target
    VARIANTARG va;

    va.vt = VT_I4;
    va.lVal = codeNotify;

    hr = Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, &va, NULL);
    return;
}


//
//  FUNCTION:   CFindDlg::OnNotify()
//
//  PURPOSE:    Handles notifications from the date pickers
//
LRESULT CFindDlg::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    if (DTN_DATETIMECHANGE == pnmhdr->code)
        EnableWindow(GetDlgItem(hwnd, IDC_FIND_NOW), _IsFindEnabled(hwnd));

    return (0);
}


//
//  FUNCTION:   CFindDlg::OnDestroy()
//
//  PURPOSE:    Clean up the message list now that we're being shut down and
//              also save our size etc.
//
void CFindDlg::OnDestroy(HWND hwnd)
{
    WINDOWPLACEMENT wp;

    // Save the sizing information
    wp.length = sizeof(wp);
    GetWindowPlacement(hwnd, &wp);
    SetOption(OPT_FINDER_POS, (LPBYTE)&wp, sizeof(wp), NULL, 0);
    
    // Unregister with Identity manager
    if (m_dwIdentCookie != 0)
    {
        MU_UnregisterIdentityNotifier(m_dwIdentCookie);
        m_dwIdentCookie = 0;
    }

    // Clean up the property
    RemoveProp(hwnd, c_szOETopLevel);

    // Stop receieving notifications
    AtlUnadvise(m_pMsgList, DIID__MessageListEvents, m_dwCookie);

    // Tell the message list to release it's folder
    m_pMsgList->SetFolder(FOLDERID_INVALID, NULL, FALSE, NULL, NOSTORECALLBACK);

    // Close the message list
    m_pMsgList->OnClose();
}



//
//  FUNCTION:   CFindDlg::CmdOpen()
//
//  PURPOSE:    Called when the user want's to open a message that they've found.
//
HRESULT CFindDlg::CmdOpen(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, 
                          VARIANTARG *pvaOut)
{
    HRESULT hr;

    TraceCall("CMessageView::CmdOpen");

    // If more than 10 messages are selected, warn the user with a "Don't show
    // me again" dialog that this could be bad.
    DWORD dwSel = 0;
    
    m_pMsgList->GetSelectedCount(&dwSel);
    if (dwSel > 10)
    {
        TCHAR szBuffer[CCHMAX_STRINGRES];
        LRESULT lResult;

        AthLoadString(idsErrOpenManyMessages, szBuffer, ARRAYSIZE(szBuffer));
        lResult = DoDontShowMeAgainDlg(m_hwnd, c_szRegManyMsgWarning, 
                                       MAKEINTRESOURCE(idsAthena), szBuffer, 
                                       MB_OKCANCEL);
        if (IDCANCEL == lResult)
            return (S_OK);
    }

    // Get the array of selected rows from the message list
    DWORD *rgRows = NULL;
    DWORD cRows = 0;

    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    LPMESSAGEINFO  pInfo;
    IMessageTable *pTable = NULL;

    hr = m_pMsgList->GetMessageTable(&pTable);
    if (SUCCEEDED(hr))
    {
        for (DWORD i = 0; (i < cRows && m_pMsgList != NULL); i++)
        {
            if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[i], &pInfo)))
            {
                INIT_MSGSITE_STRUCT initStruct;
                DWORD dwCreateFlags;
                initStruct.initTable.pListSelect = NULL;
                m_pMsgList->GetListSelector(&initStruct.initTable.pListSelect);

                // Initialize note struct
                initStruct.dwInitType = OEMSIT_MSG_TABLE;
                initStruct.initTable.pMsgTable = pTable;
                if (FAILED(GetFolderIdFromMsgTable(pTable, &initStruct.folderID)))
                    initStruct.folderID = FOLDERID_INVALID;
                initStruct.initTable.rowIndex = rgRows[i];

                // Decide whether it is news or mail
                if (pInfo->dwFlags & ARF_NEWSMSG)
                    dwCreateFlags = OENCF_NEWSFIRST;
                else
                    dwCreateFlags = 0;

                m_pMsgList->FreeMessageInfo(pInfo);

                // Create and Open Note
                hr = CreateAndShowNote(OENA_READ, dwCreateFlags, &initStruct, m_hwnd, (IUnknown *)m_pPumpRefCount);
                ReleaseObj(initStruct.initTable.pListSelect);
                if (FAILED(hr))
                    break;
            }
        }
        pTable->Release();
    }
    MemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdOpenFolder()
//
//  PURPOSE:    Called when the user want's to open the folder that contains the
//              selected message.
//
HRESULT CFindDlg::CmdOpenFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, 
                                VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            FOLDERID idFolder;

            // Get some information about the message
            if (g_pInstance && SUCCEEDED(hr = m_pMsgList->GetRowFolderId(dwFocused, &idFolder)))
            {
                g_pInstance->BrowseToObject(SW_SHOWNORMAL, idFolder);
            }
        }
    }

    MemFree(rgRows);
    return (S_OK);
}

//
//  FUNCTION:   CFindDlg::CmdReply()
//
//  PURPOSE:    Replies or Reply-All's to the selected message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::CmdReplyForward(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;
    IMessageTable  *pTable = NULL;

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            INIT_MSGSITE_STRUCT rInitSite;
            DWORD               dwCreateFlags;
            DWORD               dwAction = 0;

            // Get the message table from the message list.  The note will need
            // this to deal with next / prev commands
            hr = m_pMsgList->GetMessageTable(&pTable);
            if (FAILED(hr))
                goto exit;

            if ((1 < cRows) && ((ID_FORWARD == nCmdID) || (ID_FORWARD_AS_ATTACH == nCmdID)))
            {
                IMimeMessage   *pMsgFwd = NULL;
                BOOL            fErrorsOccured = FALSE,
                                fCreateNote = TRUE;

                hr = HrCreateMessage(&pMsgFwd);
                if (FAILED(hr))
                    goto exit;
                
                rInitSite.dwInitType = OEMSIT_MSG;
                rInitSite.pMsg = pMsgFwd;
                if (FAILED(GetFolderIdFromMsgTable(pTable, &rInitSite.folderID)))
                    rInitSite.folderID = FOLDERID_INVALID;

                dwCreateFlags = 0;
                dwAction = OENA_COMPOSE;

                for (DWORD i = 0; i < cRows; i++)
                {
                    DWORD           iRow = rgRows[i];
                    IMimeMessage   *pMsg = NULL;

                    // Since this command is 
                    hr = pTable->OpenMessage(iRow, OPEN_MESSAGE_SECURE, &pMsg, NOSTORECALLBACK);
                    if (SUCCEEDED(hr))
                    {
                        if (FAILED(pMsgFwd->AttachObject(IID_IMimeMessage, (LPVOID)pMsg, NULL)))
                            fErrorsOccured = TRUE;
                        pMsg->Release();
                    }
                    else
                        fErrorsOccured = TRUE;
                }

                if (fErrorsOccured)
                {
                    if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                            MAKEINTRESOURCEW(idsErrorAttachingMsgsToNote), NULL, MB_OKCANCEL) == IDCANCEL)
                        fCreateNote = FALSE;
                }

                if (fCreateNote)
                    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, m_hwnd, (IUnknown *)m_pPumpRefCount);                
                pMsgFwd->Release();
            }
            else
            {
                LPMESSAGEINFO   pInfo;

                // Get some information about the message
                if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
                {
                    // Determine if this is a news or mail message.
                    if (pInfo->dwFlags & ARF_NEWSMSG)
                        dwCreateFlags = OENCF_NEWSFIRST;
                    else
                        dwCreateFlags = 0;

                    // Reply or forward
                    if (nCmdID == ID_FORWARD)
                        dwAction = OENA_FORWARD;
                    else if (nCmdID == ID_FORWARD_AS_ATTACH)
                        dwAction = OENA_FORWARDBYATTACH;
                    else if (nCmdID == ID_REPLY)
                        dwAction = OENA_REPLYTOAUTHOR;
                    else if (nCmdID == ID_REPLY_ALL)
                        dwAction = OENA_REPLYALL;
                    else if (nCmdID == ID_REPLY_GROUP)
                        dwAction = OENA_REPLYTONEWSGROUP;
                    else
                        AssertSz(FALSE, "Didn't ask for a valid action");

                    // Fill out the initialization information
                    rInitSite.dwInitType = OEMSIT_MSG_TABLE;
                    rInitSite.initTable.pMsgTable = pTable;
                    rInitSite.initTable.pListSelect = NULL;
                    if (FAILED(GetFolderIdFromMsgTable(pTable, &rInitSite.folderID)))
                        rInitSite.folderID = FOLDERID_INVALID;
                    rInitSite.initTable.rowIndex  = dwFocused;

                    m_pMsgList->FreeMessageInfo(pInfo);

                    // Create the note object
                    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, m_hwnd, (IUnknown *)m_pPumpRefCount);
                }
            }
        }
    }

exit:
    ReleaseObj(pTable);
    MemFree(rgRows);
    return (S_OK);
}

HRESULT CFindDlg::CmdCancelMessage(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    FOLDERID        idFolder;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            IMessageTable  *pTable = NULL;
            LPMESSAGEINFO   pInfo;
            // Get the message table from the message list.  The note will need
            // this to deal with next / prev commands
            hr = m_pMsgList->GetMessageTable(&pTable);
            if (FAILED(hr))
                goto exit;

            // Get some information about the message
            if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
            {
                if (SUCCEEDED(hr = m_pMsgList->GetRowFolderId(dwFocused, &idFolder)))
                    hr = NewsUtil_HrCancelPost(m_hwnd, idFolder, pInfo);

                m_pMsgList->FreeMessageInfo(pInfo);
            }
            pTable->Release();
        }
    }

exit:
    MemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdFindNow()
//
//  PURPOSE:    Start's a new find.
//
HRESULT CFindDlg::CmdFindNow(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, 
                             VARIANTARG *pvaOut)
{
    // Start by freeing our current find information if we have any
    _FreeFindInfo(&m_rFindInfo);

    // Retrieve the find values from the dialog and store them in the
    // m_rFindInfo struct.
    if (_GetFindValues(m_hwnd, &m_rFindInfo))
    {
        // Validate the data.  If the user has Date From && Date To set, make 
        // sure that to is after from.
        if ((m_rFindInfo.mask & (FIM_DATEFROM | FIM_DATETO)) == (FIM_DATEFROM | FIM_DATETO) &&
            CompareFileTime(&m_rFindInfo.ftDateTo, &m_rFindInfo.ftDateFrom) < 0)
        {
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrBadFindParams), NULL, MB_OK | MB_ICONINFORMATION);
            return (E_INVALIDARG);
        }
        
        // Case insensitive search
        if (m_rFindInfo.pszFrom)
            CharUpper(m_rFindInfo.pszFrom);
        if (m_rFindInfo.pszSubject)
            CharUpper(m_rFindInfo.pszSubject);
        if (m_rFindInfo.pszTo)
            CharUpper(m_rFindInfo.pszTo);
        if (m_rFindInfo.pszBody)
            CharUpper(m_rFindInfo.pszBody);
        
        // Show the bottom portion of the dialog
        _ShowResults(m_hwnd);

        // Start the find.
        _OnFindNow(m_hwnd);
    }
    else
    {
        // If we couldn't store the information, assume it's becuase
        // their isn't enough memory to 
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsMemory), NULL, MB_OK | MB_ICONINFORMATION);    
        DestroyWindow(m_hwnd);    
    }                    

    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdBrowseForFolder()
//
//  PURPOSE:    Bring's up the folder picker dialog
//
HRESULT CFindDlg::CmdBrowseForFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, 
                                     VARIANTARG *pvaOut)
{
    FOLDERID idFolder;
    return PickFolderInEdit(m_hwnd, GetDlgItem(m_hwnd, IDC_FOLDER), 0, NULL, NULL, &idFolder);
}


//
//  FUNCTION:   CFindDlg::CmdStop()
//
//  PURPOSE:    Called when the user want's to stop a find in progress.
//
HRESULT CFindDlg::CmdStop(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HWND hwndBtn;

    m_fAbort = TRUE;

    hwndBtn = GetDlgItem(m_hwnd, IDC_STOP);
    EnableWindow(hwndBtn, FALSE);
    Button_SetStyle(hwndBtn, BS_PUSHBUTTON, TRUE);

    hwndBtn = GetDlgItem(m_hwnd, IDC_FIND_NOW);
    EnableWindow(hwndBtn, _IsFindEnabled(m_hwnd));
    Button_SetStyle(hwndBtn, BS_DEFPUSHBUTTON, TRUE);

    EnableWindow(GetDlgItem(m_hwnd, IDC_RESET), TRUE);

    UpdateWindow(m_hwnd);

    if (m_pCancel != NULL)
        m_pCancel->Cancel(CT_CANCEL);

    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdReset()
//
//  PURPOSE:    Called when the user want's to reset the find criteria
//
HRESULT CFindDlg::CmdReset(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    _FreeFindInfo(&m_rFindInfo);
    m_rFindInfo.mask = FIM_FROM | FIM_TO | FIM_SUBJECT | FIM_BODYTEXT;
    _SetFindValues(m_hwnd, &m_rFindInfo);
    EnableWindow(GetDlgItem(m_hwnd, IDC_FIND_NOW), _IsFindEnabled(m_hwnd));
    ((CMessageList *) m_pMsgList)->SetFolder(FOLDERID_INVALID, NULL, FALSE, NULL, NOSTORECALLBACK);
    m_fFindComplete = FALSE;
    m_pStatusBar->SetStatusText((LPTSTR) c_szEmpty);

    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdBlockSender()
//
//  PURPOSE:    Add the sender of the selected messages to the block senders list
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::CmdBlockSender(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr = S_OK;
    DWORD *         rgRows = NULL;
    DWORD           cRows = 0;
    LPMESSAGEINFO   pInfo = NULL;
    IUnknown *      pUnkMessage = NULL;
    IMimeMessage *  pMessage = 0;
    LPSTR           pszEmailFrom = NULL;
    ADDRESSPROPS    rSender = {0};
    CHAR            szRes[CCHMAX_STRINGRES];
    LPSTR           pszResult = NULL;

    TraceCall("CFindDlg::CmdBlockSender");

    IF_FAILEXIT(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows));

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    IF_FAILEXIT(hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo));
    
    // Do we already have the address?
    if ((NULL != pInfo->pszEmailFrom) && ('\0' != pInfo->pszEmailFrom[0]))
    {
        pszEmailFrom = pInfo->pszEmailFrom;
    }
    else
    {
        // Load that message from the store
        IF_FAILEXIT(hr = m_pMsgList->GetMessage(rgRows[0], FALSE, FALSE, &pUnkMessage));

        if (NULL == pUnkMessage)
            IF_FAILEXIT(hr = E_FAIL);
        
        // Get the IMimeMessage interface from the message
        IF_FAILEXIT(hr = pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage));

        rSender.dwProps = IAP_EMAIL;
        IF_FAILEXIT(hr = pMessage->GetSender(&rSender));
        
        Assert(rSender.pszEmail && ISFLAGSET(rSender.dwProps, IAP_EMAIL));
        pszEmailFrom = rSender.pszEmail;
    }
    
    // Bring up the rule editor for this message
    IF_FAILEXIT(hr = RuleUtil_HrAddBlockSender((0 != (pInfo->dwFlags & ARF_NEWSMSG)) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL, pszEmailFrom));
    
    // Load the template string
    AthLoadString(idsSenderAdded, szRes, sizeof(szRes));

    // Allocate the space to hold the final string
    DWORD cchSize = (lstrlen(szRes) + lstrlen(pszEmailFrom) + 1);
    IF_FAILEXIT(hr = HrAlloc((VOID **) &pszResult, sizeof(*pszResult) * cchSize));

    // Build up the warning string
    wnsprintf(pszResult, cchSize, szRes, pszEmailFrom);

    // Show the success dialog
    AthMessageBox(m_hwnd, MAKEINTRESOURCE(idsAthena), pszResult, NULL, MB_OK | MB_ICONINFORMATION);

exit:
    MemFree(pszResult);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    ReleaseObj(pMessage);
    ReleaseObj(pUnkMessage);
    m_pMsgList->FreeMessageInfo(pInfo);
    MemFree(rgRows);
    if (FAILED(hr))
    {
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsSenderError), NULL, MB_OK | MB_ICONERROR);
    }
    return (hr);
}


//
//  FUNCTION:   CFindDlg::CmdCreateRule()
//
//  PURPOSE:    Add the sender of the selected messages to the block senders list
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::CmdCreateRule(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD *         rgRows = NULL;
    DWORD           cRows = 0;
    LPMESSAGEINFO   pInfo = NULL;
    IUnknown *      pUnkMessage = NULL;
    IMimeMessage *  pMessage = 0;

    TraceCall("CFindDlg::CmdCreateRule");

    // Get the array of selected rows from the message list

    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo)))
    {
        // Load that message from the store
        if (S_OK == m_pMsgList->GetMessage(rgRows[0], FALSE, FALSE, &pUnkMessage))
        {
            // Get the IMimeMessage interface from the message
            if (NULL != pUnkMessage)
            {
                pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage);
            }
        }
        
        // Bring up the rule editor for this message
        hr = HrCreateRuleFromMessage(m_hwnd, (0 != (pInfo->dwFlags & ARF_NEWSMSG)) ? 
                    CRFMF_NEWS : CRFMF_MAIL, pInfo, pMessage);
    }

    ReleaseObj(pMessage);
    ReleaseObj(pUnkMessage);
    m_pMsgList->FreeMessageInfo(pInfo);
    MemFree(rgRows);

    return (S_OK);
}

//
//  FUNCTION:   CFindDlg::CmdCombineAndDecode()
//
//  PURPOSE:    Combines the selected messages into a single message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::CmdCombineAndDecode(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    FOLDERID           idFolder;
    DWORD             *rgRows = NULL;
    DWORD              cRows = 0;
    CCombineAndDecode *pDecode = NULL;
    HRESULT            hr;

    // Create the decoder object
    pDecode = new CCombineAndDecode();
    if (!pDecode)
        return (S_OK);

    // Get the array of selected rows from the message list
    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
    {
        pDecode->Release();
        return (hr);
    }

    // Get a pointer to the message table
    IMessageTable *pTable = NULL;
    if (SUCCEEDED(m_pMsgList->GetMessageTable(&pTable)))
    {
        // Initialize the decoder
        if (SUCCEEDED(GetFolderIdFromMsgTable(pTable, &idFolder)))
            pDecode->Start(m_hwnd, pTable, rgRows, cRows, idFolder);

    }

    MemFree(rgRows);
    pDecode->Release();
    pTable->Release();

    return (S_OK);
}


void CFindDlg::_ShowResults(HWND hwnd)
{
    if (!m_fShowResults)
    {
        RECT rc;

        m_fShowResults = TRUE;

        GetWindowRect(hwnd, &rc);
        m_ptDragMin.y = (3 * m_ptDragMin.y) / 2;
 
        ShowWindow(GetDlgItem(hwnd, IDC_STATUS_BAR), SW_SHOW);
        ShowWindow(m_hwndList, SW_SHOW);

        SetWindowPos(hwnd, NULL, 0, 0, rc.right - rc.left, m_cyDlgFull, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
    }
}


void CFindDlg::_OnFindNow(HWND hwnd)
{
    HWND hwndBtn;

    m_fInProgress = TRUE;

    hwndBtn = GetDlgItem(hwnd, IDC_FIND_NOW);
    EnableWindow(hwndBtn, FALSE);
    Button_SetStyle(hwndBtn, BS_PUSHBUTTON, TRUE);

    EnableWindow(GetDlgItem(hwnd, IDC_RESET), FALSE);

    hwndBtn = GetDlgItem(hwnd, IDC_STOP);
    EnableWindow(hwndBtn, TRUE);
    Button_SetStyle(hwndBtn, BS_DEFPUSHBUTTON, TRUE);

    ShowWindow(m_hwndList, SW_SHOW);
    SetFocus(m_hwndList);

    UpdateWindow(hwnd);

    m_fAbort = m_fClose = FALSE;

    _StartFind(_GetCurSel(hwnd), IsDlgButtonChecked(hwnd, IDC_INCLUDE_SUB));

    CmdStop(ID_STOP, OLECMDEXECOPT_DODEFAULT, NULL, NULL);

    if (m_fClose)
        DestroyWindow(m_hwnd);

    m_fInProgress = FALSE;
}

FOLDERID CFindDlg::_GetCurSel(HWND hwnd)
{
    return GetFolderIdFromEdit(GetDlgItem(hwnd, IDC_FOLDER));
}

void CFindDlg::_StartFind(FOLDERID idFolder, BOOL fSubFolders)
{
    // If we're searching subfolders, then set that flag too
    m_rFindInfo.fSubFolders = fSubFolders;

    // Initialize the Message List
    ((CMessageList *)m_pMsgList)->SetFolder(idFolder, NULL, fSubFolders, &m_rFindInfo, (IStoreCallback *)this);
}


void CFindDlg::_FreeFindInfo(FINDINFO *pfi)
{
    FreeFindInfo(pfi);
}

void CFindDlg::_SetFindValues(HWND hwnd, FINDINFO *pfi)
{
    SYSTEMTIME  st;
    HWND        hwndTo;
    
    if (pfi->mask & FIM_FROM)
    {
        Assert(GetDlgItem(hwnd, IDC_FROM));
        Edit_SetText(GetDlgItem(hwnd, IDC_FROM), pfi->pszFrom);
    }
    if (pfi->mask & FIM_TO)
    {
        hwndTo = GetDlgItem(hwnd, IDC_TO);
        if (NULL != hwndTo)
        {
            Edit_SetText(hwndTo, pfi->pszTo);
        }
    }
    if (pfi->mask & FIM_SUBJECT)
    {
        Assert(GetDlgItem(hwnd, IDC_SUBJECT));
        Edit_SetText(GetDlgItem(hwnd, IDC_SUBJECT), pfi->pszSubject);
    }
    if (pfi->mask & FIM_BODYTEXT)
    {
        Assert(GetDlgItem(hwnd, IDC_BODY));
        Edit_SetText(GetDlgItem(hwnd, IDC_BODY), pfi->pszBody);
    }
    
    if (GetDlgItem(hwnd, IDC_HAS_ATTACH))
        CheckDlgButton(hwnd, IDC_HAS_ATTACH, (pfi->mask & FIM_ATTACHMENT) ? BST_CHECKED : BST_UNCHECKED);

    if (GetDlgItem(hwnd, IDC_HAS_FLAG))
        CheckDlgButton(hwnd, IDC_HAS_FLAG, (pfi->mask & FIM_FLAGGED) ? BST_CHECKED : BST_UNCHECKED);
    
    FileTimeToSystemTime(&pfi->ftDateFrom, &st);
    DateTime_SetSystemtime(GetDlgItem(hwnd, IDC_DATE_FROM), (pfi->mask & FIM_DATEFROM) ? GDT_VALID : GDT_NONE, &st);
    
    FileTimeToSystemTime(&pfi->ftDateTo, &st);
    DateTime_SetSystemtime(GetDlgItem(hwnd, IDC_DATE_TO), (pfi->mask & FIM_DATETO) ? GDT_VALID : GDT_NONE, &st);
}


BOOL CFindDlg::_GetFindValues(HWND hwnd, FINDINFO *pfi)
{
    SYSTEMTIME  st;
    
    pfi->mask = 0;
    
    if (!AllocStringFromDlg(hwnd, IDC_FROM, &pfi->pszFrom) ||
        !AllocStringFromDlg(hwnd, IDC_SUBJECT, &pfi->pszSubject) ||
        !AllocStringFromDlg(hwnd, IDC_TO, &pfi->pszTo) ||
        !AllocStringFromDlg(hwnd, IDC_BODY, &pfi->pszBody))
    {
        return FALSE;
    }
    
    if (pfi->pszFrom)
        pfi->mask |= FIM_FROM;
    if (pfi->pszSubject)
        pfi->mask |= FIM_SUBJECT;
    if (pfi->pszTo)
        pfi->mask |= FIM_TO;
    if (pfi->pszBody)
        pfi->mask |= FIM_BODYTEXT;
    
    if (IsDlgButtonChecked(hwnd, IDC_HAS_ATTACH))
        pfi->mask |= FIM_ATTACHMENT;
    
    if (IsDlgButtonChecked(hwnd, IDC_HAS_FLAG))
        pfi->mask |= FIM_FLAGGED;

    if (DateTime_GetSystemtime(GetDlgItem(hwnd, IDC_DATE_FROM), &st) != GDT_NONE)
    {
        pfi->mask |= FIM_DATEFROM;
        st.wHour = st.wMinute = st.wSecond = st.wMilliseconds = 0;  // start of the day
        SystemTimeToFileTime(&st, &pfi->ftDateFrom);
    }
    
    if (DateTime_GetSystemtime(GetDlgItem(hwnd, IDC_DATE_TO), &st) != GDT_NONE)
    {
        pfi->mask |= FIM_DATETO;

        // end of day
        st.wHour = 23;
        st.wMinute = 59;
        st.wSecond = 59;
        st.wMilliseconds = 999;
        SystemTimeToFileTime(&st, &pfi->ftDateTo);
    }
    
    return TRUE;
}


//
//  FUNCTION:   CFindDlg::_IsFindEnabled()
//
//  PURPOSE:    Checks to see if the "Find Now" button should be enabled.
//
BOOL CFindDlg::_IsFindEnabled(HWND hwnd)
{
    BOOL fEnable;
    SYSTEMTIME st;
    HWND hwndBody, hwndAttach, hwndTo;

    hwndBody   = GetDlgItem(hwnd, IDC_BODY);
    hwndAttach = GetDlgItem(hwnd, IDC_HAS_ATTACH);
    hwndTo     = GetDlgItem(hwnd, IDC_TO);

    // If we have content in any of these fields, we can search.
    fEnable = Edit_GetTextLength(GetDlgItem(hwnd, IDC_FROM)) ||
              Edit_GetTextLength(hwndTo) || 
              Edit_GetTextLength(GetDlgItem(hwnd, IDC_SUBJECT)) || 
              Edit_GetTextLength(hwndBody) || 
              IsDlgButtonChecked(hwnd, IDC_HAS_ATTACH) ||
              IsDlgButtonChecked(hwnd, IDC_HAS_FLAG) ||
              (DateTime_GetSystemtime(GetDlgItem(hwnd, IDC_DATE_FROM), &st) != GDT_NONE) ||
              (DateTime_GetSystemtime(GetDlgItem(hwnd, IDC_DATE_TO), &st) != GDT_NONE);

    return fEnable;
}


//
//  FUNCTION:   CFindDlg::_SetFindIntlFont()
//
//  PURPOSE:    Set's the correct international font for all edit boxes.
//
void CFindDlg::_SetFindIntlFont(HWND hwnd)
{
    HWND hwndT;

    hwndT = GetDlgItem(hwnd, IDC_FROM);
    if (hwndT != NULL)
        SetIntlFont(hwndT);
    hwndT = GetDlgItem(hwnd, IDC_TO);
    if (hwndT != NULL)
        SetIntlFont(hwndT);
    hwndT = GetDlgItem(hwnd, IDC_SUBJECT);
    if (hwndT != NULL)
        SetIntlFont(hwndT);
    hwndT = GetDlgItem(hwnd, IDC_BODY);
    if (hwndT != NULL)
        SetIntlFont(hwndT);
}


//
//  FUNCTION:   CFindDlg::_InitSizingInfo()
//
//  PURPOSE:    Grabs all the sizing information we'll need later when the 
//              dialog is resized.
//
void CFindDlg::_InitSizingInfo(HWND hwnd)
{
    RECT            rc, rcClient;
    RECT            rcEdit;
    WINDOWPLACEMENT wp;

    TraceCall("CFindDlg::_InitSizingInfo");

    // Get the overall size of the default dialog template
    GetClientRect(hwnd, &rcClient);
    m_cxDlgDef = rcClient.right - rcClient.left;
    m_yView = rcClient.bottom;

    // Make room for the menu bar and save that for resizing
    AdjustWindowRect(&rcClient, GetWindowStyle(hwnd), TRUE);
    m_ptDragMin.x = rcClient.right - rcClient.left;
    m_ptDragMin.y = rcClient.bottom - rcClient.top;

    GetWindowRect(GetDlgItem(hwnd, IDC_FOLDER), &rcEdit);
    MapWindowRect(NULL, hwnd, &rcEdit);
    m_xEdit = rcEdit.left;
    m_cxFolder = rcEdit.right - rcEdit.left;

    GetWindowRect(GetDlgItem(hwnd, IDC_INCLUDE_SUB), &rc);
    MapWindowRect(NULL, hwnd, &rc);
    m_xIncSub = rc.left;
    m_yIncSub = rc.top;

    GetWindowRect(GetDlgItem(hwnd, idcStatic1), &rc);
    m_cxStatic = rc.right - rc.left;

    GetWindowRect(GetDlgItem(hwnd, IDC_BROWSE_FOLDER), &rc);
    MapWindowRect(NULL, hwnd, &rc);
    m_yBrowse = rc.top;
    m_dxBtnGap = rc.left - rcEdit.right;

    GetWindowRect(GetDlgItem(hwnd, IDC_FIND_NOW), &rc);
    MapWindowRect(NULL, hwnd, &rc);
    m_xBtn = rc.left;
    m_dxBtn = rc.right - rc.left;
    m_yBtn = rc.top;

    GetWindowRect(GetDlgItem(hwnd, IDC_STOP), &rc);
    MapWindowRect(NULL, hwnd, &rc);
    m_dyBtn = rc.top - m_yBtn;

    GetWindowRect(GetDlgItem(hwnd, IDC_FROM), &rc);
    m_cxEdit = rc.right - rc.left;
    m_cyEdit = rc.bottom - rc.top;

    SetWindowPos(hwnd, NULL, 0, 0, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);

    if (sizeof(wp) == GetOption(OPT_FINDER_POS, (LPBYTE)&wp, sizeof(wp)))
    {
        if (wp.showCmd != SW_SHOWMAXIMIZED)
            wp.showCmd = SW_SHOWNORMAL;
        m_cyDlgFull = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
        SetWindowPlacement(hwnd, &wp);
    }
    else
    {
        m_cyDlgFull = (3 * m_ptDragMin.y) / 2;
        CenterDialog(hwnd);
    }
}


//
//  FUNCTION:   CFindDlg::QuerySwitchIdentities()
//
//  PURPOSE:    Determine if it is OK for the identity manager to 
//              switch identities now
//
HRESULT CFindDlg::QuerySwitchIdentities()
{
    if (!IsWindowEnabled(m_hwnd))
        return E_PROCESS_CANCELLED_SWITCH;

    return S_OK;
}


//
//  FUNCTION:   CFindDlg::SwitchIdentities()
//
//  PURPOSE:    The current identity has switched.  Close the window.
//
HRESULT CFindDlg::SwitchIdentities()
{
    if (m_fInProgress)
    {
        CmdStop(ID_STOP, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        m_fClose = TRUE;
    }
    else
    {
        DestroyWindow(m_hwnd);
    }
    return S_OK;
}


//
//  FUNCTION:   CFindDlg::IdentityInformationChanged()
//
//  PURPOSE:    Information about the current identity has changed.
//              This is ignored.
//
HRESULT CFindDlg::IdentityInformationChanged(DWORD dwType)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\fldbar.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     fldbar.h
//
//  PURPOSE:    Defines the CFolderBar class
//

#ifndef __FLDBAR_H__
#define __FLDBAR_H__

#include "browser.h"
#include "treeview.h"
#include "conman.h"

// Mouse Over Mode enum for DoMouseOver()
#ifndef WIN16
typedef enum MOMODE
#else
enum MOMODE
#endif
{ 
    MO_NORMAL = 0,      // DoMouseOver called in response to WM_MOUSEMOVE
    MO_DRAGOVER,        // in response to IDropTarget::DragEnter/DragOver
    MO_DRAGLEAVE,       // in response to IDropTarget::DragLeave
    MO_DRAGDROP         // in response to IDropTarget::Drop
};

class CFlyOutScope;

class CFolderBar : public IDockingWindow, 
                   public IObjectWithSite, 
                   public IDropTarget,
                   public IConnectionNotify
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and initialization
    CFolderBar();
    ~CFolderBar();
    
    HRESULT HrInit(IAthenaBrowser *pBrowser);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    
    /////////////////////////////////////////////////////////////////////////
    // IDockingWindow methods
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                        IUnknown* punkToolbarSite,
                                        BOOL fReserved);

    /////////////////////////////////////////////////////////////////////////
    // IObjectWithSite methods
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    /////////////////////////////////////////////////////////////////////////
    // IDropTarget methods
    virtual STDMETHODIMP DragEnter(IDataObject* pDataObject, DWORD grfKeyState, 
                                        POINTL pt, DWORD* pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject* pDataObject, DWORD grfKeyState,
                                   POINTL pt, DWORD* pdwEffect);

    /////////////////////////////////////////////////////////////////////////
    // CFolderBar members
    HRESULT SetCurrentFolder(FOLDERID idFolder);
    void ScopePaneDied(void);
    void KillScopeCloseTimer(void);
    void Update(BOOL fDisplayNameChanged, BOOL fShowDropDownIndicator);
    void KillScopeDropDown(void);
    void SetScopeCloseTimer(void);
    void SetFolderText(LPCTSTR pszText);

    //IConnectionNotify
    virtual STDMETHODIMP OnConnectionNotify(CONNNOTIFY  nCode, LPVOID pvData, CConnectionManager *pConMan);

    
private:
    /////////////////////////////////////////////////////////////////////////
    // Drawing
    void InvalidateFolderName(void);
    void SetFolderName(LPCTSTR pszFolderName);
    void Recalc(HDC hDC, LPCRECT prcAvailableSpace, BOOL fSizeChange);
    BOOL FEnsureIcon(void);
    void GetFolderNameRect(LPRECT prc);
    BOOL FDropDownEnabled(void);
    HFONT GetFont(UINT idsFont, int nWeight = FW_NORMAL);
    HFONT GetFont(LPTSTR pszFace, LONG lSize, int nWeight = FW_NORMAL);
    int	GetXChildIndicator(void);
    int	GetYChildIndicator(void);
    void DoMouseOver(LPPOINT ppt, MOMODE moMode);
    void KillHoverTimer(void);
    void DoMouseClick(POINT pt, DWORD grfKeyState);
    HRESULT HrShowScopeFlyOut(void);


    /////////////////////////////////////////////////////////////////////////
    // Window methods
    static LRESULT CALLBACK FolderWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam);
    static LRESULT CALLBACK FrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                         LPARAM lParam);
    
    void OnPaint(HWND hwnd);
    void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void OnTimer(HWND hwnd, UINT id);

    /////////////////////////////////////////////////////////////////////////
    // Misc Data
    ULONG               m_cRef;                 // Reference count
    FOLDERID            m_idFolder;             // Current Folder Id

    // Flags
    BOOL                m_fShow;                // TRUE if we're visible
    BOOL                m_fRecalc;              // TRUE if we should call Recalc() before painting
    BOOL                m_fSmallFolderBar;      // TRUE if we're smaller than big
    BOOL                m_fHighlightIndicator;  // TRUE if the mouse is over out button
    BOOL                m_fHoverTimer;          // TRUE if the hover timer is active
    BOOL                m_fDropDownIndicator;   // TRUE if the 'v' is beside the folder name

    // Interfaces we groove with
    IDockingWindowSite *m_pSite;                // Site pointer
    IAthenaBrowser     *m_pBrowser;             // Browser that owns us
    
    // Handy handles
    HWND                m_hwnd;                 // Our window
    HWND                m_hwndFrame;            // Our frame window 
    HWND                m_hwndParent;           // Our parent's window
    HWND                m_hwndScopeDropDown;    // Handle of the drop down scope pane
    
    // Crayons, markers, paper, etc.
    HFONT               m_hfFolderName;         // Folder name font
    HFONT               m_hfViewText;           // View text font
    HICON               m_hIconSmall;           // Small Icon

    // Sizes etc. for drawing, sizing, and fun!
    int                 m_cyControl,
                        m_dyChildIndicator,
                        m_dyIcon,
                        m_dyViewText,
                        m_dyFolderName,
                        m_cxFolderNameRight;
    RECT                m_rcFolderName,
                        m_rcFolderNamePlsu,
                        m_rcViewText;
    UINT                m_nFormatFolderName,
                        m_nFormatViewText;
    
    // The text we display
    LPTSTR              m_pszFolderName;        // Folder Name
    int                 m_cchFolderName;        // Size of m_pszFolderName
    LPTSTR              m_pszViewText;          // View text
    int                 m_cchViewText;          // Size of m_pszViewText

    // Drag & Drop stuff
    IDataObject        *m_pDataObject;          // Pointer to the IDataObject being dragged over us
    IDropTarget        *m_pDTCur;
    DWORD               m_dwEffectCur;
    DWORD               m_grfKeyState;
    };

    
inline void CFolderBar::ScopePaneDied()
    { m_hwndScopeDropDown = NULL; InvalidateFolderName(); }



class CFlyOutScope 
    {
    friend CFolderBar;

public:
    CFlyOutScope();
    ~CFlyOutScope();
    ULONG AddRef(void);
    ULONG Release(void);
    HRESULT HrDisplay(IAthenaBrowser *pBrowser, CFolderBar *pFolderBar, HWND hwndParent, HWND *phwndScope);
    void Destroy(void);

protected:
    static LRESULT CALLBACK FlyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void OnNcDestroy(HWND hwnd);
    void OnPaint(HWND hwnd);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnDestroy(HWND hwnd);
    
private:
    ULONG           m_cRef;
    IAthenaBrowser *m_pBrowser;
    CFolderBar     *m_pFolderBar;
    BOOL            m_fResetParent;
    CTreeView      *m_pTreeView;
    HWND            m_hwnd;
    HWND            m_hwndParent;
    HWND            m_hwndTree;
    HWND            m_hwndFolderBar;
    HWND            m_hwndFocus;
    HWND            m_hwndTreeParent;
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\fldrprop.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     fldrprop.h
//
//  PURPOSE:    Contains the control ID's and prototypes for the folder
//              and group property sheets
//


#ifndef __FLDRPROP_H__
#define __FLDRPROP_H__

// Dialog control ID's
#define IDC_FOLDERNAME_EDIT                         1001 
#define IDC_GROUPNAME_STATIC                        1002 
#define IDC_STATUS_STATIC                           1003 
#define IDC_LASTVIEWED_STATIC                       1004 
#define IDC_FOLDER_ICON                             1005 
#define IDC_FOLDER_FILE                             1006

//
//  FUNCTION:   GroupProp_Create()
//
//  PURPOSE:    Invokes a property sheet which displays properties for the
//              specified group.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that should be the dialog's 
//                        parent.
//      <in> pfidl      - fully qualified pidl to the newsgroup
//
//  RETURN VALUE:
//      TRUE  - The dialog was successfully displayed
//      FALSE - The dialog failed.
//
BOOL GroupProp_Create(HWND hwndParent, FOLDERID idFolder, BOOL fUpdatePage = FALSE);


//
//  FUNCTION:   FolderProp_Create()
//
//  PURPOSE:    Invokes a property sheet which displays properties for the
//              specified folder.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that should be the dialog's 
//                        parent.
//      <in> pfidl      - fully qualified pidl to the folder
//
//  RETURN VALUE:
//      TRUE  - The dialog was successfully displayed
//      FALSE - The dialog failed.
//
BOOL FolderProp_Create(HWND hwndParent, FOLDERID idFolder);


#endif // __FLDRPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\fontnsc.h ===
#ifndef _FONTNSC_H
#define _FONTNSC_H

HRESULT HrCreateColorMenu(ULONG idmStart, HMENU* pMenu, BOOL fUseAuto);
HRESULT HrCreateComboColor(HWND hCombo);
void Color_WMDrawItem(LPDRAWITEMSTRUCT pdis, INT iColor, BOOL fBackground=FALSE);
DWORD GetColorRGB(INT index);
void Color_WMMeasureItem(HDC hdc, LPMEASUREITEMSTRUCT pmis, INT iColor);
HRESULT HrColorMenu_Show(HMENU hmenuColor, HWND hwndParent, POINT pt, COLORREF *pclrf);
INT GetColorIndex(INT rbg);
void FillFontNames(HWND hwndCombo);
INT CALLBACK NEnumFontNameProc(LOGFONT *plf, TEXTMETRIC *ptm, INT nFontType, LPARAM lParam);
void FillSizes(HWND hwndSize);
HRESULT HrFromIDToRBG(INT id, LPWSTR pwszColor, BOOL fBkColor);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\fldbar.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     fldbar.cpp
//
//  PURPOSE:    Implements CFolderBar
//


#include "pch.hxx"
#include <iert.h>
#include "fldbar.h"
#include "resource.h"
#include <shlwapi.h>
#include "treeview.h"
#include "ourguid.h"
#include "goptions.h"
#include "browser.h"
#include "imnglobl.h"
#include "inpobj.h"
#include "storutil.h"
#include <strconst.h>
#include "demand.h"
#include "dragdrop.h"
#include "multiusr.h"
#include "instance.h"
#include "mirror.h"
// Margins
#define CX_MARGIN_CHILDINDICATOR    4   // space between folder text and child indicator
#define CX_MARGIN_TEXT              5   // space between left edge and folder text
#define CX_MARGIN_ICON              4   // 5 space between left edge and icon
#define CX_MARGIN_ICONTEXT          5   // space between icon and view text
#define CY_MARGIN_ICON              4   // border around icon 
#define CY_MARGIN_TEXTTOP           2   // space between folder name and top edge of bar
#define CY_MARGIN_TEXTBOTTOM        2   // space between folder name and bottom edge of bar
#define CY_MARGIN                   4   // 4? margin below control
#define CX_MARGIN_RIGHTEDGE         2   // margin between the right edge of the bar and the right edge of the window
#define CX_MARGIN_FOLDERVIEWTEXT    5   // space between folder and view text
#define CXY_MARGIN_FLYOUT           4   // 4? margin around flyout scope pane

// Width/Height of child indicator bitmap
#define	CX_LARGE_CHILDINDICATOR	8
#define	CY_LARGE_CHILDINDICATOR	4
#define	CX_SMALL_CHILDINDICATOR	4
#define	CY_SMALL_CHILDINDICATOR	2

#define	CX_SMALLICON	16
#define	CY_SMALLICON	16

#define	DY_SMALLLARGE_CUTOFF	12		// folder bar is small when it takes up more than
										// DY_SMALLLARGE_CUTOFF percent of the available space

// Fly out constants
#define	FLYOUT_INCREMENT	5

// Minimum width of flyout scope pane
#define	CX_MINWIDTH_FLYOUT	200

// Mouse-Over timer ID and interval
#define	IDT_MOUSEOVERCHECK		456
#define	ELAPSE_MOUSEOVERCHECK	250

// Drag/Drop mouse-over dropdown timer ID (interval is defined by OLE)
#define IDT_DROPDOWNCHECK		457

// Drag/Drop mouse leave dropdown removal timer ID and interval
#define IDT_SCOPECLOSECHECK		458
#define ELAPSE_SCOPECLOSECHECK	500

CFolderBar::CFolderBar()
    {
    m_cRef = 1;

    m_fShow = FALSE;
    m_fRecalc = TRUE;
    m_fHighlightIndicator = FALSE;
    m_fHoverTimer = FALSE;

    m_idFolder = FOLDERID_INVALID;

    m_pSite = NULL;

    m_hwnd = NULL;
    m_hwndFrame = NULL;
    m_hwndParent = NULL;
    m_hwndScopeDropDown = NULL;

    m_hfFolderName = 0;
    m_hfViewText = 0;
    m_hIconSmall = 0;

    m_pszFolderName = NULL;
    m_cchFolderName = 0;
    m_pszViewText = NULL;
    m_cchViewText = 0;

    m_pDataObject = NULL;
    m_pDTCur = NULL;
    m_dwEffectCur = 0;
    m_grfKeyState = 0;
    }

CFolderBar::~CFolderBar()
    {
    Assert(m_cRef == 0);

    SafeRelease(m_pSite);
    SafeRelease(m_pDataObject);
    SafeRelease(m_pDTCur);
    SafeMemFree(m_pszFolderName);
    SafeMemFree(m_pszViewText);
    SafeRelease(m_pBrowser);

    if (IsWindow(m_hwndFrame))
        DestroyWindow(m_hwndFrame);

    if (m_hfFolderName)
        DeleteObject(m_hfFolderName);
    if (m_hfViewText)
        DeleteObject(m_hfViewText);
    }

HRESULT CFolderBar::HrInit(IAthenaBrowser *pBrowser)
    {
    m_pBrowser = pBrowser;

    // Don't addref this.  It creates a circular ref count with the browser.
    // m_pBrowser->AddRef();

    BOOL fInfoColumn = FALSE;
    if (SUCCEEDED(m_pBrowser->GetViewLayout(DISPID_MSGVIEW_FOLDERLIST, 0, &fInfoColumn, 0, 0)))
        m_fDropDownIndicator = !fInfoColumn;

    return (S_OK);
    }

HRESULT CFolderBar::QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IOleWindow) ||
        IsEqualIID(riid, IID_IDockingWindow))
        {
        *ppvObj = (IDockingWindow *) this;
        m_cRef++;
        return (S_OK);
        }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
        {
        *ppvObj = (IObjectWithSite *)this;
        m_cRef++;
        return (S_OK);
        }
    else if (IsEqualIID(riid, IID_IDropTarget))
        {
        *ppvObj = (IDropTarget *) this;
        m_cRef++;
        return (S_OK);
        }

    *ppvObj = NULL;
    return (E_NOINTERFACE);
    }

ULONG CFolderBar::AddRef(void)
    {
    return (m_cRef++);
    }

ULONG CFolderBar::Release(void)
    {
    m_cRef--;

    if (m_cRef > 0)
        return (m_cRef);

    delete this;
    return (0);
    }

HRESULT CFolderBar::GetWindow(HWND *pHwnd)
    {
    if (m_hwnd)
        {
        *pHwnd = m_hwnd;
        return (S_OK);
        }
    else
        {
        *pHwnd = NULL;
        return (E_FAIL);
        }
    }

HRESULT CFolderBar::ContextSensitiveHelp(BOOL fEnterMode)
    {
    return (E_NOTIMPL);
    }    

//
//  FUNCTION:   CFolderBar::ShowDW()
//
//  PURPOSE:    Causes the folder bar to be either shown or hidden.
//
//  PARAMETERS:
//      <in> fShow - TRUE if the folder bar should be shown, FALSE to hide.
//
//  RETURN VALUE:
//      HRESULT 
//
#define FOLDERBARCLASS TEXT("FolderBar Window")
#define FRAMECLASS     TEXT("FolderBar Frame")
HRESULT CFolderBar::ShowDW(BOOL fShow)
    {
    HRESULT hr = S_OK;
    TCHAR   szName[CCHMAX_STRINGRES] = {0};
    DWORD dwErr;

    // If we have a site pointer, but haven't been created yet, create the window
    if (!m_hwndFrame && m_pSite)
        {
        m_hwndParent = NULL;
        hr = m_pSite->GetWindow(&m_hwndParent);

        if (SUCCEEDED(hr))
            {
            WNDCLASSEX wc = {0};

            // Check to see if we need to register the class first
            wc.cbSize = sizeof(WNDCLASSEX);
            if (!GetClassInfoEx(g_hInst, FOLDERBARCLASS, &wc))
                {
                wc.lpfnWndProc   = FolderWndProc;
                wc.hInstance     = g_hInst;
                wc.hCursor       = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
                wc.lpszClassName = FOLDERBARCLASS;

                if (!RegisterClassEx(&wc))
                {
                    dwErr = GetLastError();
                }

                wc.lpfnWndProc   = FrameWndProc;
                wc.hbrBackground = (HBRUSH) (COLOR_3DFACE + 1);
                wc.lpszClassName = FRAMECLASS;

                if (!RegisterClassEx(&wc))
                {
                    dwErr = GetLastError();
                }
            }

            m_hwndFrame = CreateWindow(FRAMECLASS, NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
                                       0, 0, 1, 1, m_hwndParent, (HMENU) 0, g_hInst, (LPVOID *) this);
            if (!m_hwndFrame)
                {
                GetLastError();
                return (E_OUTOFMEMORY);
                }

            LoadString(g_hLocRes, idsFolderBar, szName, ARRAYSIZE(szName));

            m_hwnd = CreateWindow(FOLDERBARCLASS, szName, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE,
                                  0, 0, 0, 0, m_hwndFrame, (HMENU) 0, g_hInst, (LPVOID*) this);
            if (!m_hwnd)
                {
                GetLastError();
                return (E_OUTOFMEMORY);
                }
            RegisterDragDrop(m_hwnd, (IDropTarget *) this);
            }
        }

    // Set our state flags
    m_fShow = fShow;

    // Resize the folder bar based on its new hidden / visible state
    if (m_hwndFrame)
        {
        ResizeBorderDW(NULL, NULL, FALSE);
        ShowWindow(m_hwndFrame, fShow ? SW_SHOW : SW_HIDE);
        }

    return (hr);
    }


//
//  FUNCTION:   CFolderBar::CloseDW()
//
//  PURPOSE:    Destroys the folder bar.
//
HRESULT CFolderBar::CloseDW(DWORD dwReserved)
    {    
    if (m_hwndFrame)
        {
        DestroyWindow(m_hwndFrame);
        m_hwndFrame = NULL;
        m_hwnd = NULL;
        }
        
    return S_OK;
    }

//
//  FUNCTION:   CFolderBar::ResizeBorderDW()
//
//  PURPOSE:    This is called when the folder bar needs to resize.  The bar
//              in return figures out how much border space will be required 
//              from the parent frame and tells the parent to reserve that
//              space.  The bar then resizes itself to those dimensions.
//
//  PARAMETERS:
//      <in> prcBorder       - Rectangle containing the border space for the
//                             parent.
//      <in> punkToolbarSite - Pointer to the IDockingWindowSite that we are
//                             part of.
//      <in> fReserved       - Ignored.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CFolderBar::ResizeBorderDW(LPCRECT prcBorder,
                                   IUnknown* punkToolbarSite,
                                   BOOL fReserved)
    {
    RECT rcRequest = {0, 0, 0, 0};
    BOOL fFontChange;

    if (!m_pSite)
        return (E_FAIL);

    if (m_fShow)
        {
        RECT rcBorder;

        if (!prcBorder)
            {
            // Find out how big our parent's border space is
            m_pSite->GetBorderDW((IDockingWindow *) this, &rcBorder);
            prcBorder = &rcBorder;
            }

        if (m_fRecalc)
            {
            fFontChange = TRUE;
            InvalidateRect(m_hwnd, NULL, TRUE);
            }
        else
            {
            fFontChange = FALSE;
            InvalidateRect(m_hwnd, NULL, TRUE);
            }            

        // Recalc our internal sizing info
        Recalc(NULL, prcBorder, fFontChange);

        // Position ourself
        rcRequest.top = m_cyControl + CY_MARGIN;

        SetWindowPos(m_hwndFrame, NULL, prcBorder->left, prcBorder->top, prcBorder->right - prcBorder->left,
                     rcRequest.top, SWP_NOACTIVATE | SWP_NOZORDER);
        }

    m_pSite->SetBorderSpaceDW((IDockingWindow *) this, &rcRequest);
    
    return (S_OK);
    }

//
//  FUNCTION:   CFolderBar::SetSite()
//
//  PURPOSE:    Allows the owner of the coolbar to tell it what the current
//              IDockingWindowSite interface to use is.
//
//  PARAMETERS:
//      <in> punkSite - Pointer of the IUnknown to query for IDockingWindowSite.
//                      If this is NULL, we just release our current pointer.
//
//  RETURN VALUE:
//      S_OK - Everything worked
//      E_FAIL - Could not get IDockingWindowSite from the punkSite provided.
//
HRESULT CFolderBar::SetSite(IUnknown* punkSite)
    {
    // If we had a previous pointer, release it.
    if (m_pSite)
        {
        m_pSite->Release();
        m_pSite = NULL;
        }
    
    // If a new site was provided, get the IDockingWindowSite interface from it.
    if (punkSite)    
        {
        if (FAILED(punkSite->QueryInterface(IID_IDockingWindowSite, 
                                            (LPVOID*) &m_pSite)))
            {
            Assert(m_pSite);
            return E_FAIL;
            }
        }
   
    return (S_OK);    
    }    

HRESULT CFolderBar::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}


//
//  FUNCTION:   CFolderBar::SetCurrentFolder()
//
//  PURPOSE:    Tells the control to display information for a different folder
//
//  PARAMETERS:
//      <in> pidl - PIDL for the new folder
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CFolderBar::SetCurrentFolder(FOLDERID idFolder)
    {
    // NOTE - This routine never fails.  It will just show everything blank
    UINT        uIndex = -1;
    TCHAR       sz[CCHMAX_STRINGRES];
    FOLDERINFO  Folder;

    // Invalidate and let the paint routine know that we're going to need to 
    // recalc 
    m_fRecalc = TRUE;
    InvalidateRect(m_hwnd, NULL, TRUE);

    // Save the Folder Id
    m_idFolder = idFolder;

    // Get Folder Info
    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        return (S_OK);

    // Set Icon
    uIndex = GetFolderIcon(&Folder);

    // Clear the view text
    SetFolderText(MU_GetCurrentIdentityName());

    if ((g_dwAthenaMode & MODE_NEWSONLY) && (Folder.tyFolder == FOLDER_ROOTNODE))
    {
        //Change the name from OutLookExpress to Outlook News
        ZeroMemory(sz, sizeof(TCHAR) * CCHMAX_STRINGRES);
        LoadString(g_hLocRes, idsOutlookNewsReader, sz, ARRAYSIZE(sz));

        SetFolderName(sz);
    }
    else
    {
        // Set the folder name
        SetFolderName(Folder.pszName);
    }

    // Free the previous icons
    if (m_hIconSmall)
        {
        DestroyIcon(m_hIconSmall);
        m_hIconSmall = 0;
        }

    if (-1 != uIndex)
        {
        // Load the small icon
        HIMAGELIST himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, 
                                RGB(255, 0, 255));
        if (NULL != himl)
            {
            m_hIconSmall = ImageList_GetIcon(himl, uIndex, ILD_NORMAL);
            ImageList_Destroy(himl);
            }
        }

    // If this folder is moderated or blocked, say so
    TCHAR szRes[CCHMAX_STRINGRES];
    if (Folder.dwFlags & FOLDER_MODERATED)
    {
        AthLoadString(idsModerated, szRes, ARRAYSIZE(szRes));
        SetFolderText(szRes);
    }
    else if (Folder.dwFlags & FOLDER_BLOCKED)
    {
        AthLoadString(idsBlocked, szRes, ARRAYSIZE(szRes));
        SetFolderText(szRes);
    }

    g_pStore->FreeRecord(&Folder);

    return (S_OK);
    }


void CFolderBar::SetFolderText(LPCTSTR pszText)
    {
    // Invalidate and let the paint routine know we are going to need to
    // recalc
    m_fRecalc = TRUE;
    InvalidateRect(m_hwnd, NULL, TRUE);

    // Free an old text
    SafeMemFree(m_pszViewText);
    m_cchViewText = 0;

    if (pszText && *pszText)
        {
        m_pszViewText = PszDupA(pszText);
        m_cchViewText = lstrlen(pszText);
        }
    }


void CFolderBar::SetFolderName(LPCTSTR pszFolderName)
    {    
    // Free the old folder name
    SafeMemFree(m_pszFolderName);
    m_cchFolderName = 0;
    
    // Copy the new one
    if (pszFolderName)
        {
        m_pszFolderName = PszDupA(pszFolderName);
        m_cchFolderName = lstrlen(m_pszFolderName);
        }
    }

// Calculates the rectangle which surrounds the folder name
void CFolderBar::GetFolderNameRect(LPRECT prc)
    {
    Assert(prc);

    GetClientRect(m_hwnd, prc);
    prc->right = m_cxFolderNameRight;
    }


void CFolderBar::Recalc(HDC hDC, LPCRECT prcAvailableSpace, BOOL fSizeChange)
    {
    int         cyIcon = CY_SMALLICON,
                cxIcon = CX_SMALLICON;
    BOOL        fReleaseDC;
    TEXTMETRIC  tmFolderName,
                tmViewText;
    RECT        rcClient;
    SIZE        sFolderName,
                sViewText;
    HFONT       hFontOld;

    // Signal that we don't need to recalc again
    m_fRecalc = FALSE;

    if (prcAvailableSpace)
        {
        rcClient.left = 0;
        rcClient.top = 0;
        rcClient.right = prcAvailableSpace->right - prcAvailableSpace->left;
        rcClient.bottom = prcAvailableSpace->bottom - prcAvailableSpace->top;
        }
    else
        GetClientRect(m_hwnd, &rcClient);

    // Get a device context if we were not given one
    if (hDC)
        fReleaseDC = FALSE;
    else
        {
        hDC = GetDC(m_hwnd);
        fReleaseDC = TRUE;
        }

    // Create the fonts
    if (fSizeChange || !m_hfFolderName || !m_hfViewText)
        {
        if (m_hfFolderName)
            DeleteObject(m_hfFolderName);
        if (m_hfViewText)
            DeleteObject(m_hfViewText);
    

        // Create the font we are going to use for the folder name
        m_hfFolderName = GetFont(idsFontFolderSmall, FW_BOLD);
        m_hfViewText = GetFont(idsFontViewTextSmall, FW_BOLD);
        

        // Determine the height of the control, which is whatever is larger of                                                                         i
        // the following two things
        //      1) The icon height plus the icon margin
        //      2) The text height plus the text margin
        hFontOld = SelectFont(hDC, m_hfFolderName);
        GetTextMetrics(hDC, &tmFolderName);
        SelectFont(hDC, hFontOld);
        m_cyControl = max(cyIcon + CY_MARGIN_ICON,
                          tmFolderName.tmHeight + CY_MARGIN_TEXTTOP + CY_MARGIN_TEXTBOTTOM);

        // The top of the folder name text is position so that we have the correct
        // amount of border at the bottom of the control
        m_dyFolderName = m_cyControl - tmFolderName.tmHeight - CY_MARGIN_TEXTBOTTOM;

        // Get the height of the view text
        hFontOld = SelectFont(hDC, m_hfViewText);
        GetTextMetrics(hDC, &tmViewText);
        SelectFont(hDC, hFontOld);

        // The view text is positioned such that it's baseline matches the baseline
        // of the folder name
        m_dyViewText = m_dyFolderName + tmFolderName.tmAscent - tmViewText.tmAscent;

        // The child indicator is positioned such that the bottom of the bitmap lines
        // up with the baseline of the folder name
        m_dyChildIndicator = m_cyControl - CY_MARGIN_TEXTBOTTOM - tmFolderName.tmDescent - GetYChildIndicator();

        // The folder icon is centered within the control
        m_dyIcon = (m_cyControl - cyIcon) / 2;

        // Number must be even to ensure good-looking triangular drop arrow.
        Assert(GetXChildIndicator() % 2 == 0);

        // Width must be multiple of height for triangle to look smooth.
        Assert(GetXChildIndicator() % GetYChildIndicator() == 0);
        }

    // The view text is right justified within the folder bar
    if (m_cchViewText)
        {
        m_rcViewText.top = m_dyViewText;
        m_rcViewText.right = rcClient.right - CX_MARGIN_TEXT;

        m_rcViewText.bottom = rcClient.bottom;
        m_nFormatViewText = DT_RIGHT | DT_TOP | DT_SINGLELINE | DT_NOPREFIX;
        hFontOld = SelectFont(hDC, m_hfViewText);
        GetTextExtentPoint32(hDC, m_pszViewText, m_cchViewText, &sViewText);
        SelectFont(hDC, hFontOld);
        m_rcViewText.left = m_rcViewText.right - sViewText.cx;
        }


    // The folder name is left justified within the folder bar.  It is clipped
    // so that it does not overlap the view text
    if (m_cchFolderName)
        {
        m_rcFolderName.left = CX_MARGIN_ICONTEXT + cxIcon + CX_MARGIN_ICON;
        m_rcFolderName.top = m_dyFolderName;

        if (m_cchViewText)
            m_rcFolderName.right = m_rcViewText.left - CX_MARGIN_FOLDERVIEWTEXT;
        else
            m_rcFolderName.right = rcClient.right;

        m_rcFolderName.bottom = rcClient.bottom;

        if (FDropDownEnabled())
            m_rcFolderName.right -= GetXChildIndicator() + CX_MARGIN_CHILDINDICATOR;

        m_nFormatFolderName = DT_LEFT | DT_BOTTOM | DT_SINGLELINE | DT_NOPREFIX;

        hFontOld = SelectFont(hDC, m_hfFolderName);
        GetTextExtentPoint32(hDC, m_pszFolderName, m_cchFolderName, &sFolderName);

        if (sFolderName.cx > (m_rcFolderName.right - m_rcFolderName.left))
            {
            m_nFormatFolderName |= DT_END_ELLIPSIS;
#ifndef WIN16
            DrawTextEx(hDC, m_pszFolderName, m_cchFolderName, &m_rcFolderName,
                       m_nFormatFolderName | DT_CALCRECT, NULL);
#else
            DrawText(hDC, m_pszFolderName, m_cchFolderName, &m_rcFolderName,
                       m_nFormatFolderName | DT_CALCRECT);
#endif // !WIN16
            }
        else
            {
            m_nFormatFolderName |= DT_NOCLIP;
            m_rcFolderName.right = m_rcFolderName.left + sFolderName.cx;
            }

        SelectFont(hDC, hFontOld);
        m_cxFolderNameRight = m_rcFolderName.right + CX_MARGIN_TEXT;

        if (FDropDownEnabled())
            m_cxFolderNameRight += GetXChildIndicator() + CX_MARGIN_CHILDINDICATOR + 2;
        }


    // When the folder name is clipped it will always display at least one letter
    // followed by ellipsis.  Make sure not to draw the view text over this.
    if (m_cchViewText)
        {
        if (m_rcViewText.left < m_rcFolderName.right + CX_MARGIN_FOLDERVIEWTEXT)
            m_rcViewText.left = m_rcFolderName.right + CX_MARGIN_FOLDERVIEWTEXT;
        else
            m_nFormatViewText |= DT_NOCLIP;
        }

    if (fReleaseDC)
        ReleaseDC(m_hwnd, hDC);
    }

HFONT CFolderBar::GetFont(UINT idsFont, int nWeight)
    {
    // The font info is stored as a string in the resources so the localizers
    // can get to it.  The format of the string is "face,size"
    TCHAR   sz[CCHMAX_STRINGRES];
    LPTSTR  pszFace, pszTok;
    LONG    lSize;

    // Load the setting
    AthLoadString(idsFont, sz, ARRAYSIZE(sz));

    // Parse out the face name
    pszTok = sz;
    pszFace = StrTokEx(&pszTok, g_szComma);

    // Parse out the size
    lSize = StrToInt(StrTokEx(&pszTok, g_szComma));
    return(GetFont(/* pszFace*/ NULL, lSize, nWeight)); // (YST) szFace parametr was always ignored in OE 4.0, 
    }

HFONT CFolderBar::GetFont(LPTSTR pszFace, LONG lSize, int nWeight)
{
    HFONT   hf;
    HDC     hdc = GetDC(m_hwnd);
#ifndef WIN16
    ICONMETRICS icm;
#else
    LOGFONT lf;
#endif

    lSize = -MulDiv(lSize, GetDeviceCaps(hdc, LOGPIXELSY), 720);

#ifndef WIN16
    // Get the title bar font from the system
    icm.cbSize = sizeof(ICONMETRICS);
    SystemParametersInfo(SPI_GETICONMETRICS, sizeof(ICONMETRICS), 
                         (LPVOID) &icm, FALSE);

    // Create the font
    hf = CreateFont(lSize, 0, 0, 0, nWeight, 0, 0, 0, DEFAULT_CHARSET,
                    OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                    icm.lfFont.lfPitchAndFamily, (pszFace ? pszFace : icm.lfFont.lfFaceName));
#else
    // Get the logical font infomation for the current icon-title font.
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, FALSE);


    // Create the font
    hf = CreateFont(lSize, 0, 0, 0, nWeight /* FW_NORMAL*/, 0, 0, 0, DEFAULT_CHARSET,
                    OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                    lf.lfPitchAndFamily, (pszFace ? pszFace : icm.lfFont.lfFaceName));
#endif // !WIN16

    ReleaseDC(m_hwnd, hdc);

    return (hf);

}

void CFolderBar::OnPaint(HWND hwnd)
    {
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rcClient, 
                rc;
    POINT       pt[3];
    HBRUSH      hBrush,
                hBrushOld;
    HPEN        hPen,
                hPenOld;
    HFONT       hFontOld;
    COLORREF    crFG = GetSysColor(COLOR_WINDOW);
    COLORREF    crWindowText = GetSysColor(COLOR_WINDOWTEXT);
#ifndef WIN16
    COLORREF    crBtnHighlight = GetSysColor(COLOR_BTNHILIGHT);
#else
    COLORREF    crBtnHighlight = GetSysColor(COLOR_BTNHIGHLIGHT);
#endif // !WIN16

    GetClientRect(m_hwnd, &rcClient);

    hdc = BeginPaint(m_hwnd, &ps);

    // Recalc the text positions
    if (m_fRecalc)
        Recalc(hdc, NULL, FALSE);

    // Paint the background
    hBrush = CreateSolidBrush(GetSysColor(COLOR_3DSHADOW));
    hBrushOld = SelectBrush(hdc, hBrush);
    PatBlt(hdc, rcClient.left, rcClient.top, rcClient.right - rcClient.left,
           rcClient.bottom - rcClient.top, PATCOPY);
    SelectBrush(hdc, hBrushOld);
    DeleteBrush(hBrush);

    // Set the foreground and background color
    SetBkColor(hdc, GetSysColor(COLOR_3DSHADOW));
    SetTextColor(hdc, crFG);

    // Folder name
    if (m_cchFolderName)
        {
        hFontOld = SelectFont(hdc, m_hfFolderName);

        // Use IDrawText because DrawTextEx() doesn't handle DBCS.  
        // Note, the "bottom - top" nonsense for the last param is to undo some
        // vertical centering that IDrawText is trying to do that we don't want.
        IDrawText(hdc, m_pszFolderName, &m_rcFolderName, m_nFormatFolderName & DT_END_ELLIPSIS,
                  m_rcFolderName.bottom - m_rcFolderName.top);
        SelectFont(hdc, hFontOld);
        
        }

    // Drop-down indicator
    if (FDropDownEnabled())
        {
        pt[0].x = m_rcFolderName.right + CX_MARGIN_CHILDINDICATOR;
        pt[0].y = m_dyChildIndicator;
        pt[1].x = pt[0].x + GetXChildIndicator();
        pt[1].y = pt[0].y;
        pt[2].x = pt[0].x + GetXChildIndicator() / 2;
        pt[2].y = pt[0].y + GetYChildIndicator();

        hPen = CreatePen(PS_SOLID, 1, crFG);
        hBrush = CreateSolidBrush(crFG);
        hPenOld = SelectPen(hdc, hPen);
        hBrushOld = SelectBrush(hdc, hBrush);
        Polygon(hdc, pt, 3);
        SelectPen(hdc, hPenOld);
        SelectBrush(hdc, hBrushOld);
        DeleteObject(hPen);
        DeleteObject(hBrush);
        }

	// Mouse-over highlight
	if (m_fHighlightIndicator || m_hwndScopeDropDown)
		{
		hPen = CreatePen(PS_SOLID, 1, m_hwndScopeDropDown ? crWindowText : crBtnHighlight);
		hPenOld = SelectPen(hdc, hPen);
		pt[0].x = rcClient.left;
		pt[0].y = rcClient.bottom - 1; // - CY_MARGIN;
		pt[1].x = rcClient.left;
		pt[1].y = rcClient.top;
		pt[2].x = m_cxFolderNameRight - 1;
		pt[2].y = rcClient.top;
		Polyline(hdc, (POINT *)&pt, 3);
		SelectPen(hdc, hPenOld);
		DeleteObject(hPen);
		
		hPen = CreatePen(PS_SOLID, 1, m_hwndScopeDropDown ? crBtnHighlight : crWindowText);
		hPenOld = SelectPen(hdc, hPen);
		pt[1].x = m_cxFolderNameRight - 1;
		pt[1].y = rcClient.bottom - 1; //  - CY_MARGIN;
		pt[2].x = pt[1].x;
		pt[2].y = rcClient.top - 1;
		Polyline(hdc, (POINT *)&pt, 3);
		SelectPen(hdc, hPenOld);
		DeleteObject(hPen);
		}

    // View text
    if (m_cchViewText)
        {
        SetTextColor(hdc, crFG);
        hFontOld = SelectFont(hdc, m_hfViewText);
        ExtTextOut(hdc, m_rcViewText.left, m_rcViewText.top, ETO_OPAQUE | ETO_CLIPPED,
                   &m_rcViewText, m_pszViewText, m_cchViewText, NULL);
        SelectFont(hdc, hFontOld);
        }

    // Folder Icon
    if (m_hIconSmall)
        {
        int x = rcClient.left + CX_MARGIN_ICON;
        int y = m_dyIcon;
        
        DrawIconEx(hdc, x, y, m_hIconSmall, CX_SMALLICON, CY_SMALLICON, 0, NULL, DI_NORMAL);
        }

    EndPaint(m_hwnd, &ps);
    }


BOOL CFolderBar::FDropDownEnabled(void)
    {
    return (m_fDropDownIndicator);
    }

void CFolderBar::InvalidateFolderName(void)
    { 
	RECT rcFolderName;
	
	if (m_fRecalc)
		InvalidateRect(m_hwnd, NULL, TRUE);
	else
		{
		GetFolderNameRect(&rcFolderName);
		InvalidateRect(m_hwnd, &rcFolderName, TRUE);
		}
    }

int	CFolderBar::GetXChildIndicator()
    {
	return CX_SMALL_CHILDINDICATOR;
    }

int	CFolderBar::GetYChildIndicator()
    {
	return CY_SMALL_CHILDINDICATOR;
    }

LRESULT CALLBACK CFolderBar::FolderWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    CFolderBar *pThis = (CFolderBar *) GetWndThisPtr(hwnd);

    switch (uMsg)
        {
        case WM_NCCREATE:
            {
            pThis = (CFolderBar *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
            SetWndThisPtr(hwnd, (LONG_PTR) pThis);
            return (TRUE);
            }

        HANDLE_MSG(hwnd, WM_PAINT,       pThis->OnPaint);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,   pThis->OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, pThis->OnLButtonDown);
        HANDLE_MSG(hwnd, WM_TIMER,       pThis->OnTimer);

        case WM_CREATE:
        {
#ifndef WIN16
         if (g_pConMan)
            g_pConMan->Advise((IConnectionNotify*)pThis);
#endif  
         break;
        }

        case WM_DESTROY:
        {
#ifndef WIN16
         if (g_pConMan)
            g_pConMan->Unadvise((IConnectionNotify*)pThis);
#endif
         RevokeDragDrop(hwnd);
         break;
        }

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            {
            pThis->Recalc(NULL, NULL, TRUE);
            InvalidateRect(pThis->m_hwnd, NULL, TRUE);
            return (0);
            }

        case WM_PALETTECHANGED:

            InvalidateRect(pThis->m_hwnd, NULL, TRUE);
            break;

        case WM_QUERYNEWPALETTE:
            InvalidateRect(pThis->m_hwnd, NULL, TRUE);
            return(TRUE);
        }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

void CFolderBar::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
    {
    POINT pt = {x, y};
#if 0
    if (!IsRectEmtpy(&m_rcDragDetect) && !PtInRect(m_rcDragDetect, pt))
        {
        SetRectEmpty(m_rcDragDetect);
        HrBeginDrag();
        }
    else
#endif
        DoMouseOver(&pt, MO_NORMAL);
    }


void CFolderBar::OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
    {
    POINT pt = {x, y};
    DoMouseClick(pt, keyFlags);
    }


void CFolderBar::OnTimer(HWND hwnd, UINT id)
    {
    RECT rcClient;
    POINT pt;
    DWORD dwMP;
    BOOL fHighlightOff = FALSE;

    dwMP = GetMessagePos();
    pt.x = LOWORD(dwMP);
    pt.y = HIWORD(dwMP);
    ScreenToClient(m_hwnd, &pt);

    if (id == IDT_MOUSEOVERCHECK)
        {
        GetClientRect(m_hwnd, &rcClient);
		// No need to handle mouse in client area, OnMouseMove will catch this. We
		// only need to catch the mouse moving out of the client area.
		if (!PtInRect(&rcClient, pt))
			{
			KillTimer(m_hwnd, IDT_MOUSEOVERCHECK);
			fHighlightOff = TRUE;
			}
		}
	else if (id == IDT_DROPDOWNCHECK)
		{
		DoMouseClick(pt, 0);
// ???		DoDeferredCall(DEFERREDCALL_REGISTERTARGET);
		fHighlightOff = TRUE;
		}
	else if (id == IDT_SCOPECLOSECHECK)
		{
		KillScopeDropDown();
		}
#ifdef	DEBUG
	else
		AssertSz(FALSE, "Hey! Who has another timer going here?");
#endif

	if (fHighlightOff)
		{
		m_fHighlightIndicator = FALSE;
		InvalidateFolderName();
		}
	
	return;
    }


void CFolderBar::DoMouseOver(LPPOINT ppt, MOMODE moMode)
    {
    HWND hwndActive;
    RECT rcFolderName;

    if (!FDropDownEnabled() || m_hwndScopeDropDown)
        return;

    if (moMode == MO_NORMAL)
        {
        // Only do mouse-over if we are the active window and not d&d
        hwndActive = GetActiveWindow();
        if (!hwndActive || (hwndActive != m_hwndParent && IsChild(m_hwndParent, hwndActive)))
            return;
        }

    GetFolderNameRect(&rcFolderName);

    if (moMode == MO_DRAGLEAVE || moMode == MO_DRAGDROP)
        ppt->x = rcFolderName.left - 1;   // Force point to be outside

    if (m_fHighlightIndicator != PtInRect(&rcFolderName, *ppt))
        {
        m_fHighlightIndicator = !m_fHighlightIndicator;
        InvalidateFolderName();

        if (moMode == MO_DRAGOVER)
            {
            if (!m_hwndScopeDropDown && m_fHoverTimer != m_fHighlightIndicator)
                {
                KillHoverTimer();
                if (m_fHighlightIndicator)
                    m_fHoverTimer = (0 != SetTimer(m_hwnd, IDT_DROPDOWNCHECK, GetDoubleClickTime(), NULL));
                }
            }
        else
            {
            KillTimer(m_hwnd, IDT_MOUSEOVERCHECK);
            if (m_fHighlightIndicator)
                SetTimer(m_hwnd, IDT_MOUSEOVERCHECK, ELAPSE_MOUSEOVERCHECK, NULL);
            }
        }
    }


void CFolderBar::KillHoverTimer()
    {
	if (m_fHoverTimer)
		{
		KillTimer(m_hwnd, IDT_DROPDOWNCHECK);
		m_fHoverTimer = fFalse;
		}
    }


void CFolderBar::DoMouseClick(POINT pt, DWORD grfKeyState)
    {
    RECT rcFolderName;

    if (!FDropDownEnabled())
        return;

    GetFolderNameRect(&rcFolderName);
    if (PtInRect(&rcFolderName, pt))
        {
        if (IsWindow(m_hwndScopeDropDown))
            KillScopeDropDown();
        else
            {
            KillHoverTimer();
            HrShowScopeFlyOut();
            }
        }
    }

void CFolderBar::KillScopeDropDown(void)
    {
	POINT pt;
	
	// During window destruction hwndScopeDropDown gets set to NULL.
	if (IsWindow(m_hwndScopeDropDown))
		{
		KillScopeCloseTimer();
		DestroyWindow(m_hwndScopeDropDown);
        m_hwndScopeDropDown = NULL;
		pt.x = pt.y = 0;
		DoMouseOver(&pt, MO_DRAGLEAVE);
		}
    }

void CFolderBar::SetScopeCloseTimer(void)
    {
	KillScopeCloseTimer();

	// If we can't set the timer, we just do it immediately.
	if (!SetTimer(m_hwnd, IDT_SCOPECLOSECHECK, ELAPSE_SCOPECLOSECHECK, NULL))
		SendMessage(m_hwnd, WM_TIMER, (WPARAM) IDT_SCOPECLOSECHECK, NULL);
    }
    
void CFolderBar::KillScopeCloseTimer(void)
    {
	KillTimer(m_hwnd, IDT_SCOPECLOSECHECK);
    }


HRESULT CFolderBar::HrShowScopeFlyOut(void)
    {
    IAthenaBrowser *pBrowser = NULL;
    CFlyOutScope *pFlyOutScope;

    m_pSite->QueryInterface(IID_IAthenaBrowser, (LPVOID *) &pBrowser);
    Assert(pBrowser);

    pFlyOutScope = new CFlyOutScope;
    if (pFlyOutScope && pBrowser)
        {
        pFlyOutScope->HrDisplay(pBrowser, this, m_hwndParent, 
                                &m_hwndScopeDropDown);
        InvalidateFolderName();
        }
    SafeRelease(pBrowser);

    return (S_OK);
    }


void CFolderBar::Update(BOOL fDisplayNameChanged, BOOL fShowDropDownIndicator)
    {
    if (fDisplayNameChanged)
        {
        SetFolderName(NULL);
        }

    if (fShowDropDownIndicator)
        {
        BOOL fInfoColumn = FALSE;
        if (SUCCEEDED(m_pBrowser->GetViewLayout(DISPID_MSGVIEW_FOLDERLIST, 0, &fInfoColumn, 0, 0)))
            m_fDropDownIndicator = !fInfoColumn;        
        }

    if (fDisplayNameChanged || fShowDropDownIndicator)
        {
        m_fRecalc = TRUE;
        InvalidateRect(m_hwnd, NULL, TRUE);
        }
    }


HRESULT STDMETHODCALLTYPE CFolderBar::DragEnter(IDataObject* pDataObject, 
                                                DWORD grfKeyState, 
                                                POINTL pt, DWORD* pdwEffect)
    {    
    HRESULT hr = S_OK;
    DOUTL(32, _T("CFolderBar::DragEnter() - Starting"));

    // Release Current Data Object
    SafeRelease(m_pDataObject);

    // Initialize our state
    SafeRelease(m_pDTCur);

    // Let's get a drop target
    if (FOLDERID_INVALID == m_idFolder)
        return (E_FAIL);

    // Create the a Drop Target
    CDropTarget *pTarget = new CDropTarget();
    if (pTarget)
    {
        if (FAILED(hr = pTarget->Initialize(m_hwnd, m_idFolder)))
        {
            pTarget->Release();
            return (hr);
        }
    }
    m_pDTCur = pTarget;    

    // Save the Data Object
    m_pDataObject = pDataObject;
    m_pDataObject->AddRef();

    hr = m_pDTCur->DragEnter(m_pDataObject, grfKeyState, pt, &m_dwEffectCur);

    // Save Key State
    m_grfKeyState = grfKeyState;

    // Set the default return value to be failure
    *pdwEffect = m_dwEffectCur;

    return (S_OK);
    }


//
//  FUNCTION:   CFolderBar::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT STDMETHODCALLTYPE CFolderBar::DragOver(DWORD grfKeyState, POINTL pt, 
                                                DWORD* pdwEffect)
    {
    HRESULT         hr = E_FAIL;

    // If we don't have a stored data object from DragEnter()
    if (m_pDataObject && NULL != m_pDTCur)
        {
        // If the keys changed, we need to re-query the drop target
        if ((m_grfKeyState != grfKeyState) && m_pDTCur)
            {
            m_dwEffectCur = *pdwEffect;
            hr = m_pDTCur->DragOver(grfKeyState, pt, &m_dwEffectCur);
            }
        else
            {
            hr = S_OK;
            }

        *pdwEffect = m_dwEffectCur;
        m_grfKeyState = grfKeyState;
        }

    ScreenToClient(m_hwnd, (LPPOINT) &pt);
    DoMouseOver((LPPOINT) &pt, MO_DRAGOVER);

    return (hr);
    }
    

//
//  FUNCTION:   CFolderBar::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
HRESULT STDMETHODCALLTYPE CFolderBar::DragLeave(void)
    {
    POINT pt = {0, 0};
    DOUTL(32, _T("CFolderBarView::DragLeave()"));

    KillHoverTimer();
    DoMouseOver(&pt, MO_DRAGLEAVE);
    // SetScopeCloseTimer();

    SafeRelease(m_pDTCur);
    SafeRelease(m_pDataObject);

    return (S_OK);
    }
    

//
//  FUNCTION:   CFolderBar::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we 
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.  If this is a copy or move, then
//              we go ahead and update the store.  Otherwise, we bring up
//              a send note with the object attached.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
HRESULT STDMETHODCALLTYPE CFolderBar::Drop(IDataObject* pDataObject, 
                                          DWORD grfKeyState, POINTL pt, 
                                          DWORD* pdwEffect)
    {
    HRESULT         hr;

    Assert(m_pDataObject == pDataObject);

    if (m_pDTCur)
        {
        hr = m_pDTCur->Drop(pDataObject, grfKeyState, pt, pdwEffect);
        }
    else
        {
        *pdwEffect = 0;
        hr = S_OK;
        }

    KillHoverTimer();
    ScreenToClient(m_hwnd, (LPPOINT) &pt);
    DoMouseOver((LPPOINT) &pt, MO_DRAGDROP);
  
    SafeRelease(m_pDataObject);
    SafeRelease(m_pDTCur);

    return (hr);
    }



LRESULT CALLBACK CFolderBar::FrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam)
    {
    CFolderBar *pThis = (CFolderBar *) GetWndThisPtr(hwnd);

    switch (uMsg)
        {
        case WM_NCCREATE:
            {
            pThis = (CFolderBar *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
            SetWndThisPtr(hwnd, (LONG_PTR) pThis);
            pThis->m_hwnd = hwnd;
            return (TRUE);
            }

        case WM_SIZE:
            {
            SetWindowPos(pThis->m_hwnd, NULL, 0, 0, LOWORD(lParam) - CX_MARGIN_RIGHTEDGE, 
                         HIWORD(lParam) - CY_MARGIN, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            return (TRUE);
            }
        }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }


#define FLYOUTSCOPECLASS _T("FlyOutScope")
HRESULT CFlyOutScope::HrDisplay(IAthenaBrowser *pBrowser, CFolderBar *pFolderBar,
                                HWND hwndParent, HWND *phwndScope)
    {
    HRESULT hr = S_OK;
    RECT    rc,
            rcFrame,
            rcView;
    int     cx, 
            cy,
            cyMax,
            increments,
            dyOffset;
    const   cmsAvail = 250;
    DWORD   cmsUsed,
            cmsLeft,
            cmsThreshold,
            cmsStart,
            cmsNow;

    Assert(pBrowser);
    Assert(pFolderBar);

    m_pBrowser = pBrowser;
    m_pBrowser->AddRef();
    m_pFolderBar = pFolderBar;
    m_fResetParent = FALSE;
    m_hwndParent = hwndParent;

    m_pFolderBar->GetWindow(&m_hwndFolderBar);
    m_hwndFocus = GetFocus();

    // Create the control
    WNDCLASSEX wc = {0};

    // Check to see if we need to register the class first
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, FLYOUTSCOPECLASS, &wc))
        {
        wc.style         = 0;
        wc.lpfnWndProc   = FlyWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = g_hInst;
        wc.hCursor       = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
        wc.hbrBackground = NULL;
        wc.hIcon         = NULL;
        IF_WIN32( wc.hIconSm       = NULL; )
        wc.lpszClassName = FLYOUTSCOPECLASS;

        SideAssert(RegisterClassEx(&wc));
        }
    m_hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, FLYOUTSCOPECLASS, NULL, 
                            WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0, 0, 0, 0,
                            m_hwndParent, 0, g_hInst, (LPVOID) this);
    if (!m_hwnd)
        {
        GetLastError();
        return (E_OUTOFMEMORY);
        }

    // Get the scope pane from the browser
    m_pBrowser->GetTreeView(&m_pTreeView);
    m_pTreeView->GetWindow(&m_hwndTree);
    m_hwndTreeParent = GetParent(m_hwndTree);

    // Turn on the pin button
    SendMessage(m_hwndTree, WM_TOGGLE_CLOSE_PIN, 0, TRUE);

	// Set the focus before changing the parent. In some cases, setting the 
	// focus, causes a selection change notification to come through. This
	// makes the explorer split pane think the user has made their selection
	// and shuts down the drop down scope pane before it is even shown!

    HWND hwndT = GetWindow(m_hwndTree, GW_CHILD);
    SetFocus(m_hwndTree);
    SetParent(m_hwndTree, m_hwnd);
    m_fResetParent = TRUE;
    SetWindowPos(m_hwndTree, NULL, CXY_MARGIN_FLYOUT, CXY_MARGIN_FLYOUT, 0, 0,
                 SWP_NOSIZE | SWP_NOZORDER);
    ShowWindow(m_hwndTree, SW_SHOW);
    m_pTreeView->RegisterFlyOut(m_pFolderBar);

    // Clear the parent for better redraw
    SetParent(m_hwnd, NULL);

    // Set up for the slide, the final position for the flyout will match the
    // left/top/bottom edges of the view.  The width of the scope pane is either
    // 1/3 of the width of the view or CX_MINWIDTH_FLYOUT, whichever is larger.

    // Get the position & size of the view window
    m_pBrowser->GetViewRect(&rcView);
    MapWindowPoints(m_hwndParent, GetDesktopWindow(), (LPPOINT) &rcView, 2);

    // Determine the width of the fly-out
    cx = max(CX_MINWIDTH_FLYOUT, ((rcView.right - rcView.left) / 3) + 2 * CXY_MARGIN_FLYOUT);

    // Calculate the fly-out increments
    cyMax = cy = (rcView.bottom - rcView.top) + (CXY_MARGIN_FLYOUT * 2);
    increments = cy / FLYOUT_INCREMENT;
    cy -= increments * FLYOUT_INCREMENT;

    // Scope pane is positioned at it's final size so that it's size does not
    // change as we drop the flyout down.  This gives better redraw than resizing
    // as the window drops
    SetWindowPos(m_hwndTree, NULL, 0, 0, cx - CXY_MARGIN_FLYOUT * 2, cyMax - CXY_MARGIN_FLYOUT * 2,
                 SWP_NOMOVE | SWP_NOZORDER);

    // Move the window to its initial position
    GetWindowRect(m_hwndFolderBar, &rc);
    MoveWindow(m_hwnd, IS_WINDOW_RTL_MIRRORED(m_hwndParent) ? (rc.right + CXY_MARGIN_FLYOUT - cx) : (rc.left - CXY_MARGIN_FLYOUT), rcView.top - CXY_MARGIN_FLYOUT,
               cx, cy, FALSE);
    ShowWindow(m_hwnd, SW_SHOW);
    SetWindowPos(m_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

#ifndef WIN16
    if (GetSystemMetrics(SM_SLOWMACHINE))
        {
        // On a slow machine, just show the thing
        SetWindowPos(m_hwnd, NULL, 0, 0, cx, cyMax, SWP_NOMOVE | SWP_NOZORDER);
        }
    else
#endif // !WIN16
        {
        // Whoosh down to the bottom of the frame.  We want to do this in ~250ms on any
        // CPU.  In order to make this work on differing machine speeds, we double
        // the slide speed everytime the remaining time is halved.  If the remaining time
        // is negative, it will finish the slide in one step.

        dyOffset = FLYOUT_INCREMENT;
        cmsStart = ::GetTickCount();
        cmsThreshold = cmsAvail;

        while (cy <= cyMax)
            {
            // Slide the window down
            cy += dyOffset;
            SetWindowPos(m_hwnd, NULL, 0, 0, cx, min(cy, cyMax), SWP_NOMOVE | SWP_NOZORDER);
            UpdateWindow(m_hwnd);
            UpdateWindow(m_hwndTree);

            // Determine the next increment based on time remaining
            cmsNow = GetTickCount();
            cmsUsed = cmsNow - cmsStart;
            if (cmsUsed > cmsAvail && cy < cyMax)
                {
                // Finish it in one step
                cy = cyMax;
                }
            else
                {
                // Double scroll step if time remaining is halved since the 
                // last time we double the scroll step
                cmsLeft = cmsAvail - cmsUsed;
                if (cmsLeft < cmsThreshold)
                    {
                    dyOffset *= 2;
                    cmsThreshold /= 2;
                    }
                }
            }
        }

    *phwndScope = m_hwnd;
    return (hr);    
    }


LRESULT CALLBACK CFlyOutScope::FlyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    CFlyOutScope *pThis = (CFlyOutScope *) GetWndThisPtr(hwnd);

    switch (uMsg)
        {
        case WM_NCCREATE:
            {
            pThis = (CFlyOutScope *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
            SetWndThisPtr(hwnd, (LONG_PTR) pThis);
            pThis->m_hwnd = hwnd;
            return (TRUE);
            }
               
        HANDLE_MSG(hwnd, WM_PAINT,       pThis->OnPaint);
        HANDLE_MSG(hwnd, WM_NOTIFY,      pThis->OnNotify);
        HANDLE_MSG(hwnd, WM_DESTROY,     pThis->OnDestroy);
        HANDLE_MSG(hwnd, WM_SIZE,        pThis->OnSize);

        case WM_NCDESTROY:
            {
            pThis->Release();
            break;
            }
        }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

BOOL CFlyOutScope::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
    return (0);
    }


void CFlyOutScope::OnPaint(HWND hwnd)
    {
    HDC hdc;
    RECT rcClient;
    PAINTSTRUCT ps;

    GetClientRect(hwnd, &rcClient);

    // Paint the background
    hdc = BeginPaint(hwnd, &ps);
    SetBkColor(hdc, GetSysColor(COLOR_3DFACE));
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &ps.rcPaint, NULL, 0, NULL);

    // Draw the 3D edge
    DrawEdge(hdc, &rcClient, EDGE_RAISED, BF_RECT);
    EndPaint(hwnd, &ps);
    }


void CFlyOutScope::OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
    RECT rc;

    GetClientRect(hwnd, &rc);
    InvalidateRect(hwnd, &rc, FALSE);
    InflateRect(&rc, -CXY_MARGIN_FLYOUT, -CXY_MARGIN_FLYOUT);
    ValidateRect(hwnd, &rc);
    }


void CFlyOutScope::OnDestroy(HWND hwnd)
    {
    // Make sure to kill any bogus timers still lying around
    m_pFolderBar->KillScopeCloseTimer();
    m_pFolderBar->ScopePaneDied();

    // Reset the parent of the scope pane back to the browser
    if (m_fResetParent)
        {
        ShowWindow(m_hwndTree, SW_HIDE);
        SendMessage(m_hwndTree, WM_TOGGLE_CLOSE_PIN, 0, FALSE);
        SetParent(m_hwndTree, m_hwndTreeParent);
        m_pTreeView->RevokeFlyOut();
        }

    // Set the parent of the drop down pane itself back
    SetParent(m_hwnd, m_hwndFolderBar);

    // $TODO - Review where the focus is supposed to go
    HWND hwndBrowser;
    if (m_pBrowser)
        {
        m_pBrowser->GetWindow(&hwndBrowser);
        PostMessage(hwndBrowser, WM_OESETFOCUS, (WPARAM) m_hwndFocus, 0);
        }
    }


CFlyOutScope::CFlyOutScope()
    {
    m_cRef          = 1;
    m_pBrowser      = 0;
    m_pFolderBar    = 0;
    m_fResetParent  = 0;
    m_pTreeView     = NULL;
    m_hwnd          = NULL;
    m_hwndParent    = NULL;
    m_hwndTree      = NULL;
    m_hwndFolderBar = NULL;
    }

CFlyOutScope::~CFlyOutScope()
    {
    SafeRelease(m_pBrowser);
    SafeRelease(m_pTreeView);
    }

ULONG CFlyOutScope::AddRef(void)
    {
    return (++m_cRef);
    }

ULONG CFlyOutScope::Release(void)
    {
    ULONG cRefT = --m_cRef;

    if (m_cRef == 0)
        delete this;

    return (cRefT);
    }

HRESULT  CFolderBar::OnConnectionNotify(CONNNOTIFY  nCode, LPVOID pvData, CConnectionManager *pConMan)
{
    m_fRecalc = TRUE;
    InvalidateRect(m_hwnd, NULL, TRUE);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\fonts.h ===
// =================================================================================
// F O N T S . H
// =================================================================================
#ifndef __FONTS_H
#define __FONTS_H

// =================================================================================
// Depends On
// =================================================================================

#include "mimeole.h"

// from richedit.h
typedef struct _charformat CHARFORMAT;
struct BODYOPTINFO_tag;

// =================================================================================
// User defined charset map table
// =================================================================================
typedef struct  tagCHARSETMAPTBL
{
    TCHAR szOrginalCharsetStr[32];
    DWORD uiCodePage;
    BOOL  bEditDelete;
} CHARSETMAPTBL, *LPCHARSETMAPTBL ;

// =================================================================================
// Prototypes
// =================================================================================
HFONT HGetSystemFont(FNTSYSTYPE fnttype);
HFONT HGetCharSetFont(FNTSYSTYPE fnttype, HCHARSET hCharset);

VOID SetListViewFont (HWND hwndList, HCHARSET hCharset, BOOL fUpdate);
HCHARSET GetListViewCharset();

UINT GetICP(UINT acp);
HRESULT InitMultiLanguage(void);
void DeinitMultiLanguage(void);
HMENU CreateMimeLanguageMenu(BOOL bMailNote, BOOL bReadNote, UINT cp);
HCHARSET GetMimeCharsetFromMenuID(int nIdm);
HCHARSET GetMimeCharsetFromCodePage(UINT uiCodePage );
int SetMimeLanguageCheckMark(UINT uiCodePage, int index);
void GetRegistryFontInfo(LPCSTR lpszKeyPath);
INT  GetFontSize();
BOOL CheckIntlCharsetMap(HCHARSET hCharset, DWORD *pdwCodePage);
BOOL IntlCharsetMapLanguageCheck(HCHARSET hOldCharset, HCHARSET hNewCharset);
UINT CustomGetCPFromCharset(HCHARSET hCharset, BOOL bReadNote);
BOOL IntlCharsetMapDialogBox(HWND hwndDlg);
int IntlCharsetConflictDialogBox(void);
int GetIntlCharsetLanguageCount(void);
HRESULT HrGetComposeFontString(LPSTR rgchFont, DWORD cchFont, BOOL fMail);
HRESULT HrGetStringRBG(INT rgb, LPWSTR pwszColor);
HRESULT HrGetRBGFromString(INT* pRBG, LPWSTR pwszColor);
//UINT GetDefaultCodePageFromRegistry(void);
void ReadSendMailDefaultCharset(void);
void WriteSendMailDefaultCharset(void);
INT PointSizeToHTMLSize(INT iPointSize);
INT HTMLSizeToPointSize(INT iHTMLSize);
void _GetMimeCharsetLangString(BOOL bWebCharset, UINT uiCodePage, LPINT pnIdm, LPTSTR lpszString, int nSize );
BOOL SetSendCharSetDlg(HWND hwndDlg);
BOOL CheckAutoSelect(UINT * CodePage);

HRESULT FontToCharformat(HFONT hFont, CHARFORMAT *pcf);



#endif // __FONTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\fonts.cpp ===
// =================================================================================
// F O N T S . C P P
// =================================================================================
#include "pch.hxx"
#include "fonts.h"
#include "multlang.h"
#include "xpcomm.h"
#include "strconst.h"
#include "mimeole.h"
#include "goptions.h"
#include "error.h"
#include "thormsgs.h"
#include "richedit.h"
#include "ibodyopt.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "mimeutil.h"
#include "optres.h"
#include "demand.h"
#include "menures.h"
#include "multiusr.h"

// this part creates a MIME COM object from MLAMG.DLL which gives us a consistent 
// language menu to be the same as IE browser
// HMENU CreateMimeLanguageMenu(void)
#include <inetreg.h>
#include <mlang.h>
#include "resource.h"


#define IGNORE_HR(x)    (x)
#define MIMEINFO_NAME_MAX   72
#define DEFAULT_FONTSIZE 2

// MLANG language menu items table
static PMIMECPINFO g_pMimeCPInfo = NULL;
static ULONG g_cMimeCPInfoCount = 0;
static DWORD g_cRefMultiLanguage = 0;

TCHAR   g_szMore[32];
#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
#define BREAK_ITEM 20
#define CP_UNDEFINED            UINT(-1)
#define CP_AUTO                 50001 // cross language detection
#define CP_1252                 1252  // Ansi, Western Europe
#define CCPDEFAULT 2

void SendTridentOptionsChange();

typedef struct {
    UINT cp;
    ULONG  ulIdx;
    int  cUsed;
} CPCACHE;
    
class CCachedCPInfo 
{
public:
    CCachedCPInfo();
    static void InitCpCache (PMIMECPINFO pcp, ULONG ccp);
    static void SaveCodePage (UINT codepage, PMIMECPINFO pcp, ULONG ccp);
    BOOL fAutoSelectInstalled;
    BOOL fAutoSelectChecked;
    static UINT GetCodePage(int idx)
    {
        return idx < ARRAY_SIZE(_CpCache) ? _CpCache[idx].cp: 0;
    }
    static ULONG GetCcp()
    {
        return _ccpInfo;
    }

    static ULONG GetMenuIdx(int idx)
    {
        return idx < ARRAY_SIZE(_CpCache) ? _CpCache[idx].ulIdx: 0;
    }

 private:
    static ULONG _ccpInfo;
    static CPCACHE _CpCache[5];

};

CCachedCPInfo::CCachedCPInfo()
{
    fAutoSelectInstalled = FALSE;
    fAutoSelectChecked = FALSE;
}
// declaration for static members
ULONG CCachedCPInfo::_ccpInfo = CCPDEFAULT;
CPCACHE CCachedCPInfo::_CpCache[5] = 
{
 {CP_AUTO, 0, 0},  // cross-codepage autodetect
 {CP_1252,0,0},
};

CCachedCPInfo g_cpcache;

// useful macros...

inline BOOL IsPrimaryCodePage(MIMECPINFO *pcpinfo)
{
        return pcpinfo->uiCodePage == pcpinfo->uiFamilyCodePage;
}

//------------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::InitCpCache
//  
//              Initialize the cache with default codepages
//              which do not change through the session
//
//------------------------------------------------------------------------
void CCachedCPInfo::InitCpCache (PMIMECPINFO pcp, ULONG ccp)
{
    UINT iCache, iCpInfo;

    if  (pcp &&  ccp > 0)
    {
        for (iCache= 0; iCache < CCPDEFAULT; iCache++)
        {
            for (iCpInfo= 0; iCpInfo < ccp; iCpInfo++)
            {
                if ( pcp[iCpInfo].uiCodePage == _CpCache[iCache].cp )
                {
                    if(CP_AUTO == _CpCache[iCache].cp)
                    {
                       g_cpcache.fAutoSelectInstalled = TRUE;
                    }
                    _CpCache[iCache].ulIdx = iCpInfo;
                    _CpCache[iCache].cUsed = ARRAY_SIZE(_CpCache)-1;

                    break;
                }   
            }
        }
    }
}

//------------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::SaveCodePage
//  
//              Cache the given codepage along with the index to
//              the given array of MIMECPINFO
//
//------------------------------------------------------------------------
void CCachedCPInfo::SaveCodePage (UINT codepage, PMIMECPINFO pcp, ULONG ccp)
{
    int ccpSave = -1;
    BOOL bCached = FALSE;
    UINT i;

    // first check if we already have this cp
    for (i = 0; i < _ccpInfo; i++)
    {
        if (_CpCache[i].cp == codepage)
        {
            ccpSave = i;
            bCached = TRUE;
            break;
        }
    }
    
    // if cache is not full, use the current
    // index to an entry
    if (ccpSave < 0  && _ccpInfo < ARRAY_SIZE(_CpCache))
    {
        ccpSave =  _ccpInfo;
    }
    

    //  otherwise, popout the least used entry. 
    //  the default codepages always stay
    //  this also decriments the usage count
    int cMinUsed = ARRAY_SIZE(_CpCache);
    UINT iMinUsed = 0; 
    for ( i = CCPDEFAULT; i < _ccpInfo; i++)
    {
        if (_CpCache[i].cUsed > 0)
            _CpCache[i].cUsed--;
        
        if ( ccpSave < 0 && _CpCache[i].cUsed < cMinUsed)
        {
            cMinUsed =  _CpCache[i].cUsed;
            iMinUsed =  i;
        }
    }
    if (ccpSave < 0)
        ccpSave = iMinUsed; 
    
    // set initial usage count, which goes down to 0 if it doesn't get 
    // chosen twice in a row (with current array size)
    _CpCache[ccpSave].cUsed = ARRAY_SIZE(_CpCache)-1;
    
    // find a matching entry from given array of
    // mimecpinfo
    if (pcp &&  ccp > 0)
    {
        for (i= 0; i < ccp; i++)
        {
            if ( pcp[i].uiCodePage == codepage )
            {
                _CpCache[ccpSave].cp = codepage;
                _CpCache[ccpSave].ulIdx = i;

                if (!bCached && _ccpInfo < ARRAY_SIZE(_CpCache))
                    _ccpInfo++;

                break;
            }   
        }
    }
}

// Get UI language which can shown, using System fonts

LANGID OEGetUILang()
{
    LANGID lidUI = MLGetUILanguage();   

    if(fIsNT5())            // Nothing for NT5
        return(lidUI);
    
    if (0x0409 != lidUI) // US resource is always no need to munge
    {
        CHAR szUICP[8];
        CHAR szInstallCP[8];
        
        GetLocaleInfo(MAKELCID(lidUI, SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szUICP, ARRAYSIZE(szUICP));
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE, szInstallCP, ARRAYSIZE(szInstallCP));
        
        if (lstrcmpi(szUICP, szInstallCP))  // return default user language ID
            return(LANGIDFROMLCID(LOCALE_USER_DEFAULT));
    } 
    return (lidUI); // return lang ID from MLGetUILanguage()
    
}





BOOL CheckAutoSelect(UINT * CodePage)
{
    if(g_cpcache.fAutoSelectChecked)
    {
        *CodePage = CP_AUTO;
        return(TRUE);
    }
    return(FALSE);
}

HRESULT _InitMultiLanguage(void)
{
    HRESULT          hr;
    IMultiLanguage  *pMLang1=NULL;
    IMultiLanguage2 *pMLang2=NULL;

    // check if data has been initialized
    if (g_pMimeCPInfo)
        return S_OK ;

    Assert(g_cMimeCPInfoCount == NULL );

    // create MIME COM object
    hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void**)&pMLang2);
    if (FAILED(hr))
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage, (void**)&pMLang1);

    if (SUCCEEDED(hr))
    {
        UINT cNum;
        IEnumCodePage *pEnumCodePage;

        if (pMLang2)
        {
            hr = pMLang2->EnumCodePages(MIMECONTF_MAILNEWS | MIMECONTF_VALID, OEGetUILang(), &pEnumCodePage);
            if (SUCCEEDED(hr))
                pMLang2->GetNumberOfCodePageInfo(&cNum);
        }
        else
        {
            hr = pMLang1->EnumCodePages(MIMECONTF_MAILNEWS | MIMECONTF_VALID, &pEnumCodePage);
            if (SUCCEEDED(hr))
                pMLang1->GetNumberOfCodePageInfo(&cNum);
        }

        if (SUCCEEDED(hr))
        {
            MemAlloc((LPVOID *)&g_pMimeCPInfo, sizeof(MIMECPINFO) * cNum);
            if ( g_pMimeCPInfo )
            {
                ZeroMemory(g_pMimeCPInfo, sizeof(MIMECPINFO) * cNum);
                hr = pEnumCodePage->Next(cNum, g_pMimeCPInfo, &g_cMimeCPInfoCount);
                IGNORE_HR(MemRealloc((void **)&g_pMimeCPInfo, sizeof(MIMECPINFO) * g_cMimeCPInfoCount));
            }
            pEnumCodePage->Release();
        }

        // Release Objects
        SafeRelease(pMLang1);
        SafeRelease(pMLang2);
    }

    // get default charset, before user make any change to View/Language
    if (g_hDefaultCharsetForMail == NULL)
        ReadSendMailDefaultCharset();

    return hr;
}

HRESULT InitMultiLanguage(void)
{
    // we defer the call to _InitMultiLanguage until it is necessary

    // add reference count
    g_cRefMultiLanguage++ ;

    return S_OK ;
}

void DeinitMultiLanguage(void)
{
    // decrease reference count
    if ( g_cRefMultiLanguage )
       g_cRefMultiLanguage--;

    if ( g_cRefMultiLanguage <= 0 )
    {
        if ( g_pMimeCPInfo)
        {
            MemFree(g_pMimeCPInfo);
            g_pMimeCPInfo = NULL;
            g_cMimeCPInfoCount = 0;
        }

        WriteSendMailDefaultCharset();
    }
   return ;
}

HMENU CreateMimeLanguageMenu(BOOL bMailNote, BOOL bReadNote, UINT cp)
{
    ULONG i;
    HMENU hMenu = NULL;
    ULONG cchXlated ;
    UINT  uCodePage ;
    CHAR  szBuffer[MIMEINFO_NAME_MAX];
    BOOL  fUseSIO;
    BOOL  fBroken = FALSE;
    ULONG iMenuIdx;
    UINT  uNoteCP;
    

    if(fIsNT5())
    {
        if(GetLocaleInfoW(OEGetUILang(), 
                    LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER, 
                    (LPWSTR)(&uCodePage), 
                    sizeof(UINT)/sizeof(WCHAR) ) !=  sizeof(UINT)/sizeof(WCHAR))
        uCodePage = GetACP();
    }
    else
        uCodePage = GetACP();

    if(!cp)
        uNoteCP = uCodePage;
    else
        uNoteCP = GetMapCP(cp, bReadNote);

    bMailNote = FALSE;

    hMenu = CreatePopupMenu();

    if ( g_pMimeCPInfo == NULL)
    {
       _InitMultiLanguage();
       if ( g_pMimeCPInfo == NULL)
       {
            // create an empty menu  
            LoadString(g_hLocRes, idsEmptyStr, szBuffer, MIMEINFO_NAME_MAX);
            AppendMenu(hMenu, MF_DISABLED|MF_GRAYED , (UINT)-1, szBuffer);
            return hMenu ;
       }
    }

    g_cpcache.InitCpCache(g_pMimeCPInfo, g_cMimeCPInfoCount);
    g_cpcache.SaveCodePage(uNoteCP, g_pMimeCPInfo, g_cMimeCPInfoCount);

    for(i = 0; i < g_cpcache.GetCcp(); i++)
    {
        iMenuIdx = g_cpcache.GetMenuIdx(i);
//         cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[iMenuIdx].wszDescription, -1, szBuffer, MIMEINFO_NAME_MAX, NULL, NULL);

        if(!fCheckEncodeMenu(g_pMimeCPInfo[iMenuIdx].uiCodePage, bReadNote))
            continue ;
        
        if(i != 0)
            AppendMenuWrapW(hMenu, MF_ENABLED, iMenuIdx + ID_LANG_FIRST,g_pMimeCPInfo[iMenuIdx].wszDescription);

        // [SBAILEY]: Raid 69638: oe:ml: Autoselect doesnt work (we don't support global encoding auto-detect, therefore don't show it
#if 0
        else if(g_cpcache.fAutoSelectInstalled && bReadNote)
        {
            AppendMenuWrapW(hMenu, MF_ENABLED, iMenuIdx + ID_LANG_FIRST,g_pMimeCPInfo[iMenuIdx].wszDescription);
            AppendMenuWrapW(hMenu, MF_SEPARATOR, 0, 0);            
        }
#endif

        // mark the cp entry so we can skip it for submenu
        // this assumes we'd never use the MSB for MIMECONTF
        g_pMimeCPInfo[iMenuIdx].dwFlags |= 0x80000000;
    } 

    // Check Params
    Assert(g_pMimeCPInfo);
    Assert(g_cMimeCPInfoCount > 0 );

   // add the submenu for the rest of encodings
   HMENU hSubMenu = CreatePopupMenu();
   UINT  uiLastFamilyCp = 0;

    if ( g_cMimeCPInfoCount )
    {
	    // Get System CodePage
        if (hSubMenu)
        {
            for (i = 0; i < g_cMimeCPInfoCount ; i++)
            {
                if(!fCheckEncodeMenu(g_pMimeCPInfo[i].uiCodePage, bReadNote))
                    continue ;

                // skip codepages that are on teir1 menu
                if (!(g_pMimeCPInfo[i].dwFlags & 0x80000000))
                {
                    if ((g_pMimeCPInfo[i].dwFlags & MIMECONTF_VALID)
                      ||  IsPrimaryCodePage(g_pMimeCPInfo+i))
                    {
                        UINT uiFlags = MF_ENABLED;

                        if (uiLastFamilyCp > 0 
                        && uiLastFamilyCp != g_pMimeCPInfo[i].uiFamilyCodePage)
                        {
                            // add separater between different family unless
                            // we will be adding the menu bar break
                            if(i < BREAK_ITEM || fBroken)
                            {
                                AppendMenuWrapW(hSubMenu, MF_SEPARATOR, 0, 0);
                            }
                            else
                            {
                                uiFlags |= MF_MENUBARBREAK;
                                fBroken = TRUE;
                            }
                        }
                        // This menu gets really long. Let's break at a defined number so it all
                        // fits on the screen
                        /* cchXlated = WideCharToMultiByte(uCodePage,
                                                        0, 
                                                        g_pMimeCPInfo[i].wszDescription,
                                                        -1, 
                                                        szBuffer, 
                                                        MIMEINFO_NAME_MAX
                                                        , NULL
                                                        , NULL); */
                        AppendMenuWrapW(hSubMenu, 
                                   uiFlags, 
                                   i+ID_LANG_FIRST,
                                   g_pMimeCPInfo[i].wszDescription);

                        // save the family of added codepage
                        uiLastFamilyCp = g_pMimeCPInfo[i].uiFamilyCodePage;
                    }
                }
                else
                    g_pMimeCPInfo[i].dwFlags &= 0x7FFFFFFF;
            }
            // add this submenu to the last of tier1 menu
            if (!g_szMore[0])
            {
                LoadString(g_hLocRes, 
                                   idsEncodingMore,
                                   g_szMore,
                                   ARRAY_SIZE(g_szMore));
            }
            if (GetMenuItemCount(hSubMenu) > 0)
            {
                MENUITEMINFO mii;

                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU;
                mii.hSubMenu = hSubMenu;

                AppendMenu(hMenu, MF_DISABLED, ID_POPUP_LANGUAGE_MORE, g_szMore);
                SetMenuItemInfo(hMenu, ID_POPUP_LANGUAGE_MORE, FALSE, &mii);
            }
            else
            {
                DestroyMenu(hSubMenu);
            }
            
        }
        
    }
    else
    {
        // create an empty menu  
        LoadString(g_hLocRes, idsEmptyStr, szBuffer, MIMEINFO_NAME_MAX); 
        AppendMenu(hMenu, MF_DISABLED|MF_GRAYED , (UINT)-1, szBuffer);
    }
    
    return hMenu;
}

HCHARSET GetMimeCharsetFromMenuID(int nIdm)
{
    UINT idx;
	 HCHARSET hCharset = NULL ;
    ULONG cchXlated ;
    UINT  uCodePage ;
    CHAR  szBuffer[MIMEINFO_NAME_MAX];

    idx = nIdm - ID_LANG_FIRST;
    if((g_pMimeCPInfo[idx].uiCodePage == CP_AUTO) && g_cpcache.fAutoSelectInstalled)            // Auto Select selected
    {
        g_cpcache.fAutoSelectChecked = !g_cpcache.fAutoSelectChecked;
        return(NULL);
    }


    if ( g_pMimeCPInfo && idx < g_cMimeCPInfoCount )
    {
        uCodePage = GetACP();
        cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[idx].wszBodyCharset, -1, szBuffer, ARRAYSIZE(szBuffer), NULL, NULL);
        szBuffer[ARRAYSIZE(szBuffer) - 1] = '\0'; //better safe than not null-terminated 
        // check if BodyCharset starts with '_' like "_iso-2022-JP$ESC"
        // if it is, use BodyCharset
        // otherwise, use WebCharset
        // BUGBUG - special case for Korean 949 use BodyCharset, fix by RTM
        if ( szBuffer[0] != '_' &&  949 != g_pMimeCPInfo[idx].uiCodePage)
        {
            cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[idx].wszWebCharset, -1, szBuffer, ARRAYSIZE(szBuffer), NULL, NULL);
            szBuffer[ARRAYSIZE(szBuffer) - 1] = '\0'; //better safe than not null-terminated 
        }
        MimeOleFindCharset(szBuffer,&hCharset);
    }
    return hCharset ;
}

HCHARSET GetMimeCharsetFromCodePage(UINT uiCodePage )
{
	HCHARSET hCharset = NULL ;
    ULONG cchXlated, i ;
    UINT  uCodePage ;
    CHAR  szBuffer[MIMEINFO_NAME_MAX];

    if ( g_pMimeCPInfo == NULL)
       _InitMultiLanguage();

    if ( g_pMimeCPInfo )
    {
        uCodePage = GetACP();
        for (i = 0; i < g_cMimeCPInfoCount ; i++)
        {
            if (uiCodePage == g_pMimeCPInfo[i].uiCodePage)
            {
                cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[i].wszBodyCharset, -1, szBuffer, ARRAYSIZE(szBuffer), NULL, NULL);
                szBuffer[ARRAYSIZE(szBuffer) - 1] = '\0'; //better safe than not null-terminated 
                    
                // check if BodyCharset starts with '_' like "_iso-2022-JP$ESC"
                // if it is, use BodyCharset
                // otherwise, use WebCharset
                // BUGBUG - special case for Korean 949 use BodyCharset, fix by RTM
                if ( szBuffer[0] != '_' &&  949 != g_pMimeCPInfo[i].uiCodePage)
                {
                    cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[i].wszWebCharset, -1, szBuffer, ARRAYSIZE(szBuffer), NULL, NULL);
                    szBuffer[ARRAYSIZE(szBuffer) - 1] = '\0'; //better safe than not null-terminated 
                }
                MimeOleFindCharset(szBuffer,&hCharset);
                break ;
            }
        }
    }
    return hCharset ;
}

void _GetMimeCharsetLangString(BOOL bWebCharset, UINT uiCodePage, LPINT pnIdm, LPTSTR lpszString, int nSize )
{
    ULONG i, cchXlated ;
    UINT  uCodePage ;

    if ( g_pMimeCPInfo == NULL)
       _InitMultiLanguage();

    if ( g_cMimeCPInfoCount )
    {
        // Get System CodePage
        uCodePage = GetACP();
        for (i = 0; i < g_cMimeCPInfoCount ; i++)
        {
            if (uiCodePage == g_pMimeCPInfo[i].uiCodePage)
            {
        		// convert WideString to MultiByteString
                if (lpszString)
                {
                    if (bWebCharset)
                        cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[i].wszWebCharset, -1, lpszString, nSize, NULL, NULL);
                    else
                        cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[i].wszDescription, -1, lpszString, nSize, NULL, NULL);
                }
                if ( pnIdm )
                    *pnIdm = i+ID_LANG_FIRST;
                break ;
            }
        }
    }

    return ;
}

int SetMimeLanguageCheckMark(UINT uiCodePage, int index)
{
    ULONG i;
    if((g_pMimeCPInfo[index].uiCodePage == CP_AUTO) && g_cpcache.fAutoSelectInstalled && DwGetOption(OPT_INCOMDEFENCODE))
        return (0);    
    else if((g_pMimeCPInfo[index].uiCodePage == CP_AUTO) && g_cpcache.fAutoSelectChecked && g_cpcache.fAutoSelectInstalled)
        return (OLECMDF_LATCHED | OLECMDF_ENABLED);

    UINT iStart = g_cpcache.fAutoSelectInstalled ? 1 : 0;

    if (1 < g_cMimeCPInfoCount)
    {
        if(uiCodePage == g_pMimeCPInfo[index].uiCodePage)
            return (OLECMDF_NINCHED | OLECMDF_ENABLED);
        else 
            return OLECMDF_ENABLED;
    }
    return FALSE;
}

INT  GetFontSize(void)
{
    DWORD cb, iFontSize = 0;

    cb = sizeof(iFontSize);
    AthUserGetValue(NULL, c_szRegValIMNFontSize, NULL, (LPBYTE)&iFontSize, &cb);

    if(iFontSize < 1 || iFontSize > 7)
        iFontSize = 2;

    return((INT)iFontSize);
}

//
// GetICP() - Gets the system's *internet* codepage from the ANSI codepage
//
UINT GetICP(UINT acp)
{
    HCHARSET        hCharset = NULL;
    UINT            icp      = NULL;
    CODEPAGEINFO    rCodePage;
    INETCSETINFO    CsetInfo;
    HRESULT         hr;
    ULONG           i;

    if(!acp)
        acp = GetACP();

    icp = acp;

    // Get the codepage info for acp
    IF_FAILEXIT(hr = MimeOleGetCodePageInfo(acp, &rCodePage));

    // Use the body (internet) charset description to get the codepage id for 
    // the body charset
    IF_FAILEXIT(hr = MimeOleFindCharset(rCodePage.szBodyCset, &hCharset));
    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset,&CsetInfo));

    // Now, we need to know if MLANG understands this CP
    if ( g_pMimeCPInfo == NULL)
       _InitMultiLanguage();

    if ( g_cMimeCPInfoCount )
    {
        for (i = 0; i < g_cMimeCPInfoCount ; i++)
        {
            if (CsetInfo.cpiInternet == g_pMimeCPInfo[i].uiCodePage)
            {
                icp = CsetInfo.cpiInternet;
                break ;
            }
        }
    }   

exit:
    return icp;
}

void ReadSendMailDefaultCharset(void)
{
    // Locals
    HKEY            hTopkey;
    DWORD           cb;
    CODEPAGEID      cpiCodePage;

    // only read once, skip if it is defined
    if (g_hDefaultCharsetForMail == NULL)
    {
        cb = sizeof(cpiCodePage);
        if (ERROR_SUCCESS == AthUserGetValue(c_szRegPathMail, c_szDefaultCodePage, NULL, (LPBYTE)&cpiCodePage, &cb))
        {
            if (cpiCodePage == 50222 || cpiCodePage == 50221)
                g_hDefaultCharsetForMail = GetJP_ISOControlCharset();
            else
                g_hDefaultCharsetForMail = GetMimeCharsetFromCodePage(cpiCodePage);
        }
    }

    if (g_hDefaultCharsetForMail == NULL)
    {
        if(FAILED(HGetDefaultCharset(&g_hDefaultCharsetForMail)))
            g_hDefaultCharsetForMail = GetMimeCharsetFromCodePage(GetICP(NULL));
    }

    return;
}

void WriteSendMailDefaultCharset(void)
{
    // Locals
    CODEPAGEID      uiCodePage;
    INETCSETINFO    CsetInfo ;

    // get CodePage from HCHARSET 
    if (g_hDefaultCharsetForMail)
    {
        MimeOleGetCharsetInfo(g_hDefaultCharsetForMail,&CsetInfo);
        uiCodePage = CsetInfo.cpiInternet ;

        AthUserSetValue(c_szRegPathMail, c_szDefaultCodePage, REG_DWORD, (LPBYTE)&uiCodePage, sizeof(uiCodePage));
    }

    return;
}

INT_PTR CALLBACK CharsetChgDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg == WM_COMMAND)
    {
        int id = GET_WM_COMMAND_ID(wParam, lParam);

        if (id == IDOK || id  == IDCANCEL ||
                id == idcSendAsUnicode )
        {
            EndDialog(hwndDlg, id);
            return TRUE;
        }
    }
    else if (msg == WM_INITDIALOG )
    {
        CenterDialog(hwndDlg);
    }

    return FALSE;
}

static const HELPMAP g_rgCtxMapCharSetMap[] = 
{
    {idcStatic1,                35545},
    {idcLangCheck,              35540},
    {0,                         0}
};
        
INT_PTR CALLBACK ReadCharsetDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CODEPAGEID cpiWindows;
    CODEPAGEID cpiInternet;
    TCHAR      szCodePage[MAX_PATH];
    TCHAR      szBuffer[MIMEINFO_NAME_MAX] = "";
    int        Idm;

    switch (msg)
    {
        case WM_INITDIALOG:
        {

            // Open Trident\International
            DWORD cb = sizeof(cpiWindows);
            if (ERROR_SUCCESS != SHGetValue(MU_GetCurrentUserHKey(), c_szRegInternational, c_szDefaultCodePage, NULL, (LPBYTE)&cpiWindows, &cb))
                cpiWindows = GetACP();

            // Open the CodePage Key
            wnsprintf(szCodePage, ARRAYSIZE(szCodePage), TEXT("%s\\%d"), c_szRegInternational, cpiWindows);
            cb = sizeof(cpiInternet);
            if (ERROR_SUCCESS != SHGetValue(MU_GetCurrentUserHKey(), szCodePage, c_szDefaultEncoding, NULL, (LPBYTE)&cpiInternet, &cb))
                cpiInternet = GetICP(cpiWindows);

            // Get information about current default charset
            _GetMimeCharsetLangString(FALSE, GetMapCP(cpiInternet, TRUE), &Idm, szBuffer, MIMEINFO_NAME_MAX - 1);

            // Set the String
            SetWindowText(GetDlgItem(hwndDlg, idcStatic1), szBuffer);

            // Set the Default
            CheckDlgButton(hwndDlg, idcLangCheck, DwGetOption(OPT_INCOMDEFENCODE) ? BST_CHECKED:BST_UNCHECKED);
            break ;
        }
        case WM_COMMAND:
        {
            int id = GET_WM_COMMAND_ID(wParam, lParam);

            if (id == IDCANCEL || id == IDOK )
            {
                if(id == IDOK)
                {
                    SetDwOption(OPT_INCOMDEFENCODE, IsDlgButtonChecked(hwndDlg, idcLangCheck), NULL, 0);
#if 0
                    // hack: we should call these only if OpenFontsDialog tells us user has changed the font.
                    g_lpIFontCache->OnOptionChange();
    
                    SendTridentOptionsChange();

                    // Re-Read Default Character Set
                    SetDefaultCharset(NULL);

                    // Reset g_uiCodePage
                    DWORD dwVal = 0;
                    DWORD dwType = 0;
                    DWORD cb = sizeof(dwVal);
                    if (ERROR_SUCCESS == SHGetValue(MU_GetCurrentUserHKey(), c_szRegInternational, REGSTR_VAL_DEFAULT_CODEPAGE, &dwType, &dwVal, &cb))
                        g_uiCodePage = (UINT)dwVal;
#endif // 0
                }
                EndDialog(hwndDlg, id);
                return TRUE;
            }
            break ;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwndDlg, msg, wParam, lParam, g_rgCtxMapCharSetMap);

        default:
            break ;
    }

    return FALSE;
}

BOOL CheckIntlCharsetMap(HCHARSET hCharset, DWORD *pdwCodePage)
{
    INETCSETINFO CsetInfo ;
    LPSTR lpCharsetName, lpStr;
    ULONG i;
    UINT uiCodePage ;

    if ( hCharset == NULL )
        return FALSE ;

    if (!pdwCodePage)
        return FALSE ;
    else
        *pdwCodePage = 0 ;

    // get Code page from HCHARSET
    MimeOleGetCharsetInfo(hCharset,&CsetInfo);
    *pdwCodePage = GetMapCP(CsetInfo.cpiInternet, TRUE); // This func always called for Read note (?!)
    return(*pdwCodePage != CsetInfo.cpiInternet);
}

UINT CustomGetCPFromCharset(HCHARSET hCharset, BOOL bReadNote)
{
    INETCSETINFO CsetInfo = {0};
    UINT uiCodePage = 0 ;

    // get CodePage from HCHARSET 
    MimeOleGetCharsetInfo(hCharset,&CsetInfo);
    uiCodePage = GetMapCP(CsetInfo.cpiInternet, bReadNote);

    // Bug #51636
    // Check that code page supported by OE

    if(GetMimeCharsetFromCodePage(uiCodePage) == NULL)
    {
        HCHARSET hChar = NULL;

        if(bReadNote)
        {
            if(SUCCEEDED(HGetDefaultCharset(&hChar)))
            {
                if(FAILED(MimeOleGetCharsetInfo(hChar, &CsetInfo)))
                    return(0);
            }
            else
                return(0);
        }
        else
        {
            if(FAILED(MimeOleGetCharsetInfo(g_hDefaultCharsetForMail, &CsetInfo)))
                return(0);
        }

        return(GetMapCP(CsetInfo.cpiInternet, bReadNote));
    }

    return(uiCodePage);
}

BOOL IntlCharsetMapDialogBox(HWND hwndDlg)
{
    DialogBox(g_hLocRes, MAKEINTRESOURCE(iddIntlSetting), hwndDlg, ReadCharsetDlgProc) ;

    return TRUE ;
}

int IntlCharsetConflictDialogBox(void)
{
    return (int) DialogBox(g_hLocRes, MAKEINTRESOURCE(iddCharsetConflict), g_hwndInit, CharsetChgDlgProc);
}

int GetIntlCharsetLanguageCount(void)
{
    if ( g_pMimeCPInfo == NULL)
       _InitMultiLanguage();

    return g_cMimeCPInfoCount ;
}


HCHARSET GetListViewCharset()
{
    HCHARSET hCharset;

    if(g_uiCodePage == GetACP() || 0 == g_uiCodePage)
        hCharset = NULL;
    else
        hCharset = GetMimeCharsetFromCodePage(g_uiCodePage);

    return hCharset;
}

// =================================================================================
// SetListViewFont
// =================================================================================
VOID SetListViewFont (HWND hwndList, HCHARSET hCharset, BOOL fUpdate)
{
    // Locals
    HFONT           hFont;

    // Check Params
    Assert (IsWindow (hwndList));

    hFont = HGetCharSetFont(FNT_SYS_ICON,hCharset);

    // If we got a font, set the list view
    if (hFont)
    {
        // Set the list view font - Dont redraw quite yet
        SendMessage (hwndList, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(fUpdate, 0));

        // Try to reset header back to system icon font... 
        // Get header
        HWND hwndHeader = GetWindow (hwndList, GW_CHILD);
        // Update Header
        hFont = HGetSystemFont(FNT_SYS_ICON);
        // If font
        if (hFont && hwndHeader)                                            
            SendMessage (hwndHeader, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(fUpdate, 0));

        // Refresh
        if (fUpdate)
        {
            InvalidateRect (hwndList, NULL, TRUE);
            InvalidateRect (GetWindow(hwndList, GW_CHILD), NULL, TRUE);
        }
    }
}

// =================================================================================
// HGetSystemFont
// =================================================================================
HFONT HGetSystemFont(FNTSYSTYPE fnttype)
{
    HFONT hFont;
    Assert (g_lpIFontCache);
    if (g_lpIFontCache)
        g_lpIFontCache->GetFont(fnttype, 0, &hFont);
    else
        hFont = NULL;
    return hFont;
}

// =================================================================================
// HGetCharSetFont
// =================================================================================
HFONT HGetCharSetFont(FNTSYSTYPE fnttype, HCHARSET hCharset)
{
    HFONT hFont;
    Assert (g_lpIFontCache);
    if (g_lpIFontCache)
        g_lpIFontCache->GetFont(fnttype, hCharset, &hFont);
    else
        hFont = NULL;
    return hFont;
}


// ******************************************************
// HrGetComposeFontString
//
// Purpose: builds the compose font string based on user settings ready for execing to Trident
//
// the format of the string is:
//
//      "[Bold],[Italic],[Underline],[size],[FGRed.FGGreen.FGBlue],[BGRed.BGGreen.BGBlue],[FontFace]"
//
// Bold, Italic, Underline are either 0/1, indicating on or off. If none specified, 0 assumed.
// Size is a number between 1 and 7. If none specified, 3 assumed
// [FG|BG][Red|Green|Blue] are numbers between 0 and 255. For FG, if none specified black assumed, 
// for BG if none specified then undefined assumed.
// Font Face is a valid font name string
// For example an underline, blue text color, arial setting would be:
// 
//      ,,1,,0.0.255,,Arial
// 
// and a bold, 5 size, black, comic sans MS would be
// 
//      1,0,0,5,,,Comic Sans MS
// ******************************************************

static const TCHAR  c_szOn[]  = "1,",
                    c_szOff[] = "0,";

HRESULT HrGetComposeFontString(LPSTR rgchFont, DWORD cchFont, BOOL fMail)
{
    DWORD               dw = 0, 
                        dwSize = 2;
    TCHAR               szFontFace[LF_FACESIZE+1];
    TCHAR               szTmp[50];

    if (rgchFont==NULL)
        return E_INVALIDARG;

    // "[Bold],[Italic],[Underline],[size],[FGRed.FGGreen.FGBlue],[BGRed.BGGreen.BGBlue],[FontFace]"
    *szFontFace = 0;
    *rgchFont=0;

    // bold
    StrCatBuff(rgchFont, DwGetOption(fMail ? OPT_MAIL_FONTBOLD : OPT_NEWS_FONTBOLD) ? c_szOn :  c_szOff, cchFont);

    // italic
    StrCatBuff(rgchFont, DwGetOption(fMail ? OPT_MAIL_FONTITALIC : OPT_NEWS_FONTITALIC) ? c_szOn :  c_szOff, cchFont);

    // underline
    StrCatBuff(rgchFont, DwGetOption(fMail ? OPT_MAIL_FONTUNDERLINE : OPT_NEWS_FONTUNDERLINE) ? c_szOn :  c_szOff, cchFont);

    dw = DwGetOption(fMail ? OPT_MAIL_FONTSIZE : OPT_NEWS_FONTSIZE);
    
    // map points to HTML size
    dwSize = PointSizeToHTMLSize(dw);

    // font size
    wnsprintf(szTmp, ARRAYSIZE(szTmp), "%d,", dwSize);
    StrCatBuff(rgchFont, szTmp, cchFont);

    // font foregroundcolor
    if(fMail)
        dw = DwGetOption(OPT_MAIL_FONTCOLOR);
    else
        dw = DwGetOption(OPT_NEWS_FONTCOLOR);

    // write out RGB string
    wnsprintf(szTmp, ARRAYSIZE(szTmp), "%d.%d.%d,", GetRValue(dw), GetGValue(dw), GetBValue(dw));
    StrCatBuff(rgchFont, szTmp, cchFont);

    // default background color
    StrCatBuff(rgchFont, ",", cchFont);
    
    GetOption(fMail ? OPT_MAIL_FONTFACE : OPT_NEWS_FONTFACE, szFontFace, LF_FACESIZE);

    if(*szFontFace == 0)
        LoadString(g_hLocRes, idsComposeFontFace, szFontFace, LF_FACESIZE);

    StrCatBuff(rgchFont, szFontFace, cchFont);

    return S_OK;
}


INT PointSizeToHTMLSize(INT iPointSize)
{
    INT     iHTMLSize;
    // 1 ----- 8
    // 2 ----- 10
    // 3 ----- 12
    // 4 ----- 14
    // 5 ----- 18
    // 6 ----- 24
    // 7 ----- 36

    if(iPointSize>=8 && iPointSize<9)
        iHTMLSize = 1;
    else if(iPointSize>=9 && iPointSize<12)
        iHTMLSize = 2;
    else if(iPointSize>=12 && iPointSize<14)
        iHTMLSize = 3;
    else if(iPointSize>=14 && iPointSize<18)
        iHTMLSize = 4;
    else if(iPointSize>=18 && iPointSize<24)
        iHTMLSize = 5;
    else if(iPointSize>=24 && iPointSize<36)
        iHTMLSize = 6;
    else if(iPointSize>=36)
        iHTMLSize = 7;
    else
        iHTMLSize = DEFAULT_FONTSIZE;

    return iHTMLSize;
}


INT HTMLSizeToPointSize(INT iHTMLSize)
{
    INT     iPointSize;
    // 1 ----- 8
    // 2 ----- 10
    // 3 ----- 12
    // 4 ----- 14
    // 5 ----- 18
    // 6 ----- 24
    // 7 ----- 36

    switch (iHTMLSize)
        {
        case 1:
            iPointSize = 8;
            break;
        case 2:
            iPointSize = 10;
            break;
        case 3:
            iPointSize = 12;
            break;
        case 4:
            iPointSize = 14;
            break;
        case 5:
            iPointSize = 18;
            break;
        case 6:
            iPointSize = 24;
            break;
        case 7:
            iPointSize = 36;
            break;
        default:
            iPointSize = 10;
        }

    return iPointSize;
}

HRESULT HrGetStringRBG(INT rgb, LPWSTR pwszColor)
{
    HRESULT       hr = S_OK;
    INT           i;
    DWORD         crTemp;

    if(NULL == pwszColor)
        return E_INVALIDARG;

    rgb = ((rgb & 0x00ff0000) >> 16 ) | (rgb & 0x0000ff00) | ((rgb & 0x000000ff) << 16);
    for(i = 0; i < 6; i++)
    {
        crTemp = (rgb & (0x00f00000 >> (4*i))) >> (4*(5-i));
        pwszColor[i] = (WCHAR)((crTemp < 10)? (crTemp+L'0') : (crTemp+ L'a' - 10));
    }
    pwszColor[6] = L'\0';

    return hr;
}


HRESULT HrGetRBGFromString(INT* pRBG, LPWSTR pwszColor)
{
    HRESULT       hr = S_OK;
    INT           i, rbg = 0, len, n;
    WCHAR          ch;

    if(NULL == pRBG)
        return E_INVALIDARG;

    *pRBG = 0;
    len = lstrlenW(pwszColor);

    for(i=0; i<len; i++)
    {
        n = -1;
        ch = pwszColor[i];
        if(ch >= L'0' && ch <= L'9')
            n = ch - L'0';
        else if(ch >= L'a' && ch <= L'f')
            n = ch - L'a' + 10;
        else if(ch >= L'A' && ch <= L'F')
            n = ch - L'A' + 10;

        if(n < 0)
            continue;

        rbg = rbg*16 + n;
    }

    *pRBG = rbg;

    return hr;
}

// ***************************************************
HRESULT FontToCharformat(HFONT hFont, CHARFORMAT *pcf)
{
    DWORD   dwOldEffects;
    HDC     hdc;
    LOGFONT lf;
    INT     yPerInch;

    if (FAILED(GetObject(hFont, sizeof(lf), &lf)))
        return E_FAIL;

    hdc=GetDC(NULL);
    yPerInch=GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(NULL, hdc);

    // Set Struct Size
    ZeroMemory(pcf, sizeof (CHARFORMAT));
    pcf->cbSize = sizeof (CHARFORMAT);
     
    // Set mask
    pcf->dwMask = CFM_CHARSET | CFM_BOLD      | CFM_FACE      | CFM_ITALIC |
                  CFM_SIZE    | CFM_STRIKEOUT | CFM_UNDERLINE | CFM_COLOR;

    // Clear all the bits we are about to set.  We restore any bits we can not get from the LOGFONT using dwOldEffects.
    pcf->dwEffects = CFE_AUTOCOLOR;
    pcf->dwEffects |= (lf.lfWeight >= 700) ? CFE_BOLD : 0;
    pcf->dwEffects |= (lf.lfItalic)        ? CFE_ITALIC : 0;
    pcf->dwEffects |= (lf.lfStrikeOut)     ? CFE_STRIKEOUT : 0;
    pcf->dwEffects |= (lf.lfUnderline)     ? CFE_UNDERLINE : 0;
    pcf->yHeight = -(int)((1440*lf.lfHeight)/yPerInch);  // I think this is he conversion?
    pcf->crTextColor = 0;   // use autocolor
    pcf->bCharSet = lf.lfCharSet;
    pcf->bPitchAndFamily = lf.lfPitchAndFamily;
    StrCpyN(pcf->szFaceName, lf.lfFaceName, LF_FACESIZE - 1);

    return S_OK;
}

static const HELPMAP g_rgCtxMapSendCharSetMap[] = 
{
    {idcLangCombo,              50910},
    {IDC_RTL_MSG_DIR_CHECK,     50912},
    {IDC_ENGLISH_HDR_CHECK,     50915},
    {0,                         0}
};

INT_PTR CALLBACK SetSendCharsetDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND    hWndCombo;
    ULONG   i ;
    ULONG   cchXlated ;
    UINT    uiCodePage;
    CHAR    szBuffer[MIMEINFO_NAME_MAX];
    UINT    uiACP = GetACP();
    INETCSETINFO    CsetInfo ;
    int index = 0;
    int SelIndex = 0;

    hWndCombo = GetDlgItem(hwndDlg, idcLangCombo);

    switch (msg)
    {
        case WM_INITDIALOG:
        {
            CenterDialog(hwndDlg);

            // Init global CPs structire, if it was not inited yet
            if ( g_pMimeCPInfo == NULL)
                _InitMultiLanguage();
    
            // Get information about current default charset
            MimeOleGetCharsetInfo(g_hDefaultCharsetForMail,&CsetInfo);
            uiCodePage = CsetInfo.cpiInternet ;

            // Fill combo box with available charsets for Send
            for (i = 0; i < g_cMimeCPInfoCount ; i++)
            {
                if(!fCheckEncodeMenu(g_pMimeCPInfo[i].uiCodePage, FALSE))
                    continue ;

                cchXlated = WideCharToMultiByte(uiACP,
                                                        0, 
                                                        g_pMimeCPInfo[i].wszDescription,
                                                        -1, 
                                                        szBuffer, 
                                                        ARRAYSIZE(szBuffer),
                                                        NULL,
                                                        NULL);

                szBuffer[ARRAYSIZE(szBuffer) - 1] = '\0'; //better safe than not null-terminated 

                index = (int) SendMessage(hWndCombo, CB_ADDSTRING, 0, ((LPARAM) szBuffer));
                if(index != CB_ERR)
                    SendMessage(hWndCombo, CB_SETITEMDATA, index, ((LPARAM) (g_pMimeCPInfo[i].uiCodePage)));

                if(g_pMimeCPInfo[i].uiCodePage == uiCodePage)
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_RTL_MSG_DIR_CHECK),
                        ((g_pMimeCPInfo[i].uiFamilyCodePage == 1255) ||
                         (g_pMimeCPInfo[i].uiFamilyCodePage == 1256) ||
                         (g_pMimeCPInfo[i].uiFamilyCodePage == 1200)));
                }

            }

            //Set current selection to default charset, we can't detect this in the above
            //loop because the combobox sorting may change the index
            for (i = 0; i < g_cMimeCPInfoCount ; i++)
            {
                if(uiCodePage == (UINT)SendMessage(hWndCombo, CB_GETITEMDATA, i, NULL))
                {
                    SelIndex = i;
                    break;
                }
            }

            SendMessage(hWndCombo, CB_SETCURSEL, SelIndex, 0L);

            CheckDlgButton(hwndDlg, IDC_ENGLISH_HDR_CHECK, DwGetOption(OPT_HARDCODEDHDRS) ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwndDlg, IDC_RTL_MSG_DIR_CHECK, DwGetOption(OPT_RTL_MSG_DIR) ? BST_CHECKED:BST_UNCHECKED);
            break ;
        }
        case WM_COMMAND:
        {
            int id = GET_WM_COMMAND_ID(wParam, lParam);
            HCHARSET hCharset = NULL ;

            if ((id == idcLangCombo) && (GET_WM_COMMAND_CMD(wParam,lParam) == CBN_SELCHANGE))
            {
                index = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0L);
                if(index != CB_ERR)
                {
                    uiCodePage = (UINT) SendMessage(hWndCombo, CB_GETITEMDATA, index, 0);
                    if(((int) uiCodePage) != CB_ERR)
                    {
                        for (i = 0; i < g_cMimeCPInfoCount ; i++)
                        {
                            if(g_pMimeCPInfo[i].uiCodePage == uiCodePage)
                            {
                                EnableWindow(GetDlgItem(hwndDlg, IDC_RTL_MSG_DIR_CHECK),
                                    ((g_pMimeCPInfo[i].uiFamilyCodePage == 1255) ||
                                     (g_pMimeCPInfo[i].uiFamilyCodePage == 1256) ||
                                     (g_pMimeCPInfo[i].uiFamilyCodePage == 1200)));
                            }
                        }
                    }
                }
            }
            else if (id == IDCANCEL || id == IDOK )
            {
                if (id == IDOK )
                {
                    index = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0L);
                    if(index != CB_ERR)
                    {
                        uiCodePage = (UINT) SendMessage(hWndCombo, CB_GETITEMDATA, index, 0);
                        if(((int) uiCodePage) != CB_ERR)
                        {
                            AthUserSetValue(c_szRegPathMail, c_szDefaultCodePage, 
                                    REG_DWORD, (LPBYTE)&uiCodePage, sizeof(uiCodePage));
                            g_hDefaultCharsetForMail = GetMimeCharsetFromCodePage(uiCodePage );
                            WriteSendMailDefaultCharset();
                        }
                    }
                    SetDwOption(OPT_HARDCODEDHDRS, IsDlgButtonChecked(hwndDlg, IDC_ENGLISH_HDR_CHECK), NULL, 0);
                    SetDwOption(OPT_RTL_MSG_DIR, (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_RTL_MSG_DIR_CHECK)) && IsDlgButtonChecked(hwndDlg, IDC_RTL_MSG_DIR_CHECK)), NULL, 0);
                }

                EndDialog(hwndDlg, id);
                return TRUE;
            }

            break ;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwndDlg, msg, wParam, lParam, g_rgCtxMapSendCharSetMap);

        default:
            break ;
    }

    return FALSE;
}



BOOL SetSendCharSetDlg(HWND hwndDlg)
{
    DialogBox(g_hLocRes, MAKEINTRESOURCE(iddSendIntlSetting), hwndDlg, SetSendCharsetDlgProc) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\fldrprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     fldrprop.cpp
//
//  PURPOSE:    Implements the property sheets for news groups and mail 
//              folders.
//

#include "pch.hxx"
#include "resource.h"
#include "fldrprop.h"
#include <optres.h>
#include <shlwapi.h>
#include "storutil.h"
#include "storecb.h"
#include "newsdlgs.h"
#include "shared.h"
#include "demand.h"

/////////////////////////////////////////////////////////////////////////////
// Private types
//

   
// FOLDERPROP_INFO
//
// This struct contains the information needed to invoke and display the info
// on a property sheet for a mail folder.
typedef struct
    {
    //LPTSTR          pszFolder;
    //CIMAPFolderMgr *pFM;
    //LPCFOLDERIDLIST pfidl;
    FOLDERID        idFolder;
    HICON           hIcon;
    BOOL            fDirty;
    } FOLDERPROP_INFO, *PFOLDERPROP_INFO;
  
    
// GROUPPROP_INFO
// 
// This struct contains the information needed to invoke and display the info
// on a property sheet for a news group.
typedef struct 
    {
    LPTSTR          pszServer;
    LPTSTR          pszGroup;
    FOLDERID        idFolder;
    //LPCFOLDERIDLIST pfidl;
    //CSubList       *pSubList;
    HICON           hIcon;
    } GROUPPROP_INFO, *PGROUPPROP_INFO;

/////////////////////////////////////////////////////////////////////////////
// Private function prototypes
//    
INT_PTR CALLBACK GroupProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                       LPARAM lParam);
INT_PTR CALLBACK GroupProp_UpdateDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                       LPARAM lParam);
INT_PTR CALLBACK FolderProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                        LPARAM lParam);
INT_PTR CALLBACK NewsProp_CacheDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                    LPARAM lParam);
BOOL FolderProp_GetFolder(HWND hwnd, PFOLDERPROP_INFO pfpi, FOLDERID idFolder);
                                    
/////////////////////////////////////////////////////////////////////////////

//
//  FUNCTION:   GroupProp_Create()
//
//  PURPOSE:    Invokes a property sheet which displays properties for the
//              specified group.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that should be the dialog's 
//                        parent.
//      <in> pfidl      - fully qualified pidl to the newsgroup
//
//  RETURN VALUE:
//      TRUE  - The dialog was successfully displayed
//      FALSE - The dialog failed.
//
BOOL GroupProp_Create(HWND hwndParent, FOLDERID idFolder, BOOL fUpdatePage)
    {
    GROUPPROP_INFO gpi;
    BOOL fReturn;
    HIMAGELIST himl, himlSmall;
    HICON hIcon, hIconSmall;
    FOLDERINFO Folder;
    FOLDERINFO Store;
    LONG iIcon;
    PROPSHEETPAGE psp[3], *ppsp;
    PROPSHEETHEADER psh;
    
    Assert(IsWindow(hwndParent));
    
    fReturn = FALSE;

    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        return FALSE;

    if (FAILED(GetFolderStoreInfo(Folder.idFolder, &Store)))
        {
        g_pStore->FreeRecord(&Folder);
        return FALSE;
        }

    iIcon = GetFolderIcon(&Folder);

    // TODO: we should probably just have a global image list for this...
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFoldersLarge), 32, 0, RGB(255, 0, 255));
    if (himl != NULL)
        {
        hIcon = ImageList_GetIcon(himl, GetFolderIcon(&Folder), ILD_NORMAL);
        if (hIcon != NULL)
            {
            himlSmall = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
            if (himlSmall != NULL)
                {
                hIconSmall = ImageList_GetIcon(himlSmall, iIcon, ILD_NORMAL);
                if (hIconSmall != NULL)
                    {
                    gpi.pszServer = Store.pszName;
                    gpi.pszGroup = Folder.pszName;
                    gpi.idFolder = idFolder;
                    gpi.hIcon = hIcon;
    
                    ppsp = psp;

                    ZeroMemory(psp, sizeof(psp));
                    ppsp->dwSize = sizeof(PROPSHEETPAGE);
                    ppsp->dwFlags = PSP_DEFAULT;
                    ppsp->hInstance = g_hLocRes;
                    ppsp->pszTemplate = MAKEINTRESOURCE(iddGroupProp_General);
                    ppsp->pfnDlgProc = GroupProp_GeneralDlgProc;
                    ppsp->lParam = (LPARAM) &gpi;
                    ppsp++;

                    if (!!(Folder.dwFlags & FOLDER_SUBSCRIBED))
                    {
                        ppsp->dwSize = sizeof(PROPSHEETPAGE);
                        ppsp->dwFlags = PSP_DEFAULT;
                        ppsp->hInstance = g_hLocRes;
                        ppsp->pszTemplate = MAKEINTRESOURCE(iddGroupProp_Update);
                        ppsp->pfnDlgProc = GroupProp_UpdateDlgProc;
                        ppsp->lParam = (LPARAM) &gpi;
                        ppsp++;
                    }
                    else
                    {
                        fUpdatePage = FALSE;
                    }

                    ppsp->dwSize = sizeof(PROPSHEETPAGE);
                    ppsp->dwFlags = PSP_DEFAULT;
                    ppsp->hInstance = g_hLocRes;
                    ppsp->pszTemplate = MAKEINTRESOURCE(iddNewsProp_Cache);
                    ppsp->pfnDlgProc = NewsProp_CacheDlgProc;
                    ppsp->lParam = (LPARAM) &gpi;
                    ppsp++;

                    psh.dwSize = sizeof(PROPSHEETHEADER);
                    psh.dwFlags = PSH_USEHICON | PSH_PROPSHEETPAGE | PSH_PROPTITLE | PSH_USEPAGELANG;
                    psh.hwndParent = hwndParent;
                    psh.hInstance = g_hLocRes;
                    psh.hIcon = hIconSmall;
                    psh.pszCaption = gpi.pszGroup;
                    psh.nPages = (int) (ppsp - psp);
                    psh.nStartPage = fUpdatePage ? 1 : 0;
                    psh.ppsp = psp;
    
                    fReturn = (0 != PropertySheet(&psh));

                    DestroyIcon(hIconSmall);
                    }
                ImageList_Destroy(himlSmall);
                }
            DestroyIcon(hIcon);
            }
        ImageList_Destroy(himl);
        }

    g_pStore->FreeRecord(&Folder);
    g_pStore->FreeRecord(&Store);

    return (fReturn);
    }

//
//  FUNCTION:   FolderProp_Create()
//
//  PURPOSE:    Invokes a property sheet which displays properties for the
//              specified folder.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that should be the dialog's 
//                        parent.
//      <in> pfidl      - fully qualified pidl to the folder
//
//  RETURN VALUE:
//      TRUE  - The dialog was successfully displayed
//      FALSE - The dialog failed.
//
BOOL FolderProp_Create(HWND hwndParent, FOLDERID idFolder)
    {
    FOLDERPROP_INFO fpi = {0};
    GROUPPROP_INFO gpi = {0};
    BOOL fReturn;
    HIMAGELIST himl, himlSmall;
    HICON hIcon, hIconSmall;
    LONG iIcon;
    FOLDERINFO Folder;
    PROPSHEETPAGE psp[3], *ppsp;
    PROPSHEETHEADER psh;
    
    Assert(IsWindow(hwndParent));

    fReturn = FALSE;

    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        return FALSE;

    iIcon = GetFolderIcon(&Folder);

    // TODO: we should probably just have a global image list for this...
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFoldersLarge), 32, 0, RGB(255, 0, 255));
    if (himl != NULL)
        {
        hIcon = ImageList_GetIcon(himl, iIcon, ILD_NORMAL);
        if (hIcon != NULL)
            {
            himlSmall = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
            if (himlSmall != NULL)
                {
                hIconSmall = ImageList_GetIcon(himlSmall, iIcon, ILD_NORMAL);
                if (hIconSmall != NULL)
                    {
                    if (FolderProp_GetFolder(hwndParent, &fpi, idFolder))
                        {
                        fpi.hIcon = hIcon;    
                        fpi.fDirty = FALSE;
                        fpi.idFolder = idFolder;
        
                        ppsp = psp;

                        ZeroMemory(psp, sizeof(psp));
                        ppsp->dwSize = sizeof(PROPSHEETPAGE);
                        ppsp->dwFlags = PSP_DEFAULT;
                        ppsp->hInstance = g_hLocRes;
                        ppsp->pszTemplate = MAKEINTRESOURCE(iddFolderProp_General);
                        ppsp->pfnDlgProc = FolderProp_GeneralDlgProc;
                        ppsp->lParam = (LPARAM) &fpi;
                        ppsp++;

                        if (Folder.tyFolder != FOLDER_LOCAL)
                        {
                            gpi.hIcon = fpi.hIcon;
                            gpi.idFolder = fpi.idFolder;

                            ppsp->dwSize = sizeof(PROPSHEETPAGE);
                            ppsp->dwFlags = PSP_DEFAULT;
                            ppsp->hInstance = g_hLocRes;
                            ppsp->pszTemplate = MAKEINTRESOURCE(iddFolderProp_Update);
                            ppsp->pfnDlgProc = GroupProp_UpdateDlgProc;
                            ppsp->lParam = (LPARAM) &gpi;
                            ppsp++;

                            ppsp->dwSize = sizeof(PROPSHEETPAGE);
                            ppsp->dwFlags = PSP_DEFAULT;
                            ppsp->hInstance = g_hLocRes;
                            ppsp->pszTemplate = MAKEINTRESOURCE(iddNewsProp_Cache);
                            ppsp->pfnDlgProc = NewsProp_CacheDlgProc;
                            ppsp->lParam = (LPARAM) &gpi;
                            ppsp++;
                        }

                        psh.dwSize = sizeof(PROPSHEETHEADER);
                        psh.dwFlags = PSH_USEHICON | PSH_PROPSHEETPAGE | PSH_PROPTITLE | PSH_USEPAGELANG;
                        psh.hwndParent = hwndParent;
                        psh.hInstance = g_hLocRes;
                        psh.hIcon = hIconSmall;
                        psh.pszCaption = Folder.pszName;
                        psh.nPages = (int) (ppsp - psp);
                        psh.nStartPage = 0;
                        psh.ppsp = psp;
    
                        fReturn = (0 != PropertySheet(&psh));
                        }
                    DestroyIcon(hIconSmall);
                    }
                ImageList_Destroy(himlSmall);
                }
            DestroyIcon(hIcon);
            }
        ImageList_Destroy(himl);
        }

    g_pStore->FreeRecord(&Folder);

    return (fReturn);
    }


INT_PTR CALLBACK GroupProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                       LPARAM lParam)
    {
    PGROUPPROP_INFO pgpi = (PGROUPPROP_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];
    FOLDERINFO Folder;
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stuff the group name and server name into the dialog's extra bytes
            pgpi = (PGROUPPROP_INFO) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pgpi);

            // Intl Stuff
            SetIntlFont(GetDlgItem(hwnd, IDC_FOLDER_FILE));
            
            // Fill in what blanks we know
            SetDlgItemText(hwnd, IDC_GROUPNAME_STATIC, pgpi->pszGroup);
            
            // Put a default value into the string first
            AthLoadString(idsGroupPropStatusDef, szBuffer, ARRAYSIZE(szBuffer));

            // Get the folder info
            if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
            {
                // Is there a file
                if (Folder.pszFile)
                {
                    // Locals
                    CHAR szRootDir[MAX_PATH];

                    // Get the store root
                    if (SUCCEEDED(GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir))))
                    {
                        // Locals
                        CHAR szFilePath[MAX_PATH + MAX_PATH];

                        // Make the file path
                        if (SUCCEEDED(MakeFilePath(szRootDir, Folder.pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath))))
                            SetDlgItemText(hwnd, IDC_FOLDER_FILE, szFilePath);
                    }
                }

                // Load the status string and fill in the blanks
                AthLoadString(idsFolderPropStatus, szRes, ARRAYSIZE(szRes));

                // Format the string
                wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szRes, Folder.cMessages, Folder.cUnread);

                // Cleanup
                g_pStore->FreeRecord(&Folder);
            }

            // Set the group status info
            SetDlgItemText(hwnd, IDC_STATUS_STATIC, szBuffer);            
            
            // Set the icon correctly
            SendDlgItemMessage(hwnd, IDC_FOLDER_ICON, STM_SETICON, (WPARAM)pgpi->hIcon, 0);
            return (TRUE);
        }
    
    return (FALSE);    
    }


INT_PTR CALLBACK GroupProp_UpdateDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                      LPARAM lParam)
    {
    PGROUPPROP_INFO pgpi = (PGROUPPROP_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
    BOOL fEnabled;
    DWORD dwFlags;
    FOLDERINFO Folder;

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stuff the group name and server name into the dialog's extra bytes
            pgpi = (PGROUPPROP_INFO) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pgpi);

            // Get the Folder Info
            if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
            {
                fEnabled = (Folder.dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL));

                Button_SetCheck(GetDlgItem(hwnd, IDC_GET_CHECK), fEnabled);

                Button_Enable(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), fEnabled);
                Button_Enable(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), fEnabled);
                Button_Enable(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), fEnabled);

                // Check the right radio button
                if (fEnabled)
                {
                    if (Folder.dwFlags & FOLDER_DOWNLOADHEADERS)
                        Button_SetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), TRUE);
                    else if (Folder.dwFlags & FOLDER_DOWNLOADNEW)
                        Button_SetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), TRUE);
                    else if (Folder.dwFlags & FOLDER_DOWNLOADALL)
                        Button_SetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), TRUE);
                }
                else
                {
                    Button_SetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), TRUE);
                }

                g_pStore->FreeRecord(&Folder);
            }
            return (TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                case IDC_GET_CHECK:
                    // Check to see whether this is actually checked or not
                    fEnabled = Button_GetCheck(GET_WM_COMMAND_HWND(wParam, lParam));

                    // Enable or disable the radio buttons
                    Button_Enable(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), fEnabled);
                    Button_Enable(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), fEnabled);
                    Button_Enable(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), fEnabled);
                    
                    // Fall through...

                case IDC_NEWHEADERS_RADIO:
                case IDC_NEWMSGS_RADIO:
                case IDC_ALLMSGS_RADIO:
                    PropSheet_Changed(GetParent(hwnd), hwnd);
                    return (TRUE);

                }
            return (FALSE);

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) 
                {
                case PSN_APPLY:
                    if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
                    {
                        dwFlags = Folder.dwFlags;

                        // Remove the previous flags
                        Folder.dwFlags &= ~(FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL);

                        if (Button_GetCheck(GetDlgItem(hwnd, IDC_GET_CHECK)))
                            {
                            if (Button_GetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO)))
                                Folder.dwFlags |= FOLDER_DOWNLOADHEADERS;
                            else if (Button_GetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO)))
                                Folder.dwFlags |= FOLDER_DOWNLOADNEW;
                            else if (Button_GetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO)))
                                Folder.dwFlags |= FOLDER_DOWNLOADALL;
                            }

                        if (Folder.dwFlags != dwFlags)
                            g_pStore->UpdateRecord(&Folder);

                        g_pStore->FreeRecord(&Folder);
                    }

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    SetDlgMsgResult(hwnd, WM_NOTIFY, PSNRET_NOERROR);
                    return (TRUE);
                }
            return (FALSE);

        }

    return (FALSE);
    }

                                       
INT_PTR CALLBACK FolderProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                        LPARAM lParam)
    {
    PFOLDERPROP_INFO pfpi = (PFOLDERPROP_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];
    TCHAR szRes2[64];
    TCHAR szFldr[CCHMAX_FOLDER_NAME + 1];
    FOLDERINFO Folder;
    HRESULT hr;
    HWND hwndEdit;
    HLOCK hLock;
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stuff the folder name into the dialog's extra bytes
            pfpi = (PFOLDERPROP_INFO) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pfpi);
            
            // Put a default value into the string
            AthLoadString(idsFolderPropStatusDef, szBuffer, ARRAYSIZE(szBuffer));
            
            hwndEdit = GetDlgItem(hwnd, IDC_FOLDERNAME_EDIT);
            SetIntlFont(hwndEdit);
            SetIntlFont(GetDlgItem(hwnd, IDC_FOLDER_FILE));

            if (SUCCEEDED(g_pStore->GetFolderInfo(pfpi->idFolder, &Folder)))
                {
                if (Folder.pszFile)
                    {
                    CHAR szRootDir[MAX_PATH];

                    if (SUCCEEDED(GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir))))
                        {
                        CHAR szFilePath[MAX_PATH + MAX_PATH];

                        if (SUCCEEDED(MakeFilePath(szRootDir, Folder.pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath))))
                            SetDlgItemText(hwnd, IDC_FOLDER_FILE, szFilePath);
                        }
                    }

                AthLoadString(idsFolderPropStatus, szRes, ARRAYSIZE(szRes));
                wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szRes, Folder.cMessages, Folder.cUnread);

                if (FOLDER_IMAP != Folder.tyFolder && Folder.tySpecial == FOLDER_NOTSPECIAL)
                    {
                    SendMessage(hwndEdit, EM_SETREADONLY, (WPARAM)FALSE, 0);
                    SendMessage(hwndEdit, EM_LIMITTEXT, CCHMAX_FOLDER_NAME, 0);
                    }

                SetWindowText(hwndEdit, Folder.pszName);
                g_pStore->FreeRecord(&Folder);
                }
            
            // Set the group status info
            SetDlgItemText(hwnd, IDC_STATUS_STATIC, szBuffer);            
            
            // Need to set the specified icon
            SendDlgItemMessage(hwnd, IDC_FOLDER_ICON, STM_SETICON, (WPARAM)pfpi->hIcon, 0);

            pfpi->fDirty = FALSE;
            return (TRUE);            
            
        case WM_COMMAND:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                {
                PropSheet_Changed(GetParent(hwnd), hwnd);
                pfpi->fDirty = TRUE;
                }
            break;
            
        case WM_NOTIFY:
            NMHDR* pnmhdr = (NMHDR*) lParam;
            
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // Bug #13121 - Only try to change the folder name if the
                    //              the propsheet is dirty.
                    if (pfpi->fDirty)
                        {
                        GetDlgItemText(hwnd, IDC_FOLDERNAME_EDIT, szFldr, sizeof(szFldr) / sizeof(TCHAR));

                        if (!FAILED(hr = RenameFolderProgress(hwnd, pfpi->idFolder, szFldr, NOFLAGS)))
                            SetDlgMsgResult(hwnd, WM_NOTIFY, PSNRET_NOERROR);
                        else
                            AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrRenameFld), hr);

                        pfpi->fDirty = FALSE;
                        }
                    return (0);
                    
                case PSN_KILLACTIVE:
                    SetDlgMsgResult(hwnd, WM_NOTIFY, 0L);
                    return (0);
                }
            break;
        }
    
    return (FALSE);    
    }

//
//  FUNCTION:   FolderProp_GetFolder()
//
//  PURPOSE:    This function is used by the Folder Property dialog to get
//              the store object and folder handle for callers who did not
//              already provide this information.
//
//  PARAMETERS:
//      <in> hwnd - Handle of the property sheet window
//      <in> pfpi - Pointer to the FOLDERPROP_INFO struct that stores the prop
//                  sheet's information.
//      <in> pfidl - fully qualified pidl of folder
//      <in> pfidlLeaf - leaf pidl of folder
//
//  RETURN VALUE:
//      TRUE  - The information was retrieved
//      FALSE - The information was not available
//
BOOL FolderProp_GetFolder(HWND hwnd, PFOLDERPROP_INFO pfpi, FOLDERID idFolder)
    {
    pfpi->idFolder = idFolder;
    return (TRUE);    
    }

INT_PTR CALLBACK NewsProp_CacheDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    FOLDERINFO Folder;
    PGROUPPROP_INFO pgpi = (PGROUPPROP_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
    CHAR szRes[255];
    CHAR szMsg[255 + 255];
    
    switch (uMsg)
        {
        case WM_INITDIALOG:

            // Stuff the group name and server name into the dialog's extra bytes
            pgpi = (PGROUPPROP_INFO) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pgpi);
            SendDlgItemMessage(hwnd, IDC_FOLDER_ICON, STM_SETICON, (WPARAM)pgpi->hIcon, 0);

            // Disable the Reset button
            EnableWindow(GetDlgItem(hwnd, idbReset), FALSE);

            // Get the folder information
            if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
            {
                // News 
                if (FOLDER_NEWS == Folder.tyFolder)
                {
                    // If Its news, enable the 
                    EnableWindow(GetDlgItem(hwnd, idbReset), TRUE);
                }

                // Free the Folder Infp
                g_pStore->FreeRecord(&Folder);
            }

            // Locals
            DisplayFolderSizeInfo(hwnd, RECURSE_INCLUDECURRENT, pgpi->idFolder);

            // Done
            break;
            
        case WM_COMMAND:
            BOOL fRet = FALSE;
            UINT nCmd = GET_WM_COMMAND_ID(wParam, lParam);
            HCURSOR hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));  // Bug 12513. Need to disable button, when process command

            switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                case idbCompactCache:
                    {
                        if (SUCCEEDED(CleanupFolder(GetParent(hwnd), RECURSE_INCLUDECURRENT, pgpi->idFolder, CLEANUP_COMPACT)))
                            DisplayFolderSizeInfo(hwnd, RECURSE_INCLUDECURRENT, pgpi->idFolder);
                        fRet = TRUE;
                    }
                    break;

                case idbRemove:
                case idbReset:
                case idbDelete:
                    {
                        // Get Folder Info
                        if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
                        {
                            // Get Command
                            UINT                idCommand=GET_WM_COMMAND_ID(wParam, lParam);
                            UINT                idString;
                            CLEANUPFOLDERTYPE   tyCleanup;

                            // Remove
                            if (idbRemove == idCommand)
                            {
                                idString = idsConfirmDelBodies;
                                tyCleanup = CLEANUP_REMOVEBODIES;
                            }

                            // Delete
                            else if (idbDelete == idCommand)
                            {
                                idString = idsConfirmDelMsgs;
                                tyCleanup = CLEANUP_DELETE;
                            }

                            // Remove
                            else
                            {
                                Assert(idbReset == idCommand);
                                idString = idsConfirmReset;
                                tyCleanup = CLEANUP_RESET;
                            }

                            // Load the String
                            AthLoadString(idString, szRes, ARRAYSIZE(szRes));
        
                            // Format with the Folder Name
                            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, Folder.pszName);

                            // Confirm
                            if (IDYES == AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szMsg, NULL, MB_YESNO | MB_ICONEXCLAMATION))
                            {
                                // Cleanup the Folder
                                if (SUCCEEDED(CleanupFolder(hwnd, RECURSE_INCLUDECURRENT, pgpi->idFolder, tyCleanup)))
                                {
                                    // Reset Information
                                    DisplayFolderSizeInfo(hwnd, RECURSE_INCLUDECURRENT, pgpi->idFolder);
                                }
                            }

                            // Free Folder Information
                            g_pStore->FreeRecord(&Folder);
                        }

                        // Message Handled
                        fRet = TRUE;
                    }
                    break;
                }
            SetCursor(hCur);

            if(fRet)
                return 1;
            break;
        }
    return (FALSE);    
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\fontnsc.cpp ===
/*
 *      f o n t n s c . c p p
 *
 *      Implementation of a richedit format bar
 *
 *      Owner: AnthonyF
 *      taken from Capone: brettm
 */

#include "pch.hxx"
#include "resource.h"
#include "fonts.h"
#include <assert.h>
#ifndef WIN16
#include <wchar.h>
#endif
#include <shlwapi.h>
#include "strconst.h"
#include "demand.h"
#include "menures.h"

#ifdef WIN16
#ifdef PRINTER_FONTTYPE
#undef PRINTER_FONTTYPE
#endif
#define PRINTER_FONTTYPE   0
#endif

/*
 *  m a c r o s
 */
#define GETINDEX(m) (DWORD) (((((m) & 0xff000000) >> 24) & 0x000000ff))
#define MAKEINDEX(b, l) (((DWORD)(l) & 0x00ffffff) | ((DWORD)(b) << 24))

/*
 *  c o n s t a n t s
 */
#define NFONTSIZES 7
#define TEMPBUFSIZE 30

/*
 *  t y p e d e f s
 */
INT CALLBACK NEnumFontNameProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType, LPARAM lParam);

/*
 *  g l o b a l   d a t a
 */

/*
 *      Color table for dropdown on toolbar.  Matches COMMDLG colors
 *      exactly.
 */

static DWORD rgrgbColors[] = {
    RGB_AUTOCOLOR,        // "AUTO"},
    RGB(  0,   0, 0),     // "BLACK"},   
    RGB(128,   0, 0),     // "DARK RED"},
    RGB(  0, 128, 0),     // "DARK YELLOW"},
    RGB(128, 128, 0),     // "DARK BLUE"},
    RGB(  0,   0, 128),   // "DARK BLUE"},
    RGB(128,   0, 128),   // "DARK PURPLE"},
    RGB(  0, 128, 128),   // "DARK AQUA"},
    RGB(128, 128, 128),   // "DARK GREY"}, 
    RGB(192, 192, 192),   // "LIGHT GREY"},  
    RGB(255,   0, 0),     // "LIGHT RED"}, 
    RGB(  0, 255, 0),     // "LIGHT GREEN"}, 
    RGB(255, 255, 0),     // "LIGHT YELLOW"},
    RGB(  0,   0, 255),   // "LIGHT BLUE"},  
    RGB(255,   0, 255),   // "LIGHT PURPLE"},
    RGB(  0, 255, 255),   // "LIGHT AQUA"}, 
    RGB(255, 255, 255)   // "WHITE"}    
};

/*
 *  p r o t o t y p e s
 */

HRESULT HrCreateColorMenu(ULONG idmStart, HMENU* pMenu, BOOL fUseAuto)
{
    DWORD               irgb;
    DWORD               mniColor;

    if(pMenu == NULL)
        return E_INVALIDARG;

    *pMenu = CreatePopupMenu();

    if (*pMenu == NULL)
        return E_OUTOFMEMORY;

    // Add the COLORREF version of each entry into the menu
    for (irgb = fUseAuto ? 0 : 1, mniColor=idmStart;
             irgb < sizeof(rgrgbColors)/sizeof(DWORD);
             ++irgb, ++mniColor)
    {
        AppendMenu(*pMenu, MF_ENABLED|MF_OWNERDRAW, mniColor, (LPCSTR)IntToPtr(MAKEINDEX(irgb, rgrgbColors[irgb])));
    }
    return NOERROR;
}


HRESULT HrCreateComboColor(HWND hCombo)
{
    DWORD               irgb;
    DWORD               mniColor;
    LRESULT         lr;

    if(hCombo == NULL)
        return E_INVALIDARG;

    ComboBox_SetExtendedUI(hCombo, TRUE);

    for (irgb = 0; irgb < sizeof(rgrgbColors)/sizeof(DWORD); ++irgb)
    {
        lr = ComboBox_AddString(hCombo, (LPCSTR)" ");
        if (lr == CB_ERR || lr == CB_ERRSPACE)
                break;

        ComboBox_SetItemData(hCombo, LOWORD(lr), (LPCSTR)IntToPtr(MAKEINDEX(irgb, rgrgbColors[irgb])));
    }
    return NOERROR;
}


void Color_WMDrawItem(LPDRAWITEMSTRUCT pdis, INT iColor, BOOL fBackground)
{
    HBRUSH                          hbr;
    WORD                            dx, dy, dxBorder;
    RECT                            rc;
    TCHAR                           szColor[MAX_PATH]={0};
    DWORD                           rgbBack, rgbText;
    UINT                            id = pdis->itemID;
    ULONG                           index = 0;

    switch(iColor)
    {
    case iColorMenu:
        if(pdis->itemState&ODS_SELECTED)
        {
            rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
            rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_MENU));
            rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_MENUTEXT));
        }
        break;
    case iColorCombo:
        if(pdis->itemState&ODS_SELECTED)
        {
            rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
            rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
            rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
        }
        break;
    default:
        Assert(FALSE);
    }

    /* compute coordinates of color rectangle and draw it */
    dxBorder  = (WORD) GetSystemMetrics(SM_CXBORDER);
    if(iColor == iColorMenu)
        dx    = (WORD) GetSystemMetrics(SM_CXMENUCHECK);
    else
        dx    = (WORD) GetSystemMetrics(SM_CXBORDER);

    dy        = (WORD) GetSystemMetrics(SM_CYBORDER);
    rc.top    = pdis->rcItem.top + dy;
    rc.bottom = pdis->rcItem.bottom - dy;
    rc.left   = pdis->rcItem.left + dx;
    rc.right  = rc.left + 2 * (rc.bottom - rc.top);

    index = GETINDEX(pdis->itemData);
    LoadString(g_hLocRes, index + idsAutoColor,
                       szColor, sizeof(szColor)/sizeof(TCHAR));
    SelectObject(pdis->hDC, HGetSystemFont(FNT_SYS_MENU));

    ExtTextOut(pdis->hDC, rc.right + 2*dxBorder,
                       pdis->rcItem.top, ETO_OPAQUE, &pdis->rcItem,
                       szColor, lstrlen(szColor), NULL);


    switch(iColor)
    {
    case iColorMenu:
        if(pdis->itemID == ID_FORMAT_COLORAUTO) // auto color item
            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT));
        else if (pdis->itemID == ID_BACK_COLOR_AUTO)
            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
        else
            hbr = CreateSolidBrush((DWORD) (pdis->itemData & 0x00ffffff));

        break;
    case iColorCombo:
        if (pdis->itemID == 0) // auto color item
            {
            if (fBackground)
                hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
            else
                hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT));
            }
        else
            hbr = CreateSolidBrush((DWORD)(pdis->itemData & 0x00ffffff));
        break;
    default:
        Assert(FALSE);
    }

    if (hbr)
    {
        hbr = (HBRUSH)SelectObject (pdis->hDC, hbr);
        Rectangle(pdis->hDC, rc.left, rc.top, rc.right, rc.bottom);
        DeleteObject(SelectObject(pdis->hDC, hbr));
    }

    // draw radio check.
    if(iColor == iColorMenu && pdis->itemState&ODS_CHECKED)
    {
        WORD left, top, radius;

        if(pdis->itemState&ODS_SELECTED)
            hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHTTEXT));
        else
            hbr = CreateSolidBrush(GetSysColor(COLOR_MENUTEXT));

        if (hbr)
        {
            hbr = (HBRUSH)SelectObject (pdis->hDC, hbr);
            left = (WORD) (pdis->rcItem.left + GetSystemMetrics(SM_CXMENUCHECK) / 2);
            top = (WORD) (rc.top + (rc.bottom - rc.top) / 2);
            radius = (WORD) (GetSystemMetrics(SM_CXMENUCHECK) / 4);
            Ellipse(pdis->hDC, left-radius, top-radius, left+radius, top+radius);
            DeleteObject(SelectObject(pdis->hDC, hbr));
        }
    }

    SetTextColor(pdis->hDC, rgbText);
    SetBkColor(pdis->hDC, rgbBack);
}


void Color_WMMeasureItem(HDC hdc, LPMEASUREITEMSTRUCT pmis, INT iColor)
{
    HFONT                           hfontOld = NULL;
    TEXTMETRIC                      tm;
    UINT                            id = pmis->itemID;
    TCHAR                           szColor[MAX_PATH]={0};

    switch(iColor)
    {
    case iColorMenu:
        hfontOld = (HFONT)SelectObject(hdc, HGetSystemFont(FNT_SYS_MENU));
        break;
    case iColorCombo:
        hfontOld = (HFONT)SelectObject(hdc, HGetSystemFont(FNT_SYS_ICON));
        break;
    default:
        Assert(FALSE);
    }

    GetTextMetrics(hdc, &tm);
    SelectObject(hdc, hfontOld);

    ULONG index = GETINDEX(pmis->itemData);
    LoadString(g_hLocRes, index + idsAutoColor,
                       szColor, sizeof(szColor)/sizeof(TCHAR));

    pmis->itemHeight = tm.tmHeight + 2 * GetSystemMetrics(SM_CYBORDER);
    pmis->itemWidth = GetSystemMetrics(SM_CXMENUCHECK) +
                      2 * GetSystemMetrics(SM_CXBORDER) + 
                      2 * tm.tmHeight +
                      (lstrlen(szColor) + 2) *tm.tmAveCharWidth;
}


// displays the colorpopup menu at the specified point. if clrf if NULL, then no clrf is returned
// but instead the appropriate WM_COMMAND is dispatched to the parent window
HRESULT HrColorMenu_Show(HMENU hmenuColor, HWND hwndParent, POINT pt, COLORREF *pclrf)
{
    HRESULT     hr=NOERROR;
    int         tpm=TPM_LEFTALIGN|TPM_LEFTBUTTON;

    if(hmenuColor == NULL)
        return E_INVALIDARG;

    if(pclrf)
         tpm|=TPM_RETURNCMD;

    int id = TrackPopupMenu(hmenuColor, tpm,pt.x, pt.y, 0, hwndParent, NULL);

    switch(id)
        {
        case 1:
            return NOERROR;
        case 0:
            return E_FAIL;
        case -1:
            return E_FAIL;

        case ID_FORMAT_COLORAUTO:
        case ID_FORMAT_COLOR1:
        case ID_FORMAT_COLOR2:
        case ID_FORMAT_COLOR3:
        case ID_FORMAT_COLOR4:
        case ID_FORMAT_COLOR5:
        case ID_FORMAT_COLOR6:
        case ID_FORMAT_COLOR7:
        case ID_FORMAT_COLOR8:
        case ID_FORMAT_COLOR9:
        case ID_FORMAT_COLOR10:
        case ID_FORMAT_COLOR11:
        case ID_FORMAT_COLOR12:
        case ID_FORMAT_COLOR13:
        case ID_FORMAT_COLOR14:
        case ID_FORMAT_COLOR15:
        case ID_FORMAT_COLOR16:
            AssertSz(pclrf, "this HAS to be set to get this id back...");
            *pclrf=rgrgbColors[id-ID_FORMAT_COLORAUTO];
            return NOERROR;

        default:
            AssertSz(0, "unexpected return from TrackPopupMenu");
        }

    return E_FAIL;
}


DWORD GetColorRGB(INT index)
{
    return rgrgbColors[index];
}

INT GetColorIndex(INT rbg)
{
    INT iFound = -1;
    for(int irgb = 1; irgb < sizeof(rgrgbColors)/sizeof(DWORD); ++irgb)
    {
        if((rbg&0x00ffffff) == (LONG)rgrgbColors[irgb])
        {
            iFound = irgb;
            break;
        }
    }
    return iFound;
}


// fill font name combo box
void FillFontNames(HWND hwndCombo)
{
    LOGFONT lf = {0};
    HDC hdc;

    // reset the contents of the combo
    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);

    hdc = GetDC(NULL);
    if (hdc)
    {
        //to enumerate all styles of all fonts for the default character set
        lf.lfFaceName[0] = '\0';
        lf.lfCharSet = DEFAULT_CHARSET;

        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)NEnumFontNameProcEx, (LPARAM)hwndCombo, 0);
        ReleaseDC(NULL, hdc);
    }
}


INT CALLBACK NEnumFontNameProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType, LPARAM lParam)
{
    LONG        l;
    HWND        hwndCombo = (HWND)lParam;

    Assert(hwndCombo);

    // skip vertical fonts for OE
    if (plf->elfLogFont.lfFaceName[0]=='@')
        return TRUE;    

    // if the font is already listed, don't re-list it
    if(ComboBox_FindStringExact(hwndCombo, -1, plf->elfLogFont.lfFaceName) != -1)
        return TRUE;

    l = ComboBox_AddString(hwndCombo, plf->elfLogFont.lfFaceName);
    if (l!=-1)
        ComboBox_SetItemData(hwndCombo, l, nFontType);

    return TRUE;
}


void FillSizes(HWND hwndSize)
{
    LONG                            id;
    TCHAR                           szBuf[TEMPBUFSIZE];
    *szBuf = 0;
    LRESULT                         lr;

    // Empty the current list
    SendMessage(hwndSize, CB_RESETCONTENT, 0, 0);

    for (id = idsFontSize0; id < NFONTSIZES + idsFontSize0; ++id)
    {
        LoadString(g_hLocRes, id, szBuf, sizeof(szBuf));
        lr = SendMessage(hwndSize, CB_ADDSTRING, 0, (LPARAM) szBuf);
        if (lr == CB_ERR || lr == CB_ERRSPACE)
           break;
    }

}


// size of pszColor must be bigger than 7
HRESULT HrFromIDToRBG(INT id, LPWSTR pwszColor, BOOL fBkColor)
{
    DWORD         cr;

    if(id<0 || id>16 || !pwszColor)
        return E_INVALIDARG;

    if (id == 0)
    {
        if (fBkColor)
            cr = GetSysColor(COLOR_WINDOW);
        else
            cr = GetSysColor(COLOR_WINDOWTEXT);
    }
    else
        cr = rgrgbColors[id];

    return HrGetStringRBG(cr, pwszColor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\hotlinks.h ===
// =================================================================================
// L I N K S . H
// =================================================================================
#ifndef __LINKS_H
#define __LINKS_H

BOOL LookupLinkColors(LPCOLORREF pclrLink, LPCOLORREF pclrViewed);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\goptions.h ===
#ifndef _INC_GOPTIONS_H
#define _INC_GOPTIONS_H

#include <msoeopt.h>

#ifdef DEBUG

#define OPT_EXPIRE_MINUTES          (OPT_BASE +   300)

#endif // DBUG

extern IOptionBucketEx *g_pOpt;

class COptNotify;
extern COptNotify *g_pOptNotify;

#ifdef DEFINE_OPTION_STRUCTS
static const RECT c_rcNotePosDefault = {50, 20, 580, 450};

#define ROOT_REG    0
#define MAIL_REG    1
#define NEWS_REG    2
#define RULES_REG   3
#define COPTREGKEY  4

LPCSTR c_rgszOptRegKey[COPTREGKEY] =
    {
    NULL,
    c_szMail,
    c_szNews,
    c_szRules
    };

#define OPT_GLOBAL(opt,type,key,val,def,cb,lo,hi,fn) {opt, type, key, val, (LPCSTR)(def), cb, lo, hi, fn},

const OPTIONINFO c_rgOptInfo[] = {

// !!!To add new options, you must keep the "OPT_..." ordinals in ascending order!!!
//         OPTION,                  VARTYPE,  REG KEY,    REG VALUE,              DEFAULT,    DEF SIZE,   MIN,MAX,VALIDATE FUNC
OPT_GLOBAL(OPT_TIPOFTHEDAY,         VT_UI4,   ROOT_REG,   c_szRegTipOfTheDay,     TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWSTATUSBAR,       VT_UI4,   ROOT_REG,   c_szShowStatus,         TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWTREE,            VT_UI4,   ROOT_REG,   c_szShowTree,           TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_TREEWIDTH,           VT_UI4,   ROOT_REG,   c_szTreeWidth,          200,        0,          0,  0,  0)
OPT_GLOBAL(OPT_EXPAND_UNREAD,       VT_UI4,   ROOT_REG,   c_szRegExpandUnread,    TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_BROWSERPOS,          VT_BLOB,  ROOT_REG,   c_szBrowserPos,         NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWBODYBAR,         VT_UI4,   ROOT_REG,   c_szShowBodyBar,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_BODYBARPOS,          VT_UI4,   ROOT_REG,   c_szBodyBarPos,         0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_IMAPPURGE,           VT_UI4,   ROOT_REG,   c_szRegExpungeFolder,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_HIDEFOLDERBAR,       VT_UI4,   ROOT_REG,   c_szRegHideFolderBar,   FALSE,      0,          0,  0,  0)
// spelling options
OPT_GLOBAL(OPT_SPELLALWAYSSUGGEST,  VT_UI4,   ROOT_REG,   c_szRegAlwaysSuggest,   TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNORENUMBER,   VT_UI4,   ROOT_REG,   c_szRegIgnoreNumbers,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNOREUPPER,    VT_UI4,   ROOT_REG,   c_szRegIgnoreUpper,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNOREPROTECT,  VT_UI4,   ROOT_REG,   c_szRegIgnoreProtect,   TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLCHECKONSEND,    VT_UI4,   ROOT_REG,   c_szRegCheckOnSend,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNOREDBCS,     VT_UI4,   ROOT_REG,   c_szRegIgnoreDBCS,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNOREURL,      VT_UI4,   ROOT_REG,   c_szRegIgnoreURL,       TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLCHECKONTYPE,    VT_UI4,   ROOT_REG,   c_szRegCheckOnType,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_CHECKEDMAILACCOUNTS, VT_UI4,   MAIL_REG,   c_szRegCheckedAccounts, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_CHECKEDNEWSACCOUNTS, VT_UI4,   NEWS_REG,   c_szRegCheckedAccounts, FALSE,      0,          0,  0,  0)

OPT_GLOBAL(OPT_AUTO_IMAGE_INLINE,   VT_UI4,   ROOT_REG,   c_szRegAutoImageInline, AUTO_INLINE_FLAT, 0,    0,  0,  0)
OPT_GLOBAL(OPT_USEAUTOCOMPLETE,     VT_UI4,   ROOT_REG,   c_szRegUseAutoComplete, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_REPLYINORIGFMT,      VT_UI4,   ROOT_REG,   c_szRegReplyInOrigFmt,  TRUE,       0,          0,  0,  0)

OPT_GLOBAL(OPT_RASCONNDETAILS,      VT_UI4,   ROOT_REG,   c_szRasConnDetails,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DIALUP_CONNECTION,   VT_LPSTR, ROOT_REG,   c_szRegDialupConnection,NULL,       0,          0,  CCHMAX_CONNECTOID - 1,  0)
OPT_GLOBAL(OPT_DIALUP_WARN_SWITCH,  VT_UI4,   ROOT_REG,   c_szRegWarnSwitch,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_DIALUP_HANGUP_DONE,  VT_UI4,   ROOT_REG,   c_szRegHangupDone,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DIALUP_LAST_START,   VT_LPSTR, ROOT_REG,   c_szRegDialupLastStart, NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_DIALUP_HANGUP_WITHOUT_DIAL,VT_UI4, ROOT_REG, c_szRegHangupNoDial,  FALSE,      0,          0,  0,  0)

OPT_GLOBAL(OPT_SPOOLERDLGPOS,       VT_BLOB,  ROOT_REG,   c_szRegSpoolerDlgPos,   NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPOOLERTACK,         VT_UI4,   ROOT_REG,   c_szRegSpoolerTack,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DIAL_DURING_POLL,    VT_UI4,   ROOT_REG,   c_szRegDialDuringPoll,  DO_NOT_DIAL,      0,          0,  0,  0)

OPT_GLOBAL(OPT_LAUNCH_INBOX,        VT_UI4,   ROOT_REG,   c_szRegLaunchInbox,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITYZONE,        VT_UI4,   ROOT_REG,   c_szRegSecurityZone,    DEF_SECURITYZONE, 0,    0,  0,  0)
OPT_GLOBAL(OPT_HARDCODEDHDRS,       VT_UI4,   ROOT_REG,   c_szRegHardCodedHdrs,   TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SMTPUSEIPFORHELO,    VT_UI4,   ROOT_REG,   c_szRegSmtpUseIpForHelo,FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_FIND_THREAD,         VT_UI4,   ROOT_REG,   c_szRegFindThread,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_FIND_FILTER_STATE,   VT_UI4,   ROOT_REG,   c_szRegFindFilter,      1,          0,          0,  0,  0)

OPT_GLOBAL(OPT_NEWMAILSOUND,        VT_UI4,   MAIL_REG,   c_szOptNewMailSound,    TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_PURGEWASTE,          VT_UI4,   MAIL_REG,   c_szPurgeWaste,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_ATTACHVCARD,    VT_UI4,   MAIL_REG,   c_szRegAttachVCard,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_VCARDNAME,      VT_LPSTR, MAIL_REG,   c_szRegVCardName,       NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILHYBRIDVIEW,      VT_UI4,   MAIL_REG,   c_szRegShowHybrid,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITYZONELOCKED,  VT_UI4,   ROOT_REG,   c_szRegSecurityZoneLocked, FALSE,   0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILCXSPLIT,         VT_UI4,   MAIL_REG,   c_szRegSplitVertPct,    50,         0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILCYSPLIT,         VT_UI4,   MAIL_REG,   c_szRegSplitHorzPct,    50,         0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILSPLITDIR,        VT_UI4,   MAIL_REG,   c_szRegSplitDir,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILNOTEPOS,         VT_BLOB,  MAIL_REG,   c_szRegNotePos,         &c_rcNotePosDefault, sizeof(RECT), 0, 0, 0)
OPT_GLOBAL(OPT_SENDIMMEDIATE,       VT_UI4,   MAIL_REG,   c_szRegSendImmediate,   TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEEDWELCOMEMSG,      VT_UI4,   MAIL_REG,   c_szNeedWelcomeMsg,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_INCOMDEFENCODE,      VT_UI4,   ROOT_REG,   c_szIncDefEncode,       FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILSHOWHEADERINFO,  VT_UI4,   MAIL_REG,   c_szMailShowHeaderInfo, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_IMAP4LOGFILE,   VT_LPSTR, MAIL_REG,   c_szRegImap4LogFile,    NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILINDENT,          VT_UI4,   MAIL_REG,   c_szRegIndentChar,      DEF_INDENTCHAR, 0,      0,  0,  0)
OPT_GLOBAL(OPT_MAILLOG,             VT_UI4,   MAIL_REG,   c_szLogPop3,            DEF_LOGMAIL,0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILSMTPLOGFILE,     VT_LPSTR, MAIL_REG,   c_szSmtpLogFile,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILPOP3LOGFILE,     VT_LPSTR, MAIL_REG,   c_szPop3LogFile,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_SEND_HTML,      VT_UI4,   MAIL_REG,   c_szMsgSendHtml,        TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_PLAIN_MIME, VT_UI4,   MAIL_REG,   c_szMsgPlainMime,       TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_PLAIN_ENCODE, VT_UI4, MAIL_REG,   c_szMsgPlainEncoding,   IET_7BIT,   0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_HTML_ENCODE,VT_UI4,   MAIL_REG,   c_szMsgHTMLEncoding,    IET_QP,     0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_PLAIN_LINE_WRAP, VT_UI4, MAIL_REG,c_szMsgPlainLineWrap,   DEF_AUTOWRAP, 0,        AUTOWRAP_MIN, AUTOWRAP_MAX, 0)
OPT_GLOBAL(OPT_MAIL_MSG_HTML_LINE_WRAP, VT_UI4, MAIL_REG, c_szMsgHTMLLineWrap,    DEF_AUTOWRAP, 0,        AUTOWRAP_MIN, AUTOWRAP_MAX, 0)
OPT_GLOBAL(OPT_MAIL_MSG_HTML_ALLOW_8BIT, VT_UI4, MAIL_REG,c_szMsgHTMLAllow8bit,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_PLAIN_ALLOW_8BIT, VT_UI4, MAIL_REG, c_szMsgPlainAllow8bit,FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_LANG_VIEW,      VT_UI4,   MAIL_REG,   c_szLangView,           0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_VIEW_SET_DEFAULT, VT_UI4, MAIL_REG,   c_szLangViewSetDefault, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_AUTOADDTOWABONREPLY, VT_UI4, MAIL_REG,c_szAutoAddToWABOnReply,TRUE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_DEFENCRYPTSYMCAPS, VT_BLOB, MAIL_REG, c_szRegDefEncryptSymcaps, NULL,     0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_SENDINLINEIMAGES, VT_UI4, MAIL_REG,   c_szRegSendInlineImages,TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_HTML_INDENT_REPLY, VT_UI4, MAIL_REG, c_szRegIndentReply,  TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_DIGSIGNMESSAGES,VT_UI4,   MAIL_REG,   c_szRegDigSign,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_ENCRYPTMESSAGES,VT_UI4,   MAIL_REG,   c_szRegEncrypt,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_INCLUDECERT,    VT_UI4,   MAIL_REG,   c_szRegIncludeCert,     TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_LOGIMAP4,       VT_UI4,   MAIL_REG,   c_szRegLogImap4,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_THREAD,         VT_UI4,   MAIL_REG,   c_szRegThreadArticles,  FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SAVESENTMSGS,        VT_UI4,   MAIL_REG,   c_szOptnSaveInSentItems,TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_INCLUDEMSG,          VT_UI4,   MAIL_REG,   c_szRegIncludeMsg,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_POLLFORMSGS,         VT_UI4,   MAIL_REG,   c_szRegPollForMail,     30 * 60 * 1000, 0,      1 * 60 * 1000, 480 * 60 * 1000,0) // milliseconds
OPT_GLOBAL(OPT_MARKASREAD,          VT_UI4,   MAIL_REG,   c_szMarkPreviewAsRead,  5,          0,          0,  60, 0)
OPT_GLOBAL(OPT_MAIL_FONTCOLOR,      VT_UI4,   MAIL_REG,   c_szRegFontColor,       0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTFACE,       VT_LPSTR, MAIL_REG,   c_szRegFontFace,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTSIZE,       VT_UI4,   MAIL_REG,   c_szRegFontSize,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTBOLD,       VT_UI4,   MAIL_REG,   c_szRegFontBold,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTITALIC,     VT_UI4,   MAIL_REG,   c_szRegFontItalic,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTUNDERLINE,  VT_UI4,   MAIL_REG,   c_szRegFontUnderline,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_USESTATIONERY,  VT_UI4,   MAIL_REG,   c_szRegUseStationery,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_STATIONERYNAME, VT_LPSTR, MAIL_REG,   c_szRegStationeryName,  NULL,       0,          0,  0,  0)

OPT_GLOBAL(OPT_DOWNLOADCHUNKS,      VT_UI4,   NEWS_REG,   c_szRegDownload,        DEF_DOWNLOADCHUNKS, 0,  50, 1000, 0)
OPT_GLOBAL(OPT_NOTIFYGROUPS,        VT_UI4,   NEWS_REG,   c_szRegNotifyNewGroups, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MARKALLREAD,         VT_UI4,   NEWS_REG,   c_szRegMarkAllRead,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_ATTACHVCARD,    VT_UI4,   NEWS_REG,   c_szRegAttachVCard,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_VCARDNAME,      VT_LPSTR, NEWS_REG,   c_szRegVCardName,       NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_XPORT_LOG,      VT_UI4,   NEWS_REG,   c_szLog,                FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSHYBRIDVIEW,      VT_UI4,   NEWS_REG,   c_szRegShowHybrid,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSCXSPLIT,         VT_UI4,   NEWS_REG,   c_szRegSplitVertPct,    50,         0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSCYSPLIT,         VT_UI4,   NEWS_REG,   c_szRegSplitHorzPct,    50,         0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSSPLITDIR,        VT_UI4,   NEWS_REG,   c_szRegSplitDir,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSDLGPOS,          VT_BLOB,  NEWS_REG,   c_szRegNewsDlgPos,      NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSDLGCOLUMNS,      VT_BLOB,  NEWS_REG,   c_szRegNewsDlgColumns,  NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSSHOWHEADERINFO,  VT_UI4,   NEWS_REG,   c_szNewsShowHeaderInfo, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSNOTEADVREAD,     VT_UI4,   NEWS_REG,   c_szRegNewsNoteAdvRead, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSNOTEADVSEND,     VT_UI4,   NEWS_REG,   c_szRegNewsNoteAdvSend, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSMODERATOR,       VT_UI4,   NEWS_REG,   c_szRegNewsModerator,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSCONTROLHEADER,   VT_UI4,   NEWS_REG,   c_szRegNewsControlHeader, FALSE,    0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSINDENT,          VT_UI4,   NEWS_REG,   c_szRegIndentChar,      DEF_INDENTCHAR, 0,      0,  0,  0)
OPT_GLOBAL(OPT_CACHEDELETEMSGS,     VT_UI4,   NEWS_REG,   c_szCacheDelMsgDays,    5,          0,          1,  999,0)
OPT_GLOBAL(OPT_CACHEREAD,           VT_UI4,   NEWS_REG,   c_szCacheRead,          FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_CACHECOMPACTPER,     VT_UI4,   NEWS_REG,   c_szCacheCompactPer,    20,         0,          5,  100,0)
OPT_GLOBAL(OPT_NEWSDLDLGPOS,        VT_BLOB,  NEWS_REG,   c_szRegDLDlgPos,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_SEND_HTML,      VT_UI4,   NEWS_REG,   c_szMsgSendHtml,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_PLAIN_MIME, VT_UI4,   NEWS_REG,   c_szMsgPlainMime,       FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_PLAIN_ENCODE, VT_UI4, NEWS_REG,   c_szMsgPlainEncoding,   IET_7BIT,   0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_HTML_ENCODE,VT_UI4,   NEWS_REG,   c_szMsgHTMLEncoding,    IET_QP,     0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_PLAIN_LINE_WRAP, VT_UI4, NEWS_REG,c_szMsgPlainLineWrap,   76,         0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_HTML_LINE_WRAP, VT_UI4, NEWS_REG, c_szMsgHTMLLineWrap,    76,         0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_HTML_ALLOW_8BIT, VT_UI4, NEWS_REG,c_szMsgHTMLAllow8bit,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_PLAIN_ALLOW_8BIT, VT_UI4, NEWS_REG, c_szMsgPlainAllow8bit,FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_LANG_VIEW,      VT_UI4,   NEWS_REG,   c_szLangView,           0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_VIEW_SET_DEFAULT, VT_UI4, NEWS_REG,   c_szLangViewSetDefault, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_THREAD,         VT_UI4,   NEWS_REG,   c_szRegThreadArticles,  TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_AUTOEXPAND,          VT_UI4,   NEWS_REG,   c_szRegAutoExpand,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_AUTOFILLPREVIEW,     VT_UI4,   NEWS_REG,   c_szRegNewsFillPreview, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_SENDINLINEIMAGES, VT_UI4, NEWS_REG,   c_szRegSendInlineImages,TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTCOLOR,      VT_UI4,   NEWS_REG,   c_szRegFontColor,       0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTFACE,       VT_LPSTR, NEWS_REG,   c_szRegFontFace,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTSIZE,       VT_UI4,   NEWS_REG,   c_szRegFontSize,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTBOLD,       VT_UI4,   NEWS_REG,   c_szRegFontBold,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTITALIC,     VT_UI4,   NEWS_REG,   c_szRegFontItalic,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTUNDERLINE,  VT_UI4,   NEWS_REG,   c_szRegFontUnderline,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_USESTATIONERY,  VT_UI4,   NEWS_REG,   c_szRegUseStationery,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_STATIONERYNAME, VT_LPSTR, NEWS_REG,   c_szRegStationeryName,  NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_HTML_INDENT_REPLY, VT_UI4, NEWS_REG, c_szRegIndentReply,  TRUE,       0,          0,  0,  0)

OPT_GLOBAL(OPT_ATHENA_RUNNING,      VT_UI4,   ROOT_REG,   c_szOERunning,          FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MIGRATION_PERFORMED, VT_UI4,   ROOT_REG,   c_szMigrationPerformed, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NO_SELF_ENCRYPT,     VT_UI4,   ROOT_REG,   c_szDontEncryptForSelf, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_LAST_MESSAGE,        VT_BLOB,  ROOT_REG,   c_szLastMsg,            NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_FINDER_POS,          VT_BLOB,  ROOT_REG,   c_szFindPos,            NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_OPAQUE_SIGN,         VT_UI4,   ROOT_REG,   c_szOpaqueSigning,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELL_LANGID,        VT_LPSTR, ROOT_REG,   c_szRegSpellLangID,     NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_TEST_MODE,           VT_UI4,   ROOT_REG,   c_szTestMode,           FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DUMP_FILE,           VT_LPSTR, ROOT_REG,   c_szDumpFile,           NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NO_SPLASH,           VT_UI4,   ROOT_REG,   c_szNoSplash,           FALSE,      0,          0,  0,  0)

OPT_GLOBAL(OPT_SHOW_NOTE_STATUSBAR, VT_UI4,   ROOT_REG,   c_szShowStatusbar,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOW_NOTE_FMTBAR,    VT_UI4,   ROOT_REG,   c_szShowFormatBar,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_ATTACH_VIEW_STYLE,   VT_UI4,   ROOT_REG,   c_szAttachViewStyle,    LVS_ICON,   0,          0,  0,  0)
OPT_GLOBAL(OPT_SIGNATURE_FLAGS,     VT_UI4,   ROOT_REG,   c_szSigFlags,           FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NOPREVIEW,           VT_UI4,   ROOT_REG,   c_szNoPreview,          FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SAVEATTACH_PATH,     VT_LPSTR, ROOT_REG,   c_szSaveAttachPath,     NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOW_ENVELOPES,      VT_UI4,   ROOT_REG,   c_szShowEnvelopes,      FALSE,      0,          0,  0,  0)

OPT_GLOBAL(OPT_AUTO_ADD_SENDERS_CERT_TO_WAB, VT_UI4, ROOT_REG, c_szAutoAddSendersCertToWAB, TRUE, 0,      0,  0,  0)
OPT_GLOBAL(OPT_VIEWSOURCETABS,      VT_UI4,   ROOT_REG,   c_szViewSrcTabs,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_ENCRYPT_WARN_BITS,  VT_UI4, MAIL_REG, c_szEncryptWarnBits,    0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_SOURCE_EDIT_COLORING,VT_UI4,   ROOT_REG,   c_szSourceEditColoring, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MESSAGE_LIST_TIPS,   VT_UI4,   ROOT_REG,   c_szRegMsgListTips,     TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILNOTEADVREAD,     VT_UI4,   MAIL_REG,   c_szRegMailNoteAdvRead, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILNOTEADVSEND,     VT_UI4,   MAIL_REG,   c_szRegMailNoteAdvSend, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWOUTLOOKBAR,      VT_UI4,   ROOT_REG,   c_szRegShowOutlookBar,  FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NAVPANEWIDTH,        VT_UI4,   ROOT_REG,   c_szRegNavPaneWidth,    200,        0,          0,  0,  0)
OPT_GLOBAL(OPT_NAVPANESPLIT,        VT_UI4,   ROOT_REG,   c_szRegNavPaneSplit,    66,         0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWCONTACTS,        VT_UI4,   ROOT_REG,   c_szRegShowContacts,    TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_BACKGROUNDCOMPACT,   VT_UI4,   ROOT_REG,   c_szRegBackgroundCompact, TRUE,     0,          0,  0,  0)
OPT_GLOBAL(OPT_FILTERJUNK,          VT_UI4,   RULES_REG,  c_szRegFilterJunk,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_JUNKPCT,             VT_UI4,   RULES_REG,  c_szRegJunkPct,         2,          0,          0,  4,  0)
OPT_GLOBAL(OPT_DELETEJUNK,          VT_UI4,   RULES_REG,  c_szRegDeleteJunk,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DELETEJUNKDAYS,      VT_UI4,   RULES_REG,  c_szRegDeleteJunkDays,  7,          0,          1,  999,  0)
OPT_GLOBAL(OPT_FILTERADULT,         VT_UI4,   RULES_REG,  c_szRegFilterAdult,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_LOGHTTPMAIL,    VT_UI4,   MAIL_REG,   c_szRegLogHTTPMail,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_HTTPMAILLOGFILE,VT_LPSTR, MAIL_REG,   c_szRegHTTPMailLogFile, NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_BASORT,              VT_UI4,   ROOT_REG,   c_szBASort,             0,          0,          0,  999, 0)
OPT_GLOBAL(OPT_WATCHED_COLOR,       VT_UI4,   ROOT_REG,   c_szRegWatchedColor,   10,          0,          0,  16,  0)
OPT_GLOBAL(OPT_POLLFORMSGS_ATSTARTUP, VT_UI4, MAIL_REG,   c_szRegCheckMailOnStart, TRUE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_EXCEPTIONS_WAB,      VT_UI4,   RULES_REG,  c_szExceptionsWAB,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_BUDDYLIST_CHECK,     VT_UI4,   RULES_REG,  c_szBLAutoLogon,        TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_CANCEL_ALL_NEWS,     VT_UI4,   NEWS_REG,   c_szRegGodMode,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_REVOKE_CHECK,        VT_UI4,   ROOT_REG,   c_szRevokeCheck,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOW_DELETED,        VT_UI4,   ROOT_REG,   c_szShowDeleted,        TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SEARCH_BODIES,       VT_UI4,   ROOT_REG,   c_szRegSearchBodies,    FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SUBJECT_THREADING,   VT_UI4,   ROOT_REG,   c_szRegSubjectThreading,TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOW_REPLIES,        VT_UI4,   ROOT_REG,   c_szShowReplies,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_VIEW_GLOBAL,         VT_UI4,   RULES_REG,  c_szRegGlobalView,      RULEID_INVALID,         0,  0,  0,  0)
OPT_GLOBAL(OPT_MDN_SEND_REQUEST,    VT_UI4,   ROOT_REG,   c_szRequestMDN,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURE_READ_RECEIPT, VT_UI4,   ROOT_REG,   c_szSecureRequestMDN,   0,                      0,  0,  0,  0)
OPT_GLOBAL(OPT_MDN_SEND_RECEIPT,    VT_UI4,   ROOT_REG,   c_szSendMDN,            MDN_PROMPTFOR_SENDRECEIPT,  0,  0,  0,  0)
OPT_GLOBAL(OPT_TO_CC_LINE_RCPT,     VT_UI4,   ROOT_REG,   c_szSendReceiptToList,          TRUE,       0,          0,  0,  0)
#ifdef SMIME_V3
OPT_GLOBAL(OPT_USE_LABELS,          VT_UI4,   MAIL_REG,   c_szRegUseLabels,       FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_POLICYNAME_SIZE,     VT_UI4,   MAIL_REG,   c_szRegPolSize,         0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_POLICYNAME_DATA,     VT_BLOB,  MAIL_REG,   c_szRegPolData,         NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_HAS_CLASSIFICAT,     VT_UI4,   MAIL_REG,   c_szRegHasClass,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_CLASSIFICAT_DATA,    VT_UI4,   MAIL_REG,   c_szRegClassData,       0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_PRIVACYMARK_SIZE,    VT_UI4,   MAIL_REG,   c_szRegPrivSize,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_PRIVACYMARK_DATA,    VT_BLOB,  MAIL_REG,   c_szRegPrivData,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_CATEGORY_SIZE,       VT_UI4,   MAIL_REG,   c_szRegCategize,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_CATEGORY_DATA,       VT_BLOB,  MAIL_REG,   c_szRegCategData,       NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SECREC_USE,          VT_UI4,   MAIL_REG,   c_szRegUseSecRec,       FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECREC_VERIFY,       VT_UI4,   MAIL_REG,   c_szRegVerifySecRec,    FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MDN_SEC_RECEIPT,     VT_UI4,   MAIL_REG,   c_szSendSecMDN,         MDN_PROMPTFOR_SENDRECEIPT,  0,  0,  0,  0)
OPT_GLOBAL(OPT_SECREC_ENCRYPT,      VT_UI4,   MAIL_REG,   c_szRegEncryptSecRec,   FALSE,      0,          0,  0,  0)

#endif // SMIME_V3
OPT_GLOBAL(OPT_MAIL_STATIONERYNAMEW,VT_LPWSTR,MAIL_REG,   c_szRegStationeryNameW, NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_STATIONERYNAMEW,VT_LPWSTR,NEWS_REG,   c_szRegStationeryNameW, NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_STATCONVERTED,  VT_UI4,   MAIL_REG,   c_szRegStatNameConverted,  FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_STATCONVERTED,  VT_UI4,   NEWS_REG,   c_szRegStatNameConverted,  FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_RTL_MSG_DIR,         VT_UI4,   ROOT_REG,   c_szRegRtlMsgDir,       FALSE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILNOTEPOSEX,       VT_BLOB,  MAIL_REG,   c_szRegNotePosEx,       NULL,       0,          0,  0,  0)

OPT_GLOBAL(OPT_SECURITY_MAPI_SEND,  VT_UI4,   MAIL_REG,   c_szRegAppSend,         TRUE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITY_MAPI_SEND_LOCKED, VT_UI4, MAIL_REG, c_szRegAppSendLocked,    FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITY_ATTACHMENT, VT_UI4,   MAIL_REG,   c_szRegSafeAttachments,    TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITY_ATTACHMENT_LOCKED, VT_UI4, MAIL_REG, c_szRegSafeAttachmentsLocked, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_READ_IN_TEXT_ONLY,   VT_UI4,   ROOT_REG,   c_szRegSecReadPlainText, FALSE,     0,          0,  0,  0)
};
#endif // DEFINE_OPTION_STRUCTS

#ifndef OPTION_OFF

#define OPTION_OFF          0xffffffff

// signature option stuff
#define SIGTYPE_NONE            0
#define SIGTYPE_TEXT            1
#define SIGTYPE_FILE            2

#define SIGFLAG_AUTONEW         0x0001  // automatically add sig to new messages
#define SIGFLAG_AUTOREPLY       0x0002  // automatically add sig to reply/forward messages

enum
    {
    START_NO_CONNECT = 0,
    START_CONNECT,
    START_PROMPT
    };

enum
    {
    hybridNone = 0,
    hybridHoriz,
    hybridVert,
    hybridMax
    };

enum
    {
    AUTO_INLINE_OFF = 0,
    AUTO_INLINE_FLAT = 1,
    AUTO_INLINE_SLIDE = 2
    };

enum 
{
    DIAL_ALWAYS,
    DIAL_IF_NOT_OFFLINE,
    DO_NOT_DIAL
};

#define INDENTCHAR_NONE     0
#define DEF_INDENTCHAR      _T('>')
#define DEF_AUTOWRAP        76
#define AUTOWRAP_MIN        MIN_CBMAX_BODY_LINE
#define AUTOWRAP_MAX        132
#define DEF_NNTPPORT        119
#define DEF_SNEWSPORT       563
#define DEF_DOWNLOADCHUNKS  300
#define DEF_SECURITYZONE    URLZONE_UNTRUSTED
#define DEF_LOGMAIL         FALSE
#define AUTO_IMAGE_DELAY    2

#define MDN_SENDRECEIPT_AUTO        0x00000001
#define MDN_DONT_SENDRECEIPT        0x00000002
#define MDN_PROMPTFOR_SENDRECEIPT   0x00000004

class COptNotify : public IOptionBucketNotify
    {
    public:
        // ----------------------------------------------------------------------------
        // Construction
        // ----------------------------------------------------------------------------
        COptNotify(void);
        ~COptNotify(void);

        // -------------------------------------------------------------------
        // IUnknown Members
        // -------------------------------------------------------------------
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // -------------------------------------------------------------------
        // IOptionBucketNotify Members
        // -------------------------------------------------------------------
        STDMETHODIMP DoNotification(IOptionBucketEx *pBckt, HWND hwnd, PROPID id);

        // -------------------------------------------------------------------
        // COptNotify Members
        // -------------------------------------------------------------------
        HRESULT Register(HWND hwnd);
        HRESULT Unregister(HWND hwnd);

    private:
        LONG                m_cRef;
        int                 m_cHwnd;
        int                 m_cHwndBuf;
        HWND               *m_rgHwnd;
    };

#endif // OPTION_OFF

DWORD DwGetOption(PROPID id);
DWORD DwGetOptionDefault(PROPID id);
DWORD GetOption(PROPID id, void *pv, DWORD cb);
DWORD IDwGetOption(IOptionBucketEx *pOpt, PROPID id);
DWORD IDwGetOptionDefault(IOptionBucketEx *pOpt, PROPID id);
DWORD IGetOption(IOptionBucketEx *pOpt, PROPID id, void *pv, DWORD cb);

BOOL SetDwOption(PROPID id, DWORD dw, HWND hwnd, DWORD dwFlags);
BOOL SetOption(PROPID id, void *pv, DWORD cb, HWND hwnd, DWORD dwFlags);
BOOL ISetDwOption(IOptionBucketEx *pOpt, PROPID id, DWORD dw, HWND hwnd, DWORD dwFlags);
BOOL ISetOption(IOptionBucketEx *pOpt, PROPID id, void *pv, DWORD cb, HWND hwnd, DWORD dwFlags);

BOOL InitGlobalOptions(HKEY hkey, LPCSTR szRegOptRoot);
void DeInitGlobalOptions(void);

HRESULT OptionAdvise(HWND hwnd);
HRESULT OptionUnadvise(HWND hwnd);

LONG AthUserCreateKey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult, LPDWORD lpdwDisposition);
LONG AthUserOpenKey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult);
LONG AthUserDeleteKey(LPCSTR lpSubKey);
LONG AthUserGetValue(LPCSTR lpSubKey, LPCSTR lpValueName, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG AthUserSetValue(LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, CONST BYTE *lpData, DWORD cbData);
LONG AthUserDeleteValue(LPCSTR lpSubKey, LPCSTR lpValueName);

HKEY AthUserGetKeyRoot(void);
void AthUserGetKeyPath(LPSTR szKey, int cch);

#endif // _INC_GOPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\grplist2.cpp ===
#include "pch.hxx"
#include <iert.h>
#include <store.h>
#include "grplist2.h"
#include "resource.h"
#include "ourguid.h"
#include "thormsgs.h"
#include "goptions.h"
#include "strconst.h"
#include <inetcfg.h>
#include <fonts.h>
#include <columns.h>
#include <imagelst.h>
#include <instance.h>
#include <spoolui.h>
#include <options.h>
#include <acctutil.h>
#include <menuutil.h>
#include "storutil.h"
#include "xputil.h"
#include <browser.h>
#include "demand.h"
#include "menures.h"
#include "storecb.h"


ASSERTDATA

int __cdecl GroupListCompare(const void *lParam1, const void *lParam2);

void FreeChildren(SUBNODE *pNode)
{
    DWORD i;
    SUBNODE *pNodeT;

    Assert(pNode != NULL);
    
    if (pNode->pChildren != NULL)
    {
        for (i = 0, pNodeT = pNode->pChildren; i < pNode->cChildren; i++, pNodeT++)
        {
            FreeChildren(pNodeT);
        }

        MemFree(pNode->pChildren);
        pNode->pChildren = NULL;
        pNode->cChildren = 0;
    }

    if (pNode->pszName != NULL)
    {
        MemFree(pNode->pszName);
        pNode->pszName = NULL;
    }

    if (pNode->pszDescription != NULL)
    {
        MemFree(pNode->pszDescription);
        pNode->pszDescription = NULL;
    }
}

CGroupList::CGroupList()
{
    m_cRef = 1;
    m_hwndList = NULL;
    m_hwndHeader = NULL;
    m_himlFolders = NULL;
    m_himlState = NULL;

    m_pAdvise = NULL;
    m_pColumns = NULL;
    m_pEmptyList = NULL;

    m_csi = 0;
    m_csiBuf = 0;
    m_psi = NULL;
    m_psiCurr = NULL;

    m_cIndex = 0;
    m_cIndexBuf = 0;
    m_rgpIndex = NULL;

    m_pszSearch = NULL;
    m_filter = 0;
    m_fUseDesc = FALSE;
}

CGroupList::~CGroupList()
{
    DWORD i;
    SERVERINFO *psi;

    if (m_pszSearch != NULL)
        MemFree(m_pszSearch);
    
    if (m_rgpIndex != NULL)
        MemFree(m_rgpIndex);

    if (m_psi != NULL)
    {
        for (i = 0, psi = m_psi; i < m_csi; i++, psi++)
        {
            FreeChildren(&psi->root);
            if (psi->pszSearch != NULL)
                MemFree(psi->pszSearch);
        }

        MemFree(m_psi);
    }

    if (m_pEmptyList != NULL)
        delete m_pEmptyList;

    if (m_pColumns != NULL)
        m_pColumns->Release();
    
    if (m_himlFolders != NULL)
        ImageList_Destroy(m_himlFolders);
    if (m_himlState != NULL)
        ImageList_Destroy(m_himlState);
}

/////////////////////////////////////////////////////////////////////////
//
// OLE Interfaces
//

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CGroupList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IOleCommandTarget *)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (void*) (IOleCommandTarget *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CGroupList::AddRef()
{
    DOUT(TEXT("CGroupList::AddRef() - m_cRef = %d"), m_cRef + 1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CGroupList::Release()
{
    DOUT(TEXT("CGroupList::Release() - m_cRef = %d"), m_cRef - 1);
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

BOOL CGroupList::_IsSelectedFolder(DWORD dwFlags, BOOL fCondition, BOOL fAll, BOOL fIgnoreSpecial)
{
    HRESULT hr;
    DWORD iItem = -1;
    SUBNODE *pNode;

    while (-1 != (iItem = ListView_GetNextItem(m_hwndList, iItem, LVNI_SELECTED)))
    {
        pNode = NodeFromIndex(iItem);
        if (pNode == NULL)
            continue;

        if (fIgnoreSpecial && !!(pNode->flags & SN_SPECIAL))
            continue;

        if (fAll)
        {
            // If all must match and this one doesn't, then we can quit now.
            if (!(fCondition == !!(pNode->flags & dwFlags)))
                return (FALSE);
        }
        else
        {
            // If only one needs to match and this one does, then we can
            // quit now.
            if (fCondition == !!(pNode->flags & dwFlags))
                return (TRUE);
        }
    }

    // If the user wanted all to match, and we get here all did match.  If the
    // user wanted only one to match and we get here, then none matched and we
    // fail.
    return (fAll);
}

HRESULT CGroupList::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG i;
    int iSel, cSel, cItems;
    OLECMD *pcmd;
    SUBNODE *pNode;

    Assert(cCmds > 0);
    Assert(prgCmds != NULL);
    
    cSel = ListView_GetSelectedCount(m_hwndList);    
    cItems = ListView_GetItemCount(m_hwndList);
    iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);

    for (i = 0, pcmd = prgCmds; i < cCmds; i++, pcmd++)
    {
        if (pcmd->cmdf == 0)
        {
            switch (pcmd->cmdID)
            {
                case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
                case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
                case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
                case ID_UNMARK_RETRIEVE_FLD:
                    // TODO: should this be based on the first selection or all selected???
                    pcmd->cmdf = OLECMDF_SUPPORTED;
                    if (iSel != -1)
                    {
                        pNode = NodeFromIndex(iSel);
                        if (pNode && !!(pNode->flags & SN_SUBSCRIBED))
                        {
                            if ((pcmd->cmdID == ID_MARK_RETRIEVE_FLD_NEW_HDRS && !!(pNode->flags & SN_DOWNLOADHEADERS)) ||
                                (pcmd->cmdID == ID_MARK_RETRIEVE_FLD_NEW_MSGS && !!(pNode->flags & SN_DOWNLOADNEW)) ||
                                (pcmd->cmdID == ID_MARK_RETRIEVE_FLD_ALL_MSGS && !!(pNode->flags & SN_DOWNLOADALL)) ||
                                (pcmd->cmdID == ID_UNMARK_RETRIEVE_FLD && 0 == (pNode->flags & SN_SYNCMASK)))
                                pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_LATCHED;
                            else
                                pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        }
                    }
                    break;

                case ID_SUBSCRIBE:
                case ID_UNSUBSCRIBE:
                    if (_IsSelectedFolder(SN_SUBSCRIBED, pcmd->cmdID == ID_UNSUBSCRIBE, FALSE, TRUE))
                        pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                    break;

                case ID_SELECT_ALL:
                case ID_REFRESH:
                case ID_RESET_LIST:
                    pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
            }
        }
    }
    
    return(S_OK);
}
    
HRESULT CGroupList::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr;
    int iSel;
    BOOL fShow;
    
    hr = S_OK;
    
    switch (nCmdID)
    {
        case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
        case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
        case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
        case ID_UNMARK_RETRIEVE_FLD:
            MarkForDownload(nCmdID);
            break;

        case ID_SUBSCRIBE:
        case ID_UNSUBSCRIBE:
            Subscribe(nCmdID == ID_SUBSCRIBE);
            break;

        case ID_TOGGLE_SUBSCRIBE:
            Subscribe(TOGGLE);
            break;

        case ID_REFRESH:
        case ID_RESET_LIST:
            hr = DownloadList();
            hr = SwitchServer(TRUE);
            break;
        
        case ID_SELECT_ALL:
            ListView_SelectAll(m_hwndList);
            if (m_hwndList != GetFocus())
                SetFocus(m_hwndList);
            break;

        default:
            hr = S_FALSE;
            break;
    }
    
    return(hr);
}

HRESULT CGroupList::Initialize(IGroupListAdvise *pAdvise, CColumns *pColumns, HWND hwndList, FOLDERTYPE type)
{
    HRESULT hr;
    ULONG cServer;

    m_type = type;

    Assert(pAdvise != NULL);
    m_pAdvise = pAdvise; // don't AddRef or we'll have circular refcount

    Assert(pColumns != NULL);
    m_pColumns = pColumns;
    m_pColumns->AddRef();

    Assert(m_hwndList == NULL);
    m_hwndList = hwndList;

    m_hwndHeader = ListView_GetHeader(m_hwndList);
    Assert(m_hwndHeader != NULL);

    // Set the image lists for the listview
    Assert(m_himlFolders == NULL);
    m_himlFolders = InitImageList(16, 16, MAKEINTRESOURCE(idbFolders), cFolderIcon, RGB(255, 0, 255));
    Assert(m_himlFolders);
    ListView_SetImageList(m_hwndList, m_himlFolders, LVSIL_SMALL);
    
    Assert(m_himlState == NULL);
    m_himlState = InitImageList(16, 16, MAKEINTRESOURCE(idb16x16st), iiconStMax, RGB(255, 0, 255));
    Assert(m_himlState);
    ListView_SetImageList(m_hwndList, m_himlState, LVSIL_STATE);
    ListView_SetCallbackMask(m_hwndList, LVIS_STATEIMAGEMASK);       

    SetIntlFont(m_hwndList);

    Assert(g_pAcctMan != NULL);
    hr = g_pAcctMan->GetAccountCount(type == FOLDER_NEWS ? ACCT_NEWS : ACCT_MAIL, &cServer);
    if (FAILED(hr))
        return(hr);

    Assert(cServer > 0);
    if (!MemAlloc((void **)&m_psi, sizeof(SERVERINFO) * cServer))
    {
        return(E_OUTOFMEMORY);
    }
    else
    {
        ZeroMemory(m_psi, sizeof(SERVERINFO) * cServer);
        m_csiBuf = cServer;
    }

    m_pEmptyList = new CEmptyList;
    if (m_pEmptyList == NULL)
        return(E_OUTOFMEMORY);

    return(hr);
}

HRESULT CGroupList::HandleNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr, LRESULT *plres)
{
    HD_NOTIFY *phdn;
    int iSel;
    DWORD dwPos;
    UINT uChanged;
    FOLDERINFO info;
    LV_HITTESTINFO lvhti;
    SUBNODE *pNode;
    NM_LISTVIEW *pnmlv;
    LV_DISPINFO *pDispInfo;
    DWORD cColumns;
    NMCUSTOMDRAW *pnmcd;
    COLUMN_ID id;
    FOLDERID idFolder;
    COLUMN_SET *rgColumns;
    HRESULT hr;
    FNTSYSTYPE fntType;

    Assert(plres != NULL);
    *plres = 0;

    if (pnmhdr->hwndFrom != m_hwndList &&
        pnmhdr->hwndFrom != m_hwndHeader)
        return(S_FALSE);

    hr = S_OK;

    switch (pnmhdr->code)
    {
        case LVN_ITEMACTIVATE:
            // Tell our host to open the selected items
            iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
            if (iSel >= 0)
                m_pAdvise->ItemActivate(IdFromIndex(iSel));
            break;
        
        case LVN_GETDISPINFO:
            pDispInfo = (LV_DISPINFO *)pnmhdr;
            id = m_pColumns->GetId(pDispInfo->item.iSubItem);
        
            if ((DWORD)pDispInfo->item.iItem < m_cIndex)
                GetDisplayInfo(pDispInfo, id);
            break;
        
        case LVN_KEYDOWN:
            if (((LV_KEYDOWN *)pnmhdr)->wVKey == VK_SPACE)
            {
                Subscribe(TOGGLE);
            }
            break;
        
        case NM_CUSTOMDRAW:
            pnmcd = (NMCUSTOMDRAW *)pnmhdr;
        
            // If this is a prepaint notification, we tell the control we're interested
            // in further notfications.
            if (pnmcd->dwDrawStage == CDDS_PREPAINT)
            {
                *plres = CDRF_NOTIFYITEMDRAW;
                break;
            }
        
            // Do some extra work here to not show the selection on the priority or
            // attachment sub columns.
            // $REVIEW - Why?
            if ((pnmcd->dwDrawStage == CDDS_ITEMPREPAINT) || (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT | CDDS_SUBITEM)))
            {
                pNode = NodeFromIndex(pnmcd->dwItemSpec);
                if (pNode)
                {
                    Assert(0 == (pNode->flags & SN_HIDDEN));
                    if (!!(pNode->flags & SN_GRAYED))
                    {
                        LPNMLVCUSTOMDRAW(pnmcd)->clrText = GetSysColor(COLOR_GRAYTEXT);
                    }

                    *plres = CDRF_NOTIFYSUBITEMDRAW;
                }
                break;
            }
        
            *plres = CDRF_DODEFAULT;
            break;

        case LVN_ITEMCHANGED:
            pnmlv = (NM_LISTVIEW *)pnmhdr;
            if (!!(pnmlv->uChanged & LVIF_STATE) &&
                !!((LVIS_SELECTED | LVIS_FOCUSED) & (pnmlv->uOldState ^ pnmlv->uNewState)))
            {
                m_pAdvise->ItemUpdate();
            }
            break;
        
        case HDN_ENDTRACK:
            phdn = (HD_NOTIFY *)pnmhdr;
            m_pColumns->SetColumnWidth(phdn->iItem, phdn->pitem->cxy);
            break;
        
        case HDN_DIVIDERDBLCLICK:
            phdn = (HD_NOTIFY *)pnmhdr;
            // When the user double clicks on a header divider, we're supposed to
            // autosize that column.
            m_pColumns->SetColumnWidth(phdn->iItem, ListView_GetColumnWidth(m_hwndList, phdn->iItem));
            break;

        case LVN_ODFINDITEM:
            *plres = -1;
            break;

        default:
            hr = S_FALSE;
            break;
    }
    
    return(hr);
}

HRESULT CGroupList::SetServer(FOLDERID id)
{
    DWORD i;
    SERVERINFO *pinfo;
    HRESULT hr;
    BOOL fInit;

    Assert(id != FOLDERID_INVALID);
    Assert(m_csiBuf > 0);
    Assert(m_psi != NULL);

    if (m_psiCurr != NULL && id == m_psiCurr->root.id)
        return(S_OK);

    for (i = 0, pinfo = m_psi; i < m_csi; i++, pinfo++)
    {
        if (pinfo->root.id == id)
            break;
    }

    fInit = FALSE;

    if (i == m_csi)
    {
        // we haven't loaded this server yet
        Assert(m_csi < m_csiBuf);
        pinfo->root.id = id;
        Assert(pinfo->root.pChildren == NULL);
        Assert(pinfo->root.cChildren == 0);
        Assert(pinfo->pszSearch == NULL);
        Assert(pinfo->filter == 0);

        hr = InitializeServer(pinfo, NULL);
        if (FAILED(hr))
            return(hr);

        m_csi++;
        fInit = TRUE;
    }

#ifdef DEBUG
    if (m_psiCurr != NULL)
    {
        Assert((m_psiCurr->pszSearch == NULL && m_pszSearch == NULL) || 0 == lstrcmpi(m_psiCurr->pszSearch, m_pszSearch));
        Assert(m_psiCurr->filter == m_filter);
        Assert(m_psiCurr->fUseDesc == m_fUseDesc);
    }
#endif // DEBUG

    m_psiCurr = pinfo;

    if (fInit && m_psiCurr->root.cChildren == 0)
    {
        hr = DownloadList();
    }

    hr = SwitchServer(FALSE);

    return(hr);
}

HRESULT SaveSubscribeState(SUBNODE *pNode, SUBSTATEINFO *pInfo)
{
    HRESULT hr;
    DWORD i, cAlloc;
    SUBNODE *pNodeT;

    Assert(pNode != NULL);
    Assert(pInfo != NULL);

    hr = S_OK;

    for (i = 0, pNodeT = pNode->pChildren; i < pNode->cChildren; i++, pNodeT++)
    {
        if ((pNodeT->flags & SN_SUBSCRIBED) != (pNodeT->flagsOrig & SN_SUBSCRIBED))
        {
            if (pInfo->cState == pInfo->cStateBuf)
            {
                cAlloc = pInfo->cStateBuf + 256;
                if (!MemAlloc((void **)&pInfo->pState, cAlloc * sizeof(SUBSTATE)))
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                pInfo->cStateBuf = cAlloc;
            }

            pInfo->pState[pInfo->cState].id = pNodeT->id;
            pInfo->pState[pInfo->cState].fSub = !!(pNodeT->flags & SN_SUBSCRIBED);
            pInfo->cState++;
        }

        if (pNodeT->pChildren != NULL)
        {
            hr = SaveSubscribeState(pNodeT, pInfo);
            if (FAILED(hr))
                break;
        }
    }

    return(hr);
}

int GetSubscribeState(SUBSTATEINFO *pInfo, FOLDERID idFolder)
{
    DWORD i;
    SUBSTATE *pState;
    int iState = -1;

    Assert(pInfo != NULL);

    for (i = 0, pState = pInfo->pState; i < pInfo->cState; i++, pState++)
    {
        if (pState->id == idFolder)
        {
            iState = pState->fSub;
            break;
        }
    }

    return(iState);
}

HRESULT CGroupList::DownloadList()
{
    HRESULT hr;
    HWND hwnd;
    SUBSTATEINFO info = { 0 };

    Assert(m_psiCurr != NULL);

    m_psiCurr->fNewViewed = FALSE;

    if (m_psiCurr->fDirty && m_psiCurr->root.pChildren != NULL)
        SaveSubscribeState(&m_psiCurr->root, &info);

    DownloadNewsgroupList(m_hwndList, m_psiCurr->root.id);

    FreeChildren(&m_psiCurr->root);
    m_psiCurr->cChildrenTotal = 0;

    hr = InitializeServer(m_psiCurr, &info);

    if (info.pState != NULL)
        MemFree(info.pState);

    return(hr);
}

HRESULT CGroupList::Filter(LPCSTR pszSearch, DWORD tab, BOOL fUseDesc)
{
    HRESULT hr;
    DWORD dwFilter;

    Assert(((int) tab) >= SUB_TAB_ALL && tab <= SUB_TAB_NEW);

    switch (tab)
    {
        case SUB_TAB_ALL:
            dwFilter = 0;
            break;
        case SUB_TAB_SUBSCRIBED:
            dwFilter = SN_SUBSCRIBED;
            break;
        case SUB_TAB_NEW:
            dwFilter = SN_NEW;
            break;
    }

    hr = S_OK;

    if (m_pszSearch != NULL)
        MemFree(m_pszSearch);
    if (pszSearch != NULL)
        m_pszSearch = PszDup(pszSearch);
    else
        m_pszSearch = NULL;
    m_filter = dwFilter;
    m_fUseDesc = fUseDesc;

    if (m_psiCurr != NULL)
    {
        hr = SwitchServer(FALSE);
        Assert(SUCCEEDED(hr));
    }

    return(hr);
}

HRESULT CGroupList::HasDescriptions(BOOL *pfDesc)
{
    Assert(pfDesc != NULL);
    Assert(m_psiCurr != NULL);

    *pfDesc = m_psiCurr->fHasDesc;

    return(S_OK);
}

HRESULT CGroupList::SwitchServer(BOOL fForce)
{
    HRESULT hr;
    DWORD cSub;
    HCURSOR hcur;

    Assert(m_psiCurr != NULL);

    m_cIndex = 0;
    if (m_psiCurr->cChildrenTotal > m_cIndexBuf)
    {
        if (!MemRealloc((void **)&m_rgpIndex, m_psiCurr->cChildrenTotal * sizeof(SUBNODE *)))
            return(E_OUTOFMEMORY);
        m_cIndexBuf = m_psiCurr->cChildrenTotal;
#ifdef DEBUG
        ZeroMemory(m_rgpIndex, m_psiCurr->cChildrenTotal * sizeof(SUBNODE *));
#endif // DEBUG
    }

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Make sure the empty list window is hidden
    m_pEmptyList->Hide();

    // Turn off painting for the listview
    SetWindowRedraw(m_hwndList, FALSE);    

    if (m_filter == SN_NEW)
        m_psiCurr->fNewViewed = TRUE;

    hr = FilterServer(m_psiCurr, m_pszSearch, m_filter, m_fUseDesc, fForce);
    if (SUCCEEDED(hr))
    {
        cSub = 0;
        if (m_psiCurr->root.cChildren > 0)
            GetVisibleSubNodes(&m_psiCurr->root, m_rgpIndex, m_cIndexBuf, &cSub);

        m_cIndex = cSub;
    }

    ListView_SetItemCount(m_hwndList, m_cIndex);    
    if (m_cIndex > 0)
    {
        ListView_SetItemState(m_hwndList, -1, 0, LVIS_SELECTED | LVIS_FOCUSED);
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }

    if (m_cIndex == 0)
        m_pEmptyList->Show(m_hwndList, (LPSTR)idsEmptySubscriptionList);

    SetWindowRedraw(m_hwndList, TRUE);
    UpdateWindow(m_hwndList);

    SetCursor(hcur);

    return(hr);
}

HRESULT CommitChildren(SUBNODE *pParent, CStoreCB *pStoreCB)
{
    DWORD iNode;
    SUBNODE *pNode;
    HRESULT hr = S_OK;
    FOLDERINFO info;

    Assert(pParent != NULL);
    Assert(pParent->pChildren != NULL);
    Assert(pParent->cChildren > 0);

    for (iNode = 0, pNode = pParent->pChildren; iNode < pParent->cChildren; iNode++, pNode++)
    {
        if ((pNode->flags & SN_SUBSCRIBED) != (pNode->flagsOrig & SN_SUBSCRIBED))
        {
            if (pStoreCB != NULL)
                pStoreCB->Reset();

            hr = g_pStore->SubscribeToFolder(pNode->id, !!(pNode->flags & SN_SUBSCRIBED), pStoreCB);
            if (E_PENDING == hr)
            {
                Assert(pStoreCB != NULL);
                hr = pStoreCB->Block();
            }

            if (FAILED(hr))
                break;
        }

        if ((pNode->flags & SN_SYNCMASK) != (pNode->flagsOrig & SN_SYNCMASK))
        {
            hr = g_pStore->GetFolderInfo(pNode->id, &info);
            if (SUCCEEDED(hr))
            {
                info.dwFlags &= ~SN_SYNCMASK;
                info.dwFlags |= (SN_SYNCMASK & pNode->flags);

                hr = g_pStore->UpdateRecord(&info);
                Assert(SUCCEEDED(hr));

                g_pStore->FreeRecord(&info);
            }
        }

        pNode->flagsOrig = pNode->flags;    

        if (pNode->cChildren > 0)
        {
            hr = CommitChildren(pNode, pStoreCB);
            if (FAILED(hr))
                break;
        }
    }

    return(hr);
}

HRESULT CGroupList::Commit(HWND hwndSubscribeDlg)
{
    DWORD i;
    SERVERINFO *psi;
    HLOCK hLockNotify;
    HRESULT hr = S_OK;
    CStoreCB *pCB = NULL;

    if (m_type == FOLDER_IMAP)
    {
        pCB = new CStoreCB;
        if (pCB == NULL)
            return(E_OUTOFMEMORY);

        hr = pCB->Initialize(hwndSubscribeDlg, MAKEINTRESOURCE(idsUpdatingFolderList), FALSE);
    }

    if (SUCCEEDED(hr))
    {
        g_pStore->LockNotify(NOFLAGS, &hLockNotify);

        for (i = 0, psi = m_psi; (i < m_csi) && psi; i++, psi++)
        {
            if (psi->fNewViewed)
                _SetNewViewed(psi);

            if (psi->fDirty)
            {
                if (psi->root.cChildren > 0)
                {
                    Assert(psi->root.pChildren != NULL);
                    hr = CommitChildren(&psi->root, pCB);
                    
                    if (FAILED(hr))
                        break;
                }

                psi->fDirty = FALSE;
            }
        }

        g_pStore->UnlockNotify(&hLockNotify);

        if (pCB != NULL)
            pCB->Close();
    }

    if (pCB != NULL)
        pCB->Release();

    return(hr);
}

HRESULT CGroupList::_SetNewViewed(SERVERINFO *psi)
{
    FOLDERINFO info;
    HRESULT hr;
    DWORD iNode;
    SUBNODE *pNode;

    Assert(psi != NULL);

    if (SUCCEEDED(g_pStore->GetFolderInfo(psi->root.id, &info)))
    {
        if (!!(info.dwFlags & FOLDER_HASNEWGROUPS))
        {
            info.dwFlags &= ~FOLDER_HASNEWGROUPS;
            g_pStore->UpdateRecord(&info);
        }

        g_pStore->FreeRecord(&info);
    }

    for (iNode = 0, pNode = psi->root.pChildren; iNode < psi->root.cChildren; iNode++, pNode++)
    {
        if (!!(pNode->flags & SN_NEW))
        {
            hr = g_pStore->GetFolderInfo(pNode->id, &info);
            if (SUCCEEDED(hr))
            {
                if (!!(info.dwFlags & FOLDER_NEW))
                {
                    info.dwFlags &= ~FOLDER_NEW;

                    hr = g_pStore->UpdateRecord(&info);
                    Assert(SUCCEEDED(hr));
                }

                g_pStore->FreeRecord(&info);
            }
        }
    }

    return(S_OK);
}

HRESULT CGroupList::GetFocused(FOLDERID *pid)
{
    int iSel;
    HRESULT hr;

    Assert(pid != NULL);

    hr = S_FALSE;

    iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
    if (iSel >= 0)
    {
        *pid = IdFromIndex((DWORD)iSel);
        hr = S_OK;
    }

    return(hr);
}

HRESULT CGroupList::GetSelected(FOLDERID *pid, DWORD *pcid)
{
    int iSel, cSel;
    DWORD cid;

    Assert(pid != NULL);
    Assert(pcid != NULL);

    cid = *pcid;
    *pcid = 0;

    if (cid < ListView_GetSelectedCount(m_hwndList))
        return(E_FAIL);

    iSel = -1;
    while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
    {
        *pid = IdFromIndex((DWORD)iSel);
        pid++;
        (*pcid)++;
    }

    return(S_OK);
}

HRESULT CGroupList::GetSelectedCount(DWORD *pcid)
{
    Assert(pcid != NULL);

    *pcid = ListView_GetSelectedCount(m_hwndList);

    return(S_OK);
}

HRESULT CGroupList::Dirty()
{
    DWORD i;
    HRESULT hr;

    hr = S_FALSE;

    for (i = 0; i < m_csi; i++)
    {
        if (m_psi[i].fDirty || m_psi[i].fNewViewed)
        {
            hr = S_OK;
            break;
        }
    }

    return(hr);
}

#define GLIC_ROOT               0x0001

HRESULT CGroupList::InitializeServer(SERVERINFO *pinfo, SUBSTATEINFO *pInfo)
{
    HRESULT hr;
    FOLDERINFO info;
    DWORD cChildrenTotal;
    HCURSOR hcur;

    Assert(pinfo != NULL);
    Assert(pinfo->root.pChildren == NULL);
    Assert(pinfo->root.cChildren == 0);
    Assert(pinfo->cChildrenTotal == 0);

    pinfo->root.indent = (WORD)-1;
    pinfo->fHasDesc = FALSE;

    hr = g_pStore->GetFolderInfo(pinfo->root.id, &info);
    if (SUCCEEDED(hr))
    {
        pinfo->tyFolder = info.tyFolder;

        cChildrenTotal = 0;
        if (ISFLAGSET(info.dwFlags, FOLDER_HASCHILDREN))
        {
            hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            hr = InsertChildren(pinfo, &pinfo->root, &info, GLIC_ROOT, &cChildrenTotal, pInfo);
            if (SUCCEEDED(hr))
                pinfo->cChildrenTotal = cChildrenTotal;
            else
                FreeChildren(&pinfo->root);

            SetCursor(hcur);
        }

        g_pStore->FreeRecord(&info);
    }

    return(hr);
}

HRESULT CGroupList::InsertChildren(SERVERINFO *pinfo, SUBNODE *pParent, FOLDERINFO *pInfo, DWORD dwFlags, DWORD *pcChildrenTotal, SUBSTATEINFO *pState)
{
    FOLDERINFO info;
    HRESULT hr;
    int iSubState;
    WORD indent;
    ULONG cAlloc;
    DWORD iNode=0;
    SUBNODE *prgNode=NULL;
    IEnumerateFolders *pEnum;

    Assert(pParent != NULL);
    Assert(pParent->pChildren == NULL);
    Assert(pParent->cChildren == 0);
    Assert(pInfo != NULL);
    Assert(pcChildrenTotal != NULL);

    if (!!(dwFlags & GLIC_ROOT))
    {
        indent = 0;
        dwFlags &= ~GLIC_ROOT;
    }
    else
    {
        indent = pParent->indent + 1;
    }

    hr = g_pStore->EnumChildren(pInfo->idFolder, FALSE, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->Count(&cAlloc);
        if (SUCCEEDED(hr) && cAlloc > 0)
        {
            if (!MemAlloc((void **)&prgNode, cAlloc * sizeof(SUBNODE)))
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                ZeroMemory(prgNode, cAlloc * sizeof(SUBNODE));

                while (S_OK == pEnum->Next(1, &info, NULL))
                {
                    Assert(pParent->cChildren < cAlloc);

                    if (0 == (FOLDER_HIDDEN & info.dwFlags))
                    {
                        prgNode[iNode].id = info.idFolder;
                        prgNode[iNode].indent = indent;
                        prgNode[iNode].flags = (SN_FOLDERMASK & (WORD)(info.dwFlags));
                        prgNode[iNode].pszName = PszDup(info.pszName);
                        prgNode[iNode].tySpecial = info.tySpecial;
                        if (info.pszDescription != NULL)
                        {
                            prgNode[iNode].pszDescription = PszDup(info.pszDescription);
                            pinfo->fHasDesc = TRUE;
                        }

                        if (!!(info.dwFlags & FOLDER_NEW))
                            prgNode[iNode].flags |= SN_NEW;
                        if (info.tySpecial != FOLDER_NOTSPECIAL)
                            prgNode[iNode].flags |= SN_SPECIAL;

                        prgNode[iNode].flagsOrig = prgNode[iNode].flags;

                        if (pState != NULL)
                        {
                            iSubState = GetSubscribeState(pState, info.idFolder);
                            if (iSubState != -1)
                            {
                                if (!!iSubState)
                                    prgNode[iNode].flags |= SN_SUBSCRIBED;
                                else
                                    prgNode[iNode].flags &= ~SN_SUBSCRIBED;
                            }
                        }

                        if (ISFLAGSET(info.dwFlags, FOLDER_HASCHILDREN))
                        {
                            hr = InsertChildren(pinfo, &prgNode[iNode], &info, dwFlags, pcChildrenTotal, pState);
                            if (FAILED(hr))
                            {
                                g_pStore->FreeRecord(&info);
                                break;
                            }
                        }

                        iNode++;
                        pParent->cChildren++;
                        (*pcChildrenTotal)++;
                    }

                    g_pStore->FreeRecord(&info);
                }

                pParent->pChildren = prgNode;

                // sort the root level of mail folders so special folders are handled correctly
                if (pInfo->tyFolder != FOLDER_NEWS &&
                    !!(pInfo->dwFlags & FOLDER_SERVER) &&
                    pParent->cChildren > 0)
                {
                    qsort(pParent->pChildren, pParent->cChildren, sizeof(SUBNODE), GroupListCompare);
                }
            }
        }

        pEnum->Release();
    }

    return(hr);
}

HRESULT CGroupList::FilterServer(SERVERINFO *pinfo, LPCSTR pszSearch, DWORD filter, BOOL fUseDesc, BOOL fForce)
{
    HRESULT hr;
    BOOL fVis, fStricter, fSame;

    Assert(pinfo != NULL);

    hr = S_OK;
    fStricter = TRUE;
    fSame = TRUE;

    if (pszSearch == NULL)
    {
        if (pinfo->pszSearch != NULL)
        {
            MemFree(pinfo->pszSearch);
            pinfo->pszSearch = NULL;

            fStricter = FALSE;
            fSame = FALSE;
        }
    }
    else
    {
        if (pinfo->pszSearch != NULL)
        {
            if (0 != lstrcmpi(pinfo->pszSearch, pszSearch))
            {
                fSame = FALSE;

                if (NULL == StrStrI(pszSearch, pinfo->pszSearch))
                    fStricter = FALSE;
            }

            MemFree(pinfo->pszSearch);
        }
        else
        {
            fSame = FALSE;
        }

        pinfo->pszSearch = PszDup(pszSearch);
    }

    if (pinfo->filter != filter)
    {
        fSame = FALSE;
        fStricter = (fStricter && pinfo->filter == 0);
        pinfo->filter = filter;
    }

    if (pinfo->fUseDesc != fUseDesc)
    {
        fSame = FALSE;
        fStricter = (fStricter && pinfo->fUseDesc);
        pinfo->fUseDesc = fUseDesc;
    }

    if (fForce)
    {
        fSame = FALSE;
        fStricter = FALSE;
    }

    if (fSame && pinfo->fFiltered)
        return(S_OK);

    if (pinfo->root.cChildren > 0)
    {
        Assert(pinfo->root.pChildren != NULL);
        hr = FilterChildren(pinfo, &pinfo->root, fStricter, &fVis);
    }

    if (hr == S_OK)
        pinfo->fFiltered = TRUE;

    return(hr);
}

inline BOOL SubstringSearch(LPCSTR pszTarget, LPCSTR pszSearch)
{
    LPCSTR pszT = pszTarget;
    LPCSTR pszS = pszSearch;
    
    while (*pszT !=0 && *pszS != 0)
    {
        if (*pszT != *pszS && 
            (char)CharLower((LPSTR)IntToPtr(MAKELONG((BYTE)*pszT, 0))) != *pszS)
        {
            pszT -= (pszS - pszSearch);
            pszS = pszSearch;
        }
        else    
        {
            pszS++;
        }
        pszT++;
    }    
    
    return (*pszS == 0);    
}

HRESULT CGroupList::FilterChildren(SERVERINFO *pinfo, SUBNODE *pParent, BOOL fStricter, BOOL *pfChildVisible)
{
    LPSTR pszT, pszTok, pszToken;
    FOLDERINFO info;
    HRESULT hr;
    SUBNODE *pNode;
    BOOL fMatch, fVis;
    DWORD i;

    Assert(pinfo != NULL);
    Assert(pParent != NULL);
    Assert(pParent->pChildren != NULL);
    Assert(pParent->cChildren > 0);
    Assert(pfChildVisible != NULL);
    
    *pfChildVisible = FALSE;
    hr = S_OK;

    // TODO: we should cache this so we don't allocate it multiple times for IMAP
    pszT = NULL;
    DWORD cchSize = 0;

    if (pinfo->pszSearch != NULL)
    {
        cchSize = (lstrlen(pinfo->pszSearch) + 1);
        if (!MemAlloc((void **)&pszT, cchSize))
            return(E_OUTOFMEMORY);
    }

    for (i = 0, pNode = pParent->pChildren; i < pParent->cChildren; i++, pNode++)
    {
        if (fStricter && !!(pNode->flags & SN_HIDDEN))
        {
            // if our search criteria is stricter and it was hidden before,
            // we don't need to waste time with it again because it is
            // still going to be hidden

            continue;
        }

        pNode->flags |= SN_HIDDEN;
        pNode->flags &= ~(SN_CHILDVIS | SN_GRAYED);

        if (pinfo->filter == 0)
            fMatch = TRUE;
        else
            fMatch = !!(pNode->flags & pinfo->filter);

        if (fMatch && pinfo->pszSearch != NULL)
        {
            StrCpyN(pszT, pinfo->pszSearch, cchSize);
            pszTok = pszT;
            pszToken = StrTokEx(&pszTok, c_szDelimiters);
            while (NULL != pszToken)
            {
                if (!SubstringSearch(pNode->pszName, pszToken) &&
                    (pNode->pszDescription == NULL || !SubstringSearch(pNode->pszDescription, pszToken)))
                {
                    fMatch = FALSE;
                    break;
                }

                pszToken = StrTokEx(&pszTok, c_szDelimiters);
            }
        }

        if (fMatch)
        {
            *pfChildVisible = TRUE;
            pNode->flags &= ~SN_HIDDEN;
        }
        else if (pNode->cChildren > 0)
        {
            pNode->flags |= SN_GRAYED;
        }

        if (pNode->cChildren > 0)
        {
            Assert(pNode->pChildren != NULL);

            hr = FilterChildren(pinfo, pNode, fStricter, &fVis);
            if (FAILED(hr))
                break;

            if (fVis)
            {
                *pfChildVisible = TRUE;
                pNode->flags &= ~SN_HIDDEN;
                pNode->flags |= SN_CHILDVIS;
            }
        }
    }

    if (pszT != NULL)
        MemFree(pszT);

    return(hr);
}

HRESULT CGroupList::GetDisplayInfo(LV_DISPINFO *pDispInfo, COLUMN_ID id)
{
    SUBNODE *pNode;
    int count;
    FOLDERINFO info;
    HRESULT hr;
    
    pNode = NodeFromIndex((DWORD)pDispInfo->item.iItem);
    if (NULL == pNode)
        return (S_OK);
    
    if (!!(pDispInfo->item.mask & LVIF_TEXT))
    {
        if (id == COLUMN_NEWSGROUP || id == COLUMN_FOLDER)
        {
            StrCpyN(pDispInfo->item.pszText, pNode->pszName, pDispInfo->item.cchTextMax);
        }
        else if (id == COLUMN_DOWNLOAD)
        {
            if (!!(pNode->flags & SN_SUBSCRIBED) && !!(pNode->flags & SN_SYNCMASK))
            {
                if (!!(pNode->flags & SN_DOWNLOADALL))
                    AthLoadString(idsAllMessages, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
                else if (!!(pNode->flags & SN_DOWNLOADNEW))
                    AthLoadString(idsNewMessages, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
                else if (!!(pNode->flags & SN_DOWNLOADHEADERS))
                    AthLoadString(idsNewHeaders, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
            }
        }
        else if (id == COLUMN_TOTAL || id == COLUMN_UNREAD)
        {
            hr = g_pStore->GetFolderInfo(pNode->id, &info);
            if (SUCCEEDED(hr))
            {
                if (id == COLUMN_UNREAD)
                    count = info.cUnread;
                else
                    count = info.cMessages;

                if (count < 0)
                    count = 0;
                wnsprintf(pDispInfo->item.pszText, pDispInfo->item.cchTextMax, "%d", count);

                g_pStore->FreeRecord(&info);
            }
        }
        else if (id == COLUMN_DESCRIPTION)
        {
            if (pNode->pszDescription != NULL)
                StrCpyN(pDispInfo->item.pszText, pNode->pszDescription, pDispInfo->item.cchTextMax);
        }
    }
    
    if (!!(pDispInfo->item.mask & LVIF_IMAGE))
    {
        if (id == COLUMN_NEWSGROUP)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(pNode->flags & SN_SUBSCRIBED))
            {
                pDispInfo->item.iImage = iNewsGroup;
            }
        }
        else if (COLUMN_FOLDER == id)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(pNode->flags & SN_SUBSCRIBED))
            {
                hr = g_pStore->GetFolderInfo(pNode->id, &info);
                if (SUCCEEDED(hr))
                {
                    if (info.tySpecial == FOLDER_NOTSPECIAL)
                        pDispInfo->item.iImage = iFolderClosed;
                    else
                        pDispInfo->item.iImage = (iInbox + (info.tySpecial - 1));

                    g_pStore->FreeRecord(&info);
                }
            }
        }
    }
    
    if (!!(pDispInfo->item.mask & LVIF_STATE))
    {
        if (id == COLUMN_NEWSGROUP)
        {
            if (!!(pNode->flags & SN_NEW))
                pDispInfo->item.state = INDEXTOSTATEIMAGEMASK(iiconStateNew + 1);
        }
    }
    
    if (!!(pDispInfo->item.mask & LVIF_INDENT))
    {
        if (COLUMN_FOLDER == id)
            pDispInfo->item.iIndent = pNode->indent;
    }

    return(S_OK);    
}
    
HRESULT CGroupList::Subscribe(BOOL fSubscribe)
{
    BOOL fDirty;
    FOLDERINFO info;
    FOLDERID id;
    SUBNODE *pNode;
    int iSel;
    HRESULT hr;
    HCURSOR hcur;
    
    if (fSubscribe == TOGGLE)
    {
        iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
        if (iSel == -1)
            return(S_OK);
        
        pNode = NodeFromIndex(iSel);

        fSubscribe = (pNode && (0 == (pNode->flags & SN_SUBSCRIBED)));
    }
    
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    fDirty = FALSE;
    iSel = -1;
    while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
    {
        pNode = NodeFromIndex(iSel);
        
        if (pNode && 0 == (pNode->flags & SN_SPECIAL) &&
            fSubscribe ^ !!(pNode->flags & SN_SUBSCRIBED))
        {
            pNode->flags ^= SN_SUBSCRIBED;
            pNode->flags &= ~SN_SYNCMASK;
            
            fDirty = TRUE;

            ListView_RedrawItems(m_hwndList, iSel, iSel);
        }
    }
    
    if (fDirty)
    {
        m_psiCurr->fDirty = TRUE;

        m_pAdvise->ItemUpdate();
    }

    SetCursor(hcur);
    
    return(S_OK);
}

void CGroupList::GetVisibleSubNodes(SUBNODE *pParent, SUBNODE **rgpIndex, DWORD cIndex, DWORD *pdwSub)
{
    DWORD i;
    SUBNODE *pNode;

    Assert(pParent != NULL);
    Assert(pParent->pChildren != NULL);
    Assert(pParent->cChildren > 0);
    Assert(pdwSub != NULL);

    for (i = 0, pNode = pParent->pChildren; i < pParent->cChildren; i++, pNode++)
    {
#ifdef DEBUG
        // a node can't have visible children unless it has kids
        if (!!(pNode->flags & SN_CHILDVIS))
            Assert(pNode->cChildren > 0);
        // a node can't be grayed unless it has kids
        if (!!(pNode->flags & SN_GRAYED))
            Assert(pNode->cChildren > 0);
#endif // DEBUG

        if (0 == (pNode->flags & SN_HIDDEN))
        {
            if (rgpIndex != NULL)
            {
                Assert(*pdwSub < cIndex);
                rgpIndex[*pdwSub] = pNode;
            }
            (*pdwSub)++;

            if (pNode->cChildren > 0)
                GetVisibleSubNodes(pNode, rgpIndex, cIndex, pdwSub);
        }
    }
}

HRESULT CGroupList::MarkForDownload(DWORD nCmdID)
{
    BOOL fDirty;
    FOLDERINFO info;
    SUBNODE *pNode;
    int iSel;
    HRESULT hr;
    HCURSOR hcur;
    WORD flag;
    
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    switch (nCmdID)
    {
        case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
            flag = SN_DOWNLOADHEADERS;
            break;

        case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
            flag = SN_DOWNLOADNEW;
            break;

        case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
            flag = SN_DOWNLOADALL;
            break;

        case ID_UNMARK_RETRIEVE_FLD:
            flag = 0;
            break;

        default:
            Assert(FALSE);
            break;
    }

    fDirty = FALSE;
    iSel = -1;
    while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
    {
        pNode = NodeFromIndex(iSel);
        
        if (pNode && !!(pNode->flags & SN_SUBSCRIBED) &&
            (pNode->flags & SN_SYNCMASK) != flag)
        {
            pNode->flags &= ~SN_SYNCMASK;
            pNode->flags |= flag;

            fDirty = TRUE;

            ListView_RedrawItems(m_hwndList, iSel, iSel);
        }
    }
    
    if (fDirty)
    {
        m_psiCurr->fDirty = TRUE;

        m_pAdvise->ItemUpdate();
    }

    SetCursor(hcur);
    
    return(S_OK);
}

int __cdecl GroupListCompare(const void *lParam1, const void *lParam2) 
{
    int cmp;

    Assert(lParam1 != NULL);
    Assert(lParam2 != NULL);

    if (((SUBNODE *)lParam1)->tySpecial != FOLDER_NOTSPECIAL)
    {
        if (((SUBNODE *)lParam2)->tySpecial != FOLDER_NOTSPECIAL)
            cmp = ((SUBNODE *)lParam1)->tySpecial - ((SUBNODE *)lParam2)->tySpecial;
        else
            cmp = -1;
    }
    else
    {
        if (((SUBNODE *)lParam2)->tySpecial != FOLDER_NOTSPECIAL)
            cmp = 1;
        else
            cmp = lstrcmpi(((SUBNODE *)lParam1)->pszName, ((SUBNODE *)lParam2)->pszName);
    }

    return(cmp);
}

class CGroupListCB : public IStoreCallback, ITimeoutCallback
{
    public:
        // IUnknown 
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        ULONG   STDMETHODCALLTYPE AddRef(void);
        ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        virtual HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        CGroupListCB();
        ~CGroupListCB();

        HRESULT Initialize(FOLDERID id);
        HRESULT GetResult(void) { return(m_hr); }
        
        static INT_PTR CALLBACK CGroupListCB::DownloadGroupsDlg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    private:
        ULONG       m_cRef;
        HRESULT     m_hr;
        FOLDERID    m_id;
        FOLDERTYPE  m_tyFolder;
        HWND        m_hwnd;
        LPSTR       m_pszAcct;
        BOOL        m_fCancel;
        HTIMEOUT    m_hTimeout;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;
        BOOL        m_fDescriptions;
};

INT_PTR CALLBACK CGroupListCB::DownloadGroupsDlg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT         hr;
    CGroupListCB   *pThis = (CGroupListCB *)GetWindowLongPtr(hwnd, DWLP_USER);
    char            szBuffer[CCHMAX_STRINGRES], szRes[CCHMAX_STRINGRES];
        
    switch (uMsg)
        {
        case WM_INITDIALOG:
            Assert(lParam);
            pThis = (CGroupListCB *)lParam;

            pThis->m_hwnd = hwnd;
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            // Center the dialog over the parent window
            CenterDialog(hwnd);

            Assert(pThis->m_tyFolder == FOLDER_HTTPMAIL || pThis->m_tyFolder == FOLDER_NEWS || pThis->m_tyFolder == FOLDER_IMAP);
            if (pThis->m_tyFolder != FOLDER_NEWS)
            {
                AthLoadString(idsDownloadFoldersTitle, szRes, ARRAYSIZE(szRes));
                SetWindowText(hwnd, szRes);

                AthLoadString(idsDownloadFoldersText, szRes, ARRAYSIZE(szRes));
                SetDlgItemText(hwnd, idcStatic1, szRes);
            }

            // Set the progress text to contain the server name
            Assert(pThis->m_pszAcct);
            GetWindowText(hwnd, szBuffer, ARRAYSIZE(szBuffer));
            wnsprintf(szRes, ARRAYSIZE(szRes), szBuffer, pThis->m_pszAcct);
            SetWindowText(hwnd, szRes);

            // Open and start the animation
            Animate_OpenEx(GetDlgItem(hwnd, idcAnimation), g_hLocRes, idanCopyMsgs);
            Animate_Play(GetDlgItem(hwnd, idcAnimation), 0, -1, -1);

            hr = g_pStore->Synchronize(pThis->m_id,
                    pThis->m_fDescriptions ? (SYNC_STORE_GET_DESCRIPTIONS | SYNC_STORE_REFRESH) : SYNC_STORE_REFRESH,
                    (IStoreCallback *)pThis);
            Assert(!SUCCEEDED(hr));
            if (hr == E_PENDING)
                EnableWindow(GetDlgItem(hwnd, IDCANCEL), FALSE);
            else
                EndDialog(hwnd, 0);
            return(TRUE);

        case WM_COMMAND:
            Assert(pThis != NULL);

            if (LOWORD(wParam) == IDCANCEL && HIWORD(wParam) == BN_CLICKED)
                {
                if (pThis->m_pCancel != NULL)
                    pThis->m_pCancel->Cancel(CT_CANCEL);

                return(TRUE);
                }
            break;
            
        case WM_STORE_COMPLETE:
            EndDialog(hwnd, 0);
            break;

        case WM_DESTROY:
            Assert(pThis != NULL);
            break;
        }
    
    return(0);    
    }

HRESULT DownloadNewsgroupList(HWND hwnd, FOLDERID id)
{
    HRESULT hr;
    CGroupListCB *pCB;

    pCB = new CGroupListCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(id);
    if (SUCCEEDED(hr))
    {
        DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddDownloadGroups), hwnd, CGroupListCB::DownloadGroupsDlg, (LPARAM)pCB);

        hr = pCB->GetResult();
    }

    pCB->Release();

    return(hr);
}

CGroupListCB::CGroupListCB()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwnd = NULL;
    m_pszAcct = NULL;
    m_fCancel = FALSE;
    m_hTimeout = NULL;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_fDescriptions = FALSE;
}

CGroupListCB::~CGroupListCB()
{
    CallbackCloseTimeout(&m_hTimeout);

    if (m_pszAcct != NULL)
        MemFree(m_pszAcct);
    if (m_pCancel != NULL)
        m_pCancel->Release();
}

HRESULT STDMETHODCALLTYPE CGroupListCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CGroupListCB::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CGroupListCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CGroupListCB::Initialize(FOLDERID id)
{
    HRESULT hr;
    FOLDERINFO info;
    DWORD dw;
    IImnAccount *pAcct;

    m_id = id;

    hr = g_pStore->GetFolderInfo(id, &info);
    if (SUCCEEDED(hr))
    {
        Assert(!!(info.dwFlags & FOLDER_SERVER));
        Assert(info.pszAccountId != NULL);

        m_pszAcct = PszDup(info.pszName);
        if (m_pszAcct == NULL)
            hr = E_OUTOFMEMORY;

        m_tyFolder = info.tyFolder;

        if (m_tyFolder == FOLDER_NEWS)
        {
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, info.pszAccountId, &pAcct)))
            {
                if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_USE_DESCRIPTIONS, &dw)))
                    m_fDescriptions = (BOOL)dw;

                pAcct->Release();
            }
        }

        g_pStore->FreeRecord(&info);
    }

    return(hr);
}

HRESULT CGroupListCB::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(m_pCancel == NULL);
    Assert(m_type == SOT_INVALID);

    m_type = tyOperation;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    EnableWindow(GetDlgItem(m_hwnd, IDCANCEL), TRUE);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    CHAR szRes[255];
    CHAR szBuffer[255];

    CallbackCloseTimeout(&m_hTimeout);

    if (SOT_CONNECTION_STATUS == tyOperation)
    {
        AthLoadString(XPUtil_StatusToString((IXPSTATUS)dwCurrent), szRes, ARRAYSIZE(szRes));
        SetDlgItemText(m_hwnd, idcProgText, szRes);
    }

    else if (SOT_SYNCING_STORE == tyOperation)
    {
        AthLoadString(m_tyFolder == FOLDER_NEWS ? idsDownloadingGroups : idsDownloadingImapFldrs, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szRes, dwCurrent);
        SetDlgItemText(m_hwnd, idcProgText, szBuffer);
    }
    else if (SOT_SYNCING_DESCRIPTIONS == tyOperation)
    {
        AthLoadString(idsDownloadingDesc, szRes, ARRAYSIZE(szRes));
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szRes, dwCurrent);
        SetDlgItemText(m_hwnd, idcProgText, szBuffer);
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND    hwndParent;
    DWORD   dwReserved = 0;

    GetParentWindow(dwReserved, &hwndParent);

    return CallbackCanConnect(pszAccountId, hwndParent,
        (dwFlags & CC_FLAG_DONTPROMPT) ? FALSE : TRUE);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    CallbackCloseTimeout(&m_hTimeout);
    return CallbackOnLogonPrompt(m_hwnd, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    m_hr = hrComplete;

    CallbackCloseTimeout(&m_hTimeout);

    if (FAILED(hrComplete))
        CallbackDisplayError(m_hwnd, hrComplete, pErrorInfo);

    if (m_type != tyOperation)
        return(S_OK);

    Assert(m_hwnd != NULL);
    PostMessage(m_hwnd, WM_STORE_COMPLETE, 0, 0);

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }
    
    m_type = SOT_INVALID;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    CallbackCloseTimeout(&m_hTimeout);
    return CallbackOnPrompt(m_hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwnd != NULL);

    *phwndParent = m_hwnd;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Close my timeout
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\grplist2.h ===
#ifndef _INC_GRPLIST2_H
#define _INC_GRPLIST2_H

#include <columns.h>

#define idcAnimation 1001
#define idcProgText  1002

class CColumns;
class CEmptyList;
class CStoreDlgCB;

enum
    {
    SUB_TAB_ALL = 0,
    SUB_TAB_SUBSCRIBED,
    SUB_TAB_NEW
    };

// used for ISubscriptionManager::Subscribe( )
#define TOGGLE  ((BOOL)-1)

// SUBNODE dwFlags
#define SN_SUBSCRIBED       0x0001  // same as FOLDER_SUBSCRIBED
#define SN_CHILDVIS         0x0002  // display prop only
#define SN_GRAYED           0x0004  // display prop only
#define SN_HIDDEN           0x0008  // display prop only
#define SN_NEW              0x0010
#define SN_SPECIAL          0x0020
#define SN_DOWNLOADHEADERS  0x0800  // same as FOLDER_DOWNLOADHEADERS
#define SN_DOWNLOADNEW      0x1000  // same as FOLDER_DOWNLOADNEW
#define SN_DOWNLOADALL      0x2000  // same as FOLDER_DOWNLOADALL

#define SN_FOLDERMASK       (SN_SUBSCRIBED | SN_DOWNLOADHEADERS | SN_DOWNLOADNEW | SN_DOWNLOADALL)
#define SN_SYNCMASK         (SN_DOWNLOADHEADERS | SN_DOWNLOADNEW | SN_DOWNLOADALL)

typedef struct tagSUBNODE
{
    FOLDERID    id;
    WORD        indent;
    WORD        flags;
    WORD        flagsOrig;
    LPSTR       pszName;
    LPSTR       pszDescription;
    WORD        tySpecial;
    
    struct tagSUBNODE *pChildren;
    DWORD       cChildren;
} SUBNODE;

typedef struct tagSERVERINFO
{
    BOOL        fFiltered;
    BOOL        fDirty;
    LPSTR       pszSearch;
    DWORD       filter;
    BOOL        fUseDesc;
    BOOL        fHasDesc;
    FOLDERTYPE  tyFolder;
    BOOL        fNewViewed;

    DWORD       cChildrenTotal;
    SUBNODE     root;
} SERVERINFO;

typedef struct tagSUBSTATE
{
    FOLDERID id;
    BOOL fSub;
} SUBSTATE;

typedef struct SUBSTATEINFO
{
    DWORD cState;
    DWORD cStateBuf;
    SUBSTATE *pState;
} SUBSTATEINFO;

interface IGroupListAdvise : public IUnknown
{
public:    
    virtual HRESULT STDMETHODCALLTYPE ItemUpdate(void) = 0;
    virtual HRESULT STDMETHODCALLTYPE ItemActivate(FOLDERID id) = 0;
};

class CGroupList : public IOleCommandTarget
    {
    public:
        /////////////////////////////////////////////////////////////////////////
        //
        // OLE Interfaces
        //
    
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IOleCommandTarget
        HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                       OLECMDTEXT *pCmdText); 
        HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                                       VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

        // CGroupList
        HRESULT STDMETHODCALLTYPE Initialize(IGroupListAdvise *pAdvise, CColumns *pColumns, HWND hwndList, FOLDERTYPE type);
        HRESULT STDMETHODCALLTYPE HandleNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr, LRESULT *plResult);
        HRESULT STDMETHODCALLTYPE SetServer(FOLDERID id);
        HRESULT STDMETHODCALLTYPE Filter(LPCSTR pszSearch, DWORD tab, BOOL fUseDescription);
        HRESULT STDMETHODCALLTYPE Commit(HWND hwndSubscribeDlg);
        HRESULT STDMETHODCALLTYPE GetFocused(FOLDERID *pid);
        HRESULT STDMETHODCALLTYPE GetSelected(FOLDERID *pid, DWORD *pcid);
        HRESULT STDMETHODCALLTYPE GetSelectedCount(DWORD *pcid);
        HRESULT STDMETHODCALLTYPE Dirty(void);
        HRESULT STDMETHODCALLTYPE HasDescriptions(BOOL *pfDesc);

        /////////////////////////////////////////////////////////////////////////
        //
        // Constructors, Destructors, and Initialization
        //
        CGroupList();
        virtual ~CGroupList();
        
    private:
        inline SUBNODE *NodeFromIndex(DWORD_PTR index)
        {
            Assert(index < m_cIndex);
            if (index < m_cIndex)
            {
                Assert(m_rgpIndex[index] != NULL);
                return(m_rgpIndex[index]);
            }
            return (NULL);
        }

        inline FOLDERID IdFromIndex(DWORD index)
        {
            SUBNODE *pnode;
            pnode = NodeFromIndex(index);
            return(pnode->id);
        }

        HRESULT InitializeServer(SERVERINFO *pinfo, SUBSTATEINFO *pInfo);
        HRESULT FilterServer(SERVERINFO *pinfo, LPCSTR pszSearch, DWORD tab, BOOL fUseDesc, BOOL fForce);
        HRESULT InsertChildren(SERVERINFO *pinfo, SUBNODE *pParent, FOLDERINFO *pInfo, DWORD dwFlags, DWORD *pcChildrenTotal, SUBSTATEINFO *pState);
        HRESULT FilterChildren(SERVERINFO *pinfo, SUBNODE *pNode, BOOL fStricter, BOOL *pfChildVisible);
        HRESULT SwitchServer(BOOL fForce);
        HRESULT DownloadList(void);

        HRESULT Subscribe(BOOL fSubscribe);
        HRESULT MarkForDownload(DWORD nCmdID);

        HRESULT GetDisplayInfo(LV_DISPINFO *pDispInfo, COLUMN_ID id);
        void    GetVisibleSubNodes(SUBNODE *pNode, SUBNODE **rgpIndex, DWORD cIndex, DWORD *pdwSub);

        HRESULT _SetNewViewed(SERVERINFO *psi);
        BOOL    _IsSelectedFolder(DWORD dwFlags, BOOL fCondition, BOOL fAll, BOOL fIgnoreSpecial);

    private:
        UINT                m_cRef;
        HWND                m_hwndList;
        HWND                m_hwndHeader;
        HIMAGELIST          m_himlFolders;
        HIMAGELIST          m_himlState;

        IGroupListAdvise   *m_pAdvise;
        CColumns           *m_pColumns;
        CEmptyList         *m_pEmptyList;

        FOLDERTYPE          m_type;
        DWORD               m_csi;
        DWORD               m_csiBuf;
        SERVERINFO         *m_psi;
        SERVERINFO         *m_psiCurr;

        DWORD               m_cIndex;
        DWORD               m_cIndexBuf;
        SUBNODE           **m_rgpIndex;

        LPSTR               m_pszSearch;
        DWORD               m_filter;
        BOOL                m_fUseDesc;
    };

HRESULT DownloadNewsgroupList(HWND hwnd, FOLDERID id);

#endif // _INC_GRPLIST2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\hotlinks.cpp ===
// =================================================================================
// L I N K S . C P P
// =================================================================================
#include "pch.hxx"
#include "resource.h"
#include "hotlinks.h"
#include "error.h"
#include "xpcomm.h"
#include "goptions.h"
#include "strconst.h"
#include <shlwapi.h>

// =================================================================================
// Globals
// =================================================================================
static COLORREF g_crLink = RGB(0,0,128);
static COLORREF g_crLinkVisited = RGB(128,0,0);


// =================================================================================
// ParseLinkColorFromSz
// =================================================================================
VOID ParseLinkColorFromSz(LPTSTR lpszLinkColor, LPCOLORREF pcr)
{
    // Locals
    ULONG           iString = 0;
    TCHAR           chToken,
                    szColor[5];
    DWORD           dwR,
                    dwG,
                    dwB;

    // Red
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T(','))
        goto exit;
    dwR = StrToInt(szColor);

    // Green
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T(','))
        goto exit;
    dwG = StrToInt(szColor);

    // Blue
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T('\0'))
        goto exit;
    dwB = StrToInt(szColor);

    // Create color
    *pcr = RGB(dwR, dwG, dwB);

exit:
    // Done
    return;
}

// =================================================================================
// LookupLinkColors
// =================================================================================
BOOL LookupLinkColors(LPCOLORREF pclrLink, LPCOLORREF pclrViewed)
{
    // Locals
    HKEY        hReg=NULL;
    TCHAR       szLinkColor[255],
                szLinkVisitedColor[255];
    LONG        lResult;
    DWORD       cb;

    // Init
    *szLinkColor = _T('\0');
    *szLinkVisitedColor = _T('\0');

    // Look for IE's link color
    if (RegOpenKeyEx (HKEY_CURRENT_USER, (LPTSTR)c_szIESettingsPath, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
        goto tryns;

    // Query for value
    cb = sizeof (szLinkVisitedColor);
    RegQueryValueEx(hReg, (LPTSTR)c_szLinkVisitedColorIE, 0, NULL, (LPBYTE)szLinkVisitedColor, &cb);
    cb = sizeof (szLinkColor);
    lResult = RegQueryValueEx(hReg, (LPTSTR)c_szLinkColorIE, 0, NULL, (LPBYTE)szLinkColor, &cb);

    // Close Reg
    RegCloseKey(hReg);

    // Did we find it
    if (lResult == ERROR_SUCCESS)
        goto found;

tryns:
    // Try Netscape
    if (RegOpenKeyEx (HKEY_CURRENT_USER, (LPTSTR)c_szNSSettingsPath, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
        goto exit;

    // Query for value
    cb = sizeof (szLinkVisitedColor);
    RegQueryValueEx(hReg, (LPTSTR)c_szLinkVisitedColorNS, 0, NULL, (LPBYTE)szLinkVisitedColor, &cb);
    cb = sizeof (szLinkColor);
    lResult = RegQueryValueEx(hReg, (LPTSTR)c_szLinkColorNS, 0, NULL, (LPBYTE)szLinkColor, &cb);

    // Close Reg
    RegCloseKey(hReg);

    // Did we find it
    if (lResult == ERROR_SUCCESS)
        goto found;

    // Not Found
    goto exit;

found:

    // Parse Link
    ParseLinkColorFromSz(szLinkColor, &g_crLink);
    ParseLinkColorFromSz(szLinkVisitedColor, &g_crLinkVisited);
    
    if (pclrLink)
        *pclrLink = g_crLink;
    if (pclrViewed)    
        *pclrViewed = g_crLinkVisited;
    return (TRUE);

exit:
    // Done
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\goptions.cpp ===
#include "pch.hxx"
#include "strconst.h"
#include <mimeole.h>
#include <imnact.h>
#include "imsgcont.h"
#include <goptions.h>
#include <thormsgs.h>
#include "sigs.h"
#include <shlwapi.h>
#undef _INC_GOPTIONS_H
#define DEFINE_OPTION_STRUCTS
#include <goptions.h>
#include "demand.h"
#include "multiusr.h"

IOptionBucketEx *g_pOpt = NULL;
COptNotify *g_pOptNotify = NULL;

BOOL             g_fBadShutdown = FALSE;

static OPTBCKTINIT g_init =
{
    c_rgOptInfo,
    ARRAYSIZE(c_rgOptInfo),
    
    HKEY_CURRENT_USER,
    c_szRegRoot,
    c_rgszOptRegKey,
    COPTREGKEY
};

BOOL InitGlobalOptions(HKEY hkey, LPCSTR szRegOptRoot)
{
    OPTBCKTINIT     init;
    LPCOPTBCKTINIT  pinit;
    HRESULT         hr;
    
    Assert(NULL == g_pOpt);
    Assert(NULL == g_pOptNotify);
    
    g_init.hkey = MU_GetCurrentUserHKey();
    
    IF_NULLEXIT(g_pOptNotify = new COptNotify);
    
    IF_FAILEXIT(hr = CreateOptionBucketEx(&g_pOpt));
    pinit = &g_init;
    
    if (NULL != hkey)
    {
        Assert(NULL != szRegOptRoot);
        init = g_init;
        init.hkey = hkey;
        init.pszRegKeyBase = szRegOptRoot;
        pinit = &init;
    }
    
    IF_FAILEXIT(hr = g_pOpt->Initialize(pinit));
    IF_FAILEXIT(hr = g_pOpt->SetNotification((IOptionBucketNotify *)g_pOptNotify));
    
    // signature manager
    IF_FAILEXIT(hr = InitSignatureManager(pinit->hkey, pinit->pszRegKeyBase));
    
    // if the running regkey is still there, we shut down badly
    g_fBadShutdown = DwGetOption(OPT_ATHENA_RUNNING);
    SetDwOption(OPT_ATHENA_RUNNING, TRUE, NULL, 0);

exit:
    return (S_OK == hr);
}

void DeInitGlobalOptions(void)
{
    
    if (NULL != g_pOpt)
    {
        SetDwOption(OPT_ATHENA_RUNNING, FALSE, NULL, 0);
        g_pOpt->Release();
        g_pOpt = NULL;
    }
    
    if (NULL != g_pOptNotify)
    {
        g_pOptNotify->Release();
        g_pOptNotify = NULL;
    }
    
    DeinitSignatureManager();
}

DWORD DwGetOption(PROPID id)
{
    Assert(NULL != g_pOpt);
    
    return(IDwGetOption(g_pOpt, id));
}

DWORD DwGetOptionDefault(PROPID id)
{
    Assert(NULL != g_pOpt);
    
    return(IDwGetOptionDefault(g_pOpt, id));
}

DWORD GetOption(PROPID id, void *pv, DWORD cb)
{
    Assert(NULL != g_pOpt);
    
    return(IGetOption(g_pOpt, id, pv, cb));
}

DWORD IDwGetOption(IOptionBucketEx *pOpt, PROPID id)
{
    PROPVARIANT var;
    HRESULT hr;
    DWORD dw = 0;
    
    Assert(NULL != pOpt);

    // special case attachment checks to allow for ADM setting of group policy
    if ((id == OPT_SECURITY_ATTACHMENT) || (id == OPT_SECURITY_ATTACHMENT_LOCKED))
    {
        HKEY hkey;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_READ, &hkey))
        {
            DWORD dwVal, cb;

            cb = sizeof(dwVal);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szBlockAttachments, 0, NULL, (LPBYTE)&dwVal, &cb))
            {
                // if set then unsafe attachments are both locked and also disallowed
                if (dwVal == 1)
                    dw = 1;
            }

            RegCloseKey(hkey);
        }
    }

    if (!dw)
    {
        IF_FAILEXIT(hr = pOpt->GetProperty(MAKEPROPSTRING(id), &var, 0));

        Assert(VT_UI4 == var.vt);
        dw = var.ulVal;
    }
    
exit:
    return(dw);
}

DWORD IDwGetOptionDefault(IOptionBucketEx *pOpt, PROPID id)
{
    PROPVARIANT var;
    HRESULT hr;
    DWORD dw = 0;
    
    Assert(pOpt != NULL);
    IF_FAILEXIT(hr = pOpt->GetPropertyDefault(id, &var, 0));

    Assert(var.vt == VT_UI4);
    dw = var.ulVal;

exit:
    return(dw);
}

DWORD IGetOption(IOptionBucketEx *pOpt, PROPID id, void *pv, DWORD cb)
{
    PROPVARIANT var;
    HRESULT     hr = S_OK;
    DWORD       cbT = 0;
    LPBYTE      pByte = NULL;
    
    Assert(NULL != pOpt);
    IF_FAILEXIT(hr = pOpt->GetProperty(MAKEPROPSTRING(id), &var, 0));

    switch (var.vt)
    {
        case VT_LPSTR:
            pByte = (LPBYTE)var.pszVal;
            cbT = lstrlen(var.pszVal) + 1;
            break;

        case VT_LPWSTR:
            pByte = (LPBYTE)var.pwszVal;
            cbT = (lstrlenW(var.pwszVal) + 1) * sizeof(WCHAR);
            break;

        case VT_BLOB:
            pByte = (LPBYTE)var.blob.pBlobData;
            cbT = var.blob.cbSize;
            break;

        default:
            Assert(FALSE);
            IF_FAILEXIT(hr = E_FAIL);
            break;
    }

    if (cb >= cbT && pByte)
        CopyMemory(pv, pByte, cbT);
    else
        IF_FAILEXIT(hr = E_FAIL);

exit:
    MemFree(pByte);

    return (SUCCEEDED(hr) ? cbT : 0);
}

BOOL SetDwOption(PROPID id, DWORD dw, HWND hwnd, DWORD dwFlags)
{
    Assert(NULL != g_pOpt);
    
    return(ISetOption(g_pOpt, id, &dw, sizeof(DWORD), hwnd, dwFlags));
}

BOOL SetOption(PROPID id, void *pv, DWORD cb, HWND hwnd, DWORD dwFlags)
{
    Assert(NULL != g_pOpt);
    
    return(ISetOption(g_pOpt, id, pv, cb, hwnd, dwFlags));
}

BOOL ISetDwOption(IOptionBucketEx *pOpt, PROPID id, DWORD dw, HWND hwnd, DWORD dwFlags)
{
    Assert(NULL != pOpt);
    
    return(ISetOption(pOpt, id, &dw, sizeof(DWORD), hwnd, dwFlags));
}

BOOL ISetOption(IOptionBucketEx *pOpt, PROPID id, void *pv, DWORD cb, HWND hwnd, DWORD dwFlags)
{
    HRESULT     hr;
    PROPINFO    info;
    PROPVARIANT var;
    
    Assert(NULL != pOpt);
    Assert(NULL != pv);
    
    info.cbSize = sizeof(info);
    IF_FAILEXIT(hr = pOpt->GetPropertyInfo(id, &info, 0));

    var.vt = info.vt;

    switch(var.vt)
    {
        case VT_UI4:
            var.ulVal = *((DWORD *)pv);
            break;

        case VT_LPSTR:
            var.pszVal = (LPSTR)pv;
            break;

        case VT_LPWSTR:
            var.pwszVal = (LPWSTR)pv;
            break;

        case VT_BLOB:
            var.blob.cbSize = cb;
            var.blob.pBlobData = (BYTE *)pv;
            break;

        default:
            Assert(FALSE);
            IF_FAILEXIT(hr = E_FAIL);
            break;
    }
    
    IF_FAILEXIT(hr = pOpt->ISetProperty(hwnd, MAKEPROPSTRING(id), &var, dwFlags));

    // TODO: notify option objects that option changed

exit:
    return(SUCCEEDED(hr));
}

HRESULT OptionAdvise(HWND hwnd)
{
    Assert(NULL != g_pOptNotify);
    return(g_pOptNotify->Register(hwnd));
}

HRESULT OptionUnadvise(HWND hwnd)
{
    Assert(NULL != g_pOptNotify);
    return(g_pOptNotify->Unregister(hwnd));
}

COptNotify::COptNotify(void)
{
    m_cRef = 1;
    m_cHwnd = 0;
    m_cHwndBuf = 0;
    m_rgHwnd = NULL;
}

COptNotify::~COptNotify(void)
{
    MemFree(m_rgHwnd);
}

STDMETHODIMP COptNotify::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (NULL == ppv)
        return(E_INVALIDARG);
    
    if (IID_IUnknown == riid)
    {
        *ppv = (IUnknown *)this;
    }
    else if (IID_IOptionBucketNotify == riid)
    {
        *ppv = (IOptionBucketNotify *)this;
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }
    
    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

STDMETHODIMP_(ULONG) COptNotify::AddRef(void)
{
    return((ULONG)InterlockedIncrement(&m_cRef));
}

STDMETHODIMP_(ULONG) COptNotify::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return((ULONG)cRef);
}

#define CADVISEOPT  32

HRESULT COptNotify::Register(HWND hwnd)
{
    HRESULT hr = S_OK;
    int cbuf;
    
    if (m_cHwnd == m_cHwndBuf)
    {
        cbuf = m_cHwndBuf + CADVISEOPT;
        IF_NULLEXIT(MemRealloc((void **)&m_rgHwnd, sizeof(HWND) * cbuf));
        m_cHwndBuf = cbuf;
    }
    
    Assert(m_rgHwnd != NULL);
    m_rgHwnd[m_cHwnd] = hwnd;
    m_cHwnd++;

exit:
    return hr;
}

HRESULT COptNotify::Unregister(HWND hwnd)
{
    int index = 0;
    
    while (index < m_cHwnd)
    {
        if (m_rgHwnd[index] == hwnd)
            break;
        index++;
    }
    if (index >= m_cHwnd)
        return (E_FAIL);
    
    if (m_cHwnd == 1)
    {
        MemFree(m_rgHwnd);
        m_rgHwnd = NULL;
        m_cHwndBuf = 0;
    }
    else
    {
        while (index < m_cHwnd)
        {
            m_rgHwnd[index] = m_rgHwnd[index+1];
            index++;
        }
    }
    m_cHwnd--;
    
    return (S_OK);
}

STDMETHODIMP COptNotify::DoNotification(IOptionBucketEx *pBckt, HWND hwnd, PROPID id)
{
    int i;
    
    for (i = 0; i < m_cHwnd; i++)
    {
        if (hwnd != m_rgHwnd[i] && IsWindow(m_rgHwnd[i]))
            PostMessage(m_rgHwnd[i], CM_OPTIONADVISE, id, 0);
    }
    
    return(S_OK);
}

void GetUserKeyPath(LPCSTR lpSubKey, LPSTR sz, int cch)
{
    Assert(sz != NULL);
    Assert(cch >= MAX_PATH);
    
    LPCTSTR pszUserRoot = c_szRegRoot;
    
    if (lpSubKey == NULL)
        StrCpyN(sz, pszUserRoot, cch);
    else
        wnsprintf(sz, cch, c_szPathFileFmt, pszUserRoot, lpSubKey);
}

LONG AthUserCreateKey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(RegCreateKeyEx(MU_GetCurrentUserHKey(), sz, 0, NULL, REG_OPTION_NON_VOLATILE,
        samDesired, NULL, phkResult, lpdwDisposition));
}

LONG AthUserOpenKey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(RegOpenKeyEx(MU_GetCurrentUserHKey(), sz, 0, samDesired, phkResult));
}

LONG AthUserDeleteKey(LPCSTR lpSubKey)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(SHDeleteKey(MU_GetCurrentUserHKey(), sz));
}

LONG AthUserGetValue(LPCSTR lpSubKey, LPCSTR lpValueName, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(SHGetValue(MU_GetCurrentUserHKey(), sz, lpValueName, lpType, lpData, lpcbData));
}

LONG AthUserSetValue(LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, CONST BYTE *lpData, DWORD cbData)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(SHSetValue(MU_GetCurrentUserHKey(), sz, lpValueName, dwType, lpData, cbData));
}
 
LONG AthUserDeleteValue(LPCSTR lpSubKey, LPCSTR lpValueName)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(SHDeleteValue(MU_GetCurrentUserHKey(), sz, lpValueName));
}

HKEY AthUserGetKeyRoot(void)
{
    return(MU_GetCurrentUserHKey());
}

void AthUserGetKeyPath(LPSTR szKey, int cch)
{
    Assert(cch >= MAX_PATH);
    
    LPCTSTR pszRegRoot = c_szRegRoot;
    Assert(pszRegRoot);
    
    StrCpyN(szKey, pszRegRoot, cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\imagelst.h ===
#ifndef _INC_IMAGELST_H
#define _INC_IMAGELST_H
/*
 *  i m a g e l s t . h
 *
 *  Purpose:
 *      Born from the fire of util.h, this is where all the
 *      "shared image list stuff" went.
 *
 *  History:
 *      Halloween 1996 - Created (t-erikne)
 *
 *  Copyright (C) Microsoft Corp. 1996
 * 
 */

enum
    {
    iiconReplyOverlay = 0,
    iiconForwardOverlay,
    iiconSortAsc,
    iiconSortDesc,
    iiconHeaderPri,
    iiconHeaderAttach,
    iiconPriLow,
    iiconPriHigh,
    iiconAttach,
    iiconUnReadMail,
    iiconReadMail,
    iiconUnSentMail,
    iiconMailUnReadSigned,
    iiconMailUnReadEncrypted,
    iiconMailUnReadSignedAndEncrypted,
    iiconMailReadSigned,
    iiconMailReadEncrypted,
    iiconMailReadSignedAndEncrypted,
    iiconMailUnReadBadSigned,
    iiconMailUnReadBadEncrypted,
    iiconMailUnReadBadSignedAndEncrypted,
    iiconMailReadBadSigned,
    iiconMailReadBadEncrypted,
    iiconMailReadBadSignedAndEncrypted,
    iiconNewsHeader,
    iiconNewsHeaderRead,
    iiconNewsUnread,
    iiconNewsRead,
    iiconNewsFailed,    
    iiconNewsUnsent,
    iiconMailHeader,
    iiconMailDeleted,
    iiconVoiceMail,
    iiconHeaderFlag,
    iiconFlag,
    iiconHeaderDownload,
    iiconDownload,
    iiconHeaderThreadState,
    iiconWatchThread,
    iiconIgnoreThread,
    iiconNewsUnreadSigned,
    iiconNewsReadSigned,
    iiconSmMax
    };
    
enum
    {
    iiconStatePriHigh,
    iiconStateDownload,
    iiconStateNew,
    iiconStateFailed,
    iiconStateCollapsed,
    iiconStateExpanded,
    iiconStateUnchecked,
    iiconStateChecked,
    iiconStateIndeterminate,
    iiconStateCollapsedDownload,
    iiconStateExpandedDownload,
    iiconStateDisabled,
    iiconStateInvalid,
    iiconStateDefault,
    iiconStMax
    };
    
enum 
    {
    OVERLAY_REPLY = 1,
    OVERLAY_FORWARD = 2
    };

#define cxImlSmall      16
#define cyImlSmall      16

#define GIML_SMALL      0x0001
#define GIML_STATE      0x0004

HIMAGELIST  InitImageList(int cx, int cy, LPCSTR szbm, int cicon, COLORREF cr);
HIMAGELIST  GetImageList(UINT fIml);
void        FreeImageLists(void);
BOOL        LoadBitmapAndPalette(int idbmp, HBITMAP *phbmp, HPALETTE *phpal);
void        TileImage(HBITMAP hbmp, HDC hdc, LPPOINT lpptOrigin, LPRECT lprcDest);

#endif // _INC_IMAGELST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\imagelst.cpp ===
/*
 *  i m a g e l s t . c p p
 *
 *  Purpose:                     
 *      utilities for images and imagelists
 *    
 *  Copyright (C) Microsoft Corp. 1996
 * 
 */

#include "pch.hxx"
#include "resource.h"   // idb stuff
#include "imagelst.h"

/////////////////////////////////////////////////////////////////////////////
// 
// Macros
//

#define ILT_PARTIALBLT_LEFT     0
#define ILT_PARTIALBLT_TOP      1
#define ILT_PARTIALBLT_RIGHT    2
#define ILT_PARTIALBLT_BOTTOM   3

/////////////////////////////////////////////////////////////////////////////
//
// Global Data
//

static HIMAGELIST g_himlAthSm = NULL;
static HIMAGELIST g_himlAthSt = NULL;

/////////////////////////////////////////////////////////////////////////////
// 
// Prototypes
//

HIMAGELIST InitImageList(int cx, int cy, LPSTR szbm, int cicon);

//
// TileImage
//
// This function tiles a bitmap in lprcDest, using lpptOrigin as the origin
//
void TileImage(HBITMAP hbmp, HDC hdc, LPPOINT lpptOrigin, LPRECT lprcDest)
{
    BOOL    fFirstRow, fFirstCol;
    int     nRows, nCols, nSaveCols, offset;
    int     rgOffsetPartialBlt[4];
    POINT   ptTileOrigin, ptDraw, ptDest, ptSrc;
    SIZE    sizeImage, sizeRect, sizeBlt;
    HDC     hdcBmp=0;
    HBITMAP hbmpOrig=0;
    BITMAP  bm;

    if(!hdc)
        return;

    if(!(hdcBmp = CreateCompatibleDC(hdc)))
        goto fail;

    if(!(hbmpOrig = SelectBitmap(hdcBmp, hbmp)))
        goto fail;
    
    GetObject(hbmp, sizeof(BITMAP), &bm);
    sizeImage.cx = bm.bmWidth;
    sizeImage.cy = bm.bmHeight;

    // Generate the true origin with the tile
    lpptOrigin->x %= sizeImage.cx;
    lpptOrigin->y %= sizeImage.cy;

    // We will start the tile so that the origin lines up
    ptTileOrigin.x = lprcDest->left - lpptOrigin->x;
    ptTileOrigin.y = lprcDest->top - lpptOrigin->y;

    // Figure out how many rows and columns wo need
    sizeRect.cx = lprcDest->right - ptTileOrigin.x;
    sizeRect.cy = lprcDest->bottom - ptTileOrigin.y;

    nRows = sizeRect.cy / sizeImage.cy;
    nRows += (sizeRect.cy % sizeImage.cy) ? 1 : 0;
    nSaveCols = sizeRect.cx / sizeImage.cx;
    nSaveCols += (sizeRect.cx % sizeImage.cx) ? 1 : 0;

    // Generate the partial blt offsets
    rgOffsetPartialBlt[ILT_PARTIALBLT_TOP] = lprcDest->top - ptTileOrigin.y;
     rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT] = lprcDest->left - ptTileOrigin.x;
    if (sizeImage.cy >= sizeRect.cy)
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = sizeImage.cy - sizeRect.cy;
    else if(sizeRect.cy % sizeImage.cy)
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = sizeImage.cy -
                (sizeRect.cy % sizeImage.cy);
    else
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = 0;
    if (sizeImage.cx >= sizeRect.cx)
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = sizeImage.cx - sizeRect.cx;
    else if(sizeRect.cx % sizeImage.cx)
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = sizeImage.cx -
                (sizeRect.cx % sizeImage.cx);
    else
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = 0;

    // Draw the tiles
    ptDraw.y = ptTileOrigin.y;
    fFirstRow = TRUE;
    while (nRows--)
        {
        ptDraw.x = ptTileOrigin.x;
        nCols = nSaveCols;
        fFirstCol = TRUE;
        while (nCols--)
            {
            ptDest = ptDraw;
            sizeBlt = sizeImage;
            ptSrc.x = ptSrc.y = 0; 
            // Handle partial boundary Blts
            if (fFirstRow && rgOffsetPartialBlt[ILT_PARTIALBLT_TOP] != 0)
                {
                offset = rgOffsetPartialBlt[ILT_PARTIALBLT_TOP];
                ptDest.y += offset;
                sizeBlt.cy -= offset;
                ptSrc.y += offset;
                }
            if (nRows == 0 && rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] != 0)
                sizeBlt.cy -= rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM];
            if (fFirstCol && rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT] != 0)
                {
                offset = rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT];
                ptDest.x += offset;
                sizeBlt.cx -= offset;
                ptSrc.x += offset;
                }
            if (nCols == 0 && rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] != 0)
                sizeBlt.cx -= rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT];
            // Just do it
            BitBlt(hdc, ptDest.x, ptDest.y,    sizeBlt.cx, sizeBlt.cy,
                    hdcBmp, ptSrc.x, ptSrc.y, SRCCOPY);
            ptDraw.x += sizeImage.cx;
            fFirstCol = FALSE;
            }
        ptDraw.y += sizeImage.cy;
        fFirstRow = FALSE;
        }

fail:
    if(hdcBmp) 
        {
        if(hbmpOrig)
            SelectBitmap(hdcBmp, hbmpOrig);
        DeleteDC(hdcBmp);
        }
}

HIMAGELIST InitImageList(int cx, int cy, LPCSTR szbm, int cicon, COLORREF cr)
{
    HBITMAP hbm;
    HIMAGELIST himl;

    if(!fIsWhistler())
        himl = ImageList_Create(cx, cy, ILC_MASK, cicon, 0);
    else
        himl = ImageList_Create(cx, cy, ILC_COLOR32|ILC_MASK, cicon, 0);

    if (himl != NULL)
        {
        hbm = LoadBitmap(g_hLocRes, szbm);
        Assert(hbm != NULL);

        ImageList_AddMasked(himl, hbm, cr);

        DeleteObject((HGDIOBJ)hbm);
        }

    return(himl);
}

HIMAGELIST GetImageList(UINT fIml)
{
    if (fIml == GIML_SMALL)
    {
        if (g_himlAthSm == NULL)
        {
            g_himlAthSm = InitImageList(cxImlSmall, cyImlSmall, MAKEINTRESOURCE(idb16x16), iiconSmMax, RGB(255, 0, 255));
            ImageList_SetOverlayImage(g_himlAthSm, iiconReplyOverlay, OVERLAY_REPLY);
            ImageList_SetOverlayImage(g_himlAthSm, iiconForwardOverlay, OVERLAY_FORWARD);
        }

        return(g_himlAthSm);
    }
    else if (fIml == GIML_STATE)
    {
        if (g_himlAthSt == NULL)
            g_himlAthSt = InitImageList(cxImlSmall, cyImlSmall, MAKEINTRESOURCE(idb16x16st), iiconStMax, RGB(255, 0, 255));
        return(g_himlAthSt);
    }

    return(NULL);
}

void FreeImageLists(void)
{
    if (g_himlAthSm != NULL)
        {
        ImageList_Destroy(g_himlAthSm);
        g_himlAthSm = NULL;
        }

    if (g_himlAthSt != NULL)
        {
        ImageList_Destroy(g_himlAthSt);
        g_himlAthSt = NULL;
        }
}

BOOL LoadBitmapAndPalette(int idbmp, HBITMAP *phbmp, HPALETTE *phpal)
{
    int i, n;
    HBITMAP hbmp;
    HPALETTE hpal;
    HDC hdcBitmap;
    DWORD adw[257];
    BOOL fret = FALSE;

    Assert(phbmp != NULL);
    Assert(phpal != NULL);

    hdcBitmap = NULL;
    *phbmp = NULL;
    *phpal = NULL;

    hbmp = (HBITMAP)LoadImage(g_hLocRes, MAKEINTRESOURCE(idbmp),
                    IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if (hbmp == NULL)
        goto DoneLoadBitmap;

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap == NULL)
        goto DoneLoadBitmap;
    SelectObject(hdcBitmap, (HGDIOBJ)hbmp);
    n = GetDIBColorTable(hdcBitmap, 0, 256, (LPRGBQUAD)&adw[1]);
    for (i = 1; i <= n; i++)
        adw[i] = RGB(GetBValue(adw[i]), GetGValue(adw[i]), GetRValue(adw[i]));
    adw[0] = MAKELONG(0x300, n);
    hpal = CreatePalette((LPLOGPALETTE)&adw[0]);
    if (hpal == NULL)
        goto DoneLoadBitmap;

    *phbmp = hbmp;
    *phpal = hpal;

    fret = TRUE;

DoneLoadBitmap:
    if (hdcBitmap != NULL)
        DeleteDC(hdcBitmap);

    return(fret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\imnapi.h ===
// =================================================================================
// I M N A P I . H - IMN exported apis
// =================================================================================
#ifndef __IMNAPI_H
#define __IMNAPI_H

// =====================================================================================
// Depends on
// =====================================================================================

typedef interface IMimeMessage IMimeMessage;
typedef /* [unique] */ IMimeMessage __RPC_FAR *LPMIMEMESSAGE;
typedef struct tagMESSAGEINFO *LPMESSAGEINFO;

// =====================================================================================
// Address Types
// =====================================================================================
#define IADDR_TO        100
#define IADDR_FROM      101
#define IADDR_CC        102
#define IADDR_BCC       103

// =====================================================================================
// Address Info Struct
// =====================================================================================
typedef struct IADDRINFO
{
    DWORD               dwType;
    LPTSTR              lpszDisplay;
    LPTSTR              lpszAddress;

} IADDRINFO, *LPIADDRINFO;

// =====================================================================================
// Attach Types
// =====================================================================================
#define IATT_FILE       100
#define IATT_MSG        101
#define IATT_OLE        102

// =====================================================================================
// IAttach Info Struct
// =====================================================================================
typedef struct tagIATTINFO
{
    DWORD               dwType;
    LPTSTR              lpszFileName;
    LPTSTR              lpszPathName;
    LPTSTR              lpszExt;
    LPSTREAM            lpstmAtt;
    BOOL                fError;
    struct IMSG         *lpImsg;

} IATTINFO, *LPIATTINFO;

// =====================================================================================
// Priorities
// =====================================================================================
#define PRI_NORMAL          100
#define PRI_LOW             101
#define PRI_HIGH            102

// =====================================================================================
// IMN Message Info Struct
// =====================================================================================
typedef struct IMSG
{
    WORD                wPriority;
    LPTSTR              lpszSubject;
    FILETIME            ftSend;
    FILETIME            ftReceive;
    ULONG               uFlags;
    LPSTREAM            lpstmBody;
    ULONG               cAddress;
    LPIADDRINFO         lpIaddr;
    ULONG               cAttach;
    LPIATTINFO          lpIatt;

    LPSTREAM            lpstmHtml;
} IMSG, *LPIMSG;

STDAPI MailNewsDllInit (BOOL fInit);
STDAPI HrImnRouteMessage (LPIADDRINFO lpIaddrRoute, ULONG cAddrRoute, LPIMSG lpImsg);

class CMailMsg;
HRESULT HrImsgToMailMsg (LPIMSG lpImsg, LPMIMEMESSAGE *lppMailMsg, LPSTREAM *lppstmMsg);
HRESULT HrMailMsgToImsg(LPMIMEMESSAGE lpMailMsg, LPMESSAGEINFO pMsgInfo, LPIMSG lpImsg);

EXTERN_C_16 void WINAPI_16 FreeImsg(LPIMSG lpImsg);
typedef void (*PFNFREEIMSG)(LPIMSG);

#ifdef TNEF
HRESULT HrInitImnTnefDll (BOOL fInit);
HRESULT HrGetTnefRtfStream (LPSTREAM lpstmTnef, LPSTREAM lpstmRtf);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\impapi.h ===
#ifndef _INC_IMPAPI_H
#define _INC_IMPAPI_H

typedef enum tagIMPORTFOLDERTYPE IMPORTFOLDERTYPE;

#define INVALID_FOLDER_HANDLE   ((HANDLE)MAXULONG_PTR)

typedef struct tagIMPFOLDERNODE
    {
    struct tagIMPFOLDERNODE *pnext;
    struct tagIMPFOLDERNODE *pchild;
    struct tagIMPFOLDERNODE *pparent;

    int depth;
    TCHAR *szName;
    IMPORTFOLDERTYPE type;
    ULONG cMsg;

    LPARAM lparam;

    BOOL fImport;
    DWORD_PTR dwReserved;   // for use by the import code, the client code should ignore this
    } IMPFOLDERNODE;

typedef struct IMSG IMSG;

void DoImport(HWND hwnd);

void DoMigration(HWND hwnd);

typedef HRESULT (*PFNEXPMSGS)(HWND);

void DoExport(HWND hwnd);

#ifdef WIN16
EXTERN_C {
#endif
HRESULT WINAPI_16 ExpGetFolderList(IMPFOLDERNODE **plist);
typedef HRESULT (*PFNEXPGETFOLDERLIST)(IMPFOLDERNODE **);

void WINAPI_16 ExpFreeFolderList(IMPFOLDERNODE *plist);
typedef void (*PFNEXPFREEFOLDERLIST)(IMPFOLDERNODE *);

HRESULT WINAPI_16 ExpGetFirstImsg(HANDLE hfolder, IMSG *pimsg, HANDLE_16 *phnd);
typedef HRESULT (*PFNEXPGETFIRSTIMSG)(HANDLE, IMSG *, HANDLE_16 *);

HRESULT WINAPI_16 ExpGetNextImsg(IMSG *pimsg, HANDLE_16 hnd);
typedef HRESULT (*PFNEXPGETNEXTIMSG)(IMSG *, HANDLE_16);

void WINAPI_16 ExpGetImsgClose(HANDLE_16 hnd);
typedef void (*PFNEXPGETIMSGCLOSE)(HANDLE_16);
#ifdef WIN16
}
#endif

#endif // _INC_IMPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\imsgcont.h ===
////////////////////////////////////////////////////////////////////////
//
//  IMsgContainer
//
//  Manages internet message headers
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_IMSGCONT_H
#define _INC_IMSGCONT_H

#include "columns.h"

typedef struct tagFINDMSG FINDMSG;

// from inc\storbase.h
typedef DWORD   MSGID;

// Used for MarkThread()
typedef enum {
    MARK_THD_NO_SUPERPARENT =   0x0001,
    MARK_THD_FOR_DL =           0x0002,
    MARK_THD_NO_DL =            0x0004,
    MARK_THD_AS_READ =          0x0008,
    MARK_THD_AS_UNREAD =        0x0010
} MARKTHREADTYPE;

// Used in RemoveHeaders() and by the view
typedef enum {
    FILTER_NONE         = 0x0001,   // show all (cannot be used w/ other flags)
    FILTER_READ         = 0x0002,   // hide read messages
    FILTER_NOBODY       = 0x0004,   // hide messages without dl'd bodies
    FILTER_SHOWFILTERED = 0x0008,   // display filtered messages
    FILTER_SHOWDELETED  = 0x0010,   // display deleted messages
    PRUNE_NONREPLIES    = 0x0020,   // hide threads that are not replies to sender
} FILTERTYPE;

// Generic flags for IMessageCont methods
// use these if there is no specific set below
#define IMC_BYMSGID     0x0000      // dwIndex is a msgid (DEFAULT)
#define IMC_BYROW       0x0001      // dwIndex specifies a row
#define IMC_COMMONFLAGS 0x0002      // the mask, state, dword, whatever is SCFS_ flags (otherwise ARF_ or MSG_)
#define IMC_CONVERTARFTOMSG 0x0004

// Used by HrGetNext
#define GNM_NEXT        0x0000      // get next (DEFAULT)
// 0x0001 reserved for IMC_BYROW
// IMC_COMMONFLAGS not accepted
#define GNM_PREV        0x0004      // get previous instead of next (can't be used with GNM_UNREAD or GNM_THREAD)
#define GNM_UNREAD      0x0008      // get next unread (can't be used with GNM_PREV)
#define GNM_THREAD      0x0010      // get next thread (can't be used with GNM_PREV)
#define GNM_SKIPMAIL    0x0020      // skip over mail messages
#define GNM_SKIPNEWS    0x0040      // skip over news messages
#define GNM_SKIPUNSENT  0x0080      // skip unsent messages

// Used by GetMsgBy
#define GETMSG_SECURE   (TRUE)
#define GETMSG_INSECURE (FALSE)

// State and mask flags for SetCachedFlags
// NOTE: we list here only the flags that are easily convertable
// between ARF_ and MSG_.  Our flag situation is very annoying.
#define SCFS_NOSECUI    0x0001
#define SCFS_ALLFLAGS   0x0001      // do not use explicitly

DECLARE_INTERFACE(IMsgContainer)
{
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    STDMETHOD(Advise) (THIS_ HWND hwndAdvise) PURE;
    STDMETHOD(CollapseBranch) (THIS_ DWORD dwRow, LPDWORD pdwCount) PURE;
    STDMETHOD(ExpandAllThreads) (THIS_ BOOL fExpand) PURE;
    STDMETHOD(ExpandBranch) (THIS_ DWORD dwRow, LPDWORD pdwCount) PURE;
    STDMETHOD_(ULONG, GetCount) (THIS) PURE;
    STDMETHOD(GetDisplayInfo) (THIS_ LV_DISPINFO *plvdi, COLUMN_ID idColumn) PURE;
    STDMETHOD_(int, GetIndex) (THIS_ DWORD dwMsgId, BOOL fForceUnthreadedSearch = FALSE) PURE;
    STDMETHOD_(BOOL, GetMsgId) (THIS_ DWORD dwRow, LPDWORD pdwMsgId) PURE;
    STDMETHOD(GetMsgByIndex) (THIS_ DWORD dwRow, LPMIMEMESSAGE *ppMsg, HWND hwnd, BOOL *pfCached, BOOL fDownload, BOOL fSecure) PURE;
    STDMETHOD(GetMsgByMsgId) (THIS_ MSGID msgid, LPMIMEMESSAGE *ppMsg, HWND hwnd, BOOL *pfCached, BOOL fDownload, BOOL fSecure) PURE;
    STDMETHOD(HrFindItem) (THIS_ LPCSTR szSearch, ULONG *puRow) PURE;
    STDMETHOD(HrGetNext) (THIS_ DWORD dwIndex, LPDWORD pdwMsgId, DWORD dwFlags) PURE;
    STDMETHOD_(BOOL, FFlagState) (THIS_ DWORD dwIndex, DWORD dwMask, DWORD dwFlags) PURE;
    STDMETHOD_(BOOL, IsCollapsedThread) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, HasBody) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, HasKids) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, IsRowRead) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, IsRowOrChildUnread) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, IsRowFiltered) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(void, MarkAll) (THIS_ BOOL fRead) PURE;
    STDMETHOD_(void, MarkAllDL) (THIS_ BOOL fDL) PURE;
    STDMETHOD_(void, MarkSelected) (THIS_ HWND hwndList, MARKTHREADTYPE mtt) PURE;
    STDMETHOD_(void, MarkOne) (THIS_ BOOL fRead, DWORD dwMsgId) PURE;
    STDMETHOD_(void, MarkOneRow) (THIS_ BOOL fRead, DWORD dwRow) PURE;
    STDMETHOD_(void, MarkOneRowDL) (THIS_ BOOL fDL, DWORD dwRow) PURE;
    STDMETHOD(MarkThread) (THIS_ DWORD mtType, DWORD dwRow) PURE;
    STDMETHOD_(void, SetFilterState) (THIS_ DWORD dwFilterState) PURE;
    STDMETHOD_(void, SetViewWindow) (THIS_ HWND hwnd, BOOL fNoUI) PURE;
    STDMETHOD_(void, Sort) (THIS_ COLUMN_ID idSort, BOOL fReverse, BOOL fThread) PURE;
    STDMETHOD(Unadvise) (THIS_ HWND hwndAdvise) PURE;
    STDMETHOD(HrFindNext) (THIS_ FINDMSG *pfmsg, DWORD dwRow, BOOL fIgnoreFirst) PURE;
    STDMETHOD(CreateDragObject) (THIS_ HWND hwndList, DWORD *pdwEffectOk, IDataObject **ppDataObject) PURE;
    STDMETHOD(Delete) (THIS_ DWORD dwMsgId, BOOL fForce) PURE;
    STDMETHOD(SetCachedFlagsBy) (THIS_ DWORD dwIndex, DWORD dwState, DWORD dwStateMask, DWORD *pdwNewFlags, DWORD dwFlags) PURE;
    STDMETHOD(SetMsgViewLanguage) (THIS_ MSGID msgid, DWORD dwCodePage) PURE;
    STDMETHOD(GetMsgViewLanguage) (THIS_ MSGID msgid, DWORD *pdwCodePage) PURE;
    STDMETHOD_(void, SetUIMode) (THIS_ BOOL fUI) PURE;
    STDMETHOD_(int, GetItemParent) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(int, GetFirstChild) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(int, GetEmptyFolderString) (THIS) PURE;
    STDMETHOD_(BOOL, IsRowDeleted) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(WORD, GetRowHighlight) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(void, UpdateAdvises)(THIS_ DWORD dwMsgId) PURE;
};

#endif // _INC_IMSGCONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\impapi.cpp ===
#include "pch.hxx"
#include "strconst.h"
#include "mimeole.h"
#include "mimeutil.h"
#include <error.h>
#include <imnapi.h>
#include "goptions.h"
#include <resource.h>
#include <mso.h>
#include <envelope.h>
#include "ipab.h"
#define NO_IMPORT_ERROR
#include <newimp.h>
#include <impapi.h>
#include "storutil.h"
#include "demand.h"
#include "msgfldr.h"
#include "store.h"

class CMailImporter : public IMailImporter
    {
    private:
        ULONG         m_cRef;

    public:
        CMailImporter(void);
        ~CMailImporter(void);

        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        ULONG   STDMETHODCALLTYPE AddRef(void);
        ULONG   STDMETHODCALLTYPE Release(void);

        HRESULT Initialize(HWND hwnd);

        STDMETHODIMP OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie);
    };

class CFolderImport : public IFolderImport
    {
    private:
        ULONG               m_cRef;
        IMessageFolder     *m_pFolder;

        STDMETHODIMP ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm);

    public:
        CFolderImport(void);
        ~CFolderImport(void);
        
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        ULONG   STDMETHODCALLTYPE AddRef(void);
        ULONG   STDMETHODCALLTYPE Release(void);

        HRESULT Initialize(IMessageFolder *pFolder);

        STDMETHODIMP SetMessageCount(ULONG cMsg);
        STDMETHODIMP ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach);
        STDMETHODIMP ImportMessage(IMSG *pimsg);
    };

HRESULT GetImsgFromFolder(IMessageFolder *pfldr, LPMESSAGEINFO pMsgInfo, IMSG *pimsg);

CFolderImport::CFolderImport()
    {
    m_cRef = 1;
    m_pFolder = NULL;
    }

CFolderImport::~CFolderImport()
    {
    SafeRelease(m_pFolder);
    }

ULONG CFolderImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CFolderImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CFolderImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IFolderImport == riid)
        *ppv = (IFolderImport *)this;
    else if (IID_IUnknown == riid)
        *ppv = (IFolderImport *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CFolderImport::Initialize(IMessageFolder *pFolder)
    {
    Assert(pFolder != NULL);
    m_pFolder = pFolder;
    m_pFolder->AddRef();
    return(S_OK);
    }

HRESULT CFolderImport::SetMessageCount(ULONG cMsg)
    {
    return(S_OK);
    }

HRESULT CFolderImport::ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach)
    {
    IMimeMessage *pMsg;
    HRESULT hr;
    DWORD iAttach, dwPri;
    PROPVARIANT rVariant;
    DWORD dwMsgFlags;

    Assert(pstm != NULL);
    Assert(m_pFolder != NULL);

    if (rgszAttach == NULL)
        {
        Assert(cAttach == 0);
        return(ImportMessage(type, dwState, pstm));
        }

    Assert(cAttach > 0);

    hr = HrRewindStream(pstm);
    if (FAILED(hr))
        return(hr);

    hr = HrCreateMessage(&pMsg);
    if (SUCCEEDED(hr))
        {
        hr = pMsg->Load(pstm);
        if (SUCCEEDED(hr))
            {
            for (iAttach = 0; iAttach < cAttach; iAttach++)
                {
                Assert(rgszAttach[iAttach] != NULL);

                pMsg->AttachFile(rgszAttach[iAttach], NULL, NULL);
                }

            dwPri = dwState & MSG_PRI_MASK;
            if (dwPri != 0)
                {
                if (dwPri == MSG_PRI_HIGH)
                    rVariant.ulVal = IMSG_PRI_HIGH;
                else if (dwPri == MSG_PRI_LOW)
                    rVariant.ulVal = IMSG_PRI_LOW;
                else
                    rVariant.ulVal = IMSG_PRI_NORMAL;

                rVariant.vt = VT_UI4;
                pMsg->SetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant);
                }

            // Compute the Default arf flags
            dwMsgFlags = 0;

            // Is the Message Read ?
            if (FALSE == ISFLAGSET(dwState, MSG_STATE_UNREAD))
                FLAGSET(dwMsgFlags, ARF_READ);

            // Unsent
            if (ISFLAGSET(dwState, MSG_STATE_UNSENT))
                FLAGSET(dwMsgFlags, ARF_UNSENT);

            // Submitted
            // if (ISFLAGSET(dwState, MSG_STATE_SUBMITTED))
            //     FLAGSET(dwMsgFlags, ARF_SUBMITTED);

            if (type == MSG_TYPE_NEWS)
                FLAGSET(dwMsgFlags, ARF_NEWSMSG);

            // Insert the message
            hr = m_pFolder->SaveMessage(NULL, SAVE_MESSAGE_GENID, dwMsgFlags, 0, pMsg, NOSTORECALLBACK);
            Assert(hr != E_PENDING);
            }

        pMsg->Release();
        }

    return(hr);
    }

HRESULT CFolderImport::ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm)
    {
    WORD pri;
    IMimeMessage *pMsg;
    HRESULT hr;
    DWORD dwPri;
    PROPVARIANT rVariant;
    DWORD dwMsgFlags;

    Assert(pstm != NULL);
    Assert(m_pFolder != NULL);

    hr = HrRewindStream(pstm);
    if (FAILED(hr))
        return(hr);

    hr = HrCreateMessage(&pMsg);
    if (SUCCEEDED(hr))
        {
        if (SUCCEEDED(hr = pMsg->Load(pstm)))
            {
            dwPri = dwState & MSG_PRI_MASK;
            if (dwPri != 0)
                {
                if (dwPri == MSG_PRI_HIGH)
                    rVariant.ulVal = IMSG_PRI_HIGH;
                else if (dwPri == MSG_PRI_LOW)
                    rVariant.ulVal = IMSG_PRI_LOW;
                else
                    rVariant.ulVal = IMSG_PRI_NORMAL;

                rVariant.vt = VT_UI4;
                pMsg->SetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant);
                }


            // Compute the Default arf flags
            dwMsgFlags = 0;

            // Is the Message Read ?
            if (FALSE == ISFLAGSET(dwState, MSG_STATE_UNREAD))
                FLAGSET(dwMsgFlags, ARF_READ);

            // Unsent
            if (ISFLAGSET(dwState, MSG_STATE_UNSENT))
                FLAGSET(dwMsgFlags, ARF_UNSENT);

            // Submitted
            // if (ISFLAGSET(dwState, MSG_STATE_SUBMITTED))
            //     FLAGSET(dwMsgFlags, ARF_SUBMITTED);

            if (type == MSG_TYPE_NEWS)
                FLAGSET(dwMsgFlags, ARF_NEWSMSG);

            // Insert the message
            hr = m_pFolder->SaveMessage(NULL, SAVE_MESSAGE_GENID, dwMsgFlags, 0, pMsg, NOSTORECALLBACK);
            Assert(hr != E_PENDING);
            }

        pMsg->Release();
        }

    return(hr);
    }

HRESULT CFolderImport::ImportMessage(IMSG *pimsg)
    {
    HRESULT hr;
    MESSAGEID id;
    MESSAGEINFO info;
    LPMIMEMESSAGE   pMsg;

    Assert(pimsg != NULL);

    hr = HrImsgToMailMsg(pimsg, &pMsg, NULL);
    if (!FAILED(hr))
        {
        hr = m_pFolder->SaveMessage(&id, SAVE_MESSAGE_GENID, ISFLAGSET(pimsg->uFlags, MSGFLAG_READ) ? ARF_READ : 0, 0, pMsg, NOSTORECALLBACK);
        Assert(hr != E_PENDING);
        if (SUCCEEDED(hr))
        {
            // handle receive time
            ZeroMemory(&info, sizeof(MESSAGEINFO));
            info.idMessage = id;
            if (DB_S_FOUND == m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &info, NULL))
            {
                Assert(pimsg->ftReceive.dwLowDateTime != 0 || pimsg->ftReceive.dwHighDateTime != 0);

                CopyMemory(&info.ftReceived, &pimsg->ftReceive, sizeof(FILETIME));
                m_pFolder->UpdateRecord(&info);

                m_pFolder->FreeRecord(&info);
            }
        }

        pMsg->Release();
        }

    return(hr);
    }


CMailImporter::CMailImporter()
    {
    m_cRef = 1;
    }

CMailImporter::~CMailImporter()
    {
    }

HRESULT CMailImporter::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IMailImporter == riid)
        *ppv = (IMailImporter *)this;
    else if (IID_IUnknown == riid)
        *ppv = (IMailImporter *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

ULONG CMailImporter::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CMailImporter::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CMailImporter::Initialize(HWND hwnd)
    {
    return S_OK;
    }

HRESULT CMailImporter::OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie)
    {
    HRESULT hr;
    FOLDERID idFolder, idFolderNew;
    CFolderImport *pFldrImp;
    IMessageFolder *pFolder;
    TCHAR sz[CCHMAX_FOLDER_NAME + 1];

    Assert(szFolder != NULL);
    Assert(ppFldrImp != NULL);
    Assert(dwFlags == 0);

    *ppFldrImp = NULL;

    if (dwCookie == COOKIE_ROOT)
        idFolder = FOLDERID_LOCAL_STORE;
    else
        idFolder = (FOLDERID)dwCookie;

    idFolderNew = FOLDERID_INVALID;

    if (type != FOLDER_TYPE_NORMAL)
        {
        LoadString(g_hLocRes, idsInbox + (type - FOLDER_TYPE_INBOX), sz, ARRAYSIZE(sz));
        szFolder = sz;
        }

    if (FAILED(GetFolderIdFromName(g_pStore, szFolder, idFolder, &idFolderNew)))
        {
        FOLDERINFO Folder={0};

        Folder.idParent = idFolder;
        Folder.tySpecial = FOLDER_NOTSPECIAL;
        Folder.pszName = (LPSTR)szFolder;
        Folder.dwFlags = FOLDER_SUBSCRIBED;

        hr = g_pStore->CreateFolder(NOFLAGS, &Folder, NOSTORECALLBACK);
        Assert(hr != E_PENDING);
        if (FAILED(hr))
            return(hr);

        idFolderNew = Folder.idFolder;
        }

    hr = g_pStore->OpenFolder(idFolderNew, NULL, NOFLAGS, &pFolder);
    if (FAILED(hr))
        return(hr);

    pFldrImp = new CFolderImport;
    if (pFldrImp == NULL)
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        hr = pFldrImp->Initialize(pFolder);
        if (FAILED(hr))
            {
            pFldrImp->Release();
            pFldrImp = NULL;
            }
        }

    pFolder->Release();

    *ppFldrImp = pFldrImp;
    *pdwCookie = (DWORD_PTR)idFolderNew;

    return(S_OK);
    }

void DoImport(HWND hwnd)
    {
    HRESULT hr;
    HMODULE hlibImport;
    PFNPERFORMIMPORT lpfnPerformImport;
    CMailImporter *pImp;

    hr = hrImportLoad;

    hlibImport = LoadLibrary(c_szImnimpDll);
    if (hlibImport != NULL)
        {
        lpfnPerformImport = (PFNPERFORMIMPORT)GetProcAddress(hlibImport, achPerformImport);
        if (lpfnPerformImport != NULL)
            {
            pImp = new CMailImporter;
            if (pImp == NULL)
                {
                hr = E_OUTOFMEMORY;
                }
            else
                {
                hr = pImp->Initialize(hwnd);
                if (SUCCEEDED(hr))
                    lpfnPerformImport(hwnd, pImp, 0);

                pImp->Release();
                }
            }

        FreeLibrary(hlibImport);
        }

    if (FAILED(hr))
        {
        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrImport), hr);
        }
    }

// EXPORT STUFF

IMPFOLDERNODE *InsertFolderNode(IMPFOLDERNODE *plist, IMPFOLDERNODE *pnode)
    {
    BOOL fNodeNormal, fCurrNormal;
    IMPFOLDERNODE *pprev, *pcurr;

    Assert(pnode != NULL);
    pnode->pnext = NULL;

    if (plist == NULL)
        return(pnode);
    
    pprev = NULL;
    pcurr = plist;
    while (pcurr != NULL)
        {
        fNodeNormal = pnode->type == FOLDER_TYPE_NORMAL;
        fCurrNormal = pcurr->type == FOLDER_TYPE_NORMAL;

        if (!fNodeNormal &&
            fCurrNormal)
            break;
        
        if (fNodeNormal == fCurrNormal &&
            lstrcmpi(pnode->szName, pcurr->szName) <= 0)
            break;

        pprev = pcurr;
        pcurr = pcurr->pnext;
        }

    if (pcurr == NULL)
        {
        // insert at end of list
        Assert(pprev != NULL);
        pprev->pnext = pnode;
        }
    else if (pprev == NULL)
        {
        // insert at beginning of list
        pnode->pnext = plist;
        plist = pnode;
        }
    else
        {
        pprev->pnext = pnode;
        pnode->pnext = pcurr;
        }

    return(plist);
    }

HRESULT ExpGetSubFolders(IMPFOLDERNODE *pparent, FOLDERID idParent, IMPFOLDERNODE **pplist)
    {
    HRESULT hr;
    TCHAR *sz;
    IMPFOLDERNODE *pnode, *plist;
    HANDLE_16 hnd;
    FOLDERINFO Folder={0};
    IEnumerateFolders *pEnum;

    Assert(pplist != NULL);
    Assert(idParent != FOLDERID_INVALID);

    *pplist = NULL;
    plist = NULL;

    hr = g_pStore->EnumChildren(idParent, FALSE, &pEnum);
    if (SUCCEEDED(hr))
        {
        while (S_OK == pEnum->Next(1, &Folder, NULL))
            {
            if (!MemAlloc((void **)&pnode, sizeof(IMPFOLDERNODE) + CCHMAX_FOLDER_NAME * sizeof(TCHAR)))
                {
                hr = E_OUTOFMEMORY;
                break;
                }

            ZeroMemory(pnode, sizeof(IMPFOLDERNODE));
            sz = (TCHAR *)((BYTE *)pnode + sizeof(IMPFOLDERNODE));

            pnode->pparent = pparent;
            pnode->depth = (pparent != NULL) ? (pparent->depth + 1) : 0;
            pnode->szName = sz;
            StrCpyN(sz, Folder.pszName, CCHMAX_FOLDER_NAME);
            pnode->lparam = (LPARAM)Folder.idFolder;
            pnode->cMsg = Folder.cMessages;

            if (Folder.tySpecial == FOLDER_INBOX)
                pnode->type = FOLDER_TYPE_INBOX;
            else if (Folder.tySpecial == FOLDER_OUTBOX)
                pnode->type = FOLDER_TYPE_OUTBOX;
            else if (Folder.tySpecial == FOLDER_SENT)
                pnode->type = FOLDER_TYPE_SENT;
            else if (Folder.tySpecial == FOLDER_DELETED)
                pnode->type = FOLDER_TYPE_DELETED;
            else if (Folder.tySpecial == FOLDER_DRAFT)
                pnode->type = FOLDER_TYPE_DRAFT;

            plist = InsertFolderNode(plist, pnode);

            hr = ExpGetSubFolders(pnode, Folder.idFolder, &pnode->pchild);
            if (FAILED(hr))
                break;

            g_pStore->FreeRecord(&Folder);
            }

        pEnum->Release();
        }

    *pplist = plist;

    g_pStore->FreeRecord(&Folder);

    return(hr);
    }

HRESULT WINAPI_16 ExpGetFolderList(IMPFOLDERNODE **pplist)
    {
    IMPFOLDERNODE *plist;
    HRESULT hr;

    if (pplist == NULL)
        return(E_INVALIDARG);

    plist = NULL;

    hr = ExpGetSubFolders(NULL, FOLDERID_LOCAL_STORE, &plist);
    if (FAILED(hr))
        {
        ExpFreeFolderList(plist);
        plist = NULL;
        }

    *pplist = plist;

    return(hr);
    }

void WINAPI_16 ExpFreeFolderList(IMPFOLDERNODE *plist)
    {
    IMPFOLDERNODE *pnode;

    while (plist != NULL)
        {
        if (plist->pchild != NULL)
            ExpFreeFolderList(plist->pchild);
        pnode = plist;
        plist = plist->pnext;
        MemFree(pnode);
        }
    }

void DoExport(HWND hwnd)
    {
    HRESULT hr;
    HMODULE hlibImport;
    PFNEXPMSGS lpfnExportMessages;

    hr = hrImportLoad;

    hlibImport = LoadLibrary(c_szImnimpDll);
    if (hlibImport != NULL)
        {
        lpfnExportMessages = (PFNEXPMSGS)GetProcAddress(hlibImport, MAKEINTRESOURCE(MAKELONG(3, 0)));
        if (lpfnExportMessages != NULL)
            {
            lpfnExportMessages(hwnd);
            hr = S_OK;
            }

        FreeLibrary(hlibImport);
        }

    if (FAILED(hr))
        {
        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrExport), hr);
        }
    }

typedef struct tagEXPENUM
    {
    IMessageFolder *pFolder;
    HROWSET hRowset;
    } EXPENUM;

HRESULT WINAPI_16 ExpGetFirstImsg(HANDLE idFolder, IMSG *pimsg, HANDLE_16 *phnd)
    {
    EXPENUM *penum;
    HRESULT hr;
    MESSAGEINFO MsgInfo;

    Assert(pimsg != NULL);
    Assert(phnd != NULL);
    *phnd = NULL;

    hr = E_FAIL;
    penum = NULL;

    if (!MemAlloc((void **)&penum, sizeof(EXPENUM)))
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        ZeroMemory(penum, sizeof(EXPENUM));

        hr = g_pStore->OpenFolder((FOLDERID)idFolder, NULL, NOFLAGS, &penum->pFolder);
        if (!FAILED(hr))
            {
            hr = penum->pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &penum->hRowset);
            if (!FAILED(hr))
                {
                hr = penum->pFolder->QueryRowset(penum->hRowset, 1, (LPVOID *)&MsgInfo, NULL);
                if (!FAILED(hr))
                    {
                    if (S_OK == hr)
                        {
                        hr = GetImsgFromFolder(penum->pFolder, &MsgInfo, pimsg);
                        penum->pFolder->FreeRecord(&MsgInfo);
                        }
                    else
                        Assert(S_FALSE == hr);
                    }
                }
            }
        }

    if (hr != S_OK)
        {
        ExpGetImsgClose((HANDLE_16)penum);
        penum = NULL;
        }

    *phnd = (HANDLE_16)penum;

    return(hr);
    }

HRESULT WINAPI_16 ExpGetNextImsg(IMSG *pimsg, HANDLE_16 hnd)
    {
    HRESULT hr;
    EXPENUM *pee;
    MESSAGEINFO MsgInfo;

    Assert(pimsg != NULL);
    Assert(hnd != NULL);

    pee = (EXPENUM *)hnd;

    hr = pee->pFolder->QueryRowset(pee->hRowset, 1, (LPVOID *)&MsgInfo, NULL);
    if (hr == S_OK)
        {
        hr = GetImsgFromFolder(pee->pFolder, &MsgInfo, pimsg);
        pee->pFolder->FreeRecord(&MsgInfo);
        }

    return(hr);
    }

void WINAPI_16 ExpGetImsgClose(HANDLE_16 hnd)
    {
    EXPENUM *pee;

    pee = (EXPENUM *)hnd;

    if (pee != NULL)
        {
        if (pee->pFolder != NULL)
            {
            pee->pFolder->CloseRowset(&pee->hRowset);
            pee->pFolder->Release();
            }

        MemFree(pee);
        }
    }

HRESULT GetImsgFromFolder(IMessageFolder *pfldr, LPMESSAGEINFO pMsgInfo, IMSG *pimsg)
    {
    LPMIMEMESSAGE   pMsg;
    HRESULT         hr =  E_OUTOFMEMORY;

    // for import/export we want the secure message, so pass TRUE
    hr = pfldr->OpenMessage(pMsgInfo->idMessage, OPEN_MESSAGE_SECURE, &pMsg, NOSTORECALLBACK);
    if (SUCCEEDED(hr))
        {
        hr = HrMailMsgToImsg(pMsg, pMsgInfo, pimsg);
        pMsg->Release();
        }            

    return(hr);
    }

void DoMigration(HWND hwnd)
    {
    HMODULE hlibImport;
    PFNPERFORMMIGRATION lpfnPerformMigration;
    CMailImporter *pImp;
    
    if (!!DwGetOption(OPT_MIGRATION_PERFORMED))
        return;

    hlibImport = LoadLibrary(c_szImnimpDll);
    if (hlibImport != NULL)
        {
        lpfnPerformMigration = (PFNPERFORMMIGRATION)GetProcAddress(hlibImport, achPerformMigration);
        if (lpfnPerformMigration != NULL)
            {
            pImp = new CMailImporter;
            if (pImp != NULL)
                {
                if (SUCCEEDED(pImp->Initialize(hwnd)) &&
                    SUCCEEDED(lpfnPerformMigration(hwnd, pImp, 0)))
                    {
                    SetDwOption(OPT_MIGRATION_PERFORMED, TRUE, NULL, 0);
                    }

                pImp->Release();
                }
            }

        FreeLibrary(hlibImport);
        }
    }


HRESULT SimpleImportMailFolders(
    IMailImporter *pMailImporter, 
    IMailImport *pMailImport, 
    DWORD_PTR dwSourceCookie, 
    DWORD_PTR dwParentDestCookie)
{
    HRESULT hr = S_OK;
    DWORD_PTR cookie;
    IMPORTFOLDER folder;
    IFolderImport *pFolderImport = NULL;
    IEnumFOLDERS *pFolderEnum = NULL;

    // Enumerate source folders
    IF_FAILEXIT(hr = pMailImport->EnumerateFolders(dwSourceCookie, &pFolderEnum));

    do {
        // Get next source folder
        hr = pFolderEnum->Next(&folder);
        if (hr == S_OK) {
            // Open the destination folder by this name in this hierarchy position
            hr = pMailImporter->OpenFolder(dwParentDestCookie,
                                           folder.szName, 
                                           FOLDER_TYPE_NORMAL, 
                                           0, 
                                           &pFolderImport, 
                                           &cookie);
            if (!FAILED(hr)) {
                // Import the enumerated source folder into the opened destination folder
                pMailImport->ImportFolder(folder.dwCookie, pFolderImport);

                // Close the destination folder
                SafeRelease(pFolderImport);

                if (folder.fSubFolders > 0) {
                    // Recursively import subfolders
                    SimpleImportMailFolders(pMailImporter, pMailImport, folder.dwCookie, cookie);
                }
            }
        }
    } while (hr == S_OK);

exit:
    SafeRelease(pFolderImport);
    SafeRelease(pFolderEnum);

    return hr;
}


HRESULT SimpleImportNewsList(CMessageStore *pSrcStore)
    {
    HRESULT hr = S_OK;
    IEnumerateFolders *pEnum = NULL;
    FOLDERINFO info;

    IF_FAILEXIT(hr = pSrcStore->EnumChildren(FOLDERID_ROOT, TRUE, &pEnum));

    while (S_OK == pEnum->Next(1, &info, NULL)) {
        // info.pszName is the server/account name
        // info.pszAccountId is the source's account ID
        // info.idFolder is this account's folder ID
        // info.dwFlags contains FOLDER_HASCHILDREN
        // info.tyFolder specifies FOLDER_NEWS

        if ((info.tyFolder == FOLDER_NEWS) &&
            (info.dwFlags & FOLDER_HASCHILDREN)) {

            IImnAccount *pAccount = NULL;
            
            // Match this account to the destination
            hr = g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, info.pszName, &pAccount);

            if ((hr == S_OK) && (pAccount != NULL)) {
                TCHAR szID[CCHMAX_ACCOUNT_NAME];

                hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szID, ARRAYSIZE(szID));

                if (hr == S_OK) {
                    IEnumerateFolders *pEnumDest = NULL;
                    IEnumerateFolders *pEnumChild = NULL;
                    FOLDERID destFolderID = 0;

                    // Lookup destination folder id for this account name
                    hr = g_pStore->EnumChildren(FOLDERID_ROOT, TRUE, &pEnumDest);
                    if ((hr == S_OK) && (pEnumDest != NULL)) {
                        FOLDERINFO infoDest;

                        while (S_OK == pEnumDest->Next(1, &infoDest, NULL)) {
                            if ((destFolderID == 0) &&
                                (_tcscmp(info.pszName, infoDest.pszName) == 0)) {
                                destFolderID = infoDest.idFolder;
                            }
                            g_pStore->FreeRecord(&infoDest);
                        }
                    }
                    SafeRelease(pEnumDest);

                    // Read in source newsgroups
                    hr = pSrcStore->EnumChildren(info.idFolder, TRUE, &pEnumChild);

                    if ((hr == S_OK) && (pEnumChild != NULL)) {

                        FOLDERINFO infoChild;

                        // Add folders to destination account
                        while(S_OK == pEnumChild->Next(1, &infoChild, NULL)) {
                            LPSTR oldID;

                            // infoChild.idParent needs to be the dest server folder ID

                            oldID = infoChild.pszAccountId;
                            infoChild.pszAccountId = szID;
                            infoChild.idParent = destFolderID;

                            hr = g_pStore->CreateFolder(CREATE_FOLDER_LOCALONLY, &infoChild, NOSTORECALLBACK);
                            if (SUCCEEDED(hr)) {
                                hr = g_pStore->SubscribeToFolder(infoChild.idFolder, TRUE, NULL);
                            }
                            infoChild.pszAccountId = oldID;

                            pSrcStore->FreeRecord(&infoChild);
                        }
                    }
                    SafeRelease(pEnumChild);
                }
            }
            SafeRelease(pAccount);
        }
        pSrcStore->FreeRecord(&info);
    }


exit:
    SafeRelease(pEnum);

    return hr;
}


HRESULT ImportMailStoreToGUID(IMailImport *pMailImport, GUID *pDestUUID, LPCSTR pszDestStoreDir)
    {
    HRESULT hr = S_OK;

    CMailImporter *pNew=NULL;
    pNew = new CMailImporter;
    IF_NULLEXIT(pNew);

    // Sometimes during the SimpleStoreInit, Wab is initialized as well.
    // Since it is never terminated, some registry key will remain opened.
    // The consumer of this function will not be able to unload a mapped user
    // hive because of this. To fix this problem, we added the Wab init here
    // and an corresponding Wab done later on.
    HrInitWab (TRUE);

    IF_FAILEXIT(SimpleStoreInit(pDestUUID, pszDestStoreDir));

    IF_FAILEXIT(SimpleImportMailFolders(pNew, pMailImport, COOKIE_ROOT, COOKIE_ROOT));
 
exit:
    SimpleStoreRelease();

    HrInitWab (FALSE);

    SafeRelease(pNew);

    return hr;
    }

HRESULT ImportNewsListToGUID(LPCSTR pszSrcPath, GUID *pDestUUID, LPCSTR pszDestStoreDir)
    {
    HRESULT hr = S_OK;

    CMessageStore *pSrcStore=NULL;
    pSrcStore = new CMessageStore(FALSE);
    IF_NULLEXIT(pSrcStore);

    IF_FAILEXIT(pSrcStore->Initialize(pszSrcPath));

    // Sometimes during the SimpleStoreInit, Wab is initialized as well.
    // Since it is never terminated, some registry key will remain opened.
    // The consumer of this function will not be able to unload a mapped user
    // hive because of this. To fix this problem, we added the Wab init here
    // and an corresponding Wab done later on.
    HrInitWab (TRUE);

    IF_FAILEXIT(SimpleStoreInit(pDestUUID, pszDestStoreDir));

    IF_FAILEXIT(SimpleImportNewsList(pSrcStore));

exit:
    SimpleStoreRelease();

    HrInitWab (FALSE);

    SafeRelease(pSrcStore);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\inetcfg.h ===
#ifndef _INC_INETCFG
#define _INC_INETCFG

#define ICW_MAIL_START  0x0001  // we started up with a mail argument
#define ICW_NEWS_START  0x0002  // we started up with a news argument
#define ICW_MAIL_DEF    0x0010  // default mail thing has been done
#define ICW_NEWS_DEF    0x0020  // default news thing has been done
#define ICW_INCOMPLETE  0x0040  // incomplete accounts thing has been done

void SetStartFolderType(FOLDERTYPE ft);
HRESULT ProcessICW(HWND hwnd, FOLDERTYPE ft, BOOL fForce = FALSE, BOOL fShowUI = TRUE);

void ProcessIncompleteAccts(HWND hwnd);

HRESULT NeedToRunICW(LPCSTR pszCmdLine);

void DoAcctImport(HWND hwnd, BOOL fMail);

#endif // _INC_INETCFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\common\inetcfg.cpp ===
#include "pch.hxx"
#include "strconst.h"
#include "error.h"
#include "acctutil.h"
#include "inetcfg.h"
#include <icwcfg.h>
#include "impapi.h"
#include <options.h>
#include <shlwapi.h>
#include "shlwapip.h" 
#include "regutil.h"
#include <resource.h>
#include "instance.h"
#include <browser.h>
#include <multiusr.h>
#include "demand.h"

ASSERTDATA

void HandleIncompleteAccts(HWND hwnd, BOOL fMail);

DWORD g_dwIcw