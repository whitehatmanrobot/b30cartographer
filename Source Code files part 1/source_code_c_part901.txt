iven.
*
* This function should only be called when the calling thread has the
* devlock to ensure that there is no client region change.
*
* History:
*  Thu Jan 13 09:55:23 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" VOID WNDOBJ_vSetConsumer(
WNDOBJ  *_pwo,
PVOID   pvConsumer)
{
    PEWNDOBJ pwo = (PEWNDOBJ)_pwo;

    DBGENTRY("WNDOBJ_vSetConsumer\n");

    ASSERTGDI(pwo->bValid(), "WNDOBJ_vSetConsumer: Invalid pwo\n");

// We need to ensure that the caller holds the devlock before calling this
// function.  Otherwise, some other threads may be drawing into the wrong
// client region.

    if (pwo->hwnd)
    {
        CHECKDEVLOCKIN2(pwo->pto->pSurface);
    }

// Do not allow changes to surface wndobj.  One reason is that there is
// no delete notification for surface wndobj.

    if (pwo == pwo->pto->pwoSurf)
    {
        KdPrint(("WNDOBJ_vSetConsumer: cannot modify surface wndobj!\n"));
        return;
    }

    pwo->pvConsumer = pvConsumer;
}

/******************************Member*Function*****************************\
* EWNDOBJ::vOffset
*
* Offset the WNDOBJ by some vector.
\**************************************************************************/

VOID EWNDOBJ::vOffset(LONG x, LONG y)
{
    if ((x != 0) || (y != 0))
    {
        EPOINTL eptl(x, y);
    
        bOffset(&eptl);
        *((ERECTL*) &rclBounds) += eptl;
        *((ERECTL*) &rclClient) += eptl;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\ylateddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: xlateddi.cxx
*
* This provides the interface for device drivers to call functions
* for xlate objects.
*
* Created: 26-Nov-1990 16:40:24
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* XLATEOBJ_piVector
*
* Returns the translation vector if one exists.
*
* History:
*  03-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PULONG XLATEOBJ_piVector(XLATEOBJ *pxlo)
{
    //
    // This is really strange to have a call back, but the theory was that
    // it could be lazily computed and some drivers would choose to compute
    // it themselves (maybe with hardware help).  Anyhow we know of no driver
    // or hardware that would benefit from this so we just compute it up
    // front every time anyhow.  Drivers are written to check for NULL first
    // and call this routine if it's NULL.
    //

    return(pxlo->pulXlate);
}

/******************************Public*Routine******************************\
* XLATEOBJ_cGetPalette
*
* Used to retrieve information about the palettes used in the blt.
*
* History:
*  03-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG XLATEOBJ_cGetPalette(
XLATEOBJ *pxlo,
ULONG iPal,
ULONG cPal,
PULONG ppal)
{
    ULONG ulRet = 0;            // Assume failure

    ASSERTGDI((iPal == XO_SRCPALETTE)   ||
              (iPal == XO_DESTPALETTE)  ||
              (iPal == XO_SRCBITFIELDS) ||
              (iPal == XO_DESTBITFIELDS),
        "ERROR XLATEOBJ_cGetPalette passed undefined iPal");

    if (pxlo != NULL)
    {
        XLATE *pxl = (XLATE *) pxlo;

        if ((iPal == XO_SRCBITFIELDS) || (iPal == XO_DESTBITFIELDS))
        {
            XEPALOBJ pal((iPal == XO_SRCBITFIELDS) ? pxl->ppalSrc : pxl->ppalDst);

            if ((pal.bValid())        &&        // Must be valid
                (pal.cEntries() == 0) &&        // Must be RGB
                (cPal == 3))                    // Must have room for 3 entries
            {
                ulRet = 3;

                *(ppal)     = pal.flRed();
                *(ppal + 1) = pal.flGre();
                *(ppal + 2) = pal.flBlu();
            }
            else
            {
                WARNING("XLATEOBJ_cGetPalette failed - not bitfields, or cPal != 3");
            }
        }
        else
        {
            XEPALOBJ pal((iPal == XO_SRCPALETTE) ? pxl->ppalSrc : pxl->ppalDst);

            if (pal.bValid())
            {
                ulRet = pal.ulGetEntries(0, cPal, (LPPALETTEENTRY) ppal, TRUE);
            }
        }
    }
    else
    {
        WARNING("XLATEOBJ_cGetPalette failed - xlate invalid or identiy, no palette informinformation\n");
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* XLATEOBJ_hGetColorTransform
*
* returns color transform handle.
*
* History:
*  03-Feb-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

HANDLE
XLATEOBJ_hGetColorTransform(XLATEOBJ *pxlo)
{
    XLATE *pxl = (XLATE *) pxlo;

    ICMAPI(("XLATEOBJ_hGetColorTransform()\n"));

    //
    // Since our global identity xlate is invalid we need to check for
    // this case since drivers can't tell.
    //
    if (pxl == NULL)
    {
        WARNING("XLATEOBJ_hGetColorTransform() XLATEOBJ is NULL\n");
        return(NULL);
    }

    //
    // if ICM is not enabled for this XLATEOBJ. Or if ICM is done by host,
    // Color transform handle is for host ICM it is no meanings for device
    // driver. then just return NULL.
    //
    if (IS_ICM_DEVICE(pxl->lIcmMode))
    {
        if (pxl->hcmXform)
        {
            COLORTRANSFORMOBJ CXFormObj(pxl->hcmXform);

            if (CXFormObj.bValid())
            {
                return(CXFormObj.hGetDeviceColorTransform());
            }

            ICMMSG(("XLATEOBJ_hGetColorTransform() COLORTRANSFORMREF is invalid\n"));
        }
        else
        {
            ICMMSG(("XLATEOBJ_hGetColorTransform() Ident. color transform\n"));
        }
    }
    else
    {
        ICMMSG(("XLATEOBJ_hGetColorTransform() ICM on device is not enabled\n"));
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\xformobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: xformobj.cxx                                                *
*                                                                          *
* Xform object non-inline methods.                                         *
*                                                                          *
* Created: 12-Nov-1990 16:54:37                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.hxx"

extern "C" {
void __cdecl _fltused(void) {}              // just so that we link clean...
};

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)
#define vSetTo1Over16(ef)   (ef.e = EFLOAT_1Over16)
#else
#define vSetTo1Over16(ef)   (ef.i.lMant = 0x040000000, ef.i.lExp = -2)
#endif


/******************************Data*Structure******************************\
* matrixIdentity                                                           *
*                                                                          *
* Defines the identity transform matrices in different formats.            *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

MATRIX gmxIdentity_LToFx =
{
    EFLOAT_16,                                          // efM11
    EFLOAT_0,                                           // efM12
    EFLOAT_0,                                           // efM21
    EFLOAT_16,                                          // efM22
    EFLOAT_0,                                           // efDx
    EFLOAT_0,                                           // efDy
    0,                                                  // fxDx
    0,                                                  // fxDy
    XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION|XFORM_FORMAT_LTOFX
};

MATRIX gmxIdentity_LToL =
{
    EFLOAT_1,                                           // efM11
    EFLOAT_0,                                           // efM12
    EFLOAT_0,                                           // efM21
    EFLOAT_1,                                           // efM22
    EFLOAT_0,                                           // efDx
    EFLOAT_0,                                           // efDy
    0,                                                  // fxDx
    0,                                                  // fxDy
    XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION|XFORM_FORMAT_LTOL
};

MATRIX gmxIdentity_FxToL =
{
    EFLOAT_1Over16,                                     // efM11
    EFLOAT_0,                                           // efM12
    EFLOAT_0,                                           // efM21
    EFLOAT_1Over16,                                     // efM22
    EFLOAT_0,                                           // efDx
    EFLOAT_0,                                           // efDy
    0,                                                  // fxDx
    0,                                                  // fxDy
    XFORM_SCALE|XFORM_UNITY|XFORM_NO_TRANSLATION|XFORM_FORMAT_FXTOL
};

/******************************Member*Function*****************************\
* EXFORMOBJ::EXFORMOBJ                                                     *
*                                                                          *
* Get a transform matrix based on the request type.  The only legitimate   *
* type for now is IDENTITY.                                                *
*                                                                          *
* History:                                                                 *
*  27-Mar-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

EXFORMOBJ::EXFORMOBJ(ULONG iXform, ULONG iFormat)
{
    ASSERTGDI((iXform == IDENTITY),"XFORMOBJ:invalid iXform\n");
    bMirrored = FALSE;
    if (iFormat == XFORM_FORMAT_LTOFX)
        pmx = &gmxIdentity_LToFx;
    else if (iFormat == XFORM_FORMAT_FXTOL)
        pmx = &gmxIdentity_FxToL;
    else
        pmx = &gmxIdentity_LToL;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bEqual(EXFORMOBJ& xo)                                         *
*                                                                          *
* See if two transforms are identical.  Matrices of different formats are  *
* considered different even though the coefficients are same.              *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bEqual(EXFORMOBJ& xo)
{
    if (pmx == xo.pmx)
        return(TRUE);                   // point to the same matrix

// compare each and every element of the matrices as the structures may
// be padded.

    return ((pmx->efM11 == xo.pmx->efM11) && (pmx->efM12 == xo.pmx->efM12) &&
            (pmx->efM21 == xo.pmx->efM21) && (pmx->efM22 == xo.pmx->efM22) &&
            (pmx->efDx == xo.pmx->efDx) && (pmx->efDy == xo.pmx->efDy));
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bEqualExceptTranslations                                      *
*                                                                          *
* See if two transforms are identical other than the translations elements.*
* Matrices of different formats are considered different even though the   *
* coefficients are same.                                                   *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bEqualExceptTranslations(PMATRIX pmx_)
{
    if (pmx == pmx_)
        return(TRUE);                   // point to the same matrix

// compare each and every element of the matrices as the structures may
// be padded.

    return ((pmx->efM11 == pmx_->efM11) && (pmx->efM12 == pmx_->efM12) &&
            (pmx->efM21 == pmx_->efM21) && (pmx->efM22 == pmx_->efM22));
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of POINTL to a list of POINTL.                          *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PPOINTL pptlSrc,
PPOINTL pptlDst,
SIZE_T cPts)
{
    ASSERTGDI(cPts > 0, "Can take only positive count");
    ASSERTGDI( (((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOFX) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_FXTOL) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOL)),
                "EXFORMOBJ::bXformPtlToPtl: wrong xform format\n");

// copy the source to the dest,  This way we can use bCvtPts1 which is more efficient

    if (pptlSrc != pptlDst)
    {
        RtlCopyMemory(pptlDst, pptlSrc, cPts*sizeof(POINTL));
    }

// Straight copy if identity transform.

    if (bIdentity())
    {
        return(TRUE);
    }

    BOOL bReturn = bCvtPts1(pmx, pptlDst, cPts);

    if (!bReturn)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    return(bReturn);
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of POINTL to a list of POINTFIX.                         *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PPOINTL pptlSrc,
PPOINTFIX pptfxDst,
SIZE_T cPts)
{
    ASSERTGDI(cPts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "EXFORMOBJ::bXformPtlToPtfx: wrong xform format\n");

// Convert a list of POINTL to a list of POINTFIX if identity transform.

    if (bIdentity())
    {
        PPOINTL pptlSrcEnd = pptlSrc + cPts;

        for ( ; pptlSrc < pptlSrcEnd; pptlSrc++, pptfxDst++)
        {
            pptfxDst->x = LTOFX(pptlSrc->x);
            pptfxDst->y = LTOFX(pptlSrc->y);
        }

        return(TRUE);
    }

    BOOL bRet = bCvtPts(pmx, pptlSrc, (PPOINTL)pptfxDst, cPts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXformRound                                                   *
*                                                                          *
* Transform a list of POINTL to a list of POINTFIX.  Round the resulting   *
* points to the nearest integers for Win31 compatibility.                  *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXformRound(
PPOINTL pptlSrc,
PPOINTFIX pptfxDst,
SIZE_T cPts)
{
    ASSERTGDI(cPts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "EXFORMOBJ::bXformPtlToPtfx: wrong xform format\n");

// Convert a list of POINTL to a list of POINTFIX if identity transform.

    if (bIdentity())
    {
        PPOINTL pptlSrcEnd = pptlSrc + cPts;

        for ( ; pptlSrc < pptlSrcEnd; pptlSrc++, pptfxDst++)
        {
            pptfxDst->x = LTOFX(pptlSrc->x);
            pptfxDst->y = LTOFX(pptlSrc->y);
        }

        return(TRUE);
    }

    BOOL bRet = bCvtPts(pmx, pptlSrc, (PPOINTL)pptfxDst, cPts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    if (ulMode != GM_ADVANCED)
    {
        PPOINTFIX pptfxDstEnd = pptfxDst + cPts;

        for ( ; pptfxDst < pptfxDstEnd; pptfxDst++)
        {
            pptfxDst->x = (pptfxDst->x + FIX_HALF) & 0xFFFFFFF0;
            pptfxDst->y = (pptfxDst->y + FIX_HALF) & 0xFFFFFFF0;
        }
    }

    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of POINTFIX to a list of POINTL.                        *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PPOINTFIX pptfxSrc,
PPOINTL pptlDst,
SIZE_T cPts)
{
    ASSERTGDI(cPts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_FXTOL),
              "EXFORMOBJ::bXformPtfxToPtl: wrong xform format\n");

// Convert a list of POINTFIX to a list of POINTL if identity transform.

    if (bIdentity())
    {
        PPOINTFIX pptfxSrcEnd = pptfxSrc + cPts;

        for ( ; pptfxSrc < pptfxSrcEnd; pptfxSrc++, pptlDst++)
        {
            pptlDst->x = FXTOLROUND(pptfxSrc->x);
            pptlDst->y = FXTOLROUND(pptfxSrc->y);
        }

        return(TRUE);                       // never overflows
    }

    BOOL bRet = bCvtPts(pmx, (PPOINTL)pptfxSrc, pptlDst, cPts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    return bRet;

}

/******************************Member*Function*****************************\
* BOOL EXFORMOBJ::bXform
*
*  Given a list of vectors (pptflSrc) and number of points in the list (cVts)
*  transform the vectors and store into another list (pptflDst).
*
* History:
*  28-Jan-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PVECTORFL pvtflSrc,
PVECTORFL pvtflDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");

// check for quick exit, if the transform consists of translations
// only, there is nothing to do:

    if (bTranslationsOnly())
    {
        if (pvtflDst != pvtflSrc)  // if not transforming in place
        {
            RtlCopyMemory(pvtflDst, pvtflSrc, cVts*sizeof(VECTORFL));
        }

        return(TRUE);
    }

    BOOL bRet;

    if (pmx->flAccel & XFORM_FORMAT_LTOL)
    {
        bRet = bCvtVts_FlToFl(pmx, pvtflSrc, pvtflDst, cVts);
    }
    else if (pmx->flAccel & XFORM_FORMAT_LTOFX)
    {
        pmx->efM11.vDivBy16();
        pmx->efM12.vDivBy16();
        pmx->efM21.vDivBy16();
        pmx->efM22.vDivBy16();

        bRet = bCvtVts_FlToFl(pmx, pvtflSrc, pvtflDst, cVts);

        pmx->efM11.vTimes16();
        pmx->efM12.vTimes16();
        pmx->efM21.vTimes16();
        pmx->efM22.vTimes16();
    }
    else
    {
        pmx->efM11.vTimes16();
        pmx->efM12.vTimes16();
        pmx->efM21.vTimes16();
        pmx->efM22.vTimes16();

        bRet = bCvtVts_FlToFl(pmx, pvtflSrc, pvtflDst, cVts);

        pmx->efM11.vDivBy16();
        pmx->efM12.vDivBy16();
        pmx->efM21.vDivBy16();
        pmx->efM22.vDivBy16();
    }

    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of VECTORL to a list of VECTORL.                        *
*                                                                          *
* History:                                                                 *
*  28-Jan-1992 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PVECTORL pvtlSrc,
PVECTORL pvtlDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");

// Straight copy if identity transform.

    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "EXFORMOBJ::bXformVtlToVtl: wrong xform format\n");

    if (bTranslationsOnly())
    {
        if (pvtlDst != pvtlSrc)
        {
            RtlCopyMemory(pvtlDst, pvtlSrc, cVts*sizeof(VECTORL));
            return(TRUE);
        }
    }

    pmx->efM11.vDivBy16();
    pmx->efM12.vDivBy16();
    pmx->efM21.vDivBy16();
    pmx->efM22.vDivBy16();

    BOOL bReturn = bCvtVts(pmx, pvtlSrc, pvtlDst, cVts);

    pmx->efM11.vTimes16();
    pmx->efM12.vTimes16();
    pmx->efM21.vTimes16();
    pmx->efM22.vTimes16();

    if (!bReturn)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    return(bReturn);
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of VECTORL to a list of VECTORFX.                       *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PVECTORL pvtlSrc,
PVECTORFX pvtfxDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "XFORMOBJ::bXformVtlToVtfx: wrong xform format\n");

// Convert a list of VECTORL to a list of VECTORFX if identity transform.

    if (bTranslationsOnly())
    {
        PVECTORL pvtlSrcEnd = pvtlSrc + cVts;

        for ( ; pvtlSrc < pvtlSrcEnd; pvtlSrc++, pvtfxDst++)
        {
            if (BLTOFXOK(pvtlSrc->x) && BLTOFXOK(pvtlSrc->y))
            {
                pvtfxDst->x = LTOFX(pvtlSrc->x);
                pvtfxDst->y = LTOFX(pvtlSrc->y);
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
                return(FALSE);
            }
        }
        return(TRUE);
    }

    BOOL bRet = bCvtVts(pmx, pvtlSrc, (PVECTORL)pvtfxDst, cVts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXformRound                                                   *
*                                                                          *
* Transform a list of VECTORL to a list of VECTORFIX.  Round the resulting *
* vectors to the nearest integers for Win31 compatibility.                 *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXformRound(
PVECTORL pvtlSrc,
PVECTORFX pvtfxDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_LTOFX),
              "XFORMOBJ::bXformVtlToVtfx: wrong xform format\n");

// Convert a list of VECTORL to a list of VECTORFX if identity transform.

    if (bTranslationsOnly())
    {
        PVECTORL pvtlSrcEnd = pvtlSrc + cVts;

        for ( ; pvtlSrc < pvtlSrcEnd; pvtlSrc++, pvtfxDst++)
        {
            if (BLTOFXOK(pvtlSrc->x) && BLTOFXOK(pvtlSrc->y))
            {
                pvtfxDst->x = LTOFX(pvtlSrc->x);
                pvtfxDst->y = LTOFX(pvtlSrc->y);
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
                return(FALSE);
            }
        }
        return(TRUE);
    }

    BOOL bRet = bCvtVts(pmx, pvtlSrc, (PVECTORL)pvtfxDst, cVts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);

    if (ulMode != GM_ADVANCED)
    {
        PVECTORFX pvtfxDstEnd = pvtfxDst + cVts;

        for ( ; pvtfxDst < pvtfxDstEnd; pvtfxDst++)
        {
            pvtfxDst->x = (pvtfxDst->x + FIX_HALF) & 0xFFFFFFF0;
            pvtfxDst->y = (pvtfxDst->y + FIX_HALF) & 0xFFFFFFF0;
        }
    }
    return bRet;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bXform                                                        *
*                                                                          *
* Transform a list of VECTORFX to a list of VECTORL.                       *
*                                                                          *
* History:                                                                 *
*  06-Feb-1992 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bXform(
PVECTORFX pvtfxSrc,
PVECTORL pvtlDst,
SIZE_T cVts)
{
    ASSERTGDI(cVts > 0, "Can take only positive count");
    ASSERTGDI((pmx->flAccel & XFORM_FORMAT_FXTOL),
              "EXFORMOBJ::bXformVtfxToVtl: wrong xform format\n");

// Convert a list of VECTORFX to a list of VECTORL if identity transform.

    if (bTranslationsOnly())
    {
        PVECTORFX pvtfxSrcEnd = pvtfxSrc + cVts;

        for ( ; pvtfxSrc < pvtfxSrcEnd; pvtfxSrc++, pvtlDst++)
        {
            pvtlDst->x = FXTOL(pvtfxSrc->x);
            pvtlDst->y = FXTOL(pvtfxSrc->y);
        }

        return(TRUE);
    }

    BOOL bRet = bCvtVts(pmx, (PVECTORL)pvtfxSrc, pvtlDst, cVts);
    if (!bRet)
        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
    return bRet;

}

/******************************Member*Function*****************************\
* EXFORMOBJ::vComputeAccelFlags                                            *
*                                                                          *
* Set the accelerator flags for a given matrix.                            *
*                                                                          *
* History:                                                                 *
*  06-Dec-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vComputeAccelFlags(FLONG flFormat)
{
    pmx->flAccel = flFormat;                        // clear the flag

// set translation flag

    if ((pmx->fxDx == 0) && (pmx->fxDy == 0))
        pmx->flAccel |= XFORM_NO_TRANSLATION;

    if (pmx->efM12.bIsZero() && pmx->efM21.bIsZero())
    {
    // off diagonal elements are zeros

        pmx->flAccel |= XFORM_SCALE;

        switch(flFormat)
        {
        case XFORM_FORMAT_LTOFX:
            if (pmx->efM11.bIs16() && pmx->efM22.bIs16())
                pmx->flAccel |= XFORM_UNITY;
            break;

        case XFORM_FORMAT_LTOL:
            if (pmx->efM11.bIs1() && pmx->efM22.bIs1())
                pmx->flAccel |= XFORM_UNITY;
            break;

        default:
            if (pmx->efM11.bIs1Over16() && pmx->efM22.bIs1Over16())
                pmx->flAccel |= XFORM_UNITY;
            break;
        }
    }
}

/******************************Member*Function*****************************\
* EXFORMOBJ::vCopy(EXFORMOBJ& xo)                                          *
*                                                                          *
* Copy the coefficient values of a transform to another.                   *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vCopy(EXFORMOBJ& xo)
{
    RtlCopyMemory(pmx, xo.pmx, sizeof(MATRIX));
}

/******************************Member*Function*****************************\
* EXFORMOBJ::vRemoveTranslation()                                          *
*                                                                          *
* Remove the translation coefficients of a transform.                      *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vRemoveTranslation()
{
    pmx->fxDx = 0;
    pmx->fxDy = 0;
    pmx->efDx.vSetToZero();
    pmx->efDy.vSetToZero();
    pmx->flAccel |= XFORM_NO_TRANSLATION;
}

/******************************Member*Function*****************************\
* EXFORMOBJ::vGetCoefficient()                                             *
*                                                                          *
* Get the coefficient of a transform matrix.  This is used to convert      *
* our internal matrix structure into the GDI/DDI transform format.         *
*                                                                          *
* History:                                                                 *
*  12-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vGetCoefficient(XFORML *pxf)
{
// The coefficients have already been range-checked before they are set
// in the DC.  So it's just a matter of converting them back to
// IEEE FLOAT.  They can't possibly overflow.

// For i386, lEfToF() calls off to the assembly routine to do the EFLOAT
// to FLOAT conversion and put the result in eax, we want the C compiler
// to do direct copy to the destination here(no fstp), so some casting
// is necessary.  Note the return type of lEfToF() is LONG.  We do the
// same thing for MIPS so the code here can be shared.

    ASSERTGDI( (((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOFX) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_FXTOL) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOL)),
                "EXFORMOBJ::vGetCoefficient: wrong xform format\n");

    if (pmx->flAccel & XFORM_FORMAT_LTOFX)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vDivBy16();
        mxTmp.efM12.vDivBy16();
        mxTmp.efM21.vDivBy16();
        mxTmp.efM22.vDivBy16();
        mxTmp.efDx.vDivBy16();
        mxTmp.efDy.vDivBy16();

        *(LONG *)&pxf->eM11 = mxTmp.efM11.lEfToF();
        *(LONG *)&pxf->eM12 = mxTmp.efM12.lEfToF();
        *(LONG *)&pxf->eM21 = mxTmp.efM21.lEfToF();
        *(LONG *)&pxf->eM22 = mxTmp.efM22.lEfToF();
        *(LONG *)&pxf->eDx = mxTmp.efDx.lEfToF();
        *(LONG *)&pxf->eDy = mxTmp.efDy.lEfToF();

    }
    else if (pmx->flAccel & XFORM_FORMAT_FXTOL)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vTimes16();
        mxTmp.efM12.vTimes16();
        mxTmp.efM21.vTimes16();
        mxTmp.efM22.vTimes16();

        *(LONG *)&pxf->eM11 = mxTmp.efM11.lEfToF();
        *(LONG *)&pxf->eM12 = mxTmp.efM12.lEfToF();
        *(LONG *)&pxf->eM21 = mxTmp.efM21.lEfToF();
        *(LONG *)&pxf->eM22 = mxTmp.efM22.lEfToF();
        *(LONG *)&pxf->eDx = mxTmp.efDx.lEfToF();
        *(LONG *)&pxf->eDy = mxTmp.efDy.lEfToF();

    }
    else
    {
        *(LONG *)&pxf->eM11 = pmx->efM11.lEfToF();
        *(LONG *)&pxf->eM12 = pmx->efM12.lEfToF();
        *(LONG *)&pxf->eM21 = pmx->efM21.lEfToF();
        *(LONG *)&pxf->eM22 = pmx->efM22.lEfToF();
        *(LONG *)&pxf->eDx = pmx->efDx.lEfToF();
        *(LONG *)&pxf->eDy = pmx->efDy.lEfToF();
    }

    return;
}


/******************************Member*Function*****************************\
* EXFORMOBJ::vGetCoefficient()                                             *
*                                                                          *
* Get the coefficient of a transform matrix.  This is to convert EFLOAT's  *
* into FLOATOBJs which are now the same.                                   *
*                                                                          *
* History:                                                                 *
*  13-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.                                                                *
\**************************************************************************/

VOID EXFORMOBJ::vGetCoefficient(PFLOATOBJ_XFORM pxf)
{
// The coefficients have already been range-checked before they are set
// in the DC.  So it's just a matter of converting them back to
// IEEE FLOAT.  They can't possibly overflow.

// For i386, lEfToF() calls off to the assembly routine to do the EFLOAT
// to FLOAT conversion and put the result in eax, we want the C compiler
// to do direct copy to the destination here(no fstp), so some casting
// is necessary.  Note the return type of lEfToF() is LONG.  We do the
// same thing for MIPS so the code here can be shared.

    ASSERTGDI( (((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOFX) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_FXTOL) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOL)),
                "EXFORMOBJ::vGetCoefficient: wrong xform format\n");

    if (pmx->flAccel & XFORM_FORMAT_LTOFX)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vDivBy16();
        mxTmp.efM12.vDivBy16();
        mxTmp.efM21.vDivBy16();
        mxTmp.efM22.vDivBy16();
        mxTmp.efDx.vDivBy16();
        mxTmp.efDy.vDivBy16();

        *(EFLOAT *)&pxf->eM11 = mxTmp.efM11;
        *(EFLOAT *)&pxf->eM12 = mxTmp.efM12;
        *(EFLOAT *)&pxf->eM21 = mxTmp.efM21;
        *(EFLOAT *)&pxf->eM22 = mxTmp.efM22;
        *(EFLOAT *)&pxf->eDx  = mxTmp.efDx;
        *(EFLOAT *)&pxf->eDy  = mxTmp.efDy;
    }
    else if (pmx->flAccel & XFORM_FORMAT_FXTOL)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vTimes16();
        mxTmp.efM12.vTimes16();
        mxTmp.efM21.vTimes16();
        mxTmp.efM22.vTimes16();

        *(EFLOAT *)&pxf->eM11 = mxTmp.efM11;
        *(EFLOAT *)&pxf->eM12 = mxTmp.efM12;
        *(EFLOAT *)&pxf->eM21 = mxTmp.efM21;
        *(EFLOAT *)&pxf->eM22 = mxTmp.efM22;
        *(EFLOAT *)&pxf->eDx  = mxTmp.efDx;
        *(EFLOAT *)&pxf->eDy  = mxTmp.efDy;

    }
    else
    {
        *(EFLOAT *)&pxf->eM11 = pmx->efM11;
        *(EFLOAT *)&pxf->eM12 = pmx->efM12;
        *(EFLOAT *)&pxf->eM21 = pmx->efM21;
        *(EFLOAT *)&pxf->eM22 = pmx->efM22;
        *(EFLOAT *)&pxf->eDx  = pmx->efDx;
        *(EFLOAT *)&pxf->eDy  = pmx->efDy;
    }

    return;
}


/******************************Member*Function*****************************\
* EXFORMOBJ::vGetCoefficient()
*
* Get the coefficient of a transform matrix.  This is used to convert
* our internal matrix structure into the IFI transform format.
*
* History:
*  04-Feb-1992 -by- Gilman Wong [gilmanw]
* Adapted from vGetCoefficient.
\**************************************************************************/

VOID EXFORMOBJ::vGetCoefficient(PFD_XFORM pfd_xf)
{
// The coefficients have already been range-checked before they are set
// in the DC.  So it's just a matter of converting them back to
// IEEE FLOAT.  They can't possibly overflow.

// For i386, lEfToF() calls off to the assembly routine to do the EFLOAT
// to FLOAT conversion and put the result in eax, we want the C compiler
// to do direct copy to the destination here(no fstp), so some casting
// is necessary.  Note the return type of lEfToF() is LONG.  We do the
// same thing for MIPS so the code here can be shared.

    ASSERTGDI( (((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOFX) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_FXTOL) ||
                ((pmx->flAccel & XFORM_FORMAT) == XFORM_FORMAT_LTOL)),
                "EXFORMOBJ::vGetCoefficient: wrong xform format\n");

    if (pmx->flAccel & XFORM_FORMAT_LTOFX)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vDivBy16();
        mxTmp.efM12.vDivBy16();
        mxTmp.efM21.vDivBy16();
        mxTmp.efM22.vDivBy16();

        *(LONG *)&pfd_xf->eXX = mxTmp.efM11.lEfToF();
        *(LONG *)&pfd_xf->eXY = mxTmp.efM12.lEfToF();
        *(LONG *)&pfd_xf->eYX = mxTmp.efM21.lEfToF();
        *(LONG *)&pfd_xf->eYY = mxTmp.efM22.lEfToF();
    }
    else if (pmx->flAccel & XFORM_FORMAT_FXTOL)
    {
        MATRIX  mxTmp;
        mxTmp = *pmx;

        mxTmp.efM11.vTimes16();
        mxTmp.efM12.vTimes16();
        mxTmp.efM21.vTimes16();
        mxTmp.efM22.vTimes16();

        *(LONG *)&pfd_xf->eXX = mxTmp.efM11.lEfToF();
        *(LONG *)&pfd_xf->eXY = mxTmp.efM12.lEfToF();
        *(LONG *)&pfd_xf->eYX = mxTmp.efM21.lEfToF();
        *(LONG *)&pfd_xf->eYY = mxTmp.efM22.lEfToF();
    }
    else
    {
        *(LONG *)&pfd_xf->eXX = pmx->efM11.lEfToF();
        *(LONG *)&pfd_xf->eXY = pmx->efM12.lEfToF();
        *(LONG *)&pfd_xf->eYX = pmx->efM21.lEfToF();
        *(LONG *)&pfd_xf->eYY = pmx->efM22.lEfToF();
    }

    return;
}


/******************************Member*Function*****************************\
* EXFORMOBJ::vOrder(RECTL &rcl)
*
* Order a rectangle based on the given transform.  The rectangle will be
* well ordered after the transform is applied.  Note that the off-diagonal
* elements of the transform MUST be zero's.  ie. only scaling is allowed.
*
* History:
*  18-Dec-1990 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID EXFORMOBJ::vOrder(RECTL &rcl)
{
    LONG    lTmp;

    ASSERTGDI(bScale(), "vOrder error: not scaling transform");

    if ((pmx->efM11.bIsNegative() && (rcl.left < rcl.right)) ||
        (!pmx->efM11.bIsNegative() && (rcl.left > rcl.right)))
    {
            SWAPL(rcl.left, rcl.right, lTmp);
    }

    if ((pmx->efM22.bIsNegative() && (rcl.top < rcl.bottom)) ||
        (!pmx->efM22.bIsNegative() && (rcl.top > rcl.bottom)))
    {
            SWAPL(rcl.top, rcl.bottom, lTmp);
    }
}



/******************************Member*Function*****************************\
* bMultiply(PMATRIX pmxLeft, PMATRIX pmxRight)                             *
*                                                                          *
* Multiply two matrices together.  Put the results in the XFORMOBJ.        *
* The target matrix CANNOT be the same as either of the two src matrices.  *
*                                                                          *
* History:                                                                 *
*  Fri 20-Mar-1992 13:54:28 -by- Charles Whitmer [chuckwh]                 *
* Rewrote with new EFLOAT math operations.  We should never do any         *
* operations like efA=efB*efC+efD!  They generate intensely bad code.      *
*                                                                          *
*  19-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bMultiply(PMATRIX pmxLeft, PMATRIX pmxRight, FLONG fl)
{

    MATRIX *pmxTemp = pmx;

    ASSERTGDI((pmx != pmxLeft), "bMultiply error: pmx == pmxLeft\n");
    ASSERTGDI((pmx != pmxRight), "bMultiply error: pmx == pmxRight\n");

    EFLOAT efA,efB;

    if (pmxLeft->efM12.bIsZero() && pmxLeft->efM21.bIsZero() &&
        pmxRight->efM12.bIsZero() && pmxRight->efM21.bIsZero())
    {
        pmxTemp->efM11.eqMul(pmxLeft->efM11,pmxRight->efM11);
        pmxTemp->efM22.eqMul(pmxLeft->efM22,pmxRight->efM22);
        pmxTemp->efM12.vSetToZero();
        pmxTemp->efM21.vSetToZero();
    }
    else
    {
    // calculate the first row of the results

        efA.eqMul(pmxLeft->efM11,pmxRight->efM11);
        efB.eqMul(pmxLeft->efM12,pmxRight->efM21);
        pmxTemp->efM11.eqAdd(efA,efB);

        efA.eqMul(pmxLeft->efM11,pmxRight->efM12);
        efB.eqMul(pmxLeft->efM12,pmxRight->efM22);
        pmxTemp->efM12.eqAdd(efA,efB);

    // calculate the second row of the results

        efA.eqMul(pmxLeft->efM21,pmxRight->efM11);
        efB.eqMul(pmxLeft->efM22,pmxRight->efM21);
        pmxTemp->efM21.eqAdd(efA,efB);

        efA.eqMul(pmxLeft->efM21,pmxRight->efM12);
        efB.eqMul(pmxLeft->efM22,pmxRight->efM22);
        pmxTemp->efM22.eqAdd(efA,efB);
    }

// calculate the translation

    if (pmxLeft->efDx.bIsZero() && pmxLeft->efDy.bIsZero())
    {
        pmxTemp->efDx = pmxRight->efDx;
        pmxTemp->efDy = pmxRight->efDy;
        pmxTemp->fxDx = pmxRight->fxDx;
        pmxTemp->fxDy = pmxRight->fxDy;
    }
    else
    {
        efA.eqMul(pmxLeft->efDx,pmxRight->efM11);
        efB.eqMul(pmxLeft->efDy,pmxRight->efM21);
        efB.eqAdd(efB,pmxRight->efDx);
        pmxTemp->efDx.eqAdd(efA,efB);

        efA.eqMul(pmxLeft->efDx,pmxRight->efM12);
        efB.eqMul(pmxLeft->efDy,pmxRight->efM22);
        efB.eqAdd(efB,pmxRight->efDy);
        pmxTemp->efDy.eqAdd(efA,efB);

        if (!pmxTemp->efDx.bEfToL(pmxTemp->fxDx))
            return(FALSE);

        if (!pmxTemp->efDy.bEfToL(pmxTemp->fxDy))
            return(FALSE);
    }

    if (fl & COMPUTE_FLAGS)
        vComputeAccelFlags(fl & XFORM_FORMAT);

    return(TRUE);
}

/******************************Member*Function*****************************\
* EXFORMOBJ::bInverse(MATRIX& mxSrc)                                       *
*                                                                          *
* Calculate the inverse of a given matrix.                                 *
*                                                                          *
* The inverse is calculated as follows:                                    *
*                                                                          *
*   If x' = D + xM then x = (-DM') + x'M' where M'M = 1.                   *
*                                                                          *
*   M'11 = M22/det, M'12 = -M12/det, M'21 = -M21/det, M'22 = M11/det,      *
*     where det = M11*M22 - M12*M21                                        *
*                                                                          *
* History:                                                                 *
*  Fri 20-Mar-1992 13:54:28 -by- Charles Whitmer [chuckwh]                 *
* Rewrote with new EFLOAT math operations.  We should never do any         *
* operations like efA=efB*efC+efD!  They generate intensely bad code.      *
*                                                                          *
*  19-Nov-1990 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bInverse(MATRIX& mxSrc)
{

    MATRIX *pmxTemp = pmx;

    ASSERTGDI((&mxSrc != pmx), "bInverse src, dest same matrix\n");
    ASSERTGDI((mxSrc.flAccel & XFORM_FORMAT_LTOFX), "bInverse: wrong xform format\n");

// The accelerators of the destination matrix always equal to the
// accelerators of the source matrix.

    pmxTemp->flAccel = (mxSrc.flAccel & ~XFORM_FORMAT_LTOFX) | XFORM_FORMAT_FXTOL;

    if (mxSrc.flAccel & XFORM_UNITY)
    {
        vSetTo1Over16(pmxTemp->efM11);
        vSetTo1Over16(pmxTemp->efM22);
        pmxTemp->efM12.vSetToZero();
        pmxTemp->efM21.vSetToZero();

        pmxTemp->efDx = mxSrc.efDx;
        pmxTemp->efDy = mxSrc.efDy;
        pmxTemp->efDx.vNegate();
        pmxTemp->efDy.vNegate();
        pmxTemp->efDx.vDivBy16();
        pmxTemp->efDy.vDivBy16();
        pmxTemp->fxDx = -FXTOL(mxSrc.fxDx);
        pmxTemp->fxDy = -FXTOL(mxSrc.fxDy);
        return(TRUE);
    }

// calculate the determinant

    EFLOAT efDet;
    EFLOAT efA,efB;

    efA.eqMul(mxSrc.efM11,mxSrc.efM22);
    efB.eqMul(mxSrc.efM12,mxSrc.efM21);
    efDet.eqSub(efA,efB);

// if determinant = 0, return false

    if (efDet.bIsZero())
        return(FALSE);

    if (mxSrc.flAccel & XFORM_SCALE)
    {
        pmxTemp->efM12.vSetToZero();
        pmxTemp->efM21.vSetToZero();
    }
    else
    {
        pmxTemp->efM12.eqDiv(mxSrc.efM12,efDet);
        pmxTemp->efM12.vNegate();
        pmxTemp->efM21.eqDiv(mxSrc.efM21,efDet);
        pmxTemp->efM21.vNegate();
    }

    pmxTemp->efM11.eqDiv(mxSrc.efM22,efDet);
    pmxTemp->efM22.eqDiv(mxSrc.efM11,efDet);

// calculate the offset

    if (mxSrc.flAccel & XFORM_NO_TRANSLATION)
    {
        pmxTemp->efDx.vSetToZero();
        pmxTemp->efDy.vSetToZero();
        pmxTemp->fxDx = 0;
        pmxTemp->fxDy = 0;
        return(TRUE);
    }

    if (mxSrc.flAccel & XFORM_SCALE)
    {
        pmxTemp->efDx.eqMul(mxSrc.efDx,pmxTemp->efM11);
        pmxTemp->efDy.eqMul(mxSrc.efDy,pmxTemp->efM22);
    }
    else
    {
        efA.eqMul(mxSrc.efDx,pmxTemp->efM11);
        efB.eqMul(mxSrc.efDy,pmxTemp->efM21);
        pmxTemp->efDx.eqAdd(efA,efB);

        efA.eqMul(mxSrc.efDx,pmxTemp->efM12);
        efB.eqMul(mxSrc.efDy,pmxTemp->efM22);
        pmxTemp->efDy.eqAdd(efA,efB);
    }

    pmxTemp->efDx.vNegate();
    pmxTemp->efDy.vNegate();

// Return FALSE if translations can't fit in LONG type.

    if (!pmxTemp->efDx.bEfToL(pmxTemp->fxDx))
        return(FALSE);

    if (!pmxTemp->efDy.bEfToL(pmxTemp->fxDy))
        return(FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bComputeUnits (lAngle,ppte,pefWD,pefDW)                                  *
*                                                                          *
* Given an angle in 1/10ths of a degree in logical coordinates, we         *
* transform a vector at that angle into device coordinates.  We normalize  *
* the result into a unit vector and a scaling.                             *
*                                                                          *
* Knowing the unit vector and scaling allows us to quickly calculate the   *
* transform of any vector parallel to the angle.                           *
*                                                                          *
*  Sun 15-Mar-1992 05:26:57 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EXFORMOBJ::bComputeUnits
(
    LONG     lAngle,                // Angle in tenths of a degree.
    POINTFL *ppte,                  // Unit vector in Device Coordinates.
    EFLOAT  *pefWD,                 // World to Device multiplier.
    EFLOAT  *pefDW                  // (Optional) Device to World multiplier.
)
{
    EVECTORFL vt;
    EFLOAT    efA;
    EFLOAT    efB;
    BOOL      bNegate = FALSE;

// Get rid of negative angles.  (Modulo is unreliable on negatives.)

    if (lAngle < 0)
    {
        lAngle = -lAngle;
        bNegate = TRUE;
    }

// Handle simple cases separately for greater accuracy.

    if (bScale() && (lAngle % 900 == 0))
    {
        lAngle /= 900;
        if (lAngle & 1)
        {
            vt.x = (LONG) 0;
            vt.y = (LONG) 1;
            efA = efM22();
        }
        else
        {
            vt.x = (LONG) 1;
            vt.y = (LONG) 0;
            efA = efM11();
        }

        if (efA.bIsZero())
            return(FALSE);

        if (lAngle & 2)
            efA.vNegate();

        if (efA.bIsNegative())
        {
            vt.x.vNegate();
            vt.y.vNegate();
            efA.vNegate();
        }
    }
    else
    {
    // Get the angle.

        EFLOATEXT efAngle = lAngle;
        efAngle /= (LONG) 10;

    // Make a unit vector at that angle.

        vt.x = efCos(efAngle);
        vt.y = efSin(efAngle);

    // Transform it to device coordinates.

        if (!bXform(vt))
            return(FALSE);

    // Determine its length.

        efA.eqLength(*(POINTFL *) &vt);
        if (efA.bIsZero())
            return(FALSE);

    // Make a unit vector.

        vt.x /= efA;
        vt.y /= efA;
        efA.vTimes16();
    }

// Copy the results out.

    if (bNegate)
        vt.y.vNegate();

    *ppte  = vt;
    *pefWD = efA;

    if (pefDW != (EFLOAT *) NULL)
    {
    // Calculate the inverse.

        efB = (LONG) 1;
        efB /= efA;
        *pefDW = efB;
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\w32kevnt.c ===
/******************************Module*Header*******************************\
* Module Name: w32kevnt.c
*
*   Event handling functions
* 
* Copyright (c) 1996-1999 Microsoft Corporation
* 
\**************************************************************************/

#include "engine.h"
#include "pw32kevt.h"

/*
 *  Object type exported from the kernel
 */
extern POBJECT_TYPE *ExEventObjectType;

BOOL
EngCreateEvent(
    OUT PEVENT *ppEvent
    )

/*+++

Routine Description:

    EngCreateEvent creates a synchronization type event object that can 
    be used to synchronize hardware access between a display driver and 
    video miniport.

---*/

{
    PENG_EVENT *ppEngEvent = (PENG_EVENT *)ppEvent;
    PENG_EVENT  pEngEvent;
    PUCHAR      pAllocTmp;
    ULONG       engevtsize = sizeof(ENG_EVENT);

    //
    //  Align size to next higher multiple of 8.
    //

    engevtsize = (engevtsize + 7) & ~7;

    //
    //  Allocate the whole amount and set pEngEvent to the top.
    //

    pAllocTmp = (PUCHAR)ENG_KEVENTALLOC(engevtsize + sizeof(KEVENT));
    pEngEvent = (PENG_EVENT)pAllocTmp;

    if (pEngEvent) {

        RtlZeroMemory(pEngEvent, sizeof(ENG_EVENT));

        //
        //  Skip past the ENG_EVENT and set pEngEvent->pKEvent to that.
        //

        pAllocTmp += engevtsize;
        pEngEvent->pKEvent = (PKEVENT)pAllocTmp;

        //
        //  Initialize the KEVENT and then put the PENG_EVENT in the
        //  PPENG_EVENT. 
        //

        KeInitializeEvent(pEngEvent->pKEvent, SynchronizationEvent, FALSE);
        *ppEngEvent = pEngEvent;

    } else {
        return FALSE;
    }

    return TRUE;
}

BOOL
EngDeleteEvent(
    IN  PEVENT pEvent
    )

/*+++

Routine Description:

    EngDeleteEvent deletes the specified event object.

---*/

{
    PENG_EVENT pEngEvent = (PENG_EVENT)pEvent;

    if ( !(pEngEvent->fFlags & ENG_EVENT_FLAG_IS_MAPPED_USER)) {

        ENG_KEVENTFREE(pEngEvent);
        return TRUE;

    } else {

        ASSERTGDI(FALSE, "Don't delete MappedUserEvents");
        return FALSE;
    }
}

PEVENT
EngMapEvent(
    IN HDEV           hDev,
    IN HANDLE         hUserObject,
    IN PVOID          Reserved1,
    IN PVOID          Reserved2,
    IN PVOID          Reserved3
    )

/*+++

Routine Description:

    This routine allocates a ENG_EVENT and initialize its pKEvent pointer
    to the event object returned from Object manager. 
    
    The reserved fields must be set to NULL

---*/

{
    LONG status;
    PENG_EVENT pEngEvent;

    //
    //  Allocate a pEngEvent, but don't allocate the PKEvent that
    //  resides within this is done by ObReferenceObjectByHandle().
    //

    pEngEvent = ENG_KEVENTALLOC(sizeof(ENG_EVENT));

    if (!pEngEvent) {
        return NULL;
    }

    RtlZeroMemory(pEngEvent, sizeof(ENG_EVENT));

    //
    //  Create the reference to the HANDLE
    //  The ObRef call allocates and puts a PKEVENT object at
    //  the location pointed to by pEngEvent.
    //

    status = ObReferenceObjectByHandle( hUserObject,
                                        EVENT_ALL_ACCESS,
                                        *ExEventObjectType,
                                        UserMode,
                                        (PVOID)&(pEngEvent->pKEvent),
                                        NULL);

    //
    //  If the reference was successful, then pulse the event object.
    //
    //  KePulseEvent atomically sets the signal state of an event object
    //  to Signaled, attempts to satisfy as many Waits as possible, and
    //  then resets the signal state of the event object to Not-Signaled.
    //  The previous signalstate of the event object is returned as the
    //  function value.
    //

    if (NT_SUCCESS(status)) {

        KePulseEvent(pEngEvent->pKEvent, EVENT_INCREMENT, FALSE);
        pEngEvent->fFlags |= ENG_EVENT_FLAG_IS_MAPPED_USER;

    } else {

        ENG_KEVENTFREE(pEngEvent);
        pEngEvent = NULL;
    }

    //
    // If the caller is using the old prototype of EngMapEvent, we should
    // return the pointer of kernel event to the place pointed by the third 
    // argument.
    //

    if ( Reserved1 != NULL ) {
        *(PENG_EVENT *)Reserved1  = pEngEvent;
    }

    return (PEVENT) pEngEvent;
}


BOOL
EngUnmapEvent(
    IN PEVENT pEvent
    )

/*+++

    Routine Description:

    EngUnmapEvent cleans up the kernel-mode resources allocated for a 
    mapped user-mode event.

---*/

{
    PENG_EVENT pEngEvent = (PENG_EVENT)pEvent;

    if ( pEngEvent->fFlags & ENG_EVENT_FLAG_IS_MAPPED_USER ) {

        //
        // Decrements the object's reference count free the all the memory
        //

        ObDereferenceObject(pEngEvent->pKEvent);
        ENG_KEVENTFREE(pEngEvent);
        return TRUE;

    } else {

        return FALSE;
    }
}



BOOL
EngWaitForSingleObject(
    IN  PEVENT          pEvent,
    IN  PLARGE_INTEGER  pTimeOut
    )

/*+++

Routine Description:

    Called by Display driver. Can only be called on events created by
    the Display or miniport driver, not on mapped events. 

Return Value: 

    TRUE if successful, FALSE otherwise. A return value of FALSE indicates 
    that either one of the parameters is invalid or a time-out occurred.
  
---*/

{
    PENG_EVENT pEngEvent = (PENG_EVENT)pEvent;
    PKEVENT pKEvent;
    NTSTATUS Status;

    pKEvent = pEngEvent->pKEvent;

    //
    //  Don't even wait if it's mapped user. In fact, don't wait if it's
    //  invalid.
    //

    if (pKEvent && (!(pEngEvent->fFlags & ENG_EVENT_FLAG_IS_MAPPED_USER))) {

        Status = KeWaitForSingleObject( pKEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        pTimeOut );
    } else {

        ASSERTGDI(FALSE, "No waiting on mapped user events.");
        return FALSE;
    }

    if (NT_SUCCESS(Status))
        return TRUE;
    else 
        return FALSE;

}

LONG
EngSetEvent(
    IN PEVENT pEvent
    )

/*+++

Routine Description:

    EngSetEvent sets the state of the event object to signaled and returns
    the previous state of the event object

---*/

{
    PENG_EVENT  pEngEvent = (PENG_EVENT)pEvent;

    return ( KeSetEvent(pEngEvent->pKEvent, 0, FALSE) );

}

VOID
EngClearEvent (
IN PEVENT pEvent
)

/*+++

Routine Description:

    EngClearEvent sets the given event to a not signaled state.

---*/

{
    PENG_EVENT  pEngEvent = (PENG_EVENT)pEvent;
    KeClearEvent(pEngEvent->pKEvent);
}

LONG
EngReadStateEvent (
IN PEVENT pEvent
)

/*+++

Routine Description:

    EngReadStateEvent returns the current state, signaled or not signaled, 
    of a given event object.

---*/

{
    PENG_EVENT  pEngEvent = (PENG_EVENT)pEvent;
    return ( KeReadStateEvent(pEngEvent->pKEvent) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\watchdog.cxx ===
/******************************Module*Header*******************************\
* Module Name: watchdog.cxx                                                *
*                                                                          *
* Copyright (c) 1990-2002 Microsoft Corporation                            *
*                                                                          *
* This module hooks the display drivers "Drv" entry points.  It will       *
* enter/exit the watchdog appropriately, and set up try/except blocks to   *
* catch threads that get stuck in a driver.                                *
*                                                                          *
* Erick Smith  - ericks -                                                  *
\**************************************************************************/

#include "precomp.hxx"
#include "muclean.hxx"

#define MAKESOFTWAREEXCEPTION(Severity, Facility, Exception) \
    ((DWORD) ((Severity << 30) | (1 << 29) | (Facility << 16) | (Exception)))

#define SE_THREAD_STUCK MAKESOFTWAREEXCEPTION(3,0,1)

#define RECOVERY_SECTION_BEGIN(pldev) __try

#define RECOVERY_SECTION_END(pldev) \
    __except(GetExceptionCode() == SE_THREAD_STUCK) { \
        HandleStuckThreadException(pldev); \
    }

//
// Context Nodes are used for DX.  DdContextCreate and DdContextDestroy
// create contexts that are later passed to other DX functions such as
// DrawPrimitives2 or SetTextureStageState.  Since we need to be able
// to take the context and retrieve the original pldev, we create this
// new structure to help in the association.
//

typedef struct _CONTEXT_NODE
{
    PVOID Context;
    PDHPDEV_ASSOCIATION_NODE ppdevData;
} CONTEXT_NODE, *PCONTEXT_NODE;

PDHPDEV_ASSOCIATION_NODE gdhpdevAssociationList = NULL;
PDHSURF_ASSOCIATION_NODE gdhsurfAssociationList = NULL;

//
// The following routines are used to maintain an association between the
// data actually passed into a driver entry point, and a data structure
// used to look up the actual entry point into the driver.
//
// For example, when the system call the DrvEnablePDEV entry point, the
// driver will create it's own PDEV structure.  We will create an
// association node to associate this driver created PDEV with the LDEV for
// that driver.  Now on subsequent calls into the driver, we can retrieve
// the PDEV via various methods, and then use that to find the LDEV.  Once we
// have the LDEV we can look up the correct entry point into the driver.
//
// GDI entry points are global accross all pdev's.  However, it is possible
// that a driver may return seperate DX entry points to different pdevs.  For
// example this could happen if a driver returned on set of entry points when
// the pdev is in portrait mode, and another set when in landscape mode.
//
// We also store a list of DHSURF's and the association with the LDEV.
//

PDHPDEV_ASSOCIATION_NODE
dhpdevAssociationCreateNode(
    VOID
    )

{
    PDHPDEV_ASSOCIATION_NODE Node;
    Node = (PDHPDEV_ASSOCIATION_NODE) PALLOCMEM(sizeof(DHPDEV_ASSOCIATION_NODE), GDITAG_DRVSUP);
    return Node;
}

PDHSURF_ASSOCIATION_NODE
dhsurfAssociationCreateNode(
    VOID
    )

{
    PDHSURF_ASSOCIATION_NODE Node;
    Node = (PDHSURF_ASSOCIATION_NODE) PALLOCMEM(sizeof(DHSURF_ASSOCIATION_NODE), GDITAG_DRVSUP);
    return Node;
}


VOID
AssociationDeleteNode(
    PVOID Node
    )

{
    if (Node) {
        VFREEMEM(Node);
    }
}

VOID
dhpdevAssociationInsertNode(
    PDHPDEV_ASSOCIATION_NODE Node
    )

{
    GreAcquireFastMutex(gAssociationListMutex);

    Node->next = gdhpdevAssociationList;
    gdhpdevAssociationList = Node;

    GreReleaseFastMutex(gAssociationListMutex);
}

VOID
dhsurfAssociationInsertNode(
    PDHSURF_ASSOCIATION_NODE Node
    )

{
    GreAcquireFastMutex(gAssociationListMutex);

    Node->next = gdhsurfAssociationList;
    gdhsurfAssociationList = Node;

    GreReleaseFastMutex(gAssociationListMutex);
}


PDHPDEV_ASSOCIATION_NODE
dhpdevAssociationRemoveNode(
    DHPDEV dhpdev
    )

{
    PDHPDEV_ASSOCIATION_NODE Node;

    GreAcquireFastMutex(gAssociationListMutex);

    //
    // first find the correct node
    //

    Node = gdhpdevAssociationList;

    while (Node && (Node->dhpdev != dhpdev)) {
        Node = Node->next;
    }

    if (Node) {

        if (gdhpdevAssociationList == Node) {

            gdhpdevAssociationList = Node->next;

        } else {

            PDHPDEV_ASSOCIATION_NODE curr = gdhpdevAssociationList;

            while (curr && (curr->next != Node)) {
                curr = curr->next;
            }

            if (curr) {
                curr->next = Node->next;
            }
        }
    }

    GreReleaseFastMutex(gAssociationListMutex);

    return Node;
}

PDHSURF_ASSOCIATION_NODE
dhsurfAssociationRemoveNode(
    DHSURF dhsurf
    )

{
    PDHSURF_ASSOCIATION_NODE Node;

    GreAcquireFastMutex(gAssociationListMutex);

    //
    // first find the correct node
    //

    Node = gdhsurfAssociationList;

    while (Node && (Node->dhsurf != dhsurf)) {
        Node = Node->next;
    }

    if (Node) {

        if (gdhsurfAssociationList == Node) {

            gdhsurfAssociationList = Node->next;

        } else {

            PDHSURF_ASSOCIATION_NODE curr = gdhsurfAssociationList;

            while (curr && (curr->next != Node)) {
                curr = curr->next;
            }

            if (curr) {
                curr->next = Node->next;
            }
        }
    }

    GreReleaseFastMutex(gAssociationListMutex);

    return Node;
}

BOOL
dhsurfAssociationIsNodeInList(
    DHSURF dhsurf,
    HSURF hsurf
    )

{
    PDHSURF_ASSOCIATION_NODE Curr;
    BOOL bRet = FALSE;

    GreAcquireFastMutex(gAssociationListMutex);

    Curr = gdhsurfAssociationList;

    while (Curr) {

        //
        // We only have to check if the key and the hsurf value
        // are similar.
        //

        if ((Curr->dhsurf == dhsurf) &&
            (Curr->hsurf == hsurf)) {

            bRet = TRUE;
            break;
        }

        Curr = Curr->next;
    }

    GreReleaseFastMutex(gAssociationListMutex);

    return bRet;
}

PDHPDEV_ASSOCIATION_NODE
dhpdevRetrieveNode(
    DHPDEV dhpdev
    )

{
    PDHPDEV_ASSOCIATION_NODE Node;

    GreAcquireFastMutex(gAssociationListMutex);

    Node = gdhpdevAssociationList;

    while (Node) {

        if (Node->dhpdev == dhpdev) {
            break;
        }

        Node = Node->next;
    }

    GreReleaseFastMutex(gAssociationListMutex);

    return Node;
}

PLDEV
dhpdevRetrieveLdev(
    DHPDEV dhpdev
    )

{
    PDHPDEV_ASSOCIATION_NODE Node;

    GreAcquireFastMutex(gAssociationListMutex);

    Node = gdhpdevAssociationList;

    while (Node) {

        if (Node->dhpdev == dhpdev) {
            break;
        }

        Node = Node->next;
    }

    GreReleaseFastMutex(gAssociationListMutex);

    if (Node) {
        return (PLDEV)Node->pldev;
    } else {
        return NULL;
    }
}

PLDEV
dhsurfRetrieveLdev(
    DHSURF dhsurf
    )

{
    PDHSURF_ASSOCIATION_NODE Node;

    GreAcquireFastMutex(gAssociationListMutex);

    Node = gdhsurfAssociationList;

    while (Node) {

        if (Node->dhsurf == dhsurf) {
            break;
        }

        Node = Node->next;
    }

    GreReleaseFastMutex(gAssociationListMutex);

    if (Node) {
        return (PLDEV)Node->pldev;
    } else {
        return NULL;
    }
}

ULONG
WatchdogDrvGetModesEmpty(
    IN HANDLE hDriver,
    IN ULONG cjSize,
    OUT DEVMODEW *pdm
    )

/*++

Routine Description:

    This function replaces a drivers DrvGetModes function when
    and EA has occured.  We do this so that we can stop reporting
    modes for this device.

--*/

{
    //
    // Indicate NO modes!
    //

    return 0;
}

VOID
WatchdogRecoveryThread(
    IN PVOID Context
    )

{
    VIDEO_WIN32K_CALLBACKS_PARAMS Params;

    UNREFERENCED_PARAMETER(Context);

    Params.CalloutType = VideoChangeDisplaySettingsCallout;
    Params.Param = 0;
    Params.PhysDisp = NULL;
    Params.Status = 0;

    //
    // It is possible we'll hit an EA and try to recover for USER has
    // finished initializing.  Therefore the VideoPortCallout may fail
    // with a STATUS_INVALID_HANDLE.  We'll keep trying (with a delay)
    // until we get a different status code.
    //

    do {

        VideoPortCallout(&Params);

        if (Params.Status == STATUS_INVALID_HANDLE) {

            ZwYieldExecution();
        }

    } while (Params.Status == STATUS_INVALID_HANDLE);

    PsTerminateSystemThread(STATUS_SUCCESS);
}


VOID
HandleStuckThreadException(
    PLDEV pldev
    )

/*++

    Wake up a user mode thread waiting to reset the display resolution.

--*/

{
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    HANDLE ThreadHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;

    //
    // First disable all entries in the dispatch table in the pldev.  This
    // way we can stop future threads from entring the driver.
    //

    pldev->bThreadStuck = TRUE;

    //
    // Replacd the DrvGetModes function for the driver such that the
    // driver reports no modes!
    //

    pldev->apfn[INDEX_DrvGetModes] = (PFN) WatchdogDrvGetModesEmpty;

    //
    // Remove non-vga device from graphics device list to stop the
    // system from trying to continue using the current device.
    //
    // What do we do about multi-mon?
    //

    DrvPrepareForEARecovery();

    //
    // Create a thread to do the work of changing the display resolution.
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = PsCreateSystemThread(&ThreadHandle,
                                  (ACCESS_MASK) 0,
                                  &ObjectAttributes,
                                  NtCurrentProcess(),
                                  NULL,
                                  WatchdogRecoveryThread,
                                  NULL);

    if (NT_SUCCESS(Status) == TRUE) {

        ZwClose(ThreadHandle);

    } else {

        DbgPrint("Warning, we failed to create the Recovery Thread\n");
    }

    //
    // Clean up any pending drivers locks that this thread is holding
    //

    GreFreeSemaphoresForCurrentThread();
}

DHPDEV APIENTRY
WatchdogDrvEnablePDEV(
    DEVMODEW *pdm,
    LPWSTR    pwszLogAddress,
    ULONG     cPat,
    HSURF    *phsurfPatterns,
    ULONG     cjCaps,
    ULONG    *pdevcaps,
    ULONG     cjDevInfo,
    DEVINFO  *pdi,
    HDEV      hdev,
    LPWSTR    pwszDeviceName,
    HANDLE    hDriver
    )

{
    PDEV *ppdev = (PDEV *)hdev;
    DHPDEV dhpdevRet = NULL;

    if (ppdev->pldev->bThreadStuck == FALSE) {

        PFN_DrvEnablePDEV pfn = (PFN_DrvEnablePDEV) ppdev->pldev->apfnDriver[INDEX_DrvEnablePDEV];
        PDHPDEV_ASSOCIATION_NODE Node = dhpdevAssociationCreateNode();

        if (Node) {

            Node->pldev = ppdev->pldev;
            Node->dhpdev = NULL;

            RECOVERY_SECTION_BEGIN(ppdev->pldev) {

                Node->dhpdev = pfn(pdm,
                                   pwszLogAddress,
                                   cPat,
                                   phsurfPatterns,
                                   cjCaps,
                                   (GDIINFO *)pdevcaps,
                                   cjDevInfo,
                                   pdi,
                                   hdev,
                                   pwszDeviceName,
                                   hDriver);

            } RECOVERY_SECTION_END(ppdev->pldev);
            
            if (Node->dhpdev) {

                dhpdevRet = (DHPDEV) Node->dhpdev;

                dhpdevAssociationInsertNode(Node);

            } else {

                AssociationDeleteNode(Node);
            }
        }
    }

    return dhpdevRet;
}

VOID APIENTRY
WatchdogDrvCompletePDEV(
    DHPDEV dhpdev,
    HDEV hdev
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvCompletePDEV pfn = (PFN_DrvCompletePDEV) pldev->apfnDriver[INDEX_DrvCompletePDEV];

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {
    
       pfn(dhpdev, hdev);
       
    } RECOVERY_SECTION_END(pldev);
}

VOID APIENTRY
WatchdogDrvDisablePDEV(
    DHPDEV dhpdev
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvDisablePDEV pfn = (PFN_DrvDisablePDEV) pldev->apfnDriver[INDEX_DrvDisablePDEV];

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        pfn(dhpdev);

    } RECOVERY_SECTION_END(pldev);

    AssociationDeleteNode(dhpdevAssociationRemoveNode(dhpdev));
}

HSURF APIENTRY
WatchdogDrvEnableSurface(
    DHPDEV dhpdev
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvEnableSurface pfn = (PFN_DrvEnableSurface) pldev->apfnDriver[INDEX_DrvEnableSurface];
    HSURF hsurfRet = NULL;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return NULL;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        hsurfRet = pfn(dhpdev);

    } RECOVERY_SECTION_END(pldev);

    return hsurfRet;
}

VOID APIENTRY
WatchdogDrvDisableSurface(
    DHPDEV dhpdev
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvDisableSurface pfn = (PFN_DrvDisableSurface) pldev->apfnDriver[INDEX_DrvDisableSurface];

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        pfn(dhpdev);

    } RECOVERY_SECTION_END(pldev);
}

BOOL APIENTRY
WatchdogDrvAssertMode(
    DHPDEV dhpdev,
    BOOL bEnable
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvAssertMode pfn = (PFN_DrvAssertMode) pldev->apfnDriver[INDEX_DrvAssertMode];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(dhpdev, bEnable);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvResetPDEV(
    DHPDEV dhpdevOld,
    DHPDEV dhpdevNew
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdevOld);
    PFN_DrvResetPDEV pfn = (PFN_DrvResetPDEV) pldev->apfnDriver[INDEX_DrvResetPDEV];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(dhpdevOld, dhpdevNew);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

HBITMAP APIENTRY
WatchdogDrvCreateDeviceBitmap(
    DHPDEV dhpdev,
    SIZEL  sizl,
    ULONG  iFormat
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvCreateDeviceBitmap pfn = (PFN_DrvCreateDeviceBitmap) pldev->apfnDriver[INDEX_DrvCreateDeviceBitmap];
    HBITMAP hbitmapRet = NULL;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck == FALSE) {

        RECOVERY_SECTION_BEGIN(pldev) {

            hbitmapRet = pfn(dhpdev, sizl, iFormat);

        } RECOVERY_SECTION_END(pldev);
    }

    return hbitmapRet;
}

VOID APIENTRY
WatchdogDrvDeleteDeviceBitmap(
    IN DHSURF dhsurf
    )

{
    PLDEV pldev = dhsurfRetrieveLdev(dhsurf);
    PFN_DrvDeleteDeviceBitmap pfn = (PFN_DrvDeleteDeviceBitmap) pldev->apfnDriver[INDEX_DrvDeleteDeviceBitmap];

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        pfn(dhsurf);

    } RECOVERY_SECTION_END(pldev);

    AssociationDeleteNode(dhsurfAssociationRemoveNode(dhsurf));
}

BOOL APIENTRY
WatchdogDrvRealizeBrush(
    BRUSHOBJ *pbo,
    SURFOBJ  *psoTarget,
    SURFOBJ  *psoPattern,
    SURFOBJ  *psoMask,
    XLATEOBJ *pxlo,
    ULONG    iHatch
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(psoTarget->dhpdev);
    PFN_DrvRealizeBrush pfn = (PFN_DrvRealizeBrush) pldev->apfnDriver[INDEX_DrvRealizeBrush];
    BOOL bRet = FALSE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return FALSE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(pbo, psoTarget, psoPattern, psoMask, pxlo, iHatch);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

ULONG APIENTRY
WatchdogDrvDitherColor(
    DHPDEV dhpdev,
    ULONG iMode,
    ULONG rgb,
    ULONG *pul
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvDitherColor pfn = (PFN_DrvDitherColor) pldev->apfnDriver[INDEX_DrvDitherColor];
    ULONG ulRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        ulRet = pfn(dhpdev, iMode, rgb, pul);

    } RECOVERY_SECTION_END(pldev);

    return ulRet;
}

BOOL APIENTRY
WatchdogDrvStrokePath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    LINEATTRS *plineattrs,
    MIX       mix
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvStrokePath pfn = (PFN_DrvStrokePath) pldev->apfnDriver[INDEX_DrvStrokePath];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(pso, ppo, pco, pxo, pbo, pptlBrushOrg, plineattrs, mix);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}


BOOL APIENTRY
WatchdogDrvFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    POINTL    *pptlBrushOrg,
    MIX       mix,
    FLONG     flOptions
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvFillPath pfn = (PFN_DrvFillPath) pldev->apfnDriver[INDEX_DrvFillPath];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvStrokeAndFillPath(
    SURFOBJ   *pso,
    PATHOBJ   *ppo,
    CLIPOBJ   *pco,
    XFORMOBJ  *pxo,
    BRUSHOBJ  *pboStroke,
    LINEATTRS *plineattrs,
    BRUSHOBJ  *pboFill,
    POINTL    *pptlBrushOrg,
    MIX       mixFill,
    FLONG     flOptions
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvStrokeAndFillPath pfn = (PFN_DrvStrokeAndFillPath) pldev->apfnDriver[INDEX_DrvStrokeAndFillPath];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(pso, ppo, pco, pxo, pboStroke, plineattrs, pboFill, pptlBrushOrg, mixFill, flOptions);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvBitBlt(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    POINTL   *pptlSrc,
    POINTL   *pptlMask,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4     rop4
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PLDEV pldev = dhpdevRetrieveLdev(psoDevice->dhpdev);
    PFN_DrvBitBlt pfn = (PFN_DrvBitBlt) pldev->apfnDriver[INDEX_DrvBitBlt];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc, pptlMask, pbo, pptlBrush, rop4);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvCopyBits(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    POINTL   *pptlSrc
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PLDEV pldev = dhpdevRetrieveLdev(psoDevice->dhpdev);
    PFN_DrvCopyBits pfn = (PFN_DrvCopyBits) pldev->apfnDriver[INDEX_DrvCopyBits];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PLDEV pldev = dhpdevRetrieveLdev(psoDevice->dhpdev);
    PFN_DrvStretchBlt pfn = (PFN_DrvStretchBlt) pldev->apfnDriver[INDEX_DrvStretchBlt];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg, prclDst, prclSrc, pptlMask, iMode);

    } RECOVERY_SECTION_END(pldev);
    
    return bRet;
}

ULONG APIENTRY
WatchdogDrvSetPalette(
    DHPDEV dhpdev,
    PALOBJ *ppalo,
    FLONG  fl,
    ULONG  iStart,
    ULONG  cColors
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvSetPalette pfn = (PFN_DrvSetPalette) pldev->apfnDriver[INDEX_DrvSetPalette];
    ULONG ulRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        ulRet = pfn(dhpdev, ppalo, fl, iStart, cColors);

    } RECOVERY_SECTION_END(pldev);

    return ulRet;
}

BOOL APIENTRY
WatchdogDrvTextOut(
    SURFOBJ  *pso,
    STROBJ   *pstro,
    FONTOBJ  *pfo,
    CLIPOBJ  *pco,
    RECTL    *prclExtra,
    RECTL    *prclOpaque,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlOrg,
    MIX       mix
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvTextOut pfn = (PFN_DrvTextOut) pldev->apfnDriver[INDEX_DrvTextOut];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore, pboOpaque, pptlOrg, mix);

    } RECOVERY_SECTION_END(pldev);

    return bRet;

}

ULONG APIENTRY
WatchdogDrvEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvEscape pfn = (PFN_DrvEscape) pldev->apfnDriver[INDEX_DrvEscape];
    ULONG ulRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        ulRet = pfn(pso, iEsc, cjIn, pvIn, cjOut, pvOut);

    } RECOVERY_SECTION_END(pldev);

    return ulRet;
}

ULONG APIENTRY
WatchdogDrvDrawEscape(
    IN SURFOBJ *pso,
    IN ULONG iEsc,
    IN CLIPOBJ *pco,
    IN RECTL *prcl,
    IN ULONG cjIn,
    IN PVOID pvIn
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvDrawEscape pfn = (PFN_DrvDrawEscape) pldev->apfnDriver[INDEX_DrvDrawEscape];
    ULONG ulRet = -1;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return -1;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        ulRet = pfn(pso, iEsc, pco, prcl, cjIn, pvIn);

    } RECOVERY_SECTION_END(pldev);

    return ulRet;

}

ULONG APIENTRY
WatchdogDrvSetPointerShape(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    XLATEOBJ *pxlo,
    LONG      xHot,
    LONG      yHot,
    LONG      x,
    LONG      y,
    RECTL    *prcl,
    FLONG     fl
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvSetPointerShape pfn = (PFN_DrvSetPointerShape) pldev->apfnDriver[INDEX_DrvSetPointerShape];
    ULONG ulRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        ulRet = pfn(pso, psoMask, psoColor, pxlo, xHot, yHot, x, y, prcl, fl);

    } RECOVERY_SECTION_END(pldev);

    return ulRet;
}

VOID APIENTRY
WatchdogDrvMovePointer(
    SURFOBJ  *pso,
    LONG      x,
    LONG      y,
    RECTL    *prcl
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvMovePointer pfn = (PFN_DrvMovePointer) pldev->apfnDriver[INDEX_DrvMovePointer];

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        pfn(pso, x, y, prcl);

    } RECOVERY_SECTION_END(pldev);
}

BOOL APIENTRY
WatchdogDrvLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvLineTo pfn = (PFN_DrvLineTo) pldev->apfnDriver[INDEX_DrvLineTo];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

VOID APIENTRY
WatchdogDrvSynchronize(
    DHPDEV dhpdev,
    RECTL *prcl
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvSynchronize pfn = (PFN_DrvSynchronize) pldev->apfnDriver[INDEX_DrvSynchronize];

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        pfn(dhpdev, prcl);

    } RECOVERY_SECTION_END(pldev);
}

ULONG_PTR APIENTRY
WatchdogDrvSaveScreenBits(
    SURFOBJ   *pso,
    ULONG      iMode,
    ULONG_PTR  ident,
    RECTL     *prcl
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvSaveScreenBits pfn = (PFN_DrvSaveScreenBits) pldev->apfnDriver[INDEX_DrvSaveScreenBits];
    ULONG_PTR ulptrRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        ulptrRet = pfn(pso, iMode, ident, prcl);

    } RECOVERY_SECTION_END(pldev);

    return ulptrRet;
}

DWORD APIENTRY
WatchdogDrvSetPixelFormat(
    IN SURFOBJ *pso,
    IN LONG iPixelFormat,
    IN HWND hwnd
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvSetPixelFormat pfn = (PFN_DrvSetPixelFormat) pldev->apfnDriver[INDEX_DrvSetPixelFormat];
    DWORD dwRet = FALSE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(pso, iPixelFormat, hwnd);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

LONG APIENTRY
WatchdogDrvDescribePixelFormat(
    IN DHPDEV dhpdev,
    IN LONG iPixelFormat,
    IN ULONG cjpdf,
    OUT PIXELFORMATDESCRIPTOR *ppfd
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvDescribePixelFormat pfn = (PFN_DrvDescribePixelFormat) pldev->apfnDriver[INDEX_DrvDescribePixelFormat];
    LONG lRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        lRet = pfn(dhpdev, iPixelFormat, cjpdf, ppfd);

    } RECOVERY_SECTION_END(pldev);
    
    return lRet;
}

BOOL APIENTRY
WatchdogDrvSwapBuffers(
    IN SURFOBJ *pso,
    IN WNDOBJ *pwo
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvSwapBuffers pfn = (PFN_DrvSwapBuffers) pldev->apfnDriver[INDEX_DrvSwapBuffers];
    BOOL bRet = FALSE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return FALSE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(pso, pwo);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

DWORD APIENTRY
WatchdogDdContextCreate(
    LPD3DNTHAL_CONTEXTCREATEDATA pccd
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE)dhpdevRetrieveNode((DHPDEV)pccd->lpDDLcl->lpGbl->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    LPD3DNTHAL_CONTEXTCREATECB pfn = (LPD3DNTHAL_CONTEXTCREATECB) ppdevData->apfnDriver[INDEX_DdContextCreate];
    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
    PCONTEXT_NODE Node;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    Node = (PCONTEXT_NODE)PALLOCMEM(sizeof(CONTEXT_NODE), GDITAG_DRVSUP);

    if (Node) {

        RECOVERY_SECTION_BEGIN(pldev) {

            dwRet = pfn(pccd);

        } RECOVERY_SECTION_END(pldev);

        if (dwRet == DDHAL_DRIVER_HANDLED) {

            //
            // Store the dwhContext and the associated dhpdev
            //

            Node->Context = (PVOID)pccd->dwhContext;
            Node->ppdevData = ppdevData;

            pccd->dwhContext = (DWORD_PTR)Node;

        } else {

            VFREEMEM(Node);
        }
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdContextDestroy(
    LPD3DNTHAL_CONTEXTDESTROYDATA pcdd
    )

{
    PCONTEXT_NODE Node = (PCONTEXT_NODE) pcdd->dwhContext;
    LPD3DNTHAL_CONTEXTDESTROYCB pfn = (LPD3DNTHAL_CONTEXTDESTROYCB) Node->ppdevData->apfnDriver[INDEX_DdContextDestroy];
    PLDEV pldev = Node->ppdevData->pldev;
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    //
    // Restore driver created context
    //

    pcdd->dwhContext = (DWORD_PTR) Node->Context;

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(pcdd);

    } RECOVERY_SECTION_END(pldev);
    
    //
    // Resore our context, just in case this stucture is re-used
    //

    pcdd->dwhContext = (DWORD_PTR) Node;

    if (dwRet == DDHAL_DRIVER_HANDLED) {

        VFREEMEM(Node);
    }

    return dwRet;
}

DWORD APIENTRY
WatchdogDdCanCreateSurface(
    PDD_CANCREATESURFACEDATA lpCanCreateSurface
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpCanCreateSurface->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_CANCREATESURFACE pfn = (PDD_CANCREATESURFACE) ppdevData->apfnDriver[INDEX_DdCanCreateSurface];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpCanCreateSurface);

    } RECOVERY_SECTION_END(pldev);

    return dwRet;
}

DWORD APIENTRY
WatchdogDdCreateSurface(
    PDD_CREATESURFACEDATA lpCreateSurface
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpCreateSurface->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_CREATESURFACE pfn = (PDD_CREATESURFACE) ppdevData->apfnDriver[INDEX_DdCreateSurface];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpCreateSurface);

    } RECOVERY_SECTION_END(pldev);

    return dwRet;
}

DWORD APIENTRY
WatchdogDdDestroySurface(
    PDD_DESTROYSURFACEDATA lpDestroySurface
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpDestroySurface->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_DESTROYSURFACE pfn = (PDD_SURFCB_DESTROYSURFACE) ppdevData->apfnDriver[INDEX_DdDestroySurface];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpDestroySurface);

    } RECOVERY_SECTION_END(pldev);

    return dwRet;
}

DWORD APIENTRY
WatchdogDdLockSurface(
    PDD_LOCKDATA lpLockSurface
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpLockSurface->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_LOCK pfn = (PDD_SURFCB_LOCK) ppdevData->apfnDriver[INDEX_DdLockSurface];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpLockSurface);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdUnlockSurface(
    PDD_UNLOCKDATA lpUnlockSurface
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpUnlockSurface->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_UNLOCK pfn = (PDD_SURFCB_UNLOCK) ppdevData->apfnDriver[INDEX_DdUnlockSurface];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpUnlockSurface);

    } RECOVERY_SECTION_END(pldev);

    return dwRet;
}

#if 0

//
// I'm not sure how I can hook this one since a DD_DRVSETCOLORKEYDATA
// structure doesn't have a way to look up the dhpdev!
//

DWORD APIENTRY
WatchdogDdSetColorKey(
    PDD_DRVSETCOLORKEYDATA lpSetColorKey
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpSetColorKey->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_SETCOLORKEY pfn = (PDD_SURFCB_SETCOLORKEY) ppdevData->apfnDriver[INDEX_DdSetColorKey];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpSetColorKey);

    } RECOVERY_SECTION_END(pldev);

    return dwRet;
}
#endif

DWORD APIENTRY
WatchdogDdGetScanLine(
    PDD_GETSCANLINEDATA pGetScanLine
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)pGetScanLine->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_GETSCANLINE pfn = (PDD_GETSCANLINE) ppdevData->apfnDriver[INDEX_DdGetScanLine];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(pGetScanLine);

    } RECOVERY_SECTION_END(pldev);

    return dwRet;
}

DWORD APIENTRY
WatchdogDdCreatePalette(
    PDD_CREATEPALETTEDATA lpCreatePalette
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpCreatePalette->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_CREATEPALETTE pfn = (PDD_CREATEPALETTE) ppdevData->apfnDriver[INDEX_DdCreatePalette];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpCreatePalette);

    } RECOVERY_SECTION_END(pldev);

    return dwRet;
}

DWORD APIENTRY
WatchdogDdMapMemory(
    PDD_MAPMEMORYDATA lpMapMemory
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpMapMemory->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_MAPMEMORY pfn = (PDD_MAPMEMORY) ppdevData->apfnDriver[INDEX_DdMapMemory];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpMapMemory);

    } RECOVERY_SECTION_END(pldev);

    return dwRet;
}

DWORD APIENTRY
WatchdogDdWaitForVerticalBlank(
    PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpWaitForVerticalBlank->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_WAITFORVERTICALBLANK pfn = (PDD_WAITFORVERTICALBLANK) ppdevData->apfnDriver[INDEX_DdWaitForVerticalBlank];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpWaitForVerticalBlank);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdFlip(
    PDD_FLIPDATA lpFlip
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpFlip->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_FLIP pfn = (PDD_SURFCB_FLIP) ppdevData->apfnDriver[INDEX_DdFlip];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpFlip);

    } RECOVERY_SECTION_END(pldev);

    return dwRet;
}

DWORD APIENTRY
WatchdogDdGetDriverState(
    PDD_GETDRIVERSTATEDATA pgdsd
    )

{
    PCONTEXT_NODE Node = (PCONTEXT_NODE) pgdsd->dwhContext;
    PDD_GETDRIVERSTATE pfn = (PDD_GETDRIVERSTATE) Node->ppdevData->apfnDriver[INDEX_DdGetDriverState];
    PLDEV pldev = Node->ppdevData->pldev;
    DWORD dwRet = 0;

    //
    // how can I validate if I created this dwhcontext?
    //

    if (pfn == NULL) {
        pgdsd->ddRVal = D3DNTHAL_CONTEXT_BAD;
        return DDHAL_DRIVER_HANDLED;
    }

    if (pldev->bThreadStuck) {
        return 0;
    }

    //
    // restore original context
    //

    pgdsd->dwhContext = (DWORD_PTR) Node->Context;

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(pgdsd);

    } RECOVERY_SECTION_END(pldev);
    
    //
    // save our context again in case this structure is re-used
    //

    pgdsd->dwhContext = (DWORD_PTR) Node;

    return dwRet;
}

DWORD APIENTRY
WatchdogDdLock(
    PDD_LOCKDATA lpLock
    )
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpLock->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_LOCK pfn = (PDD_SURFCB_LOCK) ppdevData->apfnDriver[INDEX_DdLock];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpLock);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdUnlock(
    PDD_UNLOCKDATA lpUnlock)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpUnlock->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_UNLOCK pfn = (PDD_SURFCB_UNLOCK) ppdevData->apfnDriver[INDEX_DdUnlock];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpUnlock);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdBlt(
    PDD_BLTDATA lpBlt)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpBlt->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_BLT pfn = (PDD_SURFCB_BLT) ppdevData->apfnDriver[INDEX_DdBlt];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpBlt);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdAddAttachedSurface(
    PDD_ADDATTACHEDSURFACEDATA lpAddAttachedSurface)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpAddAttachedSurface->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_ADDATTACHEDSURFACE pfn = (PDD_SURFCB_ADDATTACHEDSURFACE) ppdevData->apfnDriver[INDEX_DdAddAttachedSurface];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpAddAttachedSurface);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdGetBltStatus(
    PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpGetBltStatus->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_GETBLTSTATUS pfn = (PDD_SURFCB_GETBLTSTATUS) ppdevData->apfnDriver[INDEX_DdGetBltStatus];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpGetBltStatus);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdGetFlipStatus(
    PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpGetFlipStatus->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_GETFLIPSTATUS pfn = (PDD_SURFCB_GETFLIPSTATUS) ppdevData->apfnDriver[INDEX_DdGetFlipStatus];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpGetFlipStatus);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdUpdateOverlay(
    PDD_UPDATEOVERLAYDATA lpUpdateOverlay)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpUpdateOverlay->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_UPDATEOVERLAY pfn = (PDD_SURFCB_UPDATEOVERLAY) ppdevData->apfnDriver[INDEX_DdUpdateOverlay];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpUpdateOverlay);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdSetOverlayPosition(
    PDD_SETOVERLAYPOSITIONDATA lpSetOverlayPosition)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpSetOverlayPosition->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_SETOVERLAYPOSITION pfn = (PDD_SURFCB_SETOVERLAYPOSITION) ppdevData->apfnDriver[INDEX_DdSetOverlayPosition];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpSetOverlayPosition);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdSetPalette(
    PDD_SETPALETTEDATA lpSetPalette)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpSetPalette->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_SETPALETTE pfn = (PDD_SURFCB_SETPALETTE) ppdevData->apfnDriver[INDEX_DdSetPalette];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpSetPalette);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdDestroyPalette(
    PDD_DESTROYPALETTEDATA lpDestroyPalette)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpDestroyPalette->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_PALCB_DESTROYPALETTE pfn = (PDD_PALCB_DESTROYPALETTE) ppdevData->apfnDriver[INDEX_DdDestroyPalette];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpDestroyPalette);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdSetEntries(
    PDD_SETENTRIESDATA lpSetEntries)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpSetEntries->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_PALCB_SETENTRIES pfn = (PDD_PALCB_SETENTRIES) ppdevData->apfnDriver[INDEX_DdSetEntries];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpSetEntries);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdColorControl(
    PDD_COLORCONTROLDATA lpColorControl)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpColorControl->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_COLORCB_COLORCONTROL pfn = (PDD_COLORCB_COLORCONTROL) ppdevData->apfnDriver[INDEX_DdColorControl];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpColorControl);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdCanCreateD3DBuffer(
    PDD_CANCREATESURFACEDATA lpCanCreateD3DBuffer)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpCanCreateD3DBuffer->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_CANCREATESURFACE pfn = (PDD_CANCREATESURFACE) ppdevData->apfnDriver[INDEX_DdCanCreateD3DBuffer];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpCanCreateD3DBuffer);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdCreateD3DBuffer(
    PDD_CREATESURFACEDATA lpCreateD3DBuffer)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpCreateD3DBuffer->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_CREATESURFACE pfn = (PDD_CREATESURFACE) ppdevData->apfnDriver[INDEX_DdCreateD3DBuffer];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpCreateD3DBuffer);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdDestroyD3DBuffer(
    PDD_DESTROYSURFACEDATA lpDestroyD3DBuffer)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpDestroyD3DBuffer->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_DESTROYSURFACE pfn = (PDD_SURFCB_DESTROYSURFACE) ppdevData->apfnDriver[INDEX_DdDestroyD3DBuffer];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpDestroyD3DBuffer);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdLockD3DBuffer(
    PDD_LOCKDATA lpLockD3DBuffer)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpLockD3DBuffer->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_LOCK pfn = (PDD_SURFCB_LOCK) ppdevData->apfnDriver[INDEX_DdLockD3DBuffer];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpLockD3DBuffer);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdUnlockD3DBuffer(
    PDD_UNLOCKDATA lpUnlockD3DBuffer)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpUnlockD3DBuffer->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SURFCB_UNLOCK pfn = (PDD_SURFCB_UNLOCK) ppdevData->apfnDriver[INDEX_DdUnlockD3DBuffer];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpUnlockD3DBuffer);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdGetAvailDriverMemory(
    PDD_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemory)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpGetAvailDriverMemory->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_GETAVAILDRIVERMEMORY pfn = (PDD_GETAVAILDRIVERMEMORY) ppdevData->apfnDriver[INDEX_DdGetAvailDriverMemory];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpGetAvailDriverMemory);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdAlphaBlt(
    PDD_BLTDATA lpAlphaBlt)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpAlphaBlt->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_ALPHABLT pfn = (PDD_ALPHABLT) ppdevData->apfnDriver[INDEX_DdAlphaBlt];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpAlphaBlt);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdDrawPrimitives2(
    LPD3DNTHAL_DRAWPRIMITIVES2DATA lpDrawPrimitives2)
{
    PCONTEXT_NODE Node = (PCONTEXT_NODE) lpDrawPrimitives2->dwhContext;
    LPD3DNTHAL_DRAWPRIMITIVES2CB pfn = (LPD3DNTHAL_DRAWPRIMITIVES2CB) Node->ppdevData->apfnDriver[INDEX_DdDrawPrimitives2];
    PLDEV pldev = Node->ppdevData->pldev;
    DWORD dwRet = 0;

    if (pfn == NULL) {
        lpDrawPrimitives2->ddrval = D3DNTHAL_CONTEXT_BAD;
        return DDHAL_DRIVER_HANDLED;
    }

    if (pldev->bThreadStuck) {
        return 0;
    }

    lpDrawPrimitives2->dwhContext = (DWORD_PTR) Node->Context;

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpDrawPrimitives2);

    } RECOVERY_SECTION_END(pldev);
    
    lpDrawPrimitives2->dwhContext = (DWORD_PTR) Node;

    return dwRet;
}

DWORD APIENTRY
WatchdogDdValidateTextureStageState(
    LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA lpValidateTextureStageState)
{
    PCONTEXT_NODE Node = (PCONTEXT_NODE) lpValidateTextureStageState->dwhContext;
    LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB pfn = (LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB) Node->ppdevData->apfnDriver[INDEX_DdValidateTextureStageState];
    PLDEV pldev = Node->ppdevData->pldev;
    DWORD dwRet = 0;

    if (pfn == NULL) {
        lpValidateTextureStageState->ddrval = D3DNTHAL_CONTEXT_BAD;
        return DDHAL_DRIVER_HANDLED;
    }

    if (pldev->bThreadStuck) {
        return 0;
    }

    lpValidateTextureStageState->dwhContext = (DWORD_PTR) Node->Context;

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpValidateTextureStageState);

    } RECOVERY_SECTION_END(pldev);
    
    lpValidateTextureStageState->dwhContext = (DWORD_PTR) Node;

    return dwRet;
}

DWORD APIENTRY
WatchdogDdSyncSurfaceData(
    PDD_SYNCSURFACEDATA lpSyncSurfaceData)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpSyncSurfaceData->lpDD->lpGbl->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_KERNELCB_SYNCSURFACE pfn = (PDD_KERNELCB_SYNCSURFACE) ppdevData->apfnDriver[INDEX_DdSyncSurfaceData];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpSyncSurfaceData);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdSyncVideoPortData(
    PDD_SYNCVIDEOPORTDATA lpSyncVideoPortData)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpSyncVideoPortData->lpDD->lpGbl->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_KERNELCB_SYNCVIDEOPORT pfn = (PDD_KERNELCB_SYNCVIDEOPORT) ppdevData->apfnDriver[INDEX_DdSyncVideoPortData];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpSyncVideoPortData);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdCreateSurfaceEx(
    PDD_CREATESURFACEEXDATA lpCreateSurfaceEx)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpCreateSurfaceEx->lpDDLcl->lpGbl->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_CREATESURFACEEX pfn = (PDD_CREATESURFACEEX) ppdevData->apfnDriver[INDEX_DdCreateSurfaceEx];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpCreateSurfaceEx);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdDestroyDDLocal(
    PDD_DESTROYDDLOCALDATA lpDestroyDDLocal)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpDestroyDDLocal->pDDLcl->lpGbl->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_DESTROYDDLOCAL pfn = (PDD_DESTROYDDLOCAL) ppdevData->apfnDriver[INDEX_DdDestroyDDLocal];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpDestroyDDLocal);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdFreeDriverMemory(
    PDD_FREEDRIVERMEMORYDATA lpFreeDriverMemory)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpFreeDriverMemory->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_FREEDRIVERMEMORY pfn = (PDD_FREEDRIVERMEMORY) ppdevData->apfnDriver[INDEX_DdFreeDriverMemory];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpFreeDriverMemory);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdSetExclusiveMode(
    PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpSetExclusiveMode->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_SETEXCLUSIVEMODE pfn = (PDD_SETEXCLUSIVEMODE) ppdevData->apfnDriver[INDEX_DdSetExclusiveMode];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpSetExclusiveMode);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdFlipToGDISurface(
    PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface)
{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode((DHPDEV)lpFlipToGDISurface->lpDD->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_FLIPTOGDISURFACE pfn = (PDD_FLIPTOGDISURFACE) ppdevData->apfnDriver[INDEX_DdFlipToGDISurface];
    DWORD dwRet = 0;

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpFlipToGDISurface);

    } RECOVERY_SECTION_END(pldev);
    
    return dwRet;
}

DWORD APIENTRY
WatchdogDdGetDriverInfo(
    PDD_GETDRIVERINFODATA lpGetDriverInfo
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE)dhpdevRetrieveNode((DHPDEV)lpGetDriverInfo->dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PDD_GETDRIVERINFO pfn = (PDD_GETDRIVERINFO) ppdevData->apfnDriver[INDEX_DdGetDriverInfo];
    DWORD dwRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        dwRet = pfn(lpGetDriverInfo);

    } RECOVERY_SECTION_END(pldev);

    if ((dwRet == DDHAL_DRIVER_HANDLED) &&
        (lpGetDriverInfo->ddRVal == DD_OK)) {

        if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_ColorControlCallbacks)) {

            PDD_COLORCONTROLCALLBACKS Callbacks = (PDD_COLORCONTROLCALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_COLOR_COLORCONTROL) {

                if (Callbacks->ColorControl != WatchdogDdColorControl) {

                    ppdevData->apfnDriver[INDEX_DdColorControl] = (PFN)Callbacks->ColorControl;
                }
                Callbacks->ColorControl = WatchdogDdColorControl;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_D3DCallbacks)) {

            LPD3DNTHAL_CALLBACKS Callbacks = (LPD3DNTHAL_CALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->ContextCreate) {

                if (Callbacks->ContextCreate != WatchdogDdContextCreate) {
                    ppdevData->apfnDriver[INDEX_DdContextCreate] = (PFN)Callbacks->ContextCreate;
                }
                Callbacks->ContextCreate = WatchdogDdContextCreate;
            }

            if (Callbacks->ContextDestroy) {

                if (Callbacks->ContextDestroy != WatchdogDdContextDestroy) {
                    ppdevData->apfnDriver[INDEX_DdContextDestroy] = (PFN)Callbacks->ContextDestroy;
                }
                Callbacks->ContextDestroy = WatchdogDdContextDestroy;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_D3DCallbacks3)) {

            LPD3DNTHAL_CALLBACKS3 Callbacks = (LPD3DNTHAL_CALLBACKS3) lpGetDriverInfo->lpvData;

            if (Callbacks->DrawPrimitives2) {

                if (Callbacks->DrawPrimitives2 != WatchdogDdDrawPrimitives2) {
                    ppdevData->apfnDriver[INDEX_DdDrawPrimitives2] = (PFN)Callbacks->DrawPrimitives2;
                }
                Callbacks->DrawPrimitives2 = WatchdogDdDrawPrimitives2;
            }

            if (Callbacks->ValidateTextureStageState) {

                if (Callbacks->ValidateTextureStageState != WatchdogDdValidateTextureStageState) {
                    ppdevData->apfnDriver[INDEX_DdValidateTextureStageState] = (PFN)Callbacks->ValidateTextureStageState;
                }
                Callbacks->ValidateTextureStageState = WatchdogDdValidateTextureStageState;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_KernelCallbacks)) {

            PDD_KERNELCALLBACKS Callbacks = (PDD_KERNELCALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_KERNEL_SYNCSURFACEDATA) {

                if (Callbacks->SyncSurfaceData != WatchdogDdSyncSurfaceData) {
                    ppdevData->apfnDriver[INDEX_DdSyncSurfaceData] = (PFN)Callbacks->SyncSurfaceData;
                }
                Callbacks->SyncSurfaceData = WatchdogDdSyncSurfaceData;
            }

            if (Callbacks->dwFlags & DDHAL_KERNEL_SYNCVIDEOPORTDATA) {

                if (Callbacks->SyncVideoPortData != WatchdogDdSyncVideoPortData) {
                    ppdevData->apfnDriver[INDEX_DdSyncVideoPortData] = (PFN)Callbacks->SyncVideoPortData;
                }
                Callbacks->SyncVideoPortData = WatchdogDdSyncVideoPortData;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_MiscellaneousCallbacks)) {

            PDD_MISCELLANEOUSCALLBACKS Callbacks = (PDD_MISCELLANEOUSCALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_MISCCB32_GETAVAILDRIVERMEMORY) {

                if (Callbacks->GetAvailDriverMemory != WatchdogDdGetAvailDriverMemory) {
                    ppdevData->apfnDriver[INDEX_DdGetAvailDriverMemory] = (PFN)Callbacks->GetAvailDriverMemory;
                }
                Callbacks->GetAvailDriverMemory = WatchdogDdGetAvailDriverMemory;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_Miscellaneous2Callbacks)) {

            PDD_MISCELLANEOUS2CALLBACKS Callbacks = (PDD_MISCELLANEOUS2CALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_MISC2CB32_ALPHABLT) {

                if (Callbacks->AlphaBlt != WatchdogDdAlphaBlt) {
                    ppdevData->apfnDriver[INDEX_DdAlphaBlt] = (PFN)Callbacks->AlphaBlt;
                }
                Callbacks->AlphaBlt = WatchdogDdAlphaBlt;
            }

            if (Callbacks->dwFlags & DDHAL_MISC2CB32_CREATESURFACEEX) {

                if (Callbacks->CreateSurfaceEx != WatchdogDdCreateSurfaceEx) {
                    ppdevData->apfnDriver[INDEX_DdCreateSurfaceEx] = (PFN)Callbacks->CreateSurfaceEx;
                }
                Callbacks->CreateSurfaceEx = WatchdogDdCreateSurfaceEx;
            }

            if (Callbacks->dwFlags & DDHAL_MISC2CB32_GETDRIVERSTATE) {

                if (Callbacks->GetDriverState != WatchdogDdGetDriverState) {
                    ppdevData->apfnDriver[INDEX_DdGetDriverState] = (PFN)Callbacks->GetDriverState;
                }
                Callbacks->GetDriverState = WatchdogDdGetDriverState;
            }

            if (Callbacks->dwFlags & DDHAL_MISC2CB32_DESTROYDDLOCAL) {

                if (Callbacks->DestroyDDLocal != WatchdogDdDestroyDDLocal) {
                    ppdevData->apfnDriver[INDEX_DdDestroyDDLocal] = (PFN)Callbacks->DestroyDDLocal;
                }
                Callbacks->DestroyDDLocal = WatchdogDdDestroyDDLocal;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_MotionCompCallbacks)) {

            //
            // TODO: Still need to implement
            //

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_NTCallbacks)) {

            PDD_NTCALLBACKS Callbacks = (PDD_NTCALLBACKS) lpGetDriverInfo->lpvData;

            if (Callbacks->dwFlags & DDHAL_NTCB32_FREEDRIVERMEMORY) {

                if (Callbacks->FreeDriverMemory != WatchdogDdFreeDriverMemory) {
                    ppdevData->apfnDriver[INDEX_DdFreeDriverMemory] = (PFN)Callbacks->FreeDriverMemory;
                }
                Callbacks->FreeDriverMemory = WatchdogDdFreeDriverMemory;
            }

            if (Callbacks->dwFlags & DDHAL_NTCB32_SETEXCLUSIVEMODE) {

                if (Callbacks->SetExclusiveMode != WatchdogDdSetExclusiveMode) {
                    ppdevData->apfnDriver[INDEX_DdSetExclusiveMode] = (PFN)Callbacks->SetExclusiveMode;
                }
                Callbacks->SetExclusiveMode = WatchdogDdSetExclusiveMode;
            }

            if (Callbacks->dwFlags & DDHAL_NTCB32_FLIPTOGDISURFACE) {

                if (Callbacks->FlipToGDISurface != WatchdogDdFlipToGDISurface) {
                    ppdevData->apfnDriver[INDEX_DdFlipToGDISurface] = (PFN)Callbacks->FlipToGDISurface;
                }
                Callbacks->FlipToGDISurface = WatchdogDdFlipToGDISurface;
            }

        } else if (IsEqualGUID(&lpGetDriverInfo->guidInfo, &GUID_VideoPortCallbacks)) {

            //
            // TODO: Still need to implement
            //
        }
    }

    return dwRet;
}

BOOL APIENTRY
WatchdogDrvGetDirectDrawInfo(
    DHPDEV        dhpdev,
    DD_HALINFO   *pHalInfo,
    DWORD        *pdwNumHeaps,
    VIDEOMEMORY  *pvmList,
    DWORD        *pdwNumFourCCCodes,
    DWORD        *pdwFourCC
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode(dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PFN_DrvGetDirectDrawInfo pfn = (PFN_DrvGetDirectDrawInfo) pldev->apfnDriver[INDEX_DrvGetDirectDrawInfo];
    BOOL bRet = 0;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return 0;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(dhpdev, pHalInfo, pdwNumHeaps, pvmList, pdwNumFourCCCodes, pdwFourCC);

    } RECOVERY_SECTION_END(pldev);

    //
    // If the function succeeded, then try to capture the DdGetDriverInfo
    // function from pHalInfo.
    //

    if (bRet) {
    
        if (pHalInfo->GetDriverInfo) {

            if (pHalInfo->GetDriverInfo != WatchdogDdGetDriverInfo) {
                ppdevData->apfnDriver[INDEX_DdGetDriverInfo] = (PFN)pHalInfo->GetDriverInfo;
            }
            pHalInfo->GetDriverInfo = WatchdogDdGetDriverInfo;
        }

        if (pHalInfo->lpD3DHALCallbacks) {

            LPD3DNTHAL_CALLBACKS lpD3DHALCallbacks;

            lpD3DHALCallbacks = (LPD3DNTHAL_CALLBACKS)pHalInfo->lpD3DHALCallbacks;

            //
            // Create copy of D3DHALCallbacks info - This is done to safely 
            // latch the callbacks witout actually changing driver local data
            //
            
            memcpy(&ppdevData->D3DHALCallbacks,
                   lpD3DHALCallbacks, 
                   min(sizeof(ppdevData->D3DHALCallbacks), lpD3DHALCallbacks->dwSize));

            pHalInfo->lpD3DHALCallbacks = lpD3DHALCallbacks = &ppdevData->D3DHALCallbacks;

            if (lpD3DHALCallbacks->ContextCreate &&
                lpD3DHALCallbacks->ContextDestroy) {

                if (lpD3DHALCallbacks->ContextCreate != WatchdogDdContextCreate) {
                    ppdevData->apfnDriver[INDEX_DdContextCreate] = (PFN)lpD3DHALCallbacks->ContextCreate;
                }

                if (lpD3DHALCallbacks->ContextDestroy != WatchdogDdContextDestroy) {
                    ppdevData->apfnDriver[INDEX_DdContextDestroy] = (PFN)lpD3DHALCallbacks->ContextDestroy;
                }

                lpD3DHALCallbacks->ContextCreate = WatchdogDdContextCreate;
                lpD3DHALCallbacks->ContextDestroy = WatchdogDdContextDestroy;
            }
        }

        if (pHalInfo->lpD3DBufCallbacks) {

            PDD_D3DBUFCALLBACKS lpD3DBufCallbacks;

            lpD3DBufCallbacks = pHalInfo->lpD3DBufCallbacks;

            //
            // Create copy of D3DBufCallbacks info - This is done to safely 
            // latch the callbacks witout actually changing driver local data
            //

            memcpy(&ppdevData->D3DBufCallbacks,
                   lpD3DBufCallbacks, 
                   min(sizeof(ppdevData->D3DBufCallbacks), lpD3DBufCallbacks->dwSize));

            lpD3DBufCallbacks = pHalInfo->lpD3DBufCallbacks = &ppdevData->D3DBufCallbacks;

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, CanCreateD3DBuffer)) &&
                (lpD3DBufCallbacks->CanCreateD3DBuffer)) {

                if (lpD3DBufCallbacks->CanCreateD3DBuffer != WatchdogDdCanCreateD3DBuffer) {
                    ppdevData->apfnDriver[INDEX_DdCanCreateD3DBuffer] = (PFN)lpD3DBufCallbacks->CanCreateD3DBuffer;
                }
                lpD3DBufCallbacks->CanCreateD3DBuffer = WatchdogDdCanCreateD3DBuffer;
            }

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, CreateD3DBuffer)) &&
                (lpD3DBufCallbacks->CreateD3DBuffer)) {

                if (lpD3DBufCallbacks->CreateD3DBuffer != WatchdogDdCreateD3DBuffer) {
                    ppdevData->apfnDriver[INDEX_DdCreateD3DBuffer] = (PFN)lpD3DBufCallbacks->CreateD3DBuffer;
                }
                lpD3DBufCallbacks->CreateD3DBuffer = WatchdogDdCreateD3DBuffer;
            }

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, DestroyD3DBuffer)) &&
                (lpD3DBufCallbacks->DestroyD3DBuffer)) {

                if (lpD3DBufCallbacks->DestroyD3DBuffer != WatchdogDdDestroyD3DBuffer) {
                    ppdevData->apfnDriver[INDEX_DdDestroyD3DBuffer] = (PFN)lpD3DBufCallbacks->DestroyD3DBuffer;
                }
                lpD3DBufCallbacks->DestroyD3DBuffer = WatchdogDdDestroyD3DBuffer;
            }

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, LockD3DBuffer)) &&
                (lpD3DBufCallbacks->LockD3DBuffer)) {

                if (lpD3DBufCallbacks->LockD3DBuffer != WatchdogDdLockD3DBuffer) {
                    ppdevData->apfnDriver[INDEX_DdLockD3DBuffer] = (PFN)lpD3DBufCallbacks->LockD3DBuffer;
                }
                lpD3DBufCallbacks->LockD3DBuffer = WatchdogDdLockD3DBuffer;
            }

            if ((lpD3DBufCallbacks->dwSize > FIELD_OFFSET(DD_D3DBUFCALLBACKS, UnlockD3DBuffer)) &&
                (lpD3DBufCallbacks->UnlockD3DBuffer)) {

                if (lpD3DBufCallbacks->UnlockD3DBuffer != WatchdogDdUnlockD3DBuffer) {
                    ppdevData->apfnDriver[INDEX_DdUnlockD3DBuffer] = (PFN)lpD3DBufCallbacks->UnlockD3DBuffer;
                }
                lpD3DBufCallbacks->UnlockD3DBuffer = WatchdogDdUnlockD3DBuffer;
            }
        }
    }

    return bRet;
}

BOOL APIENTRY
WatchdogDrvEnableDirectDraw(
    DHPDEV               dhpdev,
    DD_CALLBACKS        *pCallBacks,
    DD_SURFACECALLBACKS *pSurfaceCallBacks,
    DD_PALETTECALLBACKS *pPaletteCallBacks
    )

{
    PDHPDEV_ASSOCIATION_NODE ppdevData = (PDHPDEV_ASSOCIATION_NODE) dhpdevRetrieveNode(dhpdev);
    PLDEV pldev = ppdevData->pldev;
    PFN_DrvEnableDirectDraw pfn = (PFN_DrvEnableDirectDraw) pldev->apfnDriver[INDEX_DrvEnableDirectDraw];
    BOOL bRet = FALSE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return FALSE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(dhpdev, pCallBacks, pSurfaceCallBacks, pPaletteCallBacks);

    } RECOVERY_SECTION_END(pldev);

    //
    // If the function succeeded, then try to capture the Callback functions.
    //

    if (bRet) {

        //
        // Capture generic callbacks
        //

        if (pCallBacks->dwFlags & DDHAL_CB32_CANCREATESURFACE) {

            if (pCallBacks->CanCreateSurface != WatchdogDdCanCreateSurface) {
                ppdevData->apfnDriver[INDEX_DdCanCreateSurface] = (PFN)pCallBacks->CanCreateSurface;
            }
            pCallBacks->CanCreateSurface = WatchdogDdCanCreateSurface;
        }

        if (pCallBacks->dwFlags & DDHAL_CB32_CREATESURFACE) {

            if (pCallBacks->CreateSurface != WatchdogDdCreateSurface) {
                ppdevData->apfnDriver[INDEX_DdCreateSurface] = (PFN)pCallBacks->CreateSurface;
            }
            pCallBacks->CreateSurface = WatchdogDdCreateSurface;
        }

        if (pCallBacks->dwFlags & DDHAL_CB32_CREATEPALETTE) {

            if (pCallBacks->CreatePalette != WatchdogDdCreatePalette) {
                ppdevData->apfnDriver[INDEX_DdCreatePalette] = (PFN)pCallBacks->CreatePalette;
            }
            pCallBacks->CreatePalette = WatchdogDdCreatePalette;
        }

        if (pCallBacks->dwFlags & DDHAL_CB32_GETSCANLINE) {

            if (pCallBacks->GetScanLine != WatchdogDdGetScanLine) {
                ppdevData->apfnDriver[INDEX_DdGetScanLine] = (PFN)pCallBacks->GetScanLine;
            }
            pCallBacks->GetScanLine = WatchdogDdGetScanLine;
        }

        if (pCallBacks->dwFlags & DDHAL_CB32_MAPMEMORY) {

            if (pCallBacks->MapMemory != WatchdogDdMapMemory) {
                ppdevData->apfnDriver[INDEX_DdMapMemory] = (PFN)pCallBacks->MapMemory;
            }
            pCallBacks->MapMemory = WatchdogDdMapMemory;
        }

#if 0
        //
        // We can't hook this because there is no way to get the dhpdev
        // back
        //

        if (pCallBacks->dwFlags & DDHAL_CB32_SETCOLORKEY) {

            if (pCallBacks->SetColorKey != WatchdogDdSetColorKey) {
                ppdevData->apfnDriver[INDEX_DdSetColorKey] = (PFN)pCallBacks->SetColorKey;
            }
            pCallBacks->SetColorKey = WatchdogDdSetColorKey;
        }
#endif

        if (pCallBacks->dwFlags & DDHAL_CB32_WAITFORVERTICALBLANK) {

            if (pCallBacks->WaitForVerticalBlank != WatchdogDdWaitForVerticalBlank) {
                ppdevData->apfnDriver[INDEX_DdWaitForVerticalBlank] = (PFN)pCallBacks->WaitForVerticalBlank;
            }
            pCallBacks->WaitForVerticalBlank = WatchdogDdWaitForVerticalBlank;
        }

        //
        // Capture Surface Callbacks
        //

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_DESTROYSURFACE) {

            if (pSurfaceCallBacks->DestroySurface != WatchdogDdDestroySurface) {
                ppdevData->apfnDriver[INDEX_DdDestroySurface] = (PFN)pSurfaceCallBacks->DestroySurface;
            }
            pSurfaceCallBacks->DestroySurface = WatchdogDdDestroySurface;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_FLIP) {

            if (pSurfaceCallBacks->Flip != WatchdogDdFlip) {
                ppdevData->apfnDriver[INDEX_DdFlip] = (PFN)pSurfaceCallBacks->Flip;
            }
            pSurfaceCallBacks->Flip = WatchdogDdFlip;
        }

#if 0
        //
        // SetClipList is obsolete
        //

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_SETCLIPLIST) {

            if (pSurfaceCallBacks->SetClipList != WatchdogDdSetClipList) {
                ppdevData->apfnDriver[INDEX_DdSetClipList] = (PFN)pSurfaceCallBacks->SetClipList;
            }
            pSurfaceCallBacks->SetClipList = WatchdogDdSetClipList;
        }
#endif

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_LOCK) {

            if (pSurfaceCallBacks->Lock != WatchdogDdLock) {
                ppdevData->apfnDriver[INDEX_DdLock] = (PFN)pSurfaceCallBacks->Lock;
            }
            pSurfaceCallBacks->Lock = WatchdogDdLock;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_UNLOCK) {

            if (pSurfaceCallBacks->Unlock != WatchdogDdUnlock) {
                ppdevData->apfnDriver[INDEX_DdUnlock] = (PFN)pSurfaceCallBacks->Unlock;
            }
            pSurfaceCallBacks->Unlock = WatchdogDdUnlock;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_BLT) {

            if (pSurfaceCallBacks->Blt != WatchdogDdBlt) {
                ppdevData->apfnDriver[INDEX_DdBlt] = (PFN)pSurfaceCallBacks->Blt;
            }
            pSurfaceCallBacks->Blt = WatchdogDdBlt;
        }

#if 0
        //
        // We can't hook this because there is no way to get the dhpdev
        // back
        //

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_SETCOLORKEY) {

            if (pSurfaceCallBacks->SetColorKey != WatchdogDdSetColorKey) {
                ppdevData->apfnDriver[INDEX_DdSetColorKey] = (PFN)pSurfaceCallBacks->SetColorKey;
            }
            pSurfaceCallBacks->SetColorKey = WatchdogDdSetColorKey;
        }
#endif

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_ADDATTACHEDSURFACE) {

            if (pSurfaceCallBacks->AddAttachedSurface != WatchdogDdAddAttachedSurface) {
                ppdevData->apfnDriver[INDEX_DdAddAttachedSurface] = (PFN)pSurfaceCallBacks->AddAttachedSurface;
            }
            pSurfaceCallBacks->AddAttachedSurface = WatchdogDdAddAttachedSurface;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_GETBLTSTATUS) {

            if (pSurfaceCallBacks->GetBltStatus != WatchdogDdGetBltStatus) {
                ppdevData->apfnDriver[INDEX_DdGetBltStatus] = (PFN)pSurfaceCallBacks->GetBltStatus;
            }
            pSurfaceCallBacks->GetBltStatus = WatchdogDdGetBltStatus;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_GETFLIPSTATUS) {

            if (pSurfaceCallBacks->GetFlipStatus != WatchdogDdGetFlipStatus) {
                ppdevData->apfnDriver[INDEX_DdGetFlipStatus] = (PFN)pSurfaceCallBacks->GetFlipStatus;
            }
            pSurfaceCallBacks->GetFlipStatus = WatchdogDdGetFlipStatus;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_UPDATEOVERLAY) {

            if (pSurfaceCallBacks->UpdateOverlay != WatchdogDdUpdateOverlay) {
                ppdevData->apfnDriver[INDEX_DdUpdateOverlay] = (PFN)pSurfaceCallBacks->UpdateOverlay;
            }
            pSurfaceCallBacks->UpdateOverlay = WatchdogDdUpdateOverlay;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_SETOVERLAYPOSITION) {

            if (pSurfaceCallBacks->SetOverlayPosition != WatchdogDdSetOverlayPosition) {
                ppdevData->apfnDriver[INDEX_DdSetOverlayPosition] = (PFN)pSurfaceCallBacks->SetOverlayPosition;
            }
            pSurfaceCallBacks->SetOverlayPosition = WatchdogDdSetOverlayPosition;
        }

        if (pSurfaceCallBacks->dwFlags & DDHAL_SURFCB32_SETPALETTE) {

            if (pSurfaceCallBacks->SetPalette != WatchdogDdSetPalette) {
                ppdevData->apfnDriver[INDEX_DdSetPalette] = (PFN)pSurfaceCallBacks->SetPalette;
            }
            pSurfaceCallBacks->SetPalette = WatchdogDdSetPalette;
        }

        //
        // Capture Palette Callbacks
        //

        if (pPaletteCallBacks->dwFlags & DDHAL_PALCB32_DESTROYPALETTE) {

            if (pPaletteCallBacks->DestroyPalette != WatchdogDdDestroyPalette) {
                ppdevData->apfnDriver[INDEX_DdDestroyPalette] = (PFN)pPaletteCallBacks->DestroyPalette;
            }
            pPaletteCallBacks->DestroyPalette = WatchdogDdDestroyPalette;
        }

        if (pPaletteCallBacks->dwFlags & DDHAL_PALCB32_SETENTRIES) {

            if (pPaletteCallBacks->SetEntries != WatchdogDdSetEntries) {
                ppdevData->apfnDriver[INDEX_DdSetEntries] = (PFN)pPaletteCallBacks->SetEntries;
            }
            pPaletteCallBacks->SetEntries = WatchdogDdSetEntries;
        }
    }

    return bRet;
}

VOID APIENTRY
WatchdogDrvDisableDirectDraw(
    DHPDEV dhpdev
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvDisableDirectDraw pfn = (PFN_DrvDisableDirectDraw) pldev->apfnDriver[INDEX_DrvDisableDirectDraw];

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        pfn(dhpdev);

    } RECOVERY_SECTION_END(pldev);
}

BOOL APIENTRY
WatchdogDrvIcmSetDeviceGammaRamp(
    IN DHPDEV dhpdev,
    IN ULONG iFormat,
    IN LPVOID ipRamp
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvIcmSetDeviceGammaRamp pfn = (PFN_DrvIcmSetDeviceGammaRamp) pldev->apfnDriver[INDEX_DrvIcmSetDeviceGammaRamp];
    BOOL bRet = TRUE;

    if (pldev->bThreadStuck) {
        return bRet;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(dhpdev, iFormat, ipRamp);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PLDEV pldev = dhpdevRetrieveLdev(psoDevice->dhpdev);
    PFN_DrvStretchBltROP pfn = (PFN_DrvStretchBltROP) pldev->apfnDriver[INDEX_DrvStretchBltROP];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg, prclDst, prclSrc, pptlMask, iMode, pbo, rop4);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvPlgBlt(
    IN SURFOBJ *psoTrg,
    IN SURFOBJ *psoSrc,
    IN SURFOBJ *psoMsk,
    IN CLIPOBJ *pco,
    IN XLATEOBJ *pxlo,
    IN COLORADJUSTMENT *pca,
    IN POINTL *pptlBrushOrg,
    IN POINTFIX *pptfx,
    IN RECTL *prcl,
    IN POINTL *pptl,
    IN ULONG iMode
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(psoTrg->dhpdev);
    PFN_DrvPlgBlt pfn = (PFN_DrvPlgBlt) pldev->apfnDriver[INDEX_DrvPlgBlt];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(psoTrg, psoSrc, psoMsk, pco, pxlo, pca, pptlBrushOrg, pptfx, prcl, pptl, iMode);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvAlphaBlend(
    SURFOBJ *psoDest,
    SURFOBJ *psoSrc,
    CLIPOBJ *pco,
    XLATEOBJ *pxlo,
    RECTL *prclDest,
    RECTL *prclSrc,
    BLENDOBJ *pBlendObj
    )

{
    SURFOBJ *psoDevice = (psoDest->dhpdev) ? psoDest : psoSrc;
    PLDEV pldev = dhpdevRetrieveLdev(psoDevice->dhpdev);
    PFN_DrvAlphaBlend pfn = (PFN_DrvAlphaBlend) pldev->apfnDriver[INDEX_DrvAlphaBlend];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(psoDest, psoSrc, pco, pxlo, prclDest, prclSrc, pBlendObj);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvGradientFill(
    SURFOBJ *psoDest,
    CLIPOBJ *pco,
    XLATEOBJ *pxlo,
    TRIVERTEX *pVertex,
    ULONG nVertex,
    PVOID pMesh,
    ULONG nMesh,
    RECTL *prclExtents,
    POINTL *pptlDitherOrg,
    ULONG ulMode
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(psoDest->dhpdev);
    PFN_DrvGradientFill pfn = (PFN_DrvGradientFill) pldev->apfnDriver[INDEX_DrvGradientFill];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(psoDest, pco, pxlo, pVertex, nVertex, pMesh, nMesh, prclExtents, pptlDitherOrg, ulMode);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

BOOL APIENTRY
WatchdogDrvTransparentBlt(
    SURFOBJ *psoDst,
    SURFOBJ *psoSrc,
    CLIPOBJ *pco,
    XLATEOBJ *pxlo,
    RECTL *prclDst,
    RECTL *prclSrc,
    ULONG iTransColor,
    ULONG ulReserved
    )

{
    SURFOBJ *psoDevice = (psoDst->dhpdev) ? psoDst : psoSrc;
    PLDEV pldev = dhpdevRetrieveLdev(psoDevice->dhpdev);
    PFN_DrvTransparentBlt pfn = (PFN_DrvTransparentBlt) pldev->apfnDriver[INDEX_DrvTransparentBlt];
    BOOL bRet = TRUE;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return TRUE;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        bRet = pfn(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, iTransColor, ulReserved);

    } RECOVERY_SECTION_END(pldev);

    return bRet;
}

HBITMAP APIENTRY
WatchdogDrvDeriveSurface(
    DD_DIRECTDRAW_GLOBAL *pDirectDraw,
    DD_SURFACE_LOCAL *pSurface
    )

{
    PLDEV pldev = dhpdevRetrieveLdev((DHPDEV)pDirectDraw->dhpdev);
    PFN_DrvDeriveSurface pfn = (PFN_DrvDeriveSurface) pldev->apfnDriver[INDEX_DrvDeriveSurface];
    HBITMAP hBitmap = NULL;

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck == FALSE) {
    
        RECOVERY_SECTION_BEGIN(pldev) {

            hBitmap = pfn(pDirectDraw, pSurface);

        } RECOVERY_SECTION_END(pldev);
    }

    return hBitmap;
}

VOID APIENTRY
WatchdogDrvNotify(
    IN SURFOBJ *pso,
    IN ULONG iType,
    IN PVOID pvData
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvNotify pfn = (PFN_DrvNotify) pldev->apfnDriver[INDEX_DrvNotify];

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        pfn(pso, iType, pvData);

    } RECOVERY_SECTION_END(pldev);
}

VOID APIENTRY
WatchdogDrvSynchronizeSurface(
    IN SURFOBJ *pso,
    IN RECTL *prcl,
    IN FLONG fl
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(pso->dhpdev);
    PFN_DrvSynchronizeSurface pfn = (PFN_DrvSynchronizeSurface) pldev->apfnDriver[INDEX_DrvSynchronizeSurface];

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        pfn(pso, prcl, fl);

    } RECOVERY_SECTION_END(pldev);
}

VOID APIENTRY
WatchdogDrvResetDevice(
    DHPDEV dhpdev,
    PVOID Reserved
    )

{
    PLDEV pldev = dhpdevRetrieveLdev(dhpdev);
    PFN_DrvResetDevice pfn = (PFN_DrvResetDevice) pldev->apfnDriver[INDEX_DrvResetDevice];

    //
    // Return early if we are in a thread stuck condition
    //

    if (pldev->bThreadStuck) {
        return;
    }

    RECOVERY_SECTION_BEGIN(pldev) {

        pfn(dhpdev, Reserved);

    } RECOVERY_SECTION_END(pldev);
}

//
// The following table contains the replacement functions which
// hooks the real driver entry points, and set up the try/except
// handlers.
//

PFN WatchdogTable[INDEX_LAST] =
{
    (PFN)WatchdogDrvEnablePDEV,
    (PFN)WatchdogDrvCompletePDEV,
    (PFN)WatchdogDrvDisablePDEV,
    (PFN)WatchdogDrvEnableSurface,
    (PFN)WatchdogDrvDisableSurface,

    (PFN)WatchdogDrvAssertMode,
    0, // DrvOffset - obsolete
    (PFN)WatchdogDrvResetPDEV,
    0, // DrvDisableDriver - don't hook
    0, // not assigned

    (PFN)WatchdogDrvCreateDeviceBitmap,
    (PFN)WatchdogDrvDeleteDeviceBitmap,
    (PFN)WatchdogDrvRealizeBrush,
    (PFN)WatchdogDrvDitherColor,
    (PFN)WatchdogDrvStrokePath,

    (PFN)WatchdogDrvFillPath,
    (PFN)WatchdogDrvStrokeAndFillPath,
    0, // DrvPaint - obsolete
    (PFN)WatchdogDrvBitBlt,
    (PFN)WatchdogDrvCopyBits,

    (PFN)WatchdogDrvStretchBlt,
    0, // not assigned
    (PFN)WatchdogDrvSetPalette,
    (PFN)WatchdogDrvTextOut,
    (PFN)WatchdogDrvEscape,

    (PFN)WatchdogDrvDrawEscape,
    0, // DrvQueryFont
    0, // DrvQueryFontTree
    0, // DrvQueryFontData
    (PFN)WatchdogDrvSetPointerShape,

    (PFN)WatchdogDrvMovePointer,
    (PFN)WatchdogDrvLineTo,
    0, // DrvSendPage
    0, // DrvStartPage
    0, // DrvEndDoc

    0, // DrvStartDoc
    0, // not assigned
    0, // DrvGetGlyphMode
    (PFN)WatchdogDrvSynchronize,
    0, // not assigned

    (PFN)WatchdogDrvSaveScreenBits,
    0, // DrvGetModes - don't hook
    0, // DrvFree
    0, // DrvDestroyFont
    0, // DrvQueryFontCaps

    0, // DrvLoadFontFile
    0, // DrvUnloadFontFile
    0, // DrvFontManagement
    0, // DrvQueryTrueTypeTable
    0, // DrvQueryTrueTypeOutline

    0, // DrvGetTrueTypeFile
    0, // DrvQueryFontFile
    0, // DrvMovePanning
    0, // DrvQueryAdvanceWidths
    (PFN)WatchdogDrvSetPixelFormat,

    (PFN)WatchdogDrvDescribePixelFormat,
    (PFN)WatchdogDrvSwapBuffers,
    0, // DrvStartBanding
    0, // DrvNextBand
    (PFN)WatchdogDrvGetDirectDrawInfo,

    (PFN)WatchdogDrvEnableDirectDraw,
    (PFN)WatchdogDrvDisableDirectDraw,
    0, // DrvQuerySpoolType
    0, // not assigned
    0, // DrvIcmCreateColorTransform

    0, // DrvIcmDeleteColorTransform
    0, // DrvIcmCheckBitmapBits
    (PFN)WatchdogDrvIcmSetDeviceGammaRamp,
    (PFN)WatchdogDrvGradientFill,
    (PFN)WatchdogDrvStretchBltROP,

    (PFN)WatchdogDrvPlgBlt,
    (PFN)WatchdogDrvAlphaBlend,
    0, // DrvSynthesizeFont
    0, // DrvGetSynthesizedFontFiles
    (PFN)WatchdogDrvTransparentBlt,

    0, // DrvQueryPerBandInfo
    0, // DrvQueryDeviceSupport
    0, // reserved
    0, // reserved
    0, // reserved

    0, // reserved
    0, // reserved
    0, // reserved
    0, // reserved
    0, // reserved

    (PFN)WatchdogDrvDeriveSurface,
    0, // DrvQueryGlyphAttrs
    (PFN)WatchdogDrvNotify,
    (PFN)WatchdogDrvSynchronizeSurface,
    (PFN)WatchdogDrvResetDevice,

    0, // reserved
    0, // reserved
    0  // reserved
};

BOOL
WatchdogIsFunctionHooked(
    IN PLDEV pldev,
    IN ULONG functionIndex
    )

/*++

Routine Description:

    This function checks to see whether the Create/DeleteDeviceBitmap
    driver entry points are hooked.

Return Value:

    TRUE if the entry point is hooked,
    FALSE otherwise

--*/

{
    ASSERTGDI(functionIndex < INDEX_LAST, "functionIndex out of range");
    return pldev->apfn[functionIndex] == WatchdogTable[functionIndex];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\w32kevnt.h ===
/////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
//  Display driver/Eng interface.
//
/////////////////////////////////////////////////////////

//
//  Opaque type for event objects.
//

typedef struct _ENG_EVENT *PEVENT;

BOOL
EngDeleteEvent(
    IN  PEVENT pEvent
    );

BOOL
EngCreateEvent(
    OUT PEVENT *ppEvent
    );

BOOL
EngUnmapEvent(
    IN PEVENT pEvent
    );

PEVENT
EngMapEvent(
    IN  HDEV            hDev,
    IN  HANDLE          hUserObject,
    IN  OUT PVOID       Reserved1,
    IN  PVOID           Reserved2,
    IN  PVOID           Reserved3
    );

BOOL
EngWaitForSingleObject(
    IN  PEVENT          pEvent,
    IN  PLARGE_INTEGER  pTimeOut
    );

LONG
EngSetEvent(
    IN  PEVENT pEvent
    );

VOID
EngClearEvent (
IN PEVENT pEvent
);

LONG
EngReadStateEvent (
IN PEVENT pEvent
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\gdiplus\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\daytona\makefile.inc ===
PRIVATEINCS= $(PROJECT_ROOT)\$(SRCBASE)\ntgdi\math\daytona\$(TARGET_H_DIRECTORY)\efloat.hxx
!include ..\makefile.inc

# Force guids.c to be built as a native object.
!if $(IA64) && defined(LINK_TIME_CODE_GENERATION)
$(O)\guids.obj: ..\guids.c
       @type <<$(ECHO_RSP) 
$(ECHO_MSG_P:/GL=)
<<NOKEEP 
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC) $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS:/GL=) 
$**
<<NOKEEP                                                                       
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\ylateobj.cxx ===
/****************************Module*Header*******************************\
* Module Name: ylateobj.cxx
*
* This contains the xlate object constructors, destructors and methods
* An xlateobj is used to translate indexes from one palette to another.
*
* When blting between raster surfaces we create a translate object
* between to speed up the BitBlt.  When the destination surface is
* palette managed we have to do a bit more work.
*
* Created: 18-Nov-1990 14:23:55
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" VOID vInitXLATE();

#pragma alloc_text(INIT, vInitXLATE)

// These two variables are for the translate components cacheing of
// translate objects.  There access is restricted to being done only
// after the palette semaphore has been grabbed.

XLATETABLE xlateTable[XLATE_CACHE_SIZE];
ULONG ulTableIndex = 0;

TRANSLATE20 defaultTranslate =
{
    0,
    {0,1,2,3,4,5,6,7,8,9,246,247,248,249,250,251,252,253,254,255}
};

// This is the identity xlate object

XLATE256 xloIdent;

/******************************Public*Routine******************************\
* vInitXLATE
*
* initialize the xlateobj component
*
* History:
*  10-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" VOID vInitXLATE()
{
    RtlZeroMemory(xlateTable, (UINT) XLATE_CACHE_SIZE * sizeof(XLATETABLE));

    xloIdent.iUniq    = XLATE_IDENTITY_UNIQ;
    xloIdent.flXlate  = XO_TRIVIAL;
    xloIdent.iSrcType = 0;
    xloIdent.iDstType = 0;
    xloIdent.cEntries = 256;
    xloIdent.pulXlate = xloIdent.ai;
    xloIdent.iBackSrc = 0;
    xloIdent.iForeDst = 0;
    xloIdent.iBackDst = 0;

    //
    // This may seem hackish but XLATE_CACHE_JOURANL ensures that
    // it doesn't cause anything to get unlocked or freed in
    // the destructor.
    //

    xloIdent.lCacheIndex = XLATE_CACHE_JOURNAL;
    xloIdent.ppalSrc = (PPALETTE) NULL;
    xloIdent.ppalDst = (PPALETTE) NULL;
    xloIdent.ppalDstDC = (PPALETTE) NULL;

    xloIdent.hcmXform = NULL;
    xloIdent.lIcmMode = DC_ICM_OFF;

    UINT uiTemp;

    for (uiTemp = 0; uiTemp < 256; uiTemp++)
    {
        xloIdent.ai[uiTemp] = uiTemp;
    }
}


/******************************Public*Routine******************************\
* EXLATEOBJ::vDelete
*
* Deletes the object.
*
* History:
*  Sun 17-Oct-1993 -by- Patrick Haluptzok [patrickh]
* Kill hmgr references.
*
*  26-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID EXLATEOBJ::vDelete()
{
    if (pxlate != (PXLATE) NULL)
    {
        if (pxlate->lCacheIndex == XLATE_CACHE_JOURNAL)
        {
            if (ppalSrc())
            {
                bDeletePalette((HPAL) ppalSrc()->hGet());
            }
        }

        VFREEMEM(pxlate);
        pxlate = (PXLATE) NULL;
    }
}


/******************************Public*Routine******************************\
* XLATEMEMOBJ destructor
*
* destructor for xlate memory objects
*
* History:
*  Mon 19-Nov-1990 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

XLATEMEMOBJ::~XLATEMEMOBJ()
{
    if (pxlate != (PXLATE) NULL)
    {
        VFREEMEM(pxlate);
        pxlate = (PXLATE) NULL;
    }
}


/******************************Public*Routine******************************\
* XLATE::vMapNewXlate
*
*   Maps a pxlate from being relative to one palette to being relative to
*   another palette.
*
* Arguments:
*
*   ptrans - Translate to map
*
* History:
*  10-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID
FASTCALL
XLATE::vMapNewXlate(
    PTRANSLATE ptrans
    )
{
    ULONG ulTemp;
    ULONG ulCount = cEntries;

    if (ptrans == NULL)
    {
        //
        // This is the default palette case
        //

        while (ulCount--)
        {
            ulTemp = ai[ulCount];

            if (ulTemp >= 10)
            {
                ai[ulCount] = ulTemp + 236;
            }

            //
            // else
            //
            //
            // do nothing, the first 10 are a 1 to 1 mapping.
            //
        }
    }
    else
    {
        ULONG *pultemp = ai;

        while (ulCount--)
        {
            *pultemp = (ULONG) ptrans->ajVector[*pultemp];
            pultemp++;

            //
            // ai[ulCount] = (ULONG) ptrans->ajVector[ai[ulCount]];
            //
        }
    }
}


/******************************Public*Routine******************************\
* EXLATEOBJ::bMakeXlate
*
*   This is called by SetDIBitsToDevice for the DIB_PAL_COLORS case.
*   This takes the indices in bmiColors and translates them through
*   a logical palette.
*
* Arguments:
*
*   pusIndices      -
*   palDC           -
*   pSurfDst        -
*   cEntriesInit    -
*   cEntriesMax     -
*
* History:
*  17-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EXLATEOBJ::bMakeXlate(
    PUSHORT  pusIndices,
    XEPALOBJ palDC,
    SURFACE *pSurfDst,
    ULONG    cEntriesInit,
    ULONG    cEntriesMax
    )
{
    ASSERTGDI(pSurfDst != NULL, "ERROR GDI bMakeXlate1");
    ASSERTGDI(palDC.bValid(), "ERROR bMakeXlate 134");

    XEPALOBJ palDst(pSurfDst->ppal());

    ULONG ulTemp;
    ULONG ulIndex;

    //
    // count of colors in DC
    //

    ULONG cColorsDC;
    PXLATE pXlateTemp;

    ASSERTGDI(palDC.cEntries() != 0, "ERROR 0 entry dc palette isn't allowed");

    //
    // Allocate room for the Xlate.
    //

    pxlate = pXlateTemp = (PXLATE) PALLOCNOZ(sizeof(XLATE) +
                                                (sizeof(ULONG) * cEntriesMax),
                                             'tlxG');

    if (pXlateTemp == (PXLATE)NULL)
    {
        WARNING("GDISRV bMakeXlate failed memory allocation\n");
        return(FALSE);
    }

    pXlateTemp->iUniq       = ulGetNewUniqueness(ulXlatePalUnique);
    pXlateTemp->flXlate     = XO_TABLE;
    pXlateTemp->iSrcType    = pXlateTemp->iDstType = 0;
    pXlateTemp->cEntries    = cEntriesMax;
    pXlateTemp->pulXlate    = pXlateTemp->ai;
    pXlateTemp->iBackSrc    = 0;
    pXlateTemp->iForeDst    = 0;
    pXlateTemp->iBackDst    = 0;
    pXlateTemp->lCacheIndex = XLATE_CACHE_INVALID;
    pXlateTemp->ppalSrc     = (PPALETTE) NULL;
    pXlateTemp->ppalDst     = palDst.ppalGet();
    pXlateTemp->ppalDstDC   = palDC.ppalGet();

    RtlZeroMemory(((ULONG *)pXlateTemp->ai) + cEntriesInit,
                  (UINT) (cEntriesMax - cEntriesInit) * sizeof(ULONG));

    PAL_ULONG palentry;
    PTRANSLATE ptrans;
    cColorsDC = palDC.cEntries();

    //
    // Grab the palette semaphore so you can touch the pxlates.
    //

    SEMOBJ  semo(ghsemPalette);

    //
    // Ok fill in the pxlate correctly.
    //

    if ((!palDst.bValid()) || (palDst.bIsPalManaged()))
    {
        //
        // Do the palette managed cases
        //

        if (palDC.bIsPalDefault())
        {
            for(ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
            {
                //
                // Get the index into the logical palette
                //

                ulIndex = (ULONG) pusIndices[ulTemp];

                //
                // Make sure it isn't too large
                //

                if (ulIndex >= 20)
                {
                    ulIndex = ulIndex % 20;
                }

                if (ulIndex < 10)
                {
                    pXlateTemp->ai[ulTemp] = ulIndex;
                }
                else
                {
                    pXlateTemp->ai[ulTemp] = ulIndex + 236;
                }
            }
        }
        else if (palDst.bValid() && (palDC.ptransCurrent() != NULL))
        {
            //
            // Map through the current translate.
            //

            ptrans = palDC.ptransCurrent();

            for(ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
            {
                //
                // Get the index into the logical palette
                //

                ulIndex = (ULONG) pusIndices[ulTemp];

                if (ulIndex >= cColorsDC)
                {
                    ulIndex = ulIndex % cColorsDC;
                }

                pXlateTemp->ai[ulTemp] = (ULONG) ptrans->ajVector[ulIndex];

                ASSERTGDI(pXlateTemp->ai[ulTemp] < 256, "ERROR GDI bMakeXlate6");
            }
        }
        else if ((!palDst.bValid()) && (palDC.ptransFore() != NULL))
        {
            //
            // It's a bitmap, Map through the foreground translate.
            //

            ptrans = palDC.ptransFore();

            for(ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
            {
                //
                // Get the index into the logical palette
                //

                ulIndex = (ULONG) pusIndices[ulTemp];

                if (ulIndex >= cColorsDC)
                {
                    ulIndex = ulIndex % cColorsDC;
                }

                pXlateTemp->ai[ulTemp] = (ULONG) ptrans->ajVector[ulIndex];

             ASSERTGDI(pXlateTemp->ai[ulTemp] < 256, "ERROR GDI bMakeXlate6");
            }
        }
        else
        {
            //
            // It's palette hasn't been realized.  Grab the palette value and
            // then map into default palette if not PC_EXPLICIT entry.
            //

            for (ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
            {
                //
                // Get the index into the logical palette
                //

                ulIndex = (ULONG) pusIndices[ulTemp];

                if (ulIndex >= cColorsDC)
                {
                    ulIndex = ulIndex % cColorsDC;
                }

                palentry.ul = palDC.ulEntryGet(ulIndex);

                if (palentry.pal.peFlags == PC_EXPLICIT)
                {
                    //
                    // Get the correct index in the surface palette.
                    //

                    ulIndex = palentry.ul & 0x0000FFFF;

                    if (ulIndex >= 256)
                    {
                        ulIndex = ulIndex % 256;
                    }
                }
                else
                {
                    //
                    // Match against the default palette entries.
                    //

                    ulIndex = ((XEPALOBJ) ppalDefault).ulGetNearestFromPalentry(palentry.pal);

                    if (ulIndex >= 10)
                    {
                        ulIndex = ulIndex + 236;
                    }
                }

                pXlateTemp->ai[ulTemp] = ulIndex;
                ASSERTGDI(pXlateTemp->ai[ulTemp] < 256, "ERROR GDI bMakeXlate6");
            }
        }
    }
    else
    {
        //
        // Find the RGB in the palDC (reaching down to palDst for
        // PC_EXPLICIT entries).  Then find closest match in surface palette.
        //

        ASSERTGDI(palDst.bValid(), "ERROR palDst is not valid");

        for (ulTemp = 0; ulTemp < cEntriesInit; ulTemp++)
        {
            //
            // Get the index into the logical palette
            //

            palentry.ul = (ULONG) pusIndices[ulTemp];

            if (palentry.ul >= cColorsDC)
            {
                palentry.ul = palentry.ul % cColorsDC;
            }

            palentry.pal = palDC.palentryGet(palentry.ul);

            if (palentry.pal.peFlags == PC_EXPLICIT)
            {
                //
                // Get the correct index in the surface palette.
                //

                if (palDst.cEntries())
                {
                    palentry.ul = palentry.ul & 0x0000FFFF;

                    if (palentry.ul >= palDst.cEntries())
                    {
                        palentry.ul = palentry.ul % palDst.cEntries();
                    }
                }
                else
                {
                    //
                    // Well what else can we do ?
                    //

                    palentry.ul = 0;
                }

                pXlateTemp->ai[ulTemp] = palentry.ul;
            }
            else
            {
                pXlateTemp->ai[ulTemp] = palDst.ulGetNearestFromPalentry(palentry.pal);
            }
        }
    }

    pxlate->vCheckForTrivial();
    return(TRUE);
}


//
// This describes the overall logic of surface to surface xlates.
// There are basically n types of xlates to worry about:
//
// 1. XO_TRIVIAL - no translation occurs, identity.
//
// 2. XO_TABLE - look up in a table for the correct table translation.
//
//     a. XO_TO_MONO - look in to table for the correct tranlation,
//        but when getting it out of the cache make sure iBackSrc is the
//        same.  iBackSrc goes to 1, everything else to 0.
//     b. XLATE_FROM_MONO - look into table for the correct translation
//        but when getting it out of the cache make sure iBackDst and
//        iForeDst are both still valid. 1 goes to iBackDst, 0 to iForeDst.
//     c. just plain jane indexed to indexed or rgb translation.
//
// 3. XLATE_RGB_SRC - Have to call XLATEOBJ_iXlate to get it translated.
//
//     a. XO_TO_MONO - we have saved the iBackColor in ai[0]
//     b. just plain jane RGB to indexed.  Grab the RGB, find the closest
//        match in Dst palette.  Lot's of work.
//
// 4. XLATE_RGB_BOTH - Bit mashing time.  Call XLATEOBJ_iXlate
//

/******************************Public*Routine******************************\
* EXLATEOBJ::bInitXlateObj
*
*   Cache aware initializer for Xlates.
*
* Arguments:
*
*   hcmXform - hColorTransform, may be NULL
*   pdc      - pointer to DC object
*   palSrc   - src surface palette
*   palDst   - dst surface palette
*   palSrcDC - src DC palette
*   palDstDC - dst DC palette
*   iForeDst - For Mono->Color this is what a 0 goes to
*   iBackDst - For Mono->Color this is what a 1 goes to
*   iBackSrc - For Color->Mono this is the color that goes to
*              1, all other colors go to 0.
*   flCear   - Used for multi-monitor systems
*
* History:
*  Sun 23-Jun-1991 -by- Patrick Haluptzok [patrickh]
*
\**************************************************************************/

BOOL
EXLATEOBJ::bInitXlateObj(
    HANDLE      hcmXform,
    LONG        lIcmMode,
    XEPALOBJ    palSrc,
    XEPALOBJ    palDst,
    XEPALOBJ    palSrcDC,
    XEPALOBJ    palDstDC,
    ULONG       iForeDst,       
    ULONG       iBackDst,       
    ULONG       iBackSrc,       
    ULONG       flCreate        
    )
{
    //
    // Check if blting from compatible bitmap to screen.  This is a common
    // occurrence on 8bpp devices we want to accelerate.
    //

    if (!palSrc.bValid())
    {
        if (
              !palDst.bValid() ||
              (
                palDst.bIsPalManaged() &&
                (
                  (palDstDC.ptransCurrent() == NULL) ||
                  (palDstDC.ptransCurrent() == palDstDC.ptransFore())
                )
              )
           )
        {
            vMakeIdentity();
            return(TRUE);
        }
    }

    //
    // Check if blting from screen to compatible bitmap.
    //

    if (!palDst.bValid())
    {
        if (palSrc.bIsPalManaged())
        {
            //
            // Blting from screen to memory bitmap.  Check for identity.
            //

            if ((palDstDC.ptransCurrent() == NULL) ||
                (palDstDC.ptransCurrent() == palDstDC.ptransFore()))
            {
                vMakeIdentity();
                return(TRUE);
            }
        }
    }

    ASSERTGDI(palDstDC.bValid(), "7GDIERROR vInitXlateObj");
    ASSERTGDI(palDst.bValid() || palSrc.bValid(), "8GDIERROR vInitXlateObj");

    //
    // Check for the easy identity out.  This check does the right thing for
    // ppal==ppal and equal times of two different ppals.
    //

    if ((palSrc.bValid()) && (palDst.bValid()))
    {
        if (palSrc.ulTime() == palDst.ulTime())
        {
            ASSERTGDI(palSrc.cEntries() == palDst.cEntries(), "Xlateobj matching times, different # of entries");
            vMakeIdentity();
            return(TRUE);
        }
    }

    BOOL bCacheXlate = TRUE;

    if (IS_ICM_ON(lIcmMode) && (hcmXform != NULL))
    {
        //
        // If we enable ICM and have a valid color tranform,
        // don't search from cache and don't insert new Xlate to cache.
        //

        bCacheXlate = FALSE;
    }
    else if ((palSrc.bValid()) && (palDst.bValid()))
    {
        if (bSearchCache(palSrc,    palDst,    palSrcDC,    palDstDC,
                         iForeDst,  iBackDst,  iBackSrc,    flCreate))
        {
            return(TRUE);
        }
    }

    pxlate = CreateXlateObject(hcmXform,
                               lIcmMode,
                               palSrc,
                               palDst,
                               palSrcDC,
                               palDstDC,
                               iForeDst,
                               iBackDst,
                               iBackSrc,
                               flCreate);

    if (pxlate != (PXLATE) NULL)
    {
        if (bCacheXlate     &&
            palSrc.bValid() && 
            palDst.bValid() &&
            (!(pxlate->flPrivate & XLATE_RGB_SRC)))
        {
            vAddToCache(palSrc, palDst, palSrcDC, palDstDC);
        }

        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


/******************************Public*Routine******************************\
* CreateXlateObject
*
*   Allocates an xlate sets it up.
*
* Arguments:
*
*   palSrc        - src surface palette
*   palDestSurf   - dst surface palette
*   palSrcDC      - src DC palette
*   palDestDC     - dst DC palette
*   iForeDst      - For Mono->Color this is what a 0 goes to
*   iBackDst      - For Mono->Color this is what a 1 goes to
*   iBackSrc      - For Color->Mono this is the color that goes to
*                   1, all other colors go to 0.
*
* History:
*  02-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PXLATE
CreateXlateObject(
    HANDLE      hcmXform,
    LONG        lIcmMode,
    XEPALOBJ    palSrc,
    XEPALOBJ    palDestSurf,
    XEPALOBJ    palSrcDC,
    XEPALOBJ    palDestDC,
    ULONG       iForeDst,
    ULONG       iBackDst,
    ULONG       iBackSrc,
    ULONG       flCreateFlag
    )
{
    ASSERTGDI(palDestDC.bValid(), "CreateXlateObject recieved bad ppalDstDC, bug in GDI");
    ASSERTGDI(palSrc.bValid() || palDestSurf.bValid(), "CreateXlaetObject recieved bad ppalSrc, bug in GDI");
    ASSERTGDI(palSrc.ppalGet() != palDestSurf.ppalGet(), "Didn't recognize ident quickly");

    //
    // cEntry == 0 means the source palette is an RGB/Bitfields type.
    // An invalid palette means it's a compatible bitmap on a palette managed device.
    //

    ULONG ulTemp;
    ULONG cEntry = palSrc.bValid() ? palSrc.cEntries() : 256;

    //
    // Allocate room for the structure.
    //

    PXLATE pxlate = pCreateXlate(cEntry);

    if (pxlate == NULL)
    {
        WARNING("CreateXlateObject failed pCreateXlate\n");
        return(pxlate);
    }

    //
    // Grab the palette semaphore so you can access the ptrans in palDestDC.
    //

    SEMOBJ  semo(ghsemPalette); // ??? This may not need to be grabbed
                               // ??? since we have the DC's locked that
                               // ??? this palette DC is in.  Investigate.

    //
    // Initialize ICM stuffs.
    //

    pxlate->vCheckForICM(hcmXform,lIcmMode);

    BOOL bCMYKColor = ((pxlate->flXlate & XO_FROM_CMYK) ? TRUE : FALSE);

    //
    // See if we should be matching to the Dest DC palette instead of the
    // surface.  This occurs when the surface is palette managed and the
    // user hasn't selected an RGB palette into his destination DC.
    // Note we check for a valid pxlate in the Destination DC palette.
    // In multi-task OS the user can do things to get the translate in a
    // invalid or NULL state easily.  We match against the reserved palette
    // in this case.
    //

    BOOL bPalManaged = (!palDestSurf.bValid()) || (palDestSurf.bIsPalManaged());

    if (bPalManaged)
    {
        //
        // We are blting to a compatible bitmap or the screen on a palette managed
        // device.  Check that we have a foreground realization already done,
        // otherwise just use the default palette for the DC palette.
        //

        ASSERTGDI(((palDestDC.ptransFore() == NULL) && (palDestDC.ptransCurrent() == NULL)) ||
                  ((palDestDC.ptransFore() != NULL) && (palDestDC.ptransCurrent() != NULL)),
                  "ERROR translates are either both valid or both invalid");

        if (palDestDC.ptransFore() == NULL)
        {
            //
            // Match against the default palette, valid translate is not available.
            //

            palDestDC.ppalSet(ppalDefault);
        }

        if (!(flCreateFlag & XLATE_USE_SURFACE_PAL))
        {
            pxlate->flPrivate |= XLATE_PAL_MANAGED;

            //
            // Set a flag that says whether we are background or foreground.
            //

            if (palDestSurf.bValid())
            {
                pxlate->flPrivate |= XLATE_USE_CURRENT;
            }
        }
    }

    pxlate->ppalSrc   = palSrc.ppalGet();
    pxlate->ppalDst   = palDestSurf.ppalGet();
    pxlate->ppalDstDC = palDestDC.ppalGet();

    PTRANSLATE ptransFore = palDestDC.ptransFore();
    PTRANSLATE ptransCurrent = palDestDC.ptransCurrent();

    //
    // Ok, lets build the translate vector.
    //

    if (
        (!palSrc.bValid()) ||
        (
          (palSrc.bIsPalManaged()) &&
          ((ptransFore == ptransCurrent) || (flCreateFlag & XLATE_USE_FOREGROUND))
        )
       )
    {
        //
        // The source is a compatible bitmap on a palette managed device or the screen
        // with Dst DC palette having been realized in the foreground.
        //
        // We start out assuming an identity blt.
        //

        if (ptransFore == NULL)
        {
            //
            // Match against the default palette since a
            // valid translate is not available.
            //

            palDestDC.ppalSet(ppalDefault);
            pxlate->ppalDstDC = ppalDefault;
            ptransFore = ptransCurrent = (TRANSLATE *) &defaultTranslate;
        }

        ASSERTGDI(cEntry == 256, "ERROR xlate too small");

        for (ulTemp = 0; ulTemp < 256; ulTemp++)
        {
            pxlate->ai[ulTemp] = ulTemp;
        }

        if (!palDestSurf.bValid())
        {
            //
            // Compatible bitmap to compatible bitmap on palette managed
            // device. Both are relevant to the foreground realize of the
            // DestDC palette so the xlate is identity.
            //

            pxlate->flXlate |= XO_TRIVIAL;
        }
        else if ((palDestSurf.bIsPalDibsection()) && (bEqualRGB_In_Palette(palDestSurf, palDestDC)))
        {
            //
            // If you blt from a compatible bitmap to a DIBSECTION it will be identity
            // if the RGB's of both the DC palette and the DIBSECTION's palette are the same.
            // We do this special check so that if they contain duplicates we still get an
            // identity xlate.
            //

            pxlate->flXlate |= XO_TRIVIAL;  // Size wise this will combine with first check

        }
        else if ((palDestSurf.bIsPalDibsection()) && (palSrc.bValid()) && (bEqualRGB_In_Palette(palDestSurf, palSrc)))
        {
            pxlate->flXlate |= XO_TRIVIAL;  // Size wise this will combine with first check
        }
        else if (palDestSurf.bIsPalManaged())
        {
            //
            // Compatible bitmap to the screen on a palette managed device.
            // The compatible bitmaps colors are defined as the foreground
            // realization of the destination DC's palette.  If the Dst
            // DC's palette is realized in the foreground it's identity.
            // Otherwise we translate from the current to the foreground
            // indices.
            //

            if (ptransCurrent == ptransFore)
            {
                //
                // It's in the foreground or not realized yet so it's
                // identity.  Not realized case also hits on default logical palette.
                //

                pxlate->flXlate |= XO_TRIVIAL;
            }
            else
            {
                //
                // It's foreground to current translation.
                //

                ASSERTGDI(ptransFore != ptransCurrent, "Should have been identity, never get here");
                ASSERTGDI(ptransFore != NULL, "ERROR this should not have got here Fore");
                ASSERTGDI(ptransCurrent != NULL, "ERROR this should not have got here Current");

                for (ulTemp = 0; ulTemp < palDestDC.cEntries(); ulTemp++)
                {
                    pxlate->ai[ptransFore->ajVector[ulTemp]] = (ULONG) ptransCurrent->ajVector[ulTemp];
                }

                //
                // Now map the default colors that are really there independant of logical palette.
                //

                if (palDestSurf.bIsNoStatic())
                {
                    //
                    // Only black and white are here.
                    //

                    pxlate->ai[0] = 0;
                    pxlate->ai[255] = 255;
                }
                else if (!palDestSurf.bIsNoStatic256())
                {
                    //
                    // All the 20 holy colors are here.
                    // Fix them up.
                    //

                    for (ulTemp = 0; ulTemp < 10; ulTemp++)
                    {
                        pxlate->ai[ulTemp] = ulTemp;
                        pxlate->ai[ulTemp + 246] = ulTemp + 246;
                    }
                }
            }
        }
        else if (palDestSurf.bIsMonochrome())
        {
            RtlZeroMemory(pxlate->ai, 256 * sizeof(ULONG));

            ulTemp = ulGetNearestIndexFromColorref(palSrc, palSrcDC, iBackSrc);

            ASSERTGDI(ulTemp < 256, "ERROR palSrc invalid - ulGetNearest is > 256");

            pxlate->vSetIndex(ulTemp, 1);
            pxlate->flXlate |= XO_TO_MONO;
            pxlate->iBackSrc = iBackSrc;
        }
        else
        {
            //
            // Blting from palette-managed bitmap to non-palette managed surface.
            //
            // Do all the non-default colors that are realized.
            //

            if (palDestSurf.cEntries() != 256)
            {
                //
                // If the dest is 256 entries we will just leave
                // the identity xlate as the initial state.
                // Otherwise we 0 it out so we don't have a translation
                // index left that's potentially bigger than the
                // destination palette.
                //

                RtlZeroMemory(pxlate->ai, 256 * sizeof(ULONG));
            }

            //
            // We need to fill in where the default colors map.
            //

            for (ulTemp = 0; ulTemp < 10; ulTemp++)
            {
                pxlate->ai[ulTemp] =
                    palDestSurf.ulGetNearestFromPalentry(logDefaultPal.palPalEntry[ulTemp]);
                pxlate->ai[ulTemp + 246] =
                    palDestSurf.ulGetNearestFromPalentry(logDefaultPal.palPalEntry[ulTemp+10]);
            }

            if (flCreateFlag & XLATE_USE_SURFACE_PAL) 
            {
                //
                // Map directly to destination surface palette from source surface palette.
                //

                for (ulTemp = 0; ulTemp < palSrc.cEntries(); ulTemp++)
                {
                   pxlate->ai[ulTemp] = palDestSurf.ulGetNearestFromPalentry(palSrc.palentryGet(ulTemp));
                }

                pxlate->flPrivate |= XLATE_USE_SURFACE_PAL;
            }
            else
            {
                //
                // Go through DC palette and then map to destination surface palette.
                //

                if (ptransFore != NULL)
                {
                    for (ulTemp = 0; ulTemp < palDestDC.cEntries(); ulTemp++)
                    {
                        pxlate->ai[ptransFore->ajVector[ulTemp]] =
                                palDestSurf.ulGetNearestFromPalentry(palDestDC.palentryGet(ulTemp));
                    }
                }
            }
        }
    }
    else if (palSrc.bIsPalDibsection() &&
             ((palDestSurf.bValid() &&
               palDestSurf.bIsPalDibsection() &&
               bEqualRGB_In_Palette(palSrc, palDestSurf)
              ) ||
              (((!palDestSurf.bValid()) ||
                (palDestSurf.bIsPalManaged() && (ptransFore == ptransCurrent))
               ) &&
               bEqualRGB_In_Palette(palSrc, palDestDC)
              )
             )
            )
    {
        //
        // Blting from a Dibsection &&
        // ((To another Dibsection with ident palette) ||
        //  (((To a compatible palette managed bitmap)  ||
        //    (To a palette managed screen with the DstDc's logical palette realized in the foreground)) &&
        //   (the dst logical palette == Dibsection's palette)
        // ))
        //
        // This is identity.  We do this special check so even if there are duplicate
        // colors in the palette we still get identity.
        //

        for (ulTemp = 0; ulTemp < 256; ulTemp++)
        {
            pxlate->ai[ulTemp] = ulTemp;
        }

        pxlate->flXlate |= XO_TRIVIAL;
    }
    else if ((palSrc.bIsPalManaged()) && (!palDestSurf.bValid()))
    {
        //
        // We are blting from the screen to a compatible bitmap on a palette
        // managed device where the screen is realized in the background.
        //

        //
        // Make it identity by default.
        //

        for (ulTemp = 0; ulTemp < 256; ulTemp++)
        {
            pxlate->ai[ulTemp] = ulTemp;
        }

        //
        // We are blting background to foreground.
        // i.e. we are blting current realize to foreground realize.
        //

        ASSERTGDI(pxlate->cEntries == 256, "ERROR xlate too small");
        ASSERTGDI(ptransFore != ptransCurrent, "Should have been identity, never get here");
        ASSERTGDI(ptransFore != NULL, "ERROR this should not have got here Fore");
        ASSERTGDI(ptransCurrent != NULL, "ERROR this should not have got here Current");

        for (ulTemp = 0; ulTemp < palDestDC.cEntries(); ulTemp++)
        {
            pxlate->ai[ptransCurrent->ajVector[ulTemp]] = (ULONG) ptransFore->ajVector[ulTemp];
        }

        //
        // Now map the default colors that are really there independant of logical palette realization.
        //

        if (palSrc.bIsNoStatic())
        {
            //
            // Only black and white are here.
            //

            pxlate->ai[0] = 0;
            pxlate->ai[255] = 255;
        }
        else if (!palSrc.bIsNoStatic256())
        {
            //
            // All the 20 holy colors are here.
            // Fix them up.
            //

            for (ulTemp = 0; ulTemp < 10; ulTemp++)
            {
                pxlate->ai[ulTemp] = ulTemp;
                pxlate->ai[ulTemp + 246] = ulTemp + 246;
            }
        }
    }
    else if (palSrc.bIsMonochrome())
    {
        if (palDestSurf.bIsMonochrome())
        {
            //
            // It's identity blt.
            //

            pxlate->vSetIndex(0, 0);
            pxlate->vSetIndex(1, 1);
        }
        else
        {
            if (bCMYKColor)
            {
                pxlate->vSetIndex(0, iForeDst);
                pxlate->vSetIndex(1, iBackDst);
            }
            else
            {
                pxlate->vSetIndex(0, ulGetNearestIndexFromColorref(palDestSurf,
                                                                   palDestDC,
                                                                   iForeDst));
                pxlate->vSetIndex(1, ulGetNearestIndexFromColorref(palDestSurf,
                                                                   palDestDC,
                                                                   iBackDst));
            }

            //
            // XLATE_FROM_MONO is set so we know to look at colors in
            // cache code for getting a hit.
            //

            pxlate->flPrivate |= XLATE_FROM_MONO;
            pxlate->iForeDst = iForeDst;
            pxlate->iBackDst = iBackDst;
        }
    }
    else if (cEntry == 0)
    {
        ASSERTGDI(palSrc.cEntries() == 0, "ERROR how could this happen");

        //
        // Src is a RGB/Bitfields palette.
        //

        if (palDestSurf.bIsMonochrome())
        {
            //
            // Put the color the Background of the source matches in pulXlate[0]
            //

            pxlate->ai[0] = ulGetNearestIndexFromColorref(palSrc, palSrcDC, iBackSrc);
            pxlate->flXlate |= XO_TO_MONO;
            pxlate->iBackSrc = iBackSrc;

            //
            // The S3 and other snazzy drivers look at this and get the color out
            // of slot 0 when XO_TO_MONO is set to get way better performance in
            // WinBench.
            //

            pxlate->pulXlate = pxlate->ai;
        }
    }
    else
    {
        //
        // Src is a regular indexed palette, it wouldn't have duplicating entries
        // in it so we don't need to check for the Dibsection case.  This is like
        // a palette for a 16 color VGA or a printer or a SetDIBitsToDevice.
        //

        if (palDestSurf.bValid() && palDestSurf.bIsMonochrome())
        {
            RtlZeroMemory(pxlate->ai,(UINT) cEntry * sizeof(*pxlate->ai));
            cEntry = ulGetNearestIndexFromColorref(palSrc, palSrcDC, iBackSrc);
            ASSERTGDI(cEntry < pxlate->cEntries, "ERROR this is not in range");
            pxlate->vSetIndex(cEntry, 1);
            pxlate->flXlate |= XO_TO_MONO;
            pxlate->iBackSrc = iBackSrc;
        }
        else
        {
            if (bCMYKColor)
            {
                //
                // Copy source CMYK color table to index table.
                //

                while(cEntry--)
                {
                    pxlate->ai[cEntry] = palSrc.ulEntryGet(cEntry);
                }
            }
            else
            {
                //
                // If the destination is palette managed, map to logical palette
                // and then translate to physical indices accordingly.  Otherwise
                // map to the physical palette directly.
                //

                PPALETTE ppalTemp;

                if (bPalManaged && !(flCreateFlag & XLATE_USE_SURFACE_PAL))
                {
                    ppalTemp = palDestDC.ppalGet();
                }
                else
                {
                    ppalTemp = palDestSurf.ppalGet();

                    if (flCreateFlag & XLATE_USE_SURFACE_PAL)
                    {
                        pxlate->flPrivate |= XLATE_USE_SURFACE_PAL;
                    }
                }

                XEPALOBJ palTemp(ppalTemp);

                while(cEntry--)
                {

                    pxlate->ai[cEntry] =
                               palTemp.ulGetNearestFromPalentry(
                                                 palSrc.palentryGet(cEntry));
                }

                if (bPalManaged && !(flCreateFlag & XLATE_USE_SURFACE_PAL))
                {
                    //
                    // Map from DC palette to surface palette.
                    //

                    pxlate->vMapNewXlate((palDestSurf.bValid()) ? ptransCurrent
                                                                : ptransFore);
                }
            }
        }
    }

    pxlate->vCheckForTrivial();
    return(pxlate);
}

/******************************Public*Routine******************************\
* pCreateXlate
*
* This allocates an xlate object with ulNumEntries.
*
* Returns: The pointer to the xlate object, NULL for failure.
*
* History:
*  17-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PXLATE pCreateXlate(ULONG ulNumEntries)
{
    //
    // Allocate room for the XLATE.
    //

    PXLATE pxlate = (PXLATE) PALLOCNOZ((sizeof(XLATE) + sizeof(ULONG) * ulNumEntries),
                                       'tlxG');

    if (pxlate != NULL)
    {
        pxlate->iUniq = ulGetNewUniqueness(ulXlatePalUnique);
        if (ulNumEntries > 0)
        {
            pxlate->flXlate = XO_TABLE;
            pxlate->pulXlate = pxlate->ai;
            pxlate->flPrivate = 0;
        }
        else
        {
            pxlate->flXlate = 0;
            pxlate->pulXlate = NULL;
            pxlate->flPrivate = XLATE_RGB_SRC;
        }

        pxlate->iSrcType = pxlate->iDstType = 0;
        pxlate->cEntries = ulNumEntries;
        pxlate->lCacheIndex = XLATE_CACHE_INVALID;
        pxlate->ppalSrc = (PPALETTE) NULL;
        pxlate->ppalDst = (PPALETTE) NULL;
        pxlate->ppalDstDC = (PPALETTE) NULL;
    }
#if DBG
    else
    {
        WARNING("pCreateXlate failed memory allocation\n");
    }
#endif

    return(pxlate);
}


/******************************Public*Routine******************************\
* vCheckForTrivial
*
*   We need to check for trivial translation, it speeds up the inner-loop
*   for blting a great deal.
*
* History:
*
*  11-Oct-1995 -by- Tom Zakrajsek [tomzak]
* Fixed it to not mark xlates as trivial unless the Src and Dst were
* the same color depth.
*
*  17-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID XLATE::vCheckForTrivial()
{
    //
    // Check if we already recognized trivial during creation
    //

    if (flXlate & XO_TRIVIAL)
        return;

    //
    // Source Color is CMYK, XO_TRIVIAL will not be on.
    //

    if (flXlate & XO_FROM_CMYK)
        return;

    //
    // See if it's really just a trivial xlate.
    //

    if (cEntries)
    {
        //
        // Just make sure that each index translates to itself, and
        // that the color depths are the same for the source and
        // destination.
        //

        ULONG ulTemp;

        if ((ppalSrc != NULL) &&
            (ppalDst != NULL) &&
            (ppalSrc->cEntries != ppalDst->cEntries))
        {
            return;
        }

        for (ulTemp = 0; ulTemp < cEntries; ulTemp++)
        {
            if (pulXlate[ulTemp] != ulTemp)
                return;
        }
    }
    else
    {
        //
        // If the Src and Dst have the same masks it's identity.
        //

        XEPALOBJ palSrc(ppalSrc);
        XEPALOBJ palDst(ppalDst);

        if ((palSrc.bValid()) &&
            (palDst.bValid()) &&
            (!palDst.bIsIndexed()))
        {
            ASSERTGDI(!palSrc.bIsIndexed(), "ERROR Src not indexed?");

            FLONG flRedSrc, flGreSrc, flBluSrc;
            FLONG flRedDst, flGreDst, flBluDst;

            if (palSrc.bIsBitfields())
            {
                flRedSrc = palSrc.flRed();
                flGreSrc = palSrc.flGre();
                flBluSrc = palSrc.flBlu();
            }
            else
            {
                flGreSrc = 0x0000FF00;

                if (palSrc.bIsRGB())
                {
                    flRedSrc = 0x000000FF;
                    flBluSrc = 0x00FF0000;
                }
                else
                {
                    ASSERTGDI(palSrc.bIsBGR(), "What is it then?");
                    flRedSrc = 0x00FF0000;
                    flBluSrc = 0x000000FF;
                }
            }

            if (palDst.bIsBitfields())
            {
                flRedDst = palDst.flRed();
                flGreDst = palDst.flGre();
                flBluDst = palDst.flBlu();
            }
            else
            {
                flGreDst = 0x0000FF00;

                if (palDst.bIsRGB())
                {
                    flRedDst = 0x000000FF;
                    flBluDst = 0x00FF0000;
                }
                else
                {
                    ASSERTGDI(palDst.bIsBGR(), "What is it then?");
                    flRedDst = 0x00FF0000;
                    flBluDst = 0x000000FF;
                }
            }

            if ((flRedSrc != flRedDst) ||
                (flGreSrc != flGreDst) ||
                (flBluSrc != flBluDst))
            {
                return;
            }
        }
        else
            return;
    }

    //
    // We found it is really just trivial.
    //

    flXlate |= XO_TRIVIAL;
}


/******************************Public*Routine******************************\
* EXLATEOBJ::vAddToCache
*
*   Adds an xlate object to the cache.
*
* Arguments:
*
*   palSrc   -
*   palDst   -
*   palSrcDC -
*   palDstDC -
*
* History:
*  13-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID
EXLATEOBJ::vAddToCache(
    XEPALOBJ palSrc,
    XEPALOBJ palDst,
    XEPALOBJ palSrcDC,
    XEPALOBJ palDstDC
    )
{
    ULONG   cEntries;
    SEMOBJ  semo(ghsemPalette);

    for (cEntries = 0; cEntries < XLATE_CACHE_SIZE; cEntries++)
    {
        ASSERTGDI(ulTableIndex < XLATE_CACHE_SIZE, "table index out of range");

        if (xlateTable[ulTableIndex].pxlate != (PXLATE) 0)
        {
            if (xlateTable[ulTableIndex].ulReference != 0)
            {
                ulTableIndex = (ulTableIndex + 1) & XLATE_MODULA;
                continue;
            }

            VFREEMEM(xlateTable[ulTableIndex].pxlate);
        }

        //
        // Now add ours into the cache.
        //

        xlateTable[ulTableIndex].ulReference = 1;
        xlateTable[ulTableIndex].pxlate = (PXLATE)pxlate;
        xlateTable[ulTableIndex].ulPalSrc = palSrc.ulTime();
        xlateTable[ulTableIndex].ulPalDst = palDst.ulTime();
        xlateTable[ulTableIndex].ulPalSrcDC = palSrcDC.ulTime();
        xlateTable[ulTableIndex].ulPalDstDC = palDstDC.ulTime();

        //
        // Mark it so the destructor doesn't free it
        //

        pxlate->lCacheIndex = (LONG) ulTableIndex;

        //
        // Put in palSrc the index where to be found most quickly
        //

        palSrc.iXlateIndex(ulTableIndex);

        //
        // Move the cache ahead so we don't get deleted right away
        //

        ulTableIndex = (ulTableIndex + 1) & XLATE_MODULA;
        return;
    }
}


/******************************Public*Routine******************************\
* EXLATEOBJ::bSearchCache
*
*   Searches cache for a previously created xlate.
*
* Arguments:
*
*   palSrc   - src surface palette
*   palDst   - dst surface palette
*   palSrcDC - src DC palette
*   palDstDC - dst DC palette
*   iForeDst - For Mono->Color this is what a 0 goes to
*   iBackDst - For Mono->Color this is what a 1 goes to
*   iBackSrc - For Color->Mono this is the color that goes to
*              1, all other colors go to 0.
*
* History:
*  13-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EXLATEOBJ::bSearchCache(
    XEPALOBJ palSrc,
    XEPALOBJ palDst,
    XEPALOBJ palSrcDC,
    XEPALOBJ palDstDC,
    ULONG    iForeDst,
    ULONG    iBackDst,
    ULONG    iBackSrc,
    ULONG    flCreate
    )
{
    //
    // Start ulIndex at the last place in the cache that an pxlate match was
    // found for palSrc.
    //

    ULONG ulIndex = palSrc.iXlateIndex();
    ULONG ulLoop;
    SEMOBJ  semo(ghsemPalette);

    for (ulLoop = 0; ulLoop < XLATE_CACHE_SIZE; ulLoop++)
    {
        //
        // If the destination is palette managed we need to make sure we are going
        // through the correct Destination DC and that it is up to date.
        //

        if ((xlateTable[ulIndex].ulPalSrc == palSrc.ulTime()) &&
            (xlateTable[ulIndex].ulPalDst == palDst.ulTime()) &&
            (xlateTable[ulIndex].ulPalDstDC == palDstDC.ulTime()))
        {
            //
            // Lock down all the cache objects.
            //

            pxlate = xlateTable[ulIndex].pxlate;
            ASSERTGDI(bValid(), "GDIERROR:invalid pxlate xlate cache entry\n");
            ASSERTGDI(pxlate->lCacheIndex == (LONG) ulIndex, "GDIERROR:bad xlate.lCacheIndex\n");
            ASSERTGDI(!(pxlate->flPrivate & XLATE_RGB_SRC), "GDIERROR:a RGB_SRC in the cache ???\n");
            ASSERTGDI(palSrc.cEntries() == pxlate->cEntries, "ERROR bSearchCache cEntries not matching palSrc");

            //
            // Now check if it's a to/from monochrome and if it is,
            // are the fore/back colors still valid.
            //

            if (
                 (
                   ((XLATE_USE_SURFACE_PAL|XLATE_USE_FOREGROUND) & pxlate->flPrivate) == flCreate
                 )
                    &&
                 (
                   (
                     !((XO_TO_MONO & pxlate->flXlate) || (XLATE_FROM_MONO & pxlate->flPrivate))
                   )
                     ||
                   (
                     (XO_TO_MONO & pxlate->flXlate) &&
                     (iBackSrc == pxlate->iBackSrc) &&
                     (xlateTable[ulIndex].ulPalSrcDC == palSrcDC.ulTime())
                   )
                     ||
                   (
                     (XLATE_FROM_MONO & pxlate->flPrivate) &&
                     (iForeDst == pxlate->iForeDst) &&
                     (iBackDst == pxlate->iBackDst)
                   )
                 )
               )
            {

                //
                // HOT DOG, valid cache entry.  It isn't deletable now
                // because we have it locked down.  Cache the index in palSrc.
                //

                InterlockedIncrement((LPLONG) &(xlateTable[ulIndex].ulReference));
                palSrc.iXlateIndex(ulIndex);
                return(TRUE);
            }
        }

        ulIndex = (ulIndex + 1) & XLATE_MODULA;
    }

    pxlate = (PXLATE) NULL;
    return(FALSE);
}

/******************************Public*Routine******************************\
* XLATEOBJ_iXlate
*
*   This translates an index of a src palette to the closest index in the
*   dst palette.
*
* Arguments:
*
*   pxlo   -
*   cIndex -
*
* History:
*  Mon 16-Mar-1992 -by- Patrick Haluptzok [patrickh]
* Fixed something.
*
*  Wed 24-Jul-1991 -by- Patrick Haluptzok [patrickh]
* put in support for RGB-->monochrome.
*
*  22-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C"
ULONG
XLATEOBJ_iXlate(
    XLATEOBJ *pxlo,
    ULONG     cIndex
    )
{
    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
    {
        return(cIndex);
    }

    if (pxlo->flXlate & XO_TABLE)
    {
        if (cIndex > pxlo->cEntries)
        {
            cIndex = cIndex % pxlo->cEntries;
        }

        return(((XLATE *) pxlo)->ai[cIndex]);
    }

    //
    // We are beyond source palette being PAL_INDEXED.
    //

    if (pxlo->flXlate & XO_TO_MONO)
    {
        if (cIndex == ((XLATE *) pxlo)->ai[0])
        {
            return(1);
        }
        else
        {
            return(0);
        }
    }

    ASSERTGDI(((XLATE *) pxlo)->ppalSrc != (PPALETTE) NULL, "ERROR ppalSrc is NULL");

    //
    // For 8bpp destinations, go through MarkE's optimized tablelookup code.  This is
    // not so much for performance reasons (XLATEOBJ_iXlate is already hopelessly slow),
    // but to make sure GDI always performs this translation in the same way (with some drivers,
    // StretchBlt to a device surface ends up in EngCopyBits which uses MarkE's table, but
    // on the same machines StretchBlt to a memory surface goes through ulTranslate)
    //
    
    PPALETTE ppal = (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED ? 
                     ((XLATE *) pxlo)->ppalDstDC : ((XLATE *) pxlo)->ppalDst);

    ASSERTGDI(ppal != (PPALETTE) NULL, "ERROR ppal is NULL");
    ASSERTGDI(((XLATE *) pxlo)->ppalDstDC != (PPALETTE) NULL, "ERROR ppalDstDC is NULL");

    if ((ppal->flPal & PAL_INDEXED) &&
        (((XLATE *) pxlo)->ppalDstDC->cEntries == 256))
    {
        PBYTE pxlate555 = ((XEPALOBJ) ppal).pGetRGBXlate();
        if (pxlate555 == NULL)
        {
            WARNING1("Error in XLATEOBJ_iXlate:  can't generate pxlate555");
            return 0;
        }
        cIndex = XLATEOBJ_ulIndexToPalSurf(pxlo, pxlate555, cIndex);
    }
    else
    {
        PAL_ULONG palul;

        palul.ul = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).ulIndexToRGB(cIndex);

        if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
        {
            ASSERTGDI(((XLATE *) pxlo)->ppalDstDC != (PPALETTE) NULL, "ERROR ppalDstDC is NULL");
            
            cIndex = ((XEPALOBJ) (((XLATE *) pxlo)->ppalDstDC)).ulGetNearestFromPalentry(palul.pal, SE_DONT_SEARCH_EXACT_FIRST);


            if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
            {
                if (cIndex >= 10)
                {
                    cIndex += 236;
                }
            }
            else
            {
                ASSERTGDI(((XLATE *) pxlo)->ppalDstDC->flPal & PAL_DC, "ERROR in ulTranslate XLATEOBJ is hosed \n");
                ASSERTGDI(cIndex < ((XLATE *) pxlo)->ppalDstDC->cEntries, "ERROR in ultranslate3");

                if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
                {
                    cIndex = (ULONG) ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[cIndex];
                }
                else
                {
                    cIndex = (ULONG) ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[cIndex];
                }
            }
        }
        else
        {
            ASSERTGDI(((XLATE *) pxlo)->ppalDst != (PPALETTE) NULL, "ERROR ppalDst is NULL");

            cIndex = ((XEPALOBJ) (((XLATE *) pxlo)->ppalDst)).ulGetNearestFromPalentry(palul.pal, ((XEPALOBJ) (((XLATE *) pxlo)->ppalDst)).cEntries() ? SE_DONT_SEARCH_EXACT_FIRST : SE_DO_SEARCH_EXACT_FIRST);
        }
    }

    return(cIndex);
}

/**************************************************************************\
* XLATEOBJ_pGetXlate555
*
*   Retrieve 555 rgb xlate vector from appropriate palette
*
* Arguments:
*
*   pxlo
*
* Return Value:
*
*   rgb555 xlate vector or NULL
*
* History:
*
*    2/27/1997 Mark Enstrom [marke]
*
\**************************************************************************/

PBYTE
XLATEOBJ_pGetXlate555(
    XLATEOBJ *pxlo
    )
{
    PBYTE pxlate555 = NULL;

    //
    // return hi color to palette 555 translate table if the xlateobj
    // is appropriate
    //

    if (
         (pxlo == NULL) ||
         (pxlo->flXlate & XO_TRIVIAL) ||
         (pxlo->flXlate & XO_TABLE)   ||
         (pxlo->flXlate & XO_TO_MONO)
       )
    {
        return(NULL);
    }

    //
    // determine palette type to map.
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        ASSERTGDI(((XLATE *) pxlo)->ppalDstDC != (PPALETTE) NULL, "ERROR ppalDstDC is NULL");

        pxlate555 = ((XEPALOBJ) (((XLATE *) pxlo)->ppalDstDC)).pGetRGBXlate();
    }
    else
    {
        if (((XEPALOBJ) (((XLATE *) pxlo)->ppalDst)).bValid())
        {
            pxlate555 = ((XEPALOBJ) (((XLATE *) pxlo)->ppalDst)).pGetRGBXlate();
        }
    }

    return(pxlate555);
}


/**************************************************************************\
* XLATEOBJ_ulIndexToPalSurf
*   - take generic pixel input, convert it to RGB, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - index input
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_ulIndexToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    ALPHAPIX apix;
    BYTE     palIndex = 0;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_ulIndexToPalSurf: NULL pxlate555\n");

    apix.ul = ulRGB;

    apix.ul = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).ulIndexToRGB(ulRGB);

    palIndex = pxlate555[((apix.pix.b & 0xf8) << 7) |
                         ((apix.pix.g & 0xf8) << 2) |
                         ((apix.pix.r & 0xf8) >> 3)];


    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }

    return(palIndex);
}

/**************************************************************************\
* XLATEOBJ_RGB32ToPalSurf
*   - take 32 RGB pixel input, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - 32 bit RGB input pixel
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_RGB32ToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    ALPHAPIX apix;
    BYTE     palIndex = 0;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_RGB32ToPalSurf: NULL pxlate555\n");

    apix.ul = ulRGB;

    palIndex = pxlate555[((apix.pix.b & 0xf8) << 7) |
                         ((apix.pix.g & 0xf8) << 2) |
                         ((apix.pix.r & 0xf8) >> 3)];

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }

    return(palIndex);
}

/**************************************************************************\
* XLATEOBJ_RGB32ToPalSurf
*   - take 32 BGR pixel input, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - 32 bit BGR input pixel
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_BGR32ToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    BYTE     palIndex;
    ALPHAPIX apix;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_BGR32ToPalSurf: NULL pxlate555\n");

    apix.ul = ulRGB;

    palIndex = pxlate555[((apix.pix.r & 0xf8) << 7) |
                         ((apix.pix.g & 0xf8) << 2) |
                         ((apix.pix.b & 0xf8) >> 3)];

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }
    return(palIndex);
}

/**************************************************************************\
* XLATEOBJ_RGB16_565ToPalSurf
*   - take 16 bit 565 pixel input, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - 16 bit 565 input pixel
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_RGB16_565ToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    BYTE     palIndex = 0;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_BGR16_565ToPalSurf: NULL pxlate555\n");

    palIndex = pxlate555[((ulRGB & 0xf800) >> 1) |
                         ((ulRGB & 0x07c0) >> 1) |
                         ((ulRGB & 0x001f))];

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }
    return(palIndex);
}

/**************************************************************************\
* XLATEOBJ_RGB16_555ToPalSurf
*   - take 16 bit 555 pixel input, then use the rgb555
*     to palette index table to look up a palette index
*
* Arguments:
*
*   pxlo      - xlate object
*   pxlate555 - member of dest palette object, 555RGB to palette
*   ulRGB     - 16 bit 555 input pixel
*
*
* Return Value:
*
*   Destination 8 bit pixel
*
* History:
*
*    2/20/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
XLATEOBJ_RGB16_555ToPalSurf(
    XLATEOBJ *pxlo,
    PBYTE     pxlate555,
    ULONG     ulRGB
    )
{
    BYTE     palIndex = 0;

    ASSERTGDI(pxlate555 != NULL,"XLATEOBJ_BGR16_555ToPalSurf: NULL pxlate555\n");

    palIndex = pxlate555[ulRGB & 0x7fff];

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            if (palIndex >= 10)
            {
                palIndex += 236;
            }
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[palIndex];
            }
            else
            {
                palIndex = ((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[palIndex];
            }
        }
    }
    return(palIndex);
}


/******************************Public*Routine******************************\
* XLATEMEMOBJ
*
* This is a special constructor for the UpdateColors case.  It deletes the
* old xlate when it is done.
*
* History:
*  12-Dec-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

XLATEMEMOBJ::XLATEMEMOBJ(
    XEPALOBJ palSurf,
    XEPALOBJ palDC
    )
{
    //
    // Assert some fundamental truths.
    //

    ASSERTGDI(palDC.bValid(), "invalid palDC in xlatememobj123\n");
    ASSERTGDI(palSurf.bIsPalManaged(), "invalid surface palette in UpdateColors xlate");
    ASSERTGDI(palSurf.bValid(), "invalid palSurf in xlatememobj123\n");
    ASSERTGDI(!(palDC.bIsRGB()), "RGB palDC in DC->surf xlate constructor123\n");
    ASSERTGDI(!(palSurf.bIsRGB()), "RGB palSurf in DC->surf xlate constructor123\n");
    ASSERTGDI(palDC.bIsPalDC(), "not a palDC for palDC in xlatememobj123\n");
    ASSERTGDI(palDC.ptransCurrent() != NULL, "ERROR ptrans Null UpdateColors");
    ASSERTGDI(palDC.ptransOld() != NULL, "ERROR ptransOld Null UpdateColors");

    ULONG ulTemp;
    PULONG pulTemp;

    pxlate = pCreateXlate(palSurf.cEntries());

    if (pxlate)
    {
        pxlate->ppalSrc = palSurf.ppalGet();
        pxlate->ppalDst = palSurf.ppalGet();
        pxlate->ppalDstDC = palDC.ppalGet();
        pulTemp = pxlate->ai;

        //
        // Set up identity vector for all entries
        //

        for (ulTemp = 0; ulTemp < pxlate->cEntries; ulTemp++)
        {
            pulTemp[ulTemp] = ulTemp;
        }

        //
        // Change the ones that are affected by the palette realizations.
        //

        PTRANSLATE ptransOld = palDC.ptransOld();
        PTRANSLATE ptransCurrent = palDC.ptransCurrent();

        for (ulTemp = 0; ulTemp < palDC.cEntries(); ulTemp++)
        {
            pulTemp[ptransOld->ajVector[ulTemp]] = (ULONG) ptransCurrent->ajVector[ulTemp];
        }

        pxlate->vCheckForTrivial();
    }
}


/******************************Public*Routine******************************\
* EXLATEOBJ::bCreateXlateFromTable
*
* This is used to initialize an xlate when the table is already computed.
* We need this to support journaling.
*
* History:
*  17-Mar-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EXLATEOBJ::bCreateXlateFromTable(
    ULONG cEntry,
    PULONG pulVector,
    XEPALOBJ palDst
    )
{
    //
    // Assert good input data.
    //

    ASSERTGDI(palDst.bValid(), "ERROR bInitXlate bad palDst");
    ASSERTGDI(pulVector != (PULONG) NULL, "ERROR bInitXlate bad pulVector");
    ASSERTGDI(cEntry != 0, "ERROR bInitXlate cEntry is 0");

    //
    // Allocate room for the Xlate.
    //

    pxlate = pCreateXlate(cEntry);

    if (pxlate == NULL)
    {
        WARNING("ERROR bInitXlate failed call to pCreateXlate\n");
        return(FALSE);
    }

    pxlate->ppalDst = palDst.ppalGet();
    pxlate->iDstType = (USHORT) palDst.iPalMode();

    //
    // Ok, fill in the xlate vector.
    //

    RtlCopyMemory(pxlate->ai, pulVector, (UINT) (cEntry * sizeof(ULONG)));

    //
    // Init accelerators, out of here.
    //

    pxlate->vCheckForTrivial();
    return(TRUE);
}


/******************************Public*Routine******************************\
* XLATE::vCheckForICM()
*
* History:
*  26-Feb-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID XLATE::vCheckForICM(HANDLE _hcmXform,ULONG _lIcmMode)
{
    //
    // First, initialize ICM mode as default (off)
    //
    lIcmMode = DC_ICM_OFF;
    hcmXform = NULL;

    //
    // Check is there any ICM is enabled ?
    //
    if (IS_ICM_ON(_lIcmMode))
    {
        if (IS_ICM_INSIDEDC(_lIcmMode))
        {
            //
            // Inside DC ICM is enabled with valid color transform.
            //

            //
            // Copy mode and color transform handle to XLATE.
            //
            lIcmMode = _lIcmMode;
            hcmXform = _hcmXform;

            if (IS_ICM_DEVICE(lIcmMode))
            {
                COLORTRANSFORMOBJ CXFormObj(_hcmXform);

                //
                // Check transform handle is valid or not.
                //
                if (CXFormObj.bValid())
                {
                    ICMMSG(("vCheckForICM():XO_DEVICE_ICM\n"));

                    //
                    // Device driver will do color matching.
                    //
                    flXlate |= XO_DEVICE_ICM;
                }
            }
            else if (IS_ICM_HOST(lIcmMode))
            {
                ICMMSG(("vCheckForICM():XO_HOST_ICM\n"));

                //
                // Inform the images is corrected by host CMM
                //
                flXlate |= XO_HOST_ICM;

                if (IS_CMYK_COLOR(lIcmMode) && (hcmXform != NULL))
                {
                    ICMMSG(("vCheckForICM():XO_FROM_CMYK\n"));

                    //
                    // The destination surface is 32bits CMYK color,
                    // This is only happen when ICM is done by host.
                    //
                    flXlate |= XO_FROM_CMYK;
                }
            }
        }
        else if (IS_ICM_OUTSIDEDC(_lIcmMode))
        {
            //
            // Outside DC is enabled, color correction is done by application.
            //

            //
            // Copy mode and color transform handle to XLATE.
            //
            lIcmMode = _lIcmMode;
            hcmXform = 0;

            //
            // Inform the images is corrected by Host (application) ICM
            //
            flXlate |= XO_HOST_ICM;
        }
    }
}

/******************************Public*Routine******************************\
* vXlateBitfieldsToBitfields
*
* Translates a color between to arbitrary bitfield (or RGB or BGR) formats.
\**************************************************************************/

ULONG FASTCALL iXlateBitfieldsToBitfields(XLATEOBJ* pxlo, ULONG ul)
{
    ul = ((XEPALOBJ) ((XLATE *) pxlo)->ppalSrc).ulIndexToRGB(ul);
    ul = ((XEPALOBJ) ((XLATE *) pxlo)->ppalDst).ulGetNearestFromPalentry(
                                        *((PALETTEENTRY*) &ul));

    return(ul);
}

ULONG FASTCALL iXlate565ToBGR(XLATEOBJ *pxlo, ULONG ul)
{
    return(((ul << 8) & 0xf80000)
         | ((ul << 3) & 0x070000)
         | ((ul << 5) & 0x00fc00)
         | ((ul >> 1) & 0x000300)
         | ((ul << 3) & 0x0000f8)
         | ((ul >> 2) & 0x000007));
}

ULONG FASTCALL iXlate555ToBGR(XLATEOBJ *pxlo, ULONG ul)
{
    return(((ul << 9) & 0xf80000)
         | ((ul << 4) & 0x070000)
         | ((ul << 6) & 0x00f800)
         | ((ul << 1) & 0x000700)
         | ((ul << 3) & 0x0000f8)
         | ((ul >> 2) & 0x000007));
}

ULONG FASTCALL iXlateBGRTo565(XLATEOBJ *pxlo, ULONG ul)
{
    return(((ul >> 8) & 0xf800)
         | ((ul >> 5) & 0x07e0)
         | ((ul >> 3) & 0x001f));
}

ULONG FASTCALL iXlateBGRTo555(XLATEOBJ *pxlo, ULONG ul)
{
    return(((ul >> 9) & 0x7c00)
         | ((ul >> 6) & 0x03e0)
         | ((ul >> 3) & 0x001f));
}

/******************************Public*Routine******************************\
* pfnXlateBetweenBitfields
*
* Returns a pointer to an optimized routine for converting between
* two bitfields (or RGB or BGR) colors.
\**************************************************************************/

PFN_pfnXlate XLATE::pfnXlateBetweenBitfields()
{
    PFN_pfnXlate pfnXlate;
    XEPALOBJ palSrc(ppalSrc);
    XEPALOBJ palDst(ppalDst);

    ASSERTGDI(palSrc.bIsBitfields() || palSrc.bIsRGB() || palSrc.bIsBGR(),
        "ERROR: Expected bitfields source");
    ASSERTGDI(palDst.bIsBitfields() || palDst.bIsRGB() || palDst.bIsBGR(),
        "ERROR: Expected bitfields destination");

    pfnXlate = iXlateBitfieldsToBitfields;

    if (palDst.bIsBGR())
    {
        if (palSrc.bIs565())
        {
            pfnXlate = iXlate565ToBGR;
        }
        else if (palSrc.bIs555())
        {
            pfnXlate = iXlate555ToBGR;
        }
    }
    else if (palSrc.bIsBGR())
    {
        if (palDst.bIs565())
        {
            pfnXlate = iXlateBGRTo565;
        }
        else if (palDst.bIs555())
        {
            pfnXlate = iXlateBGRTo555;
        }
    }

    return(pfnXlate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\amd64\tiler.cxx ===
/*******************************Module*Header*****************************\
* 
*  Copyright (c) 1992-1999  Microsoft Corporation
*  Copyright (c) 1992  Digital Equipment Corporation
* 
*  Module Name:
* 
*     tiler.cxx
* 
*  Abstract:
* 
*     This module implements code to copy a pattern to a target surface.
* 
*  Author:
* 
*    David N. Cutler (davec) 4-May-1992
* 
*  Rewritten in C by:
* 
*    Eric Rehm (rehm@zso.dec.com) 15-July-1992
* 
*  Environment:
* 
*     Kernel mode only.
* 
*  N.B. The AMD64 platform does not enforce alignment checks in kernel
*       mode. Therefore, even though this function deals with data that
*       is unaligned, avoidance of unaligned operations is not required.
*
*  Revision History:
* 
\*************************************************************************/

#include "precomp.hxx"

VOID CopyPattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat);
VOID MergePattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat);

/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern.
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }

      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = *pulPatCur;       // set target to 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchAndCopy

/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (P).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   *pulPat;                // base pattern address
    ULONG   *pulPatCur;             // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG *) ((PUCHAR) pulPat + xPat));

      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = *pulPatCur;
                                    // set target to 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG *) ((PUCHAR) pulPat + xPat);

      }
    }
} // end vFetchShiftAndCopy

/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchNotAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern
*     using rop (Pn).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchNotAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern
      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }
      loPat = ~loPat;               // complement pattern
      hiPat = ~hiPat;
      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = ~(*pulPatCur);
                      // set target to complement of 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchNotAndCopy

/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftNotAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (Pn).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftNotAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   *pulPat;                // base pattern address
    ULONG   *pulPatCur;             // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;
                                    // get low part of 8-byte pattern
      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG *) ((PUCHAR) pulPat + xPat));

      loPat = ~loPat;               // complement pattern
      hiPat = ~hiPat;
      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = ~(*pulPatCur);
                        // set target to complemented 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG *) ((PUCHAR) pulPat + xPat);

      }
    }
} // end vFetchShiftNotAndCopy

/****************************Private*Routine******************************\
*
*  VOID CopyPattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat)
*
*  Routine Description:
*
*     This routine contains common code for copying an 8-byte pattern to
*     a target surface.
*
*  Arguments:
*
*     culFill - Supplies the size of the fill in bytes.
*     loPat, hiPat - Supplies the 8-byte pattern to copy.
*     pulTrg - Supplies the starting target surface address.
*
*  Return Value:
*
*     None.
*
*
\*************************************************************************/

VOID CopyPattern
(
        PULONG pulTrg,                  // Starting target surface address (t0)
        LONG   culFill,                 // size of fill in longwords (a1)
        LONG   hiPat,                   // hi part of pattern  (v1)
        LONG   loPat                    // lo part of pattern  (v0)
)
{
    PULONG pulTrgEnd;               // ending target surface address
    ULONG temp;                     // temp for swap

    pulTrgEnd = pulTrg + culFill;
                                    // ending target surface address(t4)

//
// If the fill size is not an even multiple of 8 bytes, then move one
// longword and swap the pattern value.
//

    if ((culFill & 0x01) != 0)
    {
      *pulTrg = loPat;              // store low 4 bytes of pattern
      pulTrg += 1;                  // advance target ptr one longword
      culFill -= 1;
      if (culFill == 0)             // if no more to move then we're done
      {
        return;
      }
      else                          // otherwise, swap 8-byte pattern value
      {
        temp = loPat;
        loPat = hiPat;
        hiPat = temp;
      }
    }

//
// Move 8-byte pattern value to target 8 bytes at a time.
//

    pulTrgEnd -= 2;                 // ending segement address
    if ((culFill & 0x02) != 0)      // check if even multiple of 8 bytes
    {
      while (pulTrg <= pulTrgEnd)   // if not, move 8 bytes at a time
      {
        *pulTrg = loPat;            // store 8-byte pattern value
        *(pulTrg + 1) = hiPat;
        pulTrg += 2;                // advance target address
      }
      return;
    }
    else                            //  move 16 bytes at a time
    {
      pulTrgEnd -= 2;               // ending segement address
      while (pulTrg <= pulTrgEnd)
      {
        *pulTrg = loPat;            // store 8-byte pattern value
        *(pulTrg + 1) = hiPat;
        *(pulTrg + 2) = loPat;      // store 8-byte pattern value
        *(pulTrg + 3) = hiPat;
        pulTrg += 4;                // advance target address
      }
    }
}

/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchAndMerge (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern
*     using ropt (DPx).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchAndMerge
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }

      MergePattern( pulTrg, culFill, hiPat, loPat); //do a 4 or 8-byte copy

    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = (*pulPatCur) ^ (*pulTrg);
                            // XOR 4-byte target with 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchAndMerge

/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftAndMerge (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (P).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftAndMerge
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   *pulPat;                // base pattern address
    ULONG   *pulPatCur;             // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;
                                    // get low part of 8-byte pattern
      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG *) ((PUCHAR) pulPat + xPat));

      MergePattern( pulTrg, culFill, hiPat, loPat); //do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = (*pulPatCur) ^ (*pulTrg);
                            // XOR 4-byte target with 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG *) ((PUCHAR) pulPat + xPat);
      }
    }
} // end vFetchShiftAndMerge

/****************************Private*Routine******************************\
*
*  VOID MergePattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat)
*
*  Routine Description:
*
*     This routine contains common code for merging an 8-byte pattern with
*     a target surface.
*
*  Arguments:
*
*     culFill - Supplies the size of the fill in bytes.
*     loPat, hiPat - Supplies the 8-byte pattern to merge.
*     pulTrg - Supplies the starting target surface address.
*
*  Return Value:
*
*     None.
*
*
\*************************************************************************/

VOID MergePattern
(
        PULONG pulTrg,                  // Starting target surface address (t0)
        LONG   culFill,                 // size of fill in longwords (a1)
        LONG   hiPat,                   // hi part of pattern  (v1)
        LONG   loPat                    // lo part of pattern  (v0)
)
{
    PULONG pulTrgEnd;               // ending target surface address
    ULONG temp;                     // temp for swap

    pulTrgEnd = pulTrg + culFill;
                                    // ending target surface address(t4)

//
// If the fill size is not an even multiple of 8 bytes, then move one
// longword and swap the pattern value.
//

    if ((culFill & 0x01) != 0)
    {
      *pulTrg = loPat ^ (*pulTrg);  // XOR low 4 bytes of pattern w/ target
      pulTrg += 1;                  // advance target ptr one longword
      culFill -= 1;
      if (culFill == 0)             // if no more to move then we're done
      {
        return;
      }
      else                          // otherwise, swap 8-byte pattern value
      {
        temp = loPat;
        loPat = hiPat;
        hiPat = temp;
      }
    }

//
// Move 8-byte pattern value to target 8 bytes at a time.
//

    pulTrgEnd -= 2;                 // ending segement address
    while (pulTrg <= pulTrgEnd)     // if not, move 8 bytes at a time
    {
      *pulTrg = loPat ^ (*pulTrg);  // XOR 4-byte pattern value
      pulTrg++;                     // advance target address
      *pulTrg = hiPat ^ (*pulTrg);  // XOR 4-byte pattern value
      pulTrg++;                     // advance target address
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\cachea.asm ===
page ,132
;*****************************Module*Header*******************************\
; Module Name: cache.asm
;
;
; Created: 9-Dec-1992
; Author:  Paul Butzi
;
; Copyright (c) 1990-1999 Microsoft Corporation
;
;*************************************************************************/
; Note: This module would be more efficient with Frame Pointer Omission
; (FPO), whereby the stack is addressed off ESP rather than EBP, so we
; could stop pushing and popping EBP. However, the ASM macros currently
; don't support FPO.
;*************************************************************************/

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include gdii386.inc
        .list


        .code
EXTRNP  xprunFindRunRFONTOBJ,2
EXTRNP  xpgdDefault,1
EXTRNP  xInsertMetricsRFONTOBJ,3
EXTRNP  xInsertMetricsPlusRFONTOBJ,3
EXTRNP  xInsertGlyphbitsRFONTOBJ,3

ifdef FE_SB
EXTRNP  xwpgdGetLinkMetricsRFONTOBJ,2
EXTRNP  xwpgdGetLinkMetricsPlusRFONTOBJ,3
endif


FAST_WCHAR_BASE equ 20h         ; Most ANSI fonts have a base of 32

;******************************Public*Routine******************************\
;
; BOOL RFONTOBJ::bGetGlyphMetrics (
;     COUNT c,
;     GLYPHPOS *pgp,
;     WCHAR *pwc
;     );
;
; Translate wchars into an array of GLYPHPOS structures, filling in
; the pointer to GLYPHDATA field.  Only the metrics are assured to be
; valid; no attempt is made to ensure that the glyph data itself is
; present in the cache before the return to the caller.
;
; This routine is to be used primarily by GetTextExtent and GetCharWidths,
; which have no need for anything except metrics.
;
; A zero return means that we failed to insert the metrics due to some
; hard error, most likely a failure to commit memory in the glyph
; insertion routine.
;
; History:
;  21-Dec-92 -by- Michael Abrash
; Fixed bug in detecting run inclusion
;  9-Dec-92 -by- Paul Butzi
; Wrote it.
;**************************************************************************/



cPublicProc xGetGlyphMetrics,4,< \
        uses       ebx esi edi,          \
        pThis:     ptr dword,            \
        c_:        dword,                \
        pgp:       ptr dword,            \
        pwc:       dword                 >
        mov     eax, pThis              ; (eax) = ptr to RFONTOBJ
        mov     eax, [eax].prfnt        ; (eax) = ptr to RFONT
        mov     esi, pwc                ; pointer to wchar data
                                        ;*486 pipelining
        mov     eax, [eax].wcgp         ; (eax) = ptr to wcgp
        mov     edi, pgp                ; pointer to glyphpos array to fill
                                        ;*486 pipelining
        lea     ebx, [eax].agprun       ; (ebx) = ptr to first wcgp run
                                        ;*486 pipelining
        mov     ecx, [ebx].wcLow        ; index of start of run
        mov     edx, [ebx].cGlyphs      ; # of glyphs in run
        mov     ebx, [ebx].apgd         ; pointer to run's pointers to cached
                                        ;  glyphdata

        push    ebp
        mov     ebp,c_  ; we'll use EBP for the glyph count
                        ; ***stack frame no longer available***
;
; Invariants:
;       (esi) = ptr to wchar
;       (edi) = ptr to pgp
;       (ebx) = ptr to base of current run
;       (ecx) = wcLow of current run
;       (edx) = cGlyphs of current run
;       (ebp) = count of glyphs remaining
loop_top:

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = wchar, zero extended

        sub     eax, ecx                ; get index relative to current run base
        cmp     eax, edx                ; is wchar in this run?
        jae     short find_run          ; wrong run, better go get right one

run_found:

        mov     eax, [ebx+4*eax]        ; (ecx) = ptr to glyphdata


;
; Invariants:
;       (esi, edi, ebx, ecx, edx) as above at loop top
;       (eax) = ptr to glyphdata
;
default_found:
        and     eax, eax                ; is cached glyphdata there?
        jz      short get_glyph         ; no glyphdata, better go get one

;
; Here, we are assured that the glyphdata is present in the cache
;
glyph_found:
        mov     [edi].gp_pgdf, eax      ; set ptr to glyphdata in glyphpos
        mov     eax, [eax].gd_hg
        mov     [edi].gp_hg, eax        ; set hg in glyphpos


        add     edi, SIZE_GLYPHPOS      ; next glyphpos to fill in
        add     esi, 2          ; next wchar to look up

        dec     ebp             ; any more glyphs?
        jnz     loop_top

        pop     ebp             ; ***stack frame available***

        mov     eax, 1          ; success
        stdRET  xGetGlyphMetrics




;=======================================================================
; We got here because the current run does not contain the wchar we're
; interested in.  Note that the following invariants must hold when
; we re-enter the loop (starred items must hold on entry, as well):
;       (esi) = ptr to wchar*
;       (edi) = ptr to pgp*
;       (ebx) = ptr to apgd of new run
;       (ecx) = wcLow of new run
;       (edx) = cGlyphs of new run
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining*
;=======================================================================
        align   4
find_run:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***
                                ; *****************************************
                                ; * Note that the approach here is to get *
                                ; * EBP off the stack, where it was       *
                                ; * pushed, by addressing off ESP. EBP    *
                                ; * remains pushed, so we don't need to   *
                                ; * re-push it when we're done.           *
                                ; * XCHGing EBP with the top of the stack *
                                ; * would be cleaner, but XCHG locks the  *
                                ; * bus.                                  *
                                ; * This trick is repeated several times  *
                                ; * below.                                *
                                ; *****************************************

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = current wchar
        mov     ebx, pThis
        stdcall xprunFindRunRFONTOBJ, <ebx, eax>        ; find the wchar's run

        pop     ebp                     ; <ebp> = glyph count
                                        ; ***stack frame no longer available***
        mov     ecx, [eax].wcLow        ; index of start of new run
        mov     edx, [eax].cGlyphs      ; # of glyphs in new run
        mov     ebx, [eax].apgd         ; pointer to new run's pointers to
                                        ;  cached glyphdata
        sub     eax, eax
        mov     ax, [esi]               ; (eax) = current wchar
        sub     eax, ecx                ; get index relative to new run base
        cmp     eax, edx                ; is wchar in this run?
        jb      run_found               ; yes, run with it
                                        ; not in any run; use default character
        push    ebp                     ; preserve count of remaining glyphs
        mov     ebp,[esp+4]             ; ***stack frame available***
ifdef FE_SB                          ; call off to linked font handler
        push    ebx                      
        push    ecx
        push    edx
        mov     eax, pThis              ; (eax) = pointer to RFONTOBJ
        sub     ebx,ebx                 ; (ebx) = 0
        mov     bx, [esi]               ; (ebx) = current wchar
        stdcall xwpgdGetLinkMetricsRFONTOBJ,<eax,ebx>
        pop     edx
        pop     ecx
        pop     ebx
else
        mov	eax, pThis
	push	ecx
	push	edx
        stdcall xpgdDefault, <eax>	; eax = ptr to default character
	pop	edx
	pop	ecx
endif
        pop     ebp                     ; <ebp> = glyph count
        jmp     default_found           ; go with the default character

;=======================================================================
; We got here because the glyph pointer in the wcgp run was null, meaning
; we don't yet have the metrics for this glyph. Note that the following
; invariants must be true on exit (starred items must hold on entry, as
; well):
;       (esi) = ptr to wchar*
;       (edi) = ptr to pgp*
;       (ebx) = ptr to apgd of new run*
;       (ecx) = wcLow of new run*
;       (edx) = cGlyphs of new run*
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining*
;=======================================================================
        align   4
get_glyph:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***

        push    ebx
        push    edx
        push    ecx

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = wchar
        mov     edx, eax                ; set aside wchar
        sub     eax, ecx                ; (eax) = index into run
        lea     ebx, [ebx+eax*4]        ; (ebx) = ptr to entry
        mov     ecx,pThis
        stdcall xInsertMetricsRFONTOBJ, <ecx, ebx, edx>
        pop     ecx
        pop     edx
        and     eax, eax                ; were we able to get the glyph metrics?
        jz      short failed            ; no

        mov     eax, [ebx]              ; get ptr to glyphdata from cache entry

        pop     ebx

        pop     ebp             ; <ebp> = glyph count
                                ; ***stack frame no longer available***
        jmp     glyph_found

failed:
        pop     ebx

        pop     eax             ; clear glyph count from stack
        pop     eax             ; clear pushed stack frame pointer from stack

        sub     eax, eax        ; failure
        stdRET  xGetGlyphMetrics

stdENDP xGetGlyphMetrics







;******************************Public*Routine******************************\
;
; BOOL RFONTOBJ::bGetGlyphMetricsPlus (
;     COUNT c,
;     GLYPHPOS *pgp,
;     WCHAR *pwc,
;     BOOL *pbAccel
;     );
;
; Translate wchars into an array of GLYPHPOS structures, filling in
; the pointer to GLYPHDATA field.  Although only the metrics are assured to be
; valid, an attempt is made to ensure that the glyph data itself is
; present in the cache before the return to the caller.  Failure in this
; attempt is indicated by clearing the flag *pbAccel.  This allows the
; text code to tell the device driver that the STROBJ_bEnum callback is
; not needed.
;
; This routine is to be used primarily by TextOut and its kin.
;
; A zero return means that we failed to insert the metrics due to some
; hard error, most likely a failure to commit memory in the glyph
; insertion routine.
;
; This is a replacement for the C++ version in cache.cxx
;
; History:
;  21-Dec-92 -by- Michael Abrash
; Fixed bug in detecting run inclusion
;  9-Dec-92 -by- Paul Butzi
; Wrote it.
;**************************************************************************/


cPublicProc xGetGlyphMetricsPlus,5,<         \
        uses       ebx esi edi,         \
        pThis:     ptr dword,           \
        c_:        dword,               \
        pgp:       ptr dword,           \
        pwc:       dword,               \
        pbAccel:   ptr dword            >
        local pbacceltmp : dword        ;1 if all glyph bits have been gotten
                                        ; so far, 0 if not

        mov     eax, pThis              ; (eax) = ptr to RFONTOBJ
        mov     pbacceltmp,1            ; set bAccel to true (all glyph bits
                                        ;  realized so far)
                                        ;*486 pipelining
        mov     eax, [eax].prfnt        ; (eax) = ptr to RFONT
        mov     esi, pwc                ; pointer to wchar data
                                        ;*486 pipelining
        mov     eax, [eax].wcgp         ; (eax) = ptr to wcgp
        mov     edi, pgp                ; pointer to glyphpos array to fill
                                        ;*486 pipelining
        lea     ebx, [eax].agprun       ; (ebx) = ptr to first wcgp run
                                        ;*486 pipelining
        push    ebp                     ;*486 pipelining
        mov     ecx, [ebx].wcLow        ; index of start of run
        mov     edx, [ebx].cGlyphs      ; # of glyphs in run
        mov     ebx, [ebx].apgd         ; pointer to run's pointers to cached
                                        ;  glyphdata

        mov     ebp,c_  ; we'll use EBP for the glyph count
                        ; ***stack frame no longer available***

;--------------------------------------------------------------------------
; Fast two-glyphs-at-a-time Pentium pipe-lined loop
;
; The philosophy of this loop is that for the vast majority of the time,
; all the glyphs will be in the proper range, have cached glyphdata, and
; have cached glyphbits -- and it takes advantage of that to better make
; use of both Pentium pipes by doing two glyphs at once.  If one of those
; conditions fail, it converts to the single-glyph-at-a-time loop when
; that happens.
;
; Invariants:
;       (esi) = ptr to 1st wchar
;       (edi) = ptr to pgp
;       (ecx) = ptr to 2nd wchar
;       (ecx) = wcLow of current run
;       (edx) = cGlyphs of current run
;       (ebp) = count of glyphs remaining
;       [esp] = wcLow of current run

        cmp     ecx, FAST_WCHAR_BASE    ; fast loop handles wcLow values only
        jne     gmp_slow_loop_top       ;  of 32

        dec     ebp                     ; pre-decrement count
        jz      gmp_slow_loop_top       ; only one character.  it's okay to
                                        ;  pop this through to gmp_slow_loop_top
                                        ;  with a zero count -- it's effectively
                                        ;  the same as a one count

        push    ecx                     ; wcLow is now at [esp]

gmp_fast_loop_top:
        mov     eax, [esi]              ; 1U (eax) = first two glyphs
        add     edi, 2*SIZE_GLYPHPOS    ; 1V each iteration does two glyphpos's.
                                        ;     we do this now to eat up a free V
                                        ;     pipe instruction
        mov     ecx, eax                ; 1U
        add     esi, 4                  ; 1V each iteration does two wchars.
                                        ;     we do this now to eat up a free V
                                        ;     pipe instruction
        shr     ecx, 16                 ; 1U (ecx) = 2nd wchar, zero extended
        and     eax, 0ffffh             ; 1V (eax) = 1st wchar, zero extended

        sub     eax, FAST_WCHAR_BASE    ; 1U get index relative to current base
        sub     ecx, FAST_WCHAR_BASE    ; 1V get index relative to current base

        cmp     eax, edx                ; 1U is 1st wchar in this run?
        jae     gmp_restart_in_slow_loop; 1V wrong run, exit fast loop
        cmp     ecx, edx                ; 1U is 2nd wchar in this run?
        jae     gmp_restart_in_slow_loop; 1V wrong run, exit fast loop

        mov     eax, [ebx+4*eax]        ; 2U (eax) = ptr to 1st glyphdata
        mov     ecx, [ebx+4*ecx]        ; 2V (ecx) = ptr to 2nd glyphdata
                                        ;     (could be 3V if in same cache
                                        ;     bank)

        test    eax, eax                ; 1U is 1st cached glyphdata there?
        jz      gmp_restart_in_slow_loop; 1V no glyphdata, exit fast loop
        test    ecx, ecx                ; 1U is 2nd cached glyphdata there?
        jz      gmp_restart_in_slow_loop; 1V no glyphdata, exit fast loop

        cmp     dword ptr [eax].gd_gdf, 0 ; 2U are 1st glyph bits in cache?
        je      gmp_restart_in_slow_loop  ; 1V no, go get them
        cmp     dword ptr [ecx].gd_gdf, 0 ; 2U are 2nd glyph bits in cache?
        je      gmp_restart_in_slow_loop  ; 1V no, go get them

        mov     [edi-2*SIZE_GLYPHPOS].gp_pgdf, eax
                                        ; 1U set ptr to glyphdata in glyphpos
        mov     eax, [eax].gd_hg        ; 1V read 1st glyph handle

        mov     [edi-1*SIZE_GLYPHPOS].gp_pgdf, ecx
                                        ; 1U set ptr to glyphdata in glyphpos
        mov     ecx, [ecx].gd_hg        ; 1V read 2nd glyph handle

        mov     [edi-2*SIZE_GLYPHPOS].gp_hg,eax ; 1U set handle in glyphpos
        mov     [edi-1*SIZE_GLYPHPOS].gp_hg,ecx ; 1V set handle in glyphpos

        sub     ebp, 2                  ; 1U each iteration does two glyphs
        jg      gmp_fast_loop_top       ; 1V more loops to do
        pop     ecx                     ; account for pushed wcLow
        jz      gmp_slow_loop_top       ; odd number of glyphs, handle last one

        pop     ebp                     ; ***stack frame available***
        mov     ebx,pbaccel             ; where we'll store whether all glyph
                                        ;  bits found
        mov     eax, 1                  ; success
        mov     [ebx], 1                ; success

        stdRET  xGetGlyphMetricsPlus

;--------------------------------------------------------------------------
; Not-so-fast one-glyph-at-a-time loop
;
; Invariants:
;       (esi) = ptr to wchar
;       (edi) = ptr to pgp
;       (ebx) = ptr to base of current run
;       (ecx) = wcLow of current run
;       (edx) = cGlyphs of current run
;       (ebp) = count of glyphs remaining

gmp_restart_in_slow_loop:
        pop     ecx                     ; (ecx) = wcLow of current run
        inc     ebp                     ; account for fast-loop preadjustments
        sub     edi, 2*SIZE_GLYPHPOS
        sub     esi, 4

gmp_slow_loop_top:
        sub     eax, eax
        mov     ax, [esi]               ; (eax) = wchar, zero extended

        sub     eax, ecx                ; get index relative to current run base
        cmp     eax, edx                ; is wchar in this run?
        jae     short gmp_find_run      ; wrong run, better go get right one

gmp_run_found:
        mov     eax, [ebx+4*eax]        ; (ecx) = ptr to glyphdata


;
; Invariants:
;       (esi, edi, ebx, ecx, edx) as above at loop top
;       (eax) = ptr to glyphdata
;
gmp_default_found:
        and     eax, eax                ; is cached glyphdata there?
        jz      gmp_get_glyph           ; no glyphdata, better go get one

;
; Here, we are assured that the glyphdata is present in the cache
;
gmp_glyph_found:
        cmp     dword ptr [eax].gd_gdf, 0 ; are the glyph bits in the cache?
        jz      gmp_get_bits              ; no, go get them

;
; Here, we have tried to get the glyphbits in the cache
;
gmp_got_bits:
        mov     [edi].gp_pgdf, eax      ; set ptr to glyphdata in glyphpos
        mov     eax, [eax].gd_hg
        mov     [edi].gp_hg, eax        ; set hg in glyphpos


        add     edi, SIZE_GLYPHPOS      ; next glyphpos to fill in
        add     esi, 2                  ; next wchar to look up

        dec     ebp                     ; any more glyphs?
        jg      gmp_slow_loop_top       ; must be 'greater than' check

        pop     ebp                     ; ***stack frame available***

        mov     ebx,pbaccel     ; where we'll store whether all glyph bits found
        mov     eax,pbacceltmp  ; 0 if not all found, 1 if all found
        mov     [ebx],eax       ; return whether we found all glyph bits or not

        mov     eax, 1          ; success
        stdRET  xGetGlyphMetricsPlus



;=======================================================================
; We got here because the current run does not contain the wchar we're
; interested in.  Note that the following invariants must hold when
; we re-enter the loop (starred items must hold on entry, as well):
;       (esi) = ptr to wchar*
;       (edi) = ptr to pgp*
;       (ebx) = ptr to apgd of new run
;       (ecx) = wcLow of new run
;       (edx) = cGlyphs of new run
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining*
;=======================================================================
        align   4
gmp_find_run:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = current wchar
        mov     ebx, pThis

        stdcall xprunFindRunRFONTOBJ, <ebx, eax>

        pop     ebp     ; <ebp> = glyph count
                        ; ***stack frame no longer available***
        mov     ecx, [eax].wcLow        ; index of start of new run
        mov     edx, [eax].cGlyphs      ; # of glyphs in new run
        mov     ebx, [eax].apgd         ; pointer to new run's pointers to
                                        ;  cached glyphdata
        sub     eax, eax
        mov     ax, [esi]               ; (eax) = current wchar
        sub     eax, ecx                ; get index relative to new run base
        cmp     eax, edx                ; is wchar in this run?
        jb      gmp_run_found           ; yes, run with it
                                        ; not in any run; use default character
        push    ebp                     ; preserve count of remaining glyphs
        mov     ebp,[esp+4]             ; ***stack frame available***

ifdef FE_SB
        push    ebx
        push    ecx
        push    edx
        mov     eax, pThis              ; (eax) = pointer to RFONTOBJ
        lea     ebx, pbacceltmp         ; (ebx) = pointer to pbacceltmp
                                        ; (esi) = pointer to current wchar
        stdcall xwpgdGetLinkMetricsPlusRFONTOBJ,<eax,esi,ebx>
        pop     edx
        pop     ecx
        pop     ebx                     ; (eax) is now proper wpgd
else
        mov     eax,pThis	
	push	ecx
	push	edx
        stdcall xpgdDefault, <eax>	; eax = ptr to default character
	pop	edx
	pop	ecx
endif
        pop     ebp                     ; <ebp> = glyph count
                                        ; ***stack frame no longer available***

        jmp     gmp_default_found       ; go with the default character


;=======================================================================
; We got here because the glyph pointer in the wcgp run was null, meaning
; we don't yet have the metrics for this glyph. Note that the following
; invariants must be true on exit (starred items must hold on entry, as
; well):
;       (esi) = ptr to wchar*
;       (edi) = ptr to pgp*
;       (ebx) = ptr to apgd of new run*
;       (ecx) = wcLow of new run*
;       (edx) = cGlyphs of new run*
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining*
;=======================================================================
        align   4
gmp_get_glyph:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***

        push    ebx
        push    edx
        push    ecx

        sub     eax, eax
        mov     ax, [esi]               ; (eax) = wchar
        mov     edx, eax                ; set aside wchar
        sub     eax, ecx                ; (eax) = index into run
        lea     ebx, [ebx+4*eax]        ; (ebx) = ptr to entry
        mov     ecx,pThis
        stdcall xInsertMetricsPlusRFONTOBJ, <ecx, ebx, edx>
        pop     ecx
        pop     edx
        and     eax, eax                ; were we able to get the glyph metrics?
        jz      short gmp_failed        ; no

        mov     eax, [ebx]              ; get ptr to glyphdata from it

        pop     ebx

        pop     ebp             ; <ebp> = glyph count
                                ; ***stack frame no longer available***
        jmp     gmp_glyph_found

gmp_failed:
        pop     ebx

        pop     eax             ; clear glyph count from stack
        pop     eax             ; clear pushed stack frame pointer from stack

        sub     eax, eax        ;failure
        stdRET  xGetGlyphMetricsPlus

;=======================================================================
; We get here if we need to try to load the bits for the glyph we're
; interested in (because the bits havene't been realized yet). We only
; even bother to try if all bits have successfully been realized so far,
; because it's only useful to realize glyphs if we can get all of them.
; Note that the following invariants must be true on both entry and exit.
;       (esi) = ptr to wchar
;       (edi) = ptr to pgp
;       (ebx) = ptr to apgd of new run
;       (ecx) = wcLow of new run
;       (edx) = cGlyphs of new run
;       (eax) = ptr to glyphdata
;       (ebp) = count of glyphs remaining
;=======================================================================
        align   4
gmp_get_bits:
        push    ebp             ; preserve count of remaining glpyhs
        mov     ebp,[esp+4]     ; ***stack frame available***

        cmp     pbacceltmp,0            ;if we already failed to get glyph bits
        je      short got_the_bits_done ; once, no point in trying again

        push    ecx
        mov     ecx, pThis
        push    edx             ;*486 pipelining
        mov     edx, [ecx].prfnt
        push    eax             ;*486 pipelining
        cmp     dword ptr [edx].ulContent, FO_HGLYPHS
        je      short got_the_bits

        sub     edx,edx
        cmp     pwc,esi
        sbb     edx,-1          ; EDX == TRUE if first wc, FALSE else
        stdcall xInsertGlyphbitsRFONTOBJ, <ecx, eax, edx> ;try to get the bits

        and     eax, eax             ; did we succeed in getting the bits?
        jnz     short got_the_bits   ; yes, we got the bits
        mov     pbacceltmp, eax      ; didn't get the glyph (note: EAX is zero)
got_the_bits:
        pop     eax
        pop     edx
        pop     ecx
got_the_bits_done:
        pop     ebp     ; <ebp> = glyph count
                        ; ***stack frame no longer available***
        jmp     gmp_got_bits


stdENDP xGetGlyphMetricsPlus



        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\gdiplus\screen.c ===
/******************************Module*Header*******************************\
* Module Name: screen.c
*
* This file contains the virtual driver that is used for user-mode GDI+
* painting on the desktop screen.
*
* Copyright (c) 1998-1999 Microsoft Corporation
*
* Created: 29-Apr-1998
* Author: J. Andrew Goossen [andrewgo]
*
\**************************************************************************/

// @@@ Re-visit headers:

#define NO_DDRAWINT_NO_COM

// @@@ Temporary:

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <winerror.h>
#include <ddraw.h>
#include <wingdi.h>
#include <winddi.h>
#include <math.h>

VOID vFreeMem(VOID*);
VOID* pAllocMem(ULONG, ULONG);

#define RIP(x) OutputDebugString(x)
#define WARNING(x) OutputDebugString(x)
#define ASSERTGDI(x, y) if (!(x)) OutputDebugString(y)
#define PALLOCMEM(size, tag) pAllocMem(size, tag);
#define VFREEMEM(p) vFreeMem(p);

ULONG
DbgPrint(
    PCH Format,
    ...
    );


typedef struct _GPDEV 
{
    HDEV                hdev;
    HWND                hwnd;           // @@@ Hwnd this HDEV was created from
    HSURF               hsurfScreen;    // Handle to the screen surface
    SIZEL               sizlScreen;     // Size of the screen
    ULONG               iBitmapFormat;  // The color depth
    ULONG               flRed;          // The RGB color masks
    ULONG               flGreen;
    ULONG               flBlue;
    HPALETTE            hpalDefault;    // The GDI palette handle
    PALETTEENTRY*       pPal;           // The palette table if palette managed
    LPDIRECTDRAW        lpDD;           // DirectDraw object
    LPDIRECTDRAWSURFACE lpDDPrimary;    // DirectDraw primary surface
    LPDIRECTDRAWSURFACE lpDDBuffer;     // DirectDraw buffer surface
    LPDIRECTDRAWCLIPPER lpDDClipper;    // Primary surface DirectDraw clipper
    SURFOBJ*            psoBuffer;      // GDI surface wrapped around buffer
} GDEV;

/******************************Public*Structure****************************\
* GDIINFO ggdiGdiPlusDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiGdiPlusDefault = {
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    320,                    // ulHorzSize 
    240,                    // ulVertSize 
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    8,                      // ulDACRed (possibly overwritten later)
    8,                      // ulDACGreen (possibly overwritten later)
    8,                      // ulDACBlue (possibly overwritten later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoGdiPlusDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoGdiPlusDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_PALMANAGED       |
     GCAPS_MONO_DITHER      |
     GCAPS_COLOR_DITHER),
                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Routine******************************\
* VOID vGpsUninitializeDirectDraw
*
\**************************************************************************/

VOID vGpsUninitializeDirectDraw(
GDEV*   pgdev)
{
    HSURF hsurf;

    if (pgdev->psoBuffer != NULL)
    {
        hsurf = pgdev->psoBuffer->hsurf;
        EngUnlockSurface(pgdev->psoBuffer);
        EngDeleteSurface(hsurf);
    }
    if (pgdev->lpDDClipper != NULL)
    {
        pgdev->lpDDClipper->lpVtbl->Release(pgdev->lpDDClipper);
        pgdev->lpDDClipper = NULL;
    }
    if (pgdev->lpDDBuffer != NULL)
    {
        pgdev->lpDDBuffer->lpVtbl->Release(pgdev->lpDDBuffer);
        pgdev->lpDDBuffer = NULL;
    }
    if (pgdev->lpDDPrimary != NULL)
    {
        pgdev->lpDDPrimary->lpVtbl->Release(pgdev->lpDDPrimary);
        pgdev->lpDDPrimary = NULL;
    }
    if (pgdev->lpDD != NULL)
    {
        pgdev->lpDD->lpVtbl->Release(pgdev->lpDD);
        pgdev->lpDD = NULL;
    }
}

/******************************Public*Routine******************************\
* BOOL bGpsInitializeDirectDraw
*
\**************************************************************************/

BOOL bGpsInitializeDirectDraw(
GDEV*   pgdev,
HWND    hwnd,
ULONG*  pScreenWidth,
ULONG*  pScreenHeight,
ULONG*  pBitsPerPlane,
ULONG*  pRedMask,
ULONG*  pGreenMask,
ULONG*  pBlueMask)
{
    LPDIRECTDRAW        lpDD;
    DDSURFACEDESC       DDMode;
    DDSURFACEDESC       ddsd;
    LPDIRECTDRAWSURFACE lpDDPrimary;
    LPDIRECTDRAWSURFACE lpDDBuffer;
    LPDIRECTDRAWCLIPPER lpDDClipper;
    SURFOBJ*            psoBuffer;
    SIZEL               sizl;
    ULONG               iFormat;
    HSURF               hsurf;

    DDMode.dwSize = sizeof(DDMode);

    if (DirectDrawCreate(NULL, &lpDD, NULL) == DD_OK)
    {
        if ((lpDD->lpVtbl->SetCooperativeLevel(lpDD, hwnd, DDSCL_NORMAL) == DD_OK) &&
            (lpDD->lpVtbl->GetDisplayMode(lpDD, &DDMode) == DD_OK))
        {
            *pScreenWidth  = DDMode.dwWidth;
            *pScreenHeight = DDMode.dwHeight;
            *pBitsPerPlane = DDMode.ddpfPixelFormat.dwRGBBitCount;
            *pRedMask      = DDMode.ddpfPixelFormat.dwRBitMask;
            *pGreenMask    = DDMode.ddpfPixelFormat.dwGBitMask;
            *pBlueMask     = DDMode.ddpfPixelFormat.dwBBitMask;

            // Create a primary surface:
    
            RtlZeroMemory(&ddsd, sizeof(ddsd));

            ddsd.dwSize = sizeof(ddsd);
            ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

            if (lpDD->lpVtbl->CreateSurface(lpDD, &ddsd, &lpDDPrimary, NULL) == DD_OK)
            {
                if (lpDD->lpVtbl->CreateClipper(lpDD, 0, &lpDDClipper, NULL) == DD_OK)
                {
                    if ((lpDDClipper->lpVtbl->SetHWnd(lpDDClipper, 0, hwnd) == DD_OK) &&
                        (lpDDPrimary->lpVtbl->SetClipper(lpDDPrimary, lpDDClipper) == DD_OK))
                    {
                        // Create a temporary DirectDraw surface that's used
                        // as a staging area.
                        //
                        // @@@ This darn well better be temporary!
                
                        RtlZeroMemory(&ddsd, sizeof(ddsd));
            
                        ddsd.dwSize         = sizeof(ddsd);
                        ddsd.dwFlags        = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
                        ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN;
                        ddsd.dwWidth        = DDMode.dwWidth;
                        ddsd.dwHeight       = DDMode.dwHeight;
                
                        if (lpDD->lpVtbl->CreateSurface(lpDD, &ddsd, &lpDDBuffer, NULL) == DD_OK) 
                        {
                            if (lpDDBuffer->lpVtbl->Lock(lpDDBuffer, NULL, &ddsd, DDLOCK_WAIT, NULL) 
                                    == DD_OK)
                            {
                                // Create a GDI surface to wrap around the temporary
                                // buffer:
        
                                sizl.cx = ddsd.dwWidth;
                                sizl.cy = ddsd.dwHeight;
        
                                switch (DDMode.ddpfPixelFormat.dwRGBBitCount)
                                {
                                    case 4:  iFormat = BMF_4BPP; break;
                                    case 8:  iFormat = BMF_8BPP; break;
                                    case 16: iFormat = BMF_16BPP; break;
                                    case 24: iFormat = BMF_24BPP; break;
                                    case 32: iFormat = BMF_32BPP; break;
                                    default: RIP("Unexpected dwRGBBitCount");
                                }

                                // !!! @@@ Why did I have to specify BMF_TOPDOWN?
            
                                hsurf = (HSURF) EngCreateBitmap(sizl, 
                                                                ddsd.lPitch, 
                                                                iFormat,
                                                                BMF_TOPDOWN,
                                                                ddsd.lpSurface);
        
                                lpDDBuffer->lpVtbl->Unlock(lpDDBuffer, ddsd.lpSurface);
        
                                if (hsurf != NULL)
                                {
                                    psoBuffer = EngLockSurface(hsurf);
        
                                    pgdev->hwnd        = hwnd;
                                    pgdev->lpDD        = lpDD;
                                    pgdev->lpDDPrimary = lpDDPrimary;
                                    pgdev->lpDDBuffer  = lpDDBuffer;
                                    pgdev->psoBuffer   = psoBuffer;
                
                                    return(TRUE);
                                }
                            }
        
                            lpDDBuffer->lpVtbl->Release(lpDDBuffer);
                        }
                    }

                    lpDDClipper->lpVtbl->Release(lpDDClipper);
                }

                lpDDPrimary->lpVtbl->Release(lpDDPrimary);
            }
        }

        lpDD->lpVtbl->Release(lpDD);
    }

    WARNING("Failed bGpsInitializeDirectDraw");

    return(FALSE);
}


/******************************Public*Routine******************************\
* BOOL bGpsInitializeModeFields
*
* Fill in the GDIINFO and DEVINFO structures required by the engine.
*
\**************************************************************************/

BOOL bGpsInitializeModeFields(
GDEV*       pgdev,
ULONG*      pScreenWidth,
ULONG*      pScreenHeight,
ULONG*      pBitsPerPlane,
ULONG*      pRedMask,
ULONG*      pGreenMask,
ULONG*      pBlueMask,
GDIINFO*    pgdi,
DEVINFO*    pdi)
{
    ULONG   BitsPerPlane;
    ULONG   RedMask;
    ULONG   GreenMask;
    ULONG   BlueMask;
    ULONG   ScreenWidth;
    ULONG   ScreenHeight;

    RedMask      = *pRedMask;
    GreenMask    = *pGreenMask;
    BlueMask     = *pBlueMask;
    BitsPerPlane = *pBitsPerPlane;
    ScreenWidth  = *pScreenWidth;
    ScreenHeight = *pScreenHeight;

    pgdev->sizlScreen.cx = ScreenWidth;
    pgdev->sizlScreen.cy = ScreenHeight;

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiGdiPlusDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzRes         = ScreenWidth;
    pgdi->ulVertRes         = ScreenHeight;
    pgdi->ulPanningHorzRes  = ScreenWidth;
    pgdi->ulPanningVertRes  = ScreenHeight;

    pgdi->cBitsPixel        = BitsPerPlane;
    pgdi->cPlanes           = 1;

    pgdi->ulLogPixelsX      = 120; // @@@
    pgdi->ulLogPixelsY      = 120;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoGdiPlusDefault;

    if (BitsPerPlane == 8)
    {
        pgdev->iBitmapFormat   = BMF_8BPP;

        pgdi->ulDACRed         = 0;
        pgdi->ulDACGreen       = 0;
        pgdi->ulDACBlue        = 0;
    }
    else if ((BitsPerPlane == 16) || (BitsPerPlane == 15))
    {
        pgdev->iBitmapFormat   = BMF_16BPP;
        pgdev->flRed           = RedMask;
        pgdev->flGreen         = GreenMask;
        pgdev->flBlue          = BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else if (BitsPerPlane == 24)
    {
        pgdev->iBitmapFormat   = BMF_24BPP;
        pgdev->flRed           = RedMask;
        pgdev->flGreen         = GreenMask;
        pgdev->flBlue          = BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else
    {
        ASSERTGDI(BitsPerPlane == 32,
            "This driver supports only 8, 16, 24 and 32bpp");

        pgdev->iBitmapFormat   = BMF_32BPP;
        pgdev->flRed           = RedMask;
        pgdev->flGreen         = GreenMask;
        pgdev->flBlue          = BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bGpsInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bGpsInitializePalette(
GDEV*    pgdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    if (pgdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = EngAllocMem(FL_ZERO_MEMORY, sizeof(PALETTEENTRY) * 256, 'zzzG');
        if (ppal == NULL)
            goto ReturnFalse;

        pgdev->pPal = ppal;

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {
        ASSERTGDI((pgdev->iBitmapFormat == BMF_16BPP) ||
         (pgdev->iBitmapFormat == BMF_24BPP) ||
         (pgdev->iBitmapFormat == BMF_32BPP),
         "This case handles only 16, 24 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                pgdev->flRed, pgdev->flGreen, pgdev->flBlue);
    }

    pgdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    WARNING("Failed bInitializePalette");
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vGpsUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vGpsUninitializePalette(GDEV* gpdev)
{
    // Delete the default palette if we created one:

    if (gpdev->hpalDefault != 0)
        EngDeletePalette(gpdev->hpalDefault);

    if (gpdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(gpdev->pPal);
}

/******************************Public*Routine******************************\
* GpsDisablePDEV
*
\**************************************************************************/

VOID GpsDisablePDEV(
DHPDEV  dhpdev)
{
    GDEV*   pgdev;

    pgdev = (GDEV*) dhpdev;

    vGpsUninitializePalette(pgdev);

    vGpsUninitializeDirectDraw(pgdev);

    VFREEMEM(pgdev);
}

/******************************Public*Routine******************************\
* DHPDEV GpsEnablePDEV
*
\**************************************************************************/

DHPDEV GpsEnablePDEV(
DEVMODEW*   pdm,            
PWSTR       pwszLogAddr,    
ULONG       cPat,           
HSURF*      phsurfPatterns, 
ULONG       cjCaps,         
ULONG*      pdevcaps,       
ULONG       cjDevInfo,      
DEVINFO*    pdi,            
HDEV        hdev,           
PWSTR       pwszDeviceName, 
HANDLE      hDriver)        
{
    GDEV*   pgdev;
    HWND    hwnd;
    ULONG   BitsPerPlane;
    ULONG   RedMask;
    ULONG   GreenMask;
    ULONG   BlueMask;
    ULONG   ScreenWidth;
    ULONG   ScreenHeight;

    pgdev = PALLOCMEM(sizeof(GDEV), 'zzzG');
    if (pgdev == NULL)
    {
        goto ReturnFailure0;
    }

    hwnd = (HWND) pdm;

    if (!bGpsInitializeDirectDraw(pgdev, hwnd, &ScreenWidth, &ScreenHeight,
                                  &BitsPerPlane, &RedMask, &GreenMask,
                                  &BlueMask))
    {
        goto ReturnFailure0;
    }
    
    if (!bGpsInitializeModeFields(pgdev, &ScreenWidth, &ScreenHeight,
                                  &BitsPerPlane, &RedMask, &GreenMask,
                                  &BlueMask, (GDIINFO*) pdevcaps, pdi))
    {
        goto ReturnFailure0;
    }

    if (!bGpsInitializePalette(pgdev, pdi))
    {
        goto ReturnFailure1; 
    }

    return((DHPDEV) pgdev);

ReturnFailure1:
    GpsDisablePDEV((DHPDEV) pgdev);

ReturnFailure0:
    return(0);
}

/******************************Public*Routine******************************\
* VOID GpsCompletePDEV
*
\**************************************************************************/

VOID GpsCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((GDEV*) dhpdev)->hdev = hdev;
}

/******************************Public*Routine******************************\
* VOID GpsDisableSurface
*
\**************************************************************************/

VOID GpsDisableSurface(
DHPDEV dhpdev)
{
    GDEV*   pgdev;

    pgdev = (GDEV*) dhpdev;

    EngDeleteSurface(pgdev->hsurfScreen);
}

/******************************Public*Routine******************************\
* HSURF GpsEnableSurface
*
\**************************************************************************/

HSURF GpsEnableSurface(
DHPDEV dhpdev)
{
    HSURF   hsurf;
    GDEV*   pgdev;

    pgdev = (GDEV*) dhpdev;

    hsurf = EngCreateDeviceSurface(NULL, pgdev->sizlScreen, pgdev->iBitmapFormat);
    if (hsurf == 0)
    {
        goto ReturnFailure;
    }

    // Associate surface with a physical device now

    if (!EngAssociateSurface(hsurf, pgdev->hdev, HOOK_BITBLT    
                                               | HOOK_COPYBITS  
                                               | HOOK_STROKEPATH
                                               | HOOK_TEXTOUT))
    {
        goto ReturnFailure;
    }

    pgdev->hsurfScreen = hsurf;             // Remember it for clean-up

    return(hsurf);

ReturnFailure:
    GpsDisableSurface((DHPDEV) pgdev);

    return(0);
}

/******************************Public*Routine******************************\
* VOID vGpsWindowOffset
*
* Hack function to account for the window offset.
*
\**************************************************************************/

VOID
vGpsWindowOffset(
GDEV*   pgdev,
RECTL*  prcl,
RECT*   prc)
{
    RECT rcWindow;

    GetWindowRect(pgdev->hwnd, &rcWindow);

    prc->left   = rcWindow.left + prcl->left;
    prc->right  = rcWindow.left + prcl->right;
    prc->top    = rcWindow.top  + prcl->top;
    prc->bottom = rcWindow.top  + prcl->bottom;
}

/******************************Public*Routine******************************\
* BOOL GpsCopyBits
*
\**************************************************************************/

BOOL GpsCopyBits(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc)
{
    GDEV*   pgdev;
    RECTL   rclSrc;
    HRESULT hr;
    RECT    rcWindow;
    RECT    rcSrc;

    rclSrc.left   = pptlSrc->x;
    rclSrc.top    = pptlSrc->y;
    rclSrc.right  = pptlSrc->x + (prclDst->right - prclDst->left);
    rclSrc.bottom = pptlSrc->y + (prclDst->bottom - prclDst->top);

    if (psoSrc->dhpdev == NULL)
    {
        // DIB-to-screen:

        pgdev = (GDEV*) psoDst->dhpdev;

        vGpsWindowOffset(pgdev, prclDst, &rcWindow);

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // Read in a copy of the destination bits in order to handle 
            // complex clipping because we're going to write everything
            // back out:

        Repeat1:

            hr = pgdev->lpDDBuffer->lpVtbl->Blt(pgdev->lpDDBuffer,
                                                (RECT*) prclDst,
                                                pgdev->lpDDPrimary,
                                                &rcWindow,
                                                DDBLT_WAIT,
                                                NULL);

            if (hr == DDERR_SURFACELOST)
            {
                DbgPrint("Lost!\n");
                pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
                goto Repeat1;
            }
        }

        EngCopyBits(pgdev->psoBuffer, psoSrc, pco, pxlo, prclDst, pptlSrc);

    Repeat2:

        hr = pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                             &rcWindow,
                                             pgdev->lpDDBuffer,
                                             (RECT*) prclDst,
                                             DDBLT_WAIT,
                                             NULL);

        if (hr == DDERR_SURFACELOST)
        {
            DbgPrint("Lost2\n");
            pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
            goto Repeat2;
        }
    }
    else if (psoDst->dhpdev == NULL)
    {
        // Screen-to-DIB:

        pgdev = (GDEV*) psoSrc->dhpdev;

        vGpsWindowOffset(pgdev, &rclSrc, &rcWindow);

        pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDBuffer,
                                        (RECT*) &rclSrc,
                                        pgdev->lpDDPrimary,
                                        &rcWindow,
                                        DDBLT_WAIT,
                                        NULL);

        EngCopyBits(psoDst, pgdev->psoBuffer, pco, pxlo, prclDst, pptlSrc);
    }
    else
    {
        // Screen-to-screen:

        pgdev = (GDEV*) psoDst->dhpdev;

        vGpsWindowOffset(pgdev, prclDst, &rcWindow);
        vGpsWindowOffset(pgdev, &rclSrc, &rcSrc);

        pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                        &rcWindow,
                                        pgdev->lpDDPrimary,
                                        &rcSrc,
                                        DDBLT_WAIT,
                                        NULL);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL GpsBitBlt
*
* An 's' is appended to this function name so that we don't conflict 
* with 'GpsBitBlt' exported from gdiplus.dll.
*
\**************************************************************************/

BOOL GpsBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMsk,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMsk,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    GDEV*   pgdev;
    HRESULT hr;
    RECT    rcWindow;

    if (psoSrc == NULL)
    {
        // Patblt to screen:

        pgdev = (GDEV*) psoDst->dhpdev;

        vGpsWindowOffset(pgdev, prclDst, &rcWindow);

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // Read in a copy of the destination bits in order to handle 
            // complex clipping because we're going to write everything
            // back out:

        Repeat1:

            hr = pgdev->lpDDBuffer->lpVtbl->Blt(pgdev->lpDDBuffer,
                                                (RECT*) prclDst,
                                                pgdev->lpDDPrimary,
                                                &rcWindow,
                                                DDBLT_WAIT,
                                                NULL);

            if (hr == DDERR_SURFACELOST)
            {
                DbgPrint("Lost!\n");
                pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
                goto Repeat1;
            }
        }

        EngBitBlt(pgdev->psoBuffer, psoSrc, psoMsk, pco, pxlo, prclDst,
                  pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

    Repeat2:

        hr = pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                             &rcWindow,
                                             pgdev->lpDDBuffer,
                                             (RECT*) prclDst,
                                             DDBLT_WAIT,
                                             NULL);

        if (hr == DDERR_SURFACELOST)
        {
            DbgPrint("Lost2\n");
            pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
            goto Repeat2;
        }

        return(TRUE);
    }
    else
    {
        return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                         pptlMsk, pbo, pptlBrush, rop4));
    }
}

/******************************Public*Routine******************************\
* BOOL GpsStrokePath
*
\**************************************************************************/

BOOL GpsStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxlo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    GDEV*   pgdev;
    HRESULT hr;
    RECT    rcWindow;

Repeat1:

    pgdev = (GDEV*) pso->dhpdev;

    vGpsWindowOffset(pgdev, &pco->rclBounds, &rcWindow);

    hr = pgdev->lpDDBuffer->lpVtbl->Blt(pgdev->lpDDBuffer,
                                        (RECT*) &pco->rclBounds,
                                        pgdev->lpDDPrimary,
                                        &rcWindow,
                                        DDBLT_WAIT,
                                        NULL);

    if (hr == DDERR_SURFACELOST)
    {
        DbgPrint("Lost!\n");
        pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
        goto Repeat1;
    }

    EngStrokePath(pgdev->psoBuffer, ppo, pco, pxlo, pbo, pptlBrush,
                  pla, mix);

    hr = pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                         &rcWindow,
                                         pgdev->lpDDBuffer,
                                         (RECT*) &pco->rclBounds,
                                         DDBLT_WAIT,
                                         NULL);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL GpsTextOut
*
\**************************************************************************/

BOOL GpsTextOut(
SURFOBJ*    pso,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclExtra,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque,
POINTL*     pptlOrg,
MIX         mix)
{
    GDEV*   pgdev;
    HRESULT hr;
    RECT    rcWindow;
    RECTL*  prclDraw;

Repeat1:

    pgdev = (GDEV*) pso->dhpdev;

    prclDraw = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    vGpsWindowOffset(pgdev, prclDraw, &rcWindow);

    hr = pgdev->lpDDBuffer->lpVtbl->Blt(pgdev->lpDDBuffer,
                                        (RECT*) prclDraw,
                                        pgdev->lpDDPrimary,
                                        &rcWindow,
                                        DDBLT_WAIT,
                                        NULL);

    if (hr == DDERR_SURFACELOST)
    {
        DbgPrint("Lost!\n");
        pgdev->lpDDPrimary->lpVtbl->Restore(pgdev->lpDDPrimary);
        goto Repeat1;
    }

    EngTextOut(pgdev->psoBuffer, pstro, pfo, pco, prclExtra, prclOpaque,
               pboFore, pboOpaque, pptlOrg, mix);

    hr = pgdev->lpDDPrimary->lpVtbl->Blt(pgdev->lpDDPrimary,
                                         &rcWindow,
                                         pgdev->lpDDBuffer,
                                         (RECT*) prclDraw,
                                         DDBLT_WAIT,
                                         NULL);

    return(TRUE);
}

/******************************Public*Structure****************************\
* DFVFN gadrvfnGdiPlus[]
*
\**************************************************************************/

DRVFN gadrvfnGdiPlus[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) GpsEnablePDEV            },
    {   INDEX_DrvCompletePDEV,          (PFN) GpsCompletePDEV          },
    {   INDEX_DrvDisablePDEV,           (PFN) GpsDisablePDEV           },
    {   INDEX_DrvEnableSurface,         (PFN) GpsEnableSurface         },
    {   INDEX_DrvDisableSurface,        (PFN) GpsDisableSurface        },
    {   INDEX_DrvCopyBits,              (PFN) GpsCopyBits              },
    {   INDEX_DrvBitBlt,                (PFN) GpsBitBlt                },
    {   INDEX_DrvStrokePath,            (PFN) GpsStrokePath            },
    {   INDEX_DrvTextOut,               (PFN) GpsTextOut               },
};

ULONG gcdrvfnGdiPlus = sizeof(gadrvfnGdiPlus) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL GpsEnableDriver
*
\**************************************************************************/

BOOL GpsEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    pded->pdrvfn         = gadrvfnGdiPlus;
    pded->c              = gcdrvfnGdiPlus;
    pded->iDriverVersion = DDI_DRIVER_VERSION;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\gdiplus\usermode.cxx ===
/******************************Module*Header*******************************\
* Module Name: usermode.cxx
*
* Copyright (c) 1998-1999 Microsoft Corporation
*
* This file contains all the system abstraction routines required to allow 
* GDI to run as a stand-alone graphics library in user-mode.  
*
* Created: 29-Apr-1998
* Author: J. Andrew Goossen [andrewgo]
*
\**************************************************************************/

#include "precomp.hxx"

extern "C" {
    BOOL gbRemoteSession=0;
}

// Temporary HDEV for first bringing up user-mode GDI+, which represents
// the screen 'device'.  This sure as heck had better be temporary!

HDEV ghdevDisplay;

// Copy of a drvsup.cxx structure that should really be moved to engine.h:

typedef struct _DRV_NAMES {
    ULONG            cNames;
    struct {
        HANDLE           hDriver;
        LPWSTR           lpDisplayName;
    } D[1];
} DRV_NAMES, *PDRV_NAMES;

HDEV hCreateHDEV(PGRAPHICS_DEVICE,PDRV_NAMES,PDEVMODEW,PVOID,BOOL,FLONG,HDEV*);

// Some random goop needed for linking user-mode GDI+:

extern "C" {
    PEPROCESS gpepCSRSS;
    ULONG gSessionId;
};

/*****************************Private*Routine******************************\
* BOOL GpInitialize
*
* History:
*  3-May-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

extern "C"
BOOL 
GpInitialize(
HWND hwnd)
{
    DRV_NAMES   drvName;
    HDEV        hdevDisabled;
    BOOL        bRet = FALSE;

    drvName.cNames             = 1;
    drvName.D[0].hDriver       = NULL;
    drvName.D[0].lpDisplayName = (LPWSTR)GpsEnableDriver;

    if (ghdevDisplay == NULL)
    {
        KdPrint(("hCreateDEV.................\n"));

        ghdevDisplay = hCreateHDEV(NULL,
                                   &drvName,
                                   ((PDEVMODEW)(hwnd)),
                                   NULL,
                                   TRUE, // ignored in this case
                                   GCH_GDIPLUS_DISPLAY,
                                   &hdevDisabled);

        bRet = (ghdevDisplay != NULL);
    }
    else
    {
        WARNING("Can't yet create multiple windows");
    }

    return(bRet);
}

/*****************************Private*Routine******************************\
* HDC UserGetDesktopDC
*
* History:
*  3-May-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HDC
UserGetDesktopDC(
ULONG   iType,
BOOL    bAltType,
BOOL    bValidate)
{
    HDC hdc = NULL;

    if ((iType == DCTYPE_DIRECT) && (bValidate))
    {
        if (ghdevDisplay != NULL)
        {
            hdc = GreCreateDisplayDC(ghdevDisplay, DCTYPE_DIRECT, bAltType);
        }
        else
        {
            WARNING("ghdevDisplay not initialized");
        }
    }
    else
    {
        WARNING("UserGetDesktopDC functionality not yet handled");
    }

    return(hdc);
}

/*****************************Private*Routine******************************\
* HDEV UserGetHDEV
*
\**************************************************************************/

HDEV
UserGetHDEV()
{
    return(ghdevDisplay);
}

/*****************************Private*Routine******************************\
* BOOL UserVisrgnFromHwnd
*
\**************************************************************************/

BOOL 
UserVisrgnFromHwnd(
HRGN*   phrgn,
HWND    hwnd)
{
    *phrgn = NULL;
    return(FALSE);
}

/*****************************Private*Routine******************************\
* DWORD GetAppCompatFlags
*
\**************************************************************************/

extern "C"
DWORD 
GetAppCompatFlags(
PVOID pv)
{
    return(0);
}

/*****************************Private*Routine******************************\
* VOID* pAllocMem
*
* Hack for screen.c header mess.
*
\**************************************************************************/

extern "C"
VOID*
pAllocMem(
ULONG   size,
ULONG   tag)
{
    return(PALLOCMEM(size, tag));
}

/*****************************Private*Routine******************************\
* VOID vFreeMem
*
* Hack for screen.c header mess.
*
\**************************************************************************/

extern "C"
VOID 
vFreeMem(
VOID*   p)
{
    VFREEMEM(p);
}


NTSTATUS
MapViewInProcessSpace(
    PVOID   pv,
    PVOID  *ppv,
    ULONG  *psize
    )

/*++

Routine Description:

    Map view of a file into current process' address space

Arguments:

    pv - Points to a MEMORY_MAPPED_FILE structure
    ppv - Return the base address of the mapped view
    psize - Return the size of the mapped view

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/

{
    MEMORY_MAPPED_FILE *mappedFile = (MEMORY_MAPPED_FILE *) pv;

    if (!mappedFile ||
        !mappedFile->fileMap ||
        !(*ppv = MapViewOfFile(mappedFile->fileMap,
                               mappedFile->readOnly ? FILE_MAP_READ : FILE_MAP_WRITE,
                               0,
                               0,
                               mappedFile->fileSize)))
    {
        WARNING("MapViewInProcessSpace failed\n");
        *ppv = NULL;
        *psize = 0;
        return STATUS_UNSUCCESSFUL;
    }

    *psize = mappedFile->fileSize;
    return STATUS_SUCCESS;
}


NTSTATUS
UnmapViewInProcessSpace(
    PVOID   pv
    )

/*++

Routine Description:

    Unmap view of a file from the current process' address space

Arguments:

    pv - Base address of the view to be unmapped

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/

{
    return UnmapViewOfFile(pv) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}


BOOL
CreateMemoryMappedSection(
    PWSTR     filename,
    FILEVIEW *fileview,
    INT       size
    )

/*++

Routine Description:

    Create a memory-mapped file structure

Arguments:

    filename - Specifies the name of the file to be mapped
    fileview - Return information about the memory-mapped file
    size - Size to be mapped
        0 : map entire content of an existing file for reading
        else : create a file of the specified size for reading & writing

Return Value:

    TRUE if successful, FALSE otherwise

--*/

#define SYSTEM32_STR    L"SYSTEM32"
#define SYSTEM32_LEN    8
#define SYSTEMROOT_STR  L"SYSTEMROOT"
#define SYSTEMROOT_LEN  10

{
    FILEVIEW fv;
    HANDLE fileHandle;
    MEMORY_MAPPED_FILE *mappedFile;
    BY_HANDLE_FILE_INFORMATION fileinfo;
    WCHAR fullpath[MAX_PATH];
    PWSTR p;

    ZeroMemory(&fv, sizeof(FILEVIEW));
    ZeroMemory(fileview, sizeof(FILEVIEW));

    //
    // Expand the input filename to fully qualified path
    //

    p = filename;

    while (*p && _wcsnicmp(p, SYSTEMROOT_STR, SYSTEMROOT_LEN))
        p++;

    if (*p)
    {
        if (GetWindowsDirectoryW(fullpath, MAX_PATH))
        {
            wcscat(fullpath, p + SYSTEMROOT_LEN);
            filename = fullpath;
        }
        else
        {
            WARNING("GetWindowsDirectory failed\n");
            return FALSE;
        }
    }
    else
    {
        p = filename;

        while (*p && _wcsnicmp(p, SYSTEM32_STR, SYSTEM32_LEN))
            p++;

        if (*p)
        {
            if (GetSystemDirectoryW(fullpath, MAX_PATH))
            {
                wcscat(fullpath, p + SYSTEM32_LEN);
                filename = fullpath;
            }
            else
            {
                WARNING("GetSystemDirectory failed\n");
                return FALSE;
            }
        }
    }

    //
    // Allocate memory for a MEMORY_MAPPED_FILE structure
    // (assume content is zero-initialized)
    //

    mappedFile = (MEMORY_MAPPED_FILE *) PALLOCMEM(sizeof(MEMORY_MAPPED_FILE), 'fmmG');

    if (mappedFile == NULL)
        return NULL;

    //
    // Open the file for reading or writing
    //

    if (size != 0)
    {
        mappedFile->readOnly = FALSE;

        fileHandle = CreateFileW(filename,
                                 GENERIC_READ|GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);
    }
    else
    {
        mappedFile->readOnly = TRUE;

        fileHandle = CreateFileW(filename,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL);
    }

    if (fileHandle == INVALID_HANDLE_VALUE)
        goto errorExit;

    //
    // Get timestamp information about the file
    //

    if (!GetFileInformationByHandle(fileHandle, &fileinfo))
        goto errorExit;

    fv.LastWriteTime.LowPart = fileinfo.ftLastWriteTime.dwLowDateTime;
    fv.LastWriteTime.HighPart = fileinfo.ftLastWriteTime.dwHighDateTime;

    //
    // If file was opened for writing, set it to requested size
    //

    if (size != 0)
    {
        if (size > 0)
            fileinfo.nFileSizeLow = (DWORD) size;

        fileinfo.nFileSizeHigh = 0;

        if (!SetFilePointer(fileHandle, fileinfo.nFileSizeLow, 0, FILE_BEGIN))
            goto errorExit;
    }

    if (fileinfo.nFileSizeHigh != 0)
        goto errorExit;

    mappedFile->fileSize = fv.cjView = fileinfo.nFileSizeLow;

    //
    // Create a file mapping handle
    //

    mappedFile->fileMap = CreateFileMapping(
                                fileHandle,
                                NULL,
                                mappedFile->readOnly ? PAGE_READONLY : PAGE_READWRITE,
                                0,
                                fileinfo.nFileSizeLow,
                                NULL);
    
    if (mappedFile->fileMap != NULL)
    {
        CloseHandle(fileHandle);
        fv.pSection = mappedFile;

        CopyMemory(fileview, &fv, sizeof(FILEVIEW));
        return TRUE;
    }

errorExit:

    WARNING("CreateMemoryMappedSection failed\n");

    if (fileHandle != INVALID_HANDLE_VALUE)
        CloseHandle(fileHandle);
    
    DeleteMemoryMappedSection(mappedFile);
    return FALSE;
}


VOID
DeleteMemoryMappedSection(
    PVOID pv
    )

/*++

Routine Description:

    Dispose of a memory-mapped file structure

Arguments:

    pv - Points to a MEMORY_MAPPED_FILE structure

Return Value:

    NONE

--*/

{
    MEMORY_MAPPED_FILE *mappedFile = (MEMORY_MAPPED_FILE *) pv;

    if (mappedFile != NULL)
    {
        if (mappedFile->fileMap != NULL)
            CloseHandle(mappedFile->fileMap);

        VFREEMEM(mappedFile);
    }
}


NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    PHANDLE KeyHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes
    )

{
    if (DesiredAccess == GENERIC_READ || DesiredAccess == 0)
        DesiredAccess = KEY_READ;
    
    return NtOpenKey(KeyHandle, DesiredAccess, ObjectAttributes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\gdiplus\usermode.h ===
/******************************Module*Header*******************************\
* Module Name: usermode.h
*
* This file contains all the system abstraction definitions required to allow 
* GDI to run as a stand-alone graphics library in user-mode.  
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#include <nturtl.h>
#include <winbase.h>
#include <winnls.h>

// Prototype for GDI+ virtual screen driver entry point:

BOOL GpsEnableDriver(ULONG, ULONG, DRVENABLEDATA*);

// User-mode GDI doesn't require any security probing:

#undef ProbeForRead
#undef ProbeForWrite
#undef ProbeAndReadStructure
#undef ProbeAndWriteStructure
#undef ProbeAndReadUlong
#undef ProbeAndWriteUlong

#define ProbeForRead(a, b, c) 0
#define ProbeForWrite(a, b, c) 0
#define ProbeAndReadStructure(a, b) (*(b *)(a))
#define ProbeAndWriteStructure(a, b, c) (*(a) = (b))
#define ProbeAndReadUlong(a) (*(ULONG *)(a))
#define ProbeAndWriteUlong(a, b) (*(a) = (b))

#undef IS_SYSTEM_ADDRESS
#undef MM_LOWEST_USER_ADDRESS
#undef MM_HIGHEST_USER_ADDRESS
#undef MM_USER_PROBE_ADDRESS
#define MM_LOWEST_USER_ADDRESS NULL
#define MM_HIGHEST_USER_ADDRESS ((VOID*) 0xffffffff)
#define MM_USER_PROBE_ADDRESS 0xffffffff

#define ExSystemExceptionFilter() EXCEPTION_EXECUTE_HANDLER

// The following are not needed for user-mode GDI:

#define KeSaveFloatingPointState(a) STATUS_SUCCESS
#define KeRestoreFloatingPointState(a) STATUS_SUCCESS

#define UserScreenAccessCheck() TRUE
#define UserGetHwnd(a, b, c, d) 0
#define UserAssertUserCritSecOut()
#define UserEnterUserCritSec()
#define UserLeaveUserCritSec()
#define UserIsUserCritSecIn() 0
#define UserAssertUserCritSecIn()
#define UserRedrawDesktop()
#define UserReleaseDC(a)
#define UserGetClientRgn(a, b, c) 0
#define UserAssociateHwnd(a, b)
#define UserSetTimer(a,b) 1
#define UserKillTimer(a) 

#define ClientPrinterThunk(a, b, c, d) 0xffffffff

#define AlignRects(a, b, c, d) 0

#define IofCallDriver(a, b) STATUS_UNSUCCESSFUL
#define IoBuildSynchronousFsdRequest(a, b, c, d, e, f, g) 0
#define IoInitializeIrp(a, b, c) 
#define IoBuildDeviceIoControlRequest(a, b, c, d, e, f, g, h, i) 0
#define IoBuildAsynchronousFsdRequest(a, b, c, d, e, f) 0
#define IoGetRelatedDeviceObject(a) 0
#define IoReadOperationCount 0
#define IoWriteOperationCount 0
#define IoQueueThreadIrp(a)
#define IoFreeIrp(a)
#define IoAllocateMdl(a, b, c, d, e) 0
#define IoFreeMdl(a)
#define IoAllocateIrp(a, b) 0
#define IoGetDeviceObjectPointer(a, b, c, d) STATUS_UNSUCCESSFUL
#define IoOpenDeviceRegistryKey(a, b, c, d) STATUS_UNSUCCESSFUL
#define IoGetRelatedDeviceObject(a) 0

#define ObOpenObjectByPointer(a, b, c, d, e, f, g) STATUS_UNSUCCESSFUL
#define ObReferenceObjectByHandle(a, b, c, d, e, f) STATUS_UNSUCCESSFUL
#define ObfDereferenceObject(a) STATUS_UNSUCCESSFUL

#define MmResetDriverPaging(a)
#define MmGrowKernelStack(a) STATUS_SUCCESS
#define MmQuerySystemSize() MmMediumSystem

#undef KeEnterCriticalRegion
#undef KeLeaveCriticalRegion
#define KeEnterCriticalRegion()
#define KeLeaveCriticalRegion()
#define KeInitializeSpinLock(a)
#define KeInitializeDpc(a, b, c)
#define KeGetCurrentIrql() PASSIVE_LEVEL
#define KeSetKernelStackSwapEnable(a) 0
#define KeResetEvent(a)

#undef SeStopImpersonatingClient
#undef SeDeleteClientSecurity
#define SeStopImpersonatingClient()
#define SeDeleteClientSecurity(a)
#define SeImpersonateClientEx(a, b) STATUS_UNSUCCESSFUL
#define SeCreateClientSecurity(a, b, c, d) STATUS_UNSUCCESSFUL

#define Win32UserProbeAddress 0
#define HalRequestSoftwareInterrupt(x) 0         

#undef W32GetCurrentPID
#define W32GetCurrentPID() ((W32PID) NtCurrentTeb()->ClientId.UniqueProcess)

#undef W32GetCurrentProcess
__inline PW32PROCESS W32GetCurrentProcess() { return(NULL); }

#undef PsGetCurrentProcess
__inline PEPROCESS PsGetCurrentProcess() { return(NULL); }

// Re-route all the memory allocations:

#define ExAllocatePoolWithTag(type, size, tag)  \
                        RtlAllocateHeap(RtlProcessHeap(), 0, (size))
#define ExFreePool(p)   RtlFreeHeap(RtlProcessHeap(), 0, (p))

#define ExDeletePagedLookasideList(a)

// Give up our time-slice when KeDelayExecutionThread called:                        

#define KeDelayExecutionThread(a, b, c) Sleep(0)

// @@@ The following are temporary (I hope!)

#undef W32GetCurrentTID
#undef W32GetCurrentThread
__inline PW32THREAD W32GetCurrentThread() { return(NULL); }     // @@@
#define W32GetCurrentTID (W32PID) 0 // @@@

#define ExIsProcessorFeaturePresent(a) 0              


/*
   comma expressions don't work in free builds since
   WARNING(x) and RIP(x) expand to nothing.
*/

#if DBG

#define IS_SYSTEM_ADDRESS(a) (RIP("IS_SYTEM_ADDRESS"), 0)


#define MmSecureVirtualMemory(x, y, z) \
            (WARNING("@@@ MmSecureVirtualMemory"), (HANDLE) 1)
#define MmUnsecureVirtualMemory(x)

#define KeAttachProcess(x) \
            (WARNING("@@@ KeAttachProcess"), STATUS_UNSUCCESSFUL)
#define KeDetachProcess() STATUS_UNSUCCESSFUL

#undef KeInitializeEvent

#define KeInitializeEvent(a, b, c) \
            (WARNING("@@@ KeInitializeEvent"), STATUS_UNSUCCESSFUL)
#define KeSetEvent(a, b, c) \
            (RIP("KeSetEvent"), STATUS_UNSUCCESSFUL)
#define KeWaitForSingleObject(a, b, c, d, e) \
            (RIP("KeWaitForSingleObject"), STATUS_UNSUCCESSFUL)
#define KeWaitForMultipleObjects(a, b, c, d, e, f, g, h) \
                (RIP("KeWaitForMultipleObjects"), STATUS_UNSUCCESSFUL)


#define MmMapViewOfSection(a, b, c, d, e, f, g, h, i, j) \
            (RIP("MmMapViewOfSection"), STATUS_UNSUCCESSFUL)
#define MmUnmapViewOfSection(a, b) STATUS_UNSUCCESSFUL
#define MmMapViewInSessionSpace(a, b, c) \
            (RIP("MmMapViewInSessionSpace"), STATUS_UNSUCCESSFUL)
#define MmUnmapViewInSessionSpace(a) STATUS_UNSUCCESSFUL
#define MmCreateSection(a, b, c, d, e, f, g, h) \
            (RIP("MmCreateSection"), STATUS_UNSUCCESSFUL)


#else // !DBG

#define IS_SYSTEM_ADDRESS(a) 0


#define MmSecureVirtualMemory(x, y, z) ((HANDLE) 1)
#define MmUnsecureVirtualMemory(x)

#define KeAttachProcess(x) STATUS_UNSUCCESSFUL
#define KeDetachProcess() STATUS_UNSUCCESSFUL

#undef KeInitializeEvent

#define KeInitializeEvent(a, b, c) STATUS_UNSUCCESSFUL
#define KeSetEvent(a, b, c) STATUS_UNSUCCESSFUL
#define KeWaitForSingleObject(a, b, c, d, e) STATUS_UNSUCCESSFUL
#define KeWaitForMultipleObjects(a, b, c, d, e, f, g, h) STATUS_UNSUCCESSFUL


#define MmMapViewOfSection(a, b, c, d, e, f, g, h, i, j) STATUS_UNSUCCESSFUL
#define MmUnmapViewOfSection(a, b) STATUS_UNSUCCESSFUL
#define MmMapViewInSessionSpace(a, b, c) STATUS_UNSUCCESSFUL
#define MmUnmapViewInSessionSpace(a) STATUS_UNSUCCESSFUL
#define MmCreateSection(a, b, c, d, e, f, g, h) STATUS_UNSUCCESSFUL

#endif // !DBG


            __inline LARGE_INTEGER KeQueryPerformanceCounter(
PLARGE_INTEGER PerformanceFrequency)
{
    LARGE_INTEGER li = { 0, 0 };
    return(li);
}

#define RtlGetDefaultCodePage(a, b) \
        { \
            *(a) = (USHORT) GetACP(); \
            *(b) = (USHORT) GetOEMCP(); \
        }

typedef struct _MEMORY_MAPPED_FILE
{
    HANDLE  fileMap;
    DWORD   fileSize;
    BOOL    readOnly;
} MEMORY_MAPPED_FILE;

NTSTATUS MapViewInProcessSpace(PVOID, PVOID*, ULONG*);
NTSTATUS UnmapViewInProcessSpace(PVOID);
BOOL CreateMemoryMappedSection(PWSTR, FILEVIEW*, INT);
VOID DeleteMemoryMappedSection(PVOID);

NTSYSAPI
NTSTATUS
NTAPI
ZwCloseKey(
    HANDLE Handle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\glyphout.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: line.asm
;
; Transparent and Opaque output for 1Bpp to 1Bpp drawing
;
; Created: 24-Aug-1994
; Author: Mark Enstrom
;
; Copyright (c) 1994-1999 Microsoft Corporation
;-----------------------------------------------------------------------;


        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include gdii386.inc
        include line.inc

spt_lEndOffset  equ 000H
spt_ulEndMask   equ 004H
spt_ulStartMask equ 008H
spt_ebp         equ 00CH
spt_esi         equ 010H
spt_edi         equ 014H
spt_ebx         equ 018H
spt_ulRetAddr   equ 01CH
spt_pjSrcIn     equ 020H
spt_SrcLeft     equ 024H
spt_DeltaSrcIn  equ 028H
spt_pjDstIn     equ 02CH
spt_DstLeft     equ 030H
spt_DstRight    equ 034H
spt_DeltaDstIn  equ 038H
spt_cy          equ 03CH
spt_uF          equ 040H
spt_uB          equ 044H
spt_pS          equ 048H

        .list



;------------------------------------------------------------------------------;

        .code


_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING



;------------------------------------------------------------------------------;

;------------------------------------------------------------------------------;
; vSrcTranCopyS1D1
;
;   Transparent copy from 1Bpp to 1Bpp (DWORD ALIGNED)
;
; Entry:
;
;   pjSrcIn
;   SrcLeft
;   DeltaSrcIn
;   pjDstIn
;   DstLeft
;   DstRight
;   DeltaDstIn
;   cy
;   uF
;   uB
;   pS
;
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

        public vSrcTranCopyS1D1@44

vSrcTranCopyS1D1@44 proc near

        ;
        ;  use ebp as general register, use esp for parameter and local access
        ;  save ebp,ebx,esi,edi

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,3 * 4

        ;
        ;  Start and end cases and masks. Start case is the first partial
        ;  DWORD (if needed) and end case is the last partial DWORD (if needed)
        ;

        mov     ecx,spt_DstLeft[esp]            ; Left (startint Dst Location)
        sub     edi,edi                         ; zero
        not     edi                             ; flag = 0xffffff
        mov     esi,edi                         ; flag = 0xffffff
        and     ecx,01Fh                        ; DstLeftAln,if 0 then don't make mask
        jz      @F

        ;
        ; ulStartMask >>= lStartCase, shift ulStartMask right by starting alignment,
        ; then BSWAP this back to little endian
        ;

        shr     edi,cl                          ; ulStartMask >> lStartCase
        ror     di,8                            ; 0 1 2 3 -> 0 1 3 2
        ror     edi,16                          ; 0 1 3 2 -> 3 2 0 1
        ror     di,8                            ; 3 2 0 1 -> 3 2 1 0
@@:
        mov     eax,spt_DstRight[esp]           ; right (last pixel)
        and     eax,01Fh                        ; DstRightAln = DstRight & 0x1F
        jz      @F                              ; if 0, mask = 0xffffffff

        ;
        ; ulEndMask = 0xFFFFFF << ( 32 - lEndCase). Shift big endian 0xFFFFFF left
        ; by lEndCase, then BSWAP
        ;

        mov     ecx,32                          ; shift 32 - lEndCase
        sub     ecx,eax                         ; 32 - lEndCase
        shl     esi,cl                          ; ulEndMask << lEndCase
        ror     si,8                            ; 0 1 2 3 -> 0 1 3 2
        ror     esi,16                          ; 0 1 3 2 -> 3 2 0 1
        ror     si,8                            ; 3 2 0 1 -> 3 2 1 0
@@:
        mov     spt_ulStartMask[esp],edi        ; save
        mov     spt_ulEndMask[esp],esi          ; save

        ;
        ; check for transparent 1 or transparent 0 foreground color
        ;

        test    spt_uF[esp],1
        jz      Trans1to1Invert

        ;
        ; calculate the number of full dwords to copy
        ;
        ; Full DWORDS = (DstRight >> 5) - ((DstLeft + 31) >> 5)
        ;

        mov     eax,spt_DstLeft[esp]            ; Left (startint Dst Location)
        mov     ebx,spt_DstRight[esp]           ; right (last pixel)
        add     eax,31                          ; DstLeft + 31
        shr     ebx,5                           ; DstRight >> 5
        shr     eax,5                           ; (DstLeft+31) >> 5

        ;
        ; if <= 0, then no full DWORDS need to be copied, go to end cases
        ;

        sub     ebx,eax                         ; RightDW - LeftDw
        jle     Tran1to1Partial

        mov     spt_lEndOffset[esp],ebx         ; save

        ;
        ; calc starting Dst Address = pjDstIn + (((DstLeft+31) >> 5) << 2)
        ; calc starting Src Address = pjSrcIn + (((SrcLeft + 31) >> 5) << 2)
        ;

        mov     edi,spt_pjDstIn[esp]
        mov     esi,spt_pjSrcIn[esp]
        mov     ebx,spt_SrcLeft[esp]            ; SrcLeft
        add     ebx,31                          ; SrcLeft + 31
        shr     ebx,5                           ; (SrcLeft + 31) >> 5
        lea     edi,[edi + 4 * eax]             ; pjDstIn + (((DstLeft+31) >> 5) * 4
        lea     esi,[esi + 4 * ebx]             ; pjSrcIn + ((SrcLeft + 31) >> 5) * 4

        ;
        ; save scan line addresses
        ;

        mov     edx,spt_cy[esp]                 ; keep track of # of scan lines

Tran1to1DwordLoop:

        ;
        ; DWORD loop
        ;

        mov     eax,spt_lEndOffset[esp]         ; get inner loop count
@@:
        ;
        ; read and write 1 DWORD
        ;

        mov     ebx,[4 * eax - 4 + esi]         ; load dw 0
        or      [4 * eax - 4 + edi],ebx         ; store dw 0

        dec     eax                             ; dec dword count
        jnz     @B                              ; loop until done

Tran1to1DwordLoopComplete:

        ;
        ; done with scan line, add strides
        ;

        add     edi,spt_DeltaDstIn[esp]         ; pjDst += DeltaDst
        add     esi,spt_DeltaSrcIn[esp]         ; pjSrc += DeltaSrc

        ;
        ; dec and check cy
        ;

        dec     edx                             ; cy--
        jne     Tran1to1DwordLoop


Tran1to1Partial:

        ;
        ; handle partial DWORD blts. first the start case, which may be the
        ; left edge or it may be a combined DWORD left and right, in which
        ; case the start and end masks are just anded together
        ;

        mov     eax,spt_DstLeft[esp]            ; left position
        and     eax,01Fh                        ; left edge pixels
        je      Tran1to1RightEdge               ; if zero, no left edge

        ;
        ; There is a left edge, are right and left DWORDS the same
        ;

        mov     ebx,spt_DstLeft[esp]            ; left position
        mov     edx,spt_DstRight[esp]           ; right edge
        mov     ecx,-32                         ; ~0x1F   - dword address alignment
        and     ebx,ecx                         ; DstLeft  & ~0x1F
        and     edx,ecx                         ; DstRight & ~0x1F

        mov     ecx,spt_ulStartMask[esp]        ; get start start mask

        cmp     edx,ebx                         ; if equal, start and stop
        jne     @F                              ; in same DWORD

        ;
        ; left and right are same src DWORD, combine masks, then
        ; set right edge to 0 so Tran1to1RightEdge won't run
        ;

        and     ecx,spt_ulEndMask[esp]          ; combine with start mask
        mov     spt_DstRight[esp],0             ; save 0
@@:
        ;
        ; calc left edge starting addresses
        ;
        ;       pjDst = pjDstIn + ((DstLeft >> 5) << 2)
        ;       pjSrc = pjSrcIn + ((SrcLeft >> 5) << 2)
        ;

        mov     eax,spt_DstLeft[esp]            ; load
        mov     ebx,spt_SrcLeft[esp]            ; load
        shr     eax,5                           ; DstLeft >> 3
        shr     ebx,5                           ; SrcLeft >> 3
        mov     edi,spt_pjDstIn[esp]            ; load dst addr
        mov     esi,spt_pjSrcIn[esp]            ; load src addr
        lea     edi,[edi + 4*eax]               ; dest address
        lea     esi,[esi + 4*ebx]               ; src address
        mov     ebp,spt_DeltaSrcIn[esp]         ; scr scan line stride
        mov     ebx,spt_DeltaDstIn[esp]         ; dst scan line stride
        mov     edx,spt_cy[esp]                 ; loop count

        ;
        ; unroll loop 2 times, this requires address fix-up
        ;

        sub     edi,ebx                         ; fix-up for odd cycle
        sub     esi,ebp                         ; fix-up for odd cycle

        add     edx,1                           ; offset for unrolling
        shr     edx,1                           ; 2 times through loop
        jnc     Tran1to1LeftEdgeOdd             ; do first "odd" dword

        add     edi,ebx                         ; un-fix-up for even cycle
        add     esi,ebp                         ; un-fix-up for even cycle

@@:
        mov     eax,[esi]                       ; load src
        and     eax,ecx                         ; mask
        or      [edi],eax                       ; store

Tran1to1LeftEdgeOdd:

        mov     eax,[esi + ebp]                 ; load src
        and     eax,ecx                         ; mask
        or      [edi + ebx],eax                 ; store

        lea     esi,[esi][ebp*2]                ; src += 2 * DeltaSrc
        lea     edi,[edi][ebx*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; loop count
        jnz     @b                              ;

        ;
        ; done with left edge
        ;

Tran1to1RightEdge:

        ;
        ; right edge, check DstRight[4:0] for pixels on the right edge
        ;

        mov     eax,spt_DstRight[esp]           ; load
        and     eax,01Fh                        ; are there right edge pixels
        jz      EndTran1to1

        ;
        ; there are right edge pixels to draw, calc pjSrc and pjDst
        ;
        ; pjDst = pjDstIn + ((DstRight >> 5) << 2)
        ; pjSrc = pjSrcIn + (((SrcLeft + (DstRight - DstLeft)) >> 5) << 2)
        ;

        mov     ebx,spt_DstRight[esp]           ; DstRight
        mov     ecx,spt_DstLeft[esp]            ; load DstLeft
        mov     eax,spt_SrcLeft[esp]            ; load SrcLeft
        mov     edx,ebx                         ; edi = DstRight
        sub     ebx,ecx                         ; (DstRight - DstLeft)
        add     eax,ebx                         ; SrcLeft + (DstRight - DstLeft)
        shr     edx,5                           ; DstRight >> 5
        shr     eax,5                           ; Src Offset >> 5
        mov     edi,spt_pjDstIn[esp]            ;
        mov     esi,spt_pjSrcIn[esp]            ;
        lea     edi,[edi + 4*edx]               ; pjDstIn + DstOffset
        lea     esi,[esi + 4*eax]               ; pjSrcIn + SrcOffset

        mov     ecx,spt_ulEndMask[esp]          ; load end mask
        mov     ebx,spt_DeltaSrcIn[esp]         ; src scan line inc
        mov     ebp,spt_DeltaDstIn[esp]         ; dst scan line inc
        mov     edx,spt_cy[esp]                 ; loop count

        ;
        ; unroll loop 2 times, fix up address for odd cycle
        ;

        sub     edi,ebp                         ; fix-up for odd cycle
        sub     esi,ebx                         ; fix-up for odd cycle

        add     edx,1                           ; offset for 2 times unrolling
        shr     edx,1                           ; LoopCount / 2
        jnc     Tran1to1RightEdgeOdd            ; do single "odd" DWORD

        add     edi,ebp                         ; un-fix-up for odd cycle
        add     esi,ebx                         ; un-fix-up for odd cycle

@@:
        mov     eax,[esi]                       ; load src dword
        and     eax,ecx                         ; mask
        or      [edi],eax                       ; or in src

Tran1to1RightEdgeOdd:

        mov     eax,[esi+ebx]                   ; load src dword
        and     eax,ecx                         ; mask
        or      [edi+ebp],eax                   ; or in src

        lea     esi,[esi][ebx*2]                ; src += 2 * DeltaSrc
        lea     edi,[edi][ebp*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; dec loop count
        jnz     @B                              ; and loop until zero

        jmp     EndTran1to1

        ;
        ; transparent invert (uF = 0)
        ;


Trans1to1Invert:

        ;
        ; Transparent text where the foreground color is 0, must invert the
        ; src DWORD and then and it onto the dest.
        ;

        ;
        ; calculate the number of full dwords to copy
        ;
        ; Full DWORDS = (DstRight >> 5) - ((DstLeft + 31) >> 5)
        ;

        mov     eax,spt_DstLeft[esp]            ; Left (startint Dst Location)
        mov     ebx,spt_DstRight[esp]           ; right (last pixel)
        add     eax,31                          ; DstLeft + 31
        shr     ebx,5                           ; DstRight >> 5
        shr     eax,5                           ; (DstLeft+31) >> 5

        ;
        ; if <= 0, then no full DWORDS need to be copied, go to end cases
        ;

        sub     ebx,eax                         ; RightDW - LeftDw
        jle     Tran1to1PartialInvert

        mov     spt_lEndOffset[esp],ebx         ; save

        ;
        ; calc starting Dst Address = pjDstIn + (((DstLeft+31) >> 5) << 2)
        ; calc starting Src Address = pjSrcIn + (((SrcLeft + 31) >> 5) << 2)
        ;

        mov     edi,spt_pjDstIn[esp]
        mov     esi,spt_pjSrcIn[esp]
        mov     ebx,spt_SrcLeft[esp]            ; SrcLeft
        add     ebx,31                          ; SrcLeft + 31
        shr     ebx,5                           ; (SrcLeft + 31) >> 5
        lea     edi,[edi + 4 * eax]             ; pjDstIn + (((DstLeft+31) >> 5) * 4
        lea     esi,[esi + 4 * ebx]             ; pjSrcIn + ((SrcLeft + 31) >> 5) * 4

        ;
        ; save scan line addresses
        ;

        mov     edx,spt_cy[esp]                 ; keep track of # of scan lines

Tran1to1DwordLoopInvert:

        ;
        ; DWORD loop
        ;

        mov     eax,spt_lEndOffset[esp]         ; get inner loop count

@@:
        ;
        ; read and write 1 DWORD
        ;

        mov     ebx,[4 * eax - 4 + esi]         ; load dw 0
        not     ebx                             ; invert
        and     [4 * eax - 4 + edi],ebx         ; store dw 0

        dec     eax                             ; dec dword count
        jnz     @B                              ; loop until done

Tran1to1DwordLoopCompleteInvert:

        ;
        ; done with scan line, add strides
        ;

        add     edi,spt_DeltaDstIn[esp]         ; pjDst += DeltaDst
        add     esi,spt_DeltaSrcIn[esp]         ; pjSrc += DeltaSrc

        ;
        ; dec and check cy
        ;

        dec     edx                             ; cy--
        jne     Tran1to1DwordLoopInvert


Tran1to1PartialInvert:

        ;
        ; handle partial DWORD blts. first the start case, which may be the
        ; left edge or it may be a combined DWORD left and right, in which
        ; case the start and end masks are just anded together
        ;

        mov     eax,spt_DstLeft[esp]            ; left position
        and     eax,01Fh                        ; left edge pixels
        je      Tran1to1RightEdgeInvert         ; if zero, no left edge

        ;
        ; There is a left edge, are right and left DWORDS the same
        ;

        mov     ebx,spt_DstLeft[esp]            ; left position
        mov     edx,spt_DstRight[esp]           ; right edge
        mov     ecx,-32                         ; ~0x1F   - dword address alignment
        and     ebx,ecx                         ; DstLeft  & ~0x1F
        and     edx,ecx                         ; DstRight & ~0x1F

        mov     ecx,spt_ulStartMask[esp]        ; get start start mask

        cmp     edx,ebx                         ; if equal then start and end
        jne     @F                              ; in same DWORD

        ;
        ; left and right are same src DWORD, combine masks, then
        ; set right edge to 0 so Tran1to1RightEdge won't run
        ;

        and     ecx,spt_ulEndMask[esp]          ; combine with start mask
        mov     spt_DstRight[esp],0             ; save 0
@@:
        ;
        ; calc left edge starting addresses
        ;
        ;       pjDst = pjDstIn + ((DstLeft >> 5) << 2)
        ;       pjSrc = pjSrcIn + ((SrcLeft >> 5) << 2)
        ;

        mov     eax,spt_DstLeft[esp]            ; load
        mov     ebx,spt_SrcLeft[esp]            ; load
        shr     eax,5                           ; DstLeft >> 3
        shr     ebx,5                           ; SrcLeft >> 3
        mov     edi,spt_pjDstIn[esp]            ; load dst addr
        mov     esi,spt_pjSrcIn[esp]            ; load src addr
        lea     edi,[edi + 4*eax]               ; dest address
        lea     esi,[esi + 4*ebx]               ; src address
        mov     ebp,spt_DeltaSrcIn[esp]         ; scr scan line stride
        mov     ebx,spt_DeltaDstIn[esp]         ; dst scan line stride
        mov     edx,spt_cy[esp]                 ; loop count

        ;
        ; unroll left edge loop 2 times, this requires address fix-up
        ;

        sub     edi,ebx                         ; fix-up for odd cycle
        sub     esi,ebp                         ; fix-up for odd cycle

        add     edx,1                           ; offset for unrolling
        shr     edx,1                           ; 2 times through loop
        jnc     Tran1to1LeftEdgeOddInvert       ; do first "odd" dword

        add     edi,ebx                         ; un-fix-up for even cycle
        add     esi,ebp                         ; un-fix-up for even cycle

@@:
        mov     eax,[esi]                       ; load src
        and     eax,ecx                         ; mask
        not     eax                             ; invert
        and     [edi],eax                       ; store

Tran1to1LeftEdgeOddInvert:

        mov     eax,[esi + ebp]                 ; load src
        and     eax,ecx                         ; mask
        not     eax                             ; invert
        and     [edi + ebx],eax                 ; store

        lea     esi,[esi][ebp*2]                ; src += 2 * DeltaSrc
        lea     edi,[edi][ebx*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; loop count
        jnz     @b                              ;

        ;
        ; done with left edge
        ;

Tran1to1RightEdgeInvert:

        ;
        ; right edge, check DstRight[4:0] for pixels on the right edge
        ;

        mov     eax,spt_DstRight[esp]           ; load
        and     eax,01Fh                        ; are there right edge pixels
        jz      EndTran1to1

        ;
        ; there are right edge pixels to draw, calc pjSrc and pjDst
        ;
        ; pjDst = pjDstIn + ((DstRight >> 5) << 2)
        ; pjSrc = pjSrcIn + (((SrcLeft + (DstRight - DstLeft)) >> 5) << 2)
        ;

        mov     ebx,spt_DstRight[esp]           ; DstRight
        mov     ecx,spt_DstLeft[esp]            ; load DstLeft
        mov     eax,spt_SrcLeft[esp]            ; load SrcLeft
        mov     edx,ebx                         ; edi = DstRight
        sub     ebx,ecx                         ; (DstRight - DstLeft)
        add     eax,ebx                         ; SrcLeft + (DstRight - DstLeft)
        shr     edx,5                           ; DstRight >> 5
        shr     eax,5                           ; Src Offset >> 5
        mov     edi,spt_pjDstIn[esp]            ;
        mov     esi,spt_pjSrcIn[esp]            ;
        lea     edi,[edi + 4*edx]               ; pjDstIn + DstOffset
        lea     esi,[esi + 4*eax]               ; pjSrcIn + SrcOffset

        mov     ecx,spt_ulEndMask[esp]          ; load end mask
        mov     ebx,spt_DeltaSrcIn[esp]         ; src scan line inc
        mov     ebp,spt_DeltaDstIn[esp]         ; dst scan line inc
        mov     edx,spt_cy[esp]                 ; loop count

        ;
        ; unroll right edge loop 2 times. This requires address fix-up
        ;

        sub     esi,ebx                         ; fix-up address for odd cycle
        sub     edi,ebp                         ; fix-up address for odd cycle

        add     edx,1                           ; offset for 2 times unrolling
        shr     edx,1                           ; LoopCount / 2
        jnc     Tran1to1RightEdgeOddInvert      ; do single "odd" DWORD

        add     esi,ebx                         ; fix-up address for odd cycle
        add     edi,ebp                         ; fix-up address for odd cycle

@@:
        mov     eax,[esi]                       ; load src dword
        and     eax,ecx                         ; mask
        not     eax                             ; invert
        and     [edi],eax                       ; or in src

Tran1to1RightEdgeOddInvert:

        mov     eax,[esi+ebx]                   ; load src dword
        and     eax,ecx                         ; mask
        not     eax                             ; invert
        and     [edi+ebp],eax                   ; or in src

        lea     esi,[esi][ebx*2]                ; src += 2 * DeltaSrc
        lea     edi,[edi][ebp*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; dec loop count
        jnz     @B                              ; and loop until zero

        ;
        ; done!
        ;

EndTran1to1:

        add     esp,3*4
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     44

vSrcTranCopyS1D1@44 endp

spo_tMask       equ 000H
spo_lXorMask    equ 004H
spo_lEndOffset  equ 008H
spo_ulEndMask   equ 00CH
spo_ulStartMask equ 010H
spo_ebp         equ 014H
spo_esi         equ 018H
spo_edi         equ 01CH
spo_ebx         equ 020H
spo_ulRetAddr   equ 024H
spo_pjSrcIn     equ 028H
spo_SrcLeft     equ 02CH
spo_DeltaSrcIn  equ 030H
spo_pjDstIn     equ 034H
spo_DstLeft     equ 038H
spo_DstRight    equ 03CH
spo_DeltaDstIn  equ 040H
spo_cy          equ 044H
spo_uF          equ 048H
spo_uB          equ 04CH
spo_pS          equ 050H

;
;---------------------------Private-Routine-----------------------------;
; vSrcOpaqCopyS1D1
;
;   Opaque copy from 1Bpp to 1Bpp (DWORD ALIGNED)
;
; Entry:
;
;   pjSrcIn
;   SrcLeft
;   DeltaSrcIn
;   pjDstIn
;   DstLeft
;   DstRight
;   DeltaDstIn
;   cy
;   uF
;   uB
;   pS
;
;
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;-----------------------------------------------------------------------;

        public vSrcOpaqCopyS1D1@44

vSrcOpaqCopyS1D1@44 proc near

        ;
        ; opaque expansion requires a check for masking, if
        ; uF and uB are the same color, then the and mask is set to
        ; 0, this really means the src is ignored. The and mask is
        ; set to 0xFFFFFFFF if the uF = 0, this causes an inversion
        ; from src to dst.
        ;
        ; This routine is split into 2 sections, section 1 has an and
        ; mask value of 0xFFFFFFFF, so it is ignored. Section 2 has an
        ; and mask value if 0, so no src needs to be read.
        ;
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp
        sub     esp,5*4

        mov     spo_lXorMask[esp],0

        test    spo_uF[esp],1
        jnz     @F
        mov     spo_lXorMask[esp],0FFFFFFFFh
@@:

        ;
        ;  Start and end cases and masks. Start case is the first partial
        ;  DWORD (if needed) and end case is the last partial DWORD (if needed)
        ;

        mov     ecx,spo_DstLeft[esp]            ; Left (startint Dst Location)
        sub     edi,edi                         ; zero
        not     edi                             ; flag = 0xffffff
        mov     esi,edi                         ; flag = 0xffffff
        and     ecx,01Fh                        ; DstLeftAln,if 0 then don't make mask
        jz      @F

        ;
        ; ulStartMask >>= lStartCase, shift ulStartMask right by starting alignment,
        ; then BSWAP this back to little endian
        ;

        shr     edi,cl                          ; ulStartMask >> lStartCase
        ror     di,8                            ; 0 1 2 3 -> 0 1 3 2
        ror     edi,16                          ; 0 1 3 2 -> 3 2 0 1
        ror     di,8                            ; 3 2 0 1 -> 3 2 1 0
@@:
        mov     eax,spo_DstRight[esp]           ; right (last pixel)
        and     eax,01Fh                        ; DstRightAln = DstRight & 0x1F
        jz      @F                              ; if 0, mask = 0xffffffff

        ;
        ; ulEndMask = 0xFFFFFF << ( 32 - lEndCase). Shift big endian 0xFFFFFF left
        ; by lEndCase, then BSWAP
        ;

        mov     ecx,32                          ; shift 32 - lEndCase
        sub     ecx,eax                         ; 32 - lEndCase
        shl     esi,cl                          ; ulEndMask << lEndCase
        ror     si,8                            ; 0 1 2 3 -> 0 1 3 2
        ror     esi,16                          ; 0 1 3 2 -> 3 2 0 1
        ror     si,8                            ; 3 2 0 1 -> 3 2 1 0
@@:
        mov     spo_ulStartMask[esp],edi        ; save
        mov     spo_ulEndMask[esp],esi          ; save

        ;
        ; check for uF == uB, if so then branch to second section of routine
        ;

        mov     eax,spo_uF[esp]
        cmp     eax,spo_uB[esp]
        jz      Opaq1to1NoSrc

        ;
        ; calculate the number of full dwords to copy
        ;
        ; Full DWORDS = (DstRight >> 5) - ((DstLeft + 31) >> 5)
        ;

        mov     eax,spo_DstLeft[esp]            ; Left (startint Dst Location)
        mov     ebx,spo_DstRight[esp]           ; right (last pixel)
        add     eax,31                          ; DstLeft + 31
        shr     ebx,5                           ; DstRight >> 5
        shr     eax,5                           ; (DstLeft+31) >> 5

        ;
        ; if <= 0, then no full DWORDS need to be copied, go to end cases
        ;

        sub     ebx,eax                         ; RightDW - LeftDw
        jle     Opaq1to1Partial

        mov     spo_lEndOffset[esp],ebx         ; save

        ;
        ; calc starting Dst Address = pjDstIn + (((DstLeft+31) >> 5) << 2)
        ; calc starting Src Address = pjSrcIn + (((SrcLeft + 31) >> 5) << 2)
        ;

        mov     edi,spo_pjDstIn[esp]
        mov     esi,spo_pjSrcIn[esp]
        mov     ebx,spo_SrcLeft[esp]            ; SrcLeft
        add     ebx,31                          ; SrcLeft + 31
        shr     ebx,5                           ; (SrcLeft + 31) >> 5
        lea     edi,[edi + 4 * eax]             ; pjDstIn + (((DstLeft+31) >> 5) * 4
        lea     esi,[esi + 4 * ebx]             ; pjSrcIn + ((SrcLeft + 31) >> 5) * 4

        ;
        ; save scan line addresses
        ;

        mov     edx,spo_cy[esp]                 ; keep track of # of scan lines
        mov     ecx,spo_lXorMask[esp]           ; load xor mask
        mov     ebp,spo_DeltaSrcIn[esp]

Opaq1to1DwordLoop:

        mov     eax,spo_lEndOffset[esp]         ; load loop x count

@@:
        ;
        ; read and write 1 DWORD
        ;

        mov     ebx,[4 * eax -4 + esi]          ; load dw 0
        xor     ebx,ecx                         ; xor mask
        mov     [4 * eax -4 + edi],ebx          ; store dw 0

        dec     eax                             ; dec dword count
        jnz     @B                              ; loop until done

        ;
        ; done with scan line, add strides
        ;

        add     edi,spo_DeltaDstIn[esp]         ; pjDst += DeltaDst
        add     esi,ebp                         ; pjSrc += DeltaSrc

        ;
        ; dec and check cy
        ;

        dec     edx                             ; cy--
        jne     Opaq1to1DwordLoop

Opaq1to1Partial:

        ;
        ; handle partial DWORD blts. first the start case, which may be the
        ; left edge or it may be a combined DWORD left and right, in which
        ; case the start and end masks are just anded together
        ;

        mov     eax,spo_DstLeft[esp]                     ; left position
        and     eax,01Fh                        ; left edge pixels
        je      Opaq1to1RightEdge               ; if zero, no left edge

        ;
        ; There is a left edge, are right and left DWORDS the same
        ;

        mov     ebx,spo_DstRight[esp]           ; right edge
        mov     edx,-32                         ; ~0x1F   - dword address alignment
        and     ebx,edx                         ; DstRight & ~0x1F
        and     edx,spo_DstLeft[esp]            ; DstLeft  & ~0x1F

        mov     ecx,spo_ulStartMask[esp]        ; get start start mask

        cmp     edx,ebx                         ; if equal, start and stop
        jne     @F                              ; in same DWORD

        ;
        ; left and right are same src DWORD, combine masks, then
        ; set right edge to 0 so Opaq1to1RightEdge won't run
        ;

        and     ecx,spo_ulEndMask[esp]          ; combine with start mask
        mov     spo_DstRight[esp],0             ; save 0
@@:

        mov     spo_ulStartMask[esp],ecx        ; Src Mask
        not     ecx
        mov     spo_tMask[esp],ecx              ; Dst Mask = ~SrcMask

        ;
        ; calc left edge starting addresses
        ;
        ;       pjDst = pjDstIn + ((DstLeft >> 5) << 2)
        ;       pjSrc = pjSrcIn + ((SrcLeft >> 5) << 2)
        ;

        mov     eax,spo_DstLeft[esp]            ; load
        mov     ebx,spo_SrcLeft[esp]            ; load
        shr     eax,5                           ; DstLeft >> 3
        shr     ebx,5                           ; SrcLeft >> 3
        mov     edi,spo_pjDstIn[esp]            ; load dst addr
        mov     esi,spo_pjSrcIn[esp]            ; load src addr
        lea     edi,[edi + 4*eax]               ; dest address
        lea     esi,[esi + 4*ebx]               ; src address
        mov     ecx,spo_DeltaDstIn[esp]
        mov     ebp,spo_DeltaSrcIn[esp]
        mov     edx,spo_cy[esp]

        ;
        ; unroll left edge loop 2 times. Address fix-up is needed
        ;

        sub     esi,ebp                         ; fix-up address for odd cycle
        sub     edi,ecx                         ; fix-up address for odd cycle

        add     edx,1
        shr     edx,1
        jnc     Opaq1to1PartialLeftOdd

        add     esi,ebp                         ; un-fix-up address for even cycle
        add     edi,ecx                         ; un-fix-up address for even cycle

@@:

        mov     eax,[esi]                       ; load src
        mov     ebx,[edi]                       ; load dst
        xor     eax,spo_lXorMask[esp]           ; xor
        and     ebx,spo_tMask[esp]
        and     eax,spo_ulStartMask[esp]
        or      eax,ebx                         ; mask src with lStartMask
        mov     [edi],eax

Opaq1to1PartialLeftOdd:

        mov     eax,[esi + ebp]                 ; load src
        mov     ebx,[edi + ecx]                 ; load dst
        xor     eax,spo_lXorMask[esp]           ; xor
        and     ebx,spo_tMask[esp]
        and     eax,spo_ulStartMask[esp]
        or      eax,ebx                         ; mask src with lStartMask
        mov     [edi + ecx],eax

        lea     esi,[esi + 2*ebp]
        lea     edi,[edi + 2*ecx]

        dec     edx
        jnz     @B

        ;
        ; done with left edge
        ;

Opaq1to1RightEdge:

        ;
        ; right edge, check DstRight[4:0] for pixels on the right edge
        ;

        mov     eax,spo_DstRight[esp]           ; load
        and     eax,01Fh                        ; are there right edge pixels
        jz      EndOpaq1to1

        ;
        ; there are right edge pixels to draw, calc pjSrc and pjDst
        ;
        ; pjDst = pjDstIn + ((DstRight >> 5) << 2)
        ; pjSrc = pjSrcIn + (((SrcLeft + (DstRight - DstLeft)) >> 5) << 2)
        ;

        mov     ebx,spo_DstRight[esp]           ; DstRight
        mov     ecx,spo_DstLeft[esp]            ; load DstLeft
        mov     eax,spo_SrcLeft[esp]            ; load SrcLeft
        mov     edx,ebx                         ; edi = DstRight
        sub     ebx,ecx                         ; (DstRight - DstLeft)
        add     eax,ebx                         ; SrcLeft + (DstRight - DstLeft)
        shr     edx,5                           ; DstRight >> 5
        shr     eax,5                           ; Src Offset >> 5
        mov     edi,spo_pjDstIn[esp]            ;
        mov     esi,spo_pjSrcIn[esp]            ;
        lea     edi,[edi + 4*edx]               ; pjDstIn + DstOffset
        lea     esi,[esi + 4*eax]               ; pjSrcIn + SrcOffset
        mov     ecx,spo_DeltaDstIn[esp]
        mov     ebp,spo_DeltaSrcIn[esp]
        mov     edx,spo_cy[esp]

        mov     eax,spo_ulEndMask[esp]          ; load end mask
        not     eax                             ; invert  for dst mask
        mov     spo_ulStartMask[esp],eax        ; not mask for dst

        ;
        ; unroll right edge 2 times. Address fix-up is needed.
        ;

        sub     esi,ebp                         ; fix up address for odd cycle
        sub     edi,ecx                         ; fix up address for odd cycle

        inc     edx                             ; add 1 to loop count
        shr     edx,1                           ; device loop count by 2
        jnc     Opaq1to1PartialRightOdd         ; if carry, loop was initially even

        add     esi,ebp                         ; fix up address for odd cycle
        add     edi,ecx                         ; fix up address for odd cycle

@@:

        mov     eax,[esi]                       ; load src dw 0
        mov     ebx,[edi]                       ; load dst dw 0
        xor     eax,spo_lXorMask[esp]           ; xor src dw
        and     ebx,spo_ulStartMask[esp]        ; mask dst dw
        and     eax,spo_ulEndMask[esp]          ; mask src dw
        or      eax,ebx                         ; combine
        mov     [edi],eax                       ; store

Opaq1to1PartialRightOdd:

        mov     eax,[esi + ebp]                 ; load src dw 1
        mov     ebx,[edi + ecx]                 ; load dst dw 1
        xor     eax,spo_lXorMask[esp]           ; xor src dw
        and     ebx,spo_ulStartMask[esp]        ; mask dst dw
        and     eax,spo_ulEndMask[esp]          ; mask src dw
        or      eax,ebx                         ; combine
        mov     [edi + ecx],eax                 ; store

        lea     esi,[esi + 2 * ebp]             ; 2nd next scan line
        lea     edi,[edi + 2 * ecx]             ; 2nd next scan line

        dec     edx                             ; dec loop count
        jnz     @B                              ; repeat

        jmp     EndOpaq1to1

        ;
        ; Opaque text expansion, no src required. lXorMask is masked and written to dest
        ;


Opaq1to1NoSrc:

        ;
        ; calculate the number of full dwords to copy
        ;
        ; Full DWORDS = (DstRight >> 5) - ((DstLeft + 31) >> 5)
        ;

        mov     eax,spo_DstLeft[esp]            ; Left (startint Dst Location)
        mov     ebx,spo_DstRight[esp]           ; right (last pixel)
        add     eax,31                          ; DstLeft + 31
        shr     ebx,5                           ; DstRight >> 5
        shr     eax,5                           ; (DstLeft+31) >> 5

        ;
        ; if <= 0, then no full DWORDS need to be copied, go to end cases
        ;

        sub     ebx,eax                         ; RightDW - LeftDw
        jle     Opaq1to1PartialNoSrc

        mov     spo_lEndOffset[esp],ebx         ; save

        ;
        ; calc starting Dst Address = pjDstIn + (((DstLeft+31) >> 5) << 2)
        ;

        mov     edi,spo_pjDstIn[esp]
        lea     edi,[edi + 4 * eax]             ; pjDstIn + (((DstLeft+31) >> 5) * 4

        ;
        ; save scan line addresses
        ;

        mov     edx,spo_cy[esp]                 ; keep track of # of scan lines
        mov     ebx,spo_lXorMask[esp]           ; xor mask
        not     ebx                             ; not xor mask
        mov     esi,spo_DeltaDstIn[esp]         ; dest scan line inc

Opaq1to1DwordLoopNoSrc:

        ;
        ; DWORD loop, unrolled 2 times. lEndOffset has been pre-incremented so
        ; a loop count of 1 is incremented to 2, then shifted to make a loop
        ; count of 1 with a carry of zero. ( no carry represents a odd element)
        ; Address fix-up is required.
        ;

        mov     eax,spo_lEndOffset[esp]         ; get inner loop count
@@:
        ;
        ; write 1 DWORD
        ;

        mov     [4 * eax - 4 + edi],ebx         ; store dw 0

        dec     eax                             ; dec dword count
        jnz     @B                              ; loop until done

        ;
        ; done with scan line, add strides
        ;

        add     edi,esi                         ; pjDst += DeltaDst

        ;
        ; dec and check cy
        ;

        dec     edx                             ; cy--
        jne     Opaq1to1DwordLoopNoSrc


Opaq1to1PartialNoSrc:

        ;
        ; handle partial DWORD blts. first the start case, which may be the
        ; left edge or it may be a combined DWORD left and right, in which
        ; case the start and end masks are just anded together
        ;

        mov     eax,spo_DstLeft[esp]            ; left position
        and     eax,01Fh                        ; left edge pixels
        je      Opaq1to1RightEdgeNoSrc          ; if zero, no left edge

        ;
        ; There is a left edge, are right and left DWORDS the same
        ;

        mov     edx,spo_DstRight[esp]           ; right edge
        mov     ecx,-32                         ; ~0x1F   - dword address alignment
        and     ebx,ecx                         ; DstLeft  & ~0x1F
        and     edx,ecx                         ; DstRight & ~0x1F

        mov     ecx,spo_ulStartMask[esp]        ; get start start mask

        cmp     edx,ebx                         ; if equal then start and end
        jne     @F                              ; in same DWORD

        ;
        ; left and right are same src DWORD, combine masks, then
        ; set right edge to 0 so Opaq1to1RightEdge won't run
        ;

        and     ecx,spo_ulEndMask[esp]          ; combine with start mask
        mov     spo_DstRight[esp],0             ; save 0
@@:
        ;
        ; calc left edge starting addresses
        ;
        ;       pjDst = pjDstIn + ((DstLeft >> 5) << 2)
        ;

        mov     eax,spo_DstLeft[esp]            ; load
        shr     eax,5                           ; DstLeft >> 3
        mov     edi,spo_pjDstIn[esp]            ; load dst addr
        lea     edi,[edi + 4*eax]               ; dest address
        mov     ebx,spo_DeltaDstIn[esp]         ; dst scan line stride
        mov     esi,spo_lXorMask[esp]           ; load xor mask
        not     esi                             ; invert
        and     esi,ecx                         ; masked constant src
        not     ecx                             ; ~lStartMask
        mov     edx,spo_cy[esp]                 ; loop count

        ;
        ; unroll left edge loop 2 times. Address fix-up is needed
        ;

        sub     edi,ebx                         ; fix-up address for odd cycle

        add     edx,1                           ; offset for unrolling
        shr     edx,1                           ; 2 times through loop
        jnc     Opaq1to1LeftEdgeOddNoSrc        ; do first "odd" dword

        add     edi,ebx                         ; un-fix-up address for even cycle

@@:
        mov     eax,[edi]                       ; load src
        and     eax,ecx                         ; mask
        or      eax,esi                         ; invert
        mov     [edi],eax                       ; store

Opaq1to1LeftEdgeOddNoSrc:

        mov     eax,[edi + ebx]                 ; load src
        and     eax,ecx                         ; mask
        or      eax,esi                         ; invert
        mov     [edi + ebx],eax                 ; store

        lea     edi,[edi][ebx*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; loop count
        jnz     @b                              ;

        ;
        ; done with left edge
        ;

Opaq1to1RightEdgeNoSrc:

        ;
        ; right edge, check DstRight[4:0] for pixels on the right edge
        ;

        mov     eax,spo_DstRight[esp]           ; load
        and     eax,01Fh                        ; are there right edge pixels
        jz      EndOpaq1to1

        ;
        ; there are right edge pixels to draw, calc pjSrc and pjDst
        ;
        ; pjDst = pjDstIn + ((DstRight >> 5) << 2)
        ;

        mov     ebx,spo_DstRight[esp]           ; DstRight
        shr     ebx,5                           ; DstRight >> 5
        mov     edi,spo_pjDstIn[esp]            ;
        lea     edi,[edi + 4*ebx]               ; pjDstIn + DstOffset

        mov     ecx,spo_ulEndMask[esp]          ; load end mask
        mov     esi,spo_lXorMask[esp]           ; load xor mask
        not     esi                             ; invert
        and     esi,ecx                         ; mask with endmask
        not     ecx                             ; invert end mask
        mov     ebx,spo_DeltaDstIn[esp]         ; dst scan line inc
        mov     edx,spo_cy[esp]                 ; loop count

        ;
        ; unroll right edge 2 times, address fix-up is needed
        ;

        sub     edi,ebx                         ; fix-up address for odd cycle

        add     edx,1                           ; offset for 2 times unrolling
        shr     edx,1                           ; LoopCount / 2
        jnc     Opaq1to1RightEdgeOddNoSrc       ; do single "odd" DWORD

        add     edi,ebx                         ; un-fix-up address for even cycle

@@:
        mov     eax,[edi]                       ; load src dword
        and     eax,ecx                         ; mask
        or      eax,esi                         ; combine
        mov     [edi],eax                       ; store

Opaq1to1RightEdgeOddNoSrc:

        mov     eax,[edi+ebx]                   ; load src dword
        and     eax,ecx                         ; mask
        or      eax,esi                         ; combine
        mov     [edi+ebx],eax                   ; store

        lea     edi,[edi][ebx*2]                ; dst += 2 * DeltaDst

        dec     edx                             ; dec loop count
        jnz     @B                              ; and loop until zero

        ;
        ; done!
        ;

EndOpaq1to1:

        add     esp,5*4

        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     44

vSrcOpaqCopyS1D1@44 endp

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\line.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: line.asm
;
; Routines for drawing line DDAs for 8BPP
;
; Created: 10-DEC-1993
; Author: Mark Enstrom
;
; Copyright (c) 1993-1999 Microsoft Corporation
;-----------------------------------------------------------------------;


        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
        include gdii386.inc
        include line.inc
        .list

        .code

;---------------------------Private-Routine-----------------------------;
; vLine1Octant07
;
;   Line drawing DDA for 8BPP X major line in octant 0 or 7
;
; Entry:
;
;   PDDALINE pDDALine,
;   PUCHAR   pjDst,
;   ULONG    lDeltaDst,
;   ULONG    iSolidColor
;       
; Returns:
;       none
; Registers Destroyed:
;       ECX, EDX
; Calls:
;       None
; History:
; Wrote it
;-----------------------------------------------------------------------;

cProc   vLine8Octant07,16,<      \
        uses    ebx esi edi,     \
        pDDA:   ptr dword,       \
        pjDst:  ptr dword,       \
        lDelta: dword,           \
        Color:  byte             >

        ;
        ; load terms
        ;

        mov     ebx,pDDA             ; ebx = pDDALine
        mov     eax,pjDst            ; eac = pjDst
        mov     ecx,[ebx].lErrorTerm ; ecx = lErrorTerm
        mov     edx,[ebx].dMajor     ; edx = dM
        mov     esi,[ebx].dMinor     ; esi = dM
        mov     edi,[ebx].cPels      ; edi = cPels

        ;
        ; pjDst += x0
        ;

        add     eax,[ebx+4]

        ;
        ; while (TRUE)
        ;

LoopStart:

        ;
        ;      *pjDst = iSolidColor
        ;

        mov     bl,Color        ; iSolidColor
        mov     [eax],bl        ; *pjDst = bl

        ;
        ;       if (--cPels == 0)
        ;               return
        ;

        dec     edi             ; --cPels
        jz      short Done      ; if zero, done

        ;
        ; this  is  an  x major line,  always
        ; add dN to the error term and always
        ; increment pjDst by 1.  If the error
        ; term  is  not  negative  after  the
        ; addition of dN, then add dM and inc
        ; pjDst by lDelta
        ; 

        inc     eax             ; pjDst++
        add     ecx,esi         ; error += dN
        js      short LoopStart

        sub     ecx,edx         ; error -= dM
        add     eax,lDelta      ; pjDst += lDelta
        jmp     short LoopStart

Done:
        cRet vLine8Octant07 

endProc vLine8Octant07

;---------------------------Private-Routine-----------------------------;
; vLine1Octant34
;
;   Line drawing DDA for 8BPP X major line in octant 3 or 4
;
; Entry:
;
;   PDDALINE pDDALine,
;   PUCHAR   pjDst,
;   ULONG    lDeltaDst,
;   ULONG    iSolidColor
;       
; Returns:
;       none
; Registers Destroyed:
;       ECX, EDX
; Calls:
;       None
; History:
;       12-10-93
;-----------------------------------------------------------------------;

cProc   vLine8Octant34,16,<      \
        uses    ebx esi edi,     \
        pDDA:   ptr dword,       \
        pjDst:  ptr dword,       \
        lDelta: dword,           \
        Color:  byte             >

        ;
        ; load terms
        ;

        mov     ebx,pDDA             ; ebx = pDDALine
        mov     eax,pjDst            ; eac = pjDst
        mov     ecx,[ebx].lErrorTerm ; ecx = lErrorTerm
        mov     edx,[ebx].dMajor     ; edx = dM
        mov     esi,[ebx].dMinor     ; esi = dM
        mov     edi,[ebx].cPels      ; edi = cPels

        ;
        ; pjDst += x0
        ;

        add     eax,[ebx+4]

        ;
        ; while (TRUE)
        ;

LoopStart:

        ;
        ;      *pjDst = iSolidColor
        ;

        mov     bl,Color        ; iSolidColor
        mov     [eax],bl        ; *pjDst = bl

        ;
        ;       if (--cPels == 0)
        ;               return
        ;

        dec     edi             ; --cPels
        jz      short Done      ; if zero, done

        ;
        ; this  is  an  x major line,  always
        ; add dN to the error term and always
        ; increment pjDst by 1.  If the error
        ; term  is  not  negative  after  the
        ; addition of dN, then add dM and inc
        ; pjDst by lDelta
        ; 

        dec     eax             ; pjDst--
        add     ecx,esi         ; error += dN
        js      short LoopStart

        sub     ecx,edx         ; error -= dM
        add     eax,lDelta      ; pjDst += lDelta
        jmp     short LoopStart

Done:

        cRet vLine8Octant34

endProc vLine8Octant34

;---------------------------Private-Routine-----------------------------;
; vLine1Octant16
;
;   Draw Y-Major line in octant 1 or 6
;
; Entry:
;
;   PDDALINE pDDALine,
;   PUCHAR   pjDst,
;   ULONG    lDeltaDst,
;   ULONG    iSolidColor
;       
; Returns:
;       none
; Registers Destroyed:
;       ECX, EDX
; Calls:
;       None
; History:
;       12-10-93
;-----------------------------------------------------------------------;

cProc   vLine8Octant16,16,<      \
        uses    ebx esi edi,     \
        pDDA:   ptr dword,       \
        pjDst:  ptr dword,       \
        lDelta: dword,           \
        Color:  byte             >

        ;
        ; load terms
        ;

        mov     ebx,pDDA             ; ebx = pDDALine
        mov     eax,pjDst            ; eac = pjDst
        mov     ecx,[ebx].lErrorTerm ; ecx = lErrorTerm
        mov     edx,[ebx].dMajor     ; edx = dM
        mov     esi,[ebx].dMinor     ; esi = dM
        mov     edi,[ebx].cPels      ; edi = cPels

        ;
        ; pjDst += x0
        ;

        add     eax,[ebx+4]

LoopStart:

        ;
        ;      *pjDst = iSolidColor
        ;

        mov     bl,Color        ; iSolidColor
        mov     [eax],bl        ; *pjDst = bl

        ;
        ;      while cPels--
        ;

        dec     edi
        jz      short Done

        ;
        ; This is a y-major line, every loop throuhg
        ; the DDA, add lDelta to pjDst to  increment
        ; to the next scan line.  Also add dN to the
        ; error term, if the error term is >= 0 after
        ; the addition them add xInc to pjDst and add
        ; dM to the error term
        ;

        add     eax,lDelta      ; pjDst += lDelta
        add     ecx,esi         ; error += dN
        js      short LoopStart

        sub     ecx,edx         ; error -= dM
        inc     eax             ; pjDst ++
        jmp     short LoopStart

Done:

        cRet vLine8Octant16

endProc vLine8Octant16

;---------------------------Private-Routine-----------------------------;
; vLine1Octant25
;
;   Draw Y-Major line in octant 5 or 6
;
; Entry:
;
;   PDDALINE pDDALine,
;   PUCHAR   pjDst,
;   ULONG    lDeltaDst,
;   ULONG    iSolidColor
;       
; Returns:
;       none
; Registers Destroyed:
;       ECX, EDX
; Calls:
;       None
; History:
;       12-10-93
;-----------------------------------------------------------------------;

cProc   vLine8Octant25,16,<      \
        uses    ebx esi edi,     \
        pDDA:   ptr dword,       \
        pjDst:  ptr dword,       \
        lDelta: dword,           \
        Color:  byte             >

        ;
        ; load terms
        ;

        mov     ebx,pDDA             ; ebx = pDDALine
        mov     eax,pjDst            ; eac = pjDst
        mov     ecx,[ebx].lErrorTerm ; ecx = lErrorTerm
        mov     edx,[ebx].dMajor     ; edx = dM
        mov     esi,[ebx].dMinor     ; esi = dM
        mov     edi,[ebx].cPels      ; edi = cPels

        ;
        ; pjDst += x0
        ;

        add     eax,[ebx+4]

LoopStart:

        ;
        ;      *pjDst = iSolidColor
        ;

        mov     bl,Color        ; iSolidColor
        mov     [eax],bl        ; *pjDst = bl

        ;
        ;      while cPels--
        ;

        dec     edi
        jz      short Done

        ;
        ; This is a y-major line, every loop throuhg
        ; the DDA, add lDelta to pjDst to  increment
        ; to the next scan line.  Also add dN to the
        ; error term, if the error term is >= 0 after
        ; the addition them add xInc to pjDst and add
        ; dM to the error term
        ;

        add     eax,lDelta      ; pjDst += lDelta
        add     ecx,esi         ; error += dN
        js      short LoopStart

        sub     ecx,edx         ; error -= dM
        dec     eax             ; pjDst --
        jmp     short LoopStart

Done:

        cRet vLine8Octant25

endProc vLine8Octant25

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\line.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: stucts.inc
;
; Copyright (c) 1992-1999 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; DFBBLT is used to store DFB BLTing info
;-----------------------------------------------------------------------;
DDALINE		STRUC
ulFlags		dd	? ; dda flags
ptlStart0	dd	? ; point.x
ptlStart1	dd	? ; point.y
cPels		dd	? ; pixel count
dMajor		dd	? ; major axis error term
dMinor		dd	? ; minor axes error term
lErrorTerm	dd	? ; dda error term
xInc		dd	? ; not used
DDALINE         ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\fasttext.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fasttext.asm
;
; Copyright (c) 1992-1999 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vFastText(GLYPHPOS * pGlyphPos, ULONG ulGlyphCount, PBYTE pTempBuffer,
;                ULONG ulBufDelta, ULONG ulCharInc, DEVSURF * pdsurf,
;                RECTL * prclText, RECTL * prclOpaque, INT iFgColor,
;                INT iBgColor, ULONG fDrawFlags, RECTL * prclClip,
;                RECTL * prclExtra, ULONG iTrgType);
; pGlyphPos -
; ulGlyphCount - # of glyphs to draw. Must never be 0.
; pTempBuffer -
; ulBufDelta -
; ulCharInc -
; pdsurf -
; prclText -
; prclOpaque -
; iFgColor -
; iBgColor -
; fDrawFlags -
; prclClip -     array of clipping rectangles
; prclExtra -    array of extra rectanlges to fill in foreground color
; iTrgType -     0 = VGA; 1 = DFB; 2 = NONE
;
; Performs accelerated proportional text drawing.
;
;-----------------------------------------------------------------------;
;
; Note: prclClip and prclExtra are null rectangle (yBottom=0) terminated
;       arrays
;
; Note: Assumes the text rectangle has a positive height and width. Will
; not work properly if this is not the case.
;
; Note: The opaquing rectangle is assumed to match the text bounding
; rectangle exactly; prclOpaque is used only to determine whether or
; not opaquing is required.
;
; Note: For maximum performance, we should not bother to draw fully-
; clipped characters to the temp buffer.
;
; Note: We do not handle clipping or bank spanning in the very fast
; byte-wide-aligned-fixed-pitch console text. This would be an
; opportunity for somewhat faster console text performance.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module is to draw the text into a system
memory buffer, then copy the buffer to the screen a word at a time
using write mode 3 so that no OUTs and a minimum of display memory reads
are required.

        commend $

        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
        include callconv.inc
        include gdii386.inc
        .list

;-----------------------------------------------------------------------;

        .data

        align   4
                               

;-----------------------------------------------------------------------;
; Tables used to branch into glyph-drawing optimizations.
;
; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; should be MOVed even if it's not aligned (intended for use in drawing the
; first glyph in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableNarrow   label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      mov_first_1_wide_rotated_need_last ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_1_wide_rotated_no_last   ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_2_wide_rotated_need_last ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_2_wide_rotated_no_last   ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_3_wide_rotated_need_last ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_3_wide_rotated_no_last   ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_4_wide_rotated_need_last ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      mov_first_4_wide_rotated_no_last   ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableNarrow    label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_first_1_wide_rotated_need_last  ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_1_wide_rotated_no_last    ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_2_wide_rotated_need_last  ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_2_wide_rotated_no_last    ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_3_wide_rotated_need_last  ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_3_wide_rotated_no_last    ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_4_wide_rotated_need_last  ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      or_first_4_wide_rotated_no_last    ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where all bytes
; should be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableNarrow        label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_all_1_wide_rotated_need_last    ;nonalign, 1 wide, need last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_1_wide_rotated_no_last      ;nonalign, 1 wide, no last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_2_wide_rotated_need_last    ;nonalign, 2 wide, need last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_2_wide_rotated_no_last      ;nonalign, 2 wide, no last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_3_wide_rotated_need_last    ;nonalign, 3 wide, need last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_3_wide_rotated_no_last      ;nonalign, 3 wide, no last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_4_wide_rotated_need_last    ;nonalign, 4 wide, need last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide
        dd      or_all_4_wide_rotated_no_last      ;nonalign, 4 wide, no last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; MOVed even if it's not aligned (intended for use in drawing the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableWide     label   dword
        dd      mov_first_N_wide_rotated_need_last      ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      mov_first_N_wide_rotated_no_last        ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableWide      label   dword
        dd      or_first_N_wide_rotated_need_last       ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      or_first_N_wide_rotated_no_last         ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where all bytes should
; be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableWide  label   dword
        dd      or_all_N_wide_rotated_need_last ;nonalign, need last
        dd      or_all_N_wide_unrotated         ;aligned
        dd      or_all_N_wide_rotated_no_last   ;nonalign, no last
        dd      or_all_N_wide_unrotated         ;aligned

; Vectors to entry points for drawing various types of text. '*' means works as
; is but could be acclerated with a custom scanning loop.
        align   4
MasterTextTypeTable     label   dword       ;tops aligned  overlap  fixed pitch
        dd      draw_nf_ntb_o_to_temp_start ;      N          N          N *
        dd      draw_f_ntb_o_to_temp_start  ;      N          N          Y *
        dd      draw_nf_ntb_o_to_temp_start ;      N          Y          N
        dd      draw_f_ntb_o_to_temp_start  ;      N          Y          Y
        dd      draw_nf_tb_no_to_temp_start ;      Y          N          N
        dd      draw_f_tb_no_to_temp_start  ;      Y          N          Y
        dd      draw_nf_ntb_o_to_temp_start ;      Y          Y          N *
        dd      draw_f_ntb_o_to_temp_start  ;      Y          Y          Y *
        dd      0;
        dd      0;
        dd      0;
        dd      0;
        dd      0;
        dd      0;
        dd      0;
        dd      0;


; Masks for clipping for the eight possible left and right edge alignments
jOpaqueLeftMasks        label   byte
        db      0ffh,07fh,03fh,01fh,00fh,007h,003h,001h

jOpaqueRightMasks       label   byte
        db      0ffh,080h,0c0h,0e0h,0f0h,0f8h,0fch,0feh

dfbfill_jLeftMasks      label   dword
                db      0ffh,0ffh,0ffh,0ffh
                db      07fh,0ffh,0ffh,0ffh
                db      03fh,0ffh,0ffh,0ffh
                db      01fh,0ffh,0ffh,0ffh
                db      00fh,0ffh,0ffh,0ffh
                db      007h,0ffh,0ffh,0ffh
                db      003h,0ffh,0ffh,0ffh
                db      001h,0ffh,0ffh,0ffh
                db      000h,0ffh,0ffh,0ffh
                db      000h,07fh,0ffh,0ffh
                db      000h,03fh,0ffh,0ffh
                db      000h,01fh,0ffh,0ffh
                db      000h,00fh,0ffh,0ffh
                db      000h,007h,0ffh,0ffh
                db      000h,003h,0ffh,0ffh
                db      000h,001h,0ffh,0ffh
                db      000h,000h,0ffh,0ffh
                db      000h,000h,07fh,0ffh
                db      000h,000h,03fh,0ffh
                db      000h,000h,01fh,0ffh
                db      000h,000h,00fh,0ffh
                db      000h,000h,007h,0ffh
                db      000h,000h,003h,0ffh
                db      000h,000h,001h,0ffh
                db      000h,000h,000h,0ffh
                db      000h,000h,000h,07fh
                db      000h,000h,000h,03fh
                db      000h,000h,000h,01fh
                db      000h,000h,000h,00fh
                db      000h,000h,000h,007h
                db      000h,000h,000h,003h
                db      000h,000h,000h,001h
                                 
dfbfill_jRightMasks     label   dword
                db      0ffh,0ffh,0ffh,0ffh
                db      080h,000h,000h,000h
                db      0c0h,000h,000h,000h
                db      0e0h,000h,000h,000h
                db      0f0h,000h,000h,000h
                db      0f8h,000h,000h,000h
                db      0fch,000h,000h,000h
                db      0feh,000h,000h,000h
                db      0ffh,000h,000h,000h
                db      0ffh,080h,000h,000h
                db      0ffh,0c0h,000h,000h
                db      0ffh,0e0h,000h,000h
                db      0ffh,0f0h,000h,000h
                db      0ffh,0f8h,000h,000h
                db      0ffh,0fch,000h,000h
                db      0ffh,0feh,000h,000h
                db      0ffh,0ffh,000h,000h
                db      0ffh,0ffh,080h,000h
                db      0ffh,0ffh,0c0h,000h
                db      0ffh,0ffh,0e0h,000h
                db      0ffh,0ffh,0f0h,000h
                db      0ffh,0ffh,0f8h,000h
                db      0ffh,0ffh,0fch,000h
                db      0ffh,0ffh,0feh,000h
                db      0ffh,0ffh,0ffh,000h
                db      0ffh,0ffh,0ffh,080h
                db      0ffh,0ffh,0ffh,0c0h
                db      0ffh,0ffh,0ffh,0e0h
                db      0ffh,0ffh,0ffh,0f0h
                db      0ffh,0ffh,0ffh,0f8h
                db      0ffh,0ffh,0ffh,0fch
                db      0ffh,0ffh,0ffh,0feh

dfbfill_pfnScanHandlers label   dword
                dd      0
                dd      0
                dd      0
                dd      0


;-----------------------------------------------------------------------;

                .code


_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;


extrn draw_gray_nf_ntb_o_to_temp_start@28:NEAR
extrn draw_gray_f_ntb_o_to_temp_start@28:NEAR

cProc vFastText,52,<\
 uses esi edi ebx,\
 pGlyphPos:ptr,\
 ulGlyphCount:dword,\
 pTempBuffer:ptr,\
 ulBufDelta:dword,\
 ulCharInc:dword,\
 pdsurf:ptr,\
 prclText:ptr,\
 prclOpaque:ptr,\
 iFgColor:dword,\
 iBgColor:dword,\
 fDrawFlags:dword,\
 prclClip:dword,\
 prclExtra:dword>

        local ulGlyDelta:dword  ;width per scan of source glyph, in bytes
        local ulWidthInBytes:dword ;width of glyph, in bytes
        local ulTmpWidthInBytes:dword ;working byte-width count
        local ulGlyphX:dword    ;for fixed-pitch text, maintains the current
                                ; glyph's left-edge X coordinate
        local pGlyphLoop:dword  ;pointer to glyph-processing loop
        local ulTempLeft:dword  ;X coordinate on screen of left edge of temp
                                ; buffer
        local ulTempTop:dword   ;Y coordinate on screen of top edge of temp
                                ; buffer
        local ulLoopCount:dword ;general loop count storage
        local ulTmpSrcDelta:dword ;distance from end of one buffer text scan to
                                  ; start of next
        local ulTmpDstDelta:dword ;distance from end of one screen text scan to
                                  ; start of next
        local ulTopScan:dword     ;top scan of dest text rect in current bank
        local ulBottomScan:dword  ;bottom scan of dest text rect
        local ulNumScans:dword    ;# of scans to draw
        local ulScreenDelta:dword ;scan-to-scan offset in screen
        local ulTextWidthInBytes:dword ;# of bytes across spanned by text
        local pScreen:dword     ;pointer to first screen byte to which to draw
        local pfnEdgeVector:dword ;pointer to routine to draw any needed edges
        local pfnFirstOpaqVector:dword ;pointer to initial drawing routine
                                       ; called for opaque (either whole
                                       ; bytes, or edge(s) if no whole bytes)
        local ulWholeWidthInWords:dword ;# of whole words to copy
        local ulWholeWidthInWordsMinus1:dword ;# of whole words to copy, -1
        local ulOddByte:dword   ;1 if odd byte in whole word copy
        local ulTextLeft:dword  ;left edge of leftmost glyph
        local ulLeftMask:dword  ;for opaque text, left edge mask for string
        local ulRightMask:dword ;for opaque text, right edge mask for string
        local ulScans:dword     ;# of scans to draw
        local ulYOrigin:dword   ;Y origin of text in string (all glyphs are at
                                ; the same Y origin)
        local rclClippedBounds[16]:byte ;clipped destination rectangle;
                                        ; defined as "byte" due to assembler
                                        ; limitations

        local ulRectLeft:dword
        local ulRectRight:dword
        local pfnDrawScans:dword         ;ptr to correct scan drawing function
        local pTempBufferSaved:dword
        local ulEdgeFlags:dword
        local ulBytesPerDstPlane:dword
        local ulLeftOffset:dword
        local pSrc:dword
        local pDst:dword
        local ulPlaneBit:dword

TRAILING_PARTIAL        equ     01h      ;partial trailing dword should be copied
LEADING_PARTIAL         equ     02h      ;partial leading dword should be copied

;-----------------------------------------------------------------------;
;
; For the moment, handle grayed text using the most general routine
; This means that we will be handing it back to the most general of
; of the C routines, namely
;
;       VOID
;       draw_gray_nf_ntb_o_to_temp_start(
;           PGLYPHPOS  pGlyphPos
;           ULONG      cGlyph
;           PUCHAR     pjTempBuffer
;           ULONG      BufferOffset
;           ULONG      ulBufferWidthInBytes
;           ULONG      ulCharInc
;           ULONG      ulTempTop
;           )
;
;   or for fixed pitch fonts
;
;       VOID
;       draw_gray_f_ntb_o_to_temp_start(
;           PGLYPHPOS  pGlyphPos
;           ULONG      cGlyph
;           PUCHAR     pjTempBuffer
;           ULONG      BufferOffset
;           ULONG      ulBufferWidthInBytes
;           ULONG      ulCharInc
;           ULONG      ulTempTop
;           )
;
; Most of these parameters are in the arguments passed to vFastText.
; However, there are a couple that we must reconstruct. The first
; parameter to be pushed is ulTempTop. I look into the calling
; routine (vExpandAndCopyText) and find
;
;       ulTempTop = prclText->top
;       BufferOffset = 8 * floor(prclText->left/8)
;
; The factor of 8 is equal to the number of pixels contained in
; a DWORD. For monochrome text, this number would become 32
;
; The third argument to vFastText is pjTempBuffer which is equal to
;
;      pjTempBuffer = pTempBuffer - ((prclText->left >> 3) & 3)
;
;  (to draw_gray..)   (input to vFastText)
;
;-----------------------------------------------------------------------;

;gray_text_test:
        mov     edx,fDrawFlags          ; Is this call for grayed text?
        test    edx,8                   ; test for ETO_GRAY in fDrawFlags
        jz      monochrome_text         ; if not go to monochrome code
;gray_text:
        mov     ebx,prclText            ; ebx = useful pointer to text rect
        push    [ebx].yTop              ; ulTempTop: 7'th argument
        push    ulCharInc               ; ulCharInc: 6'th argument
        push    ulBufDelta              ; dpDst:     5'th argument
        mov     eax,[ebx].xLeft         ; eax = prclText->left
        mov     ecx,eax                 ; ecx = prclText->left
        and     ecx,not 7               ; ecx = 8 * (prclText->left / 8)
        push    ecx                     ; BufferOffset: 4'th argument
        sar     eax,3                   ; This is the part where we
        and     eax,3                   ; correct pjTempBuffer by subtracting
        neg     eax                     ; off an additional factor (see above)
        add     eax,pTempBuffer         ; eax = pjTempBuffer[draw_gray..]
        push    eax                     ; pjTempBuffer: 3'rd argument
        push    ulGlyphCount            ; cGlyph:       2'nd argument
        push    pGlyphPos               ; pGlyphPos:    1'st argument
        mov     eax,draw_gray_f_ntb_o_to_temp_start@28
        test    edx,1                   ; fixed pitch ?
        jnz     @f                      ; yes, eax is good, jump
        mov     eax,draw_gray_nf_ntb_o_to_temp_start@28
@@:
        call    eax
        jmp     exit_fast_text
monochrome_text:

        cld

;-----------------------------------------------------------------------;
; Draws either a fixed or a non-fixed-pitch string to the temporary
; buffer. Assumes this is a horizontal string, so the origins of all glyphs
; are at the same Y coordinate. Draws leftmost glyph entirely with MOVs,
; even if it's not aligned, in order to ensure that the leftmost byte
; gets cleared when we're working with butted characters. For other
; non-aligned glyphs, leftmost byte is ORed, other bytes are MOVed.
;
; Input:
;       pGlyphPos = pointer to array of GLYPHPOS structures to draw
;       ulGlyphCount = # of glyphs to draw
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       ulCharInc = offset from one glyph to next (fixed-pitch only)
;       fDrawFlags = indicate the type of text to be drawn
;       Temp buffer zeroed if text doesn't cover every single pixel
;
; Fixed-pitch means equal spacing between glyph positions, not that all
; glyphs butt together or equal spacing between upper left corners.
;-----------------------------------------------------------------------;

        mov     ebx,prclText
        sub     eax,eax

;-----------------------------------------------------------------------;
; Handle all cases other than 8-wide byte-aligned.
;-----------------------------------------------------------------------;

general_handler:
        mov     esi,pdsurf
        mov     eax,[ebx].yTop
        mov     ulTempTop,eax   ;Y screen coordinate of top edge of temp buf
        mov     eax,[ebx].xLeft
        and     eax,not 7
        mov     ulTempLeft,eax  ;X screen coordinate of left edge of temp buf
        mov     eax,[esi].dsurf_lNextScan
        mov     ulScreenDelta,eax

        mov     eax,fDrawFlags

        jmp     MasterTextTypeTable[eax*4]

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer (we assume the text is
                                        ; right at the top of the text rect
                                        ; and hence the buffer)
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_f_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        jmp     short draw_to_temp_start_entry

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_nf_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
draw_to_temp_start_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte in temp buffer

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableNarrow[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableWide[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_f_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        jmp     short draw_to_temp_start_entry2

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_nf_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
draw_to_temp_start_entry2::
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
        mov     ulYOrigin,eax           ;remember the Y origin of all glyphs
                                        ; (necessary because glyph positions
                                        ; after first aren't set for fixed-
                                        ; pitch strings)
        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,SIZE_GLYPHPOS       ;point to the next glyph (the one
        mov     pGlyphPos,ebx           ; we're going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        jmp     short draw_to_temp_loop_entry

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,SIZE_GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer

draw_to_temp_loop_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableNarrow[eax*4] ;branch to draw the first glyph;
                                            ; need to OR the 1st byte if
                                            ; non-aligned to avoid overwriting
                                            ; what's already there
@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableWide[eax*4] ;branch to draw the next glyph;
                                          ; need to OR the 1st byte if
                                          ; non-aligned to avoid overwriting
                                          ; what's already there

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,SIZE_GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits

        mov     eax,ulYOrigin           ;dest Y coordinate
        jmp     short draw_to_temp_loop_entry2

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,SIZE_GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
draw_to_temp_loop_entry2::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer

        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the next glyph

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the next glyph

;-----------------------------------------------------------------------;
; Routines to draw all scans of a single glyph into the temp buffer,
; optimized for the following cases:
;
;       1 to 4 byte-wide destination rectangles for each of:
;               No rotation needed
;               Rotation needed, same # of source as dest bytes needed
;               Rotation needed, one less source than dest bytes needed
;
; Additionally, the three cases are handled for 5 and wider cases by a
; general routine for each case.
;
; If rotation is needed, there are three sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) The leftmost byte is ORed into the existing byte. Succeeding bytes are
;    MOVed. This is generally used after the leftmost glyph, because this may
;    not be the first data written to that byte.
; 3) All bytes are ORed. This is for drawing when characters might overlap.
;
; If rotation is not needed, there are two sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) All bytes are ORed. This is for drawing when characters might overlap.
;
; On entry:
;       EBX = # of scans to copy
;       CL  = right rotation
;       EDX = ulBufDelta = width per scan of destination buffer, in bytes
;       ESI = pointer to first glyph byte
;       EDI = pointer to first dest buffer byte
;       DF  = cleared
;       ulGlyDelta = width per scan of source glyph, in bytes (wide case only)
;       ulWidthInBytes = width of glyph, in bytes (required only for 5 and
;               wider cases)
;
; On exit:
;       Any or all of EAX, EBX, ECX, EDX, ESI, and EDI may be trashed.

;-----------------------------------------------------------------------;
; OR first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
or_all_1_wide_rotated_need_last::
or_all_1_wide_rotated_no_last::
or_first_1_wide_rotated_need_last::
or_first_1_wide_rotated_no_last::
or_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        or      [edi],ch
        add     edi,edx
        dec     ebx
        jnz     or_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_rotated_need_last::
mov_first_1_wide_rotated_no_last::
mov_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        mov     [edi],ch
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_unrotated::
mov_first_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_1_wide_unrotated::
or_all_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     or_all_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_need_last::
or_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],al
        mov     [edi+1],ah
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_need_last::
or_all_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_need_last::
mov_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_no_last::
or_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     ah,[esi]
        inc     esi
        shr     eax,cl
        or      [edi],ah
        mov     [edi+1],al
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_no_last::
or_all_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_no_last::
mov_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_2_wide_unrotated::
mov_first_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_2_wide_unrotated::
or_all_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        or      [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        or      [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        mov     [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        xchg    ah,al
        or      [edi+1],ax
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_3_wide_unrotated::
@@:
        mov     ax,[esi]
        mov     [edi],ax
        mov     al,[esi+2]
        add     esi,3
        mov     [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_3_wide_unrotated::
@@:
        mov     ax,[esi]
        or      [edi],ax
        mov     al,[esi+2]
        add     esi,3
        or      [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    al,ah
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        mov     eax,ulWidthInBytes
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        or      [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwr_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

odd_width::
        shr     eax,1           ;width in dwords
        jc      short three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;because we won't advance after last byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cl,[esi]
        inc     esi
        mov     [edi],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

two_odd_bytes::
        add     edx,2           ;because we won't advance after last word
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        add     esi,2
        mov     [edi],cx
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

three_odd_bytes::
        add     edx,3           ;because we won't advance after last word/byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        add     esi,3
        mov     [edi+2],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short or_odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short or_two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
or_no_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_no_odd_bytes_loop
        jmp     pGlyphLoop

or_odd_width::
        shr     eax,1           ;width in dwords
        jc      short or_three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;skip over last byte too
or_one_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cl,[esi]
        or      [edi],cl
        inc     esi
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_one_odd_bytes_loop
        jmp     pGlyphLoop

or_two_odd_bytes::
        add     edx,2           ;skip over last 2 bytes too
or_two_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        add     esi,2
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_two_odd_bytes_loop
        jmp     pGlyphLoop

or_three_odd_bytes::
        add     edx,3           ;skip over last 3 bytes too
or_three_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        mov     cl,[esi+2]
        or      [edi+2],cl
        add     esi,3
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_three_odd_bytes_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer.
; Now, draw the extra rectangles to the temp buffer.
;
; Input:
;       pdsurf = pointer to target surface (screen)
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       iFgColor = text color
;       iBgColor = opaquing rectangle color, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
glyphs_are_done::
extra_rects_are_done::
exit_fast_text::

        cRet    vFastText

endProc vFastText

public draw_f_tb_no_to_temp_start
public draw_nf_tb_no_to_temp_start
public draw_to_temp_start_entry
public draw_f_ntb_o_to_temp_start
public draw_nf_ntb_o_to_temp_start
public draw_to_temp_start_entry2
public draw_f_tb_no_to_temp_loop
public draw_nf_tb_no_to_temp_loop
public draw_to_temp_loop_entry
public draw_f_ntb_o_to_temp_loop
public draw_nf_ntb_o_to_temp_loop
public draw_to_temp_loop_entry2
public or_all_1_wide_rotated_need_last
public or_all_1_wide_rotated_no_last
public or_first_1_wide_rotated_need_last
public or_first_1_wide_rotated_no_last
public or_first_1_wide_rotated_loop
public mov_first_1_wide_rotated_need_last
public mov_first_1_wide_rotated_no_last
public mov_first_1_wide_rotated_loop
public mov_first_1_wide_unrotated
public mov_first_1_wide_unrotated_loop
public or_all_1_wide_unrotated
public or_all_1_wide_unrotated_loop
public or_first_2_wide_rotated_need_last
public or_first_2_wide_rotated_need_loop
public or_all_2_wide_rotated_need_last
public or_all_2_wide_rotated_need_loop
public mov_first_2_wide_rotated_need_last
public mov_first_2_wide_rotated_need_loop
public or_first_2_wide_rotated_no_last
public or_first_2_wide_rotated_loop
public or_all_2_wide_rotated_no_last
public or_all_2_wide_rotated_loop
public mov_first_2_wide_rotated_no_last
public mov_first_2_wide_rotated_loop
public mov_first_2_wide_unrotated
public mov_first_2_wide_unrotated_loop
public or_all_2_wide_unrotated
public or_all_2_wide_unrotated_loop
public or_first_3_wide_rotated_need_last
public or_all_3_wide_rotated_need_last
public mov_first_3_wide_rotated_need_last
public or_first_3_wide_rotated_no_last
public or_all_3_wide_rotated_no_last
public mov_first_3_wide_rotated_no_last
public mov_first_3_wide_unrotated
public or_all_3_wide_unrotated
public or_first_4_wide_rotated_need_last
public or_all_4_wide_rotated_need_last
public mov_first_4_wide_rotated_need_last
public or_first_4_wide_rotated_no_last
public or_all_4_wide_rotated_no_last
public mov_first_4_wide_rotated_no_last
public mov_first_4_wide_unrotated
public or_all_4_wide_unrotated
public or_first_N_wide_rotated_need_last
public or_all_N_wide_rotated_need_last
public mov_first_N_wide_rotated_need_last
public or_first_N_wide_rotated_no_last
public or_all_N_wide_rotated_no_last
public mov_first_N_wide_rotated_no_last
public mov_first_N_wide_unrotated
public odd_width
public two_odd_bytes
public three_odd_bytes
public or_all_N_wide_unrotated
public or_no_odd_bytes_loop
public or_odd_width
public or_one_odd_bytes_loop
public or_two_odd_bytes
public or_two_odd_bytes_loop
public or_three_odd_bytes
public or_three_odd_bytes_loop
public glyphs_are_done
public exit_fast_text

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\overblend.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: alphaimg.asm
;
; Inner loop for alpha blending
; See alphablt.cxx:vAlphaPerPixelOnly() for explanation
;   of algorithm.
;
; Created: 12-Mar-1997
; Author: Mark Enstrom
;
; Copyright (c) 1997-1999 Microsoft Corporation
;-----------------------------------------------------------------------;


        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        include gdii386.inc



ovr_DstLast     equ 000H
ovr_EDI         equ 004H
ovr_ESI         equ 008H
ovr_EDX         equ 00cH
ovr_ECX         equ 010H
ovr_EBX         equ 014H
ovr_ppixEBP     equ 018H
ovr_RA          equ 01cH
ovr_ppixDst     equ 020H
ovr_ppixSrc     equ 024H
ovr_cx          equ 028H
ovr_Blend       equ 02cH

ble_ConstAlpha  equ 000H
ble_LastX       equ 004H
ble_EDI         equ 008H
ble_ESI         equ 00cH
ble_EDX         equ 010H
ble_ECX         equ 014H
ble_EBX         equ 018H
ble_EBP         equ 01cH
ble_RA          equ 020H
ble_ppixDst     equ 024H
ble_ppixSrc     equ 028H
ble_cx          equ 02cH
ble_Blend       equ 030H

ble16_tSrc        equ 000H
ble16_tDst        equ 004H
ble16_ConstAlpha  equ 008H
ble16_LastX       equ 00cH
ble16_EDI         equ 010H
ble16_ESI         equ 014H
ble16_EDX         equ 018H
ble16_ECX         equ 01cH
ble16_EBX         equ 020H
ble16_EBP         equ 024H
ble16_RA          equ 028H
ble16_ppixDst     equ 02cH
ble16_ppixSrc     equ 030H
ble16_cx          equ 034H
ble16_Blend       equ 038H

;
; locals
;


        .list



;------------------------------------------------------------------------------;

        .code


_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;------------------------------------------------------------------------------;

;------------------------------------------------------------------------------;
; vAlphaPerPixelOnly
;
;   Blend source and destination scan line. Source and destination are 32bpp
;   BGRA scan lines.
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;
;
;   VOID
;   vPixelOver(
;       ALPHAPIX       *ppixDst,
;       ALPHAPIX       *ppixSrc,
;       LONG           cx,
;       BLENDFUNCTION  BlendFunction
;       )
;   {
;       ALPHAPIX pixSrc;
;       ALPHAPIX pixDst;
;
;       while (cx--)
;       {
;           pixSrc = *ppixSrc;
;
;           if (pixSrc.pix.a != 0)
;           {
;               pixDst = *ppixDst;
;
;               if (pixSrc.pix.a == 255)
;               {
;                   pixDst = pixSrc;
;               }
;               else
;               {
;                   long    SrcTran = 255 - pixSrc->a;
;                   PBYTE   pTable = &pAlphaMulTable[SrcTran * 256];
;
;                   pixDst->r = pixSrc->r + *(pTable + pixDst->r);
;                   pixDst->g = pixSrc->g + *(pTable + pixDst->g);
;                   pixDst->b = pixSrc->b + *(pTable + pixDst->b);
;                   pixDst->a = pixSrc->a + *(pTable + pixDst->a);
;               }
;
;               *pwrMask = 1;
;               *ppixDst = pixDst;
;           }
;
;           pwrMask++;
;           ppixSrc++;
;           ppixDst++;
;       }
;   }
;
;
;

;
; parameters
;



        public  vAlphaPerPixelOnly@16

vAlphaPerPixelOnly@16 proc near


        ;
        ; use ebp as general register
        ;

        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi
        sub     esp,4

        mov     ecx,ovr_cx[esp]         ; ecx = pixel count
        mov     edi,ovr_ppixDst[esp]    ; edi = destination address
        shl     ecx,2                   ; ecx = DWORD offset
        mov     esi,ovr_ppixSrc[esp]    ; esi = source address
        add     ecx,edi                 ; end dst addr
        cmp     edi,ecx                 ; end of scan line
        mov     ovr_DstLast[esp],ecx    ; save end scan line
        jz      PixelReturn
        
PixelLoop:
	mov     ecx,0FFH                ; ecx = 00 00 00 FF    
        mov     eax,[esi]               ; eax = AA RR GG BB    
	
	mov	edx,eax			; edx = AA RR GG BB
        
	shr     eax,24                  ; eax = 00 00 00 AA    
        add     esi,4                   ; inc src pointer      

        ;
        ; check for alpha == 0 and alpha == 0xff, these
        ; checks allow not writing output pixels that
        ; don't change, but this test decreases performance of the
        ; loop by 10%
        ;

        test    al,al                   ; test for 0
        jz      PixelZeroAlpha          ; jump to 0 quick out
                                        ;
        cmp     al,0ffH                 ; alpha = 0xff
        jz      PixelFFAlpha            ; jump to case ff
                                        
        sub     ecx,eax                 ; ecx = 00 00 00 255-sA
        mov     eax,[edi]               ; eax = dA dR dG dB
        
        mov     ebp,eax                 ; ebp = dA dR dG dB
        and     eax,0FF00FFFFH          ; eax = dA 00 dG dB
        
        shr     eax,8                   ; eax = 00 dA 00 dG
        and     ebp,000FF00FFH          ; ebp = 00 dR 00 dB
        
        imul    ebp,ecx                 ; ebp = dR*sA dB*sA     10 cycle delay
        
	imul    eax,ecx                 ; eax = dA*sA dG*sG     10 cycles
        
        add     ebp,0800080H            ; ebp = ( eR) ( eB)
        add     eax,0800080H            ; ebp = ( eA) ( eG)
        
        mov     ebx,ebp                 ; ebx = ( eR) ( eB)
        mov     ecx,eax                 ; ecx = ( eA) ( eG)
        
        and     ebx,0FF00FFFFH          ; ebx = eR 00 ( eB)
        and     ecx,0FF00FFFFH          ; ecx = eA 00 ( eG)
        
        shr     ebx,8                   ; ebx = 00 eR 00 eB
        add     edi,4                   ; inc dst pointer
        
        shr     ecx,8                   ; ecx = 00 eA 00 eG
        add     ebx,ebp                 ; ebx = ( eR) ( eB)
        
        and     ebx,0FF00FFFFH          ; ebx = eR 00 ( eB)
        add     ecx,eax                 ; ecx = ( eA) ( eG)
        
        mov     eax,ovr_DstLast[esp]
	and     ecx,0FF00FF00H          ; ecx = eA 00 eG 00
        
	shr     ebx,8                   ; ebx = 00 eR 00 eB
        add     ecx,edx                 ; ecx = AA sR GG sB     AA = sA + (1-sA)Da
        
        add     ecx,ebx                 ; ecx = AA RR GG BB
        cmp     edi,eax
        
        mov     [edi-4],ecx             ; save result
        jnz     PixelLoop

        ;
        ; restore stack frame
        ;

PixelReturn:

        add     esp,4
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     16


PixelZeroAlpha:

        mov     eax,ovr_DstLast[esp]    ; end scan line
        add     edi,4                   ; inc dst
	
        cmp     edi,eax                 ; dst == dstEnd
        jnz     PixelLoop               ; loop

        jmp     PixelReturn

PixelFFAlpha:

        mov     ecx,ovr_DstLast[esp]    ; end scan line
        mov     [edi],edx               ; write pixel
        add     edi,4                   ; inc dst pointer
        cmp     edi,ecx
        jnz     PixelLoop

        jmp     PixelReturn




vAlphaPerPixelOnly@16 endp


;------------------------------------------------------------------------------;
; vAlphaConstOnly
;
;   Dst = Dst + Alpha * (Src - Dst)
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

;
; parameters
;

        public  vAlphaConstOnly@16
        
vAlphaConstOnly@16 proc near

        ;
        ; use ebp as general register
        ;
        
        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi  
        sub     esp,8


        movzx   eax,BYTE PTR ble_Blend+2[esp]
        mov     ebx,ble_cx[esp]         ; ebx = pixel count
        mov     edi,ble_ppixDst[esp]    ; edi = destination address
        mov     esi,ble_ppixSrc[esp]    ; esi = source address
        lea     edx,[edi + 4 * ebx]     ; edx = last dst address
        
        cmp     edi,edx                 ; end of scan line
        jz      BlendReturn
        
        mov     ble_LastX[esp],edx      ; save end x address

BlendLoop:

        mov     ebx,[edi]               ; ebx = D aa rr gg bb
        mov     ecx,[esi]               ; ecx = S aa rr bb bb
        and     ebx,000ff00ffH          ; ebx = D 00 rr 00 bb
        and     ecx,000ff00ffH          ; ecx = S 00 rr 00 bb
        
        mov     ebp,ebx                 ; ebp = D 00 rr 00 bb
        sub     ecx,ebx                 ; ecx = s 00 rr 00 bb
        imul    ecx,eax                 ; ecx =   rr rr bb bb      u
        shl     ebp,8                   ; ebp = D rr 00 bb 00      u
        mov     edx,[edi]               ; edx = D aa rr gg bb        v
        and     edx,0ff00ff00H          ; edx = D aa 00 gg 00      u
        sub     ebp,ebx                 ; ebp = D rr ee bb ee        v
        shr     edx,8                   ; edx = D 00 aa 00 gg      u
        add     ecx,000800080H          ; ecx =   rr rr bb bb + e    v
        add     ecx,ebp                 ; ecx =   rr rr bb bb      u
        mov     ebp,[esi]               ; ebp = S aa rr gg bb        v
        shr     ebp,8                   ; ebp = S ?? aa rr gg      u
        mov     ebx,ecx                 ; ebx =   rr rr bb bb        v
        and     ecx,0ff00ff00H          ; ecx =   rr 00 bb 00      u
        and     ebp,000ff00ffH          ; ebp = S 00 aa 00 gg        v
        shr     ecx,8                   ; ecx =   00 rr 00 bb      u
        sub     ebp,edx                 ; ebp =   del a del g        v
        add     ebx,ecx                 ; ebx =   rr rr bb bb      u
        mov     ecx,edx                 ; ecx = D 00 aa 00 gg        v
        imul    ebp,eax                 ; ebp = m aa aa gg gg      u
        shl     ecx,8                   ; ecx = D aa 00 gg 00      u
        and     ebx,0FF00FF00H          ; ebx =   rr 00 bb 00        v
        add     ebp,000800080H          ; ebp = m aa aa gg gg      u
        sub     ecx,edx                 ; ecx = D aa 00 gg 00        v
        shr     ebx,8                   ; ebx =   00 rr 00 bb      u
        add     ecx,ebp                 ; ecx = M aa aa gg gg        v
        mov     edx,ecx                 ; edx = M aa aa gg gg      u  
        and     ecx,0ff00ff00H          ; ecx = M aa 00 gg 00        v
        shr     ecx,8                   ; ecx = M 00 aa 00 gg      u
        add     esi,4                   ; inc src to next pixel      v
        add     ecx,edx                 ; ecx = M aa aa gg gg      u
        mov     ebp,ble_LastX[esp]      ; ebp = Last X Dst addr      v
        and     ecx,0FF00FF00H          ; ecx = D aa 00 gg 00      u
        add     edi,4                   ; inc dst addr               v
        or      ecx,ebx                 ; ecx = D aa rr gg bb      u
        cmp     edi,ebp                 ;                            v
        mov     [edi-4],ecx             ; store dst pixel          u
        jnz     BlendLoop               ;                            v
        

        ;
        ; restore stack frame
        ;

BlendReturn:

        add     esp,8
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     16
        
vAlphaConstOnly@16 endp

;------------------------------------------------------------------------------;
; vAlphaConstOnly16_555
;
;   Dst = Dst + Alpha * (Src - Dst)
;
;   Source and destination are 16 bpp 555 format
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

;
; parameters
;

        public  vAlphaConstOnly16_555@16

vAlphaConstOnly16_555@16 proc near

        ;
        ; use ebp as general register
        ;
        
        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi  
        sub     esp,16

        movzx   eax,BYTE PTR ble16_Blend+2[esp]
        mov     ebx,ble16_cx[esp]       ; ebx = pixel count
        mov     edi,ble16_ppixDst[esp]  ; edi = destination address
        mov     esi,ble16_ppixSrc[esp]  ; esi = source address
        lea     edx,[edi + 2 * ebx]     ; edx = last dst address
        
        cmp     edi,edx                 ; end of scan line
        jz      BlendReturn_16
        
        mov     ble16_LastX[esp],edx    ; save end x address

BlendLoop_16:

        movzx   ebx,WORD PTR[edi]       ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        movzx   ecx,WORD PTR[esi]       ; ecx = S 0000 0000 0rrr rrgg gggb bbbb 
        
        mov     ble16_tDst[esp],ebx
        mov     ble16_tSrc[esp],ecx
        
        and     ebx,000007c1fH          ; ebx = D 0000 0000 0rrr rr00 000b bbbb
        and     ecx,000007c1fH          ; ecx = S 0000 0000 0rrr rr00 000b bbbb 
        
        mov     ebp,ebx                 ; ebp = D 0000 0000 0rrr rr00 000b bbbb  
        sub     ecx,ebx                 ; ecx = s 0000 0000 0RRR RR00 000B BBBB
        imul    ecx,eax                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb 
        shl     ebp,5                   ; ebp = D 0000 rrrr r000 00bb bbb0 0000
        mov     edx,ble16_tDst[esp]     ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        and     edx,0000003e0H          ; edx = D 0000 0000 0000 00gg ggg0 0000 
        sub     ebp,ebx                 ; ebp = D 0000 RRRR R000 00BB BBB0 0000 D*(32-1)
        shr     edx,5                   ; edx = D 0000 0000 0000 0000 000g gggg NOT NEEDED!
        add     ecx,000004010H          ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb + error
        add     ecx,ebp                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ebp,ble16_tSrc[esp]     ; ecx = S 0000 0000 0rrr rrgg gggb bbbb 
        shr     ebp,5                   ; ebp = S 0000 0000 0000 00rr rrrg gggg NOT NEEDED
        mov     ebx,ecx                 ; ebx = M 
        and     ecx,0000F83E0H          ; ecx = M 0000 RRRR R000 00BB BBB0 0000
        and     ebp,00000001fH          ; ebp = S 0000 0000 0000 0000 000g gggg
        shr     ecx,5                   ; ecx = M 0000 0000 0RRR RR00 000B BBBB
        sub     ebp,edx                 ; ebp =DG 0000 0000 0000 0000 000g gggg (sG-dG)
        add     ebx,ecx                 ; ebx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ecx,edx                 ; ecx = D 0000 0000 0000 0000 000g gggg
        imul    ebp,eax                 ; ebp = M 0000 0000 0000 00GG GGGg gggg alpha * (sG-dG)
        shl     ecx,5                   ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 32
        and     ebx,0000f83e0H          ; ebx = M 0000 RRRR R000 00BB BBB0 0000
        add     ebp,000004010H          ; ebp = M 0000 0000 0000 00GG GGGg gggg + error
        sub     ecx,edx                 ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 31
        shr     ebx,5                   ; ebx = M 0000 0000 0RRR RR00 000B BBBB
        add     ecx,ebp                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     edx,ecx                 ; edx = M 0000 0000 0000 00GG GGGg gggg
        and     ecx,0000003e0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000 NOT NEEDED
        shr     ecx,5                   ; ecx = M 0000 0000 0000 0000 000G GGGG
        add     esi,2                   ; inc src to next pixel      v
        add     ecx,edx                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     ebp,ble16_LastX[esp]      ; ebp = Last X Dst addr      v
        and     ecx,0000003e0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000
        add     edi,2                   ; inc dst addr               v
        or      ecx,ebx                 ; ecx = D 0000 0000 0RRR RRGG GGGB BBBB
        cmp     edi,ebp                 ;                            v
        mov     [edi-2],cx              ; store dst pixel          u
        jnz     BlendLoop_16            ;                            v

        ;
        ; restore stack frame
        ;

BlendReturn_16:

        add     esp,16
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     16
        
vAlphaConstOnly16_555@16 endp


;------------------------------------------------------------------------------;
; vAlphaConstOnly16_565
;
;   Dst = Dst + Alpha * (Src - Dst)
;
;   Source and destination are 16 bpp 565 format
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

;
; parameters
;

        public  vAlphaConstOnly16_565@16

vAlphaConstOnly16_565@16 proc near

        ;
        ; use ebp as general register
        ;
        
        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi  
        sub     esp,16

        movzx   eax,BYTE PTR ble16_Blend+2[esp]
        mov     ebx,ble16_cx[esp]         ; ebx = pixel count
        mov     edi,ble16_ppixDst[esp]    ; edi = destination address
        mov     esi,ble16_ppixSrc[esp]    ; esi = source address
        lea     edx,[edi + 2 * ebx]     ; edx = last dst address
        
        cmp     edi,edx                 ; end of scan line
        jz      BlendReturn_16
        
        mov     ble16_LastX[esp],edx      ; save end x address

BlendLoop_16:

        movzx   ebx,WORD PTR[edi]       ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        movzx   ecx,WORD PTR[esi]       ; ecx = S 0000 0000 0rrr rrgg gggb bbbb 
        
        mov     ble16_tDst[esp],ebx
        mov     ble16_tSrc[esp],ecx
        
        and     ebx,00000f81fH          ; ebx = D 0000 0000 0rrr rr00 000b bbbb
        and     ecx,00000f81fH          ; ecx = S 0000 0000 0rrr rr00 000b bbbb 
        
        mov     ebp,ebx                 ; ebp = D 0000 0000 0rrr rr00 000b bbbb  
        sub     ecx,ebx                 ; ecx = s 0000 0000 0RRR RR00 000B BBBB
        imul    ecx,eax                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb 
        shl     ebp,5                   ; ebp = D 0000 rrrr r000 00bb bbb0 0000
        mov     edx,ble16_tDst[esp]     ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        and     edx,0000007e0H          ; edx = D 0000 0000 0000 00gg ggg0 0000 
        sub     ebp,ebx                 ; ebp = D 0000 RRRR R000 00BB BBB0 0000 D*(32-1)
        shr     edx,5                   ; edx = D 0000 0000 0000 0000 000g gggg NOT NEEDED!
        add     ecx,000008010H          ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb + error
        add     ecx,ebp                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ebp,ble16_tSrc[esp]     ; ecx = S 0000 0000 0rrr rrgg gggb bbbb 
        shr     ebp,5                   ; ebp = S 0000 0000 0000 00rr rrrg gggg NOT NEEDED
        mov     ebx,ecx                 ; ebx = M 
        and     ecx,0001f03E0H          ; ecx = M 0000 RRRR R000 00BB BBB0 0000
        and     ebp,00000003fH          ; ebp = S 0000 0000 0000 0000 000g gggg
        shr     ecx,5                   ; ecx = M 0000 0000 0RRR RR00 000B BBBB
        sub     ebp,edx                 ; ebp =DG 0000 0000 0000 0000 000g gggg (sG-dG)
        add     ebx,ecx                 ; ebx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ecx,edx                 ; ecx = D 0000 0000 0000 0000 000g gggg
        imul    ebp,eax                 ; ebp = M 0000 0000 0000 00GG GGGg gggg alpha * (sG-dG)
        shl     ebp,1                   ; ConstAlpha *2
        shl     ecx,6                   ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 32
        and     ebx,0001f03e0H          ; ebx = M 0000 RRRR R000 00BB BBB0 0000
        add     ebp,000000020H          ; ebp = M 0000 0000 0000 00GG GGGg gggg + error
        sub     ecx,edx                 ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 31
        shr     ebx,5                   ; ebx = M 0000 0000 0RRR RR00 000B BBBB
        add     ecx,ebp                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     edx,ecx                 ; edx = M 0000 0000 0000 00GG GGGg gggg
        and     ecx,000000fc0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000 NOT NEEDED
        shr     ecx,6                   ; ecx = M 0000 0000 0000 0000 000G GGGG
        add     esi,2                   ; inc src to next pixel      v
        add     ecx,edx                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     ebp,ble16_LastX[esp]      ; ebp = Last X Dst addr      v
        and     ecx,000000fc0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000
        add     edi,2                   ; inc dst addr               v
        shr     ecx,1                   ;       D 0000 0000 0000 0GGG GGG0 0000
        or      ecx,ebx                 ; ecx = D 0000 0000 0RRR RRGG GGGB BBBB
        cmp     edi,ebp                 ;                            v
        mov     [edi-2],cx              ; store dst pixel          u
        jnz     BlendLoop_16            ;                            v

        ;
        ; restore stack frame
        ;

BlendReturn_16:

        add     esp,16
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     16
        
vAlphaConstOnly16_565@16 endp



_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\locka.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: lock.asm                                                 ;
;                                                                       ;
; Contains the ASM versions of locking routines.                        ;
;                                                                       ;
; Copyright (c) 1992-1999 Microsoft Corporation                         ;
;-----------------------------------------------------------------------;

        .386
        .model  small

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        include gdii386.inc
        .list

if GDIPLUS

        ; See hmgrapi.cxx

else

        .data

if DBG
  HL_AlreadyLocked    db     'HmgLock Error: GDI handle already locked by another thread',10,0
  HL_OverFlowShareRef db     'Hmg Error: GDI handle share reference count over flowed',10,0
endif


_DATA   SEGMENT DWORD PUBLIC 'DATA'

        public _GDIpLockPrefixTable
_GDIpLockPrefixTable    label dword
        dd offset FLAT:Lock1
        dd offset FLAT:Lock4
        dd offset FLAT:Lock5
        dd offset FLAT:Lock6
        dd offset FLAT:Lock7
        dd offset FLAT:Lock8
        dd 0
_DATA   ENDS




OBJECTOWNER_LOCK     equ          1h ; First bit of the objectowner
OBJECTOWNER_PID      equ  0fffffffeh ; The PID bits

        .code

extrn   _gpentHmgr:dword             ; Address of ENTRY array.
extrn   _gcMaxHmgr:dword
extrn   _gpLockShortDelay:dword      ; Pointer to global constant 10 ms delay

if DBG
        extrn   _DbgPrint:proc
        EXTRNP  _HmgPrintBadHandle,2
endif

        EXTRNP  _KeDelayExecutionThread,3
        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  _PsGetCurrentProcessId,0

;------------------------------Public-Routine------------------------------;
; HmgInterlockedCompareAndSwap(pul,ulong0,ulong1)
;
;  Compare *pul with ulong1, if equal then replace with ulong2 interlocked
;
; Returns:
;   EAX = 1 if memory written, 0 if not
;
;--------------------------------------------------------------------------;
;
        public  @HmgInterlockedCompareAndSwap@12
@HmgInterlockedCompareAndSwap@12    proc    near

        mov     eax,edx
        mov     edx,[esp]+4
        .486
Lock1:
lock    cmpxchg [ecx],edx
        .386
        jnz     Return_Zero

        mov     eax,1
        ret     4

Return_Zero:
        xor     eax,eax
        ret     4

@HmgInterlockedCompareAndSwap@12    endp

;------------------------------Public-Routine------------------------------;
; HmgLock (hobj,objt)
;
; Lock a user object.
;
; Input:
;   EAX -- scratch
;   ECX -- hobj
;   EDX -- objt
;
; Returns:
;   EAX = pointer to locked object
;
; Error Return:
;   EAX = 0, No error logged.
;
; History:
;  14-Jun-1995 -by- J. Andrew Goossen [andrewgo]
; Rewrote for Kernel Mode.
;
;  20-Dec-1993 -by- Patrick Haluptzok [patrickh]
; Move lock counts into object.
;
;  23-Sep-1993 -by- Michael Abrash [mikeab]
; Tuned ASM code.
;
;    -Sep-1992 -by- David Cutler [DaveC]
; Write HmgAltLock, HmgAltCheckLock, and HmgObjtype in ASM.
;
;  Thu 13-Aug-1992 13:21:47 -by- Charles Whitmer [chuckwh]
; Wrote it in ASM.  The common case falls straight through.
;
;  Wed 12-Aug-1992 17:38:27 -by- Charles Whitmer [chuckwh]
; Restructured the C code to minimize jumps.
;
;  29-Jun-1991 -by- Patrick Haluptzok patrickh
; Wrote it.
;--------------------------------------------------------------------------;

        public @HmgLock@8
@HmgLock@8 proc near
        push    ebx                                 ;Preserve register in call
    if DBG
        push    ecx                                 ;Stash hobj for debugging
        push    edx                                 ;Stash objt for debugging
    endif
        push    ecx                                 ;Stash hobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        dec     WORD PTR [ebx].ThKernelApcDisable

        and     ecx,INDEX_MASK
        cmp     ecx,_gcMaxHmgr
        jae     HmgLock_bad_handle_before_lock

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgLock_resume::

        ; Perf: It would be nice if we could avoid these word size overrides,
        ;       but unfortunately objectowner_Pid is currently a non-dword
        ;       aligned offset.

        mov     ebx,[ecx].entry_ObjectOwner
        stdCall _PsGetCurrentProcessId,<>
        and     eax,OBJECTOWNER_PID
        and     ebx,OBJECTOWNER_PID
        cmp     eax,ebx
        jne     HmgLock_check_for_public_owner

HmgLock_after_check_for_public_owner::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock4:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgLock_delay

        ; The handle is now locked

        cmp     dl,[ecx].entry_Objt
        pop     eax
        jnz     HmgLock_bad_handle_after_lock

        ; Perf: If FullUnique were kept on an odd word-boundary, we could
        ;       avoid the shift word compare and instead do a 32 bit 'xor'
        ;       and 'and':

        shr     eax,TYPE_SHIFT
        cmp     ax,[ecx].entry_FullUnique
        jnz     HmgLock_bad_handle_after_lock

        mov     eax,[ecx].entry_einfo
        mov     edx,fs:[PcPrcbData].PbCurrentThread     ;edx ->KeGetCurrentThread()
        cmp     word ptr [eax].object_cExclusiveLock,0  ;Note, testing here...
                                                                                                        ;cExclusiveLock is a USHORT

        jnz     HmgLock_check_if_same_thread  ;...and jumping here
        mov     byte ptr [eax].object_cExclusiveLock,1
                                                    ;We can do a byte move
                                                    ;  because we know it was
                                                    ;  a zero word before
HmgLock_after_same_thread::
        mov     [eax].object_Tid,edx
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

        ; eax is set to the proper return value

HmgLock_incAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        inc     WORD PTR [ebx].ThKernelApcDisable
        jz      HmgLock_LeaveCriticalRegion

HmgLock_Done::

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

; Roads less travelled...

HmgLock_check_for_public_owner:
        test    ebx,ebx
        .errnz  OBJECT_OWNER_PUBLIC
        jz      HmgLock_after_check_for_public_owner

HmgLock_bad_handle_before_lock::
        pop     ecx
        jmp     HmgLock_bad_handle

HmgLock_bad_handle_after_lock::
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgLock_bad_handle:
    if DBG
        ; Retrieve the debug copies of 'hobj' and 'objt' from where they
        ; were pushed on the stack:

        mov     eax,[esp]                           ;objt
        mov     ecx,[esp+4]                         ;hobj

        ; Call a debug routine that prints a warning, complete with
        ; the name of the owning process, handle value, and expected type.

        stdCall _HmgPrintBadHandle,<ecx,eax>
    endif
        xor     eax,eax
        jmp     HmgLock_incAPC

HmgLock_check_if_same_thread::
        inc     dword ptr [eax].object_cExclusiveLock   ; cExclusiveLock is USHORT
        cmp     edx,[eax].object_Tid                    ; but dword operation is faster on P5
        je      HmgLock_after_same_thread               ; than a word operation

; Error case if already locked:

        dec     dword ptr [eax].object_cExclusiveLock   ; same remark as for inc above
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it
    if DBG
        push    offset HL_AlreadyLocked
        call    _DbgPrint
        add     esp,4
    endif
        jmp     HmgLock_bad_handle

HmgLock_delay::
        push    ecx
        push    edx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     edx
        pop     ecx
        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        jmp     HmgLock_resume

HmgLock_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgLock_CallInterrupt

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

HmgLock_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgLock_Done

@HmgLock@8 endp

;------------------------------Public-Routine------------------------------;
; HmgShareCheckLock (hobj,objt)
;
; Acquire a share lock on an object, PID owner must match current PID
; or be a public.
;
; Input:
;   EAX -- scratch
;   ECX -- hobj
;   EDX -- objt
;
; Returns:
;   EAX = pointer to referenced object
;
; Error Return:
;   EAX = 0, No error logged.
;
;--------------------------------------------------------------------------;

        public @HmgShareCheckLock@8
@HmgShareCheckLock@8 proc near
        push    ebx                                 ;Preserve register in call
    if DBG
        push    ecx                                 ;Stash hobj for debugging
        push    edx                                 ;Stash objt for debugging
    endif
        push    ecx                                 ;Stash hobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        dec     WORD PTR [ebx].ThKernelApcDisable

        and     ecx,INDEX_MASK
        cmp     ecx,_gcMaxHmgr
        jae     HmgShareCheckLock_bad_handle_before_lock

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgShareCheckLock_resume::

        ; Perf: It would be nice if we could avoid these word size overrides,
        ;       but unfortunately objectowner_Pid is currently a non-dword
        ;       aligned offset.

        mov     ebx,[ecx].entry_ObjectOwner
        stdCall _PsGetCurrentProcessId,<>
        and     eax,OBJECTOWNER_PID
        and     ebx,OBJECTOWNER_PID
        cmp     eax,ebx
        
        jne     HmgShareCheckLock_check_for_public_owner

HmgShareCheckLock_after_check_for_public_owner::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock5:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgShareCheckLock_delay

        ; The handle is now locked

        cmp     dl,[ecx].entry_Objt
        pop     eax
        jnz     HmgShareCheckLock_bad_handle_after_lock

        ; Perf: If FullUnique were kept on an odd word-boundary, we could
        ;       avoid the shift word compare and instead do a 32 bit 'xor'
        ;       and 'and':

        shr     eax,TYPE_SHIFT
        cmp     ax,[ecx].entry_FullUnique
        jnz     HmgShareCheckLock_bad_handle_after_lock
        mov     eax,[ecx].entry_einfo               ;Get pointer to object
    if DBG
        cmp     [eax].object_ulShareCount, 0ffffffffH       ;Check for overflow
        jne     HmgShareCheckLock_go
        push    offset HL_OverFlowShareRef
        call    _DbgPrint
        add     esp,4
        int     3
HmgShareCheckLock_go:   
    endif       
        inc     DWORD PTR [eax].object_ulShareCount     
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it


HmgShareCheckLock_IncAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        inc     WORD PTR [ebx].ThKernelApcDisable
        jz      HmgShareCheckLock_LeaveCriticalRegion

        ; eax is set to the proper return value

HmgShareCheckLock_Done::
    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

; Roads less travelled...

HmgShareCheckLock_check_for_public_owner:
        test    ebx,ebx
        .errnz  OBJECT_OWNER_PUBLIC
        jz      HmgShareCheckLock_after_check_for_public_owner
HmgShareCheckLock_bad_handle_before_lock::
        pop     ecx
        jmp     HmgShareCheckLock_bad_handle

HmgShareCheckLock_bad_handle_after_lock::
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgShareCheckLock_bad_handle::
    if DBG
        ; Retrieve the debug copies of 'hobj' and 'objt' from where they
        ; were pushed on the stack:

        mov     eax,[esp]                           ;objt
        mov     ecx,[esp+4]                         ;hobj

        ; Call a debug routine that prints a warning, complete with
        ; the name of the owning process, handle value, and expected type.

        stdCall _HmgPrintBadHandle,<ecx,eax>
    endif
        xor     eax,eax
        jmp     HmgShareCheckLock_IncAPC

HmgShareCheckLock_delay::
        push    ecx
        push    edx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     edx
        pop     ecx
        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        jmp     HmgShareCheckLock_resume

HmgShareCheckLock_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgShareCheckLock_CallInterrupt

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

HmgShareCheckLock_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgShareCheckLock_Done

@HmgShareCheckLock@8 endp

;------------------------------Public-Routine------------------------------;
; HmgShareLock (obj,objt)
;
;
; Acquire a share lock on an object, don't check PID owner
;
; Input:
;   EAX -- scratch
;   ECX -- hobj
;   EDX -- objt
;
; Returns:
;   EAX = pointer to referenced object
;
; Error Return:
;   EAX = 0, No error logged.
;
;--------------------------------------------------------------------------;

        public @HmgShareLock@8
@HmgShareLock@8 proc near
        push    ebx                                 ;Preserve register in call
    if DBG
        push    ecx                                 ;Stash hobj for debugging
        push    edx                                 ;Stash objt for debugging
    endif
        push    ecx                                 ;Stash hobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        dec     WORD PTR [ebx].ThKernelApcDisable

        and     ecx,INDEX_MASK
        cmp     ecx,_gcMaxHmgr
        jae     HmgShareLock_bad_handle_before_lock

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgShareLock_resume::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock6:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgShareLock_delay

        ; The handle is now locked

        cmp     dl,[ecx].entry_Objt
        pop     eax
        jnz     HmgShareLock_bad_handle_after_lock

        ; Perf: If FullUnique were kept on an odd word-boundary, we could
        ;       avoid the shift word compare and instead do a 32 bit 'xor'
        ;       and 'and':

        shr     eax,TYPE_SHIFT
        cmp     ax,[ecx].entry_FullUnique
        jnz     HmgShareLock_bad_handle_after_lock
        mov     eax,[ecx].entry_einfo               ;Get pointer to object
    if DBG
        cmp     [eax].object_ulShareCount, 0ffffffffH       ;Check for overflow
        jne     HmgShareLock_go
        push    offset HL_OverFlowShareRef
        call    _DbgPrint
        add     esp,4
        int     3
HmgShareLock_go:        
    endif       
        inc     DWORD PTR [eax].object_ulShareCount     
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgShareLock_incAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        inc     WORD PTR [ebx].ThKernelApcDisable
        jz      HmgShareLock_LeaveCriticalRegion

HmgShareLock_Done::

        ; eax is set to the proper return value

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

; Roads less travelled...

HmgShareLock_bad_handle_before_lock::
        pop     ecx
        jmp     HmgShareLock_bad_handle

HmgShareLock_bad_handle_after_lock::
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgShareLock_bad_handle::
    if DBG
        ; Retrieve the debug copies of 'hobj' and 'objt' from where they
        ; were pushed on the stack:

        mov     eax,[esp]                           ;objt
        mov     ecx,[esp+4]                         ;hobj

        ; Call a debug routine that prints a warning, complete with
        ; the name of the owning process, handle value, and expected type.

        stdCall _HmgPrintBadHandle,<ecx,eax>
    endif
        xor     eax,eax
        jmp     HmgShareLock_incAPC

HmgShareLock_delay::
        push    ecx
        push    edx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     edx
        pop     ecx
        jmp     HmgShareLock_resume

HmgShareLock_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgShareLock_CallInterrupt

    if DBG
        pop     ebx                                 ;Remove debug copy of objt
        pop     ebx                                 ;Remove debug copy of hobj
    endif
        pop     ebx
        ret

HmgShareLock_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgShareLock_Done

@HmgShareLock@8 endp

;------------------------------Public-Routine------------------------------;
; HmgIncrementShareReferenceCount (pobj)
;
;
; Increment shared reference count, no checking
;
; Input:
;   EAX -- scratch
;   ECX -- pobj
;
; Returns:
;   EAX = pointer to referenced object
;
; Error Return:
;   EAX = 0, No error logged.
;
;--------------------------------------------------------------------------;

        public @HmgIncrementShareReferenceCount@4
@HmgIncrementShareReferenceCount@4 proc near
        push    ebx                                 ;Preserve register in call
        push    ecx                                 ;Stash pobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        dec     WORD PTR [ebx].ThKernelApcDisable

        mov     ecx, [ecx]
        and     ecx,INDEX_MASK

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgIncrementShareReferenceCount_resume::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock7:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgIncrementShareReferenceCount_delay

        ; The handle is now locked
        mov     eax,[ecx].entry_einfo               ;Get pointer to object

        inc     DWORD PTR [eax].object_ulShareCount     
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgIncrementShareReferenceCount_incAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        inc     WORD PTR [ebx].ThKernelApcDisable
        jz      HmgIncrementShareReferenceCount_LeaveCriticalRegion

HmgIncrementShareReferenceCount_Done::

        ; eax is set to the proper return value

        pop     ecx
        pop     ebx
        ret

; Roads less travelled...

HmgIncrementShareReferenceCount_delay::
        push    ecx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     ecx
        jmp     HmgIncrementShareReferenceCount_resume

HmgIncrementShareReferenceCount_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgIncrementShareReferenceCount_CallInterrupt

        pop     ecx
        pop     ebx
        ret

HmgIncrementShareReferenceCount_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgIncrementShareReferenceCount_Done

@HmgIncrementShareReferenceCount@4 endp

;------------------------------Public-Routine------------------------------;
; HmgDecrementShareReferenceCount (pobj)
;
;
; Decrement shared reference count, no checking
;
; Input:
;   EAX -- scratch
;   ECX -- pobj
;
; Returns:
;
; Error Return:
;   EAX = 0, No error logged.
;
;--------------------------------------------------------------------------;

        public @HmgDecrementShareReferenceCount@4
@HmgDecrementShareReferenceCount@4 proc near
        push    ebx                                 ;Preserve register in call
        push    ecx                                 ;Stash pobj for later

        ; KeEnterCriticalRegion
        ; KeGetCurrentThread()->KernelApcDisable -= 1;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;eax -> KeGetCurrentThread()
        dec     WORD PTR [ebx].ThKernelApcDisable

        mov     ecx, [ecx]
        and     ecx,INDEX_MASK

        shl     ecx,4
        .errnz  size ENTRY - 16
        add     ecx,_gpentHmgr                      ;ecx -> Entry

HmgDecrementShareReferenceCount_resume::
        mov     eax,[ecx].entry_ObjectOwner
        mov     ebx,[ecx].entry_ObjectOwner
        and     eax,NOT OBJECTOWNER_LOCK
        or      ebx,OBJECTOWNER_LOCK

        .486
Lock8:
lock    cmpxchg [ecx].entry_ObjectOwner,ebx
        .386
        mov     ebx,eax                             ;Remember unlock value
        jnz     HmgDecrementShareReferenceCount_delay

        ; The handle is now locked
        mov     edx,[ecx].entry_einfo               ;Get pointer to object

        mov     eax, [edx].object_ulShareCount
        dec     DWORD PTR [edx].object_ulShareCount     
        mov     [ecx].entry_ObjectOwner,ebx         ;Unlock it

HmgDecrementShareReferenceCount_incAPC::

        ; KiLeaveCriticalRegion  (eax must be preseerved)
        ;
        ; #define KiLeaveCriticalRegion() {                                       \
        ;     PKTHREAD Thread;                                                    \
        ;     Thread = KeGetCurrentThread();                                      \
        ;     if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) && \
        ;         (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
        ;          &Thread->ApcState.ApcListHead[KernelMode])) {                  \
        ;         Thread->ApcState.KernelApcPending = TRUE;                       \
        ;         KiRequestSoftwareInterrupt(APC_LEVEL);                          \
        ;     }                                                                   \
        ; }
        ;

        mov     ebx,fs:[PcPrcbData].PbCurrentThread ;ebx -> KeGetCurrentThread()
        inc     WORD PTR [ebx].ThKernelApcDisable
        jz      HmgDecrementShareReferenceCount_LeaveCriticalRegion

HmgDecrementShareReferenceCount_Done::

        ; eax is set to the proper return value
        pop     ecx
        pop     ebx
        ret

; Roads less travelled...

HmgDecrementShareReferenceCount_delay::
        push    ecx
        mov     eax,_gpLockShortDelay
        stdCall _KeDelayExecutionThread,<KernelMode,0,eax>
        pop     ecx
        jmp     HmgDecrementShareReferenceCount_resume

HmgDecrementShareReferenceCount_LeaveCriticalRegion::
        lea     ecx,[ebx].ThApcState+AsApcListHead
        mov     edx,[ecx].LsFlink
        cmp     ecx,edx
        jne     HmgDecrementShareReferenceCount_CallInterrupt

        pop     ecx
        pop     ebx
        ret

HmgDecrementShareReferenceCount_CallInterrupt::

        lea     ecx,[ebx].ThApcState
        mov     BYTE PTR [ecx].AsKernelApcPending,1
        push    eax
        mov     ecx,APC_LEVEL
        fstCall HalRequestSoftwareInterrupt
        pop     eax
        jmp     HmgDecrementShareReferenceCount_Done

@HmgDecrementShareReferenceCount@4 endp


_TEXT   ends

endif

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\str.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: str.asm
;
; Same format, no translation stretch blt inner loop
;
; Created: 17-Oct-1994
; Author: Mark Enstrom
;
; Copyright (c) 1994-1999 Microsoft Corporation
;-----------------------------------------------------------------------;


        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include gdii386.inc
;
;  stack based params and local variables
;

sp_TempXFrac           equ 000H
sp_YCarry              equ 004H
sp_LeftCase            equ 008H
sp_RightCase           equ 00CH
sp_pjSrcScan           equ 010H
sp_SrcIntStep          equ 014H
sp_DstStride           equ 018H
sp_XCount              equ 01CH
sp_ebp                 equ 020H
sp_esi                 equ 024H
sp_edi                 equ 028H
sp_ebx                 equ 02CH
sp_RetAddr             equ 030H
sp_pSTR_BLT            equ 034H

        .list

;------------------------------------------------------------------------------;

        .code


_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;------------------------------------------------------------------------------;

;------------------------------------------------------------------------------;
; vDirectStretch8
;
;   Stretcg 8 to 8
;
; Entry:
;
;   pSTR_BLT - pointer to stretch blt parameter block
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING   This routine uses EBP as a general variable.
;           Also, if parameters are changed, the ret statement must
;           also be fixed
;
;------------------------------------------------------------------------------;

        public vDirectStretch8@4

vDirectStretch8@4 proc near

        ;
        ;  use ebp as general register, use esp for parameter and local access
        ;  save ebp,ebx,esi,edi

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,8 * 4

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        add     esi,[ebp].str_XSrcStart                 ; add strarting Src Pixel
        mov     edi,[ebp].str_pjDstScan                 ; load dst DIB pointer
        add     edi,[ebp].str_XDstStart                 ; add strarting Dst Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     dword ptr [ebp].str_lDeltaSrc           ; calc scan line int lines to step
	mov	[esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     eax,edi                                 ; make copy of pjDst
        and     eax,3                                   ; calc left edge case
        mov     edx,4                                   ; calc left bytes = (4 - LeftCase) & 0x03
        sub     edx,eax                                 ; 4 - LeftCase
        and     edx,3                                   ; left edge bytes
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels (4-LeftCase)&0x03
        mov     eax,[ebp].str_pjDstScan                 ; make copy
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        add     eax,ecx                                 ; ending dst addr
        and     eax,3                                   ; calc right edge case
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count
        mov     ebx,[ebp].str_lDeltaDst                 ; dst scan line stride
        sub     ebx,ecx                                 ; distance from end of one line to start of next
        mov     [esp].sp_DstStride,ebx                  ; save dst scan line stride
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,2                                   ; convert from byte to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

LoopTop::

        ;
        ; can 2 scan dst lines be drawn from 1 src?
        ;

        xor     ebx,ebx                                 ; zero ebx
	mov	eax,[ebp].str_ulYFracAccumulator	; get .32 part of Y pointer
	add	eax,[ebp].str_ulYDstToSrcFracCeil	; add in fractional step
        adc     ebx,0
        mov     [esp].sp_YCarry,ebx                     ; save carry for end of loop
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        cmp     [esp].sp_SrcIntStep,0                   ; int step must be zero
        jne     SingleLoop

        cmp     ebx,0                                   ; carry must be zero
        jne     SingleLoop

        cmp     [ebp].str_YDstCount,2                   ; y count must be at least 2
        jl      SingleLoop

        ;
        ; there was no carry, draw 2 dst scan lines. Add 1 extra y Frac, and subtract
        ; one extra Y Count
        ;

	add	eax,[ebp].str_ulYDstToSrcFracCeil	; add in fractional step
        adc     ebx,0                                   ; get new carry
        mov     [esp].sp_YCarry,ebx                     ; save carry for end of loop
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator
	dec	dword ptr [ebp].str_YDstCount           ; dec y count

        ;
        ; Draw 2 Dst scan lines from 1 src scan
        ;

	mov	eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
	mov	edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

	mov	ebx,[ebp].str_lDeltaDst                 ; Get Dst Scan line delta
        mov	ebp,edi				        ; get dst pointer to ebp (ebp uses ss:)

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

	mov	edi,edx				        ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

	; esi = pointer to source pixel
	; ebp = pointer to dest pixel
	; ecx = Left edge case
	; eax = integer step in source
	; ebx = Dst scan line delta
	; edi = fractional accumulator
	; edx = free for pixel data

        ;
	; first do the left side to align dwords
        ;

        cmp     ecx,0
        je      DualDwordAligned

DualLeftEdge:

	mov	dl,[esi]				; fetch pixel
	mov	[ebp],dl				; write it out
	mov	[ebp+ebx],dl				; write it out to next scan line
	add	edi,[esp].sp_tempXFrac                  ; step fraction
	adc	esi,eax					; add in integer and possible carry
	inc	ebp					; step 1 in dest
        dec     ecx                                     ; dec and repeat for left edge
        jne     DualLeftEdge

DualDwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length

@@:
	mov	dl,[esi]				; get a source pixel edx = ???0
        add     edi,[esp].sp_tempXFrac                  ; step fraction
	adc	esi,eax					; add integer and carry

        add     edi,[esp].sp_tempXFrac                  ; step fraction
	mov	dh,[esi]				; get source pixel edx = ??10
	adc	esi,eax					; add integer and carry

	shl     edx,16  				; edx = 10??

        add     edi,[esp].sp_tempXFrac                  ; step fraction
	mov	dl,[esi]				; get a source pixel edx = 10?2
	adc	esi,eax					; add integer and carry

        add     edi,[esp].sp_tempXFrac                  ; step fraction
	mov	dh,[esi]				; get source pixel edx = 0132
	adc	esi,eax					; add integer and carry

	ror     edx,16          			; edx = 3210

	mov	[ebp],edx			        ; write everything to dest
	mov	[ebp+ebx],edx			        ; write everything to dest plus 1 scan line

	add	ebp,4					; increment dest pointer by 2 dwords
	dec	ecx					; decrement count
	jnz	@b     					; do more pixels

DualRightEdge:

        ;
	; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        cmp     ecx,0
        je      DualAddScanLine

@@:
	mov	dl,[esi]				; fetch pixel
	mov	[ebp],dl				; write it out
	mov	[ebp+ebx],dl				; write it out to next scan line
        add     edi,[esp].sp_tempXFrac                  ; step fraction
	adc	esi,eax					; add in integer and possible carry
	inc	ebp					; step 1 in dest
        dec     ecx
        jne     @B

        ;
        ; add one extra lDeltaDst (ebx) tp ebp for the
        ; extra dst scan line
        ;

DualAddScanLine:

        add     ebp,ebx

        jmp     EndScanLine                             ; skip to end

        ;
        ; Expand and draw 1 scan line
        ;

SingleLoop:

	mov	eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
	mov	ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
	mov	edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

	mov	ebp,edi				        ; get dst pointer to ebp (ebp uses ss:)

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

	mov	edi,edx				        ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

	; esi = pointer to source pixel
	; ebp = pointer to dest pixel
	; ecx = Left edge case
	; eax = integer step in source
	; ebx = fractional step in source
	; edi = fractional accumulator
	; edx = free for pixel data

        ;
	; first do the left side to align dwords
        ;

        cmp     ecx,0
        je      DwordAligned

@@:
	mov	dl,[esi]				; fetch pixel
	mov	[ebp],dl				; write it out
	add	edi,ebx					; step fraction
	adc	esi,eax					; add in integer and possible carry
	inc	ebp					; step 1 in dest
        dec     ecx                                     ; dec left count
        jne     @B                                      ; repeat until done

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length

@@:
	mov	dl,[esi]				; get a source pixel edx = ???0
	add	edi,ebx					; step fraction
	adc	esi,eax					; add integer and carry

	add	edi,ebx					; step fraction
	mov	dh,[esi]				; get source pixel edx = ??10
	adc	esi,eax					; add integer and carry

	shl     edx,16  				; edx = 10??

	add	edi,ebx					; step fraction
	mov	dl,[esi]				; get a source pixel edx = 10?2
	adc	esi,eax					; add integer and carry

	add	edi,ebx					; step fraction
	mov	dh,[esi]				; get source pixel edx = 0132
	adc	esi,eax					; add integer and carry

	ror     edx,16          			; edx = 3210

	mov	[ebp],edx			        ; write everything to dest

	add	ebp,4					; increment dest pointer by 1 dword
	dec	ecx					; decrement count
	jnz	@b     					; do more pixels

        ;
	; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        cmp     ecx,0
        je      EndScanLine

@@:

	mov	dl,[esi]				; fetch pixel
	mov	ss:[ebp],dl				; write it out
	add	edi,ebx					; step fraction
	adc	esi,eax					; add in integer and possible carry
	inc	ebp					; step 1 in dest
        dec     ecx                                     ; dec right count
        jnz     @b                                      ; repeat until done

EndScanLine:

	mov	edi,ebp					; get dst pointer back
        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        cmp     [esp].sp_YCarry,1                       ; is there a carry
	jne	@f	                                ; no additional int step

	add	esi,[ebp].str_lDeltaSrc		        ; step one extra in src
@@:
	add	esi,[esp].sp_SrcIntStep			; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
	add	edi,[esp].sp_DstStride		        ; step to next scan in dst
	dec	dword ptr [ebp].str_YDstCount
	jnz	LoopTop


        add     esp,8*4
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vDirectStretch8@4 endp

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\wow6432\makefile.inc ===
!if "$(TARGET_DIRECTORY)" == "i386"
PRIVATEINCS= $(PROJECT_ROOT)\$(SRCBASE)\ntgdi\math\wow6432\$(TARGET_H_DIRECTORY)\efloat.hxx
!else
PRIVATEINCS= $(PROJECT_ROOT)\$(SRCBASE)\ntgdi\math\daytona\$(TARGET_H_DIRECTORY)\efloat.hxx
!endif

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\tiler.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: tiler.asm
;
; Helper routines for P, Pn and DPx tiling algorithm.
;
; Created: 28-Jan-1992 10:20:08
; Author: Donald Sidoroff [donalds]
;
; Copyright (c) 1992-1999 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
        include gdii386.inc
        .list

        .code

;---------------------------Private-Routine-----------------------------;
; vFetchAndCopy
;
;   Fetch one row of a pattern and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchAndCopy,4,<       \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     edx,[ebp].ff_culFill

        or      ebx,ebx                 ; Are we at start of pattern?
        jz      vfc_copy_body

vfc_copy_head:
        mov     eax,[esi+ebx]
        stosd

        dec     edx
        jz      vfc_done

        add     ebx,4
        cmp     ebx,[ebp].ff_cxPat
        jne     vfc_copy_head

vfc_copy_body:
        mov     ecx,[ebp].ff_culWidth

        sub     edx,ecx
        jl      vfc_copy_tail

        rep     movsd

        mov     esi,[ebp].ff_pvPat       ; Reset this
        jmp     vfc_copy_body

vfc_copy_tail:
        add     edx,ecx
        mov     ecx,edx                 ; This many left!

        rep     movsd

vfc_done:
        pop     ebp

        cRet    vFetchAndCopy

endProc vFetchAndCopy

;---------------------------Private-Routine-----------------------------;
; vFetchShiftAndCopy
;
;   Fetch one row of a pattern and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchShiftAndCopy,4,<  \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     eax,[ebp].ff_culFill
        mov     [ebp].ff_culFillTmp,eax      ; Copy can be trashed

vfsc_loop:
        mov     ecx,ebx
        and     ebx,NOT 3                   ; Align to DWORD

        and     ecx,3                       ; Shift this many bytes
        shl     ecx,3

        mov     eax,[esi+ebx]               ; Prime the pipeline

vfsc_in_pipeline:
        mov     edx,[esi+ebx+4]

        shrd    eax,edx,cl
        stosd

        dec     dword ptr [ebp].ff_culFillTmp          ; Are we done?
        jz      vfsc_done

        add     dword ptr [ebp].ff_xPat,4    ; Advance position in pattern
        mov     ebx,[ebp].ff_xPat
        cmp     ebx,[ebp].ff_cxPat
        jge     vfsc_blow_out

        and     ebx,NOT 3                   ; Align to DWORD

        mov     eax,edx                     ; Pipeline is valid, use it
        jmp     vfsc_in_pipeline


vfsc_blow_out:
        sub     ebx,[ebp].ff_cxPat           ; Reset position in pattern
        mov     [ebp].ff_xPat,ebx
        jmp     vfsc_loop                   ; Restart pipeline

vfsc_done:
        pop     ebp

        cRet    vFetchShiftAndCopy

endProc vFetchShiftAndCopy

;---------------------------Private-Routine-----------------------------;
; vFetchNotAndCopy
;
;   Fetch one row of a pattern, negate it and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchNotAndCopy,4,<    \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     edx,[ebp].ff_culFill

        or      ebx,ebx                 ; Are we at start of pattern?
        jz      vfnc_copy_body

vfnc_copy_head:
        mov     eax,[esi+ebx]
        not     eax
        stosd

        dec     edx
        jz      vfnc_done

        add     ebx,4
        cmp     ebx,[ebp].ff_cxPat
        jne     vfnc_copy_head

vfnc_copy_body:
        mov     ecx,[ebp].ff_culWidth

        sub     edx,ecx
        jl      vfnc_copy_tail

@@:
        lodsd
        not     eax
        stosd
        loop    @B

        mov     esi,[ebp].ff_pvPat       ; Reset this
        jmp     vfnc_copy_body

vfnc_copy_tail:
        add     edx,ecx
        jz      vfnc_done
        mov     ecx,edx                 ; This many left!

@@:
        lodsd
        not     eax
        stosd
        loop    @B

vfnc_done:
        pop     ebp

        cRet    vFetchNotAndCopy

endProc vFetchNotAndCopy

;---------------------------Private-Routine-----------------------------;
; vFetchShiftNotAndCopy
;
;   Fetch one row of a pattern and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchShiftNotAndCopy,4,<   \
        uses    ebx esi edi,        \
        pff:    ptr FETCHFRAME      >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     eax,[ebp].ff_culFill
        mov     [ebp].ff_culFillTmp,eax      ; Copy can be trashed

vfsnc_loop:
        mov     ecx,ebx
        and     ebx,NOT 3                   ; Align to DWORD

        and     ecx,3                       ; Shift this many bytes
        shl     ecx,3

        mov     eax,[esi+ebx]               ; Prime the pipeline

vfsnc_in_pipeline:
        mov     edx,[esi+ebx+4]

        shrd    eax,edx,cl
        not     eax
        stosd

        dec     dword ptr [ebp].ff_culFillTmp ; Are we done?
        jz      vfsnc_done

        add     dword ptr [ebp].ff_xPat,4    ; Advance position in pattern
        mov     ebx,[ebp].ff_xPat
        cmp     ebx,[ebp].ff_cxPat
        jge     vfsnc_blow_out

        and     ebx,NOT 3                   ; Align to DWORD

        mov     eax,edx                     ; Pipeline is valid, use it
        jmp     vfsnc_in_pipeline

vfsnc_blow_out:
        sub     ebx,[ebp].ff_cxPat           ; Reset position in pattern
        mov     [ebp].ff_xPat,ebx
        jmp     vfsnc_loop                  ; Restart pipeline

vfsnc_done:
        pop     ebp

        cRet    vFetchShiftNotAndCopy

endProc vFetchShiftNotAndCopy

;---------------------------Private-Routine-----------------------------;
; vFetchAndMerge
;
;   Fetch one row of a pattern and copy it.
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchAndMerge,4,<      \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     edx,[ebp].ff_culFill

        or      ebx,ebx                 ; Are we at start of pattern?
        jz      vfm_copy_body

vfm_copy_head:
        mov     eax,[esi+ebx]
        xor     [edi],eax
        add     edi,4

        dec     edx
        jz      vfm_done

        add     ebx,4
        cmp     ebx,[ebp].ff_cxPat
        jne     vfm_copy_head

vfm_copy_body:
        mov     ecx,[ebp].ff_culWidth

        sub     edx,ecx
        jl      vfm_copy_tail

@@:
        lodsd
        xor     [edi],eax
        add     edi,4
        loop    @B

        mov     esi,[ebp].ff_pvPat       ; Reset this
        jmp     vfm_copy_body

vfm_copy_tail:
        add     edx,ecx
        jz      vfm_done
        mov     ecx,edx                 ; This many left!

@@:
        lodsd
        xor     [edi],eax
        add     edi,4
        loop    @B

vfm_done:
        pop     ebp

        cRet    vFetchAndMerge

endProc vFetchAndMerge

;---------------------------Private-Routine-----------------------------;
; vFetchShiftAndMerge
;
;   Fetch one row of a pattern and XOR it into destination
;
; Entry:
;       IN  pff     Points to a 'fetch' frame.
; Returns:
;       Nothing.
; Registers Destroyed:
;       EAX, ECX, EDX
; Calls:
;       None
; History:
;  28-Jan-1992 -by- Donald Sidoroff [donalds]
; Wrote it
;-----------------------------------------------------------------------;

cProc   vFetchShiftAndMerge,4,< \
        uses    ebx esi edi,    \
        pff:    ptr FETCHFRAME  >

        push    ebp

        mov     ebp,pff

        mov     edi,[ebp].ff_pvTrg
        mov     esi,[ebp].ff_pvPat
        mov     ebx,[ebp].ff_xPat
        mov     eax,[ebp].ff_culFill
        mov     [ebp].ff_culFillTmp,eax      ; Copy can be trashed

vfsm_loop:
        mov     ecx,ebx
        and     ebx,NOT 3                   ; Align to DWORD

        and     ecx,3                       ; Shift this many bytes
        shl     ecx,3

        mov     eax,[esi+ebx]               ; Prime the pipeline

vfsm_in_pipeline:
        mov     edx,[esi+ebx+4]

        shrd    eax,edx,cl
        xor     [edi],eax
        add     edi,4

        dec     dword ptr [ebp].ff_culFillTmp ; Are we done?
        jz      vfsm_done

        add     dword ptr [ebp].ff_xPat,4    ; Advance position in pattern
        mov     ebx,[ebp].ff_xPat
        cmp     ebx,[ebp].ff_cxPat
        jge     vfsm_blow_out

        and     ebx,NOT 3                   ; Align to DWORD

        mov     eax,edx                     ; Pipeline is valid, use it
        jmp     vfsm_in_pipeline

vfsm_blow_out:
        sub     ebx,[ebp].ff_cxPat           ; Reset position in pattern
        mov     [ebp].ff_xPat,ebx
        jmp     vfsm_loop                   ; Restart pipeline

vfsm_done:
        pop     ebp

        cRet    vFetchShiftAndMerge

endProc vFetchShiftAndMerge

    end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\ia64\tiler.cxx ===
/*******************************Module*Header*****************************\
* 
*  Copyright (c) 1992-1999  Microsoft Corporation
*  Copyright (c) 1992  Digital Equipment Corporation
* 
*  Module Name:
* 
*     tiler.cxx
* 
*  Abstract:
* 
*     This module implements code to copy a pattern to a target surface.
* 
*  Author:
* 
*    David N. Cutler (davec) 4-May-1992
* 
*  Rewritten in C by:
* 
*    Eric Rehm (rehm@zso.dec.com) 15-July-1992
* 
*  Environment:
* 
*     User mode only.
* 
*  Revision History:
* 
\*************************************************************************/

#include "precomp.hxx"

VOID CopyPattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat);
VOID MergePattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat);



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern.
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }

      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = *pulPatCur;       // set target to 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchAndCopy



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (P).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   UNALIGNED *pulPat;                      // base pattern address
    ULONG   UNALIGNED *pulPatCur;           // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat));

      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = *pulPatCur;
                                    // set target to 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);

      }
    }
} // end vFetchShiftAndCopy



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchNotAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern
*     using rop (Pn).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchNotAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern
      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }
      loPat = ~loPat;               // complement pattern
      hiPat = ~hiPat;
      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = ~(*pulPatCur);
                      // set target to complement of 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchNotAndCopy



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftNotAndCopy (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (Pn).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftNotAndCopy
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   UNALIGNED *pulPat;      // base pattern address
    ULONG   UNALIGNED *pulPatCur;   // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;
                                    // get low part of 8-byte pattern
      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat));

      loPat = ~loPat;               // complement pattern
      hiPat = ~hiPat;
      CopyPattern( pulTrg, culFill, hiPat, loPat); // do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = ~(*pulPatCur);
                        // set target to complemented 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);

      }
    }
} // end vFetchShiftNotAndCopy


/****************************Private*Routine******************************\
*
*  VOID CopyPattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat)
*
*  Routine Description:
*
*     This routine contains common code for copying an 8-byte pattern to
*     a target surface.
*
*  Arguments:
*
*     culFill - Supplies the size of the fill in bytes.
*     loPat, hiPat - Supplies the 8-byte pattern to copy.
*     pulTrg - Supplies the starting target surface address.
*
*  Return Value:
*
*     None.
*
*
\*************************************************************************/

VOID CopyPattern
(
        PULONG pulTrg,                  // Starting target surface address (t0)
        LONG   culFill,                 // size of fill in longwords (a1)
        LONG   hiPat,                   // hi part of pattern  (v1)
        LONG   loPat                    // lo part of pattern  (v0)
)
{
    PULONG pulTrgEnd;               // ending target surface address
    ULONG temp;                     // temp for swap

    pulTrgEnd = pulTrg + culFill;
                                    // ending target surface address(t4)

//
// If the fill size is not an even multiple of 8 bytes, then move one
// longword and swap the pattern value.
//

    if ((culFill & 0x01) != 0)
    {
      *pulTrg = loPat;              // store low 4 bytes of pattern
      pulTrg += 1;                  // advance target ptr one longword
      culFill -= 1;
      if (culFill == 0)             // if no more to move then we're done
      {
        return;
      }
      else                          // otherwise, swap 8-byte pattern value
      {
        temp = loPat;
        loPat = hiPat;
        hiPat = temp;
      }
    }

//
// Move 8-byte pattern value to target 8 bytes at a time.
//

    pulTrgEnd -= 2;                 // ending segement address
    if ((culFill & 0x02) != 0)      // check if even multiple of 8 bytes
    {
      while (pulTrg <= pulTrgEnd)   // if not, move 8 bytes at a time
      {
        *pulTrg = loPat;            // store 8-byte pattern value
        *(pulTrg + 1) = hiPat;
        pulTrg += 2;                // advance target address
      }
      return;
    }
    else                            //  move 16 bytes at a time
    {
      pulTrgEnd -= 2;               // ending segement address
      while (pulTrg <= pulTrgEnd)
      {
        *pulTrg = loPat;            // store 8-byte pattern value
        *(pulTrg + 1) = hiPat;
        *(pulTrg + 2) = loPat;      // store 8-byte pattern value
        *(pulTrg + 3) = hiPat;
        pulTrg += 4;                // advance target address
      }
    }
}



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchAndMerge (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an aligned pattern
*     using ropt (DPx).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchAndMerge
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    PULONG  pulPat;                 // base pattern address
    PULONG  pulPatCur;              // current pattern address
    PULONG  pulPatEnd;              // ending pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (PULONG) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;           // get low part of 8-byte pattern

      if (xPat == 0)
      {
        hiPat = *(pulPatCur + 1);   // get hi part of 8-byte pattern
      }
      else
      {
        hiPat = *pulPat;            // get hi part of 8-byte pattern
      }

      MergePattern( pulTrg, culFill, hiPat, loPat); //do a 4 or 8-byte copy

    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      pulPatEnd = (PULONG) ((PUCHAR) pulPat + cxPat);
                                    // ending pattern address

      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = (*pulPatCur) ^ (*pulTrg);
                            // XOR 4-byte target with 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        pulPatCur += 1;             // advance the pattern pixel offset

        if (pulPatCur == pulPatEnd) // Check if at end of pattern
        {
          pulPatCur = pulPat;       // get starting pattern address
        }
      }
    }
} // end vFetchAndMerge



/****************************Public*Routine******************************\
*
*  extern "C" VOID
*  vFetchShiftAndMerge (
*     IN PFETCHFRAME pff
*     )
*
*  Routine Description:
*
*     This routine repeatedly tiles one scan line of an unaligned pattern
*     using rop (P).
*
*  Arguments:
*
*     pff  - Supplies a pointer to a fetch frame.
*
*  Return Value:
*
*     None.
*
\*************************************************************************/

extern "C" VOID  vFetchShiftAndMerge
(
        FETCHFRAME *pff
)
{
    PULONG  pulTrg;                 // target surface address
    PULONG  pulTrgEnd;              // ending targe surface address
    ULONG   UNALIGNED *pulPat;                      // base pattern address
    ULONG   UNALIGNED *pulPatCur;           // current pattern address
    ULONG   xPat;                   // pattern offset
    ULONG   cxPat;                  // pattern width in pixels
    ULONG   culFill;                // fill size in longwords
    ULONG   loPat, hiPat;           // low, hi part of 8-byte pattern


    // Make copies of some things

    pulTrg = (PULONG) pff->pvTrg;   // starting target surface address (t0)
    pulPat = (PULONG) pff->pvPat;   // base pattern address  (t1)
    xPat = pff->xPat;               // pattern offset in bytes (t2)
    cxPat = pff->cxPat;             // pattern width in pixels (t3)
    culFill  = pff->culFill;        // Size of fill in longwords

    pulTrgEnd = pulTrg + culFill;   // compute ending target address (t4)
    pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
                                    // compute current pattern address (t5)

    if (cxPat == 8)                 // check if pattern is exactly 8 pels
    {
      loPat = *pulPatCur;
                                    // get low part of 8-byte pattern
      xPat +=4;                     // get hi part of 8-byte pattern
      if (xPat >= cxPat)
      {
          xPat -= cxPat;
      }
      hiPat = *((ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat));

      MergePattern( pulTrg, culFill, hiPat, loPat); //do a 4 or 8-byte copy
    }

    else
    {
    //
    //      The pattern is not 8 bytes in width
    //      or cannot be moved 8 bytes at a time
    //
      while (pulTrg < pulTrgEnd)
      {
        *pulTrg = (*pulPatCur) ^ (*pulTrg);
                            // XOR 4-byte target with 4-byte pattern value
        pulTrg += 1;                // advance the target ptr one longword
        xPat += 4;
        if (xPat >= cxPat)
        {
          xPat -= cxPat;
        }
        pulPatCur = (ULONG UNALIGNED *) ((PUCHAR) pulPat + xPat);
      }
    }
} // end vFetchShiftAndMerge


/****************************Private*Routine******************************\
*
*  VOID MergePattern( PULONG pulTrg, LONG culFill, LONG hiPat, LONG loPat)
*
*  Routine Description:
*
*     This routine contains common code for merging an 8-byte pattern with
*     a target surface.
*
*  Arguments:
*
*     culFill - Supplies the size of the fill in bytes.
*     loPat, hiPat - Supplies the 8-byte pattern to merge.
*     pulTrg - Supplies the starting target surface address.
*
*  Return Value:
*
*     None.
*
*
\*************************************************************************/

VOID MergePattern
(
        PULONG pulTrg,                  // Starting target surface address (t0)
        LONG   culFill,                 // size of fill in longwords (a1)
        LONG   hiPat,                   // hi part of pattern  (v1)
        LONG   loPat                    // lo part of pattern  (v0)
)
{
    PULONG pulTrgEnd;               // ending target surface address
    ULONG temp;                     // temp for swap

    pulTrgEnd = pulTrg + culFill;
                                    // ending target surface address(t4)

//
// If the fill size is not an even multiple of 8 bytes, then move one
// longword and swap the pattern value.
//

    if ((culFill & 0x01) != 0)
    {
      *pulTrg = loPat ^ (*pulTrg);  // XOR low 4 bytes of pattern w/ target
      pulTrg += 1;                  // advance target ptr one longword
      culFill -= 1;
      if (culFill == 0)             // if no more to move then we're done
      {
        return;
      }
      else                          // otherwise, swap 8-byte pattern value
      {
        temp = loPat;
        loPat = hiPat;
        hiPat = temp;
      }
    }

//
// Move 8-byte pattern value to target 8 bytes at a time.
//

    pulTrgEnd -= 2;                 // ending segement address
    while (pulTrg <= pulTrgEnd)     // if not, move 8 bytes at a time
    {
      *pulTrg = loPat ^ (*pulTrg);  // XOR 4-byte pattern value
      pulTrg++;                     // advance target address
      *pulTrg = hiPat ^ (*pulTrg);  // XOR 4-byte pattern value
      pulTrg++;                     // advance target address
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\i386\xline.asm ===
page    ,132
;------------------------------Module-Header-------------------------------;
; Module Name: xline.asm                                                   ;
;                                                                          ;
; Contains the line intersection routine.                                  ;
;                                                                          ;
; Created: 26-Apr-1991 10:49:53                                            ;
; Author: Charles Whitmer [chuckwh]                                        ;
;                                                                          ;
; Copyright (c) 1991-1999 Microsoft Corporation                            ;
;--------------------------------------------------------------------------;

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc
	include gdii386.inc
        .list

        .code

QUAD    struc
        lo      dd      0
        hi      dd      0
QUAD    ends

	extrn	cmp_table_1:dword
	extrn	cmp_table_2:dword
	extrn	cmp_table_3:dword
	extrn	cmp_table_4:dword

;------------------------------Public-Routine------------------------------;
; LONG    fxYIntersect (pptlAB,pptlCD)                                     ;
; POINTL *pptlAB;       // First line segment.                             ;
; POINTL *pptlCD;       // Second line segment.                            ;
;                                                                          ;
; Computes the y coordinate of the intersection of the two line segments.  ;
; The returned value is the ceiling of the exact geometric intersection.   ;
;                                                                          ;
; The intersection is computed by:                                         ;
;                                                                          ;
;           (Cx - Ax)(Cy - Dy) + (Cy - Ay)(Dx - Cx)                        ;
;   lamda = ---------------------------------------                        ;
;           (Bx - Ax)(Cy - Dy) + (By - Ay)(Dx - Cx)                        ;
;                                                                          ;
; If (lamda < 0) or (lamda > 1) then there is no intersection, and we      ;
; return 0x80000000.                                                       ;
;                                                                          ;
;   Y = Ay + lamda * (By - Ay)                                             ;
;                                                                          ;
; We assume on entry to this routine that all coordinates are limited to   ;
; 31 bits of significance.  Because of this we know that quantities like   ;
; (Cx - Ax) will fit in 32 bits.  Also, products like (Cx - Ax)(Cy - Dy)   ;
; will fit in 63 bits, and sums as in the numerator of lamda will fit in   ;
; 64 bits.                                                                 ;
;                                                                          ;
; Note that if you call this routine with POINTFX's instead of POINTL's    ;
; you'll get answers that are correct down to 1/16th pel.  If you only     ;
; want the integer part, just shift the answer right by 4 bits.            ;
;                                                                          ;
; History:                                                                 ;
;  Wed 25-Sep-1991 16:52:20 -by- Wendy Wu [wendywu]                        ;
; 1) Changed to return the ceiling of the geometric intersection rather    ;
;    than the floor.                                                       ;
; 2) When the given two line segments are actually the same line, we used  ;
;    to return 0x80000000, now return the y at which they last "intersect".;
; 3) If Y is bigger or smaller than both Cy and Dy, return 0x80000000.     ;
;                                                                          ;
;  Fri 26-Apr-1991 10:52:28 -by- Charles Whitmer [chuckwh]                 ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

SEGAB   struc
        AB_xA   dd      0
        AB_yA   dd      0
        AB_xB   dd      0
        AB_yB   dd      0
SEGAB   ends

SEGCD   struc
        CD_xC   dd      0
        CD_yC   dd      0
        CD_xD   dd      0
        CD_yD   dd      0
SEGCD   ends

cProc   fxYIntersect,8,<          \
        uses    ebx esi edi,      \
        pptlAB: ptr SEGAB,        \
        pptlCD: ptr SEGCD         >

local   xA:     dword
local   yA:     dword
local   yByA:   dword
local   qDenom: qword

; Load AB into registers.

        mov     esi,pptlAB
        mov     ebx,[esi].AB_yA
        mov     edx,[esi].AB_yB
        mov     eax,[esi].AB_xA
        mov     ecx,[esi].AB_xB

; Reorder AB so that By >= Ay.  This will guarantee that (By - Ay)*lamda is a
; positive number so that it's easier to compute the ceiling.  (This lets us
; complete the division earlier than a normal extended precision one.)

        cmp     edx,ebx
        jg      @F
        xchg    eax,ecx
        xchg    ebx,edx
@@:

; Save A locally.

        mov     xA,eax
        mov     yA,ebx

; Compute qDenom = (Bx - Ax)(Cy - Dy) + (By - Ay)(Dx - Cx).

        sub     edx,ebx                 ; EDX = (By - Ay)
        mov     esi,pptlCD
        sub     ecx,eax                 ; ECX = (Bx - Ax)
        mov     eax,[esi].CD_xD
        mov     yByA,edx
        sub     eax,[esi].CD_xC         ; EAX = (Dx - Cx)
        imul    edx                     ; EDX:EAX = (By - Ay)(Dx - Cx)
        xchg    ecx,edx                 ; EDX = (Bx - Ax)
        mov     ebx,eax                 ; ECX:EBX = (By - Ay)(Dx - Cx)
        mov     eax,[esi].CD_yC
        sub     eax,[esi].CD_yD         ; EAX = (Cy - Dy)
        imul    edx                     ; EDX:EAX = (Bx - Ax)(Cy - Dy)
        add     ebx,eax
        jz      qDenom_maybe_zero
        adc     ecx,edx                 ; ECX:EBX = qDenom

qDenom_not_zero:
        mov     qDenom.lo,ebx
        mov     qDenom.hi,ecx

; Compute qNum = (Cx - Ax)(Cy - Dy) + (Cy - Ay)(Dx - Cx).

        mov     edx,[esi].CD_yC
        sub     edx,yA                  ; EDX = (Cy - Ay)
        mov     eax,[esi].CD_xD
        sub     eax,[esi].CD_xC         ; EAX = (Dx - Cx)
        imul    edx                     ; EDX:EAX = (Cy - Ay)(Dx - Cx)
        mov     ecx,edx
        mov     ebx,eax                 ; ECX:EBX = (Cy - Ay)(Dx - Cx)
        mov     edx,[esi].CD_xC
        sub     edx,xA                  ; EDX = (Cx - Ax)
        mov     eax,[esi].CD_yC
        sub     eax,[esi].CD_yD         ; EAX = (Cy - Dy)
        imul    edx                     ; EDX:EAX = (Cx - Ax)(Cy - Dy)
        add     eax,ebx
        adc     edx,ecx                 ; EDX:EAX = qNum

; Force the denominator to be positive.

        mov     ebx,qDenom.lo
        mov     ecx,qDenom.hi           ; ECX:EBX = qDenom
        or      ecx,ecx
        jns     @F
        neg     ebx                     ; Negate qDenom.
        adc     ecx,0
        neg     ecx
        neg     eax                     ; Negate qNum.
        adc     edx,0
        neg     edx
        js      no_intersection         ; (qNum < 0) => (lamda < 0)
@@:

; See if (lamda > 1).

        cmp     edx,ecx
        ja      no_intersection         ; (uqNum > uqDenom) => (lamda > 1)
        jb      no_problem
        cmp     eax,ebx
        jbe     no_problem
no_intersection:
        mov     eax,80000000h
        cRet    fxYIntersect

no_problem:

; See if we can do a short form calculation.
; (99% of all cases get handled here.)

        or      ecx,ecx
        jnz     long_form
        mul     yByA                    ; EDX:EAX = (By - Ay) uqNum
        div     ebx                     ; EAX = (By - Ay) uqNum / uqDenom

; Get the ceiling of the intersection by incrementing the quotient
; by 1 if the remainder is bigger than zero.

        cmp     ecx,edx                 ; CF = 1 if (edx > 0)
        adc     eax,0
        add     eax,yA                  ; EAX = CEILING((By - Ay) uqNum /
                                        ;               uqDenom) + Ay
; Compare the intersection y with Cy and Dy.
; Return 0x80000000 if the intersection y is not between Cy and Dy.

cmp_with_cy_dy:
        cmp     eax,[esi].CD_yC
        jg      @F
        jz      done
        cmp     eax,[esi].CD_yD
        jl      no_intersection
        cRet    fxYIntersect
@@:
        cmp     eax,[esi].CD_yD
        jg      no_intersection
done:
        cRet    fxYIntersect
long_form:

; Do the extended precision calculation.

; Count the bits needed to normalize the denominator.

        mov     esi,ecx
        mov     edi,ebx                 ; ESI:EDI = uqDenom.
        xor     ecx,ecx
        cmp     esi,10000h              ; This binary search scheme is a lot
        adc     ecx,ecx                 ; faster than BSR.
        cmp     esi,cmp_table_1[4*ecx]
        adc     ecx,ecx
        cmp     esi,cmp_table_2[4*ecx]
        adc     ecx,ecx
        cmp     esi,cmp_table_3[4*ecx]
        adc     ecx,ecx
        cmp     esi,cmp_table_4[4*ecx]
        adc     ecx,ecx                 ; CL = number of bits to shift left!

; Normalize the denominator and numerator.

        shld    esi,edi,cl
        shl     edi,cl
        shld    edx,eax,cl              ; EDX:EAX = uqNum.
        shl     eax,cl

; Compute uqNum * (By - Ay), a 95 bit result.

        mov     ebx,edx
        mul     yByA
        xchg    eax,ebx
        mov     ecx,edx
        mul     yByA
        add     eax,ecx
        adc     edx,0                   ; EDX:EAX:EBX = (By - Ay) * uqNum

; Divide by the 64 bit uqDenom, we're only interested in the integer part!
; (We would have to worry about overflow in the general case, but we know the
; answer cannot be 0FFFFFFFFh in this case, since (By - Ay) is bounded below
; that.)

        div     esi
        mov     ecx,edx                 ; ECX:EBX = remainder, so far.

; We want to increment the quotient if the remainder is positive.  In this
; case, we want the carry flag set to avoid jumps.  In order to do this,
; instead of calculating the remainder, we calculate the minus remainder.

        mov     esi,eax                 ; Hold quotient temporarily.
        mul     edi
        sub     eax,ebx
        sbb     edx,ecx                 ; EDX:EAX = -remainder

; We don't have enough bits here, since the remainder is unsigned.  We
; therefore use the carry bit instead of a sign bit.  If the carry
; is set, we have a positive remainder.  We'll increment the quotient
; in this case.

; (We have bounded (By - Ay) to be less than 2^31, so we also know that
; the quotient is less than 2^31.  This guarantees that we only have to
; adjust for the quotient once.)

        adc     esi,0
        mov     eax,esi

; Add Ay to the result then compare it with Cy and Dy.

        add     eax,yA
        mov     esi,pptlCD
        jmp     cmp_with_cy_dy

qDenom_maybe_zero:
        adc     ecx,edx                 ; ECX:EBX = qDenom
        jnz     qDenom_not_zero

; These two lines are parallel since qDenom is zero, we have to find out if
; they are actually the same line.
; !!! We may want to change the interface for ulPtOnWhichSide so we call
; !!! it in a more efficient way.  However, this is not a critical path
; !!! so lets wait until performance tuning time. [wendywu]

        mov     esi,pptlAB
        mov     edi,pptlCD

        cCall   ulPtOnWhichSide,<edi,esi>       ; See if C is on SEGAB

        cmp     eax,POINT_ON_LINE
        jnz     no_intersection

; They are indeed the same line, return the last point they meet.
; MIN(MAX(AB_yA, AB_yB), MAX(CD_yC, CD_yD))

        mov     eax,[esi].AB_yA
        cmp     eax,[esi].AB_yB
        jg      @F
        mov     eax,[esi].AB_yB         ; EAX = MAX((AB_yA, AB_yB)
@@:
        mov     ebx,[edi].CD_yC
        cmp     ebx,[edi].CD_yD
        jg      @F
        mov     ebx,[edi].CD_yD         ; EBX = MAX(CD_yC, CD_yD)
@@:
        cmp     eax,ebx
        jl      @F
        mov     eax,ebx
@@:
        cRet    fxYIntersect

endProc fxYIntersect

;------------------------------Public-Routine------------------------------;
; ULONG  ulPtOnWhichSide(pptl,pptlAB)                                      ;
; POINTL *pptl;         // Point in question.                              ;
; POINTL *pptlAB;       // Line segment.                                   ;
;                                                                          ;
; Compute on which side of the line a given point lies.  This is           ;
; determined by the sign of the z component of the cross product of        ;
; the two vectors (pptlB - pptlA) x (pptl - pptlA). i.e. the sign of       ;
;                                                                          ;
; (Bx - Ax) * (y - Ay) - (By - Ay) * (x - Ax)                              ;
;                                                                          ;
; We make sure By >= Ay so the first vector is in the 1st or 2nd quadrant. ;
; If the above product is                                                  ;
;     1) positive -> the given point is on the left side of the line       ;
;     2) negative -> the given point is on the right side of the line      ;
;     3) zero -> the given point is on the given line                      ;
;                                                                          ;
; History:                                                                 ;
;  Wed 25-Sep-1991 16:52:20 -by- Wendy Wu [wendywu]                        ;
; Wrote it.                                                                ;
;--------------------------------------------------------------------------;

cProc   ulPtOnWhichSide,8,<       \
        uses    ebx esi,          \
        pptl:   ptr POINTL,       \
        pptlAB: ptr SEGAB         >

local   yByA:   dword
local   xBxA:   dword

; Load AB into registers.

        mov     esi,pptlAB
        mov     ebx,[esi].AB_yA
        mov     edx,[esi].AB_yB
        mov     ecx,[esi].AB_xA
        mov     eax,[esi].AB_xB

; Reorder AB so that By >= Ay.

        cmp     edx,ebx
        jg      @F
        xchg    eax,ecx
        xchg    ebx,edx
@@:
        sub     eax,ecx                 ; Compute (Bx - Ax)
        mov     xBxA,eax

        sub     edx,ebx                 ; Compute (By - Ay)
        mov     yByA,edx

        mov     esi,pptl
	mov	eax,[esi].ptl_y 	; Compute (y - Ay)
        sub     eax,ebx
        imul    xBxA

        mov     ebx,eax

	mov	eax,[esi].ptl_x 	; Compute (x - Ax)
        sub     eax,ecx

        mov     ecx,edx                 ; ECX:EBX = (Bx - Ax) * (y - Ay)

        imul    yByA                    ; EDX:EAX = (By - Ay) * (x - Ax)

        sub     ebx,eax
        sbb     ecx,edx                 ; ECX:EBX = (Bx - Ax) * (y - Ay) -
        jns     @F                      ;           (By - Ay) * (x - Ax)

        mov     eax,POINT_ON_RIGHT_SIDE ; on the right if negative
        cRet    ulPtOnWhichSide

@@:
        jnz     @F                      ; on the line if zero
        or      ebx,ebx
        jnz     @F
        mov     eax,POINT_ON_LINE
        cRet    ulPtOnWhichSide

@@:
        mov     eax,POINT_ON_LEFT_SIDE  ; on the left if positive
        cRet    ulPtOnWhichSide

endProc ulPtOnWhichSide

;------------------------------Public-Routine------------------------------;
; ULONG  yGetLtoR/yGetRtoL
;
; Compute the ceiling of the y coordinate in integer of a line given the
; x coordinate in FIX.  yB must be bigger than yA.
; plnfx points to a line which must satisfy ptfxLo.y < ptfxHi.y.
; Lines that start from left and end at right, i.e. ptfxLo.x <= ptfxHi.x,
; should use yGetLtoR.
; Lines that start from right and end at left, i.e. ptfxLo.x > ptfxHi.x,
; should use yGetRtoL.
;
; History:
;  02-Dec-1992 -by- Wendy Wu [wendywu]
; Wrote it.
;--------------------------------------------------------------------------;

cProc   yGetLtoR,8,<        \
        uses    ebx,        \
        plnfx:  ptr SEGAB,  \
        x:      dword       >

; Calculate DN = yB - yA

        mov     ebx,plnfx
        mov     eax,[ebx].AB_yB
        sub     eax,[ebx].AB_yA         ; EAX = yB - yA

; Calculate x - xA

        mov     edx,x
        mov     ecx,[ebx].AB_xA
        sub     edx,ecx                 ; EDX = x - xA

        mul     edx                     ; EDX:EAX = (yB - yA) * (x - xA)

; Calculate DM = xB - xA

        sub     ecx,[ebx].AB_xB
        neg     ecx                     ; ECX = xB - xA

; FXTOLONGCEILING(DN * (x - xA) / DM + yA)

        div     ecx

        xor     ecx,ecx                 ; increment by 1 if remainder not 0
        cmp     ecx,edx
        adc     eax,[ebx].AB_yA
        add     eax,15
        sar     eax,4
        cRet    yGetLtoR

endProc yGetLtoR



cProc   yGetRtoL,8,<        \
        uses    ebx,        \
        plnfx:  ptr SEGAB,  \
        x:      dword       >

; Calculate DN = yB - yA

        mov     ebx,plnfx
        mov     eax,[ebx].AB_yB
        sub     eax,[ebx].AB_yA         ; EAX = yB - yA

; Calculate xA - x

        mov     ecx,[ebx].AB_xA
        mov     edx,ecx
        sub     edx,x                   ; EDX = xA - x

        mul     edx                     ; EDX:EAX = (yB - yA) * (xA - x)

; Calculate DM = xA - xB

        sub     ecx,[ebx].AB_xB         ; ECX = xA - xB

; FXTOLONGCEILING(DN * (xA - x) / DM + yA)

        div     ecx

        xor     ecx,ecx                 ; increment by 1 if remainder not 0
        cmp     ecx,edx
        adc     eax,[ebx].AB_yA
        add     eax,15
        sar     eax,4
        cRet    yGetRtoL

endProc yGetRtoL

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htalias.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htalias.c


Abstract:

    This module contains all low levels halftone rendering functions.


Author:

    22-Jan-1991 Tue 12:49:03 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/

#define DBGP_VARNAME        dbgpHTAlias



#include "htp.h"
#include "htmapclr.h"
#include "limits.h"
#include "htpat.h"
#include "htalias.h"
#include "htstret.h"
#include "htrender.h"
#include "htgetbmp.h"
#include "htsetbmp.h"


#define DBGP_BUILD              0x00000001
#define DBGP_BUILD2             0x00000002
#define DBGP_BUILD3             0x00000004
#define DBGP_EXPMATRIX          0x00000008
#define DBGP_EXP                0x00000010
#define DBGP_AAHEADER           0x00000020
#define DBGP_OUTAA              0x00000040
#define DBGP_FUNC               0x00000080
#define DBGP_AAHT               0x00000100
#define DBGP_AAHT_MEM           0x00000200
#define DBGP_AAHT_TIME          0x00000400
#define DBGP_AAHTPAT            0x00000800
#define DBGP_FIXUPDIB           0x00001000
#define DBGP_INPUT              0x00002000
#define DBGP_VGA256XLATE        0x00004000
#define DBGP_EXPAND             0x00008000
#define DBGP_GETFIXUP           0x00010000
#define DBGP_PSD                0x00020000
#define DBGP_MASK               0x00040000
#define DBGP_PALETTE            0x00080000
#define DBGP_PAL_CHKSUM         0x00100000
#define DBGP_LUT_MAP            0x00200000


DEF_DBGPVAR(BIT_IF(DBGP_BUILD,          0)  |
            BIT_IF(DBGP_BUILD2,         0)  |
            BIT_IF(DBGP_BUILD3,         0)  |
            BIT_IF(DBGP_EXPMATRIX,      0)  |
            BIT_IF(DBGP_EXP,            0)  |
            BIT_IF(DBGP_AAHEADER,       0)  |
            BIT_IF(DBGP_OUTAA,          0)  |
            BIT_IF(DBGP_FUNC,           0)  |
            BIT_IF(DBGP_AAHT,           0)  |
            BIT_IF(DBGP_AAHT_MEM,       0)  |
            BIT_IF(DBGP_AAHT_TIME,      0)  |
            BIT_IF(DBGP_AAHTPAT,        0)  |
            BIT_IF(DBGP_FIXUPDIB,       0)  |
            BIT_IF(DBGP_INPUT,          0)  |
            BIT_IF(DBGP_VGA256XLATE,    0)  |
            BIT_IF(DBGP_EXPAND,         0)  |
            BIT_IF(DBGP_GETFIXUP,       0)  |
            BIT_IF(DBGP_PSD,            0)  |
            BIT_IF(DBGP_MASK,           0)  |
            BIT_IF(DBGP_PALETTE,        0)  |
            BIT_IF(DBGP_PAL_CHKSUM,     0)  |
            BIT_IF(DBGP_LUT_MAP,        0))


extern CONST RGBORDER   SrcOrderTable[];
extern DWORD            dwABPreMul[256];

#define SIZE_AAINFO     _ALIGN_MEM(sizeof(AAINFO))


//
// Following computation is based on
//
// NTSC_R_INT      = 299000
// NTSC_G_INT      = 587000
// NTSC_B_INT      = 114000
// GRAY_MAX_IDX    = 0xFFFF
//
// NTSC_R_GRAY_MAX = (((NTSC_R_INT * GRAY_MAX_IDX) + 500000) / 1000000)
// NTSC_B_GRAY_MAX = (((NTSC_B_INT * GRAY_MAX_IDX) + 500000) / 1000000)
// NTSC_G_GRAY_MAX = (GRAY_MAX_IDX - NTSC_R_GRAY_MAX - NTSC_B_GRAY_MAX)
//

#define NTSC_R_GRAY_MAX     (DWORD)0x4c8b
#define NTSC_B_GRAY_MAX     (DWORD)0x1d2f
#define NTSC_G_GRAY_MAX     (DWORD)(0xFFFF - NTSC_R_GRAY_MAX - NTSC_B_GRAY_MAX)



VOID
HTENTRY
SetGrayColorTable(
    PLONG       pIdxBGR,
    PAASURFINFO pAASI
    )

/*++

Routine Description:




Arguments:

    pIdxBGR - Pointer to how to translate from RGB to gray scale, typically
              this pointer is computed with NTSC gray standard plus any
              device transform or color adjustment, but if this pointer is
              NULL then we are reading from the device (1bpp, 8bpp) so we
              will only do NTSC standard mapping.


Return Value:




Author:

    19-Feb-1999 Fri 13:14:01 created  -by-  Daniel Chou (danielc)


Revision History:

    08-Aug-2000 Tue 18:34:22 updated  -by-  Daniel Chou (danielc)
        Fixing bug for alpha blending, in gray scale mode, the destination
        can only be 1bpp or 8bpp mask mono, so when we read back from the
        destination to do alpha blending, it will double color mapping pixels.
        In gray scale mode, the input function will map the source RGB value
        to gray value with the current device transform, color adjustment and
        so on, so if we read back from destination then this transform is not
        desired.


--*/

{
    PRGB4B      prgb4b;
    LONG        cSrcTable;


    ASSERT(NTSC_R_INT == 299000);
    ASSERT(NTSC_G_INT == 587000);
    ASSERT(NTSC_B_INT == 114000);
    ASSERT(GRAY_MAX_IDX == 0xFFFF);


    if (cSrcTable = (LONG)pAASI->cClrTable) {

        prgb4b = pAASI->pClrTable;

        if (pIdxBGR) {

            //
            // This is a reading from the source
            //

            ASSERT(pAASI->Flags & AASIF_GRAY);
            ASSERT(pAASI->pIdxBGR == pIdxBGR);

            while (cSrcTable--) {

                prgb4b++->a = IDXBGR_2_GRAY_BYTE(pIdxBGR,
                                                 prgb4b->b,
                                                 prgb4b->g,
                                                 prgb4b->r);
            }

        } else {

            //
            // We are reading from the destination so only do NTSC standard,
            // since the destination surface alreay halftoned.
            //

            while (cSrcTable--) {

                prgb4b++->a = (BYTE)((((DWORD)prgb4b->r * NTSC_R_GRAY_MAX) +
                                      ((DWORD)prgb4b->g * NTSC_G_GRAY_MAX) +
                                      ((DWORD)prgb4b->b * NTSC_B_GRAY_MAX) +
                                      (0x7FFF)) / 0xFFFF);
            }
        }

    } else if (pIdxBGR != pAASI->pIdxBGR) {

        //
        // This is the source surface info, we will see if this is the
        // gray color table
        //

        ASSERT(pAASI->Flags & AASIF_GRAY);
        ASSERT(pIdxBGR);
        ASSERT(pAASI->pIdxBGR);

        DBGP_IF(DBGP_INPUT,
                DBGP("Copy pIdxBGR [BGR] order from 012 to %ld%ld%ld"
                        ARGDW(pAASI->AABFData.MaskRGB[2])
                        ARGDW(pAASI->AABFData.MaskRGB[1])
                        ARGDW(pAASI->AABFData.MaskRGB[0])));

        CopyMemory(&pAASI->pIdxBGR[pAASI->AABFData.MaskRGB[2] * 256],
                   &pIdxBGR[0 * 256], sizeof(LONG) * 256);
        CopyMemory(&pAASI->pIdxBGR[pAASI->AABFData.MaskRGB[1] * 256],
                   &pIdxBGR[1 * 256], sizeof(LONG) * 256);
        CopyMemory(&pAASI->pIdxBGR[pAASI->AABFData.MaskRGB[0] * 256],
                   &pIdxBGR[2 * 256], sizeof(LONG) * 256);
    }
}



VOID
HTENTRY
ComputeInputColorInfo(
    LPBYTE      pSrcTable,
    UINT        cPerTable,
    UINT        PrimaryOrder,
    PBFINFO     pBFInfo,
    PAASURFINFO pAASI
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Feb-1999 Fri 13:14:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PRGB4B      prgb4b;
    PAABFDATA   pAABFData;
    LONG        cSrcTable;
    LONG        Count;
    LONG        LS;
    LONG        RS;
    BYTE        Mask;


    pAABFData = &pAASI->AABFData;

    if ((pSrcTable) &&
        (Count = cSrcTable = (LONG)pAASI->cClrTable)) {

        UINT    iR;
        UINT    iG;
        UINT    iB;

        prgb4b = pAASI->pClrTable;
        iR     = SrcOrderTable[PrimaryOrder].Order[0];
        iG     = SrcOrderTable[PrimaryOrder].Order[1];
        iB     = SrcOrderTable[PrimaryOrder].Order[2];

        switch (pAABFData->Format) {

        case BMF_1BPP:

            pAASI->InputFunc = (AAINPUTFUNC)Input1BPPToAA24;
            break;

        case BMF_4BPP_VGA16:
        case BMF_4BPP:

            pAASI->InputFunc = (AAINPUTFUNC)Input4BPPToAA24;
            break;

        case BMF_8BPP_VGA256:
        case BMF_8BPP:

            pAASI->InputFunc = (AAINPUTFUNC)Input8BPPToAA24;
            break;

        default:

            DBGP("ComputeInputColorInfo() Invalid Bitmap Format=%ld"
                        ARGDW(pAABFData->Format));

            break;
        }

        while (Count--) {

            prgb4b->r = *(pSrcTable + iR);
            prgb4b->g = *(pSrcTable + iG);
            prgb4b->b = *(pSrcTable + iB);

            DBGP_IF(DBGP_PALETTE,
                    DBGP("Source Pal [%3ld] = %3ld:%3ld:%3ld"
                        ARGDW((LONG)cSrcTable - Count - 1) ARGDW(prgb4b->r)
                        ARGDW(prgb4b->g) ARGDW(prgb4b->b)));

            ++prgb4b;
            pSrcTable += cPerTable;
        }

    } else {

        pAASI->InputFunc = InputAABFDATAToAA24;

        if (pBFInfo->Flags & BFIF_RGB_888) {

            pAABFData->Flags      |= AABF_MASK_IS_ORDER;
            pAABFData->MaskRGB[0]  = (BYTE)pBFInfo->RGBOrder.Order[0];
            pAABFData->MaskRGB[1]  = (BYTE)pBFInfo->RGBOrder.Order[1];
            pAABFData->MaskRGB[2]  = (BYTE)pBFInfo->RGBOrder.Order[2];

        } else {

            //
            // This is bitfield, figure out how to do it, we want to lshift to
            // to edge then right shift to 8bpp then mask off the unwanted bit
            //
            //

            cSrcTable = 3;

            while (cSrcTable--) {

                LS    = 0;
                RS    = (LONG)pBFInfo->BitStart[cSrcTable];
                Count = (LONG)pBFInfo->BitCount[cSrcTable];

                if (Count >= 8) {

                    RS   += (Count - 8);
                    Mask  = 0xFF;

                } else {

                    LS    = 8 - Count;
                    Mask  = (0xFF << LS);

                    if ((RS -= LS) < 0) {

                        LS = -RS;
                        RS = 0;

                    } else {

                        LS = 0;
                    }
                }

                pAABFData->MaskRGB[cSrcTable]   = (BYTE)Mask;
                pAABFData->LShiftRGB[cSrcTable] = (BYTE)LS;
                pAABFData->RShiftRGB[cSrcTable] = (BYTE)RS;

                DBGP_IF(DBGP_FUNC | DBGP_PALETTE,
                        DBGP("BFData[%ld]: Bits=%08lx, LS=%2ld, RS=%2ld, Mask=%02lx -->%02lx"
                            ARGDW(cSrcTable)
                            ARGDW(pBFInfo->BitsRGB[cSrcTable])
                            ARGDW(LS) ARGDW(RS) ARGDW(Mask)
                            ARGDW(((pBFInfo->BitsRGB[cSrcTable] >> RS) << LS) & Mask)));
            }
        }

        switch (pBFInfo->BitmapFormat) {

        case BMF_16BPP:
        case BMF_16BPP_555:
        case BMF_16BPP_565:

            pAABFData->cbSrcInc = 2;
            break;

        case BMF_24BPP:

            ASSERT(pAABFData->Flags & AABF_MASK_IS_ORDER);

            if (pBFInfo->RGBOrder.Index == PRIMARY_ORDER_BGR) {

                ASSERT((pAABFData->MaskRGB[0] == 2) &&
                       (pAABFData->MaskRGB[1] == 1) &&
                       (pAABFData->MaskRGB[2] == 0));

                pAABFData->Flags |= AABF_SRC_IS_BGR8;
            }

            pAABFData->cbSrcInc = 3;

            break;

        case BMF_32BPP:

            if (pAASI->Flags & AASIF_AB_PREMUL_SRC) {

                ASSERT(pAABFData->Flags & AABF_MASK_IS_ORDER);
                ASSERT(dwABPreMul[0] == 0);

                switch (pBFInfo->RGBOrder.Index) {

                case PRIMARY_ORDER_BGR:

                    ASSERT((pAABFData->MaskRGB[0] == 2) &&
                           (pAABFData->MaskRGB[1] == 1) &&
                           (pAABFData->MaskRGB[2] == 0));

                    pAABFData->Flags |= AABF_SRC_IS_BGR_ALPHA;
                    break;

                case PRIMARY_ORDER_RGB:

                    ASSERT((pAABFData->MaskRGB[0] == 0) &&
                           (pAABFData->MaskRGB[1] == 1) &&
                           (pAABFData->MaskRGB[2] == 2));

                    pAABFData->Flags |= AABF_SRC_IS_RGB_ALPHA;
                    break;

                default:

                    break;
                }

                if (dwABPreMul[0] == 0) {

                    pAASI->InputFunc = InputPreMul32BPPToAA24;
                }
            }

            pAABFData->cbSrcInc = 4;
            break;

        default:

            DBGP("ERROR: Invalid BFInfo Format=%ld" ARGDW(pBFInfo->BitmapFormat));
            break;
        }

        DBGP_IF(DBGP_FUNC,
                DBGP("Flags=%02lx. cbSrcInc=%ld, Mask=%02lx:%02lx:%02lx, LS=%2ld:%2ld:%2ld, RS=%2ld:%2ld:%2ld"
                        ARGDW(pAABFData->Flags)
                        ARGDW(pAABFData->cbSrcInc)
                        ARGDW(pAABFData->MaskRGB[0])
                        ARGDW(pAABFData->MaskRGB[1])
                        ARGDW(pAABFData->MaskRGB[2])
                        ARGDW(pAABFData->LShiftRGB[0])
                        ARGDW(pAABFData->LShiftRGB[1])
                        ARGDW(pAABFData->LShiftRGB[2])
                        ARGDW(pAABFData->RShiftRGB[0])
                        ARGDW(pAABFData->RShiftRGB[1])
                        ARGDW(pAABFData->RShiftRGB[2])));
    }

    DBGP_IF(DBGP_FUNC,
            DBGP("+++++ InputFunc = %hs(SrcFmt=%ld), cClrTable=%ld\n"
                ARGPTR(GetAAInputFuncName(pAASI->InputFunc))
                ARGDW(pBFInfo->BitmapFormat) ARGDW(pAASI->cClrTable)));
}



PAAINFO
HTENTRY
BuildTileAAInfo(
    PDEVICECOLORINFO    pDCI,
    DWORD               AAHFlags,
    PLONG               piSrcBeg,
    PLONG               piSrcEnd,
    LONG                SrcSize,
    LONG                IdxDst,
    LONG                IdxDstEnd,
    PLONG               piDstBeg,
    PLONG               piDstEnd,
    LONG                cbExtra
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered.

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.


Return Value:

    At enter of this function, the *piSrcEnd, *piDstEnd is exclusive but when
    return from this function the *piSrcEnd and *piDstEnd is inclusive

    *piSrcBeg, *piSrcEnd, *piDstBeg, *piDstEnd are updated if return value
    is not NULL

Author:

    22-Mar-1998 Sun 18:36:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    LONG        cMatrix;
    LONG        cM;
    LONG        cIn;
    LONG        cOut;
    LONG        IdxSrc;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    LONG        cLoop;
    LONG        cAAData;



    iSrcBeg = *piSrcBeg;
    iSrcEnd = *piSrcEnd;

    //
    // The source always clipped to the visiable surface area
    //

    if (iSrcBeg < 0) {

        iSrcBeg = 0;
    }

    if (iSrcEnd > SrcSize) {

        iSrcEnd = SrcSize;
    }

    cIn  = iSrcEnd - (IdxSrc = iSrcBeg);
    cOut = IdxDstEnd - IdxDst;

    if (cIn <= 0) {

        return(NULL);
    }

    ASSERT(cOut > 0);

    iDstBeg = *piDstBeg;
    iDstEnd = *piDstEnd;
    jSrcBeg = -1;

    ASSERT(iDstBeg < iDstEnd);

    DBGP_IF(DBGP_BUILD,
            DBGP("\nTile(%ld-%ld): iSrc=%ld-%ld, cSrc=%ld, iDst=%ld-%ld, Idx=%ld:%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(iSrcBeg) ARGDW(iSrcEnd)
                ARGDW(SrcSize) ARGDW(iDstBeg)
                ARGDW(iDstEnd) ARGDW(IdxSrc) ARGDW(IdxDst)));

    ALIGN_MEM(cbExtra, cbExtra);

    if (pAAInfo = (PAAINFO)HTAllocMem((LPVOID)pDCI,
                                      HTMEM_BLTAA,
                                      LPTR,
                                      SIZE_AAINFO + cbExtra)) {

        SETDBGVAR(pAAInfo->cbAlloc, SIZE_AAINFO + cbExtra);

        pAAInfo->pbExtra = (LPBYTE)pAAInfo + SIZE_AAINFO;
        cLoop            = cOut;

        while (cLoop--) {

            if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)  &&
                (IdxDst >= iDstBeg) && (IdxDst < iDstEnd)) {

                if (jSrcBeg == -1) {

                    jSrcBeg = IdxSrc;
                    jDstBeg = IdxDst;
                }

                jSrcEnd = IdxSrc;
                jDstEnd = IdxDst;

            } else if (jSrcBeg != -1) {

                break;
            }

            if (++IdxSrc >= iSrcEnd) {

                IdxSrc = iSrcBeg;
            }

            ++IdxDst;
        }

        if (jSrcBeg == -1) {

            HTFreeMem(pAAInfo);
            return(NULL);
        }

        pAAInfo->iSrcBeg    = jSrcBeg - iSrcBeg;
        jSrcBeg             = iSrcBeg;
        jSrcEnd             = iSrcEnd - 1;
        pAAInfo->Mask.iBeg  =
        *piSrcBeg           = jSrcBeg;
        *piSrcEnd           = jSrcEnd;
        *piDstBeg           = jDstBeg;
        *piDstEnd           = jDstEnd;
        pAAInfo->Mask.iSize =
        pAAInfo->cIn        = jSrcEnd - jSrcBeg + 1;
        pAAInfo->cOut       = jDstEnd - jDstBeg + 1;
        pAAInfo->cAAData    =
        pAAInfo->cAALoad    = (DWORD)pAAInfo->cOut;
        pAAInfo->Mask.cIn   = cIn;
        pAAInfo->Mask.cOut  = cOut;

        DBGP_IF(DBGP_BUILD,
                DBGP("TILE(%ld->%ld): iSrc=%ld:%ld (%ld), iDst=%ld:%ld, cAAData=%ld, cbExtra=%ld, Flags=%04lx"
                    ARGDW(pAAInfo->cIn) ARGDW(pAAInfo->cOut)
                    ARGDW(*piSrcBeg) ARGDW(*piSrcEnd)
                    ARGDW(pAAInfo->iSrcBeg) ARGDW(*piDstBeg)
                    ARGDW(*piDstEnd) ARGDW(pAAInfo->cAAData)
                    ARGDW(cbExtra) ARGDW(pAAInfo->Flags)));
    }

    return(pAAInfo);
}




PAAINFO
HTENTRY
BuildBltAAInfo(
    PDEVICECOLORINFO    pDCI,
    DWORD               AAHFlags,
    PLONG               piSrcBeg,
    PLONG               piSrcEnd,
    LONG                SrcSize,
    LONG                IdxDst,
    LONG                IdxDstEnd,
    PLONG               piDstBeg,
    PLONG               piDstEnd,
    LONG                cbExtra
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered.

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.


Return Value:

    At enter of this function, the *piSrcEnd, *piDstEnd is exclusive but when
    return from this function the *piSrcEnd and *piDstEnd is inclusive

    *piSrcBeg, *piSrcEnd, *piDstBeg, *piDstEnd are updated if return value
    is not NULL

Author:

    22-Mar-1998 Sun 18:36:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    LONG        cMatrix;
    LONG        cM;
    LONG        cIn;
    LONG        cOut;
    LONG        IdxSrc;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    LONG        cLoop;
    LONG        cAAData;



    cIn  = (LONG)((iSrcEnd = *piSrcEnd) - (iSrcBeg = IdxSrc = *piSrcBeg));
    cOut = IdxDstEnd - IdxDst;

    ASSERT(cOut > 0);

    if (iSrcBeg < 0) {

        iSrcBeg = 0;
    }

    if (iSrcEnd > SrcSize) {

        iSrcEnd = SrcSize;
    }

    iDstBeg = *piDstBeg;
    iDstEnd = *piDstEnd;
    jSrcBeg = -1;

    ASSERT(iDstBeg < iDstEnd);
    ASSERT(cIn == cOut);

    DBGP_IF(DBGP_BUILD,
            DBGP("\nBlt(%ld-%ld): iSrc=%ld-%ld, cSrc=%ld, iDst=%ld-%ld, Idx=%ld:%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(iSrcBeg) ARGDW(iSrcEnd)
                ARGDW(SrcSize) ARGDW(iDstBeg)
                ARGDW(iDstEnd) ARGDW(IdxSrc) ARGDW(IdxDst)));

    ALIGN_MEM(cbExtra, cbExtra);

    if (pAAInfo = (PAAINFO)HTAllocMem((LPVOID)pDCI,
                                      HTMEM_BLTAA,
                                      LPTR,
                                      SIZE_AAINFO + cbExtra)) {

        SETDBGVAR(pAAInfo->cbAlloc, SIZE_AAINFO + cbExtra);

        pAAInfo->pbExtra = (LPBYTE)pAAInfo + SIZE_AAINFO;
        cLoop            = cOut;

        while (cLoop--) {

            if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)  &&
                (IdxDst >= iDstBeg) && (IdxDst < iDstEnd)) {

                if (jSrcBeg == -1) {

                    jSrcBeg = IdxSrc;
                    jDstBeg = IdxDst;
                }

                jSrcEnd = IdxSrc;
                jDstEnd = IdxDst;

            } else if (jSrcBeg != -1) {

                break;
            }

            ++IdxSrc;
            ++IdxDst;
        }

        if (jSrcBeg == -1) {

            HTFreeMem(pAAInfo);
            return(NULL);
        }

        pAAInfo->Mask.iBeg  =
        *piSrcBeg           = jSrcBeg;
        *piSrcEnd           = jSrcEnd;
        *piDstBeg           = jDstBeg;
        *piDstEnd           = jDstEnd;
        pAAInfo->Mask.iSize =
        pAAInfo->cIn        = jSrcEnd - jSrcBeg + 1;
        pAAInfo->cOut       = jDstEnd - jDstBeg + 1;
        pAAInfo->cAAData    =
        pAAInfo->cAALoad    = (DWORD)pAAInfo->cOut;
        pAAInfo->Mask.cIn   = cIn;
        pAAInfo->Mask.cOut  = cOut;

        DBGP_IF(DBGP_BUILD,
                DBGP("BLT(%ld->%ld): iSrc=%ld:%ld, iDst=%ld:%ld, cAAData=%ld, cbExtra=%ld, Flags=%4lx"
                    ARGDW(pAAInfo->cIn) ARGDW(pAAInfo->cOut)
                    ARGDW(*piSrcBeg) ARGDW(*piSrcEnd) ARGDW(*piDstBeg)
                    ARGDW(*piDstEnd) ARGDW(pAAInfo->cAAData)
                    ARGDW(cbExtra) ARGDW(pAAInfo->Flags)));
    }

    return(pAAInfo);
}



#define _MATRIX_POW     (FD6)1414214

#if DBG
    FD6 MATRIX_POWER =      _MATRIX_POW;
#else
    #define MATRIX_POWER    _MATRIX_POW
#endif




BOOL
HTENTRY
BuildRepData(
    PSRCBLTINFO         pSBInfo,
    LONG                IdxSrc,
    LONG                IdxDst
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered. (exclusive)

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.


Return Value:

    At enter of this function, the *piSrcEnd, *piDstEnd is exclusive but when
    return from this function the *piSrcEnd and *piDstEnd is inclusive

    *piSrcBeg, *piSrcEnd, *piDstBeg, *piDstEnd are updated if return value
    is not NULL

Author:

    22-Mar-1998 Sun 18:36:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    SRCBLTINFO  SBInfo;
    PLONG       pSrcInc;
    PLONG       pDstInc;
    LONG        MinRep;
    LONG        MaxRep;
    LONG        cRem;
    LONG        iRep;
    LONG        cRep;
    LONG        cTot;
    LONG        cIn;
    LONG        cOut;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    UINT        cPrevSrc;
    UINT        cNextSrc;


    SBInfo  = *pSBInfo;
    pRep    = SBInfo.pRep;
    pRepEnd = SBInfo.pRepEnd;
    jSrcBeg = -1;

    if (SBInfo.cIn < SBInfo.cOut) {

        //
        // Expanding
        //

        cIn     = SBInfo.cIn;
        cOut    = SBInfo.cOut;
        pSrcInc = &IdxSrc;
        pDstInc = &IdxDst;

    } else if (SBInfo.cIn > SBInfo.cOut) {

        //
        // Shrinking
        //

        cIn     = SBInfo.cOut;
        cOut    = SBInfo.cIn;
        pSrcInc = &IdxDst;
        pDstInc = &IdxSrc;

    } else {

        ASSERT(SBInfo.cIn != SBInfo.cOut);
        return(FALSE);
    }

    MinRep = cOut / cIn;
    MaxRep = MinRep + 1;

    DBGP_IF(DBGP_BUILD,
            DBGP("\nEXPREP(%ld-%ld): iSrc=%ld-%ld, iDst=%ld-%ld, Idx=%ld:%ld"
                ARGDW(SBInfo.cIn) ARGDW(SBInfo.cOut)
                ARGDW(SBInfo.iSrcBeg) ARGDW(SBInfo.iSrcEnd)
                ARGDW(SBInfo.iDstBeg)
                ARGDW(SBInfo.iDstEnd) ARGDW(IdxSrc) ARGDW(IdxDst)));

    SBInfo.cFirstSkip =
    SBInfo.cLastSkip  = 0;
    iRep              =
    cRep              =
    cTot              = 0;

    //
    // Multiply In/Out by 2, so we do not have run down/up problem, the
    // cRem will be initialized with extra 0.5 for rounding.
    //

    cRem   = (cOut <<= 1) + cIn;
    cIn  <<= 1;

    while (IdxDst < SBInfo.iDstEnd) {

        if ((cRem -= cIn) < 0) {

            ++*pSrcInc;

            if (jSrcBeg != -1) {

                ASSERT(pRep < pRepEnd);
                ASSERT(cRep > 0);
                ASSERT(cRep <= MaxRep);

                pRep++->c  = (WORD)cRep;
                cTot      += cRep;

                DBGP_IF(DBGP_BUILD2,
                        DBGP("    Src=%4ld [%4ld-%4ld], Dst=%4ld [%4ld-%4ld], Rep %4ld=%3ld [%4ld -> %4ld, Rem=%4ld, cTot=%4ld]"
                            ARGDW(IdxSrc) ARGDW(SBInfo.iSrcBeg) ARGDW(SBInfo.iSrcEnd)
                            ARGDW(IdxDst) ARGDW(SBInfo.iDstBeg) ARGDW(SBInfo.iDstEnd)
                            ARGDW(pRep - SBInfo.pRep) ARGDW(cRep)
                            ARGDW(cIn) ARGDW(cOut) ARGDW(cRem) ARGDW(cTot)));
            }

            DBGP_IF(DBGP_BUILD3,
                    DBGP("IdxSrc=%4ld, IdxDst=%4ld, Rep=%3ld / %3ld, Rem=%5ld, cIn=%5ld"
                    ARGDW(IdxSrc) ARGDW(IdxDst)
                    ARGDW(cRep) ARGDW(1) ARGDW(cRem) ARGDW(cIn)));

            cRem += cOut;
            iRep  =
            cRep  = 0;

        } else {

            DBGP_IF(DBGP_BUILD3,
                    DBGP("IdxSrc=%4ld, IdxDst=%4ld, Rep=%3ld / %3ld, Rem=%5ld, cIn=%5ld"
                    ARGDW(IdxSrc) ARGDW(IdxDst)
                    ARGDW(cRep) ARGDW(iRep + 1) ARGDW(cRem) ARGDW(cIn)));

        }

        ++iRep;

        if ((IdxSrc >= SBInfo.iSrcBeg) && (IdxSrc < SBInfo.iSrcEnd)  &&
            (IdxDst >= SBInfo.iDstBeg) && (IdxDst < SBInfo.iDstEnd)) {

            ++cRep;

            if (jSrcBeg == -1) {

                //
                // Any iRep will be the first pixel on the destination that
                // corresponding to the current source, so minus 1 is the
                // total count to be skip for this group of destination
                //

                jSrcBeg           = IdxSrc;
                jDstBeg           = IdxDst;
                SBInfo.cFirstSkip = (BYTE)(iRep - 1);

                DBGP_IF(DBGP_BUILD3,
                        DBGP("               @@@ Set cFirstSkip=%ld at IdxDst=%ld @@@"
                            ARGDW(SBInfo.cFirstSkip) ARGDW(IdxDst)));
            }

            jSrcEnd = IdxSrc;
            jDstEnd = IdxDst;

        } else if (jSrcBeg != -1) {

            break;
        }

        ++*pDstInc;
    }

    if (jSrcBeg == -1) {

        DBGP_IF(DBGP_BUILD3,
                DBGP(" Nothing in the source is on the destination"));

        return(FALSE);
    }


    if (cRep) {

        ASSERT(pRep < pRepEnd);

        pRep++->c  = (WORD)cRep;
        cTot      += cRep;

        DBGP_IF(DBGP_BUILD2,
                DBGP("    ****** Total pRep=%ld,  Last cRep=%ld, cTot=%ld"
                        ARGDW(pRep - SBInfo.pRep)
                        ARGDW(cRep) ARGDW(cTot)));
    }

    while ((cRem -= cIn) >= 0) {

        ++SBInfo.cLastSkip;

        DBGP_IF(DBGP_BUILD3,
                DBGP("               @@@ Set cLastSkip=%4ld, cRem=%5ld @@@"
                        ARGDW(SBInfo.cLastSkip) ARGDW(cRem)));

    }

    if (SBInfo.cIn < SBInfo.cOut) {

        //
        // Expanding, checking for maximum 2 sourcs pixels on each side
        //

        cPrevSrc =
        cNextSrc = 2;

    } else {

        //
        // Shrinking, checking only cFirstSkip and cLastSkip
        //

        cPrevSrc = (UINT)SBInfo.cFirstSkip;
        cNextSrc = (UINT)SBInfo.cLastSkip;
    }

    //
    // Check src begin
    //

    IdxSrc = jSrcBeg;

    while ((cPrevSrc) && (IdxSrc > SBInfo.iSrcBeg)) {

        --IdxSrc;
        --cPrevSrc;
    }

    SBInfo.cPrevSrc = (BYTE)(jSrcBeg - IdxSrc);
    IdxSrc          = jSrcEnd;

    while ((cNextSrc) && (IdxSrc < (SBInfo.iSrcEnd - 1))) {

        ++IdxSrc;
        --cNextSrc;
    }

    SBInfo.cNextSrc = (BYTE)(IdxSrc - jSrcEnd);

    DBGP_IF(DBGP_BUILD3,
            DBGP("cFirstSkip=%ld (%ld), cLastSkip=%ld (%ld), cPrevSrc=%ld, cNextSrc=%ld"
            ARGDW(SBInfo.cFirstSkip) ARGDW(SBInfo.pRep->c)
            ARGDW(SBInfo.cLastSkip)  ARGDW((pRep - 1)->c)
            ARGDW(SBInfo.cPrevSrc) ARGDW(SBInfo.cNextSrc)));

    //  Bug 27036: ensure SBInfo.iSrcEnd is always exclusive

    SBInfo.iBeg       =
    SBInfo.iSrcBeg    = jSrcBeg;
    SBInfo.iSrcEnd    = jSrcEnd + 1;
    SBInfo.iDstBeg    = jDstBeg;
    SBInfo.iDstEnd    = jDstEnd + 1;
    SBInfo.iSize      = jSrcEnd - jSrcBeg + 1;
    SBInfo.pRepEnd    = pRep;
    SBInfo.cRep       = 1;

    DBGP_IF((DBGP_BUILD | DBGP_BUILD2 | DBGP_BUILD3),
            DBGP("EXPREP(%ld->%ld): iSrc=%ld-%ld, iDst=%ld-%ld, iRepSize=%ld"
                ARGDW(SBInfo.cIn) ARGDW(SBInfo.cOut)
                ARGDW(SBInfo.iSrcBeg) ARGDW(SBInfo.iSrcEnd)
                ARGDW(SBInfo.iDstBeg) ARGDW(SBInfo.iDstEnd)
                ARGDW(SBInfo.pRepEnd - SBInfo.pRep)));

    *pSBInfo = SBInfo;

    return(TRUE);
}




PAAINFO
HTENTRY
BuildExpandAAInfo(
    PDEVICECOLORINFO    pDCI,
    DWORD               AAHFlags,
    PLONG               piSrcBeg,
    PLONG               piSrcEnd,
    LONG                SrcSize,
    LONG                IdxDst,
    LONG                IdxDstEnd,
    PLONG               piDstBeg,
    PLONG               piDstEnd,
    LONG                cbExtra
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered. (exclusive)

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.


Return Value:

    At enter of this function, the *piSrcEnd, *piDstEnd is exclusive but when
    return from this function the *piSrcEnd and *piDstEnd is inclusive

    *piSrcBeg, *piSrcEnd, *piDstBeg, *piDstEnd are updated if return value
    is not NULL

Author:

    22-Mar-1998 Sun 18:36:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    LONG        cMatrix;
    LONG        cM;
    LONG        cIn;
    LONG        cOut;
    LONG        IdxSrc;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    LONGLONG    cTot;
    LONG        MulAdd;
    LONG        Mul;
    DWORD       cAALoad;
    LONG        cbRep;
    LONG        cRem;
    DWORD       cbED;


    cIn  = (LONG)((iSrcEnd = *piSrcEnd) - (iSrcBeg = IdxSrc = *piSrcBeg));
    cOut = IdxDstEnd - IdxDst;

    ASSERT(cOut > 0);

    if (iSrcBeg < 0) {

        iSrcBeg = 0;
    }

    if (iSrcEnd > SrcSize) {

        iSrcEnd = SrcSize;
    }

    iDstBeg = *piDstBeg;
    iDstEnd = *piDstEnd;
    jSrcBeg = -1;
    cAALoad = 0;

    ASSERT(iDstBeg < iDstEnd);
    ASSERT(cIn < cOut);

    DBGP_IF(DBGP_BUILD,
            DBGP("\nEXP(%ld-%ld): iSrc=%ld-%ld, cSrc=%ld, iDst=%ld-%ld, Idx=%ld:%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(iSrcBeg) ARGDW(iSrcEnd)
                ARGDW(SrcSize) ARGDW(iDstBeg)
                ARGDW(iDstEnd) ARGDW(IdxSrc) ARGDW(IdxDst)));

    if (AAHFlags & (AAHF_HAS_MASK       |
                    AAHF_ALPHA_BLEND    |
                    AAHF_FAST_EXP_AA    |
                    AAHF_BBPF_AA_OFF)) {

        ALIGN_MEM(cbRep, (iSrcEnd - iSrcBeg + 3) * sizeof(REPDATA));

    } else {

        cbRep = 0;
    }

    if (AAHFlags & (AAHF_BBPF_AA_OFF | AAHF_FAST_EXP_AA)) {

        cMatrix =
        cbED    =
        cM      = 0;

    } else {

        cMatrix = (LONG)((((cOut + (cIn - 1)) / cIn) << 1) - 1);
        cM      = sizeof(DWORD) * cMatrix;

        ALIGN_MEM(cbED, (iDstEnd - iDstBeg) * sizeof(EXPDATA));
    }

    DBGP_IF(DBGP_BUILD,
            DBGP("BuildEXP(%ld, %ld), cMatrix=%ld, cb=%ld+%ld+%ld=%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(cMatrix)
                ARGDW(cbRep) ARGDW(cbED) ARGDW(cM)
                ARGDW(cbRep + cbED + cM)));

    ALIGN_MEM(cbExtra, cbExtra);

    if (pAAInfo = (PAAINFO)HTAllocMem((LPVOID)pDCI,
                                      HTMEM_EXPAA,
                                      LPTR,
                                      cbRep + cbED +
                                            cbExtra + cM + SIZE_AAINFO)) {

        LPBYTE      pbExtra;

        SETDBGVAR(pAAInfo->cbAlloc, cbRep + cbED + cbExtra + cM + SIZE_AAINFO);

        pbExtra = (LPBYTE)pAAInfo + SIZE_AAINFO;

        if (cbExtra) {

            pAAInfo->pbExtra  = (LPBYTE)pbExtra;
            pbExtra          += cbExtra;
        }

        if (cbRep) {

            pAAInfo->Src.cIn      = cIn;
            pAAInfo->Src.cOut     = cOut;
            pAAInfo->Src.iSrcBeg  = iSrcBeg;
            pAAInfo->Src.iSrcEnd  = iSrcEnd;
            pAAInfo->Src.iDstBeg  = iDstBeg;
            pAAInfo->Src.iDstEnd  = iDstEnd;
            pAAInfo->Src.pRep     = (PREPDATA)pbExtra;
            pAAInfo->Src.pRepEnd  = pAAInfo->Src.pRep + (iSrcEnd - iSrcBeg);
            pbExtra              += cbRep;

            if (!BuildRepData(&(pAAInfo->Src), IdxSrc, IdxDst)) {

                HTFreeMem(pAAInfo);
                return(NULL);
            }

            pAAInfo->AB   =
            pAAInfo->Mask = pAAInfo->Src;

            if (AAHFlags & AAHF_FAST_EXP_AA) {

                pAAInfo->Src.iSrcBeg -= pAAInfo->Src.cPrevSrc;
                pAAInfo->Src.iSrcEnd += pAAInfo->Src.cNextSrc;
            }
        }

        if (cbED) {

            PEXPDATA    pED;
            PEXPDATA    pEDEnd;
            LPDWORD     pM;
            LPDWORD     pM1;
            LPDWORD     pM2;
            LONG        cRem2;
            LONG        MincM;
            LONGLONG    ExpMul[4];
            EXPDATA     ed;
            WORD        EDFlags;
            LONGLONG    cNum;
            LONG        cLoop;
            LONG        cMul0;
            LONG        cMul1;
            LONG        cMaskRem;
            LONG        iMaskBeg;
            LONG        iMaskEnd;

            pED              = (PEXPDATA)pbExtra;
            pAAInfo->pAAData = (LPVOID)pED;
            pM               = (LPDWORD)((LPBYTE)pED + cbED);
            pM1              = pM;
            pM2              = pM1 + cMatrix - 1;
            cTot             = 0;

            DBGP_IF(DBGP_BUILD,
                    DBGP("Allocate cbExtra=%ld, pbExtra=%p:%p"
                        ARGDW(cbExtra) ARGPTR(pAAInfo->pbExtra)
                        ARGPTR((LPBYTE)pAAInfo->pbExtra + cbExtra)));

            pM2   = (pM1 += (cMatrix >> 1));
            cTot  = (LONGLONG)(*pM1 = FD6_1);

            if (AAHFlags & AAHF_BBPF_AA_OFF) {

                pAAInfo->Flags |= AAIF_EXP_NO_SHARPEN;

            } else {

                MulAdd = cOut;

                while (((MulAdd -= cIn) > 0) && (--pM1 >= pM)) {

                    Mul = (LONG)DivFD6(MulAdd, cOut);

                    if (Mul != 500000) {

                        Mul = (LONG)RaisePower((FD6)Mul,
                                               MATRIX_POWER,
                                               (WORD)((Mul <= 500000) ?
                                                                0 : RPF_RADICAL));
                    }

                    DBGP_IF(DBGP_EXPMATRIX,
                            DBGP("(%4ld, %4ld) = %s ^ %s = %s"
                                    ARGDW(MulAdd) ARGDW(cOut)
                                    ARGFD6((DivFD6(MulAdd, cOut)), 1, 6)
                                    ARGFD6(MATRIX_POWER, 1, 6) ARGFD6(Mul, 1, 6)));

                    *pM1      =
                    *(++pM2)  = Mul;
                    cTot     += (Mul << 1);
                }
            }

    #if DBG
        {
            FD6 PMPrev = FD6_0;
            FD6 PMCur;


            pM1   = pM;
            cLoop = (LONG)cMatrix;

            while (cLoop--) {

                PMCur = DivFD6(*pM1, (FD6)cTot);

                DBGP_IF(DBGP_EXPMATRIX, DBGP("%3ld: %7ld [%s], Dif=%s, cTot=%ld"
                                ARGDW((pM1 - pM) + 1) ARGDW(*pM1)
                                ARGFD6(PMCur, 1, 6) ARGFD6((PMCur - PMPrev), 1, 6)
                                ARGDW(cTot)));

                PMPrev = PMCur;
                ++pM1;
            }
        }
    #endif
            cTot  *= (LONGLONG)cIn;
            cRem   = cOut + (cIn * (LONG)(cMatrix >> 1));
            cLoop  = cOut;
            cMul0  =
            cMul1  = 0;

            while (cLoop--) {

                cRem2 = cRem;

                if ((cRem -= cIn) <= 0) {

                    cRem += cOut;
                }

                pM1     = pM;
                cM      = cMatrix;
                MincM   = (cMatrix >> 1) - cLoop;
                EDFlags = 0;

                ZeroMemory(ExpMul, sizeof(ExpMul));

                while (cM--) {

                    LONG    cMul;


                    Mul = *pM1++;

                    if ((cRem2 < cIn) && (cM >= MincM)) {

                        if (cMul = cRem2) {

                            ExpMul[3] += (LONGLONG)cRem2 * (LONGLONG)Mul;
                        }

                        cRem2 -= cIn;

                        ASSERTMSG("BuildEXP: Shift more than 3 times", !ExpMul[0]);

                        CopyMemory(&ExpMul[0], &ExpMul[1], sizeof(ExpMul[0]) * 3);

                        ExpMul[3]  = (LONGLONG)-cRem2 * (LONGLONG)Mul;
                        cRem2     += cOut;

                        if (!cM) {

                            if ((++IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)) {

                                EDFlags |= EDF_LOAD_PIXEL;

                                ++cAALoad;
                                ++IdxSrc;

                                if ((IdxSrc <  iSrcBeg) ||
                                    (IdxSrc >= iSrcEnd)) {

                                    EDFlags |= EDF_NO_NEWSRC;
                                }

                                --IdxSrc;
                            }
                        }

                    } else {

                        ExpMul[3] += (LONGLONG)(cMul = cIn) * (LONGLONG)Mul;
                        cRem2     -= cIn;
                    }

                    DBGP_IF(DBGP_BUILD3,
                            DBGP("%5ld-%7ld:%7ld:%7ld:%7ld, %4ld+, cRem2=%4ld, cM=%5ld:%5ld, cMul=%5ldx%5ld%hs%hs"
                                ARGDW(cOut - cLoop - 1) ARGDW(ExpMul[0])
                                ARGDW(ExpMul[1]) ARGDW(ExpMul[2]) ARGDW(ExpMul[3])
                                ARGDW(cMul * Mul) ARGDW(cRem2) ARGDW(cM)
                                ARGDW(MincM) ARGDW(cMul) ARGDW(Mul)
                                ARGPTR((EDFlags & EDF_LOAD_PIXEL) ? ", Load Pixel" : "")
                                ARGPTR((EDFlags & EDF_NO_NEWSRC) ? ", NO New Src" : "")));
                }

                if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)  &&
                    (IdxDst >= iDstBeg) && (IdxDst < iDstEnd)) {

                    GET_FIRST_EDMUL(ed.Mul[3], ExpMul[3], cNum, cTot);
                    GET_NEXT_EDMUL( ed.Mul[2], ExpMul[2], cNum, cTot);

                    if (ExpMul[1]) {

                        ++cMul1;

                        GET_NEXT_EDMUL(ed.Mul[1], ExpMul[1], cNum, cTot);

                        if (ExpMul[0]) {

                            ++cMul0;

                            GET_NEXT_EDMUL(ed.Mul[0], ExpMul[0], cNum, cTot);

                        } else {

                            ed.Mul[0] = 0;
                        }

                    } else {

                        ed.Mul[1] =
                        ed.Mul[0] = 0;
                    }

                    ASSERTMSG("ed.Mul[0] > DI_MAX_NUM", ed.Mul[0] <= DI_MAX_NUM);
                    ASSERTMSG("ed.Mul[1] > DI_MAX_NUM", ed.Mul[1] <= DI_MAX_NUM);
                    ASSERTMSG("ed.Mul[2] > DI_MAX_NUM", ed.Mul[2] <= DI_MAX_NUM);
                    ASSERTMSG("ed.Mul[3] > DI_MAX_NUM", ed.Mul[3] <= DI_MAX_NUM);

                    DBGP_IF(DBGP_BUILD2,
                            DBGP("--%5ld=%7ld:%7ld:%7ld:%7ld, IdxSrc=%5ld --%hs%hs--"
                            ARGDW(IdxDst) ARGDW(ed.Mul[0])
                            ARGDW(ed.Mul[1]) ARGDW(ed.Mul[2])
                            ARGDW(ed.Mul[3]) ARGDW(IdxSrc)
                            ARGPTR((EDFlags & EDF_LOAD_PIXEL) ? ", Load Pixel" : "")
                            ARGPTR((EDFlags & EDF_NO_NEWSRC) ? ", NO New Src" : "")));

                    ed.Mul[0] |= EDFlags;
                    *pED++     = ed;

                    if (jSrcBeg == -1) {

                        iMaskBeg = (cOut - cLoop - 1);
                        jSrcBeg  = IdxSrc;
                        jDstBeg  = IdxDst;
                    }

                    jSrcEnd = IdxSrc;
                    jDstEnd = IdxDst;

                } else if (jSrcBeg != -1) {

                    break;
                }

                ++IdxDst;
            }

            if (jSrcBeg == -1) {

                HTFreeMem(pAAInfo);
                return(NULL);
            }

            //
            // 10-Jun-1998 Wed 08:41:16 updated  -by-  Daniel Chou (danielc)
            //  Fixed for the problem that we need to read extra source for the
            //  last loaded pixel because before expand we will sharpen the pixel
            //  by its 4 neighbors, this will make sure Last+1 pixel/scan line
            //  got read it for sharpen purpose
            //
            // BEGIN FIX
            //

            ++jSrcEnd;

            if ((jSrcEnd < iSrcBeg) || (jSrcEnd >= iSrcEnd)) {

                --jSrcEnd;
            }

            //
            // END FIX
            //

            IdxSrc           =
            *piSrcBeg        = jSrcBeg;
            *piSrcEnd        = jSrcEnd;
            *piDstBeg        = jDstBeg;
            *piDstEnd        = jDstEnd;
            pEDEnd           = pED;
            pED              = (PEXPDATA)(pAAInfo->pAAData);
            pAAInfo->cAAData = (DWORD)(pEDEnd - pED);
            pAAInfo->cAALoad = cAALoad;
            pAAInfo->cMaxMul = (DWORD)((cMul1) ? ((cMul0) ? 4 : 3) : 2);
            ed               = *pED;
            cLoop            = 4;

            if (ed.Mul[0] & EDF_LOAD_PIXEL) {

                --IdxSrc;
                --cLoop;

            } else {

                ++IdxSrc;

                if ((IdxSrc < iSrcBeg) || (IdxSrc >= iSrcEnd)) {

                    pAAInfo->Flags |= AAIF_EXP_NO_LAST_RIGHT;
                }

                --IdxSrc;
            }

            cMul0 = 0;

            while ((cMul0 < cLoop) &&
                   (!(ed.Mul[cMul0] & ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC)))) {

                ++cMul0;
            }

            DBGP_IF(DBGP_BUILD,
                DBGP("cMul0=%ld, cLoop=%ld, IdxSrc=%ld, iSrcBeg=%ld, iSrcEnd=%ld"
                    ARGDW(cMul0) ARGDW(cLoop) ARGDW(IdxSrc)
                    ARGDW(iSrcBeg) ARGDW(iSrcEnd)));

            while (cLoop-- > cMul0) {

                if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)) {

                    *piSrcBeg          = IdxSrc;
                    pAAInfo->cPreLoad += 0x01;

                } else {

                    pAAInfo->cPreLoad += 0x10;
                }

                --IdxSrc;
            }

            if (pAAInfo->cPreLoad) {

                if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)) {

                    *piSrcBeg       = IdxSrc;
                    pAAInfo->Flags |= AAIF_EXP_HAS_1ST_LEFT;
                }
            }

            if (!(pAAInfo->cPreLoad)) {

                DBGP("*** cPreLOAD=0, BuildExpandAAInfo [%04lx:%04lx:%04lx:%04lx], cPreload=0x%02lx, Flags=0x%04lx"
                    ARGDW(ed.Mul[0]) ARGDW(ed.Mul[1]) ARGDW(ed.Mul[2]) ARGDW(ed.Mul[3])
                    ARGDW(pAAInfo->cPreLoad) ARGDW(pAAInfo->Flags));
            }

        } else {

            //  Bug 27036: ensure jSrcEnd is less than iSrcEnd
            *piSrcBeg = pAAInfo->Src.iSrcBeg;
            *piSrcEnd = pAAInfo->Src.iSrcEnd - 1;
            *piDstBeg = pAAInfo->Src.iDstBeg;
            *piDstEnd = pAAInfo->Src.iDstEnd - 1;
        }

        pAAInfo->cIn  = *piSrcEnd - *piSrcBeg + 1;
        pAAInfo->cOut = *piDstEnd - *piDstBeg + 1;

        DBGP_IF((DBGP_BUILD | DBGP_BUILD2 | DBGP_BUILD3),
                DBGP("EXP(%ld->%ld): iSrc=%ld-%ld, iDst=%ld-%ld, cAAData=%ld, cPreLoad=0x%02lx, Flags=0x%04lx"
                    ARGDW(pAAInfo->cIn) ARGDW(pAAInfo->cOut)
                    ARGDW(*piSrcBeg) ARGDW(*piSrcEnd) ARGDW(*piDstBeg)
                    ARGDW(*piDstEnd) ARGDW(pAAInfo->cAAData)
                    ARGDW(pAAInfo->cPreLoad) ARGDW(pAAInfo->Flags)));
    }

    return(pAAInfo);
}



PAAINFO
HTENTRY
BuildShrinkAAInfo(
    PDEVICECOLORINFO    pDCI,
    DWORD               AAHFlags,
    PLONG               piSrcBeg,
    PLONG               piSrcEnd,
    LONG                SrcSize,
    LONG                IdxDst,
    LONG                IdxDstEnd,
    PLONG               piDstBeg,
    PLONG               piDstEnd,
    LONG                cbExtra
    )

/*++

Routine Description:




Arguments:

    piSrcBeg    - Passed in as begining source index, When return this is the
                  real source begining index.  This always well ordered

    piSrcEnd    - Passed in as ending source index, When return this is the
                  real source ending index.  This always well ordered

    SrcSize     - The real size of source in pixel

    IdxDst      - Starting index of destination pixel

    IdxDstEnd   - Ending index of destination pixel, the iDxdst and IdxDstEnd
                  must be well ordered.

    piDstBeg    - Clipped destination start index when passed in, at return
                  it adjusted to the real destination starting index.

    piDstEnd    - Clipped destination end index when passed in, at return
                  it adjusted to the real destination ending index.

    cbExtra     - Extra byte count to be allocated

    NOTE: 1) piDstBeg/piDstEnd When passed in this must be well ordered, and
             when it returned this is well ordered.

Return Value:

    PSHRINKINFO, if NULL then memory allocation failed


Author:

    20-Mar-1998 Fri 12:29:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PLONG       pMap;
    PLONG       pMapEnd;
    PSHRINKDATA pSD;
    PSHRINKDATA pSDEnd;
    LONG        cIn;
    LONG        cOut;
    LONG        IdxSrc;
    LONG        IdxDstOrg;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    LONG        jSrcBeg;
    LONG        jSrcEnd;
    LONG        jDstBeg;
    LONG        jDstEnd;
    LONG        cLoop;
    LONG        cbRep;
    LONG        Mul;
    LONG        NextMul;
    LONG        CurMul;
    LONG        cCur;
    LONG        MinPixel;
    DWORD       cAAData;
    DWORD       cAADone;
    LONGLONG    cNum;



    cIn  = (LONG)((iSrcEnd = *piSrcEnd) - (iSrcBeg = IdxSrc = *piSrcBeg));
    cOut = IdxDstEnd - (IdxDstOrg = IdxDst);

    ASSERT(cOut > 0);

    if (iSrcBeg < 0) {

        iSrcBeg = 0;
    }

    if (iSrcEnd > SrcSize) {

        iSrcEnd = SrcSize;
    }

    //
    // For shrinking we will enlarge the destination by 1 on both side to
    // obtained the source pixel that for sharpening purpose
    //

    iDstBeg = *piDstBeg - 1;
    iDstEnd = *piDstEnd;
    jSrcBeg = -1;
    cAADone = 0;

    ASSERT(iDstBeg < iDstEnd);
    ASSERT(cIn > cOut);

    DBGP_IF(DBGP_BUILD,
            DBGP("\nSRK(%ld-%ld): iSrc=%ld-%ld, cSrc=%ld, iDst=%ld-%ld (%ld-%ld), Idx=%ld:%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(iSrcBeg) ARGDW(iSrcEnd)
                ARGDW(SrcSize) ARGDW(iDstBeg) ARGDW(iDstEnd)
                ARGDW(*piDstBeg) ARGDW(*piDstEnd)
                ARGDW(IdxSrc) ARGDW(IdxDst)));

    //
    // Firstable figure out how may SHRINKDATA needed
    //
    cAAData = (DWORD)((((iDstEnd - iDstBeg + 1) * cIn) + (cOut-1)) / cOut) + 4;

    if ((LONG)cAAData > cIn) {

        (LONG)cAAData = cIn;
    }


    DBGP_IF(DBGP_BUILD,
            DBGP("BuildShrink(%ld-%ld): cSD estimated=%ld (%ld), iDst=%ld-%ld=%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(cAAData) ARGDW(cIn)
                ARGDW(iDstBeg) ARGDW(iDstEnd) ARGDW(iDstEnd - iDstBeg)));

    ALIGN_MEM(CurMul, 256 * 2 * sizeof(LONG));
    ALIGN_MEM(cCur, (cAAData + 1) * sizeof(SHRINKDATA));

    CurMul   += cCur;
    MinPixel  = (LONG)(((LONGLONG)cOut * (LONGLONG)DI_MAX_NUM) / (LONGLONG)cIn);

    if (AAHFlags & (AAHF_HAS_MASK       |
                    AAHF_ALPHA_BLEND    |
                    AAHF_FAST_EXP_AA    |
                    AAHF_BBPF_AA_OFF)) {

        ALIGN_MEM(cbRep, (iDstEnd - iDstBeg + 4) * sizeof(REPDATA));

        if (AAHFlags & AAHF_BBPF_AA_OFF) {

            CurMul = 0;
        }

    } else {

        cbRep = 0;
    }

    ALIGN_MEM(cbExtra, cbExtra);

    if (pAAInfo = (PAAINFO)HTAllocMem((LPVOID)pDCI,
                                      HTMEM_SRKAA,
                                      LPTR,
                                      SIZE_AAINFO + CurMul +
                                                    cbRep + cbExtra)) {

        LPBYTE  pbExtra;


        SETDBGVAR(pAAInfo->cbAlloc, SIZE_AAINFO + CurMul + cbRep + cbExtra);

        pbExtra = (LPBYTE)pAAInfo + SIZE_AAINFO;

        if (cbExtra) {

            pAAInfo->pbExtra  = (LPBYTE)pbExtra;
            pbExtra          += cbExtra;
        }

        if (cbRep) {

            pAAInfo->Src.cIn       = cIn;
            pAAInfo->Src.cOut      = cOut;
            pAAInfo->Src.iSrcBeg   = iSrcBeg;
            pAAInfo->Src.iSrcEnd   = iSrcEnd;
            pAAInfo->Src.iDstBeg   = iDstBeg + 1;
            pAAInfo->Src.iDstEnd   = iDstEnd;
            pAAInfo->Src.pRep      = (PREPDATA)pbExtra;
            pAAInfo->Src.pRepEnd   = pAAInfo->Src.pRep + (iDstEnd-iDstBeg+1);
            pbExtra               += cbRep;

            if (!BuildRepData(&(pAAInfo->Src), IdxSrc, IdxDst)) {

                HTFreeMem(pAAInfo);
                return(NULL);
            }

            pAAInfo->AB   =
            pAAInfo->Mask = pAAInfo->Src;
        }

        if (CurMul) {

            pAAInfo->cPreLoad  = 1;
            pMap               =
            pAAInfo->pMapMul   = (PLONG)pbExtra;
            pMapEnd            = pMap + 256;
            pSD                = (PSHRINKDATA)(pMap + (256 * 2));
            pSDEnd             = pSD + cAAData;
            pAAInfo->pAAData   = (LPVOID)pSD;
            Mul                = -MinPixel;
            CurMul             = MinPixel + 1;
            NextMul            = -CurMul;


            ASSERT_MEM_ALIGN(pAAInfo->pMapMul, sizeof(LONG));

            //
            // Build InMax 256 multiplication table
            //

            do {

                pMap[  0]  = (Mul += MinPixel);
                pMap[256]  = (NextMul += CurMul);

            } while (++pMap < pMapEnd);

            //
            // Build the SHRINKINFO table
            //


            CurMul  = 0;
            cCur    =
            cLoop   = cIn;
            cNum    = (LONGLONG)0;
            cAAData = 0;
            --pSD;

            while (cLoop--) {

                WORD    SDFlags;

                if ((cCur -= cOut) <= 0) {

                    Mul      = cCur + cOut;
                    NextMul  = -cCur;
                    cCur    += cIn;
                    SDFlags  = SDF_DONE;

                    ++IdxDst;

                } else {

                    Mul     = cOut;
                    SDFlags = 0;
                }

                if ((IdxDst >= (iDstBeg - 1)) && (IdxDst <= iDstEnd)) {

                    cNum += ((LONGLONG)Mul * (LONGLONG)DI_MAX_NUM);

                    if ((Mul = (LONG)(cNum / cIn)) > MinPixel) {

                        SDFlags |= SDF_LARGE_MUL;
                    }

                    CurMul += Mul;
                    cNum   %= cIn;

                    if (SDFlags & SDF_DONE) {

                        cNum    = (LONGLONG)NextMul * (LONGLONG)DI_MAX_NUM;
                        NextMul = (LONG)(cNum / cIn);

                        if ((Mul + NextMul) > MinPixel) {

                            SDFlags |= SDF_LARGE_MUL;

                        } else {

                            SDFlags &= ~SDF_LARGE_MUL;
                        }

                        cNum   %= cIn;
                        CurMul  = NextMul;
                        NextMul = 0;
                    }
                }

                if ((IdxDst >= iDstBeg) && (IdxDst <= iDstEnd)) {

                    if ((IdxSrc >= iSrcBeg) && (IdxSrc < iSrcEnd)) {

                        //
                        // Save it first
                        //

                        cAADone += (SDFlags & SDF_DONE) ? 1 : 0;

                        if (++pSD >= pSDEnd) {

                            DBGP("Error(1): cAAData Overrun of %ld, Fixed it"
                                                ARGDW(++cAAData));
                            ASSERT(pSD < pSDEnd);

                            --pSD;
                        }

                        pSD->Mul  = (WORD)Mul | SDFlags;

                        ASSERTMSG("sd.Mul > DI_MAX_NUM", Mul <= DI_MAX_NUM);

                        if (jSrcBeg == -1) {

                            jSrcBeg =
                            jSrcEnd = IdxSrc;
                            jDstBeg =
                            jDstEnd = IdxDst;

                            if (SDFlags & SDF_DONE) {

                                //
                                // If we just finished a pixel then we need to see
                                // if it is a source index or a detination index
                                // cause the output become valid
                                //

                                if (IdxDst == iDstBeg) {

                                    //
                                    // The destination just become valid now,
                                    // PreMul is the start of current detination
                                    // until next done pixel
                                    //

                                    DBGP_IF(DBGP_BUILD,
                                            DBGP("@@ FIRST DEST: PreMul=CurMul=%ld, No PSD, IncSrc"
                                                ARGDW(CurMul)));

                                    pAAInfo->PreMul    = (WORD)CurMul;
                                    pAAInfo->PreSrcInc = 1;
                                    --cAADone;
                                    --pSD;

                                } else {

                                    //
                                    // The source just become valid now, need to
                                    // PreMul all prev sources for this detination
                                    // and save this pSD for done pixel
                                    //

                                    DBGP_IF(DBGP_BUILD,
                                            DBGP("@@ FIRST SRC: PreMul=%ld - Mul (%ld)=%ld"
                                                ARGDW(DI_MAX_NUM) ARGDW(Mul)
                                                ARGDW(DI_MAX_NUM - Mul)));

                                    pAAInfo->PreMul = (WORD)(DI_MAX_NUM - Mul);

                                    --jDstBeg;
                                    --jDstEnd;

                                    ASSERTMSG("!!! Error: jDstBeg is WRONG",
                                                (jDstBeg >= iDstBeg) &&
                                                (jDstBeg <= iDstEnd));
                                }

                            } else {

                                //
                                // We are in the middle of compositions, so the
                                // source just become valid, notice that PreMul
                                // could be zero
                                //

                                DBGP_IF(DBGP_BUILD,
                                        DBGP("@@ FIRST MIDDLE: PreMul=CurMul (%ld) - Mul (%ld)=%ld"
                                            ARGDW(CurMul) ARGDW(Mul)
                                            ARGDW(CurMul - Mul)));

                                pAAInfo->PreMul = (WORD)(CurMul - Mul);
                            }

                        } else {

                            jSrcEnd = IdxSrc;
                            jDstEnd = IdxDst;
                        }

                    } else if (jSrcBeg != -1) {

                        //
                        // Source got cut off early, so wrap it up now
                        //

                        DBGP_IF(DBGP_BUILD,
                                DBGP("@@ END SRC: Mul=%ld, CurMul=%ld"
                                    ARGDW(Mul) ARGDW(CurMul)));

                        if (++pSD >= pSDEnd) {

                            DBGP("Error(2): cAAData Overrun of %ld, Fixed it"
                                        ARGDW(++cAAData));
                            ASSERT(pSD < pSDEnd);

                            --pSD;
                        }

                        if (!(SDFlags & SDF_DONE)) {

                            Mul += (DI_MAX_NUM - CurMul);
                        }

                        pSD->Mul  = (WORD)Mul | (SDFlags |= SDF_DONE);
                        cLoop     = 0;
                        ++cAADone;

                        ASSERTMSG("sd.Mul > DI_MAX_NUM", Mul <= DI_MAX_NUM);
                    }

                } else if (jSrcBeg != -1) {

                    //
                    // we just pass the iDstEnd so this one MUST have SDF_DONE
                    // bit set and we need to save this one, if this one is not
                    // SDF_DONE then something is wrong
                    //

                    ASSERTMSG("End Dest but not SDF_DONE", SDFlags & SDF_DONE);

                    DBGP_IF(DBGP_BUILD,
                            DBGP("@@ PASS IdxDst: Mul=%ld, CurMul=%ld"
                                    ARGDW(Mul) ARGDW(CurMul)));

                    if (++pSD >= pSDEnd) {

                        DBGP("Error(3): cAAData Overrun of %ld, Fixed it"
                                    ARGDW(++cAAData));
                        ASSERT(pSD < pSDEnd);

                        --pSD;
                    }

                    jSrcEnd  = IdxSrc;
                    Mul      = DI_MAX_NUM - CurMul;
                    pSD->Mul = (WORD)Mul | (SDFlags = SDF_DONE);
                    cLoop    = 0;
                    ++cAADone;

                    ASSERTMSG("sd.Mul > DI_MAX_NUM", Mul <= DI_MAX_NUM);
                }
#if DBG
                if ((pSD >= (PSHRINKDATA)(pAAInfo->pAAData)) ||
                    (pAAInfo->PreSrcInc)) {

                    BOOL    HasSD;

                    HasSD = (BOOL)(pSD >= (PSHRINKDATA)(pAAInfo->pAAData));

                    if (SDFlags & SDF_DONE) {

                        DBGP_IF(DBGP_BUILD2,
                                DBGP("%hscLoop=%5ld (%5ld/%5ld), iSrc=%5ld, Mul=%5ld [%5ld], Flags=0x%04lx%hs, Done Pixel"
                                    ARGPTR((HasSD) ? "" : "  >>")
                                    ARGDW(cIn - cLoop - 1) ARGDW(IdxDst)
                                    ARGDW(IdxDst - iDstBeg)
                                    ARGDW(IdxSrc)
                                    ARGDW((Mul) ? Mul :
                                                ((SDFlags & SDF_LARGE_MUL) ?
                                                        MinPixel + 1 : MinPixel))
                                    ARGDW(CurMul)
                                    ARGDW(SDFlags)
                                    ARGPTR((SDFlags & SDF_LARGE_MUL) ? ", Large Mul" : "")));

                    } else {

                        DBGP_IF(DBGP_BUILD2,
                                DBGP("%hscLoop=%5ld                iSrc=%5ld, Mul=%5ld [%5ld], Flags=0x%04lx%hs"
                                ARGPTR((HasSD) ? "" : "  >>")
                                ARGDW(cIn - cLoop - 1)
                                ARGDW(IdxSrc)
                                ARGDW((Mul) ? Mul : ((SDFlags & SDF_LARGE_MUL) ?
                                                MinPixel + 1 : MinPixel))
                                ARGDW(CurMul)
                                ARGDW(SDFlags)
                                ARGPTR((SDFlags & SDF_LARGE_MUL) ? ", Large Mul" : "")));
                    }
                }
#endif

                ++IdxSrc;
            }

            //
            // For the last one ZERO
            //

            ++pSD;

            if ((jSrcBeg == -1) || (pSD == (PSHRINKDATA)(pAAInfo->pAAData))) {

                HTFreeMem(pAAInfo);
                return(NULL);
            }

            ++iDstBeg;

            DBGP_IF(DBGP_BUILD,
                    DBGP("*** Final jDstBeg/End=%ld:%ld, REAL=(%ld:%ld)"
                    ARGDW(jDstBeg) ARGDW(jDstEnd) ARGDW(iDstBeg) ARGDW(iDstEnd)));

            //  Bug 27036: ensure jSrcEnd is less than iSrcEnd
            if (jSrcEnd >= iSrcEnd)
            {
                jSrcEnd = iSrcEnd - 1;
            }

            if (jDstBeg < iDstBeg) {

                ++(pAAInfo->cPreLoad);

                jDstBeg = iDstBeg;
            }

            if (jDstEnd >= iDstEnd) {

                jDstEnd = iDstEnd - 1;
            }

            if ((pAAInfo->PreSrcInc) && (pAAInfo->PreMul == 0)) {

                pAAInfo->PreSrcInc = 0;
                ++jSrcBeg;
            }
#if 0
            //
            // 04-Aug-2000 Fri 15:31:03 updated  -by-  Daniel Chou (danielc)
            //  This assert does not applyed here when anti-aliasing will use
            //  surounding 3 pixels (L/T/R/B) if source available (when clipped
            //  source) but the Rep does not use suround pixels.
            //

            if (cbRep) {

                ASSERT(jSrcBeg == pAAInfo->Mask.iBeg);

                if (jSrcEnd != (pAAInfo->Mask.iBeg + pAAInfo->Mask.iSize - 1)) {

                    DBGP("jSrcEnd=%ld, Mask: iBeg=%ld, iSize=%ld"
                            ARGDW(jSrcEnd) ARGDW(pAAInfo->Mask.iBeg)
                            ARGDW(pAAInfo->Mask.iSize));

                    ASSERT(jSrcEnd == pAAInfo->Mask.iBeg + pAAInfo->Mask.iSize - 1);
                }
            }
#endif
            pAAInfo->cAAData = (DWORD)(pSD - (PSHRINKDATA)(pAAInfo->pAAData));
            pAAInfo->cAADone = cAADone;
            pSD->Mul         = 0;

        } else {

            ASSERT(cbRep);

            //  Bug 27036: ensure jSrcEnd is less than iSrcEnd
            jSrcBeg = pAAInfo->Src.iSrcBeg;
            jSrcEnd = pAAInfo->Src.iSrcEnd - 1;
            jDstBeg = pAAInfo->Src.iDstBeg;
            jDstEnd = pAAInfo->Src.iDstEnd - 1;
        }

        *piSrcBeg     = jSrcBeg;
        *piSrcEnd     = jSrcEnd;
        *piDstBeg     = jDstBeg;
        *piDstEnd     = jDstEnd;
        pAAInfo->cIn  = jSrcEnd - jSrcBeg + 1;
        pAAInfo->cOut = jDstEnd - jDstBeg + 1;

        DBGP_IF(DBGP_BUILD,
                DBGP("SRK(%ld->%ld): iSrc=%ld-%ld, iDst=%ld-%ld, cAAData=%ld, cAADone=%ld, PreMul=%4ld, PresrcInc=%ld, cPreLoad=%ld"
                    ARGDW(pAAInfo->cIn) ARGDW(pAAInfo->cOut)
                    ARGDW(jSrcBeg) ARGDW(jSrcEnd) ARGDW(jDstBeg) ARGDW(jDstEnd)
                    ARGDW(pAAInfo->cAAData) ARGDW(cAADone) ARGDW(pAAInfo->PreMul)
                    ARGDW(pAAInfo->PreSrcInc) ARGDW(pAAInfo->cPreLoad)));
    }

    return(pAAInfo);
}



#if DBG
BOOL    ExpExp = TRUE;
BOOL    SrkSrk = TRUE;
#endif


LONG
HTENTRY
ComputeAABBP(
    PBITBLTPARAMS   pBBP,
    PHTSURFACEINFO  pDstSI,
    PAABBP          pAABBP,
    BOOL            GrayFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    01-Apr-1998 Wed 20:32:36 created  -by-  Daniel Chou (danielc)


Revision History:

    05-Aug-1998 Wed 19:38:56 updated  -by-  Daniel Chou (danielc)
        Fix banding problem

    10-Aug-1998 Mon 16:05:32 updated  -by-  Daniel Chou (danielc)
        Fix rectangle banding with flip (X or Y) computation, the computation
        is done first by flip the Destination rectangles (Orginal and final)
        first by compute from right to left for flipping X, and bottom to
        top for flipping Y, after computation for stretch, we flip all the
        rectangles back


--*/

{
    BITBLTPARAMS    BBP;
    RECTL           rclSurf;
    RECTL           rclPhyDst;
    LONG            cxIn;
    LONG            cyIn;
    LONG            cxOut;
    LONG            cyOut;
    LONG            Tmp;
    DWORD           AAHFlags;


    BBP      = *pBBP;
    AAHFlags = pAABBP->AAHFlags;

    DBGP_IF(DBGP_AAHEADER,
            DBGP(" Input: rclSrc=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
                ARGDW(pBBP->rclSrc.left) ARGDW(pBBP->rclSrc.top)
                ARGDW(pBBP->rclSrc.right) ARGDW(pBBP->rclSrc.bottom)
                ARGDW(pBBP->rclSrc.right - pBBP->rclSrc.left)
                ARGDW(pBBP->rclSrc.bottom - pBBP->rclSrc.top)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP(" Input: rclDst=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
            ARGDW(pBBP->rclDest.left) ARGDW(pBBP->rclDest.top)
            ARGDW(pBBP->rclDest.right) ARGDW(pBBP->rclDest.bottom)
            ARGDW(pBBP->rclDest.right - pBBP->rclDest.left)
            ARGDW(pBBP->rclDest.bottom - pBBP->rclDest.top)));

    if (BBP.Flags & BBPF_HAS_DEST_CLIPRECT) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP(" Input: rclClip=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
                    ARGDW(pBBP->rclClip.left) ARGDW(pBBP->rclClip.top)
                    ARGDW(pBBP->rclClip.right) ARGDW(pBBP->rclClip.bottom)
                    ARGDW(pBBP->rclClip.right - pBBP->rclClip.left)
                    ARGDW(pBBP->rclClip.bottom - pBBP->rclClip.top)));
    }

    if (BBP.Flags & BBPF_HAS_BANDRECT) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP(" Input: rclBand=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
                ARGDW(pBBP->rclBand.left) ARGDW(pBBP->rclBand.top)
                ARGDW(pBBP->rclBand.right) ARGDW(pBBP->rclBand.bottom)
                ARGDW(pBBP->rclBand.right - pBBP->rclBand.left)
                ARGDW(pBBP->rclBand.bottom - pBBP->rclBand.top)));
    }

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Input: ptlBrushOrg=(%6ld, %6ld)"
            ARGDW(pBBP->ptlBrushOrg.x) ARGDW(pBBP->ptlBrushOrg.y)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Input: ptlSrcMask=(%6ld, %6ld)"
                ARGDW(pBBP->ptlSrcMask.x) ARGDW(pBBP->ptlSrcMask.y)));

    if (BBP.rclDest.right < BBP.rclDest.left) {

        XCHG(BBP.rclDest.left, BBP.rclDest.right, Tmp);
        AAHFlags |= AAHF_FLIP_X;
    }

    if (BBP.rclDest.bottom < BBP.rclDest.top) {

        XCHG(BBP.rclDest.top, BBP.rclDest.bottom, Tmp);
        AAHFlags |= AAHF_FLIP_Y;
    }

    //
    // The source RECT is always well ordered
    //

    if (BBP.rclSrc.right < BBP.rclSrc.left) {

        XCHG(BBP.rclSrc.left, BBP.rclSrc.right, Tmp);
        AAHFlags ^= AAHF_FLIP_X;
    }

    if (BBP.rclSrc.bottom < BBP.rclSrc.top) {

        XCHG(BBP.rclSrc.top, BBP.rclSrc.bottom, Tmp);
        AAHFlags ^= AAHF_FLIP_Y;
    }

    if ((BBP.rclSrc.left >= BBP.rclSrc.right)   ||
        (BBP.rclSrc.top >= BBP.rclSrc.bottom)) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("EMPTY rclSrc: (%ld, %ld)-(%ld, %ld)=%ldx%ld"
                    ARGDW(BBP.rclSrc.left) ARGDW(BBP.rclSrc.top)
                    ARGDW(BBP.rclSrc.right) ARGDW(BBP.rclSrc.bottom)
                    ARGDW(BBP.rclSrc.right - BBP.rclSrc.left)
                    ARGDW(BBP.rclSrc.bottom - BBP.rclSrc.top)));

        return(0);
    }

    if ((BBP.rclDest.left >= BBP.rclDest.right)  ||
        (BBP.rclDest.top >= BBP.rclDest.bottom)) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("EMPTY rclDest: (%ld, %ld)-(%ld, %ld)=%ldx%ld"
                    ARGDW(BBP.rclDest.left) ARGDW(BBP.rclDest.top)
                    ARGDW(BBP.rclDest.right) ARGDW(BBP.rclDest.bottom)
                    ARGDW(BBP.rclDest.right - BBP.rclDest.left)
                    ARGDW(BBP.rclDest.bottom - BBP.rclDest.top)));

        return(0);
    }

    //
    // set the cxIn, cyIn for no sign
    //

    cxIn                = BBP.rclSrc.right - BBP.rclSrc.left;
    cyIn                = BBP.rclSrc.bottom - BBP.rclSrc.top;
    cxOut               = BBP.rclDest.right - BBP.rclDest.left;
    cyOut               = BBP.rclDest.bottom - BBP.rclDest.top;
    pAABBP->ptlBrushOrg = BBP.ptlBrushOrg;

    if (((((cxOut * 1000) + 500) / cxIn) > 667) &&
        ((((cyOut * 1000) + 500) / cyIn) > 667)) {

        AAHFlags |= AAHF_DO_FIXUPDIB;
    }

    if ((cxOut * cyOut) < (cxIn * cyIn)) {

        AAHFlags |= AAHF_SHRINKING;
        AAHFlags |= AAHF_DO_DST_CLR_MAPPING;

    } else {

        AAHFlags |= AAHF_DO_SRC_CLR_MAPPING;
    }

    if (cyIn == cyOut) {

        pAABBP->AAMaskCYFunc  = BltMask_CY;
        pAABBP->GetAVCYFunc   = BltAV_CY;
        pAABBP->AABuildCYFunc = BuildBltAAInfo;
        pAABBP->CYFuncMode    = AACYMODE_BLT;

    } else if (cyIn < cyOut) {

        pAABBP->AAMaskCYFunc  = ExpandMask_CY;
        pAABBP->GetAVCYFunc   = ExpandAV_CY;
        pAABBP->AABuildCYFunc = BuildExpandAAInfo;

        if (cxOut > cxIn) {

            if ((!(AAHFlags & AAHF_BBPF_AA_OFF))    &&
                ((cyIn * FAST_MAX_CY) >= cyOut)     &&
                ((cxIn * FAST_MAX_CX) >= cxOut)) {

                AAHFlags |= AAHF_FAST_EXP_AA;
            }

            pAABBP->CYFuncMode = AACYMODE_EXPAND_EXPCX;

        } else {

            pAABBP->CYFuncMode = AACYMODE_EXPAND;
        }

#if DBG
        if (!ExpExp) {

            pAABBP->CYFuncMode = AACYMODE_EXPAND;
        }
#endif

    } else {

        pAABBP->AAMaskCYFunc  = ShrinkMask_CY;
        pAABBP->GetAVCYFunc   = ShrinkAV_CY;
        pAABBP->AABuildCYFunc = BuildShrinkAAInfo;
        pAABBP->CYFuncMode    = ((cxOut < cxIn) && (!GrayFunc)) ?
                                    AACYMODE_SHRINK_SRKCX : AACYMODE_SHRINK;
#if DBG
        if (!SrkSrk) {

             pAABBP->CYFuncMode = AACYMODE_SHRINK;
        }
#endif
    }

    DBGP_IF(DBGP_FUNC, DBGP("\n+++++ AACYFuncMode = %ld"
            ARGDW(pAABBP->CYFuncMode)));

    if (cxIn == cxOut) {

        pAABBP->CXFuncMode    = AACXMODE_BLT;
        pAABBP->AAMaskCXFunc  = BltMask_CX;
        pAABBP->GetAVCXFunc   = BltAV_CX;
        pAABBP->AABuildCXFunc = BuildBltAAInfo;
        pAABBP->AACXFunc      = (GrayFunc) ? (AACXFUNC)GrayCopyDIB_CX :
                                             (AACXFUNC)CopyDIB_CX;

        DBGP_IF(DBGP_FUNC, DBGP("+++++ AACXFunc = CopyDIB_CX()"));

    } else if (cxIn < cxOut) {

        pAABBP->CXFuncMode    = AACXMODE_EXPAND;
        pAABBP->AAMaskCXFunc  = ExpandMask_CX;
        pAABBP->GetAVCXFunc   = ExpandAV_CX;
        pAABBP->AABuildCXFunc = BuildExpandAAInfo;
        pAABBP->AACXFunc      = (GrayFunc) ? (AACXFUNC)GrayExpandDIB_CX :
                                             (AACXFUNC)ExpandDIB_CX;

        DBGP_IF(DBGP_FUNC, DBGP("+++++ AACXFunc = ExpandDIB_CX()"));

    } else {

        pAABBP->CXFuncMode     = AACXMODE_SHRINK;
        pAABBP->AAMaskCXFunc   = ShrinkMask_CX;
        AAHFlags              |= AAHF_OR_AV;
        pAABBP->GetAVCXFunc    = ShrinkAV_CX;
        pAABBP->AABuildCXFunc  = BuildShrinkAAInfo;
        pAABBP->AACXFunc       = (GrayFunc) ? (AACXFUNC)GrayShrinkDIB_CX :
                                              (AACXFUNC)ShrinkDIB_CX;

        DBGP_IF(DBGP_FUNC, DBGP("+++++ AACXFunc = ShrinkDIB_CX()"));
    }

    if (BBP.Flags & BBPF_TILE_SRC) {

        pAABBP->CYFuncMode    = AACYMODE_TILE;
        pAABBP->AAMaskCXFunc  = BltMask_CX;
        pAABBP->AAMaskCYFunc  = BltMask_CY;
        pAABBP->GetAVCXFunc   = NULL;
        pAABBP->GetAVCYFunc   = TileAV_CY;
        pAABBP->AABuildCYFunc =
        pAABBP->AABuildCXFunc = BuildTileAAInfo;
        pAABBP->AACXFunc      = NULL;

        DBGP_IF(DBGP_FUNC, DBGP("+++ TILE: TileBlt_CY(), AACXFunc = NULL"));
    }

    pAABBP->AAHFlags  = AAHFlags;
    pAABBP->rclSrc    = BBP.rclSrc;
    pAABBP->ptlMask.x = BBP.ptlSrcMask.x - BBP.rclSrc.left;
    pAABBP->ptlMask.y = BBP.ptlSrcMask.y - BBP.rclSrc.top;
    rclSurf           = BBP.rclDest;

    if (BBP.Flags & BBPF_HAS_DEST_CLIPRECT) {

        if (!IntersectRECTL(&rclSurf, &BBP.rclClip)) {

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("rclClip=(%ld, %ld)-(%ld, %ld)=%ldx%ld < SURF=(%ld, %ld)-(%ld, %ld)=%ldx%ld"
                        ARGDW(BBP.rclClip.left) ARGDW(BBP.rclClip.top)
                        ARGDW(BBP.rclClip.right) ARGDW(BBP.rclClip.bottom)
                        ARGDW(BBP.rclClip.right - BBP.rclClip.left)
                        ARGDW(BBP.rclClip.bottom - BBP.rclClip.top)
                        ARGDW(rclSurf.left) ARGDW(rclSurf.top)
                        ARGDW(rclSurf.right) ARGDW(rclSurf.bottom)
                        ARGDW(rclSurf.right - rclSurf.left)
                        ARGDW(rclSurf.bottom - rclSurf.top)));

            return(0);
        }
    }

    if (BBP.Flags & BBPF_HAS_BANDRECT) {

        ASSERT(BBP.rclBand.left >= 0);
        ASSERT(BBP.rclBand.top  >= 0);
        ASSERT(BBP.rclBand.right  > BBP.rclBand.left);
        ASSERT(BBP.rclBand.bottom > BBP.rclBand.top);

        if (!IntersectRECTL(&rclSurf, &BBP.rclBand)) {

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("rclBand=(%ld, %ld)-(%ld, %ld)=%ldx%ld < SURF=(%ld, %ld)-(%ld, %ld)=%ldx%ld"
                        ARGDW(BBP.rclBand.left) ARGDW(BBP.rclBand.top)
                        ARGDW(BBP.rclBand.right) ARGDW(BBP.rclBand.bottom)
                        ARGDW(BBP.rclBand.right - BBP.rclBand.left)
                        ARGDW(BBP.rclBand.bottom - BBP.rclBand.top)
                        ARGDW(rclSurf.left) ARGDW(rclSurf.top)
                        ARGDW(rclSurf.right) ARGDW(rclSurf.bottom)
                        ARGDW(rclSurf.right - rclSurf.left)
                        ARGDW(rclSurf.bottom - rclSurf.top)));

            return(0);
        }

        //
        // 05-Aug-1998 Wed 19:38:56 updated  -by-  Daniel Chou (danielc)
        //  Fixed the banding problem when mirrored or upside down stretch
        //  The fixes is simple by offset all the Dest rects for the left/top
        //  of the band, and reset the cx/cy destination size according to the
        //  band size and then offset the brush origin according the the band's
        //  left/top position, after these all other codes should run the same
        //  excpet we do not need to check BBPF_HAS_BANDRECT at later time.
        //

        BBP.rclDest.left      -= BBP.rclBand.left;
        BBP.rclDest.right     -= BBP.rclBand.left;
        BBP.rclDest.top       -= BBP.rclBand.top;
        BBP.rclDest.bottom    -= BBP.rclBand.top;
        rclSurf.left          -= BBP.rclBand.left;
        rclSurf.right         -= BBP.rclBand.left;
        rclSurf.top           -= BBP.rclBand.top;
        rclSurf.bottom        -= BBP.rclBand.top;
        pAABBP->ptlBrushOrg.x -= BBP.rclBand.left;
        pAABBP->ptlBrushOrg.y -= BBP.rclBand.top;

        ASSERT((BBP.rclBand.right - BBP.rclBand.left) <= pDstSI->Width);
        ASSERT((BBP.rclBand.bottom - BBP.rclBand.top) <= pDstSI->Height);

        DBGP_IF(DBGP_AAHEADER,
                DBGP("BAND Output: Dest: %ld x %ld --> BAND: %ld x %ld"
                ARGDW(pDstSI->Width) ARGDW(pDstSI->Height)
                ARGDW(BBP.rclBand.right - BBP.rclBand.left)
                ARGDW(BBP.rclBand.bottom - BBP.rclBand.top)));
    }

    rclPhyDst.left   =
    rclPhyDst.top    = 0;
    rclPhyDst.right  = pDstSI->Width;
    rclPhyDst.bottom = pDstSI->Height;

    if (!IntersectRECTL(&rclSurf, &rclPhyDst)) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("PhyDest=(%ld, %ld)-(%ld, %ld)=%ldx%ld < SURF=(%ld, %ld)-(%ld, %ld)=%ldx%ld"
                    ARGDW(rclPhyDst.left) ARGDW(rclPhyDst.top)
                    ARGDW(rclPhyDst.right) ARGDW(rclPhyDst.bottom)
                    ARGDW(rclPhyDst.right - rclPhyDst.left)
                    ARGDW(rclPhyDst.bottom - rclPhyDst.top)
                    ARGDW(rclSurf.left) ARGDW(rclSurf.top)
                    ARGDW(rclSurf.right) ARGDW(rclSurf.bottom)
                    ARGDW(rclSurf.right - rclSurf.left)
                    ARGDW(rclSurf.bottom - rclSurf.top)));

        return(0);
    }

    //
    // 10-Aug-1998 Mon 16:09:13 updated  -by-  Daniel Chou (danielc)
    //  flipping X computation:  When we flip in X direction, we will first
    //  compute the destination original rectangle and final destination
    //  rectangle by compute its offset from right hand side so later at
    //  stretch computation is easier, after finished stretch computation
    //  (BuildExpand or BuildShrink) we will flip the rectangle back by
    //  substract it from ptlFlip.x.
    //

    if (AAHFlags & AAHF_FLIP_X) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("*** FLIP X: rclDstOrg=(%6ld - %6ld)=%6ld"
                ARGDW(BBP.rclDest.left) ARGDW(BBP.rclDest.right)
                ARGDW(BBP.rclDest.right - BBP.rclDest.left)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("*** FLIP X: rclDst=(%6ld -  %6ld)=%6ld, ptlFlip.x=%ld"
                ARGDW(rclSurf.left) ARGDW(rclSurf.right)
                ARGDW(rclSurf.right - rclSurf.left)
                ARGDW(BBP.rclDest.right)));

        Tmp                = rclSurf.right - rclSurf.left;
        rclSurf.left       = BBP.rclDest.right - rclSurf.right;
        rclSurf.right      = rclSurf.left + Tmp;
        pAABBP->ptlFlip.x  = BBP.rclDest.right;
        BBP.rclDest.right -= BBP.rclDest.left;
        BBP.rclDest.left   = 0;
    }

    //
    // 10-Aug-1998 Mon 16:09:13 updated  -by-  Daniel Chou (danielc)
    //  flipping Y computation:  When we flip in Y direction, we will first
    //  compute the destination original rectangle and final destination
    //  rectangle by compute its offset from bottom hand side so later at
    //  stretch computation is easier, after finished stretch computation
    //  (BuildExpand or BuildShrink) we will flip the rectangle back by
    //  substract it from ptlFlip.y.
    //

    if (AAHFlags & AAHF_FLIP_Y) {

        DBGP_IF(DBGP_AAHEADER,
                DBGP("*** FLIP Y: rclDstOrg=(%6ld - %6ld)=%6ld"
                ARGDW(BBP.rclDest.top) ARGDW(BBP.rclDest.bottom)
                ARGDW(BBP.rclDest.bottom - BBP.rclDest.top)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("*** FLIP Y: rclDst=(%6ld - %6ld)=%6ld, ptlFlip.y=%ld"
                ARGDW(rclSurf.top) ARGDW(rclSurf.bottom)
                ARGDW(rclSurf.bottom - rclSurf.top)
                ARGDW(BBP.rclDest.bottom)));

        Tmp                 = rclSurf.bottom - rclSurf.top;
        rclSurf.top         = BBP.rclDest.bottom - rclSurf.bottom;
        rclSurf.bottom      = rclSurf.top + Tmp;
        pAABBP->ptlFlip.y   = BBP.rclDest.bottom;
        BBP.rclDest.bottom -= BBP.rclDest.top;
        BBP.rclDest.top     = 0;
    }

    pAABBP->rclDstOrg = BBP.rclDest;
    pAABBP->rclDst    = rclSurf;

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output: rclSrc=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
                ARGDW(pAABBP->rclSrc.left) ARGDW(pAABBP->rclSrc.top)
                ARGDW(pAABBP->rclSrc.right) ARGDW(pAABBP->rclSrc.bottom)
                ARGDW(pAABBP->rclSrc.right - pAABBP->rclSrc.left)
                ARGDW(pAABBP->rclSrc.bottom - pAABBP->rclSrc.top)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output: rclDstOrg=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
            ARGDW(pAABBP->rclDstOrg.left) ARGDW(pAABBP->rclDstOrg.top)
            ARGDW(pAABBP->rclDstOrg.right) ARGDW(pAABBP->rclDstOrg.bottom)
            ARGDW(pAABBP->rclDstOrg.right - pAABBP->rclDstOrg.left)
            ARGDW(pAABBP->rclDstOrg.bottom - pAABBP->rclDstOrg.top)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output:    rclDst=(%6ld, %6ld)-(%6ld, %6ld)=%6ld x %6ld"
            ARGDW(pAABBP->rclDst.left) ARGDW(pAABBP->rclDst.top)
            ARGDW(pAABBP->rclDst.right) ARGDW(pAABBP->rclDst.bottom)
            ARGDW(pAABBP->rclDst.right - pAABBP->rclDst.left)
            ARGDW(pAABBP->rclDst.bottom - pAABBP->rclDst.top)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output:    ptlBrushOrg=(%6ld, %6ld)"
            ARGDW(pAABBP->ptlBrushOrg.x) ARGDW(pAABBP->ptlBrushOrg.y)));

    DBGP_IF(DBGP_AAHEADER,
            DBGP("Output:    ptlSrcMask=(%6ld, %6ld)"
            ARGDW(pAABBP->ptlMask.x) ARGDW(pAABBP->ptlMask.y)));

    return(1);

}


#if DBG
extern INT cCXMask;


LPSTR
GetAACXFuncName(
    AACXFUNC    AACXFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Jan-1999 Wed 19:11:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if (AACXFunc == (AACXFUNC)RepDIB_CX) {

        return("RepDIB_CX");

    } else if (AACXFunc == (AACXFUNC)SkipDIB_CX) {

        return("SkipDIB_CX");

    } else if (AACXFunc == (AACXFUNC)CopyDIB_CX) {

        return("CopyDIB_CX");

    } else if (AACXFunc == (AACXFUNC)ShrinkDIB_CX) {

        return("ShrinkDIB_CX");

    } else if (AACXFunc == (AACXFUNC)ExpandDIB_CX) {

        return("ExpandDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GrayRepDIB_CX) {

        return("GrayRepDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GraySkipDIB_CX) {

        return("GraySkipDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GrayCopyDIB_CXGray) {

        return("GrayCopyDIB_CXGray");

    } else if (AACXFunc == (AACXFUNC)GrayCopyDIB_CX) {

        return("GrayCopyDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GrayExpandDIB_CX) {

        return("GrayExpandDIB_CX");

    } else if (AACXFunc == (AACXFUNC)GrayShrinkDIB_CX) {

        return("GrayShrinkDIB_CX");

    } else {

        DBGP("ERROR: Unknown AACXFUNC=%p, Function" ARGPTR(AACXFunc));

        return("Unknown AACXFUNC");
    }

}



LPSTR
GetAACYFuncName(
    AACYFUNC    AACYFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Jan-1999 Wed 19:11:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    if (AACYFunc == (AACYFUNC)TileDIB_CY) {

        return("TileDIB_CY");

    } else if (AACYFunc == (AACYFUNC)RepDIB_CY) {

        return("RepDIB_CY");

    } else if (AACYFunc == (AACYFUNC)FastExpAA_CY) {

        return("FastExpAA_CY");

    } else if (AACYFunc == (AACYFUNC)SkipDIB_CY) {

        return("SkipDIB_CY");

    } else if (AACYFunc == (AACYFUNC)BltDIB_CY) {

        return("BltDIB_CY");

    } else if (AACYFunc == (AACYFUNC)ShrinkDIB_CY) {

        return("ShrinkDIB_CY");

    } else if (AACYFunc == (AACYFUNC)ShrinkDIB_CY_SrkCX) {

        return("ShrinkDIB_CY_SrkCX");

    } else if (AACYFunc == (AACYFUNC)ExpandDIB_CY_ExpCX) {

        return("ExpandDIB_CY_ExpCX");

    } else if (AACYFunc == (AACYFUNC)ExpandDIB_CY) {

        return("ExpandDIB_CY");

    } else if (AACYFunc == (AACYFUNC)GrayExpandDIB_CY_ExpCX) {

        return("GrayExpandDIB_CY_ExpCX");

    } else if (AACYFunc == (AACYFUNC)GrayExpandDIB_CY) {

        return("GrayExpandDIB_CY");

    } else if (AACYFunc == (AACYFUNC)GrayShrinkDIB_CY) {

        return("GrayShrinkDIB_CY");

    } else {

        DBGP("ERROR: Unknown AACYFUNC=%p, Function" ARGPTR(AACYFunc));

        return("Unknown AACYFUNC");
    }
}


#endif



LONG
HTENTRY
SetupAAHeader(
    PHALFTONERENDER     pHR,
    PDEVICECOLORINFO    pDCI,
    PAAHEADER           pAAHdr,
    AACYFUNC            *pAACYFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    03-Apr-1998 Fri 04:27:16 created  -by-  Daniel Chou (danielc)


Revision History:

    07-Aug-1998 Fri 19:28:21 updated  -by-  Daniel Chou (danielc)
        Fix the mirror/upside-down banding problems, the problem is when we
        flip the destination original size rectangle we did not flip the
        the real destination rectangle, this cause the the offset getting too
        big and its pointer offset passed the end of the bitmap, it also
        has problem that when we did not flip the destination rectangle
        the wrong portion of the bitmap will be in the band.

--*/

{
    PAAINFO         pAAInfoCX;
    PAAINFO         pAAInfoCY;
    PBITBLTPARAMS   pBBP;
    PHTSURFACEINFO  pSrcSI;
    PHTSURFACEINFO  pDstSI;
    PHTSURFACEINFO  pMaskSI;
    LPBYTE          pbExtra;
    AACYFUNC        AACYFunc;
    AABBP           aabbp;
    LONG            iFree;
    LONG            cbFreeBuf;
    LONG            Top;
    LONG            Bottom;
    LONG            cyNext;
    LONG            cxSize;
    LONG            cbMaskSrc;
    LONG            cIn;
    LONG            cOut;
    LONG            cbCYExtra;
    LONG            cbCXExtra;
    LONG            cbInBuf;
    LONG            cbFUDI;
    LONG            cbVGA256Xlate;
    LONG            cbOutBuf;
    LONG            cbAlphaBuf;
    LONG            cbIdxBGR;
    LONG            Result;
    LONG            cbSrcPel;
    DWORD           PrimAdjFlags;
    UINT            DstSurfFmt;


    pBBP         = pHR->pBitbltParams;
    pSrcSI       = pHR->pSrcSI;
    pDstSI       = pHR->pDestSI;
    pMaskSI      = pHR->pSrcMaskSI;
    DstSurfFmt   = (UINT)pDstSI->SurfaceFormat;
    PrimAdjFlags = (DWORD)pHR->pDevClrAdj->PrimAdj.Flags;
    cbSrcPel     = (pHR->pDevClrAdj->DMI.Flags & DMIF_GRAY) ? sizeof(BYTE) :
                                                              sizeof(BGR8);
    DBGP_IF(DBGP_AAHEADER,
            DBGP("\nSrcSI=%ld x %ld [Format=%ld], DestSI=%ld x %ld [Format=%ld]"
                ARGDW(pSrcSI->Width) ARGDW(pSrcSI->Height)
                ARGDW(pSrcSI->SurfaceFormat)
                ARGDW(pDstSI->Width) ARGDW(pDstSI->Height)
                ARGDW(pDstSI->SurfaceFormat)));

    aabbp.AAHFlags = (PrimAdjFlags & DCA_BBPF_AA_OFF) ? AAHF_BBPF_AA_OFF : 0;

    if (pBBP->Flags & BBPF_TILE_SRC) {

        aabbp.AAHFlags |= AAHF_TILE_SRC;
        aabbp.AAHFlags |= AAHF_BBPF_AA_OFF;
    }

    if (ComputeAABBP(pBBP, pDstSI, &aabbp, cbSrcPel == sizeof(BYTE)) <= 0) {

        return(0);
    }

    cbCXExtra = sizeof(RGBLUTAA);

    if (PrimAdjFlags & DCA_ALPHA_BLEND) {

        aabbp.AAHFlags |= AAHF_ALPHA_BLEND;

        if (PrimAdjFlags & DCA_CONST_ALPHA) {

            aabbp.AAHFlags |= AAHF_CONST_ALPHA;

            cbCXExtra += (AB_BGR_CA_SIZE + AB_CONST_SIZE);

        } else {

            if (PrimAdjFlags & DCA_AB_PREMUL_SRC) {

                //
                // Set the flag so we will try to compute premul's orginal src
                //

                pAAHdr->SrcSurfInfo.Flags |= AASIF_AB_PREMUL_SRC;
            }

            if (PrimAdjFlags & DCA_AB_DEST) {

                aabbp.AAHFlags |= AAHF_AB_DEST;
            }

            cbCXExtra += AB_BGR_SIZE;
        }
    }

    if (PrimAdjFlags & DCA_NO_MAPPING_TABLE) {

        aabbp.AAHFlags &= ~AAHF_DO_CLR_MAPPING;
    }

    ALIGN_MEM(cbCXExtra, cbCXExtra);

    DBGP_IF(DBGP_LUT_MAP,
            DBGP("CXExtra=%ld (RGBLUTAA) + 0 (Mapping=%hs) = %ld"
                    ARGDW(sizeof(RGBLUTAA))
                    ARGPTR((aabbp.AAHFlags & AAHF_DO_SRC_CLR_MAPPING) ?
                            "SRC" : "DST")
                    ARGDW(sizeof(RGBLUTAA) + 0)));

    //
    // This flag is set when reading the source bitmap, so the pointer will
    // advanced to next scanline, this flag will not set for the destiantion
    // since when blending and we reading from destination, we do not want to
    // advanced the destination pointer because it will be done during output
    //

    ComputeInputColorInfo((LPBYTE)pSrcSI->pColorTriad->pColorTable,
                          (UINT)pSrcSI->pColorTriad->BytesPerEntry,
                          (UINT)pSrcSI->pColorTriad->PrimaryOrder,
                          &(pHR->BFInfo),
                          &(pAAHdr->SrcSurfInfo));

    pAAHdr->SrcSurfInfo.Flags |= AASIF_INC_PB |
                                 ((cbSrcPel == sizeof(BYTE)) ? AASIF_GRAY : 0);


    if (PrimAdjFlags & DCA_USE_ADDITIVE_PRIMS) {

        aabbp.AAHFlags |= AAHF_ADDITIVE;
    }

    if (pBBP->Flags & BBPF_TILE_SRC) {

        aabbp.AAHFlags &= ~AAHF_DO_FIXUPDIB;
    }

    if (aabbp.AAHFlags & AAHF_BBPF_AA_OFF) {

        aabbp.AAHFlags &= ~AAHF_DO_FIXUPDIB;
    }

    if (aabbp.AAHFlags & AAHF_DO_FIXUPDIB) {

        CheckBMPNeedFixup(pDCI, pAAHdr, pSrcSI, &aabbp);

        if (aabbp.AAHFlags & AAHF_SHRINKING) {

            if (PrimAdjFlags & DCA_BBPF_AA_OFF) {

                aabbp.AAHFlags |= AAHF_BBPF_AA_OFF;

            } else {

                aabbp.AAHFlags &= ~AAHF_BBPF_AA_OFF;
            }
        }

    }

    if (aabbp.AAHFlags & AAHF_BBPF_AA_OFF) {

        aabbp.AAHFlags &= ~AAHF_FAST_EXP_AA;
    }

    if (pMaskSI) {

        aabbp.AAHFlags |= AAHF_HAS_MASK;
    }

    if (!(pAAInfoCX = aabbp.AABuildCXFunc(pDCI,
                                          aabbp.AAHFlags,
                                          &aabbp.rclSrc.left,
                                          &aabbp.rclSrc.right,
                                          pSrcSI->Width,
                                          aabbp.rclDstOrg.left,
                                          aabbp.rclDstOrg.right,
                                          &aabbp.rclDst.left,
                                          &aabbp.rclDst.right,
                                          cbCXExtra))) {

        //
        // Remove cbCXExtra (use pDCI's rgbLUT and BGRMapTable, AlphaBlendBGR)
        //

        if (!(pAAInfoCX = aabbp.AABuildCXFunc(pDCI,
                                              aabbp.AAHFlags,
                                              &aabbp.rclSrc.left,
                                              &aabbp.rclSrc.right,
                                              pSrcSI->Width,
                                              aabbp.rclDstOrg.left,
                                              aabbp.rclDstOrg.right,
                                              &aabbp.rclDst.left,
                                              &aabbp.rclDst.right,
                                              cbCXExtra = 0))) {

            return(HTERR_INSUFFICIENT_MEMORY);
        }
    }

    //  Bug 27036:  reject empty rectangles
    if(!pAAInfoCX->cIn  ||  !pAAInfoCX->cOut)
    {
#if 0
        LONG crash = 1 ;   // empty src or dest rectangle!
        crash /= (pAAInfoCX->cIn * pAAInfoCX->cOut);            //  delete when debugging is complete.
        if(crash)
            return 0 ;
#endif
        HTFreeMem(pAAInfoCX);
        return 0 ;
    }

    if (cbCXExtra) {

        pAAHdr->prgbLUT  = (PRGBLUTAA)(pbExtra = pAAInfoCX->pbExtra);
        pbExtra         += sizeof(RGBLUTAA);

        ASSERT_MEM_ALIGN(pAAHdr->prgbLUT, sizeof(LONG));

        if (aabbp.AAHFlags & AAHF_ALPHA_BLEND) {

            pAAHdr->pAlphaBlendBGR = (LPBYTE)pbExtra;

            if (PrimAdjFlags & DCA_CONST_ALPHA) {

                pbExtra += (AB_BGR_CA_SIZE + AB_CONST_SIZE);

            } else {

                pbExtra += AB_BGR_SIZE;
            }
        }

    } else {

        ASSERT_MEM_ALIGN(&pDCI->rgbLUT, sizeof(LONG));

        aabbp.AAHFlags  |= AAHF_USE_DCI_DATA;
        pAAHdr->prgbLUT  = &pDCI->rgbLUT;

        if (aabbp.AAHFlags & AAHF_ALPHA_BLEND) {

            pAAHdr->pAlphaBlendBGR = pDCI->pAlphaBlendBGR;

            if (PrimAdjFlags & DCA_CONST_ALPHA) {

                pAAHdr->pAlphaBlendBGR += AB_BGR_SIZE;
            }
        }
    }

    pAAHdr->pIdxBGR = pAAHdr->prgbLUT->IdxBGR;

    if (aabbp.AAHFlags & AAHF_FLIP_X) {

        DBGP_IF(DBGP_AAHEADER,
            DBGP("X Dst=(%ld - %ld)=%ld change it to (%ld - %ld), ptlFlip.x=%ld"
                ARGDW(aabbp.rclDst.left) ARGDW(aabbp.rclDst.right)
                ARGDW(aabbp.rclDst.right - aabbp.rclDst.left)
                ARGDW(aabbp.ptlFlip.x - aabbp.rclDst.left - 1)
                ARGDW(aabbp.ptlFlip.x - aabbp.rclDst.right - 1)
                ARGDW(aabbp.ptlFlip.x)));

        aabbp.rclDst.left  = aabbp.ptlFlip.x - aabbp.rclDst.left - 1;
        aabbp.rclDst.right = aabbp.ptlFlip.x - aabbp.rclDst.right - 1;
    }

    //
    // cbCYExtra is for the input scan line, add one because we want to
    // run it in DWORD mode so we need at least an extra byte at end
    // of input buffer
    //

    cIn       = pAAInfoCX->cIn;
    cOut      = pAAInfoCX->cOut;
    cbInBuf   = cIn + 6;          // left extra=3, right extra=3
    cbFreeBuf =
    cbCYExtra = 0;
    AACYFunc  = NULL;

    if (aabbp.AAHFlags & AAHF_BBPF_AA_OFF) {

        switch (aabbp.CYFuncMode) {

        case AACYMODE_SHRINK:
        case AACYMODE_SHRINK_SRKCX:

            AACYFunc = (AACYFUNC)SkipDIB_CY;
            break;

        case AACYMODE_EXPAND:
        case AACYMODE_EXPAND_EXPCX:

            cbCYExtra = (aabbp.AAHFlags & AAHF_ALPHA_BLEND) ?
                                    (sizeof(BGR8) * (cOut + 6)) : 0;

            AACYFunc = (AACYFUNC)RepDIB_CY;
            break;

        case AACYMODE_BLT:

            AACYFunc = (AACYFUNC)BltDIB_CY;
            break;
        }

        if (AACYFunc) {

            switch (aabbp.CXFuncMode) {

            case AACXMODE_BLT:

                aabbp.AACXFunc = (cbSrcPel == sizeof(BYTE)) ?
                                        (AACXFUNC)GrayCopyDIB_CXGray :
                                        (AACXFUNC)CopyDIB_CX;
                break;

            case AACXMODE_SHRINK:

                aabbp.AACXFunc = (cbSrcPel == sizeof(BYTE)) ?
                                        (AACXFUNC)GraySkipDIB_CX :
                                        (AACXFUNC)SkipDIB_CX;
                break;

            case AACXMODE_EXPAND:

                aabbp.AACXFunc = (cbSrcPel == sizeof(BYTE)) ?
                                        (AACXFUNC)GrayRepDIB_CX :
                                        (AACXFUNC)RepDIB_CX;
                break;
            }

            aabbp.CYFuncMode = AACYMODE_NONE;
        }
    }

    switch (aabbp.CYFuncMode) {

    case AACYMODE_TILE:

        AACYFunc  = TileDIB_CY;
        cbCYExtra = (cbSrcPel == sizeof(BYTE)) ? (cIn * sizeof(WORD)) : 0;
        break;

    case AACYMODE_BLT:

        AACYFunc = (AACYFUNC)BltDIB_CY;
        break;

    case AACYMODE_SHRINK:

        //
        // We need to make sure Off555Buf does not changed
        //

        cbFreeBuf = (sizeof(LONG) * 256 * 2);

        if (cbSrcPel == sizeof(BYTE)) {

            AACYFunc  = GrayShrinkDIB_CY;
            cbCYExtra = (sizeof(LONG) * cOut * 3) + cbFreeBuf +
                        ((cOut + 6) * cbSrcPel);

        } else {

            AACYFunc  = ShrinkDIB_CY;
            cbCYExtra = (sizeof(RGBL) * cIn * 3) + cbFreeBuf +
                        (cbInBuf * cbSrcPel);
        }

        break;

    case AACYMODE_SHRINK_SRKCX:

        AACYFunc  = ShrinkDIB_CY_SrkCX;
        cbFreeBuf = (sizeof(LONG) * 256 * 2);
        cbCYExtra = (sizeof(RGBL) * (pAAInfoCX->cAADone + 2) * 3) + cbFreeBuf;
        break;

    case AACYMODE_EXPAND:

        AACYFunc  = (cbSrcPel == sizeof(BYTE)) ? GrayExpandDIB_CY :
                                                 ExpandDIB_CY;
        cbCYExtra = (cbFreeBuf = (sizeof(LONG) * 256 * 4)) +
                    ((cOut + 6) * cbSrcPel * 6);
        break;

    case AACYMODE_EXPAND_EXPCX:

        //
        // This function use IputBufBeg to sharpening the input scanline so we
        // need 4 extra BGR8 for running the expand pre-read
        //

        if (aabbp.AAHFlags & AAHF_FAST_EXP_AA) {

            DBGP_IF(DBGP_AAHEADER, DBGP("Use FastExpAA_CY functions"));

            cbCYExtra = (cbInBuf * 5 * cbSrcPel);
            AACYFunc  = (AACYFUNC)FastExpAA_CY;

        } else {

            AACYFunc  = (cbSrcPel == sizeof(BYTE)) ? GrayExpandDIB_CY_ExpCX :
                                                     ExpandDIB_CY_ExpCX;
            cbCYExtra = (cbFreeBuf = (sizeof(LONG) * 256 * 4)) +
                        (cbInBuf * cbSrcPel * 3) + ((cOut + 6) * cbSrcPel * 4);
        }

        break;
    }

    cbAlphaBuf                = (aabbp.AAHFlags & AAHF_ALPHA_BLEND) ? cOut : 0;
    pAAHdr->DstSurfInfo.Flags = (cbSrcPel == sizeof(BYTE)) ? AASIF_GRAY : 0;
    pAAHdr->DstSurfInfo.cbCX  = cbAlphaBuf * cbSrcPel;

    ALIGN_MEM(cbAlphaBuf, (cbAlphaBuf + 2 + 6) * cbSrcPel);
    ALIGN_MEM(cbCYExtra, cbCYExtra);

    //
    // cbInBuf is for the input scan line of EXPAND/SHRINK mode, add one
    // because we want to run it in DWORD mode so we need at least an extra
    // byte at end of input buffer
    //
    // 26-Jun-1998 Fri 16:03:26 updated  -by-  Daniel Chou (danielc)
    //  The cbOutBuf is used only when we flipping in X direction, this is
    //  needed since the input/output buffer may collide into each other
    //

    ALIGN_MEM(cbInBuf,  (cbInBuf + 2) * cbSrcPel);
    ALIGN_MEM(cbOutBuf, (cOut + (FAST_MAX_CX * 2)) * sizeof(BGRF));

    cbMaskSrc = (aabbp.AAHFlags & AAHF_HAS_MASK) ?
                        (ComputeBytesPerScanLine(BMF_1BPP, 4, cIn) + 4) : 0;
    cbMaskSrc = _ALIGN_MEM(cbMaskSrc);

    if (cbInBuf < cbAlphaBuf) {

        cbInBuf = cbAlphaBuf;
    }

    if ((aabbp.AAHFlags & (AAHF_ALPHA_BLEND | AAHF_CONST_ALPHA)) ==
                                                            AAHF_ALPHA_BLEND) {

        ALIGN_MEM(cbAlphaBuf, cOut);

    } else {

        cbAlphaBuf = 0;
    }

    DBGP_IF(DBGP_FIXUPDIB,
            DBGP("** Allocate cIn=%ld, cOut=%ld, cbInBuf=%ld, cbOutBuf=%ld, cbMaskSrc=%ld"
                ARGDW(cIn) ARGDW(cOut) ARGDW(cbInBuf) ARGDW(cbOutBuf)
                ARGDW(cbMaskSrc)));


    if ((DstSurfFmt == BMF_8BPP_VGA256) && (pHR->pXlate8BPP)) {

        ALIGN_MEM(cbVGA256Xlate, SIZE_XLATE_666);

        DBGP_IF((DBGP_AAHTPAT | DBGP_AAHT_MEM),
                DBGP("Allocate %ld bytes of Xlate8BPP" ARGDW(cbVGA256Xlate)));

    } else {

        cbVGA256Xlate = 0;
    }

    if (aabbp.AAHFlags & AAHF_DO_FIXUPDIB) {

        ALIGN_MEM(cbFUDI, (cIn + 4) * cbSrcPel);

    } else {

        cbFUDI = 0;
    }

    if ((pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY)                    &&
        (pHR->BFInfo.Flags & BFIF_RGB_888)                          &&
        (pAAHdr->SrcSurfInfo.AABFData.Flags & AABF_MASK_IS_ORDER)   &&
        (pHR->BFInfo.RGBOrder.Index != PRIMARY_ORDER_BGR)) {

        //
        // This is for mapping >= 16bpp source's IdxBGR to gray, when mapping
        // to gray we will make IdxBGR to a correct source order so that it
        // will optimized the source input function speed
        //
        // The AABF_MASK_IS_ORDER indicate the source is 8-bits each of Red,
        // green and blue and it is only occuply lower 24-bits of either
        // a 24-bits or a 32-bits data
        //

        ALIGN_MEM(cbIdxBGR, sizeof(LONG) * 256 * 3);

        DBGP_IF(DBGP_AAHEADER,
                DBGP("Allocate gray non 24bits BGR [%ld] IDXBGR of %ld bytes"
                        ARGDW(pHR->BFInfo.RGBOrder.Index) ARGDW(cbIdxBGR)));

    } else {

        cbIdxBGR = 0;
    }

    if (pAAInfoCY = aabbp.AABuildCYFunc(pDCI,
                                        aabbp.AAHFlags,
                                        &aabbp.rclSrc.top,
                                        &aabbp.rclSrc.bottom,
                                        pSrcSI->Height,
                                        aabbp.rclDstOrg.top,
                                        aabbp.rclDstOrg.bottom,
                                        &aabbp.rclDst.top,
                                        &aabbp.rclDst.bottom,
                                        cbInBuf + cbOutBuf + cbMaskSrc +
                                            (cbFUDI * 6) + cbAlphaBuf +
                                            cbIdxBGR +
                                            cbVGA256Xlate + cbCYExtra))
    {
        //  Bug 27036:  reject empty rectangles
        if(!pAAInfoCY->cIn  ||  !pAAInfoCY->cOut)
        {
#if 0
            LONG crash = 1 ;   // empty src or dest rectangle!
            crash /= (pAAInfoCY->cIn * pAAInfoCY->cOut);            //  delete when debugging is complete.
            if(crash)
                return 0 ;
#endif
            HTFreeMem(pAAInfoCX);
            HTFreeMem(pAAInfoCY);
            return 0 ;
        }


        pbExtra                   = pAAInfoCY->pbExtra + cbCYExtra;
        pAAHdr->Flags             = aabbp.AAHFlags;
        pAAHdr->SrcSurfInfo.cbCX  = cbSrcPel * cIn;
        pAAHdr->pInputBeg         = (PBGR8)pbExtra;
        pbExtra                  += cbInBuf;

        if (cbAlphaBuf) {

            //
            // 04-Aug-2000 Fri 10:31:45 updated  -by-  Daniel Chou (danielc)
            //  Since cbAlphaBuf is Memoey Aliged Adjusted, we want the
            //  pSrcAVEnd to be at exactly count of cOut not cbAlphaBuf
            //

            pAAHdr->pSrcAV     =
            pAAHdr->pSrcAVBeg  = (LPBYTE)pbExtra;
            pAAHdr->pSrcAVEnd  = (LPBYTE)pbExtra + cOut;
            pbExtra           += cbAlphaBuf;
            pAAHdr->SrcAVInc   = sizeof(BYTE);
        }

        if (cbFUDI) {

            pAAHdr->pbFixupDIB = (LPBYTE)pbExtra;
            pAAHdr->FUDI.cbbgr = (DWORD)cbFUDI;

            for (Top = 0; Top < 6; Top++) {

                pAAHdr->FUDI.prgbD[Top]  = (PBGR8)pbExtra;
                pbExtra                 += cbFUDI;
            }
        }

        if (cbVGA256Xlate) {

            pAAHdr->pXlate8BPP  = pbExtra;
            pbExtra            += cbVGA256Xlate;
        }

        if (cbMaskSrc) {

            pAAHdr->pMaskSrc  = pbExtra;
            pbExtra          += cbMaskSrc;
        }

        if (cbIdxBGR) {

            //
            // The pIdxBGR is a local version that will be later re-arranged
            // from pAAHdr->pIdxBGR to correct source byte order in
            // SetGrayColorTable() function
            //

            pAAHdr->SrcSurfInfo.pIdxBGR  = (PLONG)pbExtra;
            pbExtra                     += cbIdxBGR;

        } else {

            pAAHdr->SrcSurfInfo.pIdxBGR = pAAHdr->pIdxBGR;
        }

        DBGP_IF(DBGP_AAHEADER,
                DBGP("cbInBuf=%ld, %p-%p" ARGDW(cbInBuf)
                        ARGPTR(pAAHdr->pInputBeg)
                        ARGPTR((LPBYTE)pAAHdr->pInputBeg + cbInBuf)));

        //
        // FAST_MAX_CX are added to both end of AABuf, this is needed when
        // we want to process the output fast, since we may need to extended
        // the computation to the neighbor pixels
        //

        pAAHdr->pOutputBeg  =
        pAAHdr->pRealOutBeg =
        pAAHdr->pAABufBeg   = (PBGRF)pbExtra + FAST_MAX_CX;
        pAAHdr->pRealOutEnd =
        pAAHdr->pOutputEnd  = pAAHdr->pAABufBeg + cOut;
        pAAHdr->pAABufEnd   = pAAHdr->pOutputEnd;

        //
        // Set the BGRF's Flags to 0xFF first, the 0xFF indicate that this
        // pixel need to be output (masked).
        //

        FillMemory((LPBYTE)pAAHdr->pOutputBeg,
                   (LPBYTE)pAAHdr->pOutputEnd - (LPBYTE)pAAHdr->pOutputBeg,
                   PBGRF_MASK_FLAG);

        //
        // We mirror the image by composed the source the the AABuf in
        // reverse way.  Reading the source from left to right but when
        // composed the source buffer (AABuf) we put it from right to left
        //

        if (aabbp.rclDst.left > aabbp.rclDst.right) {

            XCHG(aabbp.rclDst.left, aabbp.rclDst.right, Result);

            pAAHdr->pAABufBeg   = pAAHdr->pOutputEnd - 1;
            pAAHdr->pAABufEnd   = pAAHdr->pOutputBeg - 1;
            pAAHdr->AABufInc    = -(LONG)sizeof(BGRF);
            pAAHdr->pSrcAVBeg   = pAAHdr->pSrcAVEnd - 1;
            pAAHdr->pSrcAVEnd   = pAAHdr->pSrcAV - 1;
            pAAHdr->SrcAVInc    = -pAAHdr->SrcAVInc;

        } else {

            pAAHdr->AABufInc  = (LONG)sizeof(BGRF);
        }

        pAAHdr->ptlBrushOrg.x = aabbp.rclDst.left - aabbp.ptlBrushOrg.x;

        DBGP_IF(DBGP_AAHEADER,
                DBGP("pInput=%p-%p (%ld), pAABuf=%p-%p (%ld), pOutput=%p-%p, DstLeft=%ld"
                    ARGPTR(pAAHdr->pInputBeg)
                    ARGPTR((LPBYTE)pAAHdr->pInputBeg +
                           pAAHdr->SrcSurfInfo.cbCX)
                    ARGL(pAAHdr->SrcSurfInfo.cbCX)
                    ARGPTR(pAAHdr->pAABufBeg) ARGPTR(pAAHdr->pAABufEnd)
                    ARGDW(pAAHdr->AABufInc)
                    ARGPTR(pAAHdr->pOutputBeg) ARGPTR(pAAHdr->pOutputEnd)
                    ARGDW(aabbp.rclDst.left)));


        if (aabbp.AAHFlags & AAHF_FLIP_Y) {

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("Y Dst=(%ld - %ld)=%ld change it to (%ld - %ld), ptlFlip.y=%ld"
                        ARGDW(aabbp.rclDst.top) ARGDW(aabbp.rclDst.bottom)
                        ARGDW(aabbp.rclDst.bottom - aabbp.rclDst.top)
                        ARGDW(aabbp.ptlFlip.y - aabbp.rclDst.top - 1)
                        ARGDW(aabbp.ptlFlip.y - aabbp.rclDst.bottom - 1)
                        ARGDW(aabbp.ptlFlip.y)));

            aabbp.rclDst.top    = aabbp.ptlFlip.y - aabbp.rclDst.top - 1;
            aabbp.rclDst.bottom = aabbp.ptlFlip.y - aabbp.rclDst.bottom - 1;
        }

        pAAHdr->ptlBrushOrg.y = aabbp.rclDst.top - aabbp.ptlBrushOrg.y;

        DBGP_IF(DBGP_AAHEADER,
                DBGP("BrushOrg=(%ld, %ld) ---> (%ld, %ld)"
                    ARGDW(pBBP->ptlBrushOrg.x) ARGDW(pBBP->ptlBrushOrg.y)
                    ARGDW(pAAHdr->ptlBrushOrg.x) ARGDW(pAAHdr->ptlBrushOrg.y)));

        pAAHdr->pAAInfoCX         = pAAInfoCX;
        pAAHdr->pAAInfoCY         = pAAInfoCY;
        pAAHdr->AACXFunc          = aabbp.AACXFunc;
        pAAHdr->SrcSurfInfo.cx    = pAAInfoCX->cIn;
        pAAHdr->SrcSurfInfo.cyOrg =
        pAAHdr->SrcSurfInfo.cy    = pAAInfoCY->cIn;

        if (aabbp.AAHFlags & AAHF_HAS_MASK) {

            POINTL  MaskEnd;

            cyNext           =
            cxSize           = GET_PHTSI_CXSIZE(pMaskSI);
            aabbp.ptlMask.x += pAAInfoCX->Mask.iBeg;
            aabbp.ptlMask.y += pAAInfoCY->Mask.iBeg;
            MaskEnd.x        = aabbp.ptlMask.x + pAAInfoCX->Mask.iSize;
            MaskEnd.y        = aabbp.ptlMask.y + pAAInfoCY->Mask.iSize;

            if ((aabbp.ptlMask.x < 0)           ||
                (aabbp.ptlMask.y < 0)           ||
                (MaskEnd.x > pMaskSI->Width)    ||
                (MaskEnd.y > pMaskSI->Height)) {

                HTFreeMem(pAAInfoCX);
                HTFreeMem(pAAInfoCY);

                return(HTERR_SRC_MASK_BITS_TOO_SMALL);
            }

            pAAHdr->cyMaskNext = cyNext;
            pAAHdr->cyMaskIn   = pAAInfoCY->Mask.iSize;
            iFree              = ComputeByteOffset(BMF_1BPP,
                                                   MaskEnd.x,
                                                   &(pAAHdr->MaskBitOff));
            cbFreeBuf          = ComputeByteOffset(BMF_1BPP,
                                                   aabbp.ptlMask.x,
                                                   &(pAAHdr->MaskBitOff));
            pAAHdr->cbMaskSrc  = iFree - cbFreeBuf + 1;
            pAAHdr->pMaskIn    = pMaskSI->pPlane +
                                 (aabbp.ptlMask.y * cxSize) + cbFreeBuf;

            DBGP_IF(DBGP_MASK | DBGP_AAHEADER,
                    DBGP("CX: iMaskBeg=%ld, iMaskSize=%ld, cMaskIn=%ld, cMaskOut=%ld"
                        ARGDW(pAAInfoCX->Mask.iBeg) ARGDW(pAAInfoCX->Mask.iSize)
                        ARGDW(pAAInfoCX->Mask.cIn) ARGDW(pAAInfoCX->Mask.cOut)));

            DBGP_IF(DBGP_MASK | DBGP_AAHEADER,
                    DBGP("CY: iMaskBeg=%ld, iMaskSize=%ld, cMaskIn=%ld, cMaskOut=%ld"
                        ARGDW(pAAInfoCY->Mask.iBeg) ARGDW(pAAInfoCY->Mask.iSize)
                        ARGDW(pAAInfoCY->Mask.cIn) ARGDW(pAAInfoCY->Mask.cOut)));

            DBGP_IF(DBGP_MASK | DBGP_AAHEADER,
                    DBGP("aabbp.ptlMask x=%ld - %ld, cb=%ld, MaskBitOff=%02lx [%ld]"
                        ARGDW(aabbp.ptlMask.x) ARGDW(MaskEnd.x)
                        ARGDW(pAAHdr->cbMaskSrc) ARGDW(pAAHdr->MaskBitOff)
                        ARGDW(cbFreeBuf)));

            //
            // 0x01 in the source means use modified pixel, for the
            // reason of or in the mask, we will use 0=0xFF, 1=0x00
            // in the mask
            //


            if (pBBP->Flags & BBPF_INVERT_SRC_MASK) {

                aabbp.AAHFlags |= AAHF_INVERT_MASK;
            }

            pAAHdr->AAMaskCXFunc = aabbp.AAMaskCXFunc;
            pAAHdr->AAMaskCYFunc = aabbp.AAMaskCYFunc;

            SETDBGVAR(cCXMask, 0);

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("--- SrcMask=(%5ld, %5ld)->(%5ld, %5ld) ---"
                        ARGDW(pBBP->ptlSrcMask.x) ARGDW(pBBP->ptlSrcMask.y)
                        ARGDW(aabbp.ptlMask.x) ARGDW(aabbp.ptlMask.y)));
        }

        cyNext =
        cxSize = GET_PHTSI_CXSIZE(pSrcSI);

        pAAHdr->cyABNext           =
        pAAHdr->SrcSurfInfo.cyNext = cyNext;
        pAAHdr->SrcSurfInfo.pbOrg  =
        pAAHdr->SrcSurfInfo.pb     =
                    pSrcSI->pPlane + (aabbp.rclSrc.top * cxSize) +
                    ComputeByteOffset((UINT)pSrcSI->SurfaceFormat,
                                      aabbp.rclSrc.left,
                                      &(pAAHdr->SrcSurfInfo.BitOffset));

        pAAHdr->GetAVCXFunc = aabbp.GetAVCXFunc;
        pAAHdr->GetAVCYFunc = aabbp.GetAVCYFunc;

        DBGP_IF(DBGP_AAHEADER,
                DBGP("**  pIn: (%p-%p), Beg=(%4ld, %4ld)=%p [%5ld], XOff=%4ld:%ld, cbCYExtra=%p-%p (%ld)"
                ARGPTR(pSrcSI->pPlane)
                ARGPTR(pSrcSI->pPlane + (cxSize * pSrcSI->Height))
                ARGDW(aabbp.rclSrc.left) ARGDW(aabbp.rclSrc.top)
                ARGPTR(pAAHdr->SrcSurfInfo.pb)
                ARGDW(pAAHdr->SrcSurfInfo.cyNext)
                ARGDW(ComputeByteOffset((UINT)pSrcSI->SurfaceFormat,
                                        aabbp.rclSrc.left,
                                        &(pAAHdr->SrcSurfInfo.BitOffset)))
                ARGDW(pAAHdr->SrcSurfInfo.BitOffset)
                ARGPTR(pAAInfoCY->pbExtra)
                ARGPTR(pAAInfoCY->pbExtra + cbCYExtra)
                ARGDW(cbCYExtra)));

        //
        // We do up-side-down output by writing to the destination scan lines
        // in reverse order.
        //

        cxSize = GET_PHTSI_CXSIZE(pDstSI);
        cyNext = (aabbp.rclDst.top > aabbp.rclDst.bottom) ? -cxSize :
                                                             cxSize;
        pAAHdr->DstSurfInfo.cyNext = cyNext;
        pAAHdr->DstSurfInfo.pbOrg  =
        pAAHdr->DstSurfInfo.pb     =
                    pDstSI->pPlane + (aabbp.rclDst.top * cxSize) +
                    ComputeByteOffset((UINT)DstSurfFmt,
                                      aabbp.rclDst.left,
                                      &(pAAHdr->DstSurfInfo.BitOffset));
        pAAHdr->pOutLast          = pAAHdr->DstSurfInfo.pb +
                                    (pAAHdr->DstSurfInfo.cyNext *
                                     pAAInfoCY->cOut);
        pAAHdr->DstSurfInfo.cx    = cOut;
        pAAHdr->DstSurfInfo.cyOrg =
        pAAHdr->DstSurfInfo.cy    = pAAInfoCY->cOut;
        pAAHdr->Flags             = aabbp.AAHFlags;     // Re-Save
        *pAACYFunc                = AACYFunc;

#if DBG
        pAAHdr->pOutBeg = pDstSI->pPlane +
                          (aabbp.rclDst.top * cxSize) +
                          ComputeByteOffset((UINT)DstSurfFmt,
                                            aabbp.rclDst.left,
                                            (LPBYTE)&iFree);
        pAAHdr->pOutEnd = pDstSI->pPlane +
                          (aabbp.rclDst.bottom * cxSize) +
                          ComputeByteOffset((UINT)DstSurfFmt,
                                            aabbp.rclDst.right,
                                            (LPBYTE)&iFree);

        if (pAAHdr->pOutBeg > pAAHdr->pOutEnd) {

            pAAHdr->pOutEnd = pDstSI->pPlane +
                              (aabbp.rclDst.top * cxSize) +
                              ComputeByteOffset((UINT)DstSurfFmt,
                                                aabbp.rclDst.right,
                                                (LPBYTE)&iFree);
            pAAHdr->pOutBeg = pDstSI->pPlane +
                              (aabbp.rclDst.bottom * cxSize) +
                              ComputeByteOffset((UINT)DstSurfFmt,
                                                aabbp.rclDst.left,
                                                (LPBYTE)&iFree);

        }
#endif

        //
        // Check it out if we need to fixup the input source bitmap
        //

        if (aabbp.AAHFlags & AAHF_TILE_SRC) {

            //
            // Increase the source cy and adjust pIn now
            //

            pAAHdr->SrcSurfInfo.Flags |= AASIF_TILE_SRC;

            DBGP_IF(DBGP_AAHEADER,
                    DBGP("Advance pIn by iSrcBeg=%ld x %ld=%ld"
                            ARGDW(pAAInfoCY->iSrcBeg)
                            ARGDW(pAAHdr->SrcSurfInfo.cyNext)
                            ARGDW(pAAInfoCY->iSrcBeg *
                                  pAAHdr->SrcSurfInfo.cyNext)));

            pAAHdr->SrcSurfInfo.pb += pAAInfoCY->iSrcBeg *
                                      pAAHdr->SrcSurfInfo.cyNext;
            pAAHdr->SrcSurfInfo.cy -= pAAInfoCY->iSrcBeg;
        }

        pAAHdr->pbgrfAB  = (PBGRF)pAAHdr->SrcSurfInfo.pb;
        pAAHdr->cybgrfAB = pAAHdr->SrcSurfInfo.cy;

        DBGP_IF(DBGP_AAHEADER,
                DBGP("** pOut: (%p-%p), Beg=(%4ld, %4ld)=%p-%p (%p-%p) [%5ld], XOff=%4ld:%ld, cbCYExtra=%5ld"
                ARGPTR(pDstSI->pPlane)
                ARGPTR(pDstSI->pPlane + (cxSize * pDstSI->Height))
                ARGDW(aabbp.rclDst.left) ARGDW(aabbp.rclDst.top)
                ARGPTR(pAAHdr->DstSurfInfo.pb) ARGPTR(pAAHdr->pOutLast)
                ARGPTR(pAAHdr->pOutBeg) ARGPTR(pAAHdr->pOutEnd)
                ARGDW(pAAHdr->DstSurfInfo.cyNext)
                ARGDW(ComputeByteOffset((UINT)DstSurfFmt,
                                        aabbp.rclDst.left,
                                        &(pAAHdr->DstSurfInfo.BitOffset)))
                ARGDW(pAAHdr->DstSurfInfo.BitOffset)
                ARGDW(cbCYExtra)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("--- BrushOrg=(%5ld, %5ld)->(%5ld, %5ld) ---"
                ARGDW(pBBP->ptlBrushOrg.x) ARGDW(pBBP->ptlBrushOrg.y)
                ARGDW(pAAHdr->ptlBrushOrg.x) ARGDW(pAAHdr->ptlBrushOrg.y)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("pAAHdr=%p - %p, (%ld bytes)"
                    ARGPTR(pAAHdr) ARGPTR((LPBYTE)pAAHdr + pAAHdr->cbAlloc)
                    ARGDW(pAAHdr->cbAlloc)));

        DBGP_IF(DBGP_AAHEADER,
                DBGP("pAAInfoCX=%p-%p (%ld), pAAInfoCY=%p-%p (%ld)"
                    ARGPTR(pAAInfoCX)
                    ARGPTR((LPBYTE)pAAInfoCX + pAAInfoCX->cbAlloc)
                    ARGDW(pAAInfoCX->cbAlloc)
                    ARGPTR(pAAInfoCY)
                    ARGPTR((LPBYTE)pAAInfoCY + pAAInfoCY->cbAlloc)
                    ARGDW(pAAInfoCY->cbAlloc)));

        DBGP_IF(DBGP_FUNC,
                DBGP("AACYFunc=%hs, AACXFunc=%hs"
                        ARGPTR(GetAACYFuncName(*pAACYFunc))
                        ARGPTR(GetAACXFuncName(aabbp.AACXFunc))));

        return(1);
    }

    HTFreeMem(pAAInfoCX);

    return(HTERR_INSUFFICIENT_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htalias.h ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation


Module Name:

    htalias.h


Abstract:

    This module contains defines and structure for anti-aliasing


Author:

    09-Apr-1998 Thu 20:25:29 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _HTALIAS_
#define _HTALIAS_


#define XCHG(a,b,t) { (t)=(a); (a)=(b); (b)=(t); }


#define DI_R_SHIFT      13
#define DI_MAX_NUM      (0x0001 << DI_R_SHIFT)
#define DI_NUM_MASK     (DI_MAX_NUM - 1)

#define DI_MUL_SHIFT    (DI_R_SHIFT >> 1)
#define MUL_TABLE_SIZE  (DI_MUL_SHIFT * 256 * sizeof(LONG))

#define AABF_MASK_IS_ORDER      0x01
#define AABF_SRC_IS_BGR8        0x02
#define AABF_SRC_IS_BGR_ALPHA   0x04
#define AABF_SRC_IS_RGB_ALPHA   0x08

typedef struct _AABFDATA {
    BYTE    Flags;
    BYTE    Format;
    BYTE    MaskRGB[3];
    BYTE    LShiftRGB[3];
    BYTE    RShiftRGB[3];
    BYTE    cbSrcInc;
    } AABFDATA, *PAABFDATA;


#define GET_FIRST_EDMUL(em, m, n, t)                                        \
{                                                                           \
    (n)  = ((LONGLONG)(m) * (LONGLONG)DI_MAX_NUM);                          \
    (em) = (WORD)((n) / (LONGLONG)(t));                                     \
}

#define GET_NEXT_EDMUL(em, m, n, t)                                         \
{                                                                           \
    (n)  = ((LONGLONG)(m) * (LONGLONG)DI_MAX_NUM) + ((n) % (LONGLONG)(t));  \
    (em) = (WORD)((n) / (LONGLONG)(t));                                     \
}


#define SDF_LARGE_MUL           (0x0001 << (DI_R_SHIFT + 2))
#define SDF_DONE                (0x0001 << (DI_R_SHIFT + 1))
#define SDF_MUL_MASK            (0xFFFF >> (15 - DI_R_SHIFT))

#define GET_SDF_LARGE_MASK(m)   (BYTE)((SHORT)(m) >> 15)
#define GET_SDF_LARGE_INC(m)    (UINT)((m) >> 15)
#define GET_SDF_LARGE_OFF(m)    (((UINT)(m) >> ((DI_R_SHIFT+2)-10)) & 0x400)

typedef struct _SHRINKDATA {
    WORD    Mul;
    } SHRINKDATA, *PSHRINKDATA;


#define EDF_LOAD_PIXEL          0x8000
#define EDF_NO_NEWSRC           0x4000

typedef struct _EXPDATA {
    WORD    Mul[4];
    } EXPDATA, *PEXPDATA;


#define AAIF_EXP_HAS_1ST_LEFT       0x0001
#define AAIF_EXP_NO_LAST_RIGHT      0x0002
#define AAIF_EXP_NO_SHARPEN         0x0004

typedef struct _REPDATA {
    WORD    c;
    } REPDATA, *PREPDATA;


typedef struct _SRCBLTINFO {
    LONG        cIn;
    LONG        cOut;
    LONG        iBeg;
    LONG        iSize;
    LONG        iSrcBeg;
    LONG        iSrcEnd;
    LONG        iDstBeg;
    LONG        iDstEnd;
    BYTE        cPrevSrc;
    BYTE        cNextSrc;
    BYTE        cFirstSkip;
    BYTE        cLastSkip;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    } SRCBLTINFO, *PSRCBLTINFO;

typedef struct _AAINFO {
    LONG        cIn;            // Input pixels Count
    LONG        cOut;           // Output Pixel Count
    WORD        Flags;          // AAIF_xxxx
    WORD        PreSrcInc;      // For shrinking
    WORD        cPreLoad;       // Preload
    WORD        PreMul;         // pre mul for shrinking
    DWORD       cAAData;
    union {
        DWORD   cAALoad;        // for expand, blt
        DWORD   cAADone;        // for shrinking
        } DUMMYUNIONNAME2;
    union {
        PLONG   pMapMul;        // use by SHRINK
        DWORD   cMaxMul;        // use by EXPAND
        LONG    iSrcBeg;        // use by TILE (Offset for the first one)
        } DUMMYUNIONNAME3;
    LPBYTE      pbExtra;        // extra buffer allocated
    LPVOID      pAAData;        // either PEXPDATA or PSHRINKDATA
    SRCBLTINFO  Src;
    SRCBLTINFO  Mask;
    SRCBLTINFO  AB;
#if DBG
    DWORD       cbAlloc;        // allocating size
#endif
    } AAINFO, *PAAINFO;

typedef VOID (HTENTRY *AACXFUNC)(PAAINFO    pAAInfo,
                                 PBGR8      pIn,
                                 PBGR8      pOut,
                                 LPBYTE     pOutEnd,
                                 LONG       OutInc);

typedef LONG (HTENTRY *AACYFUNC)(struct _AAHEADER   *pAAHdr);


typedef PBGR8 (HTENTRY *AAINPUTFUNC)(struct _AASURFINFO *pAASI,
                                     PBGR8              pInBuf);


#define XLATE_666_IDX_OR            0x01
#define XLATE_RGB_IDX_OR            0x02
#define XLATE_IDX_MASK              (XLATE_RGB_IDX_OR | XLATE_666_IDX_OR)
#define XLATE_IDX_MAX               3


typedef struct _BM8BPPDATA {
    BYTE    pXlateIdx;
    BYTE    bXor;
    BYTE    bBlack;
    BYTE    bWhite;
    } BM8BPPDATA, *PBM8BPPDATA;

typedef union _BM8BPPINFO {
    DWORD       dw;
    BYTE        b4[4];
    BM8BPPDATA  Data;
    } BM8BPPINFO, *PBM8BPPINFO;

typedef struct _AABGRINFO {
    BYTE    Order;
    BYTE    iR;
    BYTE    iG;
    BYTE    iB;
    } AABGRINFO;

typedef struct AABITMASKINFO {
    BYTE    cFirst;
    BYTE    XorMask;
    BYTE    LSFirst;
    BYTE    cLast;
    } AABITMASKINFO;

typedef struct _AAOUTPUTINFO {
    union {
        AABITMASKINFO       bm;
        AABGRINFO           bgri;
        BM8BPPINFO          bm8i;
        LPBYTE              pXlate8BPP;
        PCMY8BPPMASK        pCMY8BPPMask;
        BYTE                b4[4];
        WORD                w2[2];
        DWORD               dw;
        } DUMMYUNIONNAME;
    } AAOUTPUTINFO, *PAAOUTPUTINFO;



typedef VOID (HTENTRY *AAOUTPUTFUNC)(struct _AAHEADER    *pAAHdr,
                                     PBGRF               pInBeg,
                                     PBGRF               pInEnd,
                                     LPBYTE              pDst,
                                     PLONG               pIdxBGR,
                                     LPBYTE              pbPat,
                                     LPBYTE              pbPatEnd,
                                     LONG                cbWrapBGR,
                                     AAOUTPUTINFO        AAOutputInfo);


typedef VOID (HTENTRY *AAMASKFUNC)(struct _AAHEADER *pAAHdr);

#define FAST_MAX_CX             5
#define FAST_MAX_CY             5



#define AAHF_FLIP_X             0x00000001
#define AAHF_FLIP_Y             0x00000002
#define AAHF_ADDITIVE           0x00000004
#define AAHF_DO_SRC_CLR_MAPPING 0x00000008
#define AAHF_DO_DST_CLR_MAPPING 0x00000010
#define AAHF_GET_LAST_SCAN      0x00000020
#define AAHF_DO_FIXUPDIB        0x00000040
#define AAHF_HAS_MASK           0x00000080
#define AAHF_INVERT_MASK        0x00000100
#define AAHF_BBPF_AA_OFF        0x00000200
#define AAHF_TILE_SRC           0x00000400
#define AAHF_ALPHA_BLEND        0x00000800
#define AAHF_CONST_ALPHA        0x00001000
#define AAHF_OR_AV              0x00002000
#define AAHF_FAST_EXP_AA        0x00004000
#define AAHF_SHRINKING          0x00080000
#define AAHF_AB_DEST            0x00100000
#define AAHF_USE_DCI_DATA       0x80000000

#define AAHF_DO_CLR_MAPPING     (AAHF_DO_SRC_CLR_MAPPING |                  \
                                 AAHF_DO_DST_CLR_MAPPING)


#define PBGRF_MASK_FLAG         0xFF
#define PBGRF_END_FLAG          0xED
#define PBGRF_HAS_MASK(p)       ((p)->f)


typedef struct _FIXUPDIBINFO {
    PBGR8   prgbD[6];
    DWORD   cbbgr;
    LONG    cyIn;
#if DBG
    LONG    cCorner;
    LONG    cChecker;
#endif
    } FIXUPDIBINFO;


#define AASIF_TILE_SRC          0x01
#define AASIF_INC_PB            0x02
#define AASIF_GRAY              0x04
#define AASIF_AB_PREMUL_SRC     0x08

typedef struct _AASURFINFO {
    BYTE        Flags;
    BYTE        BitOffset;
    WORD        cClrTable;
    PLONG       pIdxBGR;
    AAINPUTFUNC InputFunc;
    LPBYTE      pbOrg;
    LONG        cyOrg;
    LPBYTE      pb;
    LONG        cx;
    LONG        cy;
    LONG        cbCX;
    LONG        cyNext;
    AABFDATA    AABFData;
    PRGB4B      pClrTable;
    } AASURFINFO, *PAASURFINFO;



typedef struct _AAHEADER {
    DWORD           Flags;
    BYTE            MaskBitOff;
    BYTE            bReserved[3];
    AASURFINFO      SrcSurfInfo;
    AASURFINFO      DstSurfInfo;
    AAMASKFUNC      AAMaskCXFunc;
    AAMASKFUNC      AAMaskCYFunc;
    LONG            cbMaskSrc;
    LPBYTE          pMaskSrc;
    LPBYTE          pMaskIn;
    LONG            cyMaskNext;
    LONG            cyMaskIn;
    AAMASKFUNC      GetAVCXFunc;
    AAMASKFUNC      GetAVCYFunc;
    PBGRF           pbgrfAB;
    LONG            cybgrfAB;
    LONG            cyABNext;
    LPBYTE          pbFixupDIB;
    AAOUTPUTFUNC    AAOutputFunc;
    AAOUTPUTINFO    AAOutputInfo;
    AACXFUNC        AACXFunc;
    AACYFUNC        AACYFunc;
    PAAINFO         pAAInfoCX;
    PAAINFO         pAAInfoCY;
    LPBYTE          pOutLast;
    POINTL          ptlBrushOrg;
    LPBYTE          pAlphaBlendBGR;
    LPBYTE          pSrcAV;
    LPBYTE          pSrcAVBeg;
    LPBYTE          pSrcAVEnd;
    LONG            SrcAVInc;
    PRGBLUTAA       prgbLUT;
    PLONG           pIdxBGR;
    PBGR8           pBGRMapTable;
    LPBYTE          pXlate8BPP;
    AAPATINFO       AAPI;
    FIXUPDIBINFO    FUDI;
    PBGR8           pInputBeg;      // For input the source
    PBGRF           pRealOutBeg;    // original output buffer begin
    PBGRF           pRealOutEnd;    // original output buffer end
    PBGRF           pOutputBeg;     // for output to the destination the
    PBGRF           pOutputEnd;     // pOutputEnd  (will be modified)
    PBGRF           pAABufBeg;      // for temporary anti-aliasing storage
    PBGRF           pAABufEnd;      // This is exclusive
    LONG            AABufInc;       // Buffer increment (may be negative)
#if DBG
    DWORD           cbAlloc;
    LPBYTE          pOutBeg;
    LPBYTE          pOutEnd;
#endif
    } AAHEADER, *PAAHEADER;


typedef PAAINFO (HTENTRY *AABUILDFUNC)(PDEVICECOLORINFO pDCI,
                                       DWORD            AAHFlags,
                                       PLONG            piSrcBeg,
                                       PLONG            piSrcEnd,
                                       LONG             SrcSize,
                                       LONG             cOut,
                                       LONG             IdxDst,
                                       PLONG            piDstBeg,
                                       PLONG            piDstEnd,
                                       LONG             cbExtra);


#define AACYMODE_TILE           0
#define AACYMODE_BLT            1
#define AACYMODE_SHRINK         2
#define AACYMODE_SHRINK_SRKCX   3
#define AACYMODE_EXPAND         4
#define AACYMODE_EXPAND_EXPCX   5
#define AACYMODE_NONE           0xFF

#define AACXMODE_BLT            0
#define AACXMODE_SHRINK         1
#define AACXMODE_EXPAND         2

typedef struct _AABBP {
    DWORD           AAHFlags;
    BYTE            CYFuncMode;
    BYTE            CXFuncMode;
    WORD            wReserved;
    AACXFUNC        AACXFunc;
    AABUILDFUNC     AABuildCXFunc;
    AABUILDFUNC     AABuildCYFunc;
    AAMASKFUNC      AAMaskCXFunc;
    AAMASKFUNC      AAMaskCYFunc;
    AAMASKFUNC      GetAVCXFunc;
    AAMASKFUNC      GetAVCYFunc;
    RECTL           rclSrc;         // original source, not well ordered
    RECTL           rclDst;         // Final destination, well ordered
    RECTL           rclDstOrg;      // Original Destination, well ordered
    POINTL          ptlFlip;        // flipping's substraction
    LONG            cxDst;
    LONG            cyDst;
    POINTL          ptlBrushOrg;
    POINTL          ptlMask;        // Final source mask offset
    } AABBP, *PAABBP;




//
// Function prototype
//

VOID
HTENTRY
SetGrayColorTable(
    PLONG       pIdxBGR,
    PAASURFINFO pAASI
    );

VOID
HTENTRY
GetColorTable(
    PHTSURFACEINFO  pSrcSI,
    PAAHEADER       pAAHdr,
    PBFINFO         pBFInfo
    );

VOID
HTENTRY
ComputeInputColorInfo(
    LPBYTE      pSrcTable,
    UINT        cPerTable,
    UINT        PrimaryOrder,
    PBFINFO     pBFInfo,
    PAASURFINFO pAASI
    );

LONG
HTENTRY
SetupAAHeader(
    PHALFTONERENDER     pHR,
    PDEVICECOLORINFO    pDCI,
    PAAHEADER           pAAHdr,
    AACYFUNC            *pAACYFunc
    );



#endif      // _HTALIAS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htapi.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htapi.c


Abstract:

    This module contains all the halftone entry points which communicate
    with caller to the halftone dll.


Author:

    05-Feb-1991 Tue 10:52:03 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/

#define DBGP_VARNAME        dbgpHTAPI

#define _HTAPI_ENTRY_

#include "htp.h"
#include "htmapclr.h"
#include "htpat.h"
#include "htrender.h"
#include "htmath.h"
#include "htalias.h"
#include "htsetbmp.h"
#include "stdio.h"

#define INCLUDE_DEF_CIEINFO
#include "htapi.h"


#define DBGP_SHOWPAT        0x00000001
#define DBGP_TIMER          0x00000002
#define DBGP_CACHED_DCI     0x00000004
#define DBGP_CACHED_SMP     0x00000008
#define DBGP_DISABLE_HT     0x00000010
#define DBGP_DYECORRECTION  0x00000020
#define DBGP_DHI_MEM        0x00000040
#define DBGP_COMPUTE_L2I    0x00000080
#define DBGP_HTMUTEX        0x00000100
#define DBGP_GAMMA_PAL      0x00000200
#define DBGP_CHB            0x00000400
#define DBGP_DEVPELSDPI     0x00000800
#define DBGP_SRCBMP         0x00001000
#define DBGP_TILE           0x00002000
#define DBGP_HTAPI          0x00004000
#define DBGP_MEMLINK        0x00008000
#define DBGP_SHOW_CSMBMP    0x00010000



DEF_DBGPVAR(BIT_IF(DBGP_SHOWPAT,        0)  |
            BIT_IF(DBGP_TIMER,          0)  |
            BIT_IF(DBGP_CACHED_DCI,     0)  |
            BIT_IF(DBGP_CACHED_SMP,     0)  |
            BIT_IF(DBGP_DISABLE_HT,     0)  |
            BIT_IF(DBGP_DYECORRECTION,  0)  |
            BIT_IF(DBGP_DHI_MEM,        0)  |
            BIT_IF(DBGP_COMPUTE_L2I,    0)  |
            BIT_IF(DBGP_HTMUTEX,        0)  |
            BIT_IF(DBGP_GAMMA_PAL,      0)  |
            BIT_IF(DBGP_CHB,            0)  |
            BIT_IF(DBGP_DEVPELSDPI,     0)  |
            BIT_IF(DBGP_SRCBMP,         0)  |
            BIT_IF(DBGP_TILE,           0)  |
            BIT_IF(DBGP_HTAPI,          0)  |
            BIT_IF(DBGP_MEMLINK,        0)  |
            BIT_IF(DBGP_SHOW_CSMBMP,    0))


HTGLOBAL    HTGlobal = { (HMODULE)NULL,
                         (HTMUTEX)NULL,
                         (HTMUTEX)NULL,
                         (HTMUTEX)NULL,
                         (PCDCIDATA)NULL,
                         (PCSMPDATA)NULL,
                         (PBGRMAPCACHE)NULL,
                         (LONG)0,
                         (LONG)0,
                         (LONG)0,
                         (WORD)0,
                         (WORD)0
                       };

#define DO_DYES_CORRECTION      0

#define CMY_8BPP(b, i, m, t)                                                \
{                                                                           \
    if ((i) < (m)) {                                                        \
                                                                            \
        (t) = FD6_1 - DivFD6((FD6)(i),(FD6)(m));                            \
        (b) = (BYTE)SCALE_FD6((t), 255);                                    \
                                                                            \
    } else {                                                                \
                                                                            \
        (b) = 0;                                                            \
    }                                                                       \
}


#define RGB_8BPP(rgb)       (BYTE)SCALE_FD6((rgb), 255)
#define GET_DEN_LO(x)       DivFD6((FD6)((((x)     ) & 0xFF) + 1), (FD6)256)
#define GET_DEN_HI(x)       DivFD6((FD6)((((x) >> 8) & 0xFF) + 1), (FD6)256)


#if DBG


LONG
HTENTRY
HT_LOADDS
SetHalftoneError(
    DWORD   HT_FuncIndex,
    LONG    ErrorID
    )
{
    const static  LPSTR   HTApiFuncName[] = {

                        "HalftoneInitProc",
                        "HT_CreateDeviceHalftoneInfo",
                        "HT_DestroyDeviceHalftoneInfo",
                        "HT_CreateHalftoneBrush",
                        "HT_ConvertColorTable",
                        "HT_CreateStandardMonoPattern",
                        "HT_HalftoneBitmap",
                    };


    const static  LPSTR   HTErrorStr[] = {

                        "WRONG_VERSION_HTINITINFO",
                        "INSUFFICIENT_MEMORY",
                        "CANNOT_DEALLOCATE_MEMORY",
                        "COLORTABLE_TOO_BIG",
                        "QUERY_SRC_BITMAP_FAILED",
                        "QUERY_DEST_BITMAP_FAILED",
                        "QUERY_SRC_MASK_FAILED",
                        "SET_DEST_BITMAP_FAILED",
                        "INVALID_SRC_FORMAT",
                        "INVALID_SRC_MASK_FORMAT",
                        "INVALID_DEST_FORMAT",
                        "INVALID_DHI_POINTER",
                        "SRC_MASK_BITS_TOO_SMALL",
                        "INVALID_HTPATTERN_INDEX",
                        "INVALID_HALFTONE_PATTERN",
                        "HTPATTERN_SIZE_TOO_BIG",
                        "NO_SRC_COLORTRIAD",
                        "INVALID_COLOR_TABLE",
                        "INVALID_COLOR_TYPE",
                        "INVALID_COLOR_TABLE_SIZE",
                        "INVALID_PRIMARY_SIZE",
                        "INVALID_PRIMARY_VALUE_MAX",
                        "INVALID_PRIMARY_ORDER",
                        "INVALID_COLOR_ENTRY_SIZE",
                        "INVALID_FILL_SRC_FORMAT",
                        "INVALID_FILL_MODE_INDEX",
                        "INVALID_STDMONOPAT_INDEX",
                        "INVALID_DEVICE_RESOLUTION",
                        "INVALID_TONEMAP_VALUE",
                        "NO_TONEMAP_DATA",
                        "TONEMAP_VALUE_IS_SINGULAR",
                        "INVALID_BANDRECT",
                        "STRETCH_RATIO_TOO_BIG",
                        "CHB_INV_COLORTABLE_SIZE",
                        "HALFTONE_INTERRUPTTED",
                        "HTERR_NO_SRC_HTSURFACEINFO",
                        "HTERR_NO_DEST_HTSURFACEINFO",
                        "HTERR_8BPP_PATSIZE_TOO_BIG",
                        "HTERR_16BPP_555_PATSIZE_TOO_BIG"
                    };

    const static LPSTR    HTPErrorStr[] = {

                        "STRETCH_FACTOR_TOO_BIG",
                        "XSTRETCH_FACTOR_TOO_BIG",
                        "STRETCH_NEG_OVERHANG",
                        "COLORSPACE_NOT_MATCH",
                        "INVALID_SRCRGB_SIZE",
                        "INVALID_DEVRGB_SIZE"
                    };


    LPSTR   pFuncName;
    LONG    ErrorIdx;
    BOOL    MapErrorOk = FALSE;

    if (ErrorID < 0) {

        if (HT_FuncIndex < (sizeof(HTApiFuncName) / sizeof(LPSTR))) {

            pFuncName = HTApiFuncName[HT_FuncIndex];

        } else {

            pFuncName = "Invalid HT API Function Name";
        }

        ErrorIdx = -ErrorID;

        if (ErrorIdx <= (sizeof(HTErrorStr) / sizeof(LPSTR))) {

            DBGP("%s failed: HTERR_%s (%ld)"
                            ARG(pFuncName)
                            ARG(HTErrorStr[ErrorIdx - 1])
                            ARGL(ErrorID));
            DBGP("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

            MapErrorOk = TRUE;

        } else if (ErrorIdx >= -(LONG)HTERR_INTERNAL_ERRORS_START) {

            ErrorIdx += (LONG)HTERR_INTERNAL_ERRORS_START;

            if (ErrorIdx < (sizeof(HTPErrorStr) / sizeof(LPSTR))) {

                DBGP("%s Internal Error: %s (%ld)"
                            ARG(pFuncName)
                            ARG(HTPErrorStr[ErrorIdx])
                            ARGL(ErrorID));
                DBGP("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

                MapErrorOk = TRUE;
            }

        }

        if (!MapErrorOk) {

            DBGP("%s failed: ??Invalid Error ID (%ld)"
                                        ARG(pFuncName) ARGL(ErrorID));
            DBGP("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        }
    }

    return(ErrorID);
}

#endif




BOOL
PASCAL
HT_LOADDS
EnableHalftone(
    VOID
    )

/*++

Routine Description:

    This function initialize all internal halftone global data to have
    halftone DLL/LIB ready to be used

    This function MUST called from ALL API entries which does not required
    a PDEVICEHALFTONEINFO data pointer

Arguments:

    None


Return Value:

    None

Author:

    02-Mar-1993 Tue 19:38:43 created  -by-  Daniel Chou (danielc)

    15-Dec-1995 Fri 16:48:46 updated  -by-  Daniel Chou (danielc)
        All initialization is done at here

Revision History:


--*/

{

    FD6     L;
    UINT    i;


    if (!(HTGlobal.HTMutexBGRMC = CREATE_HTMUTEX())) {

        DBGMSG("InitHTInternalData: CREATE_HTMUTEX(HTMutexBGRMC) failed!");
        return(FALSE);
    }

    HTGlobal.pBGRMC      = NULL;
    HTGlobal.cBGRMC      =
    HTGlobal.cIdleBGRMC  =
    HTGlobal.cAllocBGRMC = 0;

    if (!(HTGlobal.HTMutexCDCI = CREATE_HTMUTEX())) {

        DBGMSG("InitHTInternalData: CREATE_HTMUTEX(HTMutexCDCI) failed!");
        return(FALSE);
    }

    HTGlobal.CDCICount = 0;

    if (!(HTGlobal.HTMutexCSMP = CREATE_HTMUTEX())) {

        DBGMSG("InitHTInternalData: CREATE_HTMUTEX(HTMutexCSMP) failed!");

        return(FALSE);
    }

    HTGlobal.CSMPCount = 0;

    return(TRUE);
}




VOID
PASCAL
HT_LOADDS
DisableHalftone(
    VOID
    )

/*++

Routine Description:

    This function free CDCI/CSMP cached data

Arguments:

    none.

Return Value:

    BOOL

    This function must called when gdisrv.dll is unloaded, sinnce halftone
    is a linked as a library not a individual DLL.

Author:

    20-Feb-1991 Wed 18:42:11 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    HLOCAL          hData;
    PCDCIDATA       pCDCIData;
    PCSMPDATA       pCSMPData;
    PCSMPBMP        pCSMPBmp;
    LONG            i;
    extern LPWORD   ppwHTPat[HTPAT_SIZE_MAX_INDEX];

    DBGP_IF(DBGP_DISABLE_HT,
            DBGP("FreeHTGlobal: UsedCount: CDCI=%u, CSMP=%u"
                 ARGU(HTGlobal.CDCICount)
                 ARGU(HTGlobal.CSMPCount)));

    //
    // Do the BGRMapCache first
    //

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    if (HTGlobal.pBGRMC) {

        for (i = 0; i < HTGlobal.cBGRMC; i++) {

            hData = (HLOCAL)HTGlobal.pBGRMC[i].pMap;

            DBGP_IF(DBGP_DISABLE_HT,
                    DBGP("FreeHTGlobal: HTFreeMem(pBGRMC[%ld].pMap=%p"
                        ARGDW(i) ARGPTR(hData)));

            hData     = HTFreeMem(hData);

            ASSERTMSG("FreeHTGlobal: HTFreeMem(BGRMap) Failed", !hData);
        }

        hData = (HLOCAL)HTGlobal.pBGRMC;

        DBGP_IF(DBGP_DISABLE_HT,
                DBGP("FreeHTGlobal: HTFreeMem(pBGRMC=%p" ARGPTR(hData)));

        hData = HTFreeMem(hData);

        ASSERTMSG("FreeHTGlobal: HTFreeMem(pBGRMC) Failed", !hData);
    }

    HTGlobal.cBGRMC      =
    HTGlobal.cIdleBGRMC  =
    HTGlobal.cAllocBGRMC = 0;
    HTGlobal.pBGRMC      = NULL;

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);
    DELETE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    //
    // Do the CDCI Data first
    //

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCDCI);

    pCDCIData = HTGlobal.pCDCIDataHead;

    while (hData = (HLOCAL)pCDCIData) {

        DBGP_IF(DBGP_DISABLE_HT,
                DBGP("FreeHTGlobal: HTFreeMem(pCDCIDATA=%p"
                    ARGPTR(pCDCIData)));

        pCDCIData = pCDCIData->pNextCDCIData;
        hData     = HTFreeMem(hData);

        ASSERTMSG("FreeHTGlobal: HTFreeMem(CDCI) Failed", !hData);
    }

    HTGlobal.pCDCIDataHead = NULL;
    HTGlobal.CDCICount     = 0;

    RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);
    DELETE_HTMUTEX(HTGlobal.HTMutexCDCI);

    HTGlobal.HTMutexCDCI = (HTMUTEX)0;

    //
    //  Do the bitmap pattern now
    //

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCSMP);

    pCSMPData = HTGlobal.pCSMPDataHead;

    while (pCSMPData) {

        pCSMPBmp = pCSMPData->pCSMPBmpHead;

        while (hData = (HLOCAL)pCSMPBmp) {

            DBGP_IF(DBGP_DISABLE_HT,
                    DBGP("FreeHTGlobal:    HTFreeMem(pCSMPBmp=%p"
                    ARGPTR(pCSMPBmp)));

            pCSMPBmp = pCSMPBmp->pNextCSMPBmp;
            hData    = HTFreeMem(hData);

            ASSERTMSG("FreeHTGlobal: HTFreeMem(CSMPBMP) Failed", !hData);
        }

        hData     = (HLOCAL)pCSMPData;
        pCSMPData = pCSMPData->pNextCSMPData;
        hData     = HTFreeMem(hData);

        DBGP_IF(DBGP_DISABLE_HT,
                DBGP("FreeHTGlobal: HTFreeMem(pCSMPData=%p"
                ARGPTR(pCSMPData)));

        ASSERTMSG("FreeHTGlobal: HTFreeMem(CSMPDATA) Failed", !hData);
    }

    HTGlobal.pCSMPDataHead = NULL;
    HTGlobal.CSMPCount     = 0;

    for (i = 0; i < HTPAT_SIZE_MAX_INDEX; i++) {

        if (hData = (HLOCAL)ppwHTPat[i]) {

            DBGP_IF(DBGP_DISABLE_HT,
                    DBGP("FreeHTPat: HTFreeMem(ppwHTPat[%2ld]=%p"
                                ARGDW(i) ARGPTR(hData)));

            HTFreeMem(hData);
            ppwHTPat[i] = NULL;
        }
    }

    CHK_MEM_LEAK(NULL, HTMEM_BEGIN);

    RELEASE_HTMUTEX(HTGlobal.HTMutexCSMP);
    DELETE_HTMUTEX(HTGlobal.HTMutexCSMP);

    HTGlobal.HTMutexCSMP = (HTMUTEX)NULL;
}




BOOL
HTENTRY
CleanUpDHI(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo
    )

/*++

Routine Description:

    This function clean up (free hMutex/memory) of a DeviceHalftoneInfo

Arguments:

    pDeviceHalftoneInfo - the pDeviceHalftoneInfo must be valid

Return Value:

    BOOL


Author:

    20-Feb-1991 Wed 18:42:11 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    PDEVICECOLORINFO    pDCI;
    HTMUTEX             HTMutex;
    HLOCAL              hData;
    UINT                Loop;
    BOOL                Ok = TRUE;



    pDCI = PDHI_TO_PDCI(pDeviceHalftoneInfo);

    ACQUIRE_HTMUTEX(pDCI->HTMutex);

    HTMutex = pDCI->HTMutex;

    //
    // Free all memory assoicated with this device
    //

    if ((pDCI->HTCell.pThresholds)  &&
        (!(pDCI->HTCell.Flags & HTCF_STATIC_PTHRESHOLDS))) {

        DBGP_IF(DBGP_DHI_MEM,
                DBGP("CleanUpDHI: HTFreeMem(pDCI->HTCell.pThresholds=%p)"
                ARGPTR(pDCI->HTCell.pThresholds)));

        if (HTFreeMem(pDCI->HTCell.pThresholds)) {

            ASSERTMSG("CleanUpDHI: FreeMemory(pDCI->HTCell.pThresholds)", FALSE);
            Ok = FALSE;
        }
    }

    if (hData = (HLOCAL)pDCI->pAlphaBlendBGR) {

        DBGP_IF(DBGP_DHI_MEM,
                DBGP("CleanUpDHI: HTFreeMem(pDCI->pAlphaBlendBGR=%p)"
                ARGPTR(hData)));

        if (HTFreeMem(hData)) {

            ASSERTMSG("CleanUpDHI: FreeMemory(pDCI->pAlphaBlendBGR)", FALSE);
            Ok = FALSE;
        }
    }

    Loop = CRTX_TOTAL_COUNT;

    while (Loop--) {

        if (hData = (HLOCAL)pDCI->CRTX[Loop].pFD6XYZ) {

            DBGP_IF(DBGP_DHI_MEM,
                    DBGP("CleanUpDHI: HTFreeMem(pDCI->CRTX[%u].pFD6XYZ=%p)"
                    ARGU(Loop) ARGPTR(hData)));

            if (HTFreeMem(hData)) {

                ASSERTMSG("CleanUpDHI: FreeMemory(pDCI->CRTX[])", FALSE);
                Ok = FALSE;
            }
        }
    }

    DBGP_IF(DBGP_DHI_MEM,
            DBGP("CleanUpDHI: HTFreeMem(pDHI=%p)"
            ARGPTR(pDeviceHalftoneInfo)));

    if (HTFreeMem(pDeviceHalftoneInfo)) {

        ASSERTMSG("CleanUpDHI: FreeMemory(pDeviceHalftoneInfo)", FALSE);
        Ok = FALSE;
    }

    RELEASE_HTMUTEX(HTMutex);
    DELETE_HTMUTEX(HTMutex);

    return(Ok);
}


BOOL
APIENTRY
HT_LOADDS
HalftoneInitProc(
    HMODULE hModule,
    DWORD   Reason,
    LPVOID  Reserved
    )
/*++

Routine Description:

    This function is DLL main entry point, at here we will save the module
    handle, in the future we will need to do other initialization stuff.

Arguments:

    hModule     - Handle to this moudle when get loaded.

    Reason      - may be DLL_PROCESS_ATTACH

    Reserved    - reserved

Return Value:

    Always return 1L


Author:

    20-Feb-1991 Wed 18:42:11 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    UNREFERENCED_PARAMETER(Reserved);


    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        DBGP_IF((DBGP_CACHED_DCI | DBGP_CACHED_SMP),
                DBGP("\n****** DLL_PROCESS_ATTACH ******\n"));

        HTGlobal.hModule = hModule;
        EnableHalftone();

        break;


    case DLL_PROCESS_DETACH:

        DBGP_IF((DBGP_CACHED_DCI | DBGP_CACHED_SMP),
                DBGP("\n****** DLL_PROCESS_DETACH ******\n"));

        DisableHalftone();
        break;
    }

    return(TRUE);
}


#if DO_CACHE_DCI


PCDCIDATA
HTENTRY
FindCachedDCI(
    PDEVICECOLORINFO    pDCI
    )

/*++

Routine Description:

    This function will try to find the cached DEVICECOLORINFO and put the
    cached data to the pDCI

Arguments:

    pDCI    - Pointer to current device color info


Return Value:

    INT,  Index number to the PCDCI.Header[] array, if return value is < 0 then
    the CachedDCI data is not found.

Author:

    01-May-1992 Fri 13:10:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCDCIDATA       pCurCDCIData;
    DEFDBGVAR(UINT, SearchIndex = 0)


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCDCI);

    if (pCurCDCIData = HTGlobal.pCDCIDataHead) {

        PCDCIDATA   pPrevCDCIData = NULL;
        DWORD       Checksum = pDCI->HTInitInfoChecksum;


        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("FindCDCI: Looking for Checksum (0x%08lx), Count=%u"
                    ARGDW(Checksum) ARGU(HTGlobal.CDCICount)));

        ASSERT(HTGlobal.CDCICount);

        while (pCurCDCIData) {

            if (pCurCDCIData->Checksum == Checksum) {

                DBGP_IF(DBGP_CACHED_DCI,
                        DBGP("FindCDCI: Found %08lx [CheckSum=%08lx] after %u links, pPrev=%p"
                            ARG(pCurCDCIData)
                            ARGDW(Checksum)
                            ARGU(SearchIndex)
                            ARGPTR(pPrevCDCIData)));

                if (pPrevCDCIData) {

                    //
                    // The most recent reference's DCI always as first entry,
                    // (ie. Link Head), the last is the longest unreferenced
                    // so that if we need to delete a DCI, we delete the
                    // last one.
                    //

                    DBGP_IF(DBGP_CACHED_DCI,
                            DBGP("FindCDCI: Move pCur to pHead"));

                    pPrevCDCIData->pNextCDCIData = pCurCDCIData->pNextCDCIData;
                    pCurCDCIData->pNextCDCIData  = HTGlobal.pCDCIDataHead;
                    HTGlobal.pCDCIDataHead       = pCurCDCIData;
                }

                return(pCurCDCIData);
            }

            SETDBGVAR(SearchIndex, SearchIndex + 1);

            pPrevCDCIData = pCurCDCIData;
            pCurCDCIData  = pCurCDCIData->pNextCDCIData;
        }

        DBGP_IF(DBGP_CACHED_DCI, DBGP("FindCDCI: ??? NOT FOUND ???"));

    } else {

        DBGP_IF(DBGP_CACHED_DCI, DBGP("FindCDCI: ++No CDCIDATA cahced yet++"));
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);

    return(NULL);
}




BOOL
HTENTRY
AddCachedDCI(
    PDEVICECOLORINFO    pDCI
    )

/*++

Routine Description:

    This function add the DEVICECOLORINFO information to the DCI cache

Arguments:

    pDCI        - Pointer to current device color info

    Lock        - TRUE if need to keep the hMutex locked, (only if add is
                  sucessfully)

Return Value:

    INT,  Index number to the PCDCI.Header[] array where the new data is added,
    if return value is < 0 then the pDCI'CachedDCI data did not add to the
    cached array.

    NOTE: If AddCachedDCI() return value >= 0 and Lock=TRUE then caller must
          release the PCDCI.hMutex after done with the data, if return value
          is < 0 then no unlock is necessary.


Author:

    01-May-1992 Fri 13:24:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCDCIDATA   pCurCDCIData;
    PCDCIDATA   pPrevCDCIData;
    DWORD       AllocSize;
    DWORD       SizeCell;


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCDCI);

    //
    // We only cached CDCIDATA to certain extend, if we over that limit then
    // delete the last entry in the link list before adding anything
    //

    if (HTGlobal.CDCICount >= MAX_CDCI_COUNT) {

        ASSERT(HTGlobal.pCDCIDataHead);

        pCurCDCIData  = HTGlobal.pCDCIDataHead;
        pPrevCDCIData = NULL;

        while (pCurCDCIData->pNextCDCIData) {

            pPrevCDCIData = pCurCDCIData;
            pCurCDCIData  = pCurCDCIData->pNextCDCIData;
        }

        ASSERT(pPrevCDCIData);

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("AddCDCI: CDCICount >= %u, Free pLast=%p"
                ARGU(MAX_CDCI_COUNT)
                ARGPTR(pCurCDCIData)));

        if (HTFreeMem(pCurCDCIData)) {

            ASSERTMSG("AddCDCI: HTFreeMem(pLastCDCIData) Failed", FALSE);
        }

        pPrevCDCIData->pNextCDCIData = NULL;
        --HTGlobal.CDCICount;
    }

    if (pDCI->HTCell.Flags & HTCF_STATIC_PTHRESHOLDS) {

        SizeCell = 0;

    } else {

        SizeCell  = (DWORD)pDCI->HTCell.Size;
    }

    AllocSize = (DWORD)SizeCell + (DWORD)sizeof(CDCIDATA);

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("  AddCDCI: HTAllocMem(CDCIDATA(%ld) + Cell(%ld)) = %ld bytes"
                    ARGDW(sizeof(CDCIDATA))
                    ARGDW(SizeCell) ARGDW(AllocSize)));

    if (pCurCDCIData = (PCDCIDATA)HTAllocMem(NULL,
                                             HTMEM_CurCDCIData,
                                             NONZEROLPTR,
                                             AllocSize)) {

        //
        // put this data at link list head
        //

        pCurCDCIData->Checksum      = pDCI->HTInitInfoChecksum;
        pCurCDCIData->pNextCDCIData = HTGlobal.pCDCIDataHead;
        pCurCDCIData->ClrXFormBlock = pDCI->ClrXFormBlock;
        pCurCDCIData->DCIFlags      = pDCI->Flags;
        pCurCDCIData->DevResXDPI    = pDCI->DeviceResXDPI;
        pCurCDCIData->DevResYDPI    = pDCI->DeviceResYDPI;
        pCurCDCIData->DevPelRatio   = pDCI->DevPelRatio;
        pCurCDCIData->HTCell        = pDCI->HTCell;

        if (SizeCell) {

            CopyMemory((LPBYTE)(pCurCDCIData + 1),
                       (LPBYTE)pDCI->HTCell.pThresholds,
                       SizeCell);

            pCurCDCIData->HTCell.pThresholds = NULL;
        }

        HTGlobal.pCDCIDataHead = pCurCDCIData;
        ++HTGlobal.CDCICount;


        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("  AddCDCI: CDCIHeader, UsedCount=%u, pHead=%p, [%08lx]"
                            ARGU(HTGlobal.CDCICount)
                            ARGPTR(pCurCDCIData)
                            ARGDW(pCurCDCIData->Checksum)));

    } else {

        ASSERTMSG("AddCDCI: HTAllocMem(pCDCIData) Failed", FALSE);
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);

    return((pCurCDCIData) ? TRUE : FALSE);
}




BOOL
HTENTRY
GetCachedDCI(
    PDEVICECOLORINFO    pDCI
    )

/*++

Routine Description:

    This function will try to find the cached DEVICECOLORINFO and put the
    cached data to the pDCI

Arguments:

    pDCI        - Pointer to current device color info


Return Value:

    BOOLEAN

Author:

    01-May-1992 Fri 13:10:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCDCIDATA   pCDCIData;
    BOOL        GetOk = FALSE;


    if (pCDCIData = FindCachedDCI(pDCI)) {

        pDCI->ClrXFormBlock = pCDCIData->ClrXFormBlock;
        pDCI->Flags         = pCDCIData->DCIFlags;
        pDCI->DeviceResXDPI = pCDCIData->DevResXDPI;
        pDCI->DeviceResYDPI = pCDCIData->DevResYDPI;
        pDCI->DevPelRatio   = pCDCIData->DevPelRatio;
        pDCI->HTCell        = pCDCIData->HTCell;

        if (pDCI->HTCell.Flags & HTCF_STATIC_PTHRESHOLDS) {

            GetOk = TRUE;

        } else if (pDCI->HTCell.pThresholds =
                            (LPBYTE)HTAllocMem((LPVOID)pDCI,
                                               HTMEM_GetCacheThreshold,
                                               NONZEROLPTR,
                                               pDCI->HTCell.Size)) {

            CopyMemory((LPBYTE)pDCI->HTCell.pThresholds,
                       (LPBYTE)(pCDCIData + 1),
                       pDCI->HTCell.Size);

            GetOk = TRUE;

        } else {

            DBGMSG("GetCDCI: HTAllocMem(Thresholds) failed");
        }

        RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);
    }

    return(GetOk);
}

#endif  // DO_CACHE_DCI



#if DBG


VOID
HTENTRY
DbgDumpCSMPBMP(
    VOID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Mar-1999 Thu 17:49:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCSMPDATA   pCSMPData;
    UINT        c0 = 0;

    pCSMPData = HTGlobal.pCSMPDataHead;

    while (pCSMPData) {

        PCSMPBMP    pCSMPBmp;
        UINT        c1 = 0;

        DBGP_IF(DBGP_SHOW_CSMBMP,
                DBGP("cDatas=%3ld: Checksum=%08lx"
                        ARGDW(++c0) ARGDW(pCSMPData->Checksum)));

        pCSMPBmp = pCSMPData->pCSMPBmpHead;

        while (pCSMPBmp) {

            DBGP_IF(DBGP_SHOW_CSMBMP,
                    DBGP("    %3ld: Idx=%2ld, %4ldx%4ld=%4ld"
                            ARGDW(++c1)
                            ARGDW(pCSMPBmp->PatternIndex)
                            ARGDW(pCSMPBmp->cxPels)
                            ARGDW(pCSMPBmp->cyPels)
                            ARGDW(pCSMPBmp->cxBytes)));



            pCSMPBmp = pCSMPBmp->pNextCSMPBmp;
        }

        pCSMPData = pCSMPData->pNextCSMPData;
    }

    if (c0 != (UINT)HTGlobal.CSMPCount) {

        DBGP("c0 (%ld) != CSMPCount (%ld)"
                ARGDW(c0) ARGDW(HTGlobal.CSMPCount));
    }
}


#endif


PCSMPBMP
HTENTRY
FindCachedSMP(
    PDEVICECOLORINFO    pDCI,
    UINT                PatternIndex
    )

/*++

Routine Description:

    This function will try to find the cached DEVICECOLORINFO and put the
    cached data to the pDCI

Arguments:

    pDCI    - Pointer to current device color info


Return Value:

    INT,  Index number to the PCDCI.Header[] array, if return value is < 0 then
    the CachedDCI data is not found.

Author:

    01-May-1992 Fri 13:10:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCSMPDATA       pPrevCSMPData;
    PCSMPDATA       pCurCSMPData;
    PCSMPBMP        pCurCSMPBmp;
    DWORD           Checksum = pDCI->HTSMPChecksum;
    DEFDBGVAR(UINT, SearchIndex = 0)


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCSMP);

    DBGP_IF(DBGP_SHOW_CSMBMP, DbgDumpCSMPBMP(); );

    if (pCurCSMPData = HTGlobal.pCSMPDataHead) {

        pPrevCSMPData = NULL;

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP(">>FindCSMP: Looking for Checksum (0x%08lx), Count=%u"
                    ARGDW(Checksum) ARGU(HTGlobal.CSMPCount)));

        ASSERT(HTGlobal.CSMPCount);

        while (pCurCSMPData) {

            if (pCurCSMPData->Checksum == Checksum) {

                DBGP_IF(DBGP_CACHED_SMP,
                        DBGP(">>FindCSMP: Found after %u links, pPrev=%p"
                            ARGU(SearchIndex)
                            ARGPTR(pPrevCSMPData)));

                if (pPrevCSMPData) {

                    //
                    // The most recent reference's CSMPDATA always as first
                    // entry,(ie. Link Head), the last is the longest
                    // unreferenced so that if we need to delete a CSMPDATA,
                    // we delete the last one.
                    //

                    DBGP_IF(DBGP_CACHED_SMP,
                            DBGP(">>FindCSMP: Move pCur to pHead"));

                    pPrevCSMPData->pNextCSMPData = pCurCSMPData->pNextCSMPData;
                    pCurCSMPData->pNextCSMPData  = HTGlobal.pCSMPDataHead;
                    HTGlobal.pCSMPDataHead       = pCurCSMPData;
                }

                //
                // See we cached any pattern for this group
                //

                pCurCSMPBmp = pCurCSMPData->pCSMPBmpHead;

                SETDBGVAR(SearchIndex, 0);

                while (pCurCSMPBmp) {

                    if ((UINT)pCurCSMPBmp->PatternIndex == PatternIndex) {

                        DBGP_IF(DBGP_CACHED_SMP,
                                DBGP(">>FindCSMP: Found Pat(%u) after %u links"
                                ARGU(PatternIndex)
                                ARGU(SearchIndex++)));

                        return(pCurCSMPBmp);
                    }

                    pCurCSMPBmp = pCurCSMPBmp->pNextCSMPBmp;
                }

                //
                // Found in this group but no bitmap for PatternIndex is
                // cached yet!
                //

                break;
            }

            SETDBGVAR(SearchIndex, SearchIndex + 1);

            pPrevCSMPData = pCurCSMPData;
            pCurCSMPData  = pCurCSMPData->pNextCSMPData;
        }

        DBGP_IF(DBGP_CACHED_SMP, DBGP(">>FindCSMP: ??? NOT FOUND ???"));

    } else {

        DBGP_IF(DBGP_CACHED_DCI, DBGP(">>FindCSMP: ++No CSMPDATA cahced yet++"));
    }

    if (!pCurCSMPData) {

        //
        // Since we did not even found the CSMPDATA checksum group, we want to
        // add it in there, but We only cached CSMPDATA to certain extend, if
        // we over that limit then delete the last entry in the link list
        // before adding anything
        //

        if (HTGlobal.CSMPCount >= MAX_CSMP_COUNT) {

            HLOCAL  hData;


            ASSERT(HTGlobal.pCSMPDataHead);

            pPrevCSMPData = NULL;
            pCurCSMPData  = HTGlobal.pCSMPDataHead;

            while (pCurCSMPData->pNextCSMPData) {

                pPrevCSMPData = pCurCSMPData;
                pCurCSMPData  = pCurCSMPData->pNextCSMPData;
            }

            ASSERT(pPrevCSMPData);

            //
            // Free all the allocated cached standard mono pattern bitmap for
            // this group
            //

            pCurCSMPBmp = pCurCSMPData->pCSMPBmpHead;

            DBGP_IF(DBGP_CACHED_SMP,
                DBGP(">>FindCSMP: CSMPCount >= %u, Free pLast=%p"
                     ARGU(MAX_CSMP_COUNT) ARGPTR(pCurCSMPData)));

            while (hData = (HLOCAL)pCurCSMPBmp) {

                pCurCSMPBmp = pCurCSMPBmp->pNextCSMPBmp;

                DBGP_IF(DBGP_CACHED_SMP,
                        DBGP(">>FindCSMP: Free pLastCSMPBmp=%p" ARGPTR(hData)));

                if (HTFreeMem(hData)) {

                    ASSERTMSG(">>FindCSMP: HTFreeMem(pCurCSMBmp) Failed", FALSE);
                }
            }

            //
            // Now free the header for the CSMPDATA
            //

            if (HTFreeMem(pCurCSMPData)) {

                ASSERTMSG(">>FindCSMP: HTFreeMem(pLastCSMPData) Failed", FALSE);
            }

            pPrevCSMPData->pNextCSMPData = NULL;
            --HTGlobal.CSMPCount;
        }

        if (pCurCSMPData = (PCSMPDATA)HTAllocMem((LPVOID)NULL,
                                                 HTMEM_CurCSMPData,
                                                 NONZEROLPTR,
                                                 sizeof(CSMPDATA))) {

            //
            // Make this one as the link list head
            //

            pCurCSMPData->Checksum      = Checksum;
            pCurCSMPData->pNextCSMPData = HTGlobal.pCSMPDataHead;
            pCurCSMPData->pCSMPBmpHead  = NULL;

            HTGlobal.pCSMPDataHead      = pCurCSMPData;
            ++HTGlobal.CSMPCount;

            DBGP_IF(DBGP_CACHED_SMP,
                DBGP("  >>FindCSMP: Add CSMPDATA, UsedCount=%u, pHead=%p"
                            ARGU(HTGlobal.CSMPCount) ARGPTR(pCurCSMPData)));

        } else {

            DBGMSG("  >>FindCSMP: HTAllocMem(CSMPDATA) Failed");
        }
    }

    //
    // Do allocate new pattern only if we have header
    //

    if (pCurCSMPData) {

        STDMONOPATTERN  SMP;
        DWORD           Size;


        SMP.Flags              = SMP_TOPDOWN;
        SMP.ScanLineAlignBytes = (BYTE)sizeof(BYTE);
        SMP.PatternIndex       = (BYTE)PatternIndex;
        SMP.LineWidth          = DEFAULT_SMP_LINE_WIDTH;
        SMP.LinesPerInch       = DEFAULT_SMP_LINES_PER_INCH;
        SMP.pPattern           = NULL;

        //
        // Find out the size for the pattern bitmap (BYTE Aligned)
        //

        Size = (DWORD)CreateStandardMonoPattern(pDCI, &SMP) +
               (DWORD)sizeof(CSMPBMP);

        DBGP_IF(DBGP_CACHED_SMP,
                DBGP(">>FindCSMP: Add PatternIndex=%u, sz=%ld, DPI(X=%u, Y=%u, P=%u)"
                        ARGU(PatternIndex)
                        ARGU(Size)
                        ARGU(pDCI->DeviceResXDPI)
                        ARGU(pDCI->DeviceResYDPI)
                        ARGU(pDCI->DevPelRatio)));

        if (pCurCSMPBmp = (PCSMPBMP)HTAllocMem(NULL,
                                               HTMEM_CurCSMPBmp,
                                               NONZEROLPTR,
                                               Size)) {

            SMP.pPattern = (LPBYTE)pCurCSMPBmp + sizeof(CSMPBMP);

            CreateStandardMonoPattern(pDCI, &SMP);

            //
            // Make this pattern index as link list head
            //

            pCurCSMPBmp->pNextCSMPBmp  = pCurCSMPData->pCSMPBmpHead;
            pCurCSMPBmp->PatternIndex  = (WORD)PatternIndex;
            pCurCSMPBmp->cxPels        = (WORD)SMP.cxPels;
            pCurCSMPBmp->cyPels        = (WORD)SMP.cyPels;
            pCurCSMPBmp->cxBytes       = (WORD)SMP.BytesPerScanLine;

            pCurCSMPData->pCSMPBmpHead = pCurCSMPBmp;

            return(pCurCSMPBmp);

        } else {

            ASSERTMSG("  >>FindCSMP: HTAllocMem(CSMPBMP) Failed", FALSE);
        }
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexCSMP);

    return(NULL);
}



LONG
HTENTRY
GetCachedSMP(
    PDEVICECOLORINFO    pDCI,
    PSTDMONOPATTERN     pSMP
    )

/*++

Routine Description:

    This function will try to find the cached DEVICECOLORINFO and put the
    cached data to the pDCI

Arguments:

    pDCI    - Pointer to current device color info


    pSMP    - Pointer to the STDMONOPATTERN data structure, if PatIndex is
              < CACHED_SMP_COUNT or, its not default size then it will be
              computed on the fly.



Return Value:

    The size of the SMP pattern.

Author:

    01-May-1992 Fri 13:10:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG        SizeRet = 0;
    UINT        PatIndex;


    if (!(pSMP->LineWidth)) {

        pSMP->LineWidth = DEFAULT_SMP_LINE_WIDTH;
    }

    if (!(pSMP->LinesPerInch)) {

        pSMP->LinesPerInch = DEFAULT_SMP_LINES_PER_INCH;
    }

    if (((PatIndex = (UINT)pSMP->PatternIndex) < HT_SMP_PERCENT_SCREEN_START) &&
        (pSMP->LineWidth    == DEFAULT_SMP_LINE_WIDTH)                        &&
        (pSMP->LinesPerInch == DEFAULT_SMP_LINES_PER_INCH)) {

        PCSMPBMP    pCSMPBmp;

        if (pCSMPBmp = FindCachedSMP(pDCI, PatIndex)) {

            CSMPBMP     CSMPBmp;
            LPBYTE      pPatRet;
            LPBYTE      pPat;
            WORD        cxBytesRet;


            CSMPBmp      = *pCSMPBmp;
            pPat         = (LPBYTE)pCSMPBmp + sizeof(CSMPBMP);
            pSMP->cxPels = CSMPBmp.cxPels;
            pSMP->cyPels = CSMPBmp.cyPels;

            cxBytesRet             =
            pSMP->BytesPerScanLine = (WORD)
                        ComputeBytesPerScanLine((UINT)BMF_1BPP,
                                                (UINT)pSMP->ScanLineAlignBytes,
                                                (DWORD)CSMPBmp.cxPels);
            SizeRet                = (LONG)cxBytesRet * (LONG)CSMPBmp.cyPels;

            if (pPatRet = pSMP->pPattern) {

                INT     cxBytes;
                INT     PatInc;
                WORD    Flags;


                PatInc  =
                cxBytes = (INT)CSMPBmp.cxBytes;
                Flags   = pSMP->Flags;

                DBGP_IF(DBGP_CACHED_DCI,
                        DBGP(">>  GetCSMP: *COPY* [%2u:%ux%u] @%u(%ld) -> @%u(%u) [%s] [%c=K]"
                            ARGU(PatIndex)
                            ARGU(CSMPBmp.cxPels)
                            ARGU(CSMPBmp.cyPels)
                            ARGU(cxBytes)
                            ARGU((LONG)cxBytes * (LONG)CSMPBmp.cyPels)
                            ARGU(cxBytesRet)
                            ARGU(SizeRet)
                            ARG((Flags & SMP_TOPDOWN) ? "TOP DOWN" : "BOTTOM UP ")
                            ARG((Flags & SMP_0_IS_BLACK) ? '0' : '1')));

                //
                // Start copying the cached pattern
                //

                if (!(Flags & SMP_TOPDOWN)) {

                    pPat   += (LONG)cxBytes * (LONG)(CSMPBmp.cyPels - 1);
                    PatInc  = -PatInc;
                }

                while (CSMPBmp.cyPels--) {

                    CopyMemory(pPatRet, pPat, cxBytes);

                    pPatRet += cxBytesRet;
                    pPat    += PatInc;
                }

                if (Flags & SMP_0_IS_BLACK) {

                    LONG    Count = SizeRet;


                    pPatRet = pSMP->pPattern;

                    while (Count--) {

                        *pPatRet++ ^= 0xff;
                    }
                }
            }

            RELEASE_HTMUTEX(HTGlobal.HTMutexCSMP);
        }

    } else {

        DBGP_IF(DBGP_CACHED_SMP,
                DBGP(">>  GetCSMP: NO CACHED FOR LineWidth=%u, LinesPerInch=%u"
                    ARGU(pSMP->LineWidth) ARGU(pSMP->LinesPerInch)));
    }

    if (!SizeRet) {

        SizeRet = CreateStandardMonoPattern(pDCI, pSMP);
    }

    return(SizeRet);

}


#if DO_CACHE_DCI


DWORD
HTENTRY
ComputeHTINITINFOChecksum(
    PDEVICECOLORINFO    pDCI,
    PHTINITINFO         pHTInitInfo
    )

/*++

Routine Description:

    This function compute 32-bit checksum for the HTINITINFO data structure
    passed

Arguments:

    pDCI            - Pointer to the DCI

    pHTInitInfo    - Pointer to the HTINITINFO5 data structure

Return Value:

    32-bit checksum

Author:

    29-Apr-1992 Wed 18:44:42 created  -by-  Daniel Chou (danielc)

    11-Feb-1997 Tue 12:54:50 updated  -by-  Daniel Chou (danielc)
        Changed using HTINITINFO5

Revision History:


--*/

{
    DWORD   Checksum;
    WORD    wBuf[12];


    Checksum = ComputeHTCell((WORD)pHTInitInfo->HTPatternIndex,
                             pHTInitInfo->pHalftonePattern,
                             NULL);

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("       HTPATTERN Checksum= %08lx" ARGDW(Checksum)));

    wBuf[0] = (WORD)'HT';
    wBuf[1] = (WORD)pHTInitInfo->Flags;
    wBuf[2] = (WORD)(pDCI->HTInitInfoChecksum >> 16);
    wBuf[3] = (WORD)pHTInitInfo->DeviceResXDPI;
    wBuf[4] = (WORD)pHTInitInfo->DeviceResYDPI;
    wBuf[5] = (WORD)pHTInitInfo->DevicePelsDPI;
    wBuf[6] = (WORD)(pDCI->HTInitInfoChecksum & 0xffff);
    wBuf[7] = (WORD)pHTInitInfo->DevicePowerGamma;
    wBuf[8] = (WORD)0x1234;

    if (pHTInitInfo->Version > HTINITINFO_VERSION2) {

        wBuf[9]  = (WORD)pHTInitInfo->DeviceRGamma;
        wBuf[10]  = (WORD)pHTInitInfo->DeviceGGamma;
        wBuf[11] = (WORD)pHTInitInfo->DeviceBGamma;

    } else {

        wBuf[9]  = 0x1234;
        wBuf[10] = 0xfedc;
        wBuf[11] = 0xabcd;
    }

    Checksum = ComputeChecksum((LPBYTE)&(wBuf[0]), Checksum, sizeof(wBuf));

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("    HTINITINFO Checksum= %08lx [%08lx]"
                        ARGDW(Checksum) ARGDW(pDCI->HTInitInfoChecksum)));

    if (pHTInitInfo->pInputRGBInfo) {

        Checksum = ComputeChecksum((LPBYTE)pHTInitInfo->pInputRGBInfo,
                                   Checksum,
                                   sizeof(CIEINFO));
        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("           RGBINFO Checksum= %08lx" ARGDW(Checksum)));
    }

    if (pHTInitInfo->pDeviceCIEInfo) {

        Checksum = ComputeChecksum((LPBYTE)pHTInitInfo->pDeviceCIEInfo,
                                   Checksum,
                                   sizeof(CIEINFO));
        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("             CIEINFO Checksum= %08lx" ARGDW(Checksum)));
    }

    if (pHTInitInfo->pDeviceSolidDyesInfo) {

        Checksum = ComputeChecksum((LPBYTE)pHTInitInfo->pDeviceSolidDyesInfo,
                                   Checksum,
                                   sizeof(SOLIDDYESINFO));
        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("               SOLIDDYE Checksum= %08lx" ARGDW(Checksum)));
    }

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("----------------- FINAL Checksum= %08lx" ARGDW(Checksum)));

    return(pDCI->HTInitInfoChecksum = Checksum);
}


#endif



HTCALLBACKFUNCTION
DefaultHTCallBack(
    PHTCALLBACKPARAMS   pHTCallBackParams
    )

/*++

Routine Description:

    This stuff function is provided when caller do not specified the halftone
    callback function.

Arguments:

    pHTCallBackParams   - Pointer to the PHTCALLBACKPARAMS

Return Value:

    always return false for the caller.

Author:

    18-Mar-1992 Wed 12:28:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    UNREFERENCED_PARAMETER(pHTCallBackParams);

    return(FALSE);
}


#define FLIP_COORD(m, a)        (a) = ((m) << 1) - (a)




VOID
HTENTRY
GetCIEPrims(
    PCIEINFO    pCIEInfo,
    PCIEPRIMS   pCIEPrims,
    PCIEINFO    pDefCIEInfo,
    BOOL        FlipWhite
    )

/*++

Routine Description:

    This function take CIEINFO data structure and converted it to the CIEPRIMS
    internal data type

Arguments:

    pCIEInfo    - Pointer to the CIEINFO data structure for conversion,
                  if this pointer is NULL then DefCIEPrimsIndex is used
                  to index into DefaultCIEPrims[].

    pCIEPrims   - Pointer to the CIEPRIMS data structure

    pDefCIEInfo - Pointer to the CIEINFO for the default

Return Value:

    BOOL    If it is standard CIE Info

Author:

    20-Apr-1993 Tue 01:14:23 created  -by-  Daniel Chou (danielc)


Revision History:

    06-Oct-2000 Fri 18:01:40 updated  -by-  Daniel Chou (danielc)
        fix bug: Move FlipWhite to the outer loop so it will compute even in
        default CIEINFO situation

--*/

{
    CIEINFO CIEInfo;
    BOOL    UseDefCIEInfo = TRUE;
    LONG    Diff;


    if (pCIEInfo) {

        CIEInfo = *pCIEInfo;

        if ((CIEInfo.Red.x < CIE_x_MIN)                 ||
            (CIEInfo.Red.x > CIE_x_MAX)                 ||
            (CIEInfo.Red.y < CIE_y_MIN)                 ||
            (CIEInfo.Red.y > CIE_y_MAX)                 ||
            (CIEInfo.Green.x < CIE_x_MIN)               ||
            (CIEInfo.Green.x > CIE_x_MAX)               ||
            (CIEInfo.Green.y < CIE_y_MIN)               ||
            (CIEInfo.Green.y > CIE_y_MAX)               ||
            (CIEInfo.Blue.x < CIE_x_MIN)                ||
            (CIEInfo.Blue.x > CIE_x_MAX)                ||
            (CIEInfo.Blue.y < CIE_y_MIN)                ||
            (CIEInfo.Blue.y > CIE_y_MAX)                ||
            (CIEInfo.AlignmentWhite.x < CIE_x_MIN)      ||
            (CIEInfo.AlignmentWhite.x > CIE_x_MAX)      ||
            (CIEInfo.AlignmentWhite.y < CIE_y_MIN)      ||
            (CIEInfo.AlignmentWhite.y > CIE_y_MAX)      ||
            (CIEInfo.AlignmentWhite.Y < (UDECI4)2500)   ||
            (CIEInfo.AlignmentWhite.Y > (UDECI4)60000)) {

            NULL;

        } else {

            UseDefCIEInfo = FALSE;

        }
    }

    if (UseDefCIEInfo) {

        CIEInfo = *pDefCIEInfo;
    }

    if (FlipWhite) {

        FLIP_COORD(pDefCIEInfo->AlignmentWhite.x,
                   CIEInfo.AlignmentWhite.x);

        FLIP_COORD(pDefCIEInfo->AlignmentWhite.y,
                   CIEInfo.AlignmentWhite.y);
    }

    pCIEPrims->r.x = UDECI4ToFD6(CIEInfo.Red.x);
    pCIEPrims->r.y = UDECI4ToFD6(CIEInfo.Red.y);
    pCIEPrims->g.x = UDECI4ToFD6(CIEInfo.Green.x);
    pCIEPrims->g.y = UDECI4ToFD6(CIEInfo.Green.y);
    pCIEPrims->b.x = UDECI4ToFD6(CIEInfo.Blue.x);
    pCIEPrims->b.y = UDECI4ToFD6(CIEInfo.Blue.y);
    pCIEPrims->w.x = UDECI4ToFD6(CIEInfo.AlignmentWhite.x);
    pCIEPrims->w.y = UDECI4ToFD6(CIEInfo.AlignmentWhite.y);
    pCIEPrims->Yw  = UDECI4ToFD6(CIEInfo.AlignmentWhite.Y);
}



LONG
APIENTRY
HT_LOADDS
HT_CreateDeviceHalftoneInfo(
    PHTINITINFO             pHTInitInfo,
    PPDEVICEHALFTONEINFO    ppDeviceHalftoneInfo
    )

/*++

Routine Description:

    This function initialize a device to the halftone dll, it calculate all
    the necessary parameters for the device and return a pointer points to
    the DEVICEHALFTONEINFO data structure back to the caller.

    NOTE: return pointer will not be particulary anchor to a single physucal
          device, but rather to a group of physical devices, that is if the
          caller has simillar devices which share the same characteristics
          then it may use the same pointer to halftone the bitmap.

Arguments:

    pHTInitInfo             - Pointer to the HTINITINFO data structure which
                              describe the device characteristics and other
                              initialzation requests.

    ppDeviceHalftoneInfo    - Pointer to the DEVICEHALFTONEINFO pointer, if
                              content of this pointer is not NULL then halftone
                              dll assume the caller has previously cached
                              DEVICEHALFTONEINFO data pointed by it, if it
                              is NULL then halftone dll compute all the
                              DEVICEHALFTONEINFO datas for newly created
                              halftone info. for the device. (see following
                              'Return Value' for more detail)

Return Value:

    The return value will be greater than 0L if the function sucessfully, and
    it will be an error code (less than or equal to 0) if function failed.

    Return value greater than 0

        1. The pointer location points by the ppDeviceHalftoneInfo will be
           updated to stored the pointer which points to the DEVICEHALFTONEINFO
           data structure for later any HT_xxxx() api calls.

        2. The Return value is the total bytes the caller can saved and used
           as cached DeviceHalftoneInfo for next time calling this function,
           the saved area is started from *(ppDeviceHalftoneInfo) and has
           size in bytes as return value.

        NOTE: if caller passed a pointer pointed by ppDeviceHalftoneInfo and
              the return value is greater than zero then it signal that it
              passed DEVICEHALFTONEINFO pointer is not correct of data has
              been changed from HTINITINFO data structure, the caller can
              continue to save the newly created DEVICEHALFTONEINFO cached
              data.

              In any cases the caller's passed pointer stored in the
              ppDeviceHalftoneInfo is overwritten by newly created
              DEVICEHALFTONEINFO data structure pointer.


    Return value equal to 0

        1. The caller passed pointer *(ppDeviceHalftoneInfo) is sucessfully
           used as new device halftone info

        2. The pointer location points by the ppDeviceHalftoneInfo will be
           updated to stored the new pointer which points to the
           DEVICEHALFTONEINFO data structure for later any HT_xxxx() api calls.


        NOTE: The caller's passed pointer stored in the ppDeviceHalftoneInfo
              is overwritten by newly created DEVICEHALFTONEINFO data structure
              pointer.

    Return value less than or equal to zero

        The function failed, the storage points by the ppDeviceHalftoneInfo is
        undefined.

        This function may return following error codes.

        HTERR_INSUFFICIENT_MEMORY       - Not enough memory for halftone
                                          process.

        HTERR_HTPATTERN_SIZE_TOO_BIG    - Caller defined halftone pattern's
                                          width or height is excessed limit.

        HTERR_INVALID_HALFTONEPATTERN   - One or more HALFTONEPATTERN data
                                          structure field specified invalid
                                          values.


    Note: The first field in the DEVICEHALFTONEINFO (DeviceOwnData) is a 32-bit
          area which will be set to 0L upon sucessful returned, the caller can
          put any data in this field.

Author:

    05-Feb-1991 Tue 10:54:32 created  -by-  Daniel Chou (danielc)


Revision History:

    05-Jun-1991 Wed 10:22:07 updated  -by-  Daniel Chou (danielc)

        Fixed the typing errors for halftone pattern default

--*/

{
    PHT_DHI             pHT_DHI;
    PDEVICECOLORINFO    pDCI;
    HTINITINFO          HTInitInfo;
    BOOL                UseCurNTDefault;
    FD6                 DevPelRatio;
    WORD                ExtraDCIF;
    DWORD               dwBuf[6];

#define _RegDataIdx     ((DWORD)(dwBuf[0]))
#define _MaxMulDiv      ((FD6)(dwBuf[0]))
#define _cC             ((DWORD)(dwBuf[1]))
#define _cM             ((DWORD)(dwBuf[2]))
#define _cY             ((DWORD)(dwBuf[3]))
#define _MaxCMY         ((DWORD)(dwBuf[4]))
#define _Idx            ((DWORD)(dwBuf[5]))


    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("\n********* HT_CreateDeviceHalftoneInfo *************\n"));

    ZeroMemory(&HTInitInfo, sizeof(HTINITINFO));

    //
    // Now check if we have valid data
    //

    if (pHTInitInfo->Version == (DWORD)HTINITINFO_VERSION2) {

        HTInitInfo.Version = sizeof(HTINITINFO) - HTINITINFO_V3_CB_EXTRA;

    } else if (pHTInitInfo->Version == (DWORD)HTINITINFO_VERSION) {

        HTInitInfo.Version = sizeof(HTINITINFO);

    } else {

        HTAPI_RET(HTAPI_IDX_CREATE_DHI, HTERR_WRONG_VERSION_HTINITINFO);
    }

    CopyMemory(&HTInitInfo, pHTInitInfo, HTInitInfo.Version);

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("*** Allocate HT_DHI(%ld) ***" ARGDW(sizeof(HT_DHI))));

    if (!(pHT_DHI = (PHT_DHI)HTAllocMem(NULL,
                                        HTMEM_HT_DHI,
                                        LPTR,
                                        sizeof(HT_DHI)))) {

        HTAPI_RET(HTAPI_IDX_CREATE_DHI, HTERR_INSUFFICIENT_MEMORY);
    }

    pDCI                = &(pHT_DHI->DCI);
    pDCI->HalftoneDLLID = HALFTONE_DLL_ID;

    if (!(pDCI->HTMutex = CREATE_HTMUTEX())) {

        DBGMSG("InitHTInternalData: CREATE_HTMUTEX(pDCI->HTMutex) failed!");

        HTFreeMem(pHT_DHI);
        HTAPI_RET(HTAPI_IDX_CREATE_DHI, (HTERR_INTERNAL_ERRORS_START - 1000));
    }

    if (!(pDCI->HTCallBackFunction = HTInitInfo.HTCallBackFunction)) {

        pDCI->HTCallBackFunction = DefaultHTCallBack;
    }

    HTInitInfo.Flags &= HIF_BIT_MASK;

    // ****************************************************************
    // * We want to check to see if this is a old data, if yes then   *
    // * update the caller to default                                 *
    // ****************************************************************
    //

    pDCI->HTInitInfoChecksum = HTINITINFO_INITIAL_CHECKSUM;

    if ((!HTInitInfo.pDeviceCIEInfo) ||
        (HTInitInfo.pDeviceCIEInfo->Cyan.Y != (UDECI4)VALID_YC)) {

        //
        // Let's munge around the printer info, to see if its an old def,
        // if yes, then we now make this all into NT4.00 default
        //

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("HT: *WARNING* Update Old Default COLORINFO to NT5.00 DEFAULT"));

        HTInitInfo.pDeviceCIEInfo = NULL;
        UseCurNTDefault           = TRUE;
        dwBuf[0]                  = (DWORD)'NTHT';
        dwBuf[1]                  = (DWORD)'2000';
        dwBuf[2]                  = (DWORD)'Dan.';
        dwBuf[3]                  = (DWORD)'Chou';
        pDCI->HTInitInfoChecksum  = ComputeChecksum((LPBYTE)&dwBuf[0],
                                                    pDCI->HTInitInfoChecksum,
                                                    sizeof(dwBuf[0]) * 4);

    } else {

        UseCurNTDefault = FALSE;
    }

    DevPelRatio = (FD6)HTInitInfo.DevicePelsDPI;

    DBGP_IF(DBGP_DEVPELSDPI,
            DBGP("Passed DevicePelsDPI=%08lx" ARGDW(DevPelRatio)));

    if ((HTInitInfo.DeviceRGamma == (UDECI4)0xFFFF) &&
        (HTInitInfo.DeviceGGamma == (UDECI4)0xFFFF) &&
        (HTInitInfo.DeviceBGamma == (UDECI4)0xFFFF)) {

        ExtraDCIF = DCIF_FORCE_ICM;

    } else {

        ExtraDCIF = 0;
    }

    if ((HTInitInfo.DeviceRGamma < (UDECI4)MIN_RGB_GAMMA)   ||
        (HTInitInfo.DeviceRGamma > (UDECI4)MAX_RGB_GAMMA)   ||
        (HTInitInfo.DeviceGGamma < (UDECI4)MIN_RGB_GAMMA)   ||
        (HTInitInfo.DeviceGGamma > (UDECI4)MAX_RGB_GAMMA)   ||
        (HTInitInfo.DeviceBGamma < (UDECI4)MIN_RGB_GAMMA)   ||
        (HTInitInfo.DeviceBGamma > (UDECI4)MAX_RGB_GAMMA)) {

        HTInitInfo.DeviceRGamma =
        HTInitInfo.DeviceGGamma =
        HTInitInfo.DeviceBGamma = UDECI4_1;
    }

    //
    // Compute HTInitInfoChecksum, and check if we have any cached data
    //

#if DO_CACHE_DCI
    ComputeHTINITINFOChecksum(pDCI, &HTInitInfo);

    if (!GetCachedDCI(pDCI)) {
#else
    if (TRUE) {
#endif
        LONG    Result;

        //
        // Now start to checking the init information
        //

        pDCI->Flags = (WORD)((HTInitInfo.Flags & HIF_SQUARE_DEVICE_PEL) ?
                                                    DCIF_SQUARE_DEVICE_PEL : 0);

        if ((!(pDCI->DeviceResXDPI = HTInitInfo.DeviceResXDPI)) ||
            (!(pDCI->DeviceResYDPI = HTInitInfo.DeviceResYDPI))) {

            pDCI->DeviceResXDPI =
            pDCI->DeviceResYDPI = 300;
            DevPelRatio         = 0;
        }

        if (DevPelRatio & 0x8000) {

            //
            // This is a percentage ie. 1000 = 100.0%, 960=96.0%,
            // on the DeviceResXDPI, Maximum number accepted is 300.0%
            // The larger the percetage the larger the dot size and smaller
            // the percentage the smaller the dot size, if specified as 1000
            // which is 100.0% then it has same size as its X resolution
            // The range is 33.3% to 1500%
            //

            DevPelRatio &= 0x7FFF;

            if ((DevPelRatio > MAX_RES_PERCENT) ||
                (DevPelRatio < MIN_RES_PERCENT)) {

                DBGP_IF(DBGP_DEVPELSDPI,
                        DBGP("HT: *WARNING* Invalid DevicePelsDPI=%ld (PERCENT) set to DEFAULT=1.0"
                             ARGDW(DevPelRatio)));

                DevPelRatio = FD6_1;

            } else {

                DBGP_IF(DBGP_DEVPELSDPI,
                        DBGP("*** Percentage INPUT DevicePelsDPI=%ld *** "
                                        ARGDW(DevPelRatio)));

                DevPelRatio *= 1000;

                DBGP_IF(DBGP_DEVPELSDPI,
                        DBGP("*** Percentage OUTPUT DevPelRatio=%s *** "
                                    ARGFD6(DevPelRatio, 1, 6)));
            }

        } else {

            if ((DevPelRatio > (pDCI->DeviceResXDPI * 3)) ||
                (DevPelRatio > (pDCI->DeviceResYDPI * 3))) {

                DBGP_IF(DBGP_DEVPELSDPI,
                        DBGP("HT: *WARNING* Invalid DevicePelsDPI=%ld (RES) set to DEFAULT=0"
                                        ARGDW(DevPelRatio)));

                DevPelRatio = 0;
            }

            if (DevPelRatio) {

                dwBuf[0]    = (((DWORD)pDCI->DeviceResXDPI *
                                (DWORD)pDCI->DeviceResXDPI) +
                               ((DWORD)pDCI->DeviceResYDPI *
                                (DWORD)pDCI->DeviceResYDPI));
                dwBuf[1]    = ((DWORD)DevPelRatio * (DWORD)DevPelRatio * 2);
                DevPelRatio = SquareRoot(DivFD6(dwBuf[0], dwBuf[1]));

            } else {

                DevPelRatio = FD6_1;
            }
        }

        //
        // If the DevicePelsDPI is out of range then we will make it 0 (same as
        // device resolution), so it can continue to work
        //

        if (HTInitInfo.Flags & HIF_ADDITIVE_PRIMS) {

            pDCI->ClrXFormBlock.ColorSpace  = CIELUV_1976;
            pDCI->Flags                    |= DCIF_ADDITIVE_PRIMS;

        } else {

            pDCI->ClrXFormBlock.ColorSpace  = CIELAB_1976;
#if DO_DYES_CORRECTION
            pDCI->Flags                    |= DCIF_NEED_DYES_CORRECTION;
#endif
            if (HTInitInfo.Flags & HIF_DO_DEVCLR_XFORM) {

                pDCI->Flags |= DCIF_DO_DEVCLR_XFORM;
            }

            if (HTInitInfo.Flags & HIF_HAS_BLACK_DYE) {

                pDCI->Flags |= DCIF_HAS_BLACK_DYE;
            }
        }

        //
        // Save the DevPelRatio back to PDCI
        //

        DBGP_IF(DBGP_DEVPELSDPI,
                DBGP("*** XDPI=%ld, YDPI=%ld, DevPelRatio=%s *** "
                        ARGDW(pDCI->DeviceResXDPI) ARGDW(pDCI->DeviceResYDPI)
                        ARGFD6(DevPelRatio, 1, 6)));

        pDCI->DevPelRatio               = (FD6)DevPelRatio;
        pDCI->ClrXFormBlock.DevGamma[0] = UDECI4ToFD6(HTInitInfo.DeviceRGamma);
        pDCI->ClrXFormBlock.DevGamma[1] = UDECI4ToFD6(HTInitInfo.DeviceGGamma);
        pDCI->ClrXFormBlock.DevGamma[2] = UDECI4ToFD6(HTInitInfo.DeviceBGamma);

        if ((UseCurNTDefault)                                   ||
            (HTInitInfo.HTPatternIndex > HTPAT_SIZE_MAX_INDEX)  ||
            ((HTInitInfo.HTPatternIndex == HTPAT_SIZE_USER) &&
             (HTInitInfo.pHalftonePattern == NULL))) {

            if ((HTInitInfo.HTPatternIndex != HTPAT_SIZE_8x8) &&
                (HTInitInfo.HTPatternIndex != HTPAT_SIZE_8x8_M)) {

                HTInitInfo.HTPatternIndex = HTPAT_SIZE_DEFAULT;
            }
        }

        if ((HTInitInfo.Flags & HIF_ADDITIVE_PRIMS)     &&
            (HTInitInfo.HTPatternIndex <= HTPAT_SIZE_4x4_M)) {

            HTInitInfo.HTPatternIndex = DEFAULT_SCR_HTPAT_SIZE;
        }

        switch (HTInitInfo.Flags & (HIF_INK_HIGH_ABSORPTION |
                                    HIF_INK_ABSORPTION_INDICES)) {

        case HIF_HIGHEST_INK_ABSORPTION:

            _RegDataIdx = 0;
            break;

        case HIF_HIGHER_INK_ABSORPTION:

            _RegDataIdx = 1;
            break;

        case HIF_HIGH_INK_ABSORPTION:

            _RegDataIdx = 2;
            break;

        case HIF_LOW_INK_ABSORPTION:

            _RegDataIdx = 4;
            break;

        case HIF_LOWER_INK_ABSORPTION:

            _RegDataIdx = 5;
            break;

        case HIF_LOWEST_INK_ABSORPTION:

            _RegDataIdx = 6;
            break;

        case HIF_NORMAL_INK_ABSORPTION:
        default:

            _RegDataIdx = 3;
            break;
        }

        pDCI->ClrXFormBlock.RegDataIdx = (BYTE)_RegDataIdx;

        GetCIEPrims(HTInitInfo.pDeviceCIEInfo,
                    &(pDCI->ClrXFormBlock.DevCIEPrims),
                    (PCIEINFO)&HT_CIE_SRGB,
                    TRUE);

        GetCIEPrims(HTInitInfo.pInputRGBInfo,
                    &(pDCI->ClrXFormBlock.rgbCIEPrims),
                    (PCIEINFO)&HT_CIE_SRGB,
                    FALSE);

        //
        // Compute the solid dyes mixes information and its hue shifting
        // correction factors.
        //

        if (pDCI->Flags & DCIF_NEED_DYES_CORRECTION) {

            SOLIDDYESINFO   SDI;
            MATRIX3x3       FD6SDI;
            BOOL            HasDevSDI;

            //
            // We have make sure the solid dyes info passed from the caller can be
            // inversed, if not we will use our default
            //

            if (HasDevSDI = (HTInitInfo.pDeviceSolidDyesInfo) ? TRUE : FALSE) {

                SDI = *(HTInitInfo.pDeviceSolidDyesInfo);

                if ((SDI.MagentaInCyanDye   > (UDECI4)9000) ||
                    (SDI.YellowInCyanDye    > (UDECI4)9000) ||
                    (SDI.CyanInMagentaDye   > (UDECI4)9000) ||
                    (SDI.YellowInMagentaDye > (UDECI4)9000) ||
                    (SDI.CyanInYellowDye    > (UDECI4)9000) ||
                    (SDI.MagentaInYellowDye > (UDECI4)9000)) {

                    HasDevSDI = FALSE;

                } else if ((SDI.MagentaInCyanDye   == UDECI4_0) &&
                           (SDI.YellowInCyanDye    == UDECI4_0) &&
                           (SDI.CyanInMagentaDye   == UDECI4_0) &&
                           (SDI.YellowInMagentaDye == UDECI4_0) &&
                           (SDI.CyanInYellowDye    == UDECI4_0) &&
                           (SDI.MagentaInYellowDye == UDECI4_0)) {

                    //
                    // Do not need any correction if it all zeros
                    //

                    pDCI->Flags &= (WORD)(~DCIF_NEED_DYES_CORRECTION);
                }

            } else {

                pDCI->Flags &= (WORD)(~DCIF_NEED_DYES_CORRECTION);
            }

            if (pDCI->Flags & DCIF_NEED_DYES_CORRECTION) {

                #define PDCI_CMYDYEMASKS    pDCI->ClrXFormBlock.CMYDyeMasks


                MULDIVPAIR  MDPairs[4];
                FD6         Y;


                if ((UseCurNTDefault) || (!HasDevSDI)) {

                    SDI = DefaultSolidDyesInfo;
                }

                FD6SDI.m[0][1] = UDECI4ToFD6(SDI.CyanInMagentaDye);
                FD6SDI.m[0][2] = UDECI4ToFD6(SDI.CyanInYellowDye);

                FD6SDI.m[1][0] = UDECI4ToFD6(SDI.MagentaInCyanDye);
                FD6SDI.m[1][2] = UDECI4ToFD6(SDI.MagentaInYellowDye);

                FD6SDI.m[2][0] = UDECI4ToFD6(SDI.YellowInCyanDye);
                FD6SDI.m[2][1] = UDECI4ToFD6(SDI.YellowInMagentaDye);

                FD6SDI.m[0][0] =
                FD6SDI.m[1][1] =
                FD6SDI.m[2][2] = FD6_1;

                ComputeInverseMatrix3x3(&FD6SDI, &(PDCI_CMYDYEMASKS));

                if (!(pDCI->Flags & DCIF_HAS_BLACK_DYE)) {

                    MAKE_MULDIV_INFO(MDPairs, 3, MULDIV_NO_DIVISOR);
                    MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Xr(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Xg(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Xb(PDCI_CMYDYEMASKS), FD6_1);

                    Y = FD6_1 - MulFD6(FD6_1 - MulDivFD6Pairs(MDPairs),
                                       pDCI->PrimAdj.DevCSXForm.Yrgb.R);

                    MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Yr(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Yg(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Yb(PDCI_CMYDYEMASKS), FD6_1);

                    Y -= MulFD6(FD6_1 - MulDivFD6Pairs(MDPairs),
                                pDCI->PrimAdj.DevCSXForm.Yrgb.G);

                    MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Zr(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Zg(PDCI_CMYDYEMASKS), FD6_1);
                    MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Zb(PDCI_CMYDYEMASKS), FD6_1);

                    Y -= MulFD6(FD6_1 - MulDivFD6Pairs(MDPairs),
                                pDCI->PrimAdj.DevCSXForm.Yrgb.B);

                    DBGP_IF(DBGP_DYECORRECTION,
                            DBGP("DYE: Maximum Y=%s, Make Luminance from %s to %s, Turn ON DCIF_HAS_BLACK_DYE"
                                ARGFD6(Y, 1, 6)
                                ARGFD6(pDCI->ClrXFormBlock.DevCIEPrims.Yw, 1, 6)
                                ARGFD6(MulFD6(Y,
                                              pDCI->ClrXFormBlock.DevCIEPrims.Yw),
                                       1, 6)));

                    pDCI->Flags                        |= DCIF_HAS_BLACK_DYE;
                    pDCI->ClrXFormBlock.DevCIEPrims.Yw  =
                                MulFD6(pDCI->ClrXFormBlock.DevCIEPrims.Yw, Y);
                }

                DBGP_IF(DBGP_DYECORRECTION,

                    FD6         C;
                    FD6         M;
                    FD6         Y;
                    FD6         C1;
                    FD6         M1;
                    FD6         Y1;
                    static BYTE DyeName[] = "WCMBYGRK";
                    WORD        Loop = 0;

                    DBGP("====== DyeCorrection 3x3 Matrix =======");
                    DBGP("[Cc Cm Cy] [%s %s %s] [%s %s %s]"
                                        ARGFD6(FD6SDI.m[0][0], 2, 6)
                                        ARGFD6(FD6SDI.m[0][1], 2, 6)
                                        ARGFD6(FD6SDI.m[0][2], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[0][0], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[0][1], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[0][2], 2, 6));
                    DBGP("[Mc Mm My]=[%s %s %s]=[%s %s %s]"
                                        ARGFD6(FD6SDI.m[1][0], 2, 6)
                                        ARGFD6(FD6SDI.m[1][1], 2, 6)
                                        ARGFD6(FD6SDI.m[1][2], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[1][0], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[1][1], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[1][2], 2, 6));
                    DBGP("[Yc Ym Yy] [%s %s %s] [%s %s %s]"
                                        ARGFD6(FD6SDI.m[2][0], 2, 6)
                                        ARGFD6(FD6SDI.m[2][1], 2, 6)
                                        ARGFD6(FD6SDI.m[2][2], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[2][0], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[2][1], 2, 6)
                                        ARGFD6(PDCI_CMYDYEMASKS.m[2][2], 2, 6));
                    DBGP("================================================");

                    MAKE_MULDIV_INFO(MDPairs, 3, MULDIV_NO_DIVISOR);

                    for (Loop = 0; Loop <= 7; Loop++) {

                        C = (FD6)((Loop & 0x01) ? FD6_1 : FD6_0);
                        M = (FD6)((Loop & 0x02) ? FD6_1 : FD6_0);
                        Y = (FD6)((Loop & 0x04) ? FD6_1 : FD6_0);


                        MAKE_MULDIV_PAIR(MDPairs,1,CIE_Xr(PDCI_CMYDYEMASKS),C);
                        MAKE_MULDIV_PAIR(MDPairs,2,CIE_Xg(PDCI_CMYDYEMASKS),M);
                        MAKE_MULDIV_PAIR(MDPairs,3,CIE_Xb(PDCI_CMYDYEMASKS),Y);
                        C1 = MulDivFD6Pairs(MDPairs);

                        MAKE_MULDIV_PAIR(MDPairs,1,CIE_Yr(PDCI_CMYDYEMASKS),C);
                        MAKE_MULDIV_PAIR(MDPairs,2,CIE_Yg(PDCI_CMYDYEMASKS),M);
                        MAKE_MULDIV_PAIR(MDPairs,3,CIE_Yb(PDCI_CMYDYEMASKS),Y);
                        M1 = MulDivFD6Pairs(MDPairs);

                        MAKE_MULDIV_PAIR(MDPairs,1,CIE_Zr(PDCI_CMYDYEMASKS),C);
                        MAKE_MULDIV_PAIR(MDPairs,2,CIE_Zg(PDCI_CMYDYEMASKS),M);
                        MAKE_MULDIV_PAIR(MDPairs,3,CIE_Zb(PDCI_CMYDYEMASKS),Y);
                        Y1 = MulDivFD6Pairs(MDPairs);

                        DBGP("%u:[%c] = [%s %s %s]"
                            ARGU(Loop) ARGB(DyeName[Loop])
                            ARGFD6(C1, 2, 6) ARGFD6(M1, 2, 6) ARGFD6(Y1, 2, 6));
                    }
                );
            }
        }

        //
        // Re-compute
        //
        // Geneate internal HTCELL data structure based on the halftone
        // pattern data passed.
        //

        if ((Result = ComputeHTCell((WORD)HTInitInfo.HTPatternIndex,
                                    HTInitInfo.pHalftonePattern,
                                    pDCI)) < 0) {

            CleanUpDHI((PDEVICEHALFTONEINFO)pHT_DHI);
            HTAPI_RET(HTAPI_IDX_CREATE_DHI, Result);
        }

        //
        // Compute simulated rotate pattern for 3 planes
        //

#if DO_CACHE_DCI
        AddCachedDCI(pDCI);
#endif
    }

    pDCI->CRTX[CRTX_LEVEL_255].PrimMax  = CRTX_PRIMMAX_255;
    pDCI->CRTX[CRTX_LEVEL_255].SizeCRTX = (WORD)CRTX_SIZE_255;
    pDCI->CRTX[CRTX_LEVEL_RGB].PrimMax  = CRTX_PRIMMAX_RGB;
    pDCI->CRTX[CRTX_LEVEL_RGB].SizeCRTX = (WORD)CRTX_SIZE_RGB;

    //
    // Setting the public field so the caller can looked at
    //

    pHT_DHI->DHI.DeviceOwnData     = 0;
    pHT_DHI->DHI.cxPattern         = (WORD)pDCI->HTCell.cxReal;
    pHT_DHI->DHI.cyPattern         = (WORD)pDCI->HTCell.Height;

    if ((HTInitInfo.DefHTColorAdjustment.caIlluminantIndex >
                                            ILLUMINANT_MAX_INDEX)       ||
        (HTInitInfo.DefHTColorAdjustment.caSize !=
                                            sizeof(COLORADJUSTMENT))    ||
        ((HTInitInfo.DefHTColorAdjustment.caRedGamma   == 10000)  &&
         (HTInitInfo.DefHTColorAdjustment.caGreenGamma == 10000)  &&
         (HTInitInfo.DefHTColorAdjustment.caBlueGamma  == 10000))) {

        pHT_DHI->DHI.HTColorAdjustment = DefaultCA;

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("*** USE DEFAULT COLORADJUSTMENT in DCI *** "));

    } else {

        pHT_DHI->DHI.HTColorAdjustment = HTInitInfo.DefHTColorAdjustment;
    }

    if ((HTInitInfo.Flags & (HIF_ADDITIVE_PRIMS | HIF_PRINT_DRAFT_MODE)) ==
                                                  HIF_PRINT_DRAFT_MODE) {

        pDCI->Flags |= DCIF_PRINT_DRAFT_MODE;
    }

    //
    // Compute what 8bpp mode we will be in
    //

    if (HTInitInfo.Flags & HIF_USE_8BPP_BITMASK) {

        pDCI->Flags |= DCIF_USE_8BPP_BITMASK |
                       ((HTInitInfo.Flags & HIF_INVERT_8BPP_BITMASK_IDX) ?
                            DCIF_INVERT_8BPP_BITMASK_IDX : 0);
        _cC          = (DWORD)((HTInitInfo.CMYBitMask8BPP >> 5) & 0x7);
        _cM          = (DWORD)((HTInitInfo.CMYBitMask8BPP >> 2) & 0x7);
        _cY          = (DWORD)((HTInitInfo.CMYBitMask8BPP     ) & 0x3);

        if (HTInitInfo.CMYBitMask8BPP == 1) {

            //
            // This is 4:4:4: format (0-4 of 5 levels)
            //

            _cC =
            _cM =
            _cY = 4;
            HTInitInfo.CMYBitMask8BPP = (BYTE)((5 * 5 * 5) - 1);

        } else if (HTInitInfo.CMYBitMask8BPP == 2) {

            //
            // This is 5:5:5: format (0-5 of 6 levels)
            //

            _cC =
            _cM =
            _cY = 5;
            HTInitInfo.CMYBitMask8BPP = (BYTE)((6 * 6 * 6) - 1);

        } else if ((_cC < 1) || (_cM < 1) || (_cY < 1)) {

            _cC                        =
            _cM                        =
            _cY                        = 0xFF;
            HTInitInfo.CMYBitMask8BPP  = 0xFF;
            pDCI->Flags               |= DCIF_MONO_8BPP_BITMASK;
        }

        pDCI->CMY8BPPMask.GenerateXlate =
                        (pDCI->Flags & DCIF_INVERT_8BPP_BITMASK_IDX) ? 1 : 0;

        if ((_cC == _cM) && (_cC == _cY)) {

            pDCI->Flags                 |= DCIF_CMY8BPPMASK_SAME_LEVEL;
            pDCI->CMY8BPPMask.SameLevel  = (BYTE)_cC;

        } else {

            pDCI->CMY8BPPMask.SameLevel  = 0;
        }

        if ((_MaxCMY = _cC) < _cM) {

            _MaxCMY = _cM;
        }

        if (_MaxCMY < _cY) {

            _MaxCMY = _cY;
        }

        //
        // Set to 0xFFFF to indicate this is a default setting to start with
        // then modified depends on the parameters passed
        //

        pDCI->CMY8BPPMask.KCheck = 0xFFFF;

        if ((_MaxCMY <= 6)                  &&
            (pHTInitInfo->pDeviceCIEInfo)   &&
            (pHTInitInfo->pDeviceCIEInfo->Blue.Y == VALID_YB_DENSITY)) {

            PCIEINFO    pCIE = pHTInitInfo->pDeviceCIEInfo;

            //
            // 27-Sep-2000 Wed 15:05:38 updated  -by-  Daniel Chou (danielc)
            //  if Blue.Y == 0xfffe then it specified that it has CMY densities
            //  in the CIEINFO, Cyan.x=C1,C2, Cyan.y=C3,C4, Red.Y=C5,C6
            //  Magenta.x=M1,M2, Magenta.y=M3,M4, Magenta.Y=M5,M6
            //  Yellow.x=Y1,Y2, Yellow.y=Y3,Y4, Yellow.Y=Y5,Y6, each density is
            //  one byte and its computation is (C1+1)/256 to get the perentage
            //  of the density.  The Last level is to specified maximum dye
            //  output for that color. for example if Cyan has 2 levels
            //  and C1=0x7F and C2=0xF0 then first level of ink is
            //  (0x7f+1) / 0x100=50% and last level of ink is 0xF0 which
            //  speicified maximum ink will be used, at here =
            //  (0xF0 + 1) / 0x100 = 94.14% which maximum cyan ink will be at
            //  94.14% not 100%
            //

            pDCI->Flags               |= DCIF_HAS_DENSITY;
            pDCI->CMY8BPPMask.DenC[0]  = GET_DEN_HI(pCIE->Cyan.x);
            pDCI->CMY8BPPMask.DenC[1]  = GET_DEN_LO(pCIE->Cyan.x);
            pDCI->CMY8BPPMask.DenC[2]  = GET_DEN_HI(pCIE->Cyan.y);
            pDCI->CMY8BPPMask.DenC[3]  = GET_DEN_LO(pCIE->Cyan.y);
            pDCI->CMY8BPPMask.DenC[4]  = GET_DEN_HI(pCIE->Red.Y);
            pDCI->CMY8BPPMask.DenC[5]  = GET_DEN_LO(pCIE->Red.Y);
            pDCI->CMY8BPPMask.DenM[0]  = GET_DEN_HI(pCIE->Magenta.x);
            pDCI->CMY8BPPMask.DenM[1]  = GET_DEN_LO(pCIE->Magenta.x);
            pDCI->CMY8BPPMask.DenM[2]  = GET_DEN_HI(pCIE->Magenta.y);
            pDCI->CMY8BPPMask.DenM[3]  = GET_DEN_LO(pCIE->Magenta.y);
            pDCI->CMY8BPPMask.DenM[4]  = GET_DEN_HI(pCIE->Magenta.Y);
            pDCI->CMY8BPPMask.DenM[5]  = GET_DEN_LO(pCIE->Magenta.Y);
            pDCI->CMY8BPPMask.DenY[0]  = GET_DEN_HI(pCIE->Yellow.x);
            pDCI->CMY8BPPMask.DenY[1]  = GET_DEN_LO(pCIE->Yellow.x);
            pDCI->CMY8BPPMask.DenY[2]  = GET_DEN_HI(pCIE->Yellow.y);
            pDCI->CMY8BPPMask.DenY[3]  = GET_DEN_LO(pCIE->Yellow.y);
            pDCI->CMY8BPPMask.DenY[4]  = GET_DEN_HI(pCIE->Yellow.Y);
            pDCI->CMY8BPPMask.DenY[5]  = GET_DEN_LO(pCIE->Yellow.Y);

            //
            // The Green.Y is a UDECI4 number that specified the black ink
            // replacement base ratio, the range and meaning as follow
            //
            //           0: Default black ink replacement computation
            //  1  -  9999: Specified black ink replacement base ratio
            //    >= 10000: turn off black ink replacement computation
            //

            if (pCIE->Green.Y >= UDECI4_1) {

                pDCI->CMY8BPPMask.KCheck = FD6_0;

            } else if (pCIE->Green.Y != UDECI4_0) {

                pDCI->CMY8BPPMask.KCheck = UDECI4ToFD6(pCIE->Green.Y);
            }

            _MaxMulDiv                 = DivFD6(FD6_1, pDCI->DevPelRatio);
            pDCI->CMY8BPPMask.MaxMulC  = MulFD6(pDCI->CMY8BPPMask.DenC[_cC - 1],
                                                _MaxMulDiv);
            pDCI->CMY8BPPMask.MaxMulM  = MulFD6(pDCI->CMY8BPPMask.DenM[_cM - 1],
                                                _MaxMulDiv);
            pDCI->CMY8BPPMask.MaxMulY  = MulFD6(pDCI->CMY8BPPMask.DenY[_cY - 1],
                                                _MaxMulDiv);

            for (_Idx = COUNT_ARRAY(pDCI->CMY8BPPMask.DenC);
                 _Idx > 0;
                 _Idx--) {

                if (_Idx >= _cC) {

                    pDCI->CMY8BPPMask.DenC[_Idx - 1]  = FD6_1;
                }

                if (_Idx >= _cM) {

                    pDCI->CMY8BPPMask.DenM[_Idx - 1]  = FD6_1;
                }

                if (_Idx >= _cY) {

                    pDCI->CMY8BPPMask.DenY[_Idx - 1]  = FD6_1;
                }
            }

            DBGP_IF(DBGP_CACHED_DCI,
                    DBGP("   Cyan %ld/%s Density: %s, %s, %s, %s, %s, %s"
                            ARGDW(_cC)
                            ARGFD6(pDCI->CMY8BPPMask.MaxMulC, 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[0], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[1], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[2], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[3], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[4], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenC[5], 1, 6)));

            DBGP_IF(DBGP_CACHED_DCI,
                    DBGP("Magenta %ld/%s Density: %s, %s, %s, %s, %s, %s"
                            ARGDW(_cM)
                            ARGFD6(pDCI->CMY8BPPMask.MaxMulM, 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[0], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[1], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[2], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[3], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[4], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenM[5], 1, 6)));

            DBGP_IF(DBGP_CACHED_DCI,
                    DBGP(" Yellow %ld/%s Density: %s, %s, %s, %s, %s, %s"
                            ARGDW(_cY)
                            ARGFD6(pDCI->CMY8BPPMask.MaxMulY, 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[0], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[1], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[2], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[3], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[4], 1, 6)
                            ARGFD6(pDCI->CMY8BPPMask.DenY[5], 1, 6)));

        } else {

            _MaxMulDiv                = FD6xL(pDCI->DevPelRatio, _MaxCMY);
            pDCI->CMY8BPPMask.MaxMulC = DivFD6(FD6xL(FD6_1, _cC), _MaxMulDiv);
            pDCI->CMY8BPPMask.MaxMulM = DivFD6(FD6xL(FD6_1, _cM), _MaxMulDiv);
            pDCI->CMY8BPPMask.MaxMulY = DivFD6(FD6xL(FD6_1, _cY), _MaxMulDiv);
        }

        if ((_MaxMulDiv = pDCI->CMY8BPPMask.MaxMulC) <
                                                pDCI->CMY8BPPMask.MaxMulM) {

            _MaxMulDiv =  pDCI->CMY8BPPMask.MaxMulM;
        }

        if (_MaxMulDiv < pDCI->CMY8BPPMask.MaxMulY) {

            _MaxMulDiv =  pDCI->CMY8BPPMask.MaxMulY;
        }

        if (pDCI->CMY8BPPMask.KCheck == 0xFFFF) {

            //
            // Default setting, turn off K Replacement only if
            // DevPelsRatio/Density = 100% and CMY inks are in same level
            //

            pDCI->CMY8BPPMask.KCheck =
                        ((_MaxMulDiv == FD6_1) &&
                         (pDCI->Flags & DCIF_CMY8BPPMASK_SAME_LEVEL)) ?
                                                        FD6_0 : K_REP_START;
        }

        if (pDCI->CMY8BPPMask.KCheck == FD6_0) {

            //
            // If K replacement was turn off, but the ratio is not 100% or
            // have different ink levels then wee need to turn it on at
            // 1.0 (FD6_1) so that a 8bpp black replacement function is
            // used, only in k replacement function it compute how to
            // reduced non 100% device pel ratio (KPower)
            //

            if ((_MaxMulDiv != FD6_1) ||
                (!(pDCI->Flags & DCIF_CMY8BPPMASK_SAME_LEVEL))) {

                pDCI->CMY8BPPMask.KCheck = FD6_1;
            }
        }

        DBGP_IF(DBGP_CACHED_DCI,
            DBGP("KCheck= %s ^ %s = %s"
                ARGFD6(pDCI->CMY8BPPMask.KCheck, 1, 6) ARGFD6(_MaxMulDiv, 1, 6)
                ARGFD6(Power(pDCI->CMY8BPPMask.KCheck, _MaxMulDiv), 1, 6)));

        pDCI->CMY8BPPMask.KCheck  = Power(pDCI->CMY8BPPMask.KCheck, _MaxMulDiv);
        pDCI->CMY8BPPMask.PatSubC =
                        (WORD)MulFD6(pDCI->CMY8BPPMask.MaxMulC, 0xFFF) + 1;
        pDCI->CMY8BPPMask.PatSubM =
                        (WORD)MulFD6(pDCI->CMY8BPPMask.MaxMulM, 0xFFF) + 1;
        pDCI->CMY8BPPMask.PatSubY =
                        (WORD)MulFD6(pDCI->CMY8BPPMask.MaxMulY, 0xFFF) + 1;

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("*** USE_8BPP_BITMASK: CMY=%ld:%ld:%ld, Same=%ld], Mask=%02lx, Max=%ld ***"
                    ARGDW(_cC) ARGDW(_cM) ARGDW(_cY)
                    ARGDW(pDCI->CMY8BPPMask.SameLevel)
                    ARGDW(HTInitInfo.CMYBitMask8BPP) ARGDW(_MaxCMY)));

        DBGP_IF(DBGP_CACHED_DCI,
                DBGP("*** MaxMulCMY=%s:%s:%s [KCheck=%s], SubCMY=%4ld:%4ld:%4ld ***"
                    ARGFD6(pDCI->CMY8BPPMask.MaxMulC, 1, 6)
                    ARGFD6(pDCI->CMY8BPPMask.MaxMulM, 1, 6)
                    ARGFD6(pDCI->CMY8BPPMask.MaxMulY, 1, 6)
                    ARGFD6(pDCI->CMY8BPPMask.KCheck, 1, 6)
                    ARGDW(pDCI->CMY8BPPMask.PatSubC)
                    ARGDW(pDCI->CMY8BPPMask.PatSubM)
                    ARGDW(pDCI->CMY8BPPMask.PatSubY)));

    } else {

        _cC                       =
        _cM                       =
        _cY                       =
        _MaxCMY                   = 1;
        HTInitInfo.CMYBitMask8BPP = 0xFF;
    }

    pDCI->CMY8BPPMask.cC   = (BYTE)_cC;
    pDCI->CMY8BPPMask.cM   = (BYTE)_cM;
    pDCI->CMY8BPPMask.cY   = (BYTE)_cY;
    pDCI->CMY8BPPMask.Max  = (BYTE)_MaxCMY;
    pDCI->CMY8BPPMask.Mask = (BYTE)HTInitInfo.CMYBitMask8BPP;

    //
    // Now compute the HTSMP checksum for the pattern
    //

    dwBuf[0] = (DWORD)pDCI->DeviceResXDPI;
    dwBuf[1] = (DWORD)pDCI->DeviceResYDPI;
    dwBuf[2] = (DWORD)pDCI->DevPelRatio;
    dwBuf[3] = (DWORD)(dwBuf[0] + dwBuf[1]);

    pDCI->HTSMPChecksum = ComputeChecksum((LPBYTE)&dwBuf[0],
                                          HTSMP_INITIAL_CHECKSUM,
                                          sizeof(dwBuf[0]) * 4);

    ASSERTMSG("pDCI->ClrXFormBlock.RegDataIdx > 6",
                        (pDCI->ClrXFormBlock.RegDataIdx < 7));

    if (pDCI->ClrXFormBlock.RegDataIdx > 6) {

        pDCI->ClrXFormBlock.RegDataIdx = 3;
    }

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("SMP Checksum = %08lx, RegDataIdx=%u"
                ARGDW(pDCI->HTSMPChecksum)
                ARGU(pDCI->ClrXFormBlock.RegDataIdx)));

    DBGP_IF(DBGP_CACHED_DCI,
            DBGP("*** Final DevResDPI=%ld x %ld DevPelRatio=%ld, cx/cyPat=%ld x %ld=%ld *** "
                        ARGDW(pDCI->DeviceResXDPI)
                        ARGDW(pDCI->DeviceResYDPI)
                        ARGDW(pDCI->DevPelRatio)
                        ARGDW(pHT_DHI->DHI.cxPattern)
                        ARGDW(pHT_DHI->DHI.cyPattern)
                        ARGDW(pDCI->HTCell.Size)));

    //
    // Set the ILLUMINANT index to an invalid value for next one will get
    // computed
    //

    pDCI->Flags                |= ExtraDCIF;
    pDCI->ca.caSize             = ADJ_FORCE_DEVXFORM;
    pDCI->ca.caIlluminantIndex  = 0xffff;
    *ppDeviceHalftoneInfo       = (PDEVICEHALFTONEINFO)pHT_DHI;

    return(HALFTONE_DLL_ID);


#undef _RegDataIdx
#undef _MaxMulDiv
#undef _cC
#undef _cM
#undef _cY
#undef _MaxCMY
#undef _Idx
}




BOOL
APIENTRY
HT_LOADDS
HT_DestroyDeviceHalftoneInfo(
    PDEVICEHALFTONEINFO     pDeviceHalftoneInfo
    )

/*++

Routine Description:

    This function destroy the handle which returned from halftone initialize
    function HT_CreateDeviceHalftoneInfo()

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

Return Value:

    TRUE    - if function sucessed.
    FALSE   - if function failed.

Author:

    05-Feb-1991 Tue 14:18:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if ((!pDeviceHalftoneInfo) ||
        (PHT_DHI_DCI_OF(HalftoneDLLID) != HALFTONE_DLL_ID)) {

        SET_ERR(HTAPI_IDX_DESTROY_DHI, HTERR_INVALID_DHI_POINTER);
        return(FALSE);
    }

    return(CleanUpDHI(pDeviceHalftoneInfo));
}




LONG
APIENTRY
HT_LOADDS
HT_CreateHalftoneBrush(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PCOLORTRIAD         pColorTriad,
    CHBINFO             CHBInfo,
    LPVOID              pOutputBuffer
    )

/*++

Routine Description:

    This function create halftone mask for the requested solid color.

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

    pHTColorAdjustment  - Pointer to the HTCOLORADJUSTMENT data structure to
                          specified the input/output color adjustment/transform,
                          if this pointer is NULL then a default color
                          adjustments is applied.

    pColorTriad         - Pointer to the COLORTRIAD data structure to describe
                          the brush colors.

    CHBInfo             - CHBINFO data structure, specified following:

                            Flags: CHBF_BW_ONLY
                                   CHBF_USE_ADDITIVE_PRIMS
                                   CHBF_NEGATIVE_PATTERN


                            DestSurfaceFormat:  BMF_1BPP
                                                BMF_4BPP
                                                BMF_4BPP_VGA16
                                                BMF_8BPP_VGA256

                            ScanLineAlignBytes: 0 - 255

                            DestPrimaryOrder:   One of PRIMARY_ORDER_xxx



    pOutputBuffer       - Pointer to the buffer area to received indices/mask.
                          in bytes needed to stored the halftone pattern.


Return Value:

    if the return value is negative or zero then an error was encountered,
    possible error codes are

        HTERR_INVALID_DHI_POINTER           - Invalid pDevideHalftoneInfo is
                                              passed.

        HTERR_INVALID_DEST_FORMAT           - the Format of the destination
                                              surface is not one of the defined
                                              HSC_FORMAT_xxxx

        HTERR_CHB_INV_COLORTABLE_SIZE       - Color table size is not 1

    otherwise

        If pSurface is NULL, it return the bytes count which need to stored
        the pattern, otherwise it return the size in byte copied to the output
        buffer.

Author:

    05-Feb-1991 Tue 14:28:23 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    PDEVICECOLORINFO    pDCI;
    PDEVCLRADJ          pDevClrAdj;
    CTSTD_UNION         CTSTDUnion;
    WORD                ForceFlags;
    LONG                cbBufScan;
    LONG                cbBufSize;


    if ((!pColorTriad)                          ||
        (pColorTriad->ColorTableEntries != 1)   ||
        (!(pColorTriad->pColorTable))) {

        HTAPI_RET(HTAPI_IDX_CHB, HTERR_CHB_INV_COLORTABLE_SIZE);
    }

    ForceFlags             = ADJ_FORCE_BRUSH;
    CTSTDUnion.b.cbPrim    = 0;
    CTSTDUnion.b.SrcOrder  = pColorTriad->PrimaryOrder;
    CTSTDUnion.b.BMFDest   = CHBInfo.DestSurfaceFormat;
    CTSTDUnion.b.DestOrder = CHBInfo.DestPrimaryOrder;

    if ((CHBInfo.Flags & CHBF_BW_ONLY) ||
        (CHBInfo.DestSurfaceFormat == BMF_1BPP)) {

        ForceFlags |= ADJ_FORCE_MONO;
    }

    if (CHBInfo.Flags & CHBF_NEGATIVE_BRUSH) {

        ForceFlags |= ADJ_FORCE_NEGATIVE;
    }

    if (CHBInfo.Flags & CHBF_USE_ADDITIVE_PRIMS) {

        ForceFlags |= ADJ_FORCE_ADDITIVE_PRIMS;
    }

    if (CHBInfo.Flags & CHBF_ICM_ON) {

        ForceFlags |= ADJ_FORCE_ICM;
    }

    SETDBGVAR(pDevClrAdj, NULL);

    if (!(pDCI = pDCIAdjClr(pDeviceHalftoneInfo,
                            pHTColorAdjustment,
                            (pOutputBuffer) ? &pDevClrAdj : NULL,
                            0,
                            ForceFlags,
                            CTSTDUnion.b,
                            &cbBufSize))) {

        HTAPI_RET(HTAPI_IDX_CHB, cbBufSize);
    }

    cbBufScan = (LONG)ComputeBytesPerScanLine(
                                        (UINT)CHBInfo.DestSurfaceFormat,
                                        (UINT)CHBInfo.DestScanLineAlignBytes,
                                        (DWORD)pDCI->HTCell.cxReal);
    cbBufSize = cbBufScan * (LONG)pDCI->HTCell.Height;

    if (pOutputBuffer) {

        if (CHBInfo.Flags & CHBF_BOTTOMUP_BRUSH) {

            (LPBYTE)pOutputBuffer += (cbBufSize - cbBufScan);
            cbBufScan              = -cbBufScan;
        }

        //-------------------------------------------------------------------
        // CreateHalftoneBrushPat will release the semaphore for us
        //-------------------------------------------------------------------

        if ((cbBufScan = CreateHalftoneBrushPat(pDCI,
                                                pColorTriad,
                                                pDevClrAdj,
                                                pOutputBuffer,
                                                cbBufScan)) <= 0) {

            cbBufSize = cbBufScan;
        }

        if (HTFreeMem(pDevClrAdj)) {

            ASSERTMSG("HTFreeMem(pDevClrAdj) Failed", FALSE);
        }

    } else {

        RELEASE_HTMUTEX(pDCI->HTMutex);

        ASSERT(pDevClrAdj == NULL);
    }

    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_CreateHalftoneBrush(%hs %ld/%6ld): RGB=0x%08lx (%ld), Dst(Fmt=%ld, Order=%ld)"
                    ARGPTR((pOutputBuffer) ? "BUF" : "NUL")
                    ARGDW(pDCI->cbMemTot) ARGDW(pDCI->cbMemMax)
                    ARGDW(*((LPDWORD)pColorTriad->pColorTable))
                    ARGDW(pColorTriad->PrimaryOrder)
                    ARGDW(CHBInfo.DestSurfaceFormat)
                    ARGDW(CHBInfo.DestPrimaryOrder)));

    HTAPI_RET(HTAPI_IDX_CHB, cbBufSize);
}




LONG
APIENTRY
HT_LOADDS
HT_ComputeRGBGammaTable(
    WORD    GammaTableEntries,
    WORD    GammaTableType,
    UDECI4  RedGamma,
    UDECI4  GreenGamma,
    UDECI4  BlueGamma,
    LPBYTE  pGammaTable
    )

/*++

Routine Description:

    This function compute device gamma correction table based on the lightness

                                                       (1/RedGamma)
    Gamma[N] = INT((LIGHTNESS(N / GammaTableEntries-1))             x 255)

                                      3
    LIGHTNESS(x) = ((x + 0.16) / 1.16)      if x >= 0.007996
                   (x / 9.033)              if x <  0.007996


    1. INT() is a integer function which round up to next integer number if
       resulting fraction is 0.5 or higher, the final result always limit
       to have range between 0 and 255.

    2. N is a integer step number and range from 0 to (GammaTableEntries-1)
       in one (1) increment.


Arguments:

    GammaTableEntries       - Total gamma table entries for each of red, green
                              and blue gamma table, halftone dll normalized
                              the gamma table with step value computed as
                              1/GammaTableEntries.

                              This value must range from 3 to 255 else a 0
                              is returned and no table is updated.

    GammaTableType          - red, green and blue gamma table organizations

                                0 - The gamma table is Red, Green, Blue 3 bytes
                                    for each gamma step entries and total of
                                    GammaTableEntries entries.

                                1 - The gamma table is Red Gamma tables follow
                                    by green gamma table then follow by blue
                                    gamma table, each table has total of
                                    GammaTableEntries bytes.

                                Other value default to 0.

    RedGamma                - Red gamma number in UDECI4 format

    GreenGamma              - Green gamma number in UDECI4 format

    BlueGamma               - Blue gamma number in UDECI4 format

    pGammaTable             - pointer to the gamma table byte array.
                              each output gamma number is range from 0 to 255.


Return Value:

    Return value is the total table entries updated.

Author:

    15-Sep-1992 Tue 17:49:20 updated  -by-  Daniel Chou (danielc)
        Fixed bug# 6257

    17-Jul-1992 Fri 19:04:31 created    -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE      pRGamma;
    LPBYTE      pGGamma;
    LPBYTE      pBGamma;
    FD6         L_StepInc;
    FD6         IValue;
    FD6         Lightness;
    LONG        Result;
    UINT        NextEntry;
    FD6         RGBGamma[3];


    //
    // Initialize All internal data first
    //

    if (((Result = GammaTableEntries) > 256) ||
        (Result < 2)) {

        return(0);
    }

    Lightness   = FD6_0;
    L_StepInc   = DivFD6((FD6)1, (FD6)(GammaTableEntries - 1));
    RGBGamma[0] = UDECI4ToFD6(RedGamma);
    RGBGamma[1] = UDECI4ToFD6(GreenGamma);
    RGBGamma[2] = UDECI4ToFD6(BlueGamma);

    pRGamma    = pGammaTable;

    if (GammaTableType == 1) {

        pGGamma   = pRGamma + GammaTableEntries;
        pBGamma   = pGGamma + GammaTableEntries;
        NextEntry = 1;

    } else {

        pGGamma   = pRGamma + 1;
        pBGamma   = pGGamma + 1;
        NextEntry = 3;
    }

    while (--GammaTableEntries) {

        IValue      = Lightness;    // CIE_L2I(Lightness);
        *pRGamma    = RGB_8BPP(Radical(IValue, RGBGamma[0]));
        *pGGamma    = RGB_8BPP(Radical(IValue, RGBGamma[1]));
        *pBGamma    = RGB_8BPP(Radical(IValue, RGBGamma[2]));
        pRGamma    += NextEntry;
        pGGamma    += NextEntry;
        pBGamma    += NextEntry;
        Lightness  += L_StepInc;
    }

    *pRGamma =
    *pGGamma =
    *pBGamma = 255;

    return(Result);
}



LONG
APIENTRY
HT_LOADDS
HT_Get8BPPFormatPalette(
    LPPALETTEENTRY  pPaletteEntry,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    )

/*++

Routine Description:

    This functions retrieve a halftone's VGA256 color table definitions

Arguments:

    pPaletteEntry   - Pointer to PALETTEENTRY data structure array,

    RedGamma        - The monitor's red gamma value in UDECI4 format

    GreenGamma      - The monitor's green gamma value in UDECI4 format

    BlueGamma       - The monitor's blue gamma value in UDECI4 format


Return Value:

    if pPaletteEntry is NULL then it return the PALETTEENTRY count needed for
    VGA256 halftone process, if it is not NULL then it return the total
    paletteEntry updated.

    If the pPaletteEntry is not NULL then halftone.dll assume it has enough
    space for the size returned when this pointer is NULL.

Author:

    14-Apr-1992 Tue 13:03:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FD6     RGBGamma[3];
    FD6     IValue;
    FD6     Yr;
    FD6     Yg;
    FD6     Yb;
    UINT    RIndex;
    UINT    GIndex;
    UINT    BIndex;
    UINT    TableSize;

    DEFDBGVAR(UINT, PaletteIdx = 0)


    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_Get8BPPFormatPalette(%p): Gamma=%05ld:%05ld:%05ld"
                    ARGPTR(pPaletteEntry)
                    ARGDW(RedGamma) ARGDW(GreenGamma) ARGDW(BlueGamma)));

    //
    // Initialize All internal data first
    //

    if (pPaletteEntry) {

        RGBGamma[0] = UDECI4ToFD6(RedGamma);
        RGBGamma[1] = UDECI4ToFD6(GreenGamma);
        RGBGamma[2] = UDECI4ToFD6(BlueGamma);

        DBGP_IF(DBGP_GAMMA_PAL,
                DBGP("***** HT_Get8BPPFormatPalette: %s:%s:%s *****"
                     ARGFD6(RGBGamma[0], 1, 4)
                     ARGFD6(RGBGamma[1], 1, 4)
                     ARGFD6(RGBGamma[2], 1, 4)));

        //
        // Our VGA256 format is BGR type of Primary order.
        //

        RIndex    =
        GIndex    =
        BIndex    = 0;

        TableSize = VGA256_CUBE_SIZE;

        while (TableSize--) {

            Yr                     = DivFD6(RIndex, VGA256_R_IDX_MAX);
            Yg                     = DivFD6(GIndex, VGA256_G_IDX_MAX);
            Yb                     = DivFD6(BIndex, VGA256_B_IDX_MAX);
            pPaletteEntry->peRed   = RGB_8BPP(Yr);
            pPaletteEntry->peGreen = RGB_8BPP(Yg);
            pPaletteEntry->peBlue  = RGB_8BPP(Yb);
            pPaletteEntry->peFlags = 0;


            DBGP_IF(DBGP_GAMMA_PAL,
                    DBGP("%3u - %3u:%3u:%3u"
                     ARGU(PaletteIdx++)
                     ARGU(pPaletteEntry->peRed  )
                     ARGU(pPaletteEntry->peGreen)
                     ARGU(pPaletteEntry->peBlue )));

            ++pPaletteEntry;

            if ((++RIndex) > VGA256_R_IDX_MAX) {

                RIndex = 0;

                if ((++GIndex) > VGA256_G_IDX_MAX) {

                    GIndex = 0;
                    ++BIndex;
                }
            }
        }

        //
        // 03-Feb-1999 Wed 00:49:08 updated  -by-  Daniel Chou (danielc)
        //
        // Since all these monochrome/gray scale is not stick in the system
        // palette, The halftone codes with new supercell will not use these
        // entries anymore, so do not return it.
        //
#if 0
        RIndex = 0;

        while (RIndex <= VGA256_M_IDX_MAX) {

            IValue                  = DivFD6(RIndex++, VGA256_M_IDX_MAX);
            pPaletteEntry->peRed    = RGB_8BPP(IValue);
            pPaletteEntry->peGreen  = RGB_8BPP(IValue);
            pPaletteEntry->peBlue   = RGB_8BPP(IValue);
            pPaletteEntry->peFlags  = 0;

            DBGP_IF(DBGP_GAMMA_PAL,
                    DBGP("%3u - %3u:%3u:%3u [%s]"
                     ARGU(PaletteIdx++)
                     ARGU(pPaletteEntry->peRed  )
                     ARGU(pPaletteEntry->peGreen)
                     ARGU(pPaletteEntry->peBlue )
                     ARGFD6(IValue, 1, 6)));

            ++pPaletteEntry;
        }
#endif
    }

    return((LONG)VGA256_CUBE_SIZE);

    // return((LONG)VGA256_PALETTE_COUNT);

}





LONG
APIENTRY
HT_LOADDS
HT_Get8BPPMaskPalette(
    LPPALETTEENTRY  pPaletteEntry,
    BOOL            Use8BPPMaskPal,
    BYTE            CMYMask,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    )

/*++

Routine Description:

    This functions retrieve a halftone's VGA256 color table definitions

Arguments:

    pPaletteEntry   - Pointer to PALETTEENTRY data structure array,

    Use8BPPMaskPal  - TRUE if using byte Mask palette, false to use NT4.0
                      standard MS 8bpp palette

    CMYMask         - Specified level mask in C3:M3:Y2

    RedGamma        - The monitor's red gamma value in UDECI4 format

    GreenGamma      - The monitor's green gamma value in UDECI4 format

    BlueGamma       - The monitor's blue gamma value in UDECI4 format


Return Value:

    if pPaletteEntry is NULL then it return the PALETTEENTRY count needed for
    VGA256 halftone process, if it is not NULL then it return the total
    paletteEntry updated.

    If the pPaletteEntry is not NULL then halftone.dll assume it has enough
    space for the size returned when this pointer is NULL.

Author:

    14-Apr-1992 Tue 13:03:21 created  -by-  Daniel Chou (danielc)


Revision History:

    03-Aug-2000 Thu 19:58:18 updated  -by-  Daniel Chou (danielc)
        Overloading the pPaletteEntry to returned a inverted indices palette
        based on Whistler bug# 22915.  Because the Windows GDI ROP assume
        index 0 always black, last index alwasy white without checking the
        halftone palette and cause many rop got inverted result.

    08-Sep-2000 Fri 14:24:28 updated  -by-  Daniel Chou (danielc)
     For new CMY_INVERTED mode, we want to make sure we pack all
     possible ink entries in the middle of 256 indices and pack
     black/white at end.  If the total ink color compositions are
     an odd number then we duplicate the middle one.  This will

//
// ***************************************************************************
// * SPECIAL NOTE for Windows NT version later than Windows 2000 Release     *
// ***************************************************************************
// Current version of Window NT (Post Windows 2000) will Overloading the
// pPaletteEntry in HT_Get8BPPMaskPalette(DoUseCMYMask) API to returned a
// inverted indices palette based on additive palette entries composition.
// Because Windows GDI ROP assume index 0 always black and last index always
// white without checking the palette entries. (Indices based ROPs rather color
// based)  This cause many ROPS got wrong result which has inverted output.
//
// To correct this GDI ROPs behavior, the POST windows 2000 version of GDI
// Halftone will supports a special CMY_INVERTED format. All new drivers should
// use this CMY_INVERTED method for future compabilities
//
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @   Following Steps are required for ALL POST Windows 2000 Drivers when    @
// @   using Window GDI Halftone 8bpp CMY332 Mask mode                        @
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 1. Must set HT_FLAG_INVERT_8BPP_BITMASK_IDX flags
//
// 2. Must set pPaleteEntry[0] when calling HT_Get8BPPMaskPalette() with
//
//     pPaletteEntry[0].peRed   = 'R';
//     pPaletteEntry[0].peGreen = 'G';
//     pPaletteEntry[0].peBlue  = 'B';
//     pPaletteEntry[0].peFlags = '0';
//
//     The caller can use following supplied macro to set this for future
//     compabilities
//
//         HT_SET_BITMASKPAL2RGB(pPaletteEntry)
//
//     where pPaletteEntry is the pointer to the PALETTEENTRY that passed to
//     the HT_GET8BPPMaskPalette() fucntion call
//
// 3. Must Check the return Palette from HT_Get8BPPMaskPalette() using
//    following Macro
//
//         HT_IS_BITMASKPALRGB(pPaletteEntry)
//
//    where pPaletteEntry is the pointer to the PALETTEENTRY that passed to the
//    HT_GET8BPPMaskPalette() fucntion call,
//
//    If this macro return FALSE then the current version of GDI HALFTONE does
//    NOT support the CMY_INVERTED 8bpp bitmaask mode and it only supports CMY
//    mode.
//
//    If this macro return TRUE then the GDI HALFTONE DOES support the
//    CMY_INVERTED 8bpp bitmaask mode and the caller must using a translation
//    table to obtain final halftone surface bitmap 8bpp indices ink levels.
//
// 4. Behavior changes for GDI halftone that supports 8bpp CMY_INVERTED bitmask
//    mode, following is a list of changes of CMYMask mode passed to
//    the HT_Get8BPPMaskPalette()
//
//    CMYMask      CMY Mode Indices          CMY_INVERTED Mode Indices
//    =======  =========================   =============================
//         0         0: WHITE                    0: BLACK
//               1-254: Light->Dark Gray     1-254: Dark->Light Gray
//                 255: BLACK                  255: WHITE
//    -------------------------------------------------------------------
//         1         0: WHITE                 0-65: BLACK
//               1-123: 5^3 CMY color       66-188: 5^3 RGB color
//             124-255: BLACK              189-255: WHITE
//                                         127-128: Duplicate for XOR ROP
//                                                  (CMY Levels 2:2:2)
//    -------------------------------------------------------------------
//         2         0: WHITE                 0-20: BLACK
//               1-214: 6^3 CMY color       21-234: 6^3 RGB color
//             215-255: BLACK              235-255: WHITE
//    -------------------------------------------------------------------
//     3-255*        0: WHITE                    0: BLACK
//               1-254: CMY Color BitMask    1-254: Centered CxMxY BitMask*
//                 255: BLACK                  255: WHITE
//    ===================================================================
//
//     * For CMYMask mode 3-255, the valid combination must NOT have any
//       of Cyan, Magenta or Yellow ink level equal to 0.
//
//     * The reason for CMY_INVERTED mode that pading BLACK and WHITE entires
//       at both end and have all other color in the middle is to make sure
//       all 256 color palette entries are even distributed so that GDI ROPs
//       (raster operation) will work more correctly. This is because GDI ROPs
//       are based on the indices not color
//
//     * The CMY_INVERTED Mode has all non-black, non white indices centered
//       and even distributed within the total 256 palette indices.  For
//       example; if a CMY=333 levels then it has total 3x3x3=27 indices,
//       these 27 indices will be centered by packing 114 black indices at
//       begining and packing 114 white indices at end to ensure that ROP
//       will be correct rendered.
//
//       See following sample function of for how to generate these ink levels
//       and Windows 2000 CMY332 Index translation table
//
//
// 5. For CMYMask index mode 0 to 255, the caller can use following sample
//    function to genrate INKLEVELS translation table
//
//    The follwing structure and tables are examples of how to translate 8bpp
//    bitmask halftone bitmap indices to ink levels
//
//        typedef struct _INKLEVELS {
//             BYTE    Cyan;        // Cyan level from 0 to max
//             BYTE    Magenta;     // Magenta level from 0 to max
//             BYTE    Yellow;      // Yellow level from 0 to max
//             BYTE    CMY332Idx;   // Original windows 2000 CMY332 Index
//             } INKLEVELS, *PINKLEVELS;
//
//     To Compute a 8bpp translate table of INKLEVELS, following sample
//     function show how to genrate a INKLEVELS translate table for a valid
//     CMYMask range from 0 to 255.  It can be use to generate either Windows
//     2000 CMY Mode or new Post Windows 2000's CMY_INVERTED mode translation
//     table.  It also generate a windows 2000 CMY Mode CMY332Idx so caller
//     can map CMY_INVERTED new indices to old index for current existing
//     indices processing function.
//
//     Example Function that generate translate table for CMYMask 0 to 255,
//     the pInkLevels must pointed to a valid memory location of 256 INKLEVELS
//     entries, if return value is TRUE then it can be used to trnaslate 8bpp
//     indices to ink levels or mapp to the older CMY332 style indices.
//
//     
//     BOOL
//     GenerateInkLevels(
//         PINKLEVELS  pInkLevels,     // Pointer to 256 INKLEVELS table
//         BYTE        CMYMask,        // CMYMask mode
//         BOOL        CMYInverted     // TRUE for CMY_INVERTED mode
//         )
//     {
//         PINKLEVELS  pILDup;
//         PINKLEVELS  pILEnd;
//         INKLEVELS   InkLevels;
//         INT         Count;
//         INT         IdxInc;
//         INT         cC;
//         INT         cM;
//         INT         cY;
//         INT         xC;
//         INT         xM;
//         INT         xY;
//         INT         iC;
//         INT         iM;
//         INT         iY;
//         INT         mC;
//         INT         mM;
//
//
//         switch (CMYMask) {
//
//         case 0:
//
//             cC =
//             cM =
//             xC =
//             xM = 0;
//             cY =
//             xY = 255;
//             break;
//
//         case 1:
//         case 2:
//
//             cC =
//             cM =
//             cY =
//             xC =
//             xM =
//             xY = 3 + (INT)CMYMask;
//             break;
//
//         default:
//
//             cC = (INT)((CMYMask >> 5) & 0x07);
//             cM = (INT)((CMYMask >> 2) & 0x07);
//             cY = (INT)( CMYMask       & 0x03);
//             xC = 7;
//             xM = 7;
//             xY = 3;
//             break;
//         }
//
//         Count = (cC + 1) * (cM + 1) * (cY + 1);
//
//         if ((Count < 1) || (Count > 256)) {
//
//             return(FALSE);
//         }
//
//         InkLevels.Cyan      =
//         InkLevels.Magenta   =
//         InkLevels.Yellow    =
//         InkLevels.CMY332Idx = 0;
//         mC                  = (xM + 1) * (xY + 1);
//         mM                  = xY + 1;
//         pILDup              = NULL;
//
//         if (CMYInverted) {
//
//             //
//             // Move the pInkLevels to the first entry which center around
//             // 256 table entries, if we skip any then all entries skipped
//             // will be white (CMY levels all zeros).  Because this is
//             // CMY_INVERTED so entries start from back of the table and
//             // moving backward to the begining of the table
//             //
//
//             pILEnd      = pInkLevels - 1;
//             IdxInc      = ((256 - Count - (Count & 0x01)) / 2);
//             pInkLevels += 255;
//
//             while (IdxInc--) {
//
//                 *pInkLevels-- = InkLevels;
//             }
//
//             if (Count & 0x01) {
//
//                 //
//                 // If we have odd number of entries then we need to
//                 // duplicate the center one for correct XOR ROP to
//                 // operated correctly. The pILDup will always be index
//                 // 127, the duplication are indices 127, 128
//                 //
//
//                 pILDup = pInkLevels - (Count / 2) - 1;
//             }
//
//             //
//             // We running from end of table to the begining, because
//             // when in CMYInverted mode, the index 0 is black and index
//             // 255 is white.  Since we only generate 'Count' of index
//             // and place them at center, we will change xC, xM, xY max.
//             // index to same as cC, cM and cY.
//             //
//
//             IdxInc = -1;
//             xC     = cC;
//             xM     = cM;
//             xY     = cY;
//
//         } else {
//
//             IdxInc = 1;
//             pILEnd = pInkLevels + 256;
//         }
//
//         //
//         // At following, the composition of ink levels, index always
//         // from 0 CMY Ink levels (WHITE) to maximum ink levels (BLACK),
//         // the different with CMY_INVERTED mode is we compose it from
//         // index 255 to index 0 rather than from index 0 to 255
//         //
//
//         if (CMYMask) {
//
//             INT Idx332C;
//             INT Idx332M;
//
//             for (iC = 0, Idx332C = -mC; iC <= xC; iC++) {
//
//                 if (iC <= cC) {
//
//                     InkLevels.Cyan  = (BYTE)iC;
//                     Idx332C        += mC;
//                 }
//
//                 for (iM = 0, Idx332M = -mM; iM <= xM; iM++) {
//
//                     if (iM <= cM) {
//
//                         InkLevels.Magenta  = (BYTE)iM;
//                         Idx332M           += mM;
//                     }
//
//                     for (iY = 0; iY <= xY; iY++) {
//
//                         if (iY <= cY) {
//
//                             InkLevels.Yellow = (BYTE)iY;
//                         }
//
//                         InkLevels.CMY332Idx = (BYTE)(Idx332C + Idx332M) +
//                                               InkLevels.Yellow;
//                         *pInkLevels         = InkLevels;
//
//                         if ((pInkLevels += IdxInc) == pILDup) {
//
//                             *pInkLevels  = InkLevels;
//                             pInkLevels  += IdxInc;
//                         }
//                     }
//                 }
//             }
//
//             //
//             // Now if we need to pack black at other end of the
//             // translation table then do it here, Notice that InkLevels
//             // are at cC, cM and cY here and the CMY332Idx is at BLACK
//             //
//
//             while (pInkLevels != pILEnd) {
//
//                 *pInkLevels  = InkLevels;
//                 pInkLevels  += IdxInc;
//             }
//
//         } else {
//
//             //
//             // Gray Scale case
//             //
//
//             for (iC = 0; iC < 256; iC++, pInkLevels += IdxInc) {
//
//                 pInkLevels->Cyan      =
//                 pInkLevels->Magenta   =
//                 pInkLevels->Yellow    =
//                 pInkLevels->CMY332Idx = (BYTE)iC;
//             }
//         }
//
//         return(TRUE);
//     }
//
//
// 6. For CMYMask Mode 0 (Gray scale), the gray scale table just inverted
//    between CMY and CMY_INVERTED mode.
//
//     CMY mode:          0 to 255 gray scale from WHITE to BLACK increment,
//     CMY_INVERTED Mode: 0 to 255 gray scale from BLACK to WHITE increment.
//
//
// 7. For CMYMask Mode 1 and 2, the caller should use a translation table for
//    translate indices to CMY ink levels.
//
// 8. For CMYMode mode 3 to 255,
//
//    if in CMY Mode (Windows 2000) is specified then The final CMY ink levels
//    indices byte has following meanings
//
//         Bit     7 6 5 4 3 2 1 0
//                 |   | |   | | |
//                 +---+ +---+ +=+
//                   |     |    |
//                   |     |    +-- Yellow 0-3 (Max. 4 levels)
//                   |     |
//                   |     +-- Magenta 0-7 (Max. 8 levels)
//                   |
//                   +-- Cyan 0-7 (Max. 8 levels)
//
//
//     If a CMY_INVERTED mode is specified then caller must use a translation
//     table to convert a index to the ink levels, to generate this table,
//     please see above #5 description.
//
//

--*/

{
    LPPALETTEENTRY  pPalOrg;
    FD6             RGBGamma[3];
    FD6             Tmp;
    FD6             Y;
    INT             PalInc;
    UINT            PalStart;
    UINT            PalIdx;
    UINT            cC;
    UINT            cM;
    UINT            cY;
    UINT            iC;
    UINT            iM;
    UINT            iY;
    UINT            MaxPal;
    UINT            IdxPalDup;
    BYTE            bR;
    BYTE            bG;
    BYTE            bB;


    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_Get8BPPMaskPalette(%p): UseMask=%ld, CMYMask=%02lx, Gamma=%05ld:%05ld:%05ld"
                    ARGPTR(pPaletteEntry)
                    ARGDW((Use8BPPMaskPal) ? 1 : 0)
                    ARGDW(CMYMask)
                    ARGDW(RedGamma) ARGDW(GreenGamma) ARGDW(BlueGamma)));

    if (!Use8BPPMaskPal) {

        return(HT_Get8BPPFormatPalette(pPaletteEntry,
                                       RedGamma,
                                       GreenGamma,
                                       BlueGamma));
    }

    //
    // Checking the CMYMask first to make sure caller passed valid CMYMask
    //

    switch (CMYMask) {

    case 1:

        cC       =
        cM       =
        cY       = 4;
        MaxPal   = 125;
        break;

    case 2:

        cC     =
        cM     =
        cY     = 5;
        MaxPal = 216;
        break;

    default:

        MaxPal = 0;
        cC     = (UINT)((CMYMask >> 5) & 0x07);
        cM     = (UINT)((CMYMask >> 2) & 0x07);
        cY     = (UINT)((CMYMask >> 0) & 0x03);

        //
        // If this is not zero, but one of the cC, cM, cY is zero then return
        // zero to indicate error
        //

        if ((CMYMask != 0) && ((!cC) || (!cM) || (!cY))) {

            ASSERTMSG("One of Ink Levels is ZERO", (cC) && (cM) && (cY));

            return(0);
        }

        break;
    }

    //
    // Initialize All internal data first
    //

    if (pPalOrg = pPaletteEntry) {

        PalStart  = 0;
        PalInc    = 1;
        IdxPalDup = 0x200;

        //
        // Since we will always compose the palette using CMY method, the only
        // thing we need to do for the RGB mode is write the palette from index
        // 255 to 0, the backward writing provied that caller can just invert
        // its 8bpp indices to get the CMY ink levels definition
        //

        if (*((LPDWORD)pPaletteEntry) == HTBITMASKPALRGB_DW) {

            //
            // RGB Mode, go to end of the palette end move backward, the reason
            // for the 5:5:5 and 6:6:6 that pas white and black at both end is
            // to make sure the ROP work more correctly for the GDI.
            //

            pPaletteEntry += 255;
            PalInc         = -1;

            //
            // 08-Sep-2000 Fri 14:22:02 updated  -by-  Daniel Chou (danielc)
            //  For new CMY_INVERTED mode, we want to make sure we pack all
            //  possible ink entries in the middle of 256 indices and pack
            //  black/white at end.  If the total ink color compositions are
            //  an odd number then we duplicate the middle one.  This will
            //  ensure that the ROP will work correctly on color entries
            //

            if (CMYMask) {

                MaxPal    = (cC + 1) * (cM + 1) * (cY + 1);
                PalStart  = (256 - MaxPal) >> 1;

                if (MaxPal & 0x01) {

                    IdxPalDup = (MaxPal >> 1) + PalStart;
                }
            }
        }

        //
        // Clear all palette entries to zero first
        //

        ZeroMemory(pPalOrg, sizeof(PALETTEENTRY) * 256);

        RGBGamma[0] = UDECI4ToFD6(RedGamma);
        RGBGamma[1] = UDECI4ToFD6(GreenGamma);
        RGBGamma[2] = UDECI4ToFD6(BlueGamma);
        PalIdx      = 0;

        DBGP_IF(DBGP_GAMMA_PAL,
                DBGP("***** HT_Get8BPPMaskPalette: %s:%s:%s, CMY=%u:%u:%u=%3ld (%s, %ld,%ld) *****"
                     ARGFD6(RGBGamma[0], 1, 4)
                     ARGFD6(RGBGamma[1], 1, 4)
                     ARGFD6(RGBGamma[2], 1, 4)
                     ARGDW(cC) ARGDW(cM) ARGDW(cY) ARGDW(MaxPal)
                     ARGPTR((PalInc==-1) ? "RGB" : "CMY")
                     ARGDW(PalStart) ARGDW(IdxPalDup)));

        if (MaxPal) {

            //
            // For the begining filler, we will fill with WHITE, because
            // we are composing use CMY, when CMY is 0 it means white
            //

            for (;
                 PalIdx < PalStart;
                 PalIdx++, pPaletteEntry += PalInc) {

                pPaletteEntry->peRed   =
                pPaletteEntry->peGreen =
                pPaletteEntry->peBlue  = 0xFF;
            }

            for (iC = 0; iC <= cC; iC++) {

                CMY_8BPP(bR, iC, cC, Tmp);

                for (iM = 0; iM <= cM; iM++) {

                    CMY_8BPP(bG, iM, cM, Tmp)

                    for (iY = 0;
                         iY <= cY;
                         iY++, PalIdx++, pPaletteEntry += PalInc) {

                        CMY_8BPP(bB, iY, cY, Tmp);

                        pPaletteEntry->peRed   = bR;
                        pPaletteEntry->peGreen = bG;
                        pPaletteEntry->peBlue  = bB;

                        DBGP_IF(DBGP_GAMMA_PAL,
                                DBGP("[%3ld] %3u - %3u:%3u:%3u"
                                 ARGU(pPaletteEntry - pPalOrg)
                                 ARGU(PalIdx)
                                 ARGU(pPaletteEntry->peRed  )
                                 ARGU(pPaletteEntry->peGreen)
                                 ARGU(pPaletteEntry->peBlue )));

                        if (PalIdx == IdxPalDup) {

                            ++PalIdx;
                            pPaletteEntry          += PalInc;
                            pPaletteEntry->peRed    = bR;
                            pPaletteEntry->peGreen  = bG;
                            pPaletteEntry->peBlue   = bB;

                            DBGP_IF(DBGP_GAMMA_PAL,
                                    DBGP("[%3ld] %3u - %3u:%3u:%3u --- DUP"
                                     ARGU(pPaletteEntry - pPalOrg)
                                     ARGU(PalIdx)
                                     ARGU(pPaletteEntry->peRed  )
                                     ARGU(pPaletteEntry->peGreen)
                                     ARGU(pPaletteEntry->peBlue )));
                        }
                    }
                }
            }

            //
            // For ending fillers (Current PalIdx to 255), we will fill with
            // BLACK, because we are composing use CMY, when CMY is at MAX it
            // means BLACK, Since we clear all pPalOrg to ZERO at begining of
            // this function, so we are done and do not need to do anything.
            //

        } else if ((cC < 1) || (cM < 1) || (cY < 1)) {

            for (Y = 255;
                 PalIdx <= 255;
                 PalIdx++, Y--, pPaletteEntry += PalInc) {

                pPaletteEntry->peRed   =
                pPaletteEntry->peGreen =
                pPaletteEntry->peBlue  = (BYTE)Y;

                DBGP_IF(DBGP_GAMMA_PAL,
                        DBGP("[%3ld] %3u - %3u:%3u:%3u"
                         ARGU(pPaletteEntry - pPalOrg)
                         ARGU(PalIdx)
                         ARGU(pPaletteEntry->peRed  )
                         ARGU(pPaletteEntry->peGreen)
                         ARGU(pPaletteEntry->peBlue )));
            }

        } else {

            for (iC = 0; iC <= 7; iC++) {

                CMY_8BPP(bR, iC, cC, Tmp);

                for (iM = 0; iM <= 7; iM++) {

                    CMY_8BPP(bG, iM, cM, Tmp)

                    for (iY = 0;
                         iY <= 3;
                         iY++, PalIdx++, pPaletteEntry += PalInc) {

                        CMY_8BPP(bB, iY, cY, Tmp);

                        pPaletteEntry->peRed   = bR;
                        pPaletteEntry->peGreen = bG;
                        pPaletteEntry->peBlue  = bB;

                        DBGP_IF(DBGP_GAMMA_PAL,
                                DBGP("[%3ld] %3u - %3u:%3u:%3u"
                                 ARGU(pPaletteEntry - pPalOrg)
                                 ARGU(PalIdx)
                                 ARGU(pPaletteEntry->peRed  )
                                 ARGU(pPaletteEntry->peGreen)
                                 ARGU(pPaletteEntry->peBlue )));
                    }
                }
            }
        }
    }

    //
    // Always return full 256 palette entry for halftone
    //

    return((LONG)256);
}




LONG
APIENTRY
HT_LOADDS
HT_CreateStandardMonoPattern(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PSTDMONOPATTERN     pStdMonoPattern
    )

/*++

Routine Description:

    This function create standard predefined monochrome pattern for the device.

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

    pStdMonoPattern     - Pointer to the STDMONOPATTERN data structure, the
                          pPattern in this data structure is optional.

Return Value:

    if the return value is negative or zero then an error was encountered,
    possible error codes are

        HTERR_INVALID_DHI_POINTER           - Invalid pDevideHalftoneInfo is
                                              passed.

        HTERR_INVALID_STDMONOPAT_INDEX      - The PatternIndex field in
                                              STDMONOPATTERN data structure is
                                              invalid.
    otherwise

        If pPattern field in STDMONOPATTERN data structure Surface is NULL, it
        return the bytes count which need to stored the pattern, otherwise it
        return the size in byte copied to the pattern buffer.

Author:

    05-Feb-1991 Tue 14:28:23 created  -by-  Daniel Chou (danielc)


Revision History:

    05-Jun-1991 Wed 10:22:41 updated  -by-  Daniel Chou (danielc)

        Fixed the bugs when the pStdMonoPattern is NULL, it was used without
        checking it.


--*/

{

    PDEVICECOLORINFO    pDCI;
    CHBINFO             CHBInfo;
    CTSTD_UNION         CTSTDUnion;
    LONG                Result;
    WORD                PatCX;
    WORD                PatCY;
    BYTE                PatIndex;


    if ((PatIndex = pStdMonoPattern->PatternIndex) > HT_SMP_MAX_INDEX) {

        HTAPI_RET(HTAPI_IDX_CREATE_SMP, HTERR_INVALID_STDMONOPAT_INDEX);
    }

    CTSTDUnion.b.cbPrim    =
    CTSTDUnion.b.SrcOrder  =
    CTSTDUnion.b.BMFDest   =
    CTSTDUnion.b.DestOrder = 0;

    if (!(pDCI = pDCIAdjClr(pDeviceHalftoneInfo,
                            NULL,
                            NULL,
                            0,
                            0,
                            CTSTDUnion.b,
                            &Result))) {

        HTAPI_RET(HTAPI_IDX_CREATE_SMP, Result);
    }

    if (PatIndex >= HT_SMP_PERCENT_SCREEN_START) {

        CHBInfo.DestScanLineAlignBytes = pStdMonoPattern->ScanLineAlignBytes;
        PatCX = pStdMonoPattern->cxPels = pDCI->HTCell.cxReal;
        PatCY = pStdMonoPattern->cyPels = pDCI->HTCell.Height;

        pStdMonoPattern->BytesPerScanLine = (WORD)
                ComputeBytesPerScanLine((UINT)BMF_1BPP,
                                        (UINT)CHBInfo.DestScanLineAlignBytes,
                                        (DWORD)PatCX);
        CHBInfo.Flags = CHBF_BW_ONLY;

        if (pStdMonoPattern->pPattern) {

            BYTE        rgb[3];
            COLORTRIAD  ColorTriad;

            rgb[0] =
            rgb[1] =
            rgb[0] = (BYTE)(HT_SMP_MAX_INDEX - PatIndex);

            ColorTriad.Type              = (BYTE)COLOR_TYPE_RGB;
            ColorTriad.BytesPerPrimary   = (BYTE)sizeof(BYTE);
            ColorTriad.BytesPerEntry     = (BYTE)(sizeof(BYTE) * 3);
            ColorTriad.PrimaryOrder      = PRIMARY_ORDER_RGB;
            ColorTriad.PrimaryValueMax   = (FD6)100;
            ColorTriad.ColorTableEntries = 1;
            ColorTriad.pColorTable       = (LPVOID)rgb;

            if (pStdMonoPattern->Flags & SMP_0_IS_BLACK) {

                CHBInfo.Flags |= CHBF_USE_ADDITIVE_PRIMS;
            }

            if (!(pStdMonoPattern->Flags & SMP_TOPDOWN)) {

                CHBInfo.Flags |= CHBF_BOTTOMUP_BRUSH;
            }

            CHBInfo.DestSurfaceFormat = BMF_1BPP;
            CHBInfo.DestPrimaryOrder  = PRIMARY_ORDER_123;

            Result = HT_CreateHalftoneBrush(pDeviceHalftoneInfo,
                                            NULL,
                                            &ColorTriad,
                                            CHBInfo,
                                            (LPVOID)pStdMonoPattern->pPattern);

        } else {

            Result = (LONG)pStdMonoPattern->BytesPerScanLine *
                     (LONG)PatCY;
        }

    } else {

        Result = GetCachedSMP(pDCI, pStdMonoPattern);
    }

    RELEASE_HTMUTEX(pDCI->HTMutex);

DBGP_IF(DBGP_SHOWPAT,

    LPBYTE  pCurPat;
    LPBYTE  pPatScan;
    BYTE    Buf1[80];
    BYTE    Buf2[80];
    BYTE    Buf3[80];
    BYTE    Digit1;
    BYTE    Digit2;
    WORD    Index;
    WORD    XInc;
    WORD    YInc;
    BYTE    Mask;
    BOOL    Swap;


    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_CreateStandardMonoPattern(%d) = %ld"
                            ARGI(PatIndex - HT_SMP_PERCENT_SCREEN_START)
                            ARGDW(Result)));

    if ((Result > 0) && (pPatScan = pStdMonoPattern->pPattern)) {

        Swap = (BOOL)(pStdMonoPattern->Flags & SMP_0_IS_BLACK);

        FillMemory(Buf1, 80, ' ');
        FillMemory(Buf2, 80, ' ');
        Digit1 = 0;
        Digit2 = 0;
        Index = 4;
        XInc = pStdMonoPattern->cxPels;

        while ((XInc--) && (Index < 79)) {

            if (!Digit2) {

                Buf1[Index] = (BYTE)(Digit1 + '0');

                if (++Digit1 == 10) {

                    Digit1 = 0;
                }
            }

            Buf2[Index] = (BYTE)(Digit2 + '0');

            if (++Digit2 == 10) {

                Digit2 = 0;
            }

            ++Index;
        }

        Buf1[Index] = Buf2[Index] = 0;

        DBGP("%s" ARG(Buf1));
        DBGP("%s\r\n" ARG(Buf2));

        for (YInc = 0; YInc < pStdMonoPattern->cyPels; YInc++) {

            Index = (WORD)sprintf(Buf3, "%3u ", YInc);

            pCurPat = pPatScan;

            for (XInc = 0, Mask = 0x80;
                 XInc < pStdMonoPattern->cxPels;
                 XInc++) {

                if (Swap) {

                    Buf3[Index] = (BYTE)((*pCurPat & Mask) ? '' : '');

                } else {

                    Buf3[Index] = (BYTE)((*pCurPat & Mask) ? '' : '');
                }

                if (!(Mask >>= 1)) {

                    Mask = 0x80;
                    ++pCurPat;
                }

                if (++Index > 75) {

                    Index = 75;
                }
            }

            sprintf(&Buf3[Index], " %-3u", YInc);
            DBGP("%s" ARG(Buf3));

            pPatScan += pStdMonoPattern->BytesPerScanLine;
        }

        DBGP("\r\n%s" ARG(Buf2));
        DBGP("%s" ARG(Buf1));
    }
)

    HTAPI_RET(HTAPI_IDX_CREATE_SMP, Result);
}




LONG
HTENTRY
CheckABInfo(
    PBITBLTPARAMS   pBBP,
    UINT            SrcSurfFormat,
    UINT            DstSurfFormat,
    LPWORD          pForceFlags,
    PLONG           pcOutMax
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    04-Mar-1999 Thu 18:41:06 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PABINFO pABInfo;
    LONG    cOutMax;
    WORD    ForceFlags;


    if (!(pABInfo = pBBP->pABInfo)) {

        return(HTERR_INVALID_ABINFO);
    }

    switch (DstSurfFormat) {

    case BMF_1BPP:

        cOutMax = 2;
        break;

    case BMF_4BPP:
    case BMF_4BPP_VGA16:

        cOutMax = 16;
        break;

    case BMF_8BPP:
    case BMF_8BPP_VGA256:

        cOutMax = 256;
        break;

    default:

        cOutMax = 0;
        break;
    }

    if (cOutMax) {

        if ((pABInfo->pDstPal == NULL) ||
            (pABInfo->cDstPal > cOutMax)) {

            return(HTERR_INVALID_ABINFO);
        }
    }

    *pForceFlags |= ADJ_FORCE_ALPHA_BLEND;


    if (pABInfo->Flags & ABIF_USE_CONST_ALPHA_VALUE) {

        switch (pABInfo->ConstAlphaValue) {

        case 0:

            //
            // We do not need to do anything
            //

            return(0);

        case 0xFF:

            *pForceFlags &= ~ADJ_FORCE_ALPHA_BLEND;
            cOutMax       = 0;
            break;

        default:

            *pForceFlags |= ADJ_FORCE_CONST_ALPHA;
            break;
        }

    } else if (SrcSurfFormat != BMF_32BPP) {

         return(HTERR_INVALID_SRC_FORMAT);

    } else {

        if (pABInfo->Flags & ABIF_SRC_ALPHA_IS_PREMUL) {

            *pForceFlags |= ADJ_FORCE_AB_PREMUL_SRC;
        }

        if (pABInfo->Flags & ABIF_BLEND_DEST_ALPHA) {

            if (DstSurfFormat != BMF_32BPP) {

                return(HTERR_INVALID_DEST_FORMAT);
            }

            *pForceFlags |= ADJ_FORCE_AB_DEST;
        }
    }

    *pcOutMax = cOutMax;

    return(1);
}




LONG
APIENTRY
HT_LOADDS
HT_HalftoneBitmap(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PHTSURFACEINFO      pSourceHTSurfaceInfo,
    PHTSURFACEINFO      pSourceMaskHTSurfaceInfo,
    PHTSURFACEINFO      pDestinationHTSurfaceInfo,
    PBITBLTPARAMS       pBitbltParams
    )

/*++

Routine Description:

    This function halftone the source bitmap and output to the destination
    surface depends on the surface type and bitblt parameters

    The source surface type must one of the following:

        1-bit per pel. (BMF_1BPP)
        4-bit per pel. (BMF_4BPP)
        8-bit per pel. (BMF_8BPP)
       16-bit per pel. (BMF_16BPP)
       24-bit per pel. (BMF_24BPP)
       32-bit per pel. (BMF_32BPP)

    The destination surface type must one of the following:

        1-bit per pel.                  (BMF_1BPP)
        4-bit per pel.                  (BMF_4BPP)
        3 plane and 1 bit per pel.      (BMF_1BPP_3PLANES)

Arguments:

    pDeviceHalftoneInfo         - pointer to the DEVICEHALFTONEINFO data
                                  structure

    pHTColorAdjustment          - Pointer to the HTCOLORADJUSTMENT data
                                  structure to specified the input/output color
                                  adjustment/transform, if this pointer is NULL
                                  then a default color adjustments is applied.

    pSourceHTSurfaceInfo        - pointer to the source surface infomation.

    pSourceMaskHTSurfaceInfo    - pointer to the source mask surface infomation,
                                  if this pointer is NULL then there is no
                                  source mask for the halftoning.

    pDestinationHTSurfaceInfo   - pointer to the destination surface infomation.

    pBitbltParams               - pointer to the BITBLTPARAMS data structure to
                                  specified the source, destination, source
                                  mask and clipping rectangle information, the
                                  content of this data structure will not be
                                  modified by this function.


Return Value:

    if the return value is less than zero then an error has occurred,
    the error code is one of the following #define which start with HTERR_.

    HTERR_INSUFFICIENT_MEMORY           - not enough memory to do the halftone
                                          process.

    HTERR_COLORTABLE_TOO_BIG            - can not create the color table to map
                                          the colors to the dyes' densities.

    HTERR_QUERY_SRC_BITMAP_FAILED       - callback function return FALSE when
                                          query the source bitmap pointer.

    HTERR_QUERY_DEST_BITMAP_FAILED      - callback function return FALSE when
                                          query the destination bitmap pointers.

    HTERR_INVALID_SRC_FORMAT            - Invalid source surface format.

    HTERR_INVALID_DEST_FORMAT           - Invalid destination surface type,
                                          this function only recongnized 1/4/
                                          bits per pel source surfaces or 1 bit
                                          per pel 3 planes.

    HTERR_INVALID_DHI_POINTER           - Invalid pDevideHalftoneInfo is passed.

    HTERR_SRC_MASK_BITS_TOO_SMALL       - If the source mask bitmap is too
                                          small to cover the visible region of
                                          the source bitmap.

    HTERR_INVALID_MAX_QUERYLINES        - One or more of Source/Destination
                                          SourceMasks' maximum query scan line
                                          is < 0

    HTERR_INTERNAL_ERRORS_START         - any other negative numbers indicate
                                          a halftone internal failue.

   else                                - the total destination scan lines
                                          halftoned.


Author:

    05-Feb-1991 Tue 15:23:07 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEVICECOLORINFO    pDCI;
    PHALFTONERENDER     pHR;
    PAAHEADER           pAAHdr;
    PDEVCLRADJ          pDevClrAdj;
    PRGB4B              pClrTable;
    PABINFO             pABInfo;
    LONG                Result;
    WORD                ForceFlags;
    WORD                BBPFlags;
    CTSTD_UNION         CTSTDUnion;
    LONG                cInPal;
    LONG                cInMax;
    LONG                cOutMax;
    BYTE                SrcSurfFormat;
    BYTE                DstSurfFormat;
    CONST static BYTE   MaxPal_0148_LS[4] = { 0, 1, 4, 8 };


    DBG_TIMER_RESET;

    SrcSurfFormat = pSourceHTSurfaceInfo->SurfaceFormat;
    DstSurfFormat = pDestinationHTSurfaceInfo->SurfaceFormat;
    BBPFlags      = pBitbltParams->Flags;
    ForceFlags    = 0;

    cInPal  =
    cInMax  =
    cOutMax = 0;

    switch (SrcSurfFormat) {

    case BMF_1BPP:
    case BMF_4BPP:
    case BMF_8BPP:

        cInMax = (UINT)0x01 << MaxPal_0148_LS[SrcSurfFormat];

        if (pSourceHTSurfaceInfo->pColorTriad) {

            cInPal = (LONG)pSourceHTSurfaceInfo->pColorTriad->ColorTableEntries;
        }

        if (!cInPal) {

            HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, HTERR_INVALID_COLOR_TABLE);
        }

    default:

        break;
    }

    if ((BBPFlags & BBPF_DO_ALPHA_BLEND)    &&
        ((Result = CheckABInfo(pBitbltParams,
                               SrcSurfFormat,
                               DstSurfFormat,
                               &ForceFlags,
                               &cOutMax)) <= 0)) {

        HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, Result);
    }

    DBGP_IF(DBGP_SRCBMP,
            DBGP("SrcFmt=%ld, cInPal=%ld (%ld), DstFmt=%ld, cOutMax=%ld"
                ARGDW(SrcSurfFormat) ARGDW(cInMax) ARGDW(cInPal)
                ARGDW(DstSurfFormat) ARGDW(cOutMax)));

    CTSTDUnion.b.cbPrim    = 0;
    CTSTDUnion.b.SrcOrder  = PRIMARY_ORDER_BGR;
    CTSTDUnion.b.BMFDest   = (BYTE)DstSurfFormat;
    CTSTDUnion.b.DestOrder = (BYTE)pBitbltParams->DestPrimaryOrder;

    if (BBPFlags & BBPF_USE_ADDITIVE_PRIMS) {

        ForceFlags |= ADJ_FORCE_ADDITIVE_PRIMS;
    }

    if (BBPFlags & BBPF_NEGATIVE_DEST) {

        ForceFlags |= ADJ_FORCE_NEGATIVE;
    }

    if ((BBPFlags & BBPF_BW_ONLY) ||
        (CTSTDUnion.b.BMFDest == BMF_1BPP)) {

        ForceFlags |= ADJ_FORCE_MONO;
    }

    if (BBPFlags & BBPF_ICM_ON) {

        ForceFlags |= ADJ_FORCE_ICM;
    }

    //
    // Find out if we will call anti-aliasing codes
    //

    ASSERTMSG("Source X is not well ordered",
                    pBitbltParams->rclSrc.right >= pBitbltParams->rclSrc.left);
    ASSERTMSG("Source Y is not well ordered",
                    pBitbltParams->rclSrc.bottom >= pBitbltParams->rclSrc.top);

    if (BBPFlags & BBPF_NO_ANTIALIASING) {

        ForceFlags |= ADJ_FORCE_NO_EXP_AA;
    }

    //
    // Now Compute the Device Color Adjusment data
    //

    if (!(pDCI = pDCIAdjClr(pDeviceHalftoneInfo,
                            pHTColorAdjustment,
                            &pDevClrAdj,
                            sizeof(HALFTONERENDER) + sizeof(AAHEADER) +
                                        ((cInMax + cOutMax) * sizeof(RGB4B)),
                            ForceFlags,
                            CTSTDUnion.b,
                            &Result))) {

        HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, Result);
    }

    pHR = (PHALFTONERENDER)(pDevClrAdj + 1);

    //
    // We will mask out the more flags, since this flag is currently used
    // internally.
    //

    pHR->pDeviceColorInfo = pDCI;
    pHR->pDevClrAdj       = pDevClrAdj;
    pHR->pBitbltParams    = pBitbltParams;
    pHR->pSrcSI           = pSourceHTSurfaceInfo;
    pHR->pSrcMaskSI       = pSourceMaskHTSurfaceInfo;
    pHR->pDestSI          = pDestinationHTSurfaceInfo;
    pAAHdr                = (PAAHEADER)(pHR->pAAHdr = (LPVOID)(pHR + 1));
    pClrTable             = (PRGB4B)(pAAHdr + 1);

    if (cInMax) {

        pAAHdr->SrcSurfInfo.cClrTable  = (WORD)cInPal;
        pAAHdr->SrcSurfInfo.pClrTable  = (PRGB4B)pClrTable;
        pClrTable                     += cInMax;
    }

    if (ForceFlags & ADJ_FORCE_ALPHA_BLEND) {

        if ((!(pDCI->pAlphaBlendBGR))   &&
            (!(pDCI->pAlphaBlendBGR = (LPBYTE)HTAllocMem(pDCI,
                                                         HTMEM_AlphaBlendBGR,
                                                         LPTR,
                                                         AB_DCI_SIZE)))) {

            RELEASE_HTMUTEX(pDCI->HTMutex);

            HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, HTERR_INSUFFICIENT_MEMORY);
        }

        if (ForceFlags & ADJ_FORCE_CONST_ALPHA) {

            pDCI->PrevConstAlpha = pDCI->CurConstAlpha;
            pDCI->CurConstAlpha  = pBitbltParams->pABInfo->ConstAlphaValue;
        }

        if (cOutMax) {

            pAAHdr->DstSurfInfo.pClrTable = (PRGB4B)pClrTable;
            pAAHdr->DstSurfInfo.cClrTable =
                                        (WORD)pBitbltParams->pABInfo->cDstPal;
        }
    }

    pAAHdr->SrcSurfInfo.AABFData.Format = (BYTE)SrcSurfFormat;
    pAAHdr->DstSurfInfo.AABFData.Format = (BYTE)DstSurfFormat;

    if (BBPFlags & BBPF_TILE_SRC) {

        //
        // Remove SrcMask if TILE_SRC is used
        //

        pHR->pSrcMaskSI = NULL;
    }

    //-----------------------------------------------------------------------
    // The semaphore pDCI->HTMutex will be released by AAHalftoneBitmap
    //-----------------------------------------------------------------------

    Result = AAHalftoneBitmap(pHR);

    if (HTFreeMem(pDevClrAdj)) {

        ASSERTMSG("HTFreeMem(pDevClrAdj) Failed", FALSE);
    }

    DBGP_IF(DBGP_HTAPI,
            DBGP("HT_HalftoneBitmap(%ld/%6ld): Src[%ld]=(%4ld,%4ld)-(%4ld,%4ld), Dst[%ld]=(%4ld,%4ld)-(%4ld,%4ld) [0x%04lx]"
                    ARGDW(pDCI->cbMemTot) ARGDW(pDCI->cbMemMax)
                    ARGDW(SrcSurfFormat)
                    ARGDW(pBitbltParams->rclSrc.left)
                    ARGDW(pBitbltParams->rclSrc.top)
                    ARGDW(pBitbltParams->rclSrc.right)
                    ARGDW(pBitbltParams->rclSrc.bottom)
                    ARGDW(DstSurfFormat)
                    ARGDW(pBitbltParams->rclDest.left)
                    ARGDW(pBitbltParams->rclDest.top)
                    ARGDW(pBitbltParams->rclDest.right)
                    ARGDW(pBitbltParams->rclDest.bottom)
                    ARGDW(BBPFlags)));

    DBGP_IF(DBGP_MEMLINK,

           DumpMemLink(NULL, 0);
           DumpMemLink((LPVOID)pDCI, 0);
    )

    DBGP_IF(DBGP_TIMER,

        UINT    i;

        DBG_TIMER_END(TIMER_TOT);

        DbgTimer[TIMER_LAST].Tot = DbgTimer[TIMER_TOT].Tot;

        for (i = 1; i < TIMER_LAST; i++) {

            DbgTimer[TIMER_LAST].Tot -= DbgTimer[i].Tot;
        }

        DBGP("HTBlt(%s): Setup=%s, AA=%s, In=%s, Out=%s, Mask=%s, Fmt=%ld->%ld [%02lx]"
            ARGTIME(TIMER_TOT)
            ARGTIME(TIMER_SETUP)
            ARGTIME(TIMER_LAST)
            ARGTIME(TIMER_INPUT)
            ARGTIME(TIMER_OUTPUT)
            ARGTIME(TIMER_MASK)
            ARGDW(pSourceHTSurfaceInfo->SurfaceFormat)
            ARGDW(pDevClrAdj->DMI.CTSTDInfo.BMFDest)
            ARGDW(pDevClrAdj->DMI.Flags));
    )

    HTAPI_RET(HTAPI_IDX_HALFTONE_BMP, Result);
}




LONG
APIENTRY
HT_LOADDS
HT_GammaCorrectPalette(
    LPPALETTEENTRY  pPaletteEntry,
    LONG            cPalette,
    UDECI4          RedGamma,
    UDECI4          GreenGamma,
    UDECI4          BlueGamma
    )

/*++

Routine Description:

    This functions retrieve a halftone's VGA256 color table definitions

Arguments:

    pPaletteEntry   - Pointer to PALETTEENTRY data structure array,

    cPalette        - Total palette passed by the pPaletteEntry

    RedGamma        - The monitor's red gamma value in UDECI4 format

    GreenGamma      - The monitor's green gamma value in UDECI4 format

    BlueGamma       - The monitor's blue gamma value in UDECI4 format


Return Value:

    if pPaletteEntry is NULL then it return the PALETTEENTRY count needed for
    VGA256 halftone process, if it is not NULL then it return the total
    paletteEntry updated.

    If the pPaletteEntry is not NULL then halftone.dll assume it has enough
    space for the size returned when this pointer is NULL.

Author:

    14-Apr-1992 Tue 13:03:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FD6     RGBGamma[3];
    LONG    cPal;
    FD6     Yr;
    FD6     Yg;
    FD6     Yb;
    BYTE    r;
    BYTE    g;
    BYTE    b;

    //
    // Initialize All internal data first
    //

    if ((cPal = cPalette) && (pPaletteEntry)) {

        RGBGamma[0] = UDECI4ToFD6(RedGamma);
        RGBGamma[1] = UDECI4ToFD6(GreenGamma);
        RGBGamma[2] = UDECI4ToFD6(BlueGamma);

        DBGP_IF(DBGP_GAMMA_PAL,
                DBGP("***** HT_GammaCorrectPalette: %s:%s:%s *****"
                     ARGFD6(RGBGamma[0], 1, 4)
                     ARGFD6(RGBGamma[1], 1, 4)
                     ARGFD6(RGBGamma[2], 1, 4)));

        while (cPalette--) {

            Yr  = (FD6)DivFD6(r = pPaletteEntry->peRed,   255);
            Yg  = (FD6)DivFD6(g = pPaletteEntry->peGreen, 255);
            Yb  = (FD6)DivFD6(b = pPaletteEntry->peBlue,  255);

            pPaletteEntry->peRed   = RGB_8BPP(Yr);
            pPaletteEntry->peGreen = RGB_8BPP(Yg);
            pPaletteEntry->peBlue  = RGB_8BPP(Yb);
            pPaletteEntry->peFlags = 0;

            DBGP_IF(DBGP_GAMMA_PAL,
                    DBGP("%3u - %3u:%3u:%3u --> %3u:%3u:%3u"
                         ARGU(cPalette)
                         ARGU(r) ARGU(g) ARGU(b)
                         ARGU(pPaletteEntry->peRed  )
                         ARGU(pPaletteEntry->peGreen)
                         ARGU(pPaletteEntry->peBlue )));

            ++pPaletteEntry;
        }
    }

    return((LONG)cPal);
}





LONG
APIENTRY
HT_LOADDS
HT_ConvertColorTable(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PCOLORTRIAD         pColorTriad,
    DWORD               Flags
    )


/*++

Routine Description:

    This function modified input color table entries base on the
    pHTColorAdjustment data structure specification.

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

    pHTColorAdjustment  - Pointer to the HTCOLORADJUSTMENT data structure to
                          specified the input/output color adjustment/transform,
                          if this pointer is NULL then a default color
                          adjustments is applied.

    pColorTriad         - Specified the source color table format and location.

    Flags               - One of the following may be specified

                            CCTF_BW_ONLY

                                Create grayscale of the color table.

                            CCTF_NEGATIVE

                                Create negative version of the original color
                                table.

Return Value:

    if the return value is negative or zero then an error was encountered,
    possible error codes are

        HTERR_INVALID_COLOR_TABLE   - The ColorTableEntries field is = 0 or
                                      CCTInfo.SizePerColorTableEntry is not
                                      between 3 to 255, or if the
                                      CCTInfo.FirstColorIndex in CCTInfo is
                                      not in the range of 0 to
                                      (SizePerColorTableEntry - 3).

        HTERR_INVALID_DHI_POINTER   - Invalid pDevideHalftoneInfo is passed.

    otherwise

        Total entries of the converted color table is returned.


Author:

    14-Aug-1991 Wed 12:43:29 updated  -by-  Daniel Chou (danielc)


Revision History:

    16-Feb-1993 Tue 00:10:56 updated  -by-  Daniel Chou (danielc)
        Fixes bug #10448 which create all black densitities brushes, this
        was caused by not initialized ColorTriad.PrimaryOrder.


--*/

{

    PDEVICECOLORINFO    pDCI;
    PDEVCLRADJ          pDevClrAdj;
    CTSTD_UNION         CTSTDUnion;
    WORD                ForceFlags;
    LONG                Result;

    return(HTERR_COLORTABLE_TOO_BIG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htgetbmp.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htgetbmp.c


Abstract:

    This module provided a set of functions which read the 1/4/8/16/24/32
    bits per pel bitmap and composed it


Author:
    08-Jan-1999 Fri 18:14:42 updated  -by-  Daniel Chou (danielc)
        Re-write

    23-Apr-1992 Thu 21:14:55 updated  -by-  Daniel Chou (danielc)
        1. Delete InFuncInfo.StretchSize, and using Prim1/Prim2 to determined
           when we will stop the source stretch,

        2. Change 'ColorInfoIncrement' from 'CHAR' to 'SHORT', this will make
           sure the default MIPS's 'unsigned char' will not affect our
           signed operation.

    28-Mar-1992 Sat 20:54:58 updated  -by-  Daniel Chou (danielc)
        Update it for VGA intensity (16 colors mode), this make all the
        codes update to 4 primaries internal.

    05-Apr-1991 Fri 15:55:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/

#define DBGP_VARNAME        dbgpHTGetBmp

#include "htp.h"
#include "htmapclr.h"
#include "htpat.h"
#include "htalias.h"
#include "htrender.h"
#include "htstret.h"
#include "htgetbmp.h"


#define DBGP_INPUT              0x00000001
#define DBGP_GETFIXUP           0x00000002
#define DBGP_CHK_FUDI           0x00000004
#define DBGP_FUDI               0x00000008
#define DBGP_EXP_MASK           0x00000010


DEF_DBGPVAR(BIT_IF(DBGP_INPUT,          0)  |
            BIT_IF(DBGP_GETFIXUP,       0)  |
            BIT_IF(DBGP_CHK_FUDI,       0)  |
            BIT_IF(DBGP_FUDI,           0)  |
            BIT_IF(DBGP_EXP_MASK,       0))


#if DBG
    INT cCXMask = 0;

    #define DBG_CXMASK      0
#else
    #define DBG_CXMASK      0
#endif

#define GET_AV(p)       (BYTE)(p)->f
#define OR_AV(AV1, AV2) (BYTE)(((UINT)(AV1) + (UINT)(AV2) + 1) >> 1)

extern  DWORD           dwABPreMul[256];

#define GET_PREMUL_SRC(x, m)                                           \
                        (BYTE)((((DWORD)(x) * (DWORD)(m)) + 0x800000) >> 24)



VOID
HTENTRY
BltAV_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    LPBYTE      pSrcAV;
    LPBYTE      pSrcAVEnd;
    INT         SrcAVInc;
    PBGRF       pbgrfAB;


    pSrcAV      = pAAHdr->pSrcAVBeg;
    pSrcAVEnd   = pAAHdr->pSrcAVEnd;
    SrcAVInc    = (INT)pAAHdr->SrcAVInc;
    pbgrfAB     = pAAHdr->pbgrfAB;

    if (pAAHdr->Flags & AAHF_OR_AV) {

        do {

            *pSrcAV = OR_AV(*pSrcAV, GET_AV(pbgrfAB));

            ++pbgrfAB;

        } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);

    } else {

        do {

            *pSrcAV = GET_AV(pbgrfAB);

            ++pbgrfAB;

        } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);
    }
}



VOID
HTENTRY
BltAV_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    pAAHdr->GetAVCXFunc(pAAHdr);

    (LPBYTE)pAAHdr->pbgrfAB += pAAHdr->cyABNext;
}





VOID
HTENTRY
TileAV_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    LPBYTE      pSrcAV;
    LPBYTE      pSrcAVEnd;
    INT         SrcAVInc;
    PBGRF       pbgrfAB;
    PBGRF       pbgrfABBeg;
    PBGRF       pbgrfABEnd;


    pSrcAV      = pAAHdr->pSrcAVBeg;
    pSrcAVEnd   = pAAHdr->pSrcAVEnd;
    SrcAVInc    = (INT)pAAHdr->SrcAVInc;
    pbgrfAB     =
    pbgrfABBeg  = pAAHdr->pbgrfAB;
    pbgrfABEnd  = pbgrfAB + pAAHdr->SrcSurfInfo.cx;
    pbgrfAB    +=  pAAHdr->pAAInfoCX->iSrcBeg;

    do {

        *pSrcAV = GET_AV(pbgrfAB);

        if (++pbgrfAB >= pbgrfABEnd) {

            pbgrfAB = pbgrfABBeg;
        }

    } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);

    if (--pAAHdr->cybgrfAB <= 0) {

        pAAHdr->pbgrfAB  = (PBGRF)pAAHdr->SrcSurfInfo.pbOrg;
        pAAHdr->cybgrfAB = pAAHdr->SrcSurfInfo.cyOrg;
    }
}




VOID
HTENTRY
ExpandAV_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    LPBYTE      pSrcAV;
    LPBYTE      pSrcAVEnd;
    PBGRF       pbgrfAB;
    INT         SrcAVInc;
    BOOL        OrAV;
    DWORD       cRep;
    BYTE        AV;


    pSrcAV    = pAAHdr->pSrcAVBeg;
    pSrcAVEnd = pAAHdr->pSrcAVEnd;
    SrcAVInc  = (INT)pAAHdr->SrcAVInc;
    pbgrfAB   = pAAHdr->pbgrfAB;
    pAAInfo   = pAAHdr->pAAInfoCX;
    pRep      = pAAInfo->AB.pRep;
    pRepEnd   = pAAInfo->AB.pRepEnd;
    cRep      = 1;

    //
    // The AB set to 0xff so if the source AB is not available at begining
    // then it will be no AB
    //

    AV   = 0xFF;
    OrAV = (BOOL)(pAAHdr->Flags & AAHF_OR_AV);

    do {

        if (--cRep == 0) {

            ASSERT(pRep < pRepEnd);

            cRep = (DWORD)pRep++->c;
            AV   = GET_AV(pbgrfAB);

            if (OrAV) {

                AV = OR_AV(AV, *pSrcAV);
            }

            ++pbgrfAB;
        }

        *pSrcAV = (BYTE)AV;

    } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);
}



VOID
HTENTRY
ExpandAV_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;


    pAAInfo = pAAHdr->pAAInfoCY;

    if (--pAAInfo->AB.cRep == 0) {

        ASSERT(pAAInfo->AB.pRep < pAAInfo->AB.pRepEnd);

        pAAInfo->AB.cRep = (DWORD)pAAInfo->AB.pRep++->c;

        BltAV_CY(pAAHdr);
    }
}




VOID
HTENTRY
ShrinkAV_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    LPBYTE      pSrcAV;
    LPBYTE      pSrcAVEnd;
    PBGRF       pbgrfAB;
    INT         SrcAVInc;
    DWORD       cRep;
    BOOL        OrAV;
    BYTE        AV;


    pSrcAV    = pAAHdr->pSrcAVBeg;
    pSrcAVEnd = pAAHdr->pSrcAVEnd;
    SrcAVInc  = (INT)pAAHdr->SrcAVInc;
    pbgrfAB   = pAAHdr->pbgrfAB;
    pAAInfo   = pAAHdr->pAAInfoCX;
    pRep      = pAAInfo->AB.pRep;
    pRepEnd   = pAAInfo->AB.pRepEnd;
    OrAV      = (BOOL)(pAAHdr->Flags & AAHF_OR_AV);

    do {

        AV = 0xFF;

        ASSERT(pRep < pRepEnd);

        if (pRep < pRepEnd) {

            AV = GET_AV(pbgrfAB);

            if (OrAV) {

                AV = OR_AV(*pSrcAV, AV);
            }

            ++pbgrfAB;
            cRep = (DWORD)pRep++->c;

            while (--cRep) {

                AV = OR_AV(AV, GET_AV(pbgrfAB));
                ++pbgrfAB;
            }
        }

        *pSrcAV = AV;

    } while (((LPBYTE)pSrcAV += SrcAVInc) != (LPBYTE)pSrcAVEnd);
}



VOID
HTENTRY
ShrinkAV_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfoCY;
    DWORD       AAHFlags;
    DWORD       cRep;

    //
    // We will get the scan first then subsequence scans will be or in
    //


    pAAInfoCY      = pAAHdr->pAAInfoCY;
    AAHFlags       = pAAHdr->Flags;
    pAAHdr->Flags &= ~AAHF_OR_AV;

    ASSERT(pAAInfoCY->AB.pRep < pAAInfoCY->AB.pRepEnd);

    cRep = (DWORD)pAAInfoCY->AB.pRep++->c;

    while (cRep--) {

        pAAHdr->GetAVCXFunc(pAAHdr);

        pAAHdr->Flags            = AAHFlags;
        (LPBYTE)pAAHdr->pbgrfAB += pAAHdr->cyABNext;
    }
}



VOID
HTENTRY
BltMask_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PBGRF       pDst;
    PBGRF       pDstEnd;
    LPBYTE      pb;
    INT         DstInc;
    DW2W4B      dw4b;
    BYTE        Mask;

    pAAInfo     = pAAHdr->pAAInfoCX;
    pDst        = pAAHdr->pAABufBeg;
    pDstEnd     = pAAHdr->pAABufEnd;
    DstInc      = pAAHdr->AABufInc;
    pb          = pAAHdr->pMaskSrc;
    dw4b.dw     = 0x01;
    dw4b.b[2]   = *pb++;
    dw4b.dw   <<= pAAHdr->MaskBitOff;

    do {

        if (dw4b.b[1]) {

            dw4b.dw   = 0x01;
            dw4b.b[2] = *pb++;
        }

        pDst->f   = (BYTE)((dw4b.b[2] & 0x80) ? PBGRF_MASK_FLAG : 0);
        dw4b.dw <<= 1;

    } while (((LPBYTE)pDst += DstInc) != (LPBYTE)pDstEnd);
}



VOID
HTENTRY
BltMask_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    GET_MASK_SCAN(pAAHdr);
    pAAHdr->AAMaskCXFunc(pAAHdr);
}



VOID
HTENTRY
ExpandMask_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    PBGRF       pDst;
    PBGRF       pDstEnd;
    LPBYTE      pb;
    DWORD       cRep;
    INT         DstInc;
    DW2W4B      dw4b;
    BYTE        Mask;


    pAAInfo     = pAAHdr->pAAInfoCX;
    pRep        = pAAInfo->Mask.pRep;
    pRepEnd     = pAAInfo->Mask.pRepEnd;
    pDst        = pAAHdr->pAABufBeg;
    pDstEnd     = pAAHdr->pAABufEnd;
    DstInc      = pAAHdr->AABufInc;
    pb          = pAAHdr->pMaskSrc;
    dw4b.dw     = 0x01;
    dw4b.b[2]   = *pb++;
    dw4b.dw   <<= pAAHdr->MaskBitOff;

    //
    // The Mask set to 0xff so if the source mask is not available at begining
    // then it will be no mask
    //

    Mask = PBGRF_MASK_FLAG;
    cRep = 1;

    do {

        if (--cRep == 0) {

            ASSERT(pRep < pRepEnd);

            cRep = (DWORD)pRep++->c;

            //
            // Load new byte data if we already used up current byte
            //

            if (dw4b.b[1]) {

                dw4b.dw   = 0x01;
                dw4b.b[2] = *pb++;
            }

            Mask       = (BYTE)((dw4b.b[2] & 0x80) ? PBGRF_MASK_FLAG : 0);
            dw4b.dw  <<= 1;
        }

        pDst->f = Mask;

    } while (((LPBYTE)pDst += DstInc) != (LPBYTE)pDstEnd);

    SETDBGVAR(cCXMask, -1);
}



VOID
HTENTRY
ExpandMask_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;


    pAAInfo = pAAHdr->pAAInfoCY;

    if (--pAAInfo->Mask.cRep == 0) {

        ASSERT(pAAInfo->Mask.pRep < pAAInfo->Mask.pRepEnd);

        pAAInfo->Mask.cRep = (DWORD)pAAInfo->Mask.pRep++->c;

        DBGP_IF(DBGP_EXP_MASK,
                DBGP("LOAD: cy=%4ld, cMaskRem=%4ld, cMaskIn=%4ld, cMaskOut=%4ld"
                    ARGDW(pAAHdr->cyMaskIn) ARGDW(pAAInfo->Mask.cRep)
                    ARGDW(pAAInfo->Mask.cIn) ARGDW(pAAInfo->Mask.cOut)));

        BltMask_CY(pAAHdr);

    } else {

        DBGP_IF(DBGP_EXP_MASK,
                DBGP("      cy=%4ld, cMaskRem=%4ld, cMaskIn=%4ld, cMaskOut=%4ld"
                        ARGDW(pAAHdr->cyMaskIn) ARGDW(pAAInfo->Mask.cRep)
                        ARGDW(pAAInfo->Mask.cIn) ARGDW(pAAInfo->Mask.cOut)));
    }
}




VOID
HTENTRY
ShrinkMask_CX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    PBGRF       pDst;
    PBGRF       pDstEnd;
    LPBYTE      pb;
    DWORD       cRep;
    DW2W4B      dw4b;
    INT         DstInc;
    BYTE        Mask;



    pAAInfo     = pAAHdr->pAAInfoCX;
    pRep        = pAAInfo->Mask.pRep;
    pRepEnd     = pAAInfo->Mask.pRepEnd;
    pDst        = pAAHdr->pAABufBeg;
    pDstEnd     = pAAHdr->pAABufEnd;
    DstInc      = pAAHdr->AABufInc;
    pb          = pAAHdr->pMaskSrc;
    dw4b.dw     = 0x01;
    dw4b.b[2]   = *pb++;
    dw4b.dw   <<= pAAHdr->MaskBitOff;

    //
    // --iMaskSize, because we want it to go negative when we reach 0, and
    // use bit 24-31 for mask
    //

    do {

        ASSERT(pRep < pRepEnd);

        cRep = (DWORD)pRep++->c;
        Mask = 0;

        while (cRep--) {

            //
            // Load new byte data if we already used up current byte
            //

            if (dw4b.b[1]) {

                dw4b.dw   = 0x01;
                dw4b.b[2] = *pb++;
            }

            //
            // Or in the bit 0x80, we will mask it later
            //

            Mask     |= dw4b.b[2];
            dw4b.dw <<= 1;
        }

        pDst->f = (BYTE)((Mask & 0x80) ? PBGRF_MASK_FLAG : 0);

    } while (((LPBYTE)pDst += DstInc) != (LPBYTE)pDstEnd);
}



VOID
HTENTRY
ShrinkMask_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PAAINFO pAAInfo;
    DWORD   cRep;

    //
    // We will get the scan first then subsequence scans will be or in
    //

    GET_MASK_SCAN(pAAHdr);

    pAAInfo = pAAHdr->pAAInfoCY;

    ASSERT(pAAInfo->Mask.pRep < pAAInfo->Mask.pRepEnd);

    cRep = (DWORD)pAAInfo->Mask.pRep++->c;

    while (--cRep) {

        OR_MASK_SCAN(pAAHdr);
    }

    pAAHdr->AAMaskCXFunc(pAAHdr);
}





PBGR8
HTENTRY
Input1BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    15-Apr-1998 Wed 16:25:04 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE  pIn;
    PBGR8   pRet;
    UINT    cIn;
    UINT    Idx;
    UINT    i;
    W2B     Bit;
    UINT    InData;


    pIn     = pAASI->pb;
    cIn     = (UINT)pAASI->cx;
    pRet    = pInBuf;

    if (pAASI->Flags & AASIF_GRAY) {

        LPBYTE  pbIB = (LPBYTE)pInBuf;
        BYTE    Gray[2];

        Gray[0] = pAASI->pClrTable[0].a;
        Gray[1] = pAASI->pClrTable[1].a;

        if (Idx = pAASI->BitOffset) {

            Bit.w = (WORD)*pIn++ << Idx;

            if ((Idx = 8 - Idx) > cIn) {

                Idx = cIn;
            }

            cIn -= Idx;

            while (Idx--) {

                Bit.w   <<= 1;
                *pbIB++   = Gray[i = (Bit.b[1] & 0x01)];
            }
        }

        Idx = cIn >> 3;

        while (Idx--) {

            InData       = (UINT)*pIn++;
            *(pbIB + 0)  = Gray[(InData >> 7) & 0x01];
            *(pbIB + 1)  = Gray[(InData >> 6) & 0x01];
            *(pbIB + 2)  = Gray[(InData >> 5) & 0x01];
            *(pbIB + 3)  = Gray[(InData >> 4) & 0x01];
            *(pbIB + 4)  = Gray[(InData >> 3) & 0x01];
            *(pbIB + 5)  = Gray[(InData >> 2) & 0x01];
            *(pbIB + 6)  = Gray[(InData >> 1) & 0x01];
            *(pbIB + 7)  = Gray[(InData     ) & 0x01];
            pbIB        += 8;
        }

        if (cIn &= 0x07) {

            Bit.w = (WORD)*pIn;

            while (cIn--) {

                Bit.w   <<= 1;
                *pbIB++   = Gray[i = (Bit.b[1] & 0x01)];
            }
        }

    } else {

        BGR8    rgb[2];

        rgb[0] = *(PBGR8)pAASI->pClrTable;
        rgb[1] = *(PBGR8)(pAASI->pClrTable + 1);

        if (Idx = pAASI->BitOffset) {

            Bit.w = (WORD)*pIn++ << Idx;

            if ((Idx = 8 - Idx) > cIn) {

                Idx = cIn;
            }

            cIn -= Idx;

            while (Idx--) {

                Bit.w     <<= 1;
                *pInBuf++   = rgb[i = (Bit.b[1] & 0x01)];
            }
        }

        Idx = cIn >> 3;

        while (Idx--) {

            InData         = (UINT)*pIn++;
            *(pInBuf + 0)  = rgb[(InData >> 7) & 0x01];
            *(pInBuf + 1)  = rgb[(InData >> 6) & 0x01];
            *(pInBuf + 2)  = rgb[(InData >> 5) & 0x01];
            *(pInBuf + 3)  = rgb[(InData >> 4) & 0x01];
            *(pInBuf + 4)  = rgb[(InData >> 3) & 0x01];
            *(pInBuf + 5)  = rgb[(InData >> 2) & 0x01];
            *(pInBuf + 6)  = rgb[(InData >> 1) & 0x01];
            *(pInBuf + 7)  = rgb[(InData     ) & 0x01];
            pInBuf       += 8;
        }

        if (cIn &= 0x07) {

            Bit.w = (WORD)*pIn;

            while (cIn--) {

                Bit.w     <<= 1;
                *pInBuf++   = rgb[i = (Bit.b[1] & 0x01)];
            }
        }
    }

    DBGP_IF(DBGP_INPUT,
            DBGP("cyIn=%5ld, pIn=%p-%p, cbIn=%5ld, Buf=%p-%p"
                ARGDW(pAASI->cy) ARGPTR(pAASI->pb)
                ARGPTR(pIn) ARGDW(pAASI->cbCX)
                ARGPTR(pRet) ARGPTR((LPBYTE)pRet + pAASI->cbCX)));

    SET_NEXT_PIN(pAASI);

    return(pRet);
}



PBGR8
HTENTRY
Input4BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    15-Apr-1998 Wed 16:25:04 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE  pIn;
    PBGR8   pRet;
    PRGB4B  pColorTable;
    UINT    InData;
    UINT    InData2;
    UINT    cIn;
    UINT    Idx;


    pIn         = pAASI->pb;
    cIn         = (UINT)pAASI->cx;
    pRet        = pInBuf;
    pColorTable = pAASI->pClrTable;

    if (pAASI->Flags & AASIF_GRAY) {

        LPBYTE  pbIB = (LPBYTE)pInBuf;

        if (pAASI->BitOffset) {

            --cIn;
            InData  = (UINT)(*pIn++ & 0x0F);
            *pbIB++ = pColorTable[InData].a;
        }

        Idx = cIn >> 1;

        while (Idx--) {

            InData       = (UINT)*pIn++;
            *(pbIB + 0)  = pColorTable[InData >>   4].a;
            *(pbIB + 1)  = pColorTable[InData & 0x0F].a;
            pbIB        += 2;
        }

        if (cIn & 0x01) {

            InData  = (UINT)(*pIn >> 4);
            *pbIB++ = pColorTable[InData].a;
        }

    } else {

        if (pAASI->BitOffset) {

            --cIn;
            InData     = (UINT)(*pIn++ & 0x0F);
            *pInBuf++  = *(PBGR8)(pColorTable + InData);
        }

        Idx = cIn >> 1;

        while (Idx--) {

            InData         = (UINT)*pIn++;
            *(pInBuf + 0)  = *(PBGR8)(pColorTable + (InData >> 4));
            *(pInBuf + 1)  = *(PBGR8)(pColorTable + (InData & 0x0F));
            pInBuf        += 2;
        }

        if (cIn & 0x01) {

            InData    = (UINT)(*pIn >> 4);
            *pInBuf++ = *(PBGR8)(pColorTable + InData);
        }
    }

    DBGP_IF(DBGP_INPUT,
            DBGP("cyIn=%5ld, pIn=%p-%p, cbIn=%5ld, Buf=%p-%p"
                ARGDW(pAASI->cy) ARGPTR(pAASI->pb)
                ARGPTR(pIn) ARGDW(pAASI->cbCX)
                ARGPTR(pRet) ARGPTR((LPBYTE)pRet + pAASI->cbCX)));

    SET_NEXT_PIN(pAASI);

    return(pRet);
}



PBGR8
HTENTRY
Input8BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    15-Apr-1998 Wed 16:25:04 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pbIB    ((LPBYTE)pInBuf)

    LPBYTE  pIn;
    LPBYTE  pInBufEnd;
    PBGR8   pRet;
    PRGB4B  pColorTable;


    pIn         = pAASI->pb;
    pRet        = pInBuf;
    pColorTable = pAASI->pClrTable;
    pInBufEnd   = (LPBYTE)pInBuf + pAASI->cbCX;

    if (pAASI->Flags & AASIF_GRAY) {

        ASSERT(pAASI->cbCX == pAASI->cx);

        do {

            *pbIB = pColorTable[*pIn++].a;

        } while (++pbIB < pInBufEnd);

    } else {

        ASSERT(pAASI->cbCX == (LONG)(pAASI->cx * sizeof(BGR8)));

        do {

            *pInBuf = *(PBGR8)(pColorTable + *pIn++);

        } while (++pInBuf < (PBGR8)pInBufEnd);
    }

    DBGP_IF(DBGP_INPUT,
            DBGP("cyIn=%5ld, pIn=%p-%p, cbIn=%5ld, Buf=%p-%p"
                ARGDW(pAASI->cy) ARGPTR(pAASI->pb)
                ARGPTR(pIn) ARGDW(pAASI->cbCX)
                ARGPTR(pRet) ARGPTR((LPBYTE)pRet + pAASI->cbCX)));

    SET_NEXT_PIN(pAASI);

    return(pRet);

#undef pbIB
}



PBGR8
HTENTRY
InputPreMul32BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:

    This function will read input from a 32-bit (red, green, blue, alpha
    8 bits for each channel) type of source and reverse mapped the input
    alpha channel pre-multiply RGB byte data to its orginal value.

    This function only used if alpha blending is requested and its is a per
    pixel alpha blending with 32-bit source

Arguments:




Return Value:

    pointer to the pInBuf


Author:

    16-Aug-2000 Wed 11:07:15 updated  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pbIB        ((LPBYTE)pInBuf)
#define mR          (AABFData.MaskRGB[0])
#define mG          (AABFData.MaskRGB[1])
#define mB          (AABFData.MaskRGB[2])

    LPBYTE      pbIn;
    PBGR8       pRet;
    LPBYTE      pInBufEnd;
    AABFDATA    AABFData;
    DWORD       Mul;
    BYTE        bgr[3];


    pbIn      = (LPBYTE)pAASI->pb;
    pRet      = pInBuf;
    AABFData  = pAASI->AABFData;
    pInBufEnd = pbIB + pAASI->cbCX;

    ASSERT(AABFData.Flags & AABF_MASK_IS_ORDER);
    ASSERT(dwABPreMul[0] == 0);

    //
    // If the pbIn[0], pbIn[1], pbIn[2] is greater than is alpha value in
    // pbIn[3] then it will be some wrong xlate, but at here we trust that
    // caller doing the right math for its RGB values
    //

    if (pAASI->Flags & AASIF_GRAY) {

        PLONG   pIdxBGR;
        BGR8    bgr8;


        pIdxBGR = pAASI->pIdxBGR;

        ASSERT((LONG)pAASI->cbCX == (LONG)pAASI->cx);
        ASSERT(pIdxBGR);

        //
        // When we need to translate from a 32-bits RGB source to gray, the
        // pIdxBGR mapping table must already re-arranged to have
        //
        //  pIdxBGR[  0 - 255] for 1st byte source RGB order
        //  pIdxBGR[256 - 511] for 2nd byte source RGB order
        //  pIdxBGR[512 - 768] for 3rd byte source RGB order
        //

        do {

            Mul    = (DWORD)dwABPreMul[pbIn[3]];
            *pbIB  = IDXBGR_2_GRAY_BYTE(pIdxBGR,
                                        GET_PREMUL_SRC(pbIn[0], Mul),
                                        GET_PREMUL_SRC(pbIn[1], Mul),
                                        GET_PREMUL_SRC(pbIn[2], Mul));
            pbIn  += 4;

        } while (++pbIB < pInBufEnd);

    } else {

        ASSERT(pAASI->cbCX == (LONG)(pAASI->cx * sizeof(BGR8)));

        if (AABFData.Flags & AABF_SRC_IS_BGR_ALPHA) {

            do {

                Mul        = (DWORD)dwABPreMul[pbIn[3]];
                pInBuf->b  = GET_PREMUL_SRC(pbIn[0], Mul);
                pInBuf->g  = GET_PREMUL_SRC(pbIn[1], Mul);
                pInBuf->r  = GET_PREMUL_SRC(pbIn[2], Mul);
                pbIn      += 4;

            } while (++pInBuf < (PBGR8)pInBufEnd);

        } else if (AABFData.Flags & AABF_SRC_IS_RGB_ALPHA) {

            do {

                Mul        = (DWORD)dwABPreMul[pbIn[3]];
                pInBuf->r  = GET_PREMUL_SRC(pbIn[0], Mul);
                pInBuf->g  = GET_PREMUL_SRC(pbIn[1], Mul);
                pInBuf->b  = GET_PREMUL_SRC(pbIn[2], Mul);
                pbIn      += 4;

            } while (++pInBuf < (PBGR8)pInBufEnd);

        } else {

            do {

                Mul        = (DWORD)dwABPreMul[pbIn[3]];
                bgr[0]     = pbIn[mB];
                bgr[1]     = pbIn[mG];
                bgr[2]     = pbIn[mR];
                pInBuf->b  = GET_PREMUL_SRC(bgr[0], Mul);
                pInBuf->g  = GET_PREMUL_SRC(bgr[1], Mul);
                pInBuf->r  = GET_PREMUL_SRC(bgr[2], Mul);
                pbIn      += 4;

            } while (++pInBuf < (PBGR8)pInBufEnd);
        }
    }

    SET_NEXT_PIN(pAASI);

    return(pRet);

#undef  mR
#undef  mG
#undef  mB
#undef  pbIB
}



PBGR8
HTENTRY
InputAABFDATAToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    )

/*++

Routine Description:

    This function read input from a 16/24/32 bits per pixel source, these
    source can be bit mask type of source (16/32 bits)


Arguments:




Return Value:




Author:

    12-Mar-1999 Fri 12:53:16 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pbIB        ((LPBYTE)pInBuf)
#define pwIn        ((LPWORD)pbIn)
#define pdwIn       ((LPDWORD)pbIn)
#define mR          (AABFData.MaskRGB[0])
#define mG          (AABFData.MaskRGB[1])
#define mB          (AABFData.MaskRGB[2])
#define lR          (AABFData.LShiftRGB[0])
#define lG          (AABFData.LShiftRGB[1])
#define lB          (AABFData.LShiftRGB[2])
#define rR          (AABFData.RShiftRGB[0])
#define rG          (AABFData.RShiftRGB[1])
#define rB          (AABFData.RShiftRGB[2])

#define GET_AABFDATA_BGR8(pbgr8, dwIn)                                      \
{                                                                           \
    (pbgr8)->r  = (BYTE)(((dwIn >> rR) << lR) & mR);                        \
    (pbgr8)->g  = (BYTE)(((dwIn >> rG) << lG) & mG);                        \
    (pbgr8)->b  = (BYTE)(((dwIn >> rB) << lB) & mB);                        \
}


    LPBYTE      pbIn;
    PBGR8       pRet;
    LPBYTE      pInBufEnd;
    AABFDATA    AABFData;
    DWORD       dwIn;
    UINT        cbSrcInc;


    pbIn      = (LPBYTE)pAASI->pb;
    pRet      = pInBuf;
    AABFData  = pAASI->AABFData;
    cbSrcInc  = (UINT)AABFData.cbSrcInc;
    pInBufEnd = (LPBYTE)pInBuf + pAASI->cbCX;

    if (pAASI->Flags & AASIF_GRAY) {

        PLONG   pIdxBGR;
        BGR8    bgr8;


        ASSERT((LONG)pAASI->cbCX == (LONG)pAASI->cx);

        pIdxBGR   = pAASI->pIdxBGR;
        pInBufEnd = pbIB + pAASI->cx;

        if (AABFData.Flags & AABF_MASK_IS_ORDER) {

            //
            // When we have AASIF_GRAY, the pIdxBGR must already re-arranged
            // to have
            //
            //  pIdxBGR[  0 - 255] for 1st byte source RGB order
            //  pIdxBGR[256 - 511] for 2nd byte source RGB order
            //  pIdxBGR[512 - 768] for 3rd byte source RGB order
            //

            do {

                *pbIB  = IDXBGR_2_GRAY_BYTE(pIdxBGR, pbIn[0], pbIn[1], pbIn[2]);
                pbIn  += cbSrcInc;

            } while (++pbIB < pInBufEnd);

        } else if (cbSrcInc == 4) {

            do {

                dwIn = (DWORD)*pdwIn++;

                GET_AABFDATA_BGR8(&bgr8, dwIn);

                *pbIB = IDXBGR_2_GRAY_BYTE(pIdxBGR, bgr8.b, bgr8.g, bgr8.r);

            } while (++pbIB < pInBufEnd);

        } else {

            ASSERT(cbSrcInc == 2);

            do {

                dwIn = (DWORD)*pwIn++;

                GET_AABFDATA_BGR8(&bgr8, dwIn);

                *pbIB = IDXBGR_2_GRAY_BYTE(pIdxBGR, bgr8.b, bgr8.g, bgr8.r);

            } while (++pbIB < pInBufEnd);
        }

    } else {

        ASSERT(pAASI->cbCX == (LONG)(pAASI->cx * sizeof(BGR8)));

        if (AABFData.Flags & AABF_MASK_IS_ORDER) {

            if (AABFData.Flags & AABF_SRC_IS_BGR8) {

                CopyMemory(pInBuf, pbIn, pAASI->cbCX);

            } else {

                do {

                    pInBuf->r  = pbIn[mR];
                    pInBuf->g  = pbIn[mG];
                    pInBuf->b  = pbIn[mB];
                    pbIn      += cbSrcInc;

                } while (++pInBuf < (PBGR8)pInBufEnd);
            }

        } else if (cbSrcInc == 4) {

            do {

                dwIn = (DWORD)*pdwIn++;

                GET_AABFDATA_BGR8(pInBuf, dwIn);

            } while (++pInBuf < (PBGR8)pInBufEnd);

        } else {

            ASSERT(cbSrcInc == 2);

            do {

                dwIn = (DWORD)*pwIn++;

                GET_AABFDATA_BGR8(pInBuf, dwIn);

            } while (++pInBuf < (PBGR8)pInBufEnd);
        }
    }

    SET_NEXT_PIN(pAASI);

    return(pRet);

#undef  mR
#undef  mG
#undef  mB
#undef  lR
#undef  lG
#undef  lB
#undef  rR
#undef  rG
#undef  rB
#undef  pwIn
#undef  pdwIn
#undef  pbIB
}




#if DBG


LPSTR
GetAAInputFuncName(
    AAINPUTFUNC AAInputFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Jan-1999 Wed 19:11:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if (AAInputFunc == (AAINPUTFUNC)Input1BPPToAA24) {

        return("Input1BPPToAA24");

    } else if (AAInputFunc == (AAINPUTFUNC)Input4BPPToAA24) {

        return("Input4BPPToAA24");

    } else if (AAInputFunc == (AAINPUTFUNC)Input8BPPToAA24) {

        return("Input8BPPToAA24");

    } else if (AAInputFunc == (AAINPUTFUNC)InputPreMul32BPPToAA24) {

        return("InputPreMul32BPPToAA24");

    } else if (AAInputFunc == (AAINPUTFUNC)InputAABFDATAToAA24) {

        return("InputAABFDATAToAA24");

    } else {

        return("ERROR: Unknown Function");
    }
}


#endif




PBGR8
HTENTRY
FixupGrayScan(
    PAAHEADER   pAAHdr,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Apr-1999 Tue 11:48:14 created  -by-  Daniel Chou (danielc)


Revision History:

    06-May-1999 Thu 13:07:49 updated  -by-  Daniel Chou (danielc)
        The pInBuf can be NULL now

--*/

{
    FIXUPDIBINFO    FUDI;
    LPBYTE          pS0;
    LPBYTE          pS1;
    LPBYTE          pS2;
    LPBYTE          pS3;
    LPBYTE          pD1;
    LPBYTE          pD2;
    UINT            cIn;
    UINT            cbIn;
    BYTE            Mask;


    cbIn =
    cIn  = (UINT)pAAHdr->SrcSurfInfo.cx;
    FUDI = pAAHdr->FUDI;

    if (pAAHdr->Flags & AAHF_GET_LAST_SCAN) {

        pS0             = (LPBYTE)FUDI.prgbD[4];
        pAAHdr->Flags &= ~AAHF_GET_LAST_SCAN;

        DBGP_IF(DBGP_GETFIXUP,
            DBGP("*** GetFixupScan: Re-Copy cyIn=%ld LAST SCANLINE ***"
                        ARGDW(FUDI.cyIn)));

        ++FUDI.cyIn;

    } else if (FUDI.cyIn <= 1) {

        pS0 = (LPBYTE)FUDI.prgbD[5];

        DBGP_IF(DBGP_GETFIXUP,
                DBGP("*** GetFixupScan: cyIn=%ld, FINAL SCANLINE, cChecker=%ld, cCorner=%ld, Tot=%ld"
                        ARGDW(FUDI.cyIn)
                        ARGDW(pAAHdr->FUDI.cChecker)
                        ARGDW(pAAHdr->FUDI.cCorner)
                        ARGDW(pAAHdr->FUDI.cCorner + pAAHdr->FUDI.cChecker)));

    } else {

        DWORD   g0;
        DWORD   g1;
        LONG    c0;
        LONG    c1;
        LONG    c2;
        LONG    c3;
        LONG    c0L;
        LONG    c0T;
        LONG    c1R;
        LONG    c1T;
        LONG    c2L;
        LONG    c2B;
        LONG    c3R;
        LONG    c3B;

        //
        // Scroll up the scan lines
        //

        pD2 = (LPBYTE)FUDI.prgbD[0];
        CopyMemory(&FUDI.prgbD[0], &FUDI.prgbD[1], sizeof(FUDI.prgbD[0]) * 5);
        FUDI.prgbD[5] = (PBGR8)pD2;

        pS0 = (LPBYTE)FUDI.prgbD[0];
        pS1 = (LPBYTE)FUDI.prgbD[1];
        pS2 = (LPBYTE)FUDI.prgbD[2];
        pS3 = (LPBYTE)FUDI.prgbD[3];
        pD1 = (LPBYTE)FUDI.prgbD[4];

        CopyMemory(pD2, pS2, FUDI.cbbgr);

        //
        // Save the next source scan line
        //

        if (pAAHdr->SrcSurfInfo.cy > 0) {

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo),
                                          (PBGR8)(pS3 + 1));

            *(pS3 + 0)       = *(pS3 + 2);
            *(pS3 + cIn + 1) = *(pS3 + cIn - 1);

        } else {

            //
            // No more scan lines, so copy the prev -2
            //

            CopyMemory(pS3, pS1, FUDI.cbbgr);
        }

        c0  = (LONG)*(pS1 + 0);
        c2  = (LONG)*(pS2 + 0);
        c1  = (LONG)*(pS1 + 1);
        c3  = (LONG)*(pS2 + 1);
        c1R = (LONG)*(pS1 + 2);
        c3R = (LONG)*(pS2 + 2);
        g1  = c1;

        while (--cIn) {

            c0L = c0;
            c2L = c2;
            c0  = c1;
            c2  = c3;
            c1  = c1R;
            c3  = c3R;
            c1R = (LONG)*(pS1 + 3);
            c3R = (LONG)*(pS2 + 3);
            g0  = g1;
            g1  = c1;

            if ((c0 != c1) && (!((c0 ^ c3) | (c1 ^ c2)))) {

                c0T = (LONG)*(pS0 + 1);
                c1T = (LONG)*(pS0 + 2);
                c2B = (LONG)*(pS3 + 1);
                c3B = (LONG)*(pS3 + 2);

                if ((!((c0L ^ c1) | (c2L ^ c3) | (c1R ^ c0) | (c3R ^ c2))) ||
                    (!((c0T ^ c2) | (c1T ^ c3) | (c2B ^ c0) | (c3B ^ c1)))) {

                    *(pD1 + 1) =
                    *(pD1 + 2) =
                    *(pD2 + 1) =
                    *(pD2 + 2) = (BYTE)(((LONG)*(pS1 + 1) +
                                         (LONG)*(pS1 + 2) + 1) >> 1);

                    SETDBGVAR(FUDI.cChecker, FUDI.cChecker + 1);

                } else {

                    if (g0 >= g1) {

                        SET_CORNER_GRAY(pD1 + 1, c1, c1R, c2, c2B);
                        SET_CORNER_GRAY(pD2 + 2, c1, c1T, c2, c2L);

                    } else {

                        SET_CORNER_GRAY(pD1 + 2, c0, c0L, c3, c3B);
                        SET_CORNER_GRAY(pD2 + 1, c0, c0T, c3, c3R);
                    }

                    SETDBGVAR(FUDI.cCorner, FUDI.cCorner + 1);
                }
            }

            ++pS0;
            ++pS1;
            ++pS2;
            ++pS3;
            ++pD1;
            ++pD2;
        }

        pS0 = (LPBYTE)FUDI.prgbD[4];

        DBGP_IF(DBGP_GETFIXUP,
                DBGP("*** GetFixupScan: cyIn=%ld" ARGDW(FUDI.cyIn - 1)));
    }

    if (pInBuf) {

        CopyMemory(pInBuf, pS0 + 1, cbIn);
    }

    --FUDI.cyIn;
    pAAHdr->FUDI = FUDI;

    return(pInBuf);
}



PBGR8
HTENTRY
FixupColorScan(
    PAAHEADER   pAAHdr,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Apr-1999 Tue 11:48:20 created  -by-  Daniel Chou (danielc)


Revision History:

    06-May-1999 Thu 13:07:49 updated  -by-  Daniel Chou (danielc)
        The pInBuf can be NULL now

--*/

{
    FIXUPDIBINFO    FUDI;
    PBGR8           pS0;
    PBGR8           pS1;
    PBGR8           pS2;
    PBGR8           pS3;
    PBGR8           pD1;
    PBGR8           pD2;
    UINT            cIn;
    UINT            cbIn;
    BYTE            Mask;


    cIn  = (UINT)pAAHdr->SrcSurfInfo.cx;
    cbIn = (UINT)pAAHdr->SrcSurfInfo.cbCX;
    FUDI = pAAHdr->FUDI;

    if (pAAHdr->Flags & AAHF_GET_LAST_SCAN) {

        pS0             = FUDI.prgbD[4];
        pAAHdr->Flags &= ~AAHF_GET_LAST_SCAN;

        DBGP_IF(DBGP_GETFIXUP,
            DBGP("*** GetFixupScan: Re-Copy cyIn=%ld LAST SCANLINE ***"
                        ARGDW(FUDI.cyIn)));

        ++FUDI.cyIn;

    } else if (FUDI.cyIn <= 1) {

        pS0 = FUDI.prgbD[5];

        DBGP_IF(DBGP_GETFIXUP,
                DBGP("*** GetFixupScan: cyIn=%ld, FINAL SCANLINE, cChecker=%ld, cCorner=%ld, Tot=%ld"
                        ARGDW(FUDI.cyIn)
                        ARGDW(pAAHdr->FUDI.cChecker)
                        ARGDW(pAAHdr->FUDI.cCorner)
                        ARGDW(pAAHdr->FUDI.cCorner + pAAHdr->FUDI.cChecker)));

    } else {

        DWORD   g0;
        DWORD   g1;
        LONG    c0;
        LONG    c1;
        LONG    c2;
        LONG    c3;
        LONG    c0L;
        LONG    c0T;
        LONG    c1R;
        LONG    c1T;
        LONG    c2L;
        LONG    c2B;
        LONG    c3R;
        LONG    c3B;

        //
        // Scroll up the scan lines
        //

        pD2 = FUDI.prgbD[0];
        CopyMemory(&FUDI.prgbD[0], &FUDI.prgbD[1], sizeof(FUDI.prgbD[0]) * 5);
        FUDI.prgbD[5] = pD2;

        pS0 = FUDI.prgbD[0];
        pS1 = FUDI.prgbD[1];
        pS2 = FUDI.prgbD[2];
        pS3 = FUDI.prgbD[3];
        pD1 = FUDI.prgbD[4];

        CopyMemory(pD2, pS2, FUDI.cbbgr);

        //
        // Save the next source scan line
        //

        if (pAAHdr->SrcSurfInfo.cy > 0) {

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo), pS3 + 1);

            *(pS3 + 0)       = *(pS3 + 2);
            *(pS3 + cIn + 1) = *(pS3 + cIn - 1);

        } else {

            //
            // No more scan lines, so copy the prev -2
            //

            CopyMemory(pS3, pS1, FUDI.cbbgr);
        }

        c0  = GET_LBGR(pS1 + 0);
        c2  = GET_LBGR(pS2 + 0);
        c1  = GET_LBGR(pS1 + 1);
        c3  = GET_LBGR(pS2 + 1);
        c1R = GET_LBGR(pS1 + 2);
        c3R = GET_LBGR(pS2 + 2);
        g1  = GET_GRAY_RGB(pS1 + 1);

        while (--cIn) {

            c0L = c0;
            c2L = c2;
            c0  = c1;
            c2  = c3;
            c1  = c1R;
            c3  = c3R;
            c1R = GET_LBGR(pS1 + 3);
            c3R = GET_LBGR(pS2 + 3);
            g0  = g1;
            g1  = GET_GRAY_RGB(pS1 + 2);

            if ((c0 != c1) && (!((c0 ^ c3) | (c1 ^ c2)))) {

                c0T = GET_LBGR(pS0 + 1);
                c1T = GET_LBGR(pS0 + 2);
                c2B = GET_LBGR(pS3 + 1);
                c3B = GET_LBGR(pS3 + 2);

                if ((!((c0L ^ c1) | (c2L ^ c3) | (c1R ^ c0) | (c3R ^ c2))) ||
                    (!((c0T ^ c2) | (c1T ^ c3) | (c2B ^ c0) | (c3B ^ c1)))) {

                    (pD1 + 1)->r =
                    (pD1 + 2)->r =
                    (pD2 + 1)->r =
                    (pD2 + 2)->r = (BYTE)(((LONG)(pS1 + 1)->r +
                                           (LONG)(pS1 + 2)->r + 1) >> 1);
                    (pD1 + 1)->g =
                    (pD1 + 2)->g =
                    (pD2 + 1)->g =
                    (pD2 + 2)->g = (BYTE)(((LONG)(pS1 + 1)->g +
                                           (LONG)(pS1 + 2)->g + 1) >> 1);
                    (pD1 + 1)->b =
                    (pD1 + 2)->b =
                    (pD2 + 1)->b =
                    (pD2 + 2)->b = (BYTE)(((LONG)(pS1 + 1)->b +
                                           (LONG)(pS1 + 2)->b + 1) >> 1);

                    SETDBGVAR(FUDI.cChecker, FUDI.cChecker + 1);

                } else {

                    if (g0 >= g1) {

                        SET_CORNER_BGR(pD1 + 1, c1, c1R, c2, c2B);
                        SET_CORNER_BGR(pD2 + 2, c1, c1T, c2, c2L);

                    } else {

                        SET_CORNER_BGR(pD1 + 2, c0, c0L, c3, c3B);
                        SET_CORNER_BGR(pD2 + 1, c0, c0T, c3, c3R);
                    }

                    SETDBGVAR(FUDI.cCorner, FUDI.cCorner + 1);
                }
            }

            ++pS0;
            ++pS1;
            ++pS2;
            ++pS3;
            ++pD1;
            ++pD2;
        }

        pS0 = FUDI.prgbD[4];

        DBGP_IF(DBGP_GETFIXUP,
                DBGP("*** GetFixupScan: cyIn=%ld" ARGDW(FUDI.cyIn - 1)));
    }

    if (pInBuf) {

        CopyMemory(pInBuf, pS0 + 1, cbIn);
    }

    --FUDI.cyIn;
    pAAHdr->FUDI = FUDI;

    return(pInBuf);
}




PBGR8
HTENTRY
GetFixupScan(
    PAAHEADER   pAAHdr,
    PBGR8       pInBuf
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Oct-1998 Sat 15:25:57 created  -by-  Daniel Chou (danielc)


Revision History:

    06-May-1999 Thu 13:07:49 updated  -by-  Daniel Chou (danielc)
        The pInBuf can be NULL now


--*/

{
    DWORD   AAHFlags;


    DBG_TIMER_BEG(TIMER_INPUT);

    if (!((AAHFlags = pAAHdr->Flags) & AAHF_DO_FIXUPDIB)) {

        if (AAHFlags & AAHF_GET_LAST_SCAN) {

            if (++pAAHdr->SrcSurfInfo.cy > pAAHdr->SrcSurfInfo.cyOrg) {

                DBGP("Error: GET_LAST_SCAN on first scan line %ld (%ld)"
                        ARGDW(pAAHdr->SrcSurfInfo.cy)
                        ARGDW(pAAHdr->SrcSurfInfo.cyOrg));

                pAAHdr->SrcSurfInfo.cy = pAAHdr->SrcSurfInfo.cyOrg;
            }

            pAAHdr->SrcSurfInfo.pb     = pAAHdr->SrcSurfInfo.pbOrg +
                                         ((pAAHdr->SrcSurfInfo.cyOrg -
                                           pAAHdr->SrcSurfInfo.cy) *
                                          pAAHdr->SrcSurfInfo.cyNext);
            pAAHdr->SrcSurfInfo.Flags |= AASIF_INC_PB;
            pAAHdr->Flags             &= ~AAHF_GET_LAST_SCAN;
        }

        if (pInBuf) {

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo), pInBuf);

        } else {

            SET_NEXT_PIN((&(pAAHdr->SrcSurfInfo)));
        }

    } else if (pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY) {

        FixupGrayScan(pAAHdr, pInBuf);

    } else {

        FixupColorScan(pAAHdr, pInBuf);
    }

    if ((pAAHdr->Flags & AAHF_DO_SRC_CLR_MAPPING) && (pInBuf)) {

        MappingBGR(pInBuf,
                   pAAHdr->SrcSurfInfo.cx,
                   (PBGR8)pAAHdr->pBGRMapTable,
                   (LPBYTE)pAAHdr->AAPI.pbPat555);

        if ((pAAHdr->AAPI.pbPat555 += pAAHdr->AAPI.cyNext555) ==
                                                pAAHdr->AAPI.pbWrap555) {

            pAAHdr->AAPI.pbPat555 = pAAHdr->AAPI.pbBeg555;
        }
    }

    DBG_TIMER_END(TIMER_INPUT);

    return(pInBuf);
}



BOOL
HTENTRY
CheckBMPNeedFixup(
    PDEVICECOLORINFO    pDCI,
    PAAHEADER           pAAHdr,
    PHTSURFACEINFO      pSrcSI,
    PAABBP              pAABBP
    )

/*++

Routine Description:

    This function check the bitmap to see if we need to do a fixup, if yes
    then it allocated memory accordingly


Arguments:




Return Value:




Author:

    07-Dec-1998 Mon 18:25:45 created  -by-  Daniel Chou (danielc)


Revision History:

    15-Aug-2000 Tue 19:05:25 updated  -by-  Daniel Chou (danielc)
        At pre-read checking, we HAVE TO turn off the the gray conversion
        and Alpha Blending pre-multiply conversion.


--*/

{
    LPBYTE      pbAlloc = NULL;
    LPBYTE      pInEnd;
    LPDWORD     pdwBegPal;
    LPDWORD     pdwEndPal;
    LPDWORD     pdw;
    AASURFINFO  SrcSurfInfo;
    RECTL       rclSrc;
    UINT        SrcFmt;
    LONG        cIn;
    LONG        cbIn;
    LONG        cPalChk;
    LONG        cPalTot;
    LONG        cyIn;
    LONG        cySkip;
    LONG        cy;
    DW2W4B      dw4b;
    DWORD       AAHFlags;
    BOOL        NewPal;

    DEFDBGVAR(LONG,  iY)


    SrcFmt = (UINT)pSrcSI->SurfaceFormat;

    if (!((AAHFlags = pAABBP->AAHFlags) & AAHF_DO_FIXUPDIB)) {

        DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                DBGP("CheckBMPNeedFixup(%ld)=No" ARGDW(SrcFmt)));

        return(FALSE);
    }

    switch (SrcFmt) {

    case BMF_1BPP:
    case BMF_4BPP:
    case BMF_4BPP_VGA16:

        pAABBP->AAHFlags |= (AAHF_DO_FIXUPDIB | AAHF_BBPF_AA_OFF);

        DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                DBGP("CheckBMPNeedFixup(%ld)=1BPP/4BPPNo, Check DIB and AA=OFF" ARGDW(SrcFmt)));

        return(TRUE);
        break;

    case BMF_8BPP:
    case BMF_8BPP_VGA256:
    case BMF_16BPP:
    case BMF_16BPP_555:
    case BMF_16BPP_565:
    case BMF_24BPP:
    case BMF_32BPP:

        rclSrc.left   =
        rclSrc.top    = 0;
        rclSrc.right  = pSrcSI->Width;
        rclSrc.bottom = pSrcSI->Height;

        if (!IntersectRECTL(&rclSrc, &pAABBP->rclSrc)) {

            return(FALSE);
        }

        //
        // 15-Aug-2000 Tue 19:05:25 updated  -by-  Daniel Chou (danielc)
        //  At pre-read checking, we HAVE TO turn off the the gray conversion
        //  and Alpha Blending pre-multiply conversion.
        //

        SrcSurfInfo        = pAAHdr->SrcSurfInfo;
        SrcSurfInfo.Flags &= ~(AASIF_GRAY | AASIF_AB_PREMUL_SRC);
        SrcSurfInfo.cyNext =
        cIn                = GET_PHTSI_CXSIZE(pSrcSI);
        cyIn               =
        SrcSurfInfo.cy     = rclSrc.bottom - rclSrc.top;
        SrcSurfInfo.pb     = pSrcSI->pPlane +
                             (rclSrc.top * cIn) +
                             ComputeByteOffset(SrcFmt,
                                               rclSrc.left,
                                               &(SrcSurfInfo.BitOffset));
        SrcSurfInfo.cx     =
        cIn                = rclSrc.right - rclSrc.left;
        SrcSurfInfo.cbCX   = cIn * sizeof(BGR8);
        cySkip             = 1;

        ALIGN_MEM(cbIn, (cIn + 2) * sizeof(BGR8));

        if ((cPalTot = cyIn * cIn) <= MIN_FIXUP_SIZE) {

            DBGP_IF(DBGP_FUDI,
                    DBGP("cyIn=%ld x cIn==%ld = %ld (<= MIN_FIXUP_SIZE=%ld, Turn off AA"
                        ARGDW(cyIn) ARGDW(cIn) ARGDW(cPalTot)
                        ARGDW(MIN_FIXUP_SIZE)));

            AAHFlags |= AAHF_BBPF_AA_OFF;
            break;

        } else if (cPalTot <= MIN_PAL_SIZE) {

            DBGP_IF(DBGP_FUDI,
                    DBGP("cPalTot=%ld <= MIN_PAL_SIZE=%ld, cPalChk: %ld -> %ld"
                        ARGDW(cPalTot) ARGDW(MIN_PAL_SIZE)
                        ARGDW(cPalTot) ARGDW(GET_PAL_CHK_COUNT(cPalTot))));

            cPalChk = GET_PAL_CHK_COUNT(cPalTot);

        } else {

            SrcSurfInfo.cy      = (cyIn + STD_PAL_CY_SKIP - 1) / STD_PAL_CY_SKIP;
            SrcSurfInfo.cyNext *= (cySkip = STD_PAL_CY_SKIP);
            cPalChk             = MAX_FIXUPDIB_PAL;

            DBGP_IF(DBGP_FUDI,
                    DBGP("REGULAR BITMAP, cySkip=%ld, cy=%ld -> %ld, cPalChk=%ld (MAX_FIXUPDIB_PAL)"
                        ARGDW(cySkip) ARGDW(cyIn) ARGDW(SrcSurfInfo.cy)
                        ARGDW(cPalChk) ARGDW(MAX_FIXUPDIB_PAL)));
        }

        if (!(pbAlloc = (LPBYTE)HTAllocMem((LPVOID)pDCI,
                                           HTMEM_FIXUPDIB,
                                           LPTR,
                                           cbIn + ((cPalChk + 1) *
                                                        sizeof(DWORD))))) {

            DBGP("Error: Cannot Allocate FixupDIB memory=%ld bytes, Turn of FIXUP"
                    ARGDW(cbIn + ((cPalChk + 1) * sizeof(DWORD))));

            pAABBP->AAHFlags = (AAHFlags & ~AAHF_DO_FIXUPDIB);

            return(FALSE);
        }

        pdwEndPal =
        pdwBegPal = (LPDWORD)(pbAlloc + cbIn);
        pInEnd    = (LPBYTE)pbAlloc + (cIn * sizeof(BGR8));
        cPalTot   = 0;

        SETDBGVAR(iY, 0);

        DBGP_IF(DBGP_FUDI,
                DBGP("SrcInputFunc=%p, cySkip=%ld, pIn=%p, Fmt=%ld (%ld x %ld), cPalChk=%ld"
                        ARGPTR(SrcSurfInfo.InputFunc) ARGDW(cySkip)
                        ARGPTR(SrcSurfInfo.pb) ARGDW(SrcFmt)
                        ARGDW(cIn) ARGDW(cyIn) ARGDW(cPalChk)));

        cbIn    = (cyIn * cIn);
        dw4b.dw = 0;

        do {

            PBGR8   pbgr;

            //
            // Try to read some lines and determine if this is a non primary
            // color bitmap, we only fixed up the bitmap if any of RGB is
            // 0x00, 0x40, 0x80, 0xc0, 0xFF
            //

            NewPal = FALSE;
            pbgr   = SrcSurfInfo.InputFunc(&SrcSurfInfo, (PBGR8)pbAlloc);

            do {


                //
                // The first entry is the sentinal, so it always stop there
                //

                dw4b.b[0] = pbgr->g;

                if ((dw4b.b[1] = pbgr->r) ==
                    (dw4b.b[2] = pbgr->b)) {

                    //
                    // This is a gray scale data, make it collapse by 4,
                    // the 0, 1, 2, 3 = 0, 4, 5, 6, 7 = 4,...., 252, 253,
                    // 254, 255 = 252
                    //

                    dw4b.dw &= 0xFCFCFCFC;
                }

                *pdwBegPal  = dw4b.dw;
                pdw         = pdwEndPal;

                while (*pdw != dw4b.dw) {

                    --pdw;
                }

                if (pdw == pdwBegPal) {

                    //
                    // We have new palette entry
                    //

                    if (++cPalTot > cPalChk) {

                        break;
                    }

                    *(++pdwEndPal) = dw4b.dw;
                    NewPal         = TRUE;
                }

            } while (++pbgr < (PBGR8)pInEnd);

            DBGP_IF(DBGP_FUDI,
                    DBGP("IsBmpNeedFixup(%4ld/%4ld) [%4ld/%4ld]: cPalTot=%4ld, cPalChk=%4ld"
                            ARGDW(iY) ARGDW(SrcSurfInfo.cy)
                            ARGDW((iY * cySkip) + 1)
                            ARGDW(cyIn) ARGDW(cPalTot) ARGDW(cPalChk)));

            SETDBGVAR(iY, iY + 1);

            if ((cPalChk != MAX_FIXUPDIB_PAL) && (!NewPal)) {

                DBGP_IF(DBGP_FUDI,
                        DBGP("Same Scanline Pal (%4ld / %4ld),  cPalChk=%ld (%ld)"
                            ARGDW(iY) ARGDW(SrcSurfInfo.cy)
                            ARGDW(cPalChk) ARGDW(MAX_FIXUPDIB_PAL)));

                //
                // Scan line is same, so reduced the cPalChk for SMALL BMP
                //

                if ((cbIn -= cIn) <= MIN_FIXUP_SIZE) {

                    DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                            DBGP("cx*cy=%ld <= MIN_FIXUP_SIZE=%ld, Turn off AA"
                                ARGDW(cbIn) ARGDW(MIN_FIXUP_SIZE)));

                    AAHFlags |= AAHF_BBPF_AA_OFF;
                    break;
                }

                cPalChk = GET_PAL_CHK_COUNT2(cbIn);
            }

        } while ((cPalTot <= cPalChk) && (SrcSurfInfo.cy));

        DBGP_IF(DBGP_CHK_FUDI,
                DBGP("IsBmpNeedFixup(): cPalChk=%ld, cy=%ld, cPalTot=%ld"
                        ARGDW(cPalChk) ARGDW((iY * cySkip) + 1)
                        ARGDW(cPalTot)));

        if (cPalTot < MAX_FIXUPDIB_PAL) {

            DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                    DBGP("cPalTot=%ld < MAX_FIXUPDIB_PAL (%ld) Turn off AA"
                        ARGDW(cPalTot) ARGDW(MAX_FIXUPDIB_PAL)));

            AAHFlags |= AAHF_BBPF_AA_OFF;
        }

        if (cPalChk == MAX_FIXUPDIB_PAL) {

            //
            // We are checking regular size bitmap, turn OFF FIXUPDIB if
            // cPalTot > cPalChk
            //

            if (cPalTot > cPalChk) {

                AAHFlags &= ~AAHF_DO_FIXUPDIB;
            }

            DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                    DBGP("Checking REGULAR BITMAP: cPalTot=%ld, cPalChk=%ld, DO_FIXUP=%hs"
                        ARGDW(cPalTot) ARGDW(cPalChk)
                        ARGPTR((AAHFlags & AAHF_DO_FIXUPDIB) ? "Yes" : "No")));

        } else {

            //
            // We are checking bitmap size <= MIN_PAL_SIZE (smaller size)
            // the FIXUPDIB will be turn ON if (cPalTot <= MAX_FIXUPDIB_PAL) ||
            // (cPalTot > cPalChk)
            //

            if ((cPalTot > MAX_FIXUPDIB_PAL) ||
                (cPalTot <= cPalChk)) {

                AAHFlags &= ~AAHF_DO_FIXUPDIB;
            }

            DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
                    DBGP("Checking SMALL BITMAP: Min=%ld, cPalTot=%ld, cPalChk=%ld, DO_FIXUP=%hs"
                        ARGDW(MAX_FIXUPDIB_PAL) ARGDW(cPalTot) ARGDW(cPalChk)
                        ARGPTR((AAHFlags & AAHF_DO_FIXUPDIB) ? "Yes" : "No")));
        }
    }

    if (pbAlloc) {

        HTFreeMem(pbAlloc);
    }

    pAABBP->AAHFlags = AAHFlags;

    DBGP_IF(DBGP_FUDI | DBGP_CHK_FUDI,
            DBGP("CheckBMPNeedFixup(%ld): DoFixup=%hs, AA=%hs"
                ARGDW(SrcFmt)
                ARGPTR((AAHFlags & AAHF_DO_FIXUPDIB) ? "Yes" : "No")
                ARGPTR((AAHFlags & AAHF_BBPF_AA_OFF) ? "Off" : "On")));

    return((BOOL)(AAHFlags & AAHF_DO_FIXUPDIB));
}




VOID
HTENTRY
InitializeFUDI(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    16-Dec-1998 Wed 17:30:34 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PBGR8   pbgr;
    LPBYTE  pb;
    UINT    cIn;
    UINT    i;


    pAAHdr->FUDI.cyIn = (pAAHdr->Flags & AAHF_TILE_SRC) ?
                                        pAAHdr->DstSurfInfo.cy :
                                        pAAHdr->SrcSurfInfo.cy;
    cIn               = pAAHdr->SrcSurfInfo.cx;

    if (pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY) {

        for (i = 2; i <= 3; i++) {

            pb = (LPBYTE)pAAHdr->FUDI.prgbD[i];

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo),
                                          (PBGR8)(pb + 1));

            *(pb + 0)       = *(pb + 2);
            *(pb + cIn + 1) = *(pb + cIn - 1);
        }

    } else {

        for (i = 2; i <= 3; i++) {

            pbgr = pAAHdr->FUDI.prgbD[i];

            pAAHdr->SrcSurfInfo.InputFunc(&(pAAHdr->SrcSurfInfo), pbgr + 1);

            *(pbgr + 0)       = *(pbgr + 2);
            *(pbgr + cIn + 1) = *(pbgr + cIn - 1);
        }
    }

    //
    // Save this one in case we need to copy first scan line
    //

    CopyMemory(pAAHdr->FUDI.prgbD[5],
               pAAHdr->FUDI.prgbD[2],
               pAAHdr->FUDI.cbbgr);
    CopyMemory(pAAHdr->FUDI.prgbD[1],
               pAAHdr->FUDI.prgbD[3],
               pAAHdr->FUDI.cbbgr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htapi.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htapi.h


Abstract:

    This module contains all the public defines, constants, structures and
    functions declarations for htapi.c

Author:

    15-Jan-1991 Wed 21:13:21 updated  -by-  Daniel Chou (danielc)
        add in test pattern support

    15-Jan-1991 Tue 21:13:21 created  -by-  Daniel Chou (danielc)
        wrote it



[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/

#ifndef _HTAPI_
#define _HTAPI_

//
// The following are default printer and monitor C.I.E. color space Red,
// Green, Blue, Alignment White's coordinate and its white/black luminance.
//

#define VALID_YC                0xFFFE
#define VALID_YB_DENSITY        0xFFFE
#define MIN_RGB_GAMMA             100
#define MAX_RGB_GAMMA           65500

#define INTENSITY_R             (FD6)212674
#define INTENSITY_G             (FD6)715151
#define INTENSITY_B             (FD6) 72175

#define HT_BRUSH_COLORFULNESS   5

#define HT_K_REF_CLIP           (FD6)0
#define HT_W_REF_CLIP           (FD6)0
#define HT_K_REF_BASE           HT_K_REF_CLIP
#define HT_W_REF_BASE           (FD6_1 - HT_W_REF_CLIP)
#define HT_KW_REF_RANGE         (FD6_1 - (HT_K_REF_CLIP + HT_W_REF_CLIP))
#define HT_K_REF_ADD            (HT_K_REF_CLIP + (FD6)0)
#define HT_W_REF_SUB            (HT_W_REF_CLIP + (FD6)0)

#define DEFAULT_SCR_HTPAT_SIZE  HTPAT_SIZE_SUPERCELL_M


#if 0

CIEINFO CIEInfoSRGBScreen = {

        { 6400, 3300,       0 },    // xr, yr, Yr CIE_NORNAL_MONITOR
        { 3000, 6000,       0 },    // xg, yg, Yg
        { 1500,  600,       0 },    // xb, yb, Yb
        {    0,    0,VALID_YC },    // xc, yc, Yc
        {    0,    0,       0 },    // xm, ym, Ym
        {    0,    0,       0 },    // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }     // xw, yw, Yw
    };

CIEINFO CIEInfoSRGBPrinter = {

        { 6400, 3300,       0 },    // xr, yr, Yr CIE_NORNAL_MONITOR
        { 3000, 6000,       0 },    // xg, yg, Yg
        { 1500,  600,       0 },    // xb, yb, Yb
        {    0,    0,VALID_YC },    // xc, yc, Yc
        {    0,    0,       0 },    // xm, ym, Ym
        {    0,    0,       0 },    // xy, yy, Yy
        { 3457, 3585,UDECI4_1 }     // xw, yw, Yw
    };


CIEINFO CIEInfoNormalMonitor = {

        { 6280, 3475,       0 },    // xr, yr, Yr CIE_NORNAL_MONITOR
        { 2750, 5980,       0 },    // xg, yg, Yg
        { 1480,  625,       0 },    // xb, yb, Yb
        {    0,    0,VALID_YC },    // xc, yc, Yc
        {    0,    0,       0 },    // xm, ym, Ym
        {    0,    0,       0 },    // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }     // xw, yw, Yw
    };


CIEINFO CIEInfoNTSC = {

        { 6700, 3300,       0 },    // xr, yr, Yr CIE_NTSC
        { 2100, 7100,       0 },    // xg, yg, Yg
        { 1250,  800,       0 },    // xb, yb, Yb
        { 1750, 3950,VALID_YC },    // xc, yc, Yc
        { 2550, 2050,       0 },    // xm, ym, Ym
        { 4250, 5200,       0 },    // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }     // xw, yw, Yw
    };


CIEINFO CIEInfoNormalPrinter = {

        { 6380, 3350,       0 },        // xr, yr, Yr
        { 2345, 6075,       0 },        // xg, yg, Yg
        { 1410,  932,       0 },        // xb, yb, Yb
        { 2000, 2450,VALID_YC },        // xc, yc, Yc
        { 5210, 2100,       0 },        // xm, ym, Ym
        { 4750, 5100,       0 },        // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }         // xw, yw, Yw
    };

CIEINFO CIEInfoColorFilm = {

        { 6810, 3050,       0 },        // xr, yr, Yr
        { 2260, 6550,       0 },        // xg, yg, Yg
        { 1810,  500,       0 },        // xb, yb, Yb
        { 2000, 2450,VALID_YC },        // xc, yc, Yc
        { 5210, 2100,       0 },        // xm, ym, Ym
        { 4750, 5100,       0 },        // xy, yy, Yy
        { 3470, 2985,UDECI4_1 }         // xw, yw, Yw
    };

#endif


#ifdef INCLUDE_DEF_CIEINFO


CONST CIEINFO HT_CIE_SRGB = {

        { 6400, 3300,       0 },    // xr, yr, Yr CIE_NORNAL_MONITOR
        { 3000, 6000,       0 },    // xg, yg, Yg
        { 1500,  600,       0 },    // xb, yb, Yb
        {    0,    0,VALID_YC },    // xc, yc, Yc
        {    0,    0,       0 },    // xm, ym, Ym
        {    0,    0,       0 },    // xy, yy, Yy
        { 3127, 3290,UDECI4_1 }     // xw, yw, Yw
    };

CONST SOLIDDYESINFO   DefaultSolidDyesInfo = {

       2720,   1730,    // M/C, Y/C
       1720,   1068,    // C/M, Y/M
        320,    210,    // C/Y, M/Y
    };

#if 0

CONST SOLIDDYESINFO   DefaultSolidDyesInfo = {

        712,    121,    // M/C, Y/C
         86,    468,    // C/M, Y/M
         21,     35     // C/Y, M/Y
    };

#endif

CONST HTCOLORADJUSTMENT   DefaultCA = {

            sizeof(COLORADJUSTMENT),
            0,
            ILLUMINANT_DEFAULT,
            HT_DEF_RGB_GAMMA,
            HT_DEF_RGB_GAMMA,
            HT_DEF_RGB_GAMMA,
                0,
            10000,
            0,
            0,
            0,
            0
    };


#define MAX_RES_PERCENT         15000
#define MIN_RES_PERCENT         333
#define TOT_RES_PERCENT         (MAX_RES_PERCENT - MIN_RES_PERCENT + 1)



#endif

#ifndef _HTUI_CIEINFO_ONLY_


typedef struct _HTTESTDATA {
    WORD    cx;
    WORD    cy;
    FD6     cyRatio;
    LPBYTE  pBitmap;
    } HTTESTDATA, FAR *PHTTESTDATA;

typedef struct _HTTESTINFO {
    COLORTRIAD  ColorTriad;
    PHTTESTDATA pTestData;
    BYTE        SurfaceFormat;
    BYTE        TotalData;
    BYTE        cx;
    BYTE        cy;
    } HTTESTINFO, FAR *PHTTESTINFO;


#define DEFAULT_DENSITY_WHITE       (DECI4)9127
#define DEFAULT_DENSITY_BLACK       (DECI4)478

#define HTAPI_IDX_INIT                          0
#define HTAPI_IDX_CREATE_DHI                    1
#define HTAPI_IDX_DESTROY_DHI                   2
#define HTAPI_IDX_CHB                           3
#define HTAPI_IDX_CCT                           4
#define HTAPI_IDX_CREATE_SMP                    5
#define HTAPI_IDX_HALFTONE_BMP                  6


#if DBG

LONG
HTENTRY
HT_LOADDS
SetHalftoneError(
    DWORD   HT_FuncIndex,
    LONG    ErrorID
    );



#define SET_ERR(a,b)    SetHalftoneError((a),(b))
#define HTAPI_RET(a,b)  return((LONG)(((b)<0) ? SET_ERR((a),(b)) : (b)))

#else

#define SET_ERR(a,b)
#define HTAPI_RET(a,b)  return(b)

#endif

#define HTINITINFO_INITIAL_CHECKSUM     0x1234f012
#define HTSMP_INITIAL_CHECKSUM          0xa819203f

#define MAX_CDCI_COUNT      16
#define MAX_CSMP_COUNT      10


//
// Following are the function prototype
//

BOOL
HTENTRY
CleanUpDHI(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo
    );

PCDCIDATA
HTENTRY
FindCachedDCI(
    PDEVICECOLORINFO    pDCI
    );

BOOL
HTENTRY
AddCachedDCI(
    PDEVICECOLORINFO    pDCI
    );

BOOL
HTENTRY
GetCachedDCI(
    PDEVICECOLORINFO    pDCI
    );

PCSMPBMP
HTENTRY
FindCachedSMP(
    PDEVICECOLORINFO    pDCI,
    UINT                PatternIndex
    );

LONG
HTENTRY
GetCachedSMP(
    PDEVICECOLORINFO    pDCI,
    PSTDMONOPATTERN     pSMP
    );

DWORD
HTENTRY
ComputeHTINITINFOChecksum(
    PDEVICECOLORINFO    pDCI,
    PHTINITINFO         pHTInitInfo
    );


#endif // _HTUI_API_
#endif // _HTAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htgetbmp.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htgetbmp.h


Abstract:

    This module contains all local definitions for the htgetbmp.c


Author:
    28-Mar-1992 Sat 20:54:58 updated  -by-  Daniel Chou (danielc)
        Update it for VGA intensity (16 colors mode), this make all the
        codes update to 4 primaries internal.


    05-Apr-1991 Fri 15:54:23 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/


#ifndef _HTGETBMP_
#define _HTGETBMP_


#define GET_GRAY_RGB(p)     (((DWORD)((PBGR3)(p))->r << 2) +                \
                             ((DWORD)((PBGR3)(p))->g << 3) +                \
                             ((DWORD)((PBGR3)(p))->b     ))




#define SET_NEXT_PIN(pAASI)                                                 \
{                                                                           \
    if (pAASI->Flags & AASIF_INC_PB) {                                      \
                                                                            \
        if ((pAASI->cy == 0)  || (--pAASI->cy == 0)) {  /*  Bug 27036  */     \
                                                                            \
            if (pAASI->Flags & AASIF_TILE_SRC) {                            \
                                                                            \
                pAASI->pb = pAASI->pbOrg;                                   \
                pAASI->cy = pAASI->cyOrg;                                   \
                                                                            \
            } else {                                                        \
                                                                            \
                pAASI->Flags &= ~AASIF_INC_PB;                              \
            }                                                               \
                                                                            \
        } else {                                                            \
                                                                            \
            pAASI->pb += pAASI->cyNext;                                     \
        }                                                                   \
    }                                                                       \
}


#define GET_LBGR(p)     (LONG)(((DWORD)*(DWORD UNALIGNED *)(p)) & 0xFFFFFF)

#define SET_CORNER_BGR(p, c0, c1, c2, c3)                                   \
{                                                                           \
    LONG    cS = GET_LBGR(p);                                               \
                                                                            \
    (p)->b = (BYTE)((((cS & 0x0000FF) << 3) +                               \
                     ((cS & 0x0000FF) << 2) +                               \
                            0x000008 +                                      \
                      (c0 & 0x0000FF) +                                     \
                      (c1 & 0x0000FF) +                                     \
                      (c2 & 0x0000FF) +                                     \
                      (c3 & 0x0000FF)) >> 4);                               \
    (p)->g = (BYTE)((((cS & 0x00FF00) << 3) +                               \
                     ((cS & 0x00FF00) << 2) +                               \
                            0x000800 +                                      \
                      (c0 & 0x00FF00) +                                     \
                      (c1 & 0x00FF00) +                                     \
                      (c2 & 0x00FF00) +                                     \
                      (c3 & 0x00FF00)) >> (4 + 8));                         \
    (p)->r = (BYTE)((((cS & 0xFF0000) << 3) +                               \
                     ((cS & 0xFF0000) << 2) +                               \
                            0x080000 +                                      \
                      (c0 & 0xFF0000) +                                     \
                      (c1 & 0xFF0000) +                                     \
                      (c2 & 0xFF0000) +                                     \
                      (c3 & 0xFF0000)) >> (4 + 16));                        \
}

#define SET_CORNER_GRAY(p, c0, c1, c2, c3)                                  \
{                                                                           \
    LONG    cS = (LONG)*(p);                                                \
                                                                            \
    *(p) = (BYTE)((((cS) << 3) + ((cS) << 2) + 8 +                          \
                   (c0) + (c1) + (c2) + (c3)) >> 4);                        \
}


#define STD_PAL_CY_SKIP         6
#define MAX_FIXUPDIB_PAL        20
#define MIN_FIXUP_SIZE          (48 * 48)
#define MIN_PAL_SIZE            (128 * 128)
#define GET_PAL_CHK_COUNT(x)    ((x) >> 3)
#define GET_PAL_CHK_COUNT2(x)   ((x) >> 4)



#define ZERO_MASK_SCAN(pAAHdr)  ZeroMemory(pAAHdr->pMaskSrc, pAAHdr->cbMaskSrc)

#define GET_MASK_SCAN(pAAHdr)                                               \
{                                                                           \
    LPBYTE  pbSrc = (LPBYTE)pAAHdr->pMaskIn;                                \
    LPBYTE  pbDst = (LPBYTE)pAAHdr->pMaskSrc;                               \
    UINT    cb    = (UINT)pAAHdr->cbMaskSrc;                                \
    UINT    cdw;                                                            \
                                                                            \
    if (pAAHdr->Flags & AAHF_INVERT_MASK) {                                 \
                                                                            \
        cdw  = cb >> 2;                                                     \
        cb  &= 0x03;                                                        \
                                                                            \
        while (cdw--) {                                                     \
                                                                            \
            *((LPDWORD)pbDst)++ = ~*((LPDWORD)pbSrc)++;                     \
        }                                                                   \
                                                                            \
        while (cb--) {                                                      \
                                                                            \
            *pbDst++ = ~*pbSrc++;                                           \
        }                                                                   \
                                                                            \
    } else {                                                                \
                                                                            \
        CopyMemory(pbDst, pbSrc, cb);                                       \
    }                                                                       \
                                                                            \
    if (--pAAHdr->cyMaskIn > 0) {                                           \
                                                                            \
        pAAHdr->pMaskIn += pAAHdr->cyMaskNext;                              \
    }                                                                       \
}


#define OR_MASK_SCAN(pAAHdr)                                                \
{                                                                           \
    LPBYTE  pbSrc = (LPBYTE)pAAHdr->pMaskIn;                                \
    LPBYTE  pbDst = (LPBYTE)pAAHdr->pMaskSrc;                               \
    UINT    cb    = (UINT)pAAHdr->cbMaskSrc;                                \
    UINT    cdw;                                                            \
                                                                            \
    cdw  = cb >> 2;                                                         \
    cb  &= 0x03;                                                            \
                                                                            \
    if (pAAHdr->Flags & AAHF_INVERT_MASK) {                                 \
                                                                            \
        while (cdw--) {                                                     \
                                                                            \
            *((LPDWORD)pbDst)++ |= ~*((LPDWORD)pbSrc)++;                    \
        }                                                                   \
                                                                            \
        while (cb--) {                                                      \
                                                                            \
            *pbDst++ |= ~*pbSrc++;                                          \
        }                                                                   \
                                                                            \
    } else {                                                                \
                                                                            \
        while (cdw--) {                                                     \
                                                                            \
            *((LPDWORD)pbDst)++ |= *((LPDWORD)pbSrc)++;                     \
        }                                                                   \
                                                                            \
        while (cb--) {                                                      \
                                                                            \
            *pbDst++ |= *pbSrc++;                                           \
        }                                                                   \
    }                                                                       \
                                                                            \
    if (--pAAHdr->cyMaskIn > 0) {                                           \
                                                                            \
        pAAHdr->pMaskIn += pAAHdr->cyMaskNext;                              \
    }                                                                       \
}




//
// Function prototypes
//

VOID
HTENTRY
BltAV_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandAV_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkAV_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
BltAV_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
TileAV_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandAV_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkAV_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
BltMask_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandMask_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkMask_CX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
BltMask_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandMask_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkMask_CY(
    PAAHEADER   pAAHdr
    );

PBGR8
HTENTRY
Input1BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
Input4BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
Input8BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
InputPreMul32BPPToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
InputAABFDATAToAA24(
    PAASURFINFO pAASI,
    PBGR8       pInBuf
    );

PBGR8
HTENTRY
GetFixupScan(
    PAAHEADER   pAAHdr,
    PBGR8       pInBuf
    );

BOOL
CheckBMPNeedFixup(
    PDEVICECOLORINFO    pDCI,
    PAAHEADER           pAAHdr,
    PHTSURFACEINFO      pSrcSI,
    PAABBP              pAABBP
    );

VOID
HTENTRY
InitializeFUDI(
    PAAHEADER   pAAHdr
    );

#if DBG

LPSTR
GetAAInputFuncName(
    AAINPUTFUNC AAInputFunc
    );

#endif


#endif  // _HTGETBMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htdebug.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htdebug.h


Abstract:

    This module contains all the debug definitions


Author:
    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        changed DBG_TIMEx structure fields' 'CHAR' type to 'BYTE' type, this
        will make sure if compiled under MIPS the default 'unsigned char' will
        not affect the signed operation on the single 8 bits

    28-Mar-1992 Sat 20:54:09 updated  -by-  Daniel Chou (danielc)
        change DEF_DBGPVAR() marco so MIPS build does not complaint


    20-Feb-1991 Wed 23:06:36 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/


#ifndef _HTDEBUG_
#define _HTDEBUG_


#if DBG

#define TIMER_TOT               0
#define TIMER_SETUP             1
#define TIMER_INPUT             2
#define TIMER_OUTPUT            3
#define TIMER_MASK              4
#define TIMER_LAST              5

#define TIMER_MAX_IDX   TIMER_LAST

typedef struct _DBGTIMER {
    DWORD   Last;
    DWORD   Tot;
    } DBGTIMER, *PDBGTIMER;

LPBYTE
HTENTRY
HT_LOADDS
FD6ToString(
    LONG    Num,
    SHORT   IntDigits,
    WORD    FracDigits
    );

VOID
cdecl
HTENTRY
HT_LOADDS
DbgPrintf(
    LPSTR   pStr,
    ...
    );

VOID
HTENTRY
HT_LOADDS
_MyAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    WORD    LineNo
    );

LPSTR
HTENTRY
HT_LOADDS
DbgTimeString(
    UINT    Idx
    );


#if defined(_OS2_) || defined(_OS_20_) || defined(_DOS_)

#ifdef _DOS_                    // if Dos Win3

VOID
FAR PASCAL
DebugBreak(
    VOID
    );

#define DEBUGOUTPUTFUNC(x)  OutputDebugString(x)

#else   // if OS2

VOID
HTENTRY
DebugBreak(
    VOID
    );

VOID
FAR PASCAL
DebugOutput(
    LPSTR   pStr
    );

#define DEBUGOUTPUTFUNC(x)  DebugOutput(x)

#endif

#define DBG_INSERT_CR_TO_LF


#else   // OS2/DOS


#undef ASSERTMSG
#undef ASSERT

#ifdef UMODE
    #define DEBUGOUTPUTFUNC(x)  OutputDebugString(x)
#else
    void  DrvDbgPrint(
        char * pch,
        ...);

    #define DEBUGOUTPUTFUNC(x)  DrvDbgPrint(x)
#endif

#define DBG_INSERT_CR_TO_LF

#endif  // OS2/DOS

#define ASSERTMSG(msg, exp)     \
                    if (!(exp)) { _MyAssert(msg, #exp, __FILE__, __LINE__); }

#define ASSERT(exp)             ASSERTMSG("-ERROR-",(exp))

#ifdef UMODE
    #define DBGSTOP()               DebugBreak()
#else
    #define DBGSTOP()               EngDebugBreak()
#endif

#define ARG(x)                  ,(x)
#define ARGB(x)                 ,(BYTE)(x)
#define ARGC(x)                 ,(CHAR)(x)
#define ARGW(x)                 ,(WORD)(x)
#define ARGS(x)                 ,(SHORT)(x)
#define ARGU(x)                 ,(UINT)(x)
#define ARGI(x)                 ,(INT)(x)
#define ARGDW(x)                ,(DWORD)(x)
#define ARGL(x)                 ,(LONG)(x)
#define ARGPTR(x)               ,(LPVOID)(x)
#define ARGFD6(x, i, f)         ,FD6ToString((FD6)(x),(SHORT)(i),(WORD)(f))
#define ARGFD6s(x)              ARGFD6(x,0,0)
#define ARGFD6l(x)              ARGFD6(x,5,6)
#define ARGTIME(i)             ,DbgTimeString(i)

#define DBGP(y)                 DbgPrintf(y)
#define DBGMSG(y)               DbgPrintf(y); DbgPrintf("\n");

#define DEFDBGVAR(type, val)    type val;
#define SETDBGVAR(name, val)    name=val

extern UINT     DbgTimerIdx;
extern DBGTIMER DbgTimer[TIMER_MAX_IDX + 1];


#ifdef UMODE
    #define GET_TICK            (DWORD)GetTickCount()
#else
    #define GET_TICK            (DWORD)0
#endif


#define DBG_TIMER_BEG(i)        DbgTimer[DbgTimerIdx=i].Last=GET_TICK
#define DBG_TIMER_END(i)        DbgTimer[i].Tot+=GET_TICK-DbgTimer[i].Last; \
                                DbgTimerIdx = TIMER_LAST
#define DBG_TIMER_RESET         ZeroMemory(DbgTimer, sizeof(DbgTimer));     \
                                DbgTimerIdx=TIMER_LAST;                     \
                                DbgTimer[TIMER_TOT].Last=GET_TICK

//
// The following macros used for the DBGP_IF()
//

#ifdef DBGP_VARNAME

#define DEF_DBGPVAR(x)   DWORD DBGP_VARNAME = (x);
#define DBGP_IF(v,y)     if ((v) && ((v) & DBGP_VARNAME)) { y; }

#else

#define DEF_DBGPVAR(x)
#define DBGP_IF(v,y)

#endif


#ifdef NODBGMSG

#undef  DBGP
#undef  DBGMSG

#define DBGMSG(x)
#define DBGP(y)

#endif  // NODBGMSG


#else   // DBG != 0

#define ARG(x)
#define ARGB(x)
#define ARGC(x)
#define ARGW(x)
#define ARGS(x)
#define ARGU(x)
#define ARGI(x)
#define ARGDW(x)
#define ARGL(x)
#define ARGFD6(x, i, f)
#define ARGFD6s(x)
#define ARGFD6l(x)
#define ARGTIME(i)

#define DBGSTOP()
#define DBGMSG(x)
#define DBGP(y)

#define DEFDBGVAR(type, val)
#define SETDBGVAR(name, val)

#define DBG_TIMER_BEG(i)
#define DBG_TIMER_END(i)
#define DBG_TIMER_RESET

#define DEF_DBGPVAR(x)
#define DBGP_IF(v,y)


#define ASSERT(exp)
#define ASSERTMSG(msg,exp)


#endif  // DBG != 0


#endif // _HTDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htdebug.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htdebug.c


Abstract:

    This module contains the debug functions


Author:
    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        changed 'CHAR' type to 'BYTE' type, this will make sure if compiled
        under MIPS the default 'unsigned char' will not affect the signed
        operation on the single 8 bits


    28-Mar-1992 Sat 20:53:29 updated  -by-  Daniel Chou (danielc)
        Modify sprintf for by not using va_start

    20-Feb-1991 Wed 23:06:09 created  -by-  Daniel Chou (danielc)



[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/




#if DBG

#include <htp.h>
#include <string.h>
#include <time.h>

#include "htdebug.h"
#include "stdio.h"


UINT        DbgTimerIdx = TIMER_LAST;
DBGTIMER    DbgTimer[TIMER_MAX_IDX + 1];




LPBYTE
HTENTRY
HT_LOADDS
FD6ToString(
    LONG    Num,
    SHORT   IntDigits,
    WORD    FracDigits
    )
{
#define DBG_ONE_FD6_STR_SIZE    13
#define DBG_FD6_STR_MAX         20
#define DBG_FD6_STR_SIZE        (DBG_ONE_FD6_STR_SIZE * DBG_FD6_STR_MAX)
#define DBG_FD6_LAST_STR_IDX    (DBG_ONE_FD6_STR_SIZE * (DBG_FD6_STR_MAX-1))

    static  WORD Rounding[]        = { 50000, 5000, 500, 50, 5 };
    static  WORD DbgFD6StringIndex = 0;
    static  BYTE DbgFD6Strings[DBG_FD6_STR_SIZE + 2];


    LPBYTE  pFD6Str;
    LPBYTE  pb;
    DWORD   Number;
    INT     Loop;
    BOOL    Sign;
#ifdef UMODE
    DWORD   dw = GET_TICK;
#endif

    //
    // Check before using it
    //

    if ((DbgFD6StringIndex += DBG_ONE_FD6_STR_SIZE) > DBG_FD6_LAST_STR_IDX) {

        DbgFD6StringIndex = 0;          // Reset
    }

    pFD6Str = &DbgFD6Strings[DbgFD6StringIndex];


    if (Sign = (BOOL)(Num < 0)) {

        Number = (DWORD)-Num;

    } else {

        Number = (DWORD)Num;
    }

    if (FracDigits) {

        if (FracDigits < 6) {

            Num += (LONG)Rounding[FracDigits];

        } else {

            FracDigits = 6;
        }
    }

    sprintf(pFD6Str, "%5u.%06ld", (UINT)(Number / 1000000L), Number % 1000000L);

    if (!FracDigits) {

        pb         = pFD6Str + 11;
        Loop       = (INT)5;
        FracDigits = 6;

        while ((Loop--) && (*pb-- == (BYTE)'0')) {

            --FracDigits;
        }
    }

    *(pFD6Str + 6 + FracDigits) = (BYTE)0;
    pFD6Str += 4;

    if (IntDigits > 5) {

        IntDigits = 5;
    }

    while (*pFD6Str != (BYTE)' ') {

        --IntDigits;
        --pFD6Str;
    }

    if (Sign) {

        --IntDigits;
        *pFD6Str = '-';

    } else {

        ++pFD6Str;
    }

#ifdef UMODE
    dw                          = GET_TICK - dw;
    DbgTimer[DbgTimerIdx].Last += dw;
    DbgTimer[TIMER_TOT].Last   += dw;
#endif

    return((LPBYTE)((IntDigits > 0) ? pFD6Str - IntDigits : pFD6Str));

#undef DBG_ONE_FD6_STR_SIZE
#undef DBG_FD6_STR_MAX
#undef DBG_FD6_STR_SIZE
#undef DBG_FD6_LAST_STR_IDX
}


VOID
cdecl
HTENTRY
HT_LOADDS
DbgPrintf(
    LPSTR   pStr,
    ...
    )
{
    va_list     vaList;
    BYTE        Buf[256];
#ifdef UMODE
    DWORD   dw = GET_TICK;
#endif

    va_start(vaList, pStr);
    vsprintf(Buf, pStr, vaList);
    va_end(vaList);

#ifdef DBG_INSERT_CR_TO_LF

    {
    LPBYTE      pBufCurrent;
    LPBYTE      pBufNext;


    pBufCurrent = (LPBYTE)Buf;

    while (pBufCurrent) {

        if (pBufNext = (LPBYTE)strchr(pBufCurrent, 0x0a)) {

            *pBufNext++ = 0x00;
            DEBUGOUTPUTFUNC(pBufCurrent);
            DEBUGOUTPUTFUNC("\r\n");

        } else {

            DEBUGOUTPUTFUNC(pBufCurrent);
        }

        pBufCurrent = pBufNext;
    }

    DEBUGOUTPUTFUNC("\r\n");
    }

#else  // DBG_INSERT_CR_TO_LF

    DEBUGOUTPUTFUNC(Buf);

#endif // DBG_INSERT_CR_TO_LF


#ifdef UMODE
    dw                          = GET_TICK - dw;
    DbgTimer[DbgTimerIdx].Last += dw;
    DbgTimer[TIMER_TOT].Last   += dw;
#endif

}



VOID
HTENTRY
HT_LOADDS
_MyAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    WORD    LineNo
    )
{
#ifdef UMODE
    DWORD   dw = GET_TICK;
#endif

    DbgPrintf("\n*   Assertion Failed: %s", pMsg);
    DbgPrintf("*   False Expression: %s", pFalseExp);
    DbgPrintf("*    Failed Filename: %s", pFilename);
    DbgPrintf("* Failed Line Number: %u\n\n", LineNo);

    DBGSTOP();

#ifdef UMODE
    dw                          = GET_TICK - dw;
    DbgTimer[DbgTimerIdx].Last += dw;
    DbgTimer[TIMER_TOT].Last   += dw;
#endif

}



LPSTR
HTENTRY
HT_LOADDS
DbgTimeString(
    UINT    Idx
    )
{
#define DBG_ONE_TIME_STR_SIZE   12
#define DBG_TIME_STR_MAX        (TIMER_MAX_IDX + 1)
#define DBG_TIME_STR_SIZE       (DBG_ONE_TIME_STR_SIZE * DBG_TIME_STR_MAX)
#define DBG_TIME_LAST_STR_IDX   (DBG_ONE_TIME_STR_SIZE * (DBG_TIME_STR_MAX-1))

    static  WORD DbgTimeStringIndex = 0;
    static  BYTE DbgTimeStrings[DBG_TIME_STR_SIZE + 2];
    LPSTR   pTimeStr;
    DWORD   Time;
    UINT    Second;

    if ((DbgTimeStringIndex += DBG_ONE_TIME_STR_SIZE) > DBG_TIME_LAST_STR_IDX) {

        DbgTimeStringIndex = 0;          // Reset
    }

    pTimeStr = &DbgTimeStrings[DbgTimeStringIndex];

    if ((Time = DbgTimer[Idx].Tot) >= 1000L) {

        Second = (UINT)(Time / 1000L);
        Time  %= 1000L;

    } else {

        Second = 0;
    }

    sprintf(pTimeStr, "%2u.%03u", Second, Time);
    return(pTimeStr);


#undef DBG_ONE_TIME_STR_SIZE
#undef DBG_TIME_STR_MAX
#undef DBG_TIME_STR_SIZE
#undef DBG_TIME_LAST_STR_IDX
}

#if defined(_OS2_) || defined(_OS_20_)


VOID
HTENTRY
DebugBreak(
    VOID
    )
{
    _asm
    {
        int 3h
    }
}

#endif  // _OS2_

#ifndef UMODE

void  DrvDbgPrint(
    char * pch,
    ...)
{
    va_list ap;
    va_start(ap, pch);

    EngDebugPrint("",pch,ap);

    va_end(ap);
}

#endif

#endif  // DBG != 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htmapclr.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmapclr.c


Abstract:

    This module contains low levels functions which map the input color to
    the dyes' densities.


Author:

    29-Jan-1991 Tue 10:28:20 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]

    1. In the near future we will also allowed the XYZ/LAB to be specified in
       the color table


Revision History:


--*/

#define DBGP_VARNAME        dbgpHTMapClr

#include "htp.h"
#include "htmapclr.h"
#include "htrender.h"
#include "htmath.h"
#include "htapi.h"
#include "htpat.h"
#include "htalias.h"


#define DBGP_SHOWXFORM_RGB      0x00000001
#define DBGP_SHOWXFORM_ALL      0x00000002
#define DBGP_CIEMATRIX          0x00000004
#define DBGP_CSXFORM            0x00000008
#define DBGP_CCT                0x00000010
#define DBGP_DYE_CORRECT        0x00000020
#define DBGP_HCA                0x00000040
#define DBGP_PRIMARY_ORDER      0x00000080
#define DBGP_CACHED_GAMMA       0x00000100
#define DBGP_RGBLUTAA           0x00000200
#define DBGP_SCALE_RGB          0x00000400
#define DBGP_MONO_PRIM          0x00000800
#define DBGP_PRIMADJFLAGS       0x00001000
#define DBGP_CELLGAMMA          0x00002000
#define DBGP_CONST_ALPHA        0x00004000
#define DBGP_BGRMAPTABLE        0x00008000


DEF_DBGPVAR(BIT_IF(DBGP_SHOWXFORM_RGB,  0)  |
            BIT_IF(DBGP_SHOWXFORM_ALL,  0)  |
            BIT_IF(DBGP_CIEMATRIX,      0)  |
            BIT_IF(DBGP_CSXFORM,        0)  |
            BIT_IF(DBGP_CCT,            0)  |
            BIT_IF(DBGP_DYE_CORRECT,    0)  |
            BIT_IF(DBGP_HCA,            0)  |
            BIT_IF(DBGP_PRIMARY_ORDER,  0)  |
            BIT_IF(DBGP_CACHED_GAMMA,   0)  |
            BIT_IF(DBGP_RGBLUTAA,       0)  |
            BIT_IF(DBGP_SCALE_RGB,      0)  |
            BIT_IF(DBGP_MONO_PRIM,      0)  |
            BIT_IF(DBGP_PRIMADJFLAGS,   0)  |
            BIT_IF(DBGP_CELLGAMMA,      0)  |
            BIT_IF(DBGP_CONST_ALPHA,    0)  |
            BIT_IF(DBGP_BGRMAPTABLE,    0))


extern  HTCOLORADJUSTMENT   DefaultCA;
extern  CONST LPBYTE        p8BPPXlate[];
extern  HTGLOBAL            HTGlobal;


#define FD6_p25             (FD6_5 / 2)
#define FD6_p75             (FD6_p25 * 3)
#define JND_ADJ(j,x)        RaisePower((j), (FD6)(x), RPF_INTEXP)

#define FD6_p1125           (FD6)112500
#define FD6_p225            (FD6)225000
#define FD6_p325            (FD6)325000
#define FD6_p55             (FD6)550000
#define FD6_p775            (FD6)775000



const FD6     SinNumber[] = {

                 0,  17452,  34899,  52336,  69756,   // 0
             87156, 104528, 121869, 139173, 156434,   // 5.0
            173648, 190809, 207912, 224951, 241922,   // 10
            258819, 275637, 292372, 309017, 325568,   // 15.0
            342020, 358368, 374607, 390731, 406737,   // 20
            422618, 438371, 453990, 469472, 484810,   // 25.0
            500000, 515038, 529919, 544639, 559193,   // 30
            573576, 587785, 601815, 615661, 629320,   // 35.0
            642788, 656059, 669131, 681998, 694658,   // 40
            707107, 719340, 731354, 743145, 754710,   // 45.0
            766044, 777146, 788011, 798636, 809017,   // 50
            819152, 829038, 838671, 848048, 857167,   // 55.0
            866025, 874620, 882948, 891007, 898794,   // 60
            906308, 913545, 920505, 927184, 933580,   // 65.0
            939693, 945519, 951057, 956305, 961262,   // 70
            965926, 970296, 974370, 978148, 981627,   // 75.0
            984808, 987688, 990268, 992546, 994522,   // 80
            996195, 997564, 998630, 999391, 999848,   // 85.0
            1000000
        };


#define CLAMP_0(x)              if ((x) < FD6_0) { (x) = FD6_0; }
#define CLAMP_1(x)              if ((x) > FD6_1) { (x) = FD6_1; }
#define CLAMP_01(x)             CLAMP_0(x) else CLAMP_1(x)
#define CLAMP_PRIMS_0(a,b,c)    CLAMP_0(a); CLAMP_0(b); CLAMP_0(c)
#define CLAMP_PRIMS_1(a,b,c)    CLAMP_1(a); CLAMP_1(b); CLAMP_1(c)
#define CLAMP_PRIMS_01(a,b,c)   CLAMP_01(a); CLAMP_01(b); CLAMP_01(c)


FD6 LogFilterMax = 0;

#if 0
#define LOG_FILTER_RATIO            4
#else
#define LOG_FILTER_RATIO            7
#endif

#define LOG_FILTER_POWER            (FD6)1200000
#define PRIM_LOG_RATIO(p)           Log(FD6xL((p), LOG_FILTER_RATIO) + FD6_1)

#define PRIM_CONTRAST(p,adj)        (p)=MulFD6((p), (adj).Contrast)
#define PRIM_BRIGHTNESS(p,adj)      (p)+=((adj).Brightness)
#define PRIM_COLORFULNESS(a,b,adj)  (a)=MulFD6((a),(adj).Color);            \
                                    (b)=MulFD6((b),(adj).Color)
#define PRIM_TINT(a,b,t,adj)        (t)=(a);                                \
                                    (a)=MulFD6((a),(adj).TintCosAngle) -    \
                                        MulFD6((b),(adj).TintSinAngle);     \
                                    (b)=MulFD6((t),(adj).TintSinAngle) +    \
                                        MulFD6((b),(adj).TintCosAngle)
#if 0
#define PRIM_LOG_FILTER(p)                                                  \
(p)=FD6_1-Power(FD6_1-DivFD6(PRIM_LOG_RATIO(p),LogFilterMax),LOG_FILTER_POWER)
#else
#define PRIM_LOG_FILTER(p)          (p)=DivFD6(PRIM_LOG_RATIO(p),LogFilterMax)
#endif

#define PRIM_BW_ADJ(p,adj)                                                  \
{                                                                           \
    if ((p) <= (adj).MinL) {                                                \
                                                                            \
        (p) = MulFD6(p, (adj).MinLMul);                                     \
                                                                            \
    } else if ((p) >= (adj).MaxL) {                                         \
                                                                            \
        (p) = HT_W_REF_BASE + MulFD6((p)-(adj).MaxL, (adj).MaxLMul);        \
                                                                            \
    } else {                                                                \
                                                                            \
        (p) = HT_K_REF_BASE + MulFD6((p)-(adj).MinL, (adj).RangeLMul);      \
    }                                                                       \
}


#define COMP_CA(pca1,pca2)          CompareMemory((LPBYTE)(pca1),           \
                                                  (LPBYTE)(pca2),           \
                                                  sizeof(HTCOLORADJUSTMENT))
#define ADJ_CA(a,min,max)           if (a < min) { a = min; } else  \
                                    if (a > max) { a = max; }

#define GET_CHECKSUM(c, f)      (c)=ComputeChecksum((LPBYTE)&(f),(c),sizeof(f))
#define PRIM_GAMMA_ADJ(p,g)     (p)=Power((p),(g))


#define NO_NEGATIVE_RGB_SCALE       0

#if NO_NEGATIVE_RGB_SCALE
#define SCALE_PRIM_RGB(pPrim,py)    ScaleRGB((pPrim))
#else
#define SCALE_PRIM_RGB(pPrim,py)    ScaleRGB((pPrim), (py))
#endif


#define SET_CACHED_CMI_CA(ca)                                           \
{                                                                       \
    (ca).caFlags         &= ~(CLRADJF_LOG_FILTER |                      \
                              CLRADJF_NEGATIVE);                        \
    (ca).caRedGamma       =                                             \
    (ca).caGreenGamma     =                                             \
    (ca).caBlueGamma      = 0;                                          \
    (ca).caReferenceBlack = 0x1234;                                     \
    (ca).caReferenceWhite = 0x5678;                                     \
    (ca).caContrast       = (SHORT)0xABCD;                              \
    (ca).caBrightness     = (SHORT)0xFFFF;                              \
}


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// The following macros used in Color space transform functions, these macros
// are used to compute CIELAB X/Xw, Y/Yw, Z/Zw when its values is less
// than 0.008856
//
//               1/3
//  fX = (X/RefXw)   - (16/116)     (X/RefXw) >  0.008856
//  fX = 7.787 x (X/RefXw)          (X/RefXw) <= 0.008856
//
//               1/3
//  fY = (Y/RefYw)   - (16/116)     (Y/RefYw) >  0.008856
//  fY = 7.787 x (Y/RefYw)          (Y/RefYw) <= 0.008856
//
//               1/3
//  fZ = (Z/RefZw)   - (16/116)     (Z/RefZw) >  0.008856
//  fZ = 7.787 x (Z/RefZw)          (Z/RefZw) <= 0.008856
//
//
//                       1/3
//  Thresholds at 0.008856   - (16/116) = 0.068962
//                7.787 x 0.008856      = 0.068962
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#define NORM_XYZ(xyz, w)    (FD6)(((w)==FD6_1) ? (xyz) : DivFD6((xyz), (w)))

#define fXYZFromXYZ(f,n,w)  (f) = ((((f)=NORM_XYZ((n),(w))) >= FD6_p008856) ? \
                                    (CubeRoot((f))) :                         \
                                    (MulFD6((f), FD6_7p787) + FD6_16Div116))

#define XYZFromfXYZ(n,f,w)  (n)=((f)>(FD6)206893) ?                          \
                                (Cube((f))) :                                \
                                (DivFD6((f) - FD6_16Div116, FD6_7p787));                   \
                            if ((w)!=FD6_1) { (n)=MulFD6((n),(w)); }


//
// Following #defines are used in  ComputeColorSpaceXForm, XFormRGB_XYZ_UCS()
// and XFormUCS_XYZ_RGB() functions for easy referenced.
//

#define CSX_AUw(XForm)      XForm.AUw
#define CSX_BVw(XForm)      XForm.BVw
#define CSX_RefXw(XForm)    XForm.WhiteXYZ.X
#define CSX_RefYw(XForm)    FD6_1
#define CSX_RefZw(XForm)    XForm.WhiteXYZ.Z

#define iAw                 CSX_AUw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iBw                 CSX_BVw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iUw                 CSX_AUw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iVw                 CSX_BVw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iRefXw              CSX_RefXw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iRefYw              CSX_RefYw(pDevClrAdj->PrimAdj.rgbCSXForm)
#define iRefZw              CSX_RefZw(pDevClrAdj->PrimAdj.rgbCSXForm)

#define oAw                 CSX_AUw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oBw                 CSX_BVw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oUw                 CSX_AUw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oVw                 CSX_BVw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oRefXw              CSX_RefXw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oRefYw              CSX_RefYw(pDevClrAdj->PrimAdj.DevCSXForm)
#define oRefZw              CSX_RefZw(pDevClrAdj->PrimAdj.DevCSXForm)



CONST CIExy2 StdIlluminant[ILLUMINANT_MAX_INDEX] = {

        { (UDECI4)4476, (UDECI4)4074 },     //  A   Tungsten
        { (UDECI4)3489, (UDECI4)3520 },     //  B   Noon Sun
        { (UDECI4)3101, (UDECI4)3162 },     //  C   NTSC
        { (UDECI4)3457, (UDECI4)3585 },     // D50  Plain Paper
        { (UDECI4)3324, (UDECI4)3474 },     // D55  White Bond Paper
        { (UDECI4)3127, (UDECI4)3290 },     // D65  Standard Sun
        { (UDECI4)2990, (UDECI4)3149 },     // D75  Northern Sun
        { (UDECI4)3721, (UDECI4)3751 }      //  F2  Cool White
    };

CONST REGDATA RegData[] = {

    { 9,251,35000,950000,100840336,68627450,31372549,100745314,40309045 },
    { 8,249,45000,930000, 69716775,66386554,33613445,101097041,42542759 },
    { 7,247,55000,910000, 49910873,65141612,34858387,101555706,44600305 },
    { 6,245,65000,890000, 36199095,64349376,35650623,102121877,46557500 },
    { 5,243,75000,870000, 26143790,63800904,36199095,102799050,48461978 },
    { 4,241,85000,850000, 18454440,63398692,36601307,103595587,50361904 },
    { 3,239,95000,830000, 12383900,63091118,36908881,104537807,52367907 }
};

//
//
// REG_L_MIN    = 0.075
// REG_L_MAX    = 0.8500
// REG_D255MIN  = 7
// REG_D255MAX  = 248 (255 - 7)
//
//                  iP        7
// REG_DMIN_MUL = ------- * -----
//                 0.075     255
//
//              = iP * 0.366013
//              = (iP * 36.601307) / 100
//
//
//                 248       iP - 0.8500      7
// REG_DMAX_MUL = ----- + ( ------------- * ----- )
//                 255          0.1500       255
//
//              = 0.972549 + (0.183007 * iP) - 0.155556
//              = 0.816993 + (0.183007 * iP)
//                ~~~~~~~~    ~~~~~~~~
//              = (81.699346  + (18.300654 * iP)) / 100;
//
//
//
//                 7        X - RegLogSub       241
// REG_DEN_MUL = ----- + ((--------------- ) * ----- )
//                255       RegLogRange         255
//
//                 7        X - RegLogSub       241
//             = ----- + ((--------------- ) * ----- )
//                255       RegLogRange         255
//
//                 7        X - -2.080771       241
//             = ----- + ((--------------- ) * ----- )
//                255          1.900361         255
//
//                 7        X + 2.080771       241
//             = ----- + ((-------------- ) * ----- )
//                255          1.900361        255
//
//                 7        X + 2.080771       241
//             = ----- + ((-------------- ) * ----- )
//                255          1.900361        255
//
//             = 0.027451 + (( X + 2.080771) * 0.49736)
//             = 0.027451 + ( 0.49736X + 1.034820)
//             = 0.027451 + 0.49736X + 1.034820
//             = 0.497326X + 1.062271
//             = (49.732555 X + 106.227145) / 100
//
//
//  X           = Log(CIE_L2I(iP)),
//  RegLogMin   = Log(CIE_L2I(REG_L_MIN)) = Log(CIE_L2I(0.075)) = -2.080771
//  RegLogMax   = Log(CIE_L2I(REG_L_MAX)) = Log(CIE_L2I(0.85))  = -0.180410
//  RegLogSub   = -2.080771
//  RegLogRange = -0.180410 - -2.080771 = 1.900361
//

//
// Standard Illuminant Coordinates and its tristimulus values
//
// Illuminant      x          y          X         Y         Z
//------------ ---------- ---------- --------- --------- ---------
//    EQU       0.333333   0.333333   100.000   100.000   100.000
//     A        0.447573   0.407440   109.850   100.000    35.585
//     B        0.348904   0.352001    99.120   100.000    84.970
//     C        0.310061   0.316150    98.074   100.000   118.232
//    D50       0.345669   0.358496    96.422   100.000    82.521
//    D55       0.332424   0.347426    95.682   100.000    92.149
//    D65       0.312727   0.329023    95.047   100.000   108.883
//    D75       0.299021   0.314852    94.972   100.000   122.638
//     F2       0.372069   0.375119    99.187   100.000    67.395
//     F7       0.312852   0.329165    95.044   100.000   108.755
//    F11       0.380521   0.376881   100.966   100.000    64.370
//-----------------------------------------------------------------
//

//
// This is the Source RGB order in Halftone's order, ORDER_ABC, where A is
// lowest memory location and C is the highest memory location
//

const RGBORDER   SrcOrderTable[PRIMARY_ORDER_MAX + 1] = {

                { PRIMARY_ORDER_RGB, { 0, 1, 2 } },
                { PRIMARY_ORDER_RBG, { 0, 2, 1 } },
                { PRIMARY_ORDER_GRB, { 1, 0, 2 } },
                { PRIMARY_ORDER_GBR, { 2, 0, 1 } },
                { PRIMARY_ORDER_BGR, { 2, 1, 0 } },
                { PRIMARY_ORDER_BRG, { 1, 2, 0 } }
            };

//
// This is the destination RGB order in Halftone's order, ORDER_ABC, where C is
// lowest memory location and A is the highest memory location
//

const RGBORDER   DstOrderTable[PRIMARY_ORDER_MAX + 1] = {

                { PRIMARY_ORDER_RGB, { 2, 1, 0 } },
                { PRIMARY_ORDER_RBG, { 2, 0, 1 } },
                { PRIMARY_ORDER_GRB, { 1, 2, 0 } },
                { PRIMARY_ORDER_GBR, { 0, 2, 1 } },
                { PRIMARY_ORDER_BGR, { 0, 1, 2 } },
                { PRIMARY_ORDER_BRG, { 1, 0, 2 } }
            };


#define SRC_BF_HT_RGB       0
#define SRC_TABLE_BYTE      1
#define SRC_TABLE_WORD      2
#define SRC_TABLE_DWORD     3


#if DBG


const LPBYTE  pCBFLUTName[] = { "CBFLI_16_MONO",
                                "CBFLI_24_MONO",
                                "CBFLI_32_MONO",
                                "CBFLI_16_COLOR",
                                "CBFLI_24_COLOR",
                                "CBFLI_32_COLOR" };

const LPBYTE  pSrcPrimTypeName[] = { "SRC_BF_HT_RGB",
                                     "SRC_TABLE_BYTE",
                                     "SRC_TABLE_WORD",
                                     "SRC_TABLE_DWORD" };

const LPBYTE  pDbgCSName[]  = { "LUV", "LAB" };
const LPBYTE  pDbgCMIName[] = { "TABLE:MONO",  "TABLE:COLOR",
                                "HT555:MONO",  "HT555:COLOR" };
#endif

DWORD   dwABPreMul[256] = { 0xFFFFFFFF };


VOID
GenCMYMaskXlate(
    LPBYTE      pbXlate,
    BOOL        CMYInverted,
    LONG        cC,
    LONG        cM,
    LONG        cY
    )

/*++

Routine Description:

    This function generate xlate table for 332 format which CMYMask Mode 3-255


Arguments:




Return Value:




Author:

    08-Sep-2000 Fri 17:57:02 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    iC;
    LONG    iM;
    LONG    iY;
    LONG    IdxDup;
    LONG    Clr;
    LONG    MaxC;
    LONG    MaxM;
    LONG    MaxIdx;
    LONG    IdxC;
    LONG    IdxM;
    LONG    IdxY;


    MaxC   = (cM + 1) * (cY + 1);
    MaxM   = (cY + 1);
    MaxIdx = (cC + 1) * (cM + 1) * (cY + 1);

    if ((MaxIdx >= 1) && (MaxIdx <= 256) && (CMYInverted)) {

        if (MaxIdx & 0x01) {

            IdxDup = MaxIdx / 2;
            ++MaxIdx;

        } else {

            IdxDup = 0x200;
        }

        MaxIdx += ((256 - MaxIdx) / 2) - 1;

        for (iC = 0, IdxC = -MaxC; iC <= 7; iC++) {

            if (iC <= cC) {

                IdxC += MaxC;
            }

            for (iM = 0, IdxM = -MaxM; iM <= 7; iM++) {

                if (iM <= cM) {

                    IdxM += MaxM;
                }

                for (iY = 0, IdxY = -1; iY <= 3; iY++) {

                    if (iY <= cY) {

                        ++IdxY;
                    }

                    if ((Clr = IdxC + IdxM + IdxY) > IdxDup) {

                        ++Clr;
                    }

                    *pbXlate++ = (BYTE)(MaxIdx - Clr);
                }
            }
        }

    } else {

        for (iC = 0; iC < 256; iC++) {

            *pbXlate++ = (BYTE)iC;
        }
    }
}



VOID
HTENTRY
TintAngle(
    LONG    TintAdjust,
    LONG    AngleStep,
    PFD6    pSin,
    PFD6    pCos
    )

/*++

Routine Description:

    This function return a sin/cos number for the tint adjust, these returned
    numbers are used to rotate the color space.

Arguments:

    TintAdjust  - Range from -100 to 100

    AngleStep   - Range from 1 to 10

    pSin        - Pointer to a FD6 number to store the SIN result

    pCos        - Pointer to a FD6 number to store the COS result

Return Value:

    no return value, but the result is stored in pSin/pCos

Author:

    13-Mar-1992 Fri 15:58:30 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Major;
    LONG    Minor;
    BOOL    PosSin;
    BOOL    PosCos = TRUE;
    FD6     Sin;
    FD6     Cos;


    if (PosSin = (BOOL)(TintAdjust <= 0)) {

        if (!(TintAdjust = (LONG)-TintAdjust)) {

            *pSin = *pCos = (FD6)0;
            return;
        }
    }

    if (TintAdjust > 100) {

        TintAdjust = 100;
    }

    if ((AngleStep < 1) || (AngleStep > 10)) {

        AngleStep = 10;
    }

    if ((TintAdjust *= AngleStep) >= 900) {

        TintAdjust = 1800L - TintAdjust;
        PosCos     = FALSE;
    }

    //
    // Compute the Sin portion
    //

    Major = TintAdjust / 10L;
    Minor = TintAdjust % 10L;

    Sin = SinNumber[Major];

    if (Minor) {

        Sin += (FD6)((((LONG)(SinNumber[Major+1] - Sin) * Minor) + 5L) / 10L);
    }

    *pSin = (PosSin) ? Sin : -Sin;

    //
    // Compute the cosine portion
    //

    if (Minor) {

        Minor = 10 - Minor;
        ++Major;
    }

    Major = 90 - Major;

    Cos = SinNumber[Major];

    if (Minor) {

        Cos += (FD6)((((LONG)(SinNumber[Major+1] - Cos) * Minor) + 5L) / 10L);
    }

    *pCos = (PosCos) ? Cos : -Cos;
}




#define DO_DEST_GAMMA   1
#define DO_SS_GAMMA     0



BOOL
HTENTRY
AdjustSrcDevGamma(
    PDEVICECOLORINFO    pDCI,
    PPRIMADJ            pPrimAdj,
    PHTCOLORADJUSTMENT  pca,
    BYTE                DestSurfFormat,
    WORD                AdjForceFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Jan-1997 Wed 12:34:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FD6         SrcGamma[3];
    FD6         DevGamma[3];
    FD6         PelGamma;
    DWORD       Flags;
    BOOL        Changed;



    Changed          = FALSE;
    Flags            = 0;
    SrcGamma[0]      = DivFD6((FD6)pca->caRedGamma,    (FD6)HT_DEF_RGB_GAMMA);
    SrcGamma[1]      = DivFD6((FD6)pca->caGreenGamma,  (FD6)HT_DEF_RGB_GAMMA);
    SrcGamma[2]      = DivFD6((FD6)pca->caBlueGamma,   (FD6)HT_DEF_RGB_GAMMA);
    PelGamma         = FD6_1;
    pPrimAdj->Flags &= ~DCA_DO_DEVCLR_XFORM;


    if (AdjForceFlags & ADJ_FORCE_ICM) {

        Flags       |= DCA_HAS_ICM;
        DevGamma[0]  =
        DevGamma[1]  =
        DevGamma[2]  = FD6_1;

        //
        // ??? LATER - We may have to turn off ALL gamma correction here
        //

        DBGP_IF(DBGP_CELLGAMMA, DBGP("--- DCA_HAS_ICM ---"));

    } else {

        FD6 GammaMul = FD6_1;


        if (pDCI->Flags & DCIF_ADDITIVE_PRIMS) {

            //
            // Screen Devices
            //

            switch (DestSurfFormat) {

            case BMF_1BPP:
            case BMF_4BPP:
            case BMF_4BPP_VGA16:

                //
                // Since we only have two levels (on/off) we will simulate the
                // 16bpp's darker output
                //

                DevGamma[0]            =
                DevGamma[1]            =
                DevGamma[2]            = 1325000;
                pca->caReferenceBlack += 550;
                pca->caReferenceWhite -= 300;

                break;

            case BMF_8BPP_VGA256:

                DevGamma[0] =
                DevGamma[1] =
                DevGamma[2] = (FD6)1025000;
                break;

            case BMF_16BPP_555:
            case BMF_16BPP_565:
            case BMF_24BPP:
            case BMF_32BPP:

                DevGamma[0] =
                DevGamma[1] =
                DevGamma[2] = (FD6)1000000;
                break;

                break;

            default:

                return(FALSE);
            }

        } else {

            FD6 CellSubGamma = GET_REG_GAMMA(pDCI->ClrXFormBlock.RegDataIdx);

#if DO_DEST_GAMMA
            CopyMemory(DevGamma, pDCI->ClrXFormBlock.DevGamma, sizeof(DevGamma));
#else
            SrcGamma[0] = MulFD6(SrcGamma[0], pDCI->ClrXFormBlock.DevGamma[0]);
            SrcGamma[1] = MulFD6(SrcGamma[1], pDCI->ClrXFormBlock.DevGamma[1]);
            SrcGamma[2] = MulFD6(SrcGamma[2], pDCI->ClrXFormBlock.DevGamma[2]);
            DevGamma[0] =
            DevGamma[1] =
            DevGamma[2] = FD6_1;
#endif
            //
            // Printer Devices
            //

            pPrimAdj->Flags |= DCA_DO_DEVCLR_XFORM;

            if (pDCI->HTCell.HTPatIdx <= HTPAT_SIZE_16x16_M) {

                GammaMul = FD6_1 +
                           FD6xL(((pDCI->HTCell.HTPatIdx >> 1) + 1), 25000);

                if (DestSurfFormat == BMF_1BPP) {

                    DBGP_IF(DBGP_CELLGAMMA,
                            DBGP("1BPP: HTPatIdx=%ld, GammaMul=%s --> %s"
                                ARGDW(pDCI->HTCell.HTPatIdx)
                                ARGFD6(GammaMul, 1, 6)
                                ARGFD6(MulFD6(GammaMul, 1125000), 1, 6)));

                    GammaMul = MulFD6(GammaMul, 1125000);
                }
            }

            if (pDCI->DevPelRatio > FD6_1) {

                PelGamma = DivFD6(-477121,
                                  Log(DivFD6(333333, pDCI->DevPelRatio)));

            } else if (pDCI->DevPelRatio < FD6_1) {

                PelGamma = DivFD6(Log(pDCI->DevPelRatio / 3), -477121);
            }

            switch (DestSurfFormat) {

            case BMF_1BPP:
            case BMF_4BPP:
            case BMF_4BPP_VGA16:

                break;

            case BMF_8BPP_VGA256:

                if ((pDCI->Flags & (DCIF_USE_8BPP_BITMASK |
                                    DCIF_MONO_8BPP_BITMASK)) ==
                                    DCIF_USE_8BPP_BITMASK) {

                    DBGP_IF(DBGP_CELLGAMMA,
                            DBGP("Mask 8BPP, Reset PelGamma=FD6_1, CellSubGamma=%s --> %s"
                                ARGFD6(CellSubGamma, 1, 6)
                                ARGFD6(DivFD6(CellSubGamma, MASK8BPP_GAMMA_DIV), 1, 6)));

                    CellSubGamma = DivFD6(CellSubGamma, MASK8BPP_GAMMA_DIV);
                    PelGamma     = FD6_1;
                }

                break;

            case BMF_16BPP_555:
            case BMF_16BPP_565:
            case BMF_24BPP:
            case BMF_32BPP:

                if (!(pDCI->Flags & DCIF_DO_DEVCLR_XFORM)) {

                   pPrimAdj->Flags &= ~DCA_DO_DEVCLR_XFORM;
                   CellSubGamma     = FD6_1;

                   break;
                }

                break;

            default:

                return(FALSE);
            }

            DBGP_IF(DBGP_CELLGAMMA,
                    DBGP("Res=%ldx%ld, , PelRatio=%s, PelGamma=%s"
                        ARGDW(pDCI->DeviceResXDPI) ARGDW(pDCI->DeviceResYDPI)
                        ARGFD6(pDCI->DevPelRatio, 1, 6) ARGFD6(PelGamma, 1, 6)));

            DBGP_IF(DBGP_CELLGAMMA,
                    DBGP("HTPatIdx=%ld, CellSubGamma=%s, SUB GammaMul=%s"
                        ARGDW(pDCI->HTCell.HTPatIdx)
                        ARGFD6(CellSubGamma, 1, 6)
                        ARGFD6(GammaMul, 1, 6)));

            GammaMul = MulFD6(GammaMul, CellSubGamma);

#if DO_SS_GAMMA
            if (pDCI->Flags & (DCIF_SUPERCELL | DCIF_SUPERCELL_M)) {

                DBGP_IF(DBGP_CELLGAMMA,
                        DBGP("SM: Gamma: %s:%s:%s --> %s:%s:%s"
                            ARGFD6(SrcGamma[0], 1, 6)
                            ARGFD6(SrcGamma[1], 1, 6)
                            ARGFD6(SrcGamma[2], 1, 6)
                            ARGFD6(MulFD6(SrcGamma[0], SCM_R_GAMMA_MUL), 1, 6)
                            ARGFD6(MulFD6(SrcGamma[1], SCM_G_GAMMA_MUL), 1, 6)
                            ARGFD6(MulFD6(SrcGamma[2], SCM_B_GAMMA_MUL), 1, 6)));

                SrcGamma[0] = MulFD6(SrcGamma[0], SCM_R_GAMMA_MUL);
                SrcGamma[1] = MulFD6(SrcGamma[1], SCM_G_GAMMA_MUL);
                SrcGamma[2] = MulFD6(SrcGamma[2], SCM_B_GAMMA_MUL);
            }
#endif
        }

        SrcGamma[0] = MulFD6(SrcGamma[0], GammaMul);
        SrcGamma[1] = MulFD6(SrcGamma[1], GammaMul);
        SrcGamma[2] = MulFD6(SrcGamma[2], GammaMul);

        DBGP_IF(DBGP_CELLGAMMA,
                DBGP("Gamma: Src=%s:%s:%s, Dev=%s:%s:%s, Pel=%s, Mul=%s"
                    ARGFD6(SrcGamma[0], 1, 6)
                    ARGFD6(SrcGamma[1], 1, 6)
                    ARGFD6(SrcGamma[2], 1, 6)
                    ARGFD6(DevGamma[0], 1, 6)
                    ARGFD6(DevGamma[1], 1, 6)
                    ARGFD6(DevGamma[2], 1, 6)
                    ARGFD6(PelGamma,   1, 6)
                    ARGFD6(GammaMul,   1, 6)));

        DBGP_IF(DBGP_CELLGAMMA,
                DBGP("Source Gamma=%s:%s:%s, PelGamma=%s"
                    ARGFD6(SrcGamma[0], 1, 6) ARGFD6(SrcGamma[1], 1, 6)
                    ARGFD6(SrcGamma[2], 1, 6) ARGFD6(PelGamma, 1, 6)));

        if (PelGamma != FD6_1) {

            DevGamma[0] = MulFD6(DevGamma[0], PelGamma);
            DevGamma[1] = MulFD6(DevGamma[1], PelGamma);
            DevGamma[2] = MulFD6(DevGamma[2], PelGamma);

            DBGP_IF(DBGP_CELLGAMMA,
                    DBGP("DevGamma=%s:%s:%s, PelGamma=%s"
                        ARGFD6(DevGamma[0], 1, 6) ARGFD6(DevGamma[1], 1, 6)
                        ARGFD6(DevGamma[2], 1, 6) ARGFD6(PelGamma, 1, 6)));
        }
    }

    if ((SrcGamma[0] != FD6_1) ||
        (SrcGamma[1] != FD6_1) ||
        (SrcGamma[2] != FD6_1)) {

        Flags |= DCA_HAS_SRC_GAMMA;

        DBGP_IF(DBGP_CELLGAMMA,
                DBGP("--- DCA_HAS_SRC_GAMMA --- %s:%s:%s [%s]"
                    ARGFD6(SrcGamma[0], 1, 6)
                    ARGFD6(SrcGamma[1], 1, 6)
                    ARGFD6(SrcGamma[2], 1, 6)
                    ARGFD6(MulFD6(SrcGamma[0], (FD6)2200000), 1, 6)));
    }

    if ((SrcGamma[0] != pPrimAdj->SrcGamma[0])    ||
        (SrcGamma[1] != pPrimAdj->SrcGamma[1])    ||
        (SrcGamma[2] != pPrimAdj->SrcGamma[2])) {

        CopyMemory(pPrimAdj->SrcGamma, SrcGamma, sizeof(SrcGamma));
        Changed = TRUE;
    }

    if ((DevGamma[0] != FD6_1) ||
        (DevGamma[1] != FD6_1) ||
        (DevGamma[2] != FD6_1)) {

        Flags |= DCA_HAS_DEST_GAMMA;

        DBGP_IF(DBGP_CELLGAMMA,
                DBGP("--- DCA_HAS_DEST_GAMMA --- %s:%s:%s"
                    ARGFD6(DevGamma[0], 1, 6)
                    ARGFD6(DevGamma[1], 1, 6)
                    ARGFD6(DevGamma[2], 1, 6)));
    }

    if ((DevGamma[0] != pPrimAdj->DevGamma[0])    ||
        (DevGamma[1] != pPrimAdj->DevGamma[1])    ||
        (DevGamma[2] != pPrimAdj->DevGamma[2])) {

        CopyMemory(pPrimAdj->DevGamma, DevGamma, sizeof(DevGamma));

        Changed = TRUE;
    }

    if ((pPrimAdj->Flags & (DCA_HAS_ICM         |
                            DCA_HAS_SRC_GAMMA   |
                            DCA_HAS_DEST_GAMMA)) != Flags) {

        Changed = TRUE;
    }

    if (Changed) {

        pPrimAdj->Flags = (pPrimAdj->Flags & ~(DCA_HAS_ICM          |
                                               DCA_HAS_SRC_GAMMA    |
                                               DCA_HAS_DEST_GAMMA)) | Flags;
    }

    return(Changed);
}



PDEVICECOLORINFO
HTENTRY
pDCIAdjClr(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PDEVCLRADJ          *ppDevClrAdj,
    DWORD               cbAlloc,
    WORD                ForceFlags,
    CTSTDINFO           CTSTDInfo,
    PLONG               pError
    )

/*++

Routine Description:

    This function allowed the caller to changed the overall color adjustment
    for all the pictures rendered

Arguments:

    pDeviceHalftoneInfo - Pointer to the DEVICEHALFTONEINFO data structure
                          which returned from the HT_CreateDeviceHalftoneInfo.

    pHTColorAdjustment  - Pointer to the HTCOLORADJUSTMENT data structure, if
                          this pointer is NULL then a default is applied.

    ppDevClrAdj         - Pointer to pointer to the DEVCLRADJ data structure
                          where the computed results will be stored, if this
                          pointer isNULL then no color adjustment is done.

                          if pSrcSI and ppDevClrAdj are not NULL then
                          *ppDevClrAdj->Flags must contains the BBPFlags;

    ForceFlags          - Force flags to make color changed.

Return Value:

    PDEVICECOLORINFO, if return is NULL then a invalid pDeviceHalftoneInfo
    pointer is passed.

Author:

    29-May-1991 Wed 09:11:31 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    PDEVICECOLORINFO    pDCI;


    if ((!pDeviceHalftoneInfo) ||
        (PHT_DHI_DCI_OF(HalftoneDLLID) != HALFTONE_DLL_ID)) {

        *pError = HTERR_INVALID_DHI_POINTER;

        return(NULL);
    }

    pDCI = PDHI_TO_PDCI(pDeviceHalftoneInfo);

    //
    // Lock For this DCI
    //

    ACQUIRE_HTMUTEX(pDCI->HTMutex);

    //
    // Only if caller required color adjustments computations, then we will
    // compute for it.
    //

    if (ppDevClrAdj) {

        PDEVCLRADJ          pDevClrAdj;
        PCIEPRIMS           pDevPrims;
        PRGBLUTAA           prgbLUT;
        HTCOLORADJUSTMENT   ca;
        HTCOLORADJUSTMENT   caCached;
        DEVMAPINFO          DMI;
        DWORD               LUTAAHdr[LUTAA_HDR_COUNT];
        PRIMADJ             PrimAdj;
        DWORD               DCIFlags;


        if ((ForceFlags & ADJ_FORCE_AB_PREMUL_SRC) &&
            (dwABPreMul[0])) {

            DWORD   i;

            //
            // Generate a ABPreMul[] so that we can multiply it and get the
            // original pre-mul source value
            //

            dwABPreMul[0] = 0;

            for (i = 1; i < 256; i++) {

                dwABPreMul[i] = (DWORD)((0xFF000000 + (i - 1))  / i);
            }
        }

        if (!(*ppDevClrAdj = pDevClrAdj =
                        (PDEVCLRADJ)HTAllocMem((LPVOID)pDCI,
                                               HTMEM_DevClrAdj,
                                               LPTR,
                                               cbAlloc + sizeof(DEVCLRADJ)))) {

            *pError = HTERR_INSUFFICIENT_MEMORY;

            //================================================================
            // Release SEMAPHORE NOW, since we are failing the memory request
            //================================================================

            RELEASE_HTMUTEX(pDCI->HTMutex);

            return(NULL);
        }

        //
        // Force the ICM on
        //

        if ((DCIFlags = pDCI->Flags) & DCIF_FORCE_ICM) {

            ForceFlags |= ADJ_FORCE_ICM;
        }

        //
        // Force gray scale
        //

        DMI.CTSTDInfo = CTSTDInfo;

        if ((DMI.CTSTDInfo.BMFDest == BMF_1BPP)    ||
            ((DMI.CTSTDInfo.BMFDest == BMF_8BPP_VGA256) &&
             ((DCIFlags & (DCIF_USE_8BPP_BITMASK | DCIF_MONO_8BPP_BITMASK)) ==
                          (DCIF_USE_8BPP_BITMASK | DCIF_MONO_8BPP_BITMASK)))) {

            ForceFlags |= (ADJ_FORCE_MONO | ADJ_FORCE_IDXBGR_MONO);
        }

        prgbLUT = (ForceFlags & ADJ_FORCE_BRUSH) ? &pDCI->rgbLUTPat :
                                                   &pDCI->rgbLUT;

        if (ForceFlags & ADJ_FORCE_ICM) {

            //
            // These two does not mix
            //

            ForceFlags &= ~ADJ_FORCE_BRUSH;
        }

        //=====================================================================
        // We must make sure only one thread using this info.
        //=====================================================================

        ca = (pHTColorAdjustment) ? *pHTColorAdjustment :
                                    pDeviceHalftoneInfo->HTColorAdjustment;

        if ((ca.caSize != sizeof(HTCOLORADJUSTMENT)) ||
            (ca.caFlags & ~(CLRADJF_FLAGS_MASK))) {

            ca = DefaultCA;
        }

        caCached = pDCI->ca;
        PrimAdj  = pDCI->PrimAdj;


        //
        // Now validate all color adjustments
        //

        ca.caFlags &= CLRADJF_FLAGS_MASK;

        if (ca.caIlluminantIndex > ILLUMINANT_MAX_INDEX) {

            ca.caIlluminantIndex = DefaultCA.caIlluminantIndex;
        }

        ADJ_CA(ca.caRedGamma,   RGB_GAMMA_MIN, RGB_GAMMA_MAX);
        ADJ_CA(ca.caGreenGamma, RGB_GAMMA_MIN, RGB_GAMMA_MAX);
        ADJ_CA(ca.caBlueGamma,  RGB_GAMMA_MIN, RGB_GAMMA_MAX);
        ADJ_CA(ca.caReferenceBlack, 0,                   REFERENCE_BLACK_MAX);
        ADJ_CA(ca.caReferenceWhite, REFERENCE_WHITE_MIN, 10000);
        ADJ_CA(ca.caContrast,     MIN_COLOR_ADJ, MAX_COLOR_ADJ);
        ADJ_CA(ca.caBrightness,   MIN_COLOR_ADJ, MAX_COLOR_ADJ);
        ADJ_CA(ca.caColorfulness, MIN_COLOR_ADJ, MAX_COLOR_ADJ);
        ADJ_CA(ca.caRedGreenTint, MIN_COLOR_ADJ, MAX_COLOR_ADJ);

        if ((ForceFlags & ADJ_FORCE_MONO)   ||
            (ca.caColorfulness == MIN_COLOR_ADJ)) {

            ca.caColorfulness  = MIN_COLOR_ADJ;
            ca.caRedGreenTint  = 0;
        }

        if (ForceFlags & ADJ_FORCE_NEGATIVE) {

            ca.caFlags |= CLRADJF_NEGATIVE;
        }

        ca.caSize = (WORD)(ForceFlags & (ADJ_FORCE_DEVXFORM     |
                                         ADJ_FORCE_BRUSH        |
                                         ADJ_FORCE_MONO         |
                                         ADJ_FORCE_IDXBGR_MONO  |
                                         ADJ_FORCE_ICM));

        if ((AdjustSrcDevGamma(pDCI,
                               &PrimAdj,
                               &ca,
                               DMI.CTSTDInfo.BMFDest,
                               ForceFlags)) ||
            (!COMP_CA(&ca, &caCached))){

            DBGP_IF(DBGP_HCA,
                    DBGP("---- New Color Adjustments --%08lx---" ARGDW(ca.caSize));
                    DBGP("Flags    = %08x" ARGDW(ca.caFlags));
                    DBGP("Illum    = %d" ARGW(ca.caIlluminantIndex));
                    DBGP("R_Power  = %u" ARGI(ca.caRedGamma));
                    DBGP("G_Power  = %u" ARGI(ca.caGreenGamma));
                    DBGP("B_Power  = %u" ARGI(ca.caBlueGamma));
                    DBGP("BlackRef = %u" ARGW(ca.caReferenceBlack));
                    DBGP("WhiteRef = %u" ARGW(ca.caReferenceWhite));
                    DBGP("Contrast = %d" ARGI(ca.caContrast));
                    DBGP("Bright   = %d" ARGI(ca.caBrightness));
                    DBGP("Colorful = %d" ARGI(ca.caColorfulness));
                    DBGP("RG_Tint  = %d" ARGI(ca.caRedGreenTint));
                    DBGP("ForceAdj = %04lx" ARGDW(ForceFlags)));

            PrimAdj.Flags &= (DCA_HAS_ICM           |
                              DCA_DO_DEVCLR_XFORM   |
                              DCA_HAS_SRC_GAMMA     |
                              DCA_HAS_DEST_GAMMA);

            if (ForceFlags & ADJ_FORCE_IDXBGR_MONO) {

                PrimAdj.Flags |= DCA_MONO_ONLY;

                DBGP_IF(DBGP_HCA, DBGP("---DCA_MONO_ONLY---"));

            }

            if (ca.caFlags & CLRADJF_LOG_FILTER) {

                if (!LogFilterMax) {

                    LogFilterMax = PRIM_LOG_RATIO(FD6_1);
                }

                PrimAdj.Flags |= DCA_LOG_FILTER;

                DBGP_IF(DBGP_HCA, DBGP("---DCA_LOG_FILTER---"));
            }

            if (ca.caFlags & CLRADJF_NEGATIVE) {

                PrimAdj.Flags |= DCA_NEGATIVE;

                DBGP_IF(DBGP_HCA, DBGP("---DCA_NEGATIVE---"));
            }

            pDevPrims = (PrimAdj.Flags & DCA_HAS_ICM) ?
                                &(pDCI->ClrXFormBlock.rgbCIEPrims) :
                                &(pDCI->ClrXFormBlock.DevCIEPrims);

            if ((ca.caSize &       (ADJ_FORCE_ICM | ADJ_FORCE_DEVXFORM)) !=
                (caCached.caSize & (ADJ_FORCE_ICM | ADJ_FORCE_DEVXFORM))) {

                //
                // Re-Compute Device RGB xfrom matrix
                //

                DBGP_IF(DBGP_CCT,
                        DBGP("\n***  ComputeColorSpaceForm(%hs_XFORM) ***\n"
                                ARGPTR((PrimAdj.Flags & DCA_HAS_ICM) ?
                                        "ICM" : "DEVICE")));

                ComputeColorSpaceXForm(pDCI,
                                       pDevPrims,
                                       &(PrimAdj.DevCSXForm),
                                       -1);
            }

            if (ca.caIlluminantIndex != caCached.caIlluminantIndex) {

                DBGP_IF(DBGP_CCT,
                        DBGP("***  ComputeColorSpaceForm(RGB_XFORM Illuminant=%u) ***"
                                ARGU(ca.caIlluminantIndex)));

                ComputeColorSpaceXForm(pDCI,
                                       &(pDCI->ClrXFormBlock.rgbCIEPrims),
                                       &(PrimAdj.rgbCSXForm),
                                       (INT)ca.caIlluminantIndex);
            }

            if ((PrimAdj.Flags & DCA_MONO_ONLY) ||
                (CompareMemory((LPBYTE)pDevPrims,
                               (LPBYTE)&(pDCI->ClrXFormBlock.rgbCIEPrims),
                               sizeof(CIEPRIMS)))) {

                PrimAdj.Flags &= ~DCA_HAS_CLRSPACE_ADJ;

            } else {

                PrimAdj.Flags |= DCA_HAS_CLRSPACE_ADJ;
            }

            PrimAdj.MinL = UDECI4ToFD6(ca.caReferenceBlack) + HT_K_REF_ADD;
            PrimAdj.MaxL = UDECI4ToFD6(ca.caReferenceWhite) - HT_W_REF_SUB;

            if ((PrimAdj.MinL != HT_K_REF_BASE) ||
                (PrimAdj.MaxL != HT_W_REF_BASE)) {

                PrimAdj.Flags     |= DCA_HAS_BW_REF_ADJ;
                PrimAdj.MinLMul    = DivFD6(HT_K_REF_CLIP, PrimAdj.MinL);
                PrimAdj.MaxLMul    = DivFD6(HT_W_REF_CLIP,
                                            FD6_1 - PrimAdj.MaxL);
                PrimAdj.RangeLMul  = DivFD6(HT_KW_REF_RANGE,
                                            PrimAdj.MaxL - PrimAdj.MinL);

                DBGP_IF(DBGP_HCA,
                        DBGP("--- DCA_HAS_BW_REF_ADJ %s to %s, xK=%s, xW=%s, xRange=%s ---"
                            ARGFD6(PrimAdj.MinL, 1, 6)
                            ARGFD6(PrimAdj.MaxL, 1, 6)
                            ARGFD6(PrimAdj.MinLMul, 1, 6)
                            ARGFD6(PrimAdj.MaxLMul, 1, 6)
                            ARGFD6(PrimAdj.RangeLMul, 1, 6)));

            } else {

                PrimAdj.Flags     &= ~DCA_HAS_BW_REF_ADJ;
                PrimAdj.MinL       = FD6_0;
                PrimAdj.MaxL       = FD6_1;
                PrimAdj.MinLMul    =
                PrimAdj.MaxLMul    =
                PrimAdj.RangeLMul  = FD6_0;
            }

            if (ca.caContrast) {

                PrimAdj.Contrast  = JND_ADJ((FD6)1015000, ca.caContrast);
                PrimAdj.Flags    |= DCA_HAS_CONTRAST_ADJ;

                DBGP_IF(DBGP_HCA,
                        DBGP("--- DCA_HAS_CONTRAST_ADJ = %s ---"
                            ARGFD6(PrimAdj.Contrast, 1, 6)));
            }

            if (ca.caBrightness) {

                PrimAdj.Brightness  = FD6xL((FD6)3750, ca.caBrightness);
                PrimAdj.Flags      |= DCA_HAS_BRIGHTNESS_ADJ;

                DBGP_IF(DBGP_HCA,
                        DBGP("--- DCA_HAS_BRIGHTNESS_ADJ = %s ---"
                                ARGFD6(PrimAdj.Brightness, 1, 6)));
            }

            //
            // Colorfulness, RedGreenTint, and DYE_CORRECTIONS only valid and
            // necessary if it a color device output
            //

            if (!(PrimAdj.Flags & DCA_MONO_ONLY)) {

                PrimAdj.Color = (FD6)(ca.caColorfulness + MAX_COLOR_ADJ);

                // if (ca.caSize & ADJ_FORCE_BRUSH) {
                //
                //     PrimAdj.Color += HT_BRUSH_COLORFULNESS;
                // }

                if ((PrimAdj.Color *= 10000) != FD6_1) {

                    PrimAdj.Flags |= DCA_HAS_COLOR_ADJ;

                    DBGP_IF(DBGP_HCA,
                            DBGP("--- DCA_HAS_COLOR_ADJ = %s ---"
                                                ARGFD6(PrimAdj.Color, 1, 6)));
                }

                if (ca.caRedGreenTint) {

                    TintAngle((LONG)ca.caRedGreenTint,
                              (LONG)6,
                              (PFD6)&(PrimAdj.TintSinAngle),
                              (PFD6)&(PrimAdj.TintCosAngle));

                    PrimAdj.Flags |= DCA_HAS_TINT_ADJ;

                    DBGP_IF(DBGP_HCA,
                            DBGP("--- DCA_HAS_TINT_ADJ Sin=%s, Cos=%s ---"
                                    ARGFD6(PrimAdj.TintSinAngle, 1, 6)
                                    ARGFD6(PrimAdj.TintCosAngle, 1, 6)));
                }

                if ((DCIFlags & DCIF_NEED_DYES_CORRECTION)  &&
                    ((PrimAdj.Flags & (DCA_HAS_ICM | DCA_DO_DEVCLR_XFORM)) ==
                                                     DCA_DO_DEVCLR_XFORM)) {

                    PrimAdj.Flags |= DCA_NEED_DYES_CORRECTION;

                    DBGP_IF(DBGP_HCA, DBGP("---DCA_NEED_DYES_CORRECTION---"));

                    if (DCIFlags & DCIF_HAS_BLACK_DYE) {

                        PrimAdj.Flags |= DCA_HAS_BLACK_DYE;

                        DBGP_IF(DBGP_HCA, DBGP("---DCA_HAS_BLACK_DYE---"));
                    }
                }
            }

            DBGP_IF(DBGP_CCT,
                    DBGP("** Save PrimAdj back to pDCI, Flags=%08lx **"
                            ARGDW(PrimAdj.Flags)));

            pDCI->ca      = ca;
            pDCI->PrimAdj = PrimAdj;

        } else {

            DBGP_IF(DBGP_CCT, DBGP("* Use cached HTCOLORADJUSTMENT *"));
        }

        //
        // These flags are always computed per call, so turn it off first
        //

        PrimAdj.Flags &= ~(DCA_NO_ANY_ADJ               |
                           DCA_NO_MAPPING_TABLE         |
                           DCA_MASK8BPP                 |
                           DCA_BBPF_AA_OFF              |
                           DCA_USE_ADDITIVE_PRIMS       |
                           DCA_XLATE_555_666            |
                           DCA_XLATE_332                |
                           DCA_REPLACE_BLACK);

        if (!(PrimAdj.Flags & (DCA_NEED_DYES_CORRECTION |
                               DCA_HAS_CLRSPACE_ADJ     |
                               DCA_HAS_SRC_GAMMA        |
                               DCA_HAS_BW_REF_ADJ       |
                               DCA_HAS_CONTRAST_ADJ     |
                               DCA_HAS_BRIGHTNESS_ADJ   |
                               DCA_HAS_COLOR_ADJ        |
                               DCA_HAS_TINT_ADJ         |
                               DCA_LOG_FILTER           |
                               DCA_NEGATIVE             |
                               DCA_DO_DEVCLR_XFORM      |
                               DCA_HAS_DEST_GAMMA))) {

            PrimAdj.Flags |= DCA_NO_ANY_ADJ;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_NO_ANY_ADJ---"));
        }

        if ((PrimAdj.Flags & DCA_MONO_ONLY) ||
            (!(PrimAdj.Flags & (DCA_NEED_DYES_CORRECTION    |
                                DCA_HAS_CLRSPACE_ADJ        |
                                DCA_HAS_COLOR_ADJ           |
                                DCA_HAS_TINT_ADJ)))) {

            PrimAdj.Flags |= DCA_NO_MAPPING_TABLE;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_NO_MAPPING_TABLE---"));
        }

        if ((DCIFlags & DCIF_PRINT_DRAFT_MODE)    ||
            (ForceFlags & ADJ_FORCE_NO_EXP_AA)) {

            PrimAdj.Flags |= DCA_BBPF_AA_OFF;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_BBPF_AA_OFF---"));
        }

        if (ForceFlags & ADJ_FORCE_ALPHA_BLEND) {

            PrimAdj.Flags |= DCA_ALPHA_BLEND;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_ALPHA_BLEND---"));

            if (ForceFlags & ADJ_FORCE_CONST_ALPHA) {

                PrimAdj.Flags |= DCA_CONST_ALPHA;

                DBGP_IF(DBGP_HCA, DBGP("---DCA_CONST_ALPHA---"));

            } else {

                if (ForceFlags & ADJ_FORCE_AB_PREMUL_SRC) {

                    DBGP_IF(DBGP_HCA, DBGP("---DCA_AB_PREMUL_SRC---"));

                    PrimAdj.Flags |= DCA_AB_PREMUL_SRC;
                }

                if (ForceFlags & ADJ_FORCE_AB_DEST) {

                    DBGP_IF(DBGP_HCA, DBGP("---DCA_AB_DEST---"));

                    PrimAdj.Flags |= DCA_AB_DEST;
                }
            }
        }

        //
        // Since we do substractive prims at output time, we need to re-set
        // this flag evertime the pDCIAdjClr called.
        //

        if (ForceFlags & ADJ_FORCE_ADDITIVE_PRIMS) {

            PrimAdj.Flags |= DCA_USE_ADDITIVE_PRIMS;

            DBGP_IF(DBGP_HCA, DBGP("---DCA_USE_ADDITIVE_PRIMS---"));
        }

        //
        // All following is first set in RGB order wehre B is lowest memory
        // location (0) and R is in highest memory location (2), see
        // DstOrderTable[], so the index 0=B, 1=G. 2=R
        //
        // LUTAAHdr[]:  DWORD Masking for the destination in BGR order
        // Mul[]:       Multiply factor when makeing RGBLUTAA table
        // MulAdd:      Addition amount after Mul
        // LSft:        Left shift amount after Mul/MulAdd
        //

        ZeroMemory(LUTAAHdr, sizeof(LUTAAHdr));

        DMI.BlackChk         = FD6_1;
        DMI.Flags            = 0;
        DMI.LSft[0]          =
        DMI.LSft[1]          =
        DMI.LSft[2]          = 4;
        DMI.CTSTDInfo.cbPrim = sizeof(BGR8);

        if (PrimAdj.Flags & DCA_MONO_ONLY) {

            PrimAdj.Flags |= DCA_RGBLUTAA_MONO;
            DMI.Flags     |= DMIF_GRAY;
            DMI.Mul[0]     =
            DMI.Mul[1]     =
            DMI.Mul[2]     = GRAY_MAX_IDX;
            DMI.MulAdd     = 0;

        } else {

            DMI.MulAdd = 0x1000;
            DMI.Mul[0] =
            DMI.Mul[1] =
            DMI.Mul[2] = DMI.MulAdd - 1;
        }

        switch (DMI.CTSTDInfo.BMFDest) {

        case BMF_1BPP:

            //
            //  PRIMARY_ORDER_RGB (Always)
            //
            //      NOT APPLICABLE
            //

            ASSERT(DMI.Flags & DMIF_GRAY);

            DMI.CTSTDInfo.DestOrder  = PRIMARY_ORDER_RGB;

            break;

        case BMF_4BPP_VGA16:

            //
            //  PRIMARY_ORDER_BGR
            //                |||
            //                ||+-- bit 0/4
            //                ||
            //                |+--- bit 1/5
            //                |
            //                +---- bit 2/7
            //
            //

            PrimAdj.Flags           |= DCA_USE_ADDITIVE_PRIMS;
            DMI.CTSTDInfo.DestOrder  = PRIMARY_ORDER_BGR;

            //
            // Fall through for same as BMF_4BPP
            //

        case BMF_4BPP:

            //
            //  PRIMARY_ORDER_abc
            //                |||
            //                ||+-- bit 0/4
            //                ||
            //                |+--- bit 1/5
            //                |
            //                +---- bit 2/7
            //
            //

            LUTAAHdr[0] = 0x100000;
            LUTAAHdr[1] = 0x200000;
            LUTAAHdr[2] = 0x400000;
            LUTAAHdr[3] = 0x010000;
            LUTAAHdr[4] = 0x020000;
            LUTAAHdr[5] = 0x040000;
            DMI.LSft[0] = 4;
            DMI.LSft[1] = 5;
            DMI.LSft[2] = 6;
            DMI.MulAdd  = 0x0;

            break;

        case BMF_8BPP_VGA256:

            //
            //  8BPP_MASK_CLR (COLOR)
            //
            //      PRIMARY_ORDER_CMY (system standard 3:3:2 CMY format)
            //                    |||
            //                    ||+-- bit 0-1 (Max. 2 bits of yellow)
            //                    ||
            //                    |+--- bit 2-4 (Max. 3 bits of magenta)
            //                    |
            //                    +---- bit 5-7 (Max. 3 bits of cyan)
            //
            //
            //  8BPP_MASK_MONO (MONO)
            //
            //      NOT APPLICABLE
            //
            //
            //
            //  VGA_256 System Halftone Standard (BGR Always)
            //
            //      PRIMARY_ORDER_BGR
            //                    | |
            //                    | +-- Lowest Primary Index
            //                    |
            //                    |
            //                    |
            //                    +---- Highest Primary Index
            //
            //

            if (DCIFlags & DCIF_USE_8BPP_BITMASK) {

                BM8BPPINFO  bm8i;


                PrimAdj.Flags |= DCA_MASK8BPP;
                bm8i.dw        = 0;

                if (pDCI->CMY8BPPMask.GenerateXlate) {

                    GenCMYMaskXlate(pDCI->CMY8BPPMask.bXlate,
                                    (BOOL)(DCIFlags &
                                                DCIF_INVERT_8BPP_BITMASK_IDX),
                                    (LONG)pDCI->CMY8BPPMask.cC,
                                    (LONG)pDCI->CMY8BPPMask.cM,
                                    (LONG)pDCI->CMY8BPPMask.cY);

                    pDCI->CMY8BPPMask.GenerateXlate = 0;
                }

                if (DCIFlags & DCIF_INVERT_8BPP_BITMASK_IDX) {

                    bm8i.Data.pXlateIdx |= XLATE_RGB_IDX_OR;
                    bm8i.Data.bXor       = 0xFF;

                } else {

                    bm8i.Data.bXor = 0;
                }

                bm8i.Data.bBlack = pDCI->CMY8BPPMask.Mask ^ bm8i.Data.bXor;
                bm8i.Data.bWhite = bm8i.Data.bXor;

                if (DCIFlags & DCIF_MONO_8BPP_BITMASK) {

                    ASSERT(DMI.Flags & DMIF_GRAY);

                    LUTAAHdr[0]              =
                    LUTAAHdr[1]              =
                    LUTAAHdr[2]              = 0xFF0000;
                    DMI.CTSTDInfo.DestOrder  = PRIMARY_ORDER_RGB;
                    DMI.CTSTDInfo.BMFDest    = BMF_8BPP_MONO;

                    DBGP_IF(DBGP_HCA, DBGP("---DCA_MASK8BPP_MONO---"));

                } else {

                    LPBYTE  pXlate;
                    DWORD   KIdx;


                    DMI.Mul[0]  = ((DWORD)pDCI->CMY8BPPMask.cY << 12) - 1;
                    DMI.Mul[1]  = ((DWORD)pDCI->CMY8BPPMask.cM << 12) - 1;
                    DMI.Mul[2]  = ((DWORD)pDCI->CMY8BPPMask.cC << 12) - 1;
                    LUTAAHdr[0] = (DWORD)pDCI->CMY8BPPMask.PatSubY;
                    LUTAAHdr[1] = (DWORD)pDCI->CMY8BPPMask.PatSubM;
                    LUTAAHdr[2] = (DWORD)pDCI->CMY8BPPMask.PatSubC;
                    DMI.LSft[0] = 4;
                    DMI.LSft[1] = 7;
                    DMI.LSft[2] = 10;

                    switch (pDCI->CMY8BPPMask.SameLevel) {

                    case 4:
                    case 5:

                        if (pDCI->CMY8BPPMask.SameLevel == 4) {

                            DMI.CTSTDInfo.BMFDest = BMF_8BPP_L555;
                            KIdx                  = SIZE_XLATE_555 - 1;

                        } else {

                            DMI.CTSTDInfo.BMFDest  = BMF_8BPP_L666;
                            bm8i.Data.pXlateIdx   |= XLATE_666_IDX_OR;
                            KIdx                   = SIZE_XLATE_666 - 1;
                        }

                        PrimAdj.Flags       |= DCA_XLATE_555_666;
                        bm8i.Data.pXlateIdx &= XLATE_IDX_MASK;
                        pXlate               = p8BPPXlate[bm8i.Data.pXlateIdx];
                        bm8i.Data.bBlack     = pXlate[KIdx];
                        bm8i.Data.bWhite     = pXlate[0];
                        break;

                    default:

                        DMI.LSft[1]           = 6;
                        DMI.LSft[2]           = 9;
                        DMI.CTSTDInfo.BMFDest = BMF_8BPP_B332;

                        if (DCIFlags & DCIF_INVERT_8BPP_BITMASK_IDX) {

                            PrimAdj.Flags    |= DCA_XLATE_332;
                            bm8i.Data.bBlack  = pDCI->CMY8BPPMask.bXlate[255];
                            bm8i.Data.bWhite  = pDCI->CMY8BPPMask.bXlate[0];
                        }

                        break;
                    }


                    if (pDCI->CMY8BPPMask.KCheck) {

                        PrimAdj.Flags  |= DCA_REPLACE_BLACK;
                        DMI.BlackChk    = pDCI->CMY8BPPMask.KCheck;
                        DMI.LSft[0]    -= 4;
                        DMI.LSft[1]    -= 4;
                        DMI.LSft[2]    -= 4;

                        switch (DMI.CTSTDInfo.BMFDest) {

                        case BMF_8BPP_B332:

                            DMI.CTSTDInfo.BMFDest = BMF_8BPP_K_B332;
                            break;

                        case BMF_8BPP_L555:

                            DMI.CTSTDInfo.BMFDest = BMF_8BPP_K_L555;
                            break;

                        case BMF_8BPP_L666:

                            DMI.CTSTDInfo.BMFDest = BMF_8BPP_K_L666;
                            break;
                        }
                    }

                    DMI.CTSTDInfo.DestOrder = PRIMARY_ORDER_CMY;

                    DBGP_IF(DBGP_HCA,
                            DBGP("---%hsFlag=%04lx, KCheck=%s, KPower=%s ---"
                                    ARGPTR((PrimAdj.Flags & DCA_REPLACE_BLACK) ?
                                        "DCA_REPLACE_BLACK, " : " ")
                                    ARGDW(DMI.Flags)
                                    ARGFD6(DMI.BlackChk, 1, 6)
                                    ARGFD6(K_REP_POWER, 1, 6)));
                }

                DBGP_IF(DBGP_HCA,
                    DBGP("---DCA_MASK8BPP (%hs), Idx=%02lx, Xor=%02lx, K=%02lx (%ld), W=(%02lx/%ld) ---"
                            ARGPTR((DCIFlags & DCIF_INVERT_8BPP_BITMASK_IDX) ?
                                    "RGB" : "CMY")
                            ARGDW(bm8i.Data.pXlateIdx)
                            ARGDW(bm8i.Data.bXor)
                            ARGDW(bm8i.Data.bBlack) ARGDW(bm8i.Data.bBlack)
                            ARGDW(bm8i.Data.bWhite) ARGDW(bm8i.Data.bWhite)));

                LUTAAHdr[3] =
                LUTAAHdr[4] =
                LUTAAHdr[5] = bm8i.dw;


            } else {

                //
                //  PRIMARY_ORDER_BGR (Always BGR system halftone palette)
                //                |||
                //                ||+-- bit 0-2  (3 bits)
                //                ||
                //                |+--- bit 3-5  (3 bits)
                //                |
                //                +---- bit 6-8  (3 bits)
                //
                //

                DMI.Mul[0]               =
                DMI.Mul[1]               =
                DMI.Mul[2]               = 0x4FFF;
                LUTAAHdr[0]              = 0x0070000;
                LUTAAHdr[1]              = 0x0380000;
                LUTAAHdr[2]              = 0x1c00000;
                DMI.LSft[0]              = 4;
                DMI.LSft[1]              = 7;
                DMI.LSft[2]              = 10;
                DMI.CTSTDInfo.DestOrder  = PRIMARY_ORDER_BGR;
                PrimAdj.Flags           &= ~DCA_MASK8BPP;
            }

            break;

        case BMF_16BPP_555:

            //
            //  PRIMARY_ORDER_abc
            //                |||
            //                ||+-- bit 0-4   (5 bits)
            //                ||
            //                |+--- bit 5-9   (5 bits)
            //                |
            //                +---- bit 10-14 (5 bits)
            //
            //

            DMI.Mul[0]  =
            DMI.Mul[1]  =
            DMI.Mul[2]  = 0x1EFFF;
            LUTAAHdr[0] = 0x001F0000;
            LUTAAHdr[1] = 0x03e00000;
            LUTAAHdr[2] = 0x7c000000;
            LUTAAHdr[3] =
            LUTAAHdr[4] =
            LUTAAHdr[5] = 0x7FFF7FFF;
            DMI.LSft[0] = 4;
            DMI.LSft[1] = 9;
            DMI.LSft[2] = 14;

            break;

        case BMF_16BPP_565:

            //
            //  PRIMARY_ORDER_RGB (or BGR)
            //                |||
            //                ||+-- bit 0-4   (5 bits)
            //                ||
            //                |+--- bit 5-10  (6 bits)
            //                |
            //                +---- bit 11-15 (5 bits)
            //
            //

            switch (DMI.CTSTDInfo.DestOrder) {

            case PRIMARY_ORDER_RGB:
            case PRIMARY_ORDER_BGR:

                break;

            default:

                DBGP("Invalid 16BPP 565 Order=%ld, Allowed=(%ld,%ld) --> %ld"
                        ARGDW(DMI.CTSTDInfo.DestOrder)
                        ARGDW(PRIMARY_ORDER_RGB) ARGDW(PRIMARY_ORDER_BGR)
                        ARGDW(PRIMARY_ORDER_RGB));

                DMI.CTSTDInfo.DestOrder = PRIMARY_ORDER_RGB;
            }

            DMI.Mul[0]  =
            DMI.Mul[2]  = 0x1EFFF;
            DMI.Mul[1]  = 0x3EFFF;
            LUTAAHdr[0] = 0x001F0000;
            LUTAAHdr[1] = 0x07e00000;
            LUTAAHdr[2] = 0xF8000000;
            LUTAAHdr[3] =
            LUTAAHdr[4] =
            LUTAAHdr[5] = 0xFFFFFFFF;
            DMI.LSft[0] = 4;
            DMI.LSft[1] = 9;
            DMI.LSft[2] = 15;

            break;

        case BMF_24BPP:

            //
            //  PRIMARY_ORDER_BGR (system standard always BGR)
            //                |||
            //                ||+-- bit 0-7   (8 bits)
            //                ||
            //                |+--- bit 8-15  (8 bits)
            //                |
            //                +---- bit 16-23 (8 bits)
            //
            //

            DBGP_IF(DBGP_HCA,
                    DBGP("24BPP DstOrder=%ld" ARGDW(DMI.CTSTDInfo.DestOrder)));

            //
            // Fall through
            //

        case BMF_32BPP:

            //
            //  PRIMARY_ORDER_abc
            //                |||
            //                ||+-- bit 0-7   (8 bits)
            //                ||
            //                |+--- bit 8-15  (8 bits)
            //                |
            //                +---- bit 16-23 (8 bits)
            //
            //

            DMI.Mul[0]  =
            DMI.MulAdd              = 0;
            DMI.LSft[0]             =
            DMI.LSft[1]             =
            DMI.LSft[2]             = 0;
            DMI.Mul[0]              =
            DMI.Mul[1]              =
            DMI.Mul[2]              = 0xFF;
            LUTAAHdr[0]             = 0;
            LUTAAHdr[1]             = 1;
            LUTAAHdr[2]             = 2;
            break;
        }

        //
        // Watch out!!!, the ExtBGR must in BGR order
        //

        DMI.DstOrder               = DstOrderTable[DMI.CTSTDInfo.DestOrder];
        pDevClrAdj->DMI            = DMI;
        pDevClrAdj->ca             = ca;
        prgbLUT->ExtBGR[2]         = LUTAAHdr[DMI.DstOrder.Order[0]];
        prgbLUT->ExtBGR[1]         = LUTAAHdr[DMI.DstOrder.Order[1]];
        prgbLUT->ExtBGR[0]         = LUTAAHdr[DMI.DstOrder.Order[2]];
        prgbLUT->ExtBGR[5]         = LUTAAHdr[DMI.DstOrder.Order[0] + 3];
        prgbLUT->ExtBGR[4]         = LUTAAHdr[DMI.DstOrder.Order[1] + 3];
        prgbLUT->ExtBGR[3]         = LUTAAHdr[DMI.DstOrder.Order[2] + 3];
        pDevClrAdj->PrimAdj        = PrimAdj;
        pDevClrAdj->pClrXFormBlock = &(pDCI->ClrXFormBlock);
        pDevClrAdj->pCRTXLevel255  = &(pDCI->CRTX[CRTX_LEVEL_255]);
        pDevClrAdj->pCRTXLevelRGB  = &(pDCI->CRTX[CRTX_LEVEL_RGB]);

        DBGP_IF(DBGP_HCA,
                DBGP("DestFmt=%3ld, Order=%ld [%ld:%ld:%ld], DMI.Flags=%02lx"
                    ARGDW(DMI.CTSTDInfo.BMFDest) ARGDW(DMI.DstOrder.Index)
                    ARGDW(DMI.DstOrder.Order[0]) ARGDW(DMI.DstOrder.Order[1])
                    ARGDW(DMI.DstOrder.Order[2]) ARGDW(DMI.Flags)));

        DBGP_IF(DBGP_HCA,
                DBGP("ExtBGR=%08lx:%08lx:%08lx:%08lx:%08lx:%08lx, LSft=%ld:%ld:%ld"
                    ARGDW(prgbLUT->ExtBGR[0]) ARGDW(prgbLUT->ExtBGR[1])
                    ARGDW(prgbLUT->ExtBGR[2]) ARGDW(prgbLUT->ExtBGR[3])
                    ARGDW(prgbLUT->ExtBGR[4]) ARGDW(prgbLUT->ExtBGR[5])
                    ARGDW(pDevClrAdj->DMI.LSft[0])
                    ARGDW(pDevClrAdj->DMI.LSft[1])
                    ARGDW(pDevClrAdj->DMI.LSft[2])));

        DBGP_IF(DBGP_HCA,
                DBGP("Mul=%08lx:%08lx:%08lx, MulAdd=%08lx"
                    ARGDW(pDevClrAdj->DMI.Mul[0]) ARGDW(pDevClrAdj->DMI.Mul[1])
                    ARGDW(pDevClrAdj->DMI.Mul[2]) ARGDW(pDevClrAdj->DMI.MulAdd)));

        DBGP_IF(DBGP_PRIMADJFLAGS,
                DBGP("pDCIAdjClr: PrimAdj.Flags=%08lx" ARGDW(PrimAdj.Flags)));
    }

    return(pDCI);
}



VOID
HTENTRY
ComputeColorSpaceXForm(
    PDEVICECOLORINFO    pDCI,
    PCIEPRIMS           pCIEPrims,
    PCOLORSPACEXFORM    pCSXForm,
    INT                 IlluminantIndex
    )

/*++

Routine Description:

    This function take device's R/G/B/W CIE coordinate (x,y) and compute
    3 x 3 transform matrix, it assume the primaries are additively.

    Calcualte the 3x3 CIE matrix and its inversion (matrix) based on the
    C.I.E. CHROMATICITY x, y coordinates or RGB and WHITE alignment.

    this function produces the CIE XYZ matrix and/or its inversion for trnaform
    between RGB primary colors and CIE color spaces, the transforms are
                                                        -1
    [ X ] = [ Xr Xg Xb ] [ R ]      [ R ] = [ Xr Xg Xb ]   [ X ]
    [ Y ] = [ Yr Yg Yb ] [ G ] and  [ G ]   [ Yr Yg Yb ]   [ Y ]
    [ Z ] = [ Zr Zg Zb ] [ B ]      [ B ]   [ Zr Zg Zb ]   [ Z ]

Arguments:

    pDCI            - The current device color info

    pCIEPrims       - Pointer to CIEPRIMS data structure, the CIEPRIMS data
                      must already validated.

    pCSXForm        - Pointer to the location to stored the transfrom

    ColorSpace      - CIELUV or CIELAB

    IlluminantIndex - Standard illuminant index if < 0 then pCIEPrims->w is
                      used

Return Value:

    VOID

Author:

    11-Oct-1991 Fri 14:19:59 created    -by-  Daniel Chou (danielc)


Revision History:

    20-Apr-1993 Tue 03:08:15 updated  -by-  Daniel Chou (danielc)
        re-write so that xform will be correct when device default is used.

    22-Jan-1998 Thu 03:01:02 updated  -by-  Daniel Chou (danielc)
        use IlluminantIndex to indicate if device reverse transform is needed


--*/

{
    MATRIX3x3   Matrix3x3;
    FD6XYZ      WhiteXYZ;
    MULDIVPAIR  MDPairs[5];
    FD6         DiffRGB;
    FD6         RedXYZScale;
    FD6         GreenXYZScale;
    FD6         BlueXYZScale;
    FD6         AUw;
    FD6         BVw;
    FD6         xr;
    FD6         yr;
    FD6         xg;
    FD6         yg;
    FD6         xb;
    FD6         yb;
    FD6         xw;
    FD6         yw;
    FD6         Yw;



    xr = pCIEPrims->r.x;
    yr = pCIEPrims->r.y;
    xg = pCIEPrims->g.x;
    yg = pCIEPrims->g.y;
    xb = pCIEPrims->b.x;
    yb = pCIEPrims->b.y;
    Yw = pCIEPrims->Yw;

    if (IlluminantIndex < 0) {

        xw = pCIEPrims->w.x;
        yw = pCIEPrims->w.y;

    } else {

        if (--IlluminantIndex < 0) {

            IlluminantIndex = ILLUMINANT_D65 - 1;
        }

        pCIEPrims->w.x =
        xw             = UDECI4ToFD6(StdIlluminant[IlluminantIndex].x);
        pCIEPrims->w.y =
        yw             = UDECI4ToFD6(StdIlluminant[IlluminantIndex].y);
    }

    DBGP_IF(DBGP_CIEMATRIX,
            DBGP("** CIEINFO:  [xw, yw, Yw] = [%s, %s, %s], Illuminant=%d"
                ARGFD6l(xw) ARGFD6l(yw) ARGFD6l(Yw) ARGI(IlluminantIndex)));

    DBGP_IF(DBGP_CIEMATRIX,
            DBGP("[xR yR] = [%s %s]" ARGFD6l(xr) ARGFD6l(yr));
            DBGP("[xG yG] = [%s %s]" ARGFD6l(xg) ARGFD6l(yg));
            DBGP("[xB yB] = [%s %s]" ARGFD6l(xb) ARGFD6l(yb));
            DBGP("***********************************************"));

    //
    // Normalized to have C.I.E. Y equal to 1.0
    //

    MAKE_MULDIV_INFO(MDPairs, 3, MULDIV_HAS_DIVISOR);
    MAKE_MULDIV_DVSR(MDPairs, Yw);

    MAKE_MULDIV_PAIR(MDPairs, 1, xr, yg - yb);
    MAKE_MULDIV_PAIR(MDPairs, 2, xg, yb - yr);
    MAKE_MULDIV_PAIR(MDPairs, 3, xb, yr - yg);

    DiffRGB = MulFD6(yw, MulDivFD6Pairs(MDPairs));

    //
    // Compute Scaling factors for each color
    //

    MAKE_MULDIV_INFO(MDPairs, 4, MULDIV_HAS_DIVISOR);
    MAKE_MULDIV_DVSR(MDPairs, DiffRGB);

    MAKE_MULDIV_PAIR(MDPairs, 1,  xw, yg - yb);
    MAKE_MULDIV_PAIR(MDPairs, 2, -yw, xg - xb);
    MAKE_MULDIV_PAIR(MDPairs, 3,  xg, yb     );
    MAKE_MULDIV_PAIR(MDPairs, 4, -xb, yg     );

    RedXYZScale = MulDivFD6Pairs(MDPairs);

    MAKE_MULDIV_PAIR(MDPairs, 1,  xw, yb - yr);
    MAKE_MULDIV_PAIR(MDPairs, 2, -yw, xb - xr);
    MAKE_MULDIV_PAIR(MDPairs, 3, -xr, yb     );
    MAKE_MULDIV_PAIR(MDPairs, 4,  xb, yr     );

    GreenXYZScale = MulDivFD6Pairs(MDPairs);

    MAKE_MULDIV_PAIR(MDPairs, 1,  xw, yr - yg);
    MAKE_MULDIV_PAIR(MDPairs, 2, -yw, xr - xg);
    MAKE_MULDIV_PAIR(MDPairs, 3,  xr, yg     );
    MAKE_MULDIV_PAIR(MDPairs, 4, -xg, yr     );

    BlueXYZScale = MulDivFD6Pairs(MDPairs);

    //
    // Now scale the RGB coordinate by it ratio, notice that C.I.E z value.
    // equal to (1.0 - x - y)
    //
    // Make sure Yr + Yg + Yb = 1.0, this may happened when ruound off
    // durning the computation, we will add the difference (at most it will
    // be 0.000002) to the Yg since this is brightnest color
    //

    CIE_Xr(Matrix3x3) = MulFD6(xr,              RedXYZScale);
    CIE_Xg(Matrix3x3) = MulFD6(xg,              GreenXYZScale);
    CIE_Xb(Matrix3x3) = MulFD6(xb,              BlueXYZScale);

    pCSXForm->Yrgb.R  =
    CIE_Yr(Matrix3x3) = MulFD6(yr,              RedXYZScale);
    pCSXForm->Yrgb.G  =
    CIE_Yg(Matrix3x3) = MulFD6(yg,              GreenXYZScale);
    pCSXForm->Yrgb.B  =
    CIE_Yb(Matrix3x3) = MulFD6(yb,              BlueXYZScale);

    CIE_Zr(Matrix3x3) = MulFD6(FD6_1 - xr - yr, RedXYZScale);
    CIE_Zg(Matrix3x3) = MulFD6(FD6_1 - xg - yg, GreenXYZScale);
    CIE_Zb(Matrix3x3) = MulFD6(FD6_1 - xb - yb, BlueXYZScale);

    WhiteXYZ.X = CIE_Xr(Matrix3x3) + CIE_Xg(Matrix3x3) + CIE_Xb(Matrix3x3);
    WhiteXYZ.Y = CIE_Yr(Matrix3x3) + CIE_Yg(Matrix3x3) + CIE_Yb(Matrix3x3);
    WhiteXYZ.Z = CIE_Zr(Matrix3x3) + CIE_Zg(Matrix3x3) + CIE_Zb(Matrix3x3);

    //
    // If request a 3 x 3 transform matrix then save the result back
    //

    DBGP_IF(DBGP_CIEMATRIX,

        DBGP("== RGB -> XYZ 3x3 Matrix ==== White = (%s, %s) =="
                                   ARGFD6s(xw) ARGFD6s(yw));
        DBGP("[Xr Xg Xb] = [%s %s %s]" ARGFD6l(CIE_Xr(Matrix3x3))
                                   ARGFD6l(CIE_Xg(Matrix3x3))
                                   ARGFD6l(CIE_Xb(Matrix3x3)));
        DBGP("[Yr Yg Yb] = [%s %s %s]" ARGFD6l(CIE_Yr(Matrix3x3))
                                   ARGFD6l(CIE_Yg(Matrix3x3))
                                   ARGFD6l(CIE_Yb(Matrix3x3)));
        DBGP("[Zr Zg Zb] = [%s %s %s]" ARGFD6l(CIE_Zr(Matrix3x3))
                                       ARGFD6l(CIE_Zg(Matrix3x3))
                                       ARGFD6l(CIE_Zb(Matrix3x3)));
        DBGP("===============================================");
    );

    DBGP_IF(DBGP_CIEMATRIX,
           DBGP("RGB->XYZ: [Xw=%s, Yw=%s, Zw=%s]"
                ARGFD6l(WhiteXYZ.X)
                ARGFD6l(WhiteXYZ.Y)
                ARGFD6l(WhiteXYZ.Z)));

    if (IlluminantIndex < 0) {

        pCSXForm->M3x3 = Matrix3x3;

        ComputeInverseMatrix3x3(&(pCSXForm->M3x3), &Matrix3x3);

        DBGP_IF(DBGP_CIEMATRIX,

            DBGP("======== XYZ -> RGB INVERSE 3x3 Matrix ========");
            DBGP("          -1");
            DBGP("[Xr Xg Xb]   = [%s %s %s]" ARGFD6l(CIE_Xr(Matrix3x3))
                                             ARGFD6l(CIE_Xg(Matrix3x3))
                                             ARGFD6l(CIE_Xb(Matrix3x3)));
            DBGP("[Yr Yg Yb]   = [%s %s %s]"
                                             ARGFD6l(CIE_Yr(Matrix3x3))
                                             ARGFD6l(CIE_Yg(Matrix3x3))
                                             ARGFD6l(CIE_Yb(Matrix3x3)));
            DBGP("[Zr Zg Zb]   = [%s %s %s]"
                                             ARGFD6l(CIE_Zr(Matrix3x3))
                                             ARGFD6l(CIE_Zg(Matrix3x3))
                                             ARGFD6l(CIE_Zb(Matrix3x3)));
            DBGP("===============================================");
        );
    }

    if ((pCSXForm->YW = WhiteXYZ.Y) != NORMALIZED_WHITE) {

        if (WhiteXYZ.Y) {

            WhiteXYZ.X = DivFD6(WhiteXYZ.X, WhiteXYZ.Y);
            WhiteXYZ.Z = DivFD6(WhiteXYZ.Z, WhiteXYZ.Y);

        } else {

            WhiteXYZ.X =
            WhiteXYZ.Z = FD6_0;
        }

        WhiteXYZ.Y = NORMALIZED_WHITE;
    }

    switch (pDCI->ClrXFormBlock.ColorSpace) {

    case CIELUV_1976:

        //
        // U' = 4X / (X + 15Y + 3Z)
        // V' = 9Y / (X + 15Y + 3Z)
        //
        // U* = 13 x L x (U' - Uw)
        // V* = 13 x L x (V' - Vw)
        //
        //

        DiffRGB = WhiteXYZ.X + FD6xL(WhiteXYZ.Y, 15) + FD6xL(WhiteXYZ.Z, 3);
        AUw     = DivFD6(FD6xL(WhiteXYZ.X, 4), DiffRGB);
        BVw     = DivFD6(FD6xL(WhiteXYZ.Y, 9), DiffRGB);

        break;

    case CIELAB_1976:
    default:

        //
        // CIELAB 1976 L*A*B*
        //
        //  A* = 500 x (fX - fY)
        //  B* = 200 x (fY - fZ)
        //
        //             1/3
        //  fX = (X/Xw)                     (X/Xw) >  0.008856
        //  fX = 7.787 x (X/Xw) + (16/116)  (X/Xw) <= 0.008856
        //
        //             1/3
        //  fY = (Y/Yw)                     (Y/Yw) >  0.008856
        //  fY = 7.787 Y (Y/Yw) + (16/116)  (Y/Yw) <= 0.008856
        //
        //             1/3
        //  fZ = (Z/Zw)                     (Z/Zw) >  0.008856
        //  fZ = 7.787 Z (Z/Zw) + (16/116)  (Z/Zw) <= 0.008856
        //

        AUw =
        BVw = FD6_0;

        break;

    }

    pCSXForm->M3x3     = Matrix3x3;
    pCSXForm->WhiteXYZ = WhiteXYZ;
    pCSXForm->AUw      = AUw;
    pCSXForm->BVw      = BVw;
    pCSXForm->xW       = xw;
    pCSXForm->yW       = yw;

    DBGP_IF(DBGP_CSXFORM,
        DBGP("------- ComputeColorSpaceXForm: %s ---------"
                            ARG(pDbgCSName[pDCI->ClrXFormBlock.ColorSpace]));
        DBGP("   White XYZ = (%s, %s, %s)" ARGFD6(WhiteXYZ.X, 1, 6)
                                           ARGFD6(WhiteXYZ.Y, 1, 6)
                                           ARGFD6(WhiteXYZ.Z, 1, 6));
        DBGP("     AUw/BVw = %s / %s" ARGFD6(AUw, 1, 6) ARGFD6s(BVw));
        DBGP("   White xyY = (%s, %s, %s)" ARGFD6(pCSXForm->xW, 1, 6)
                                           ARGFD6(pCSXForm->yW, 1, 6)
                                           ARGFD6(pCSXForm->YW, 1, 6));
        DBGP("------------------------------------------------");
    );
}




PCACHERGBTOXYZ
HTENTRY
CacheRGBToXYZ(
    PCACHERGBTOXYZ      pCRTX,
    PFD6XYZ             pFD6XYZ,
    LPDWORD             pNewChecksum,
    PDEVCLRADJ          pDevClrAdj
    )

/*++

Routine Description:

    This function cached the RGB color input to XYZ


Arguments:

    pCRTX       - Pointer to the CACHERGBTOXYZ

    pFD6XYZ     - Pointer to the local cached RGB->XYZ table (will be updated)

    pNewChecksum- Pointer to the new checksum computed

    pDevClrAdj  - Pointer to DEVCLRADJ,

Return Value:

    if a cahced is copied to the pFD6XYZ then NULL will be returned, otherwise
    the cache table is computed on the pFD6XYZ and pCRTX returned


    TRUE if cached XYZ info is generate, false otherwise, only possible failure
    is that memory allocation failed.

Author:

    08-May-1992 Fri 13:21:03 created  -by-  Daniel Chou (danielc)


Revision History:

    09-Mar-1995 Thu 10:50:13 updated  -by-  Daniel Chou (danielc)
        DO NOT TURN OFF DCA_NEGATIVE in this function

--*/

{
    PMATRIX3x3  pRGBToXYZ;
    PPRIMADJ    pPrimAdj;
    FD6         rgbX;
    FD6         rgbY;
    FD6         rgbZ;
    FD6         PrimCur;
    UINT        PrimMax;
    UINT        PrimInc;
    DWORD       Checksum;
    UINT        RGBIndex;

    //
    // Turn off the one we did not need any checksum for
    //

    pPrimAdj   = &(pDevClrAdj->PrimAdj);
    pRGBToXYZ  = &(pPrimAdj->rgbCSXForm.M3x3);
    Checksum   = ComputeChecksum((LPBYTE)pRGBToXYZ, 'CXYZ', sizeof(MATRIX3x3));

    if ((pCRTX->pFD6XYZ) &&
        (pCRTX->Checksum == Checksum)) {

        CopyMemory(pFD6XYZ, pCRTX->pFD6XYZ, pCRTX->SizeCRTX);

        DBGP_IF(DBGP_CACHED_GAMMA,
                DBGP("*** Use %u bytes CACHED RGB->XYZ Table ***"
                    ARGU(pCRTX->SizeCRTX)));

        return(NULL);
    }

    *pNewChecksum = Checksum;

    DBGP_IF(DBGP_CCT, DBGP("** Re-Compute %ld bytes RGB->XYZ xform table **"
                    ARGDW(pCRTX->SizeCRTX)));

    PrimMax = (UINT)pCRTX->PrimMax;

    for (RGBIndex = 0; RGBIndex < 3; RGBIndex++) {

        rgbX = pRGBToXYZ->m[X_INDEX][RGBIndex];
        rgbY = pRGBToXYZ->m[Y_INDEX][RGBIndex];
        rgbZ = pRGBToXYZ->m[Z_INDEX][RGBIndex];

        DBGP_IF(DBGP_CACHED_GAMMA,
                DBGP("CachedRGBToXYZ %u:%u, XYZ=%s:%s:%s"
                         ARGU(RGBIndex) ARGU(PrimMax)
                         ARGFD6(rgbX,  2, 6) ARGFD6(rgbY,  2, 6)
                         ARGFD6(rgbZ,  2, 6)));

        for (PrimInc = 0; PrimInc <= PrimMax; PrimInc++, pFD6XYZ++) {

            PrimCur     = DivFD6((FD6)PrimInc, (FD6)PrimMax);
            pFD6XYZ->X  = MulFD6(rgbX, PrimCur);
            pFD6XYZ->Y  = MulFD6(rgbY, PrimCur);
            pFD6XYZ->Z  = MulFD6(rgbZ, PrimCur);

            DBGP_IF(DBGP_CACHED_GAMMA,
                    DBGP("(%u:%3u): %s, XYZ=%s:%s:%s"
                    ARGU(RGBIndex) ARGU(PrimInc)
                    ARGFD6(PrimCur, 1, 6)
                    ARGFD6(pFD6XYZ->X, 1, 6)
                    ARGFD6(pFD6XYZ->Y, 1, 6)
                    ARGFD6(pFD6XYZ->Z, 1, 6)));
        }
    }

    return(pCRTX);
}


#define RD_MIN_POWER    (FD6)1500000
#define RD_MAX_POWER    (FD6)2000000

#define GET_RD_MIN_PRIM(p, RD)                                              \
{                                                                           \
  (p) = FD6_1 - DivFD6(p, RD.LMin);                                         \
  (p) = MulFD6(FD6_1 - Power(p, RD_MIN_POWER), RD.LMin);                    \
}

#define GET_RD_MAX_PRIM(p, RD)                                              \
{                                                                           \
  (p) = DivFD6((p) - RD.LMax, FD6_1 - RD.LMax);                             \
  (p) = RD.LMax + MulFD6(Power(p, RD_MAX_POWER), FD6_1 - RD.LMax);          \
}




VOID
HTENTRY
ComputeRGBLUTAA(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PRGBLUTAA           prgbLUT
    )

/*++

Routine Description:

    This function compute a RGB to Monochrome *L translation table.


Arguments:

    pDCI        - Pointer to the DEVICECOLORINFO

    pDevClrAdj  - Pointer to DEVCLRADJ, the DCA_NEGATIVE and DCA_HAS_SRC_GAMMA
                  flags in pDevClrAdj->PrimAdj.Flags will always be turn off
                  at return.

    prgbLUT     - Pointer to the RGBLUTAA buffer for computation

Return Value:

    VOID

Author:

    05-Mar-1993 Fri 17:37:12 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPDWORD             pdw;
    LPBYTE              pbAB;
    REGDATA             RD;
    PRIMADJ             PrimAdj;
    DEVMAPINFO          DMI;
    HTCOLORADJUSTMENT   ca;
    FD6                 Prim;
    FD6                 PrimOrg;
    FD6                 PrimKDiv;
    FD6                 Mul;
    FD6                 SrcGamma;
    FD6                 DevGamma;
    DWORD               dwPrim;
    DWORD               PrimMask;
    DWORD               aMulAdd[3];
    DWORD               CurCA;
    DWORD               PrevCA;
    FD6                 aPrimMaxMul[3];
    FD6                 PrimMaxMul;
    PFD6                pDenCMY[3];
    PFD6                pDensity;
    UINT                Index;
    UINT                LeftShift;
    UINT                PrimIdx;
    INT                 PrimCur;


    PrimAdj                     = pDevClrAdj->PrimAdj;
    ca                          = pDevClrAdj->ca;
    DMI                         = pDevClrAdj->DMI;
    pDevClrAdj->PrimAdj.Flags  &= ~(DCA_HAS_SRC_GAMMA       |
                                    DCA_HAS_DEST_GAMMA      |
                                    DCA_HAS_BW_REF_ADJ      |
                                    DCA_HAS_CONTRAST_ADJ    |
                                    DCA_HAS_BRIGHTNESS_ADJ  |
                                    DCA_LOG_FILTER          |
                                    DCA_NEGATIVE            |
                                    DCA_DO_DEVCLR_XFORM);

    ca.caColorfulness =
    ca.caRedGreenTint = (PrimAdj.Flags & DCA_MONO_ONLY) ? 0xff : 0x00;

    SET_CACHED_CMI_CA(pDevClrAdj->ca);

    aPrimMaxMul[0] =
    aPrimMaxMul[1] =
    aPrimMaxMul[2] = FD6_1;
    aMulAdd[0]     =
    aMulAdd[1]     =
    aMulAdd[2]     = DMI.MulAdd;
    pDenCMY[0]     =
    pDenCMY[1]     =
    pDenCMY[2]     = NULL;

    if (PrimAdj.Flags & DCA_RGBLUTAA_MONO) {

        ASSERT(PrimAdj.Flags & DCA_NO_MAPPING_TABLE);
        ASSERT(DMI.Mul[1] == GRAY_MAX_IDX);
        ASSERT(PrimAdj.Flags & DCA_MONO_ONLY);
        ASSERT(DMI.MulAdd == 0);
        ASSERT(DMI.Flags & DMIF_GRAY);

        DMI.Mul[0]             = (DWORD)MulFD6(NTSC_R_INT, DMI.Mul[1]);
        DMI.Mul[2]             = (DWORD)MulFD6(NTSC_B_INT, DMI.Mul[1]);
        DMI.Mul[1]            -= (DMI.Mul[0] + DMI.Mul[2]);
        DMI.DstOrder.Order[0]  = 0;
        DMI.DstOrder.Order[1]  = 1;
        DMI.DstOrder.Order[2]  = 2;
        DMI.LSft[0]            =
        DMI.LSft[1]            =
        DMI.LSft[2]            = 0;

    } else {

        ASSERT(!(DMI.Flags & DMIF_GRAY));

        if (PrimAdj.Flags & DCA_MASK8BPP) {

            ASSERT((pDCI->Flags & (DCIF_USE_8BPP_BITMASK |
                                   DCIF_MONO_8BPP_BITMASK)) ==
                                   DCIF_USE_8BPP_BITMASK);

            aPrimMaxMul[0] = pDCI->CMY8BPPMask.MaxMulY;
            aPrimMaxMul[1] = pDCI->CMY8BPPMask.MaxMulM;
            aPrimMaxMul[2] = pDCI->CMY8BPPMask.MaxMulC;

            if (pDCI->Flags & DCIF_HAS_DENSITY) {

                pDenCMY[0] = pDCI->CMY8BPPMask.DenY;
                pDenCMY[1] = pDCI->CMY8BPPMask.DenM;
                pDenCMY[2] = pDCI->CMY8BPPMask.DenC;
            }
        }
    }

    if (!(PrimAdj.Flags & DCA_REPLACE_BLACK)) {

        DMI.BlackChk = FD6_1;
    }

    PrimMask = PrimAdj.Flags & (DCA_REPLACE_BLACK   |
                                DCA_DO_DEVCLR_XFORM |
                                DCA_ALPHA_BLEND     |
                                DCA_CONST_ALPHA     |
                                DCA_NO_MAPPING_TABLE);

    GET_CHECKSUM(PrimMask, PrimAdj.SrcGamma);
    GET_CHECKSUM(PrimMask, PrimAdj.DevGamma);
    GET_CHECKSUM(PrimMask, ca);
    GET_CHECKSUM(PrimMask, DMI);

    CurCA  = (DWORD)pDCI->CurConstAlpha;
    PrevCA = (DWORD)pDCI->PrevConstAlpha;

    if (prgbLUT->Checksum != PrimMask) {

        prgbLUT->Checksum    = PrimMask;
        PrevCA               =
        pDCI->PrevConstAlpha = AB_CONST_MAX + 1;

        DBGP_IF(DBGP_RGBLUTAA,
                DBGP("** Re-Compute %ld bytes of pLUT=%p, SG=%s:%s:%s, DG=%s:%s:%s **"
                        ARGDW(sizeof(RGBLUTAA))
                        ARGPTR(prgbLUT)
                        ARGFD6(PrimAdj.SrcGamma[0], 1, 4)
                        ARGFD6(PrimAdj.SrcGamma[1], 1, 4)
                        ARGFD6(PrimAdj.SrcGamma[2], 1, 4)
                        ARGFD6(PrimAdj.DevGamma[0], 1, 4)
                        ARGFD6(PrimAdj.DevGamma[1], 1, 4)
                        ARGFD6(PrimAdj.DevGamma[2], 1, 4)));

        DBGP_IF(DBGP_RGBLUTAA,
                DBGP("DMI.Mul=%08lx:%08lx:%08lx, %08lx, LSft=%ld:%ld:%ld"
                    ARGDW(DMI.Mul[0]) ARGDW(DMI.Mul[1]) ARGDW(DMI.Mul[2])
                    ARGDW(DMI.Mul[0] + DMI.Mul[1] + DMI.Mul[2])
                    ARGDW(DMI.LSft[0]) ARGDW(DMI.LSft[1]) ARGDW(DMI.LSft[2])));

        if (PrimAdj.Flags & DCA_DO_DEVCLR_XFORM) {

            RD = RegData[pDCI->ClrXFormBlock.RegDataIdx];
        }

        //
        // Compute order BGR
        //

        Index    = 3;
        PrimKDiv = FD6_1 - DMI.BlackChk;
        PrimMask = (DWORD)(DMI.MulAdd - 1);
        pdw      = (LPDWORD)prgbLUT->IdxBGR;

        if ((PrimAdj.Flags & DCA_ALPHA_BLEND) &&
            (!(DMI.Flags & DMIF_GRAY))) {

            pbAB = (LPBYTE)pDCI->pAlphaBlendBGR;

        } else {

            pbAB = NULL;
        }

        while (Index--) {

            SrcGamma   = PrimAdj.SrcGamma[Index];
            DevGamma   = PrimAdj.DevGamma[Index];
            PrimIdx    = DMI.DstOrder.Order[Index];
            PrimMaxMul = aPrimMaxMul[PrimIdx];
            DMI.MulAdd = aMulAdd[PrimIdx];
            LeftShift  = DMI.LSft[PrimIdx];
            Mul        = DMI.Mul[PrimIdx];
            pDensity   = pDenCMY[PrimIdx];
            PrimCur    = -1;

            DBGP_IF(DBGP_RGBLUTAA,
                    DBGP("Index=%ld: Mul=%08lx, LSft=%2ld [%08lx], PrimMaxMul=%s, MulAdd=%04lx"
                        ARGDW(Index) ARGDW(Mul) ARGDW(LeftShift)
                        ARGDW( ((Mul + DMI.MulAdd) & PrimMask) |
                              (((Mul + DMI.MulAdd) & ~PrimMask) << LeftShift))
                        ARGFD6(PrimMaxMul, 1, 6) ARGDW(DMI.MulAdd)));

            while (++PrimCur < BF_GRAY_TABLE_COUNT) {

                PrimOrg =
                Prim    = DivFD6((FD6)PrimCur, (FD6)(BF_GRAY_TABLE_COUNT - 1));

                if (PrimAdj.Flags & DCA_HAS_SRC_GAMMA) {

                    Prim = Power(Prim, SrcGamma);
                }

                if (PrimAdj.Flags & DCA_HAS_BW_REF_ADJ) {

                    PRIM_BW_ADJ(Prim, PrimAdj);
                }

                if (PrimAdj.Flags & DCA_HAS_CONTRAST_ADJ) {

                    PRIM_CONTRAST(Prim, PrimAdj);
                }

                if (PrimAdj.Flags & DCA_HAS_BRIGHTNESS_ADJ) {

                    PRIM_BRIGHTNESS(Prim, PrimAdj);
                }

                if (PrimAdj.Flags & DCA_LOG_FILTER) {

                    PRIM_LOG_FILTER(Prim);
                }

                CLAMP_01(Prim);

                if (PrimAdj.Flags & DCA_NEGATIVE) {

                    Prim = FD6_1 - Prim;
                }

                if (PrimAdj.Flags & DCA_DO_DEVCLR_XFORM) {

                    if (Prim <= RD.LMin) {

                        GET_RD_MIN_PRIM(Prim, RD);
                        Prim = REG_DMIN_ADD + 50 + MulFD6(Prim, RD.DMinMul);

                    } else if (Prim >= RD.LMax) {

                        GET_RD_MAX_PRIM(Prim, RD);
                        Prim = RD.DMaxAdd + 50 + MulFD6(Prim, RD.DMaxMul);

                    } else {

                        Prim = RD.DenAdd + 50 +
                               MulFD6(Log(CIE_L2I(Prim)), RD.DenMul);
                    }

                    Prim /= 100;
                }

                CLAMP_01(Prim);

                if (PrimAdj.Flags & DCA_HAS_DEST_GAMMA) {

                    Prim = Power(Prim, DevGamma);
                }

                if (pbAB) {

                    *pbAB++ = (BYTE)MulFD6(Prim, 0xFF);
                    Prim    = PrimOrg;
                }

                if (!(DMI.Flags & DMIF_GRAY)) {

                    Prim = FD6_1 - Prim;
                }

                if (pDensity) {

                    FD6     p1;
                    FD6     p2;
                    DWORD   Idx;

                    p2  = FD6_0;
                    Idx = ~0;

                    do {

                        p1 = p2;
                        p2 = pDensity[++Idx];

                    } while (Prim > p2);

                    dwPrim = MulFD6(DivFD6(Prim - p1, p2 - p1), MAX_BGR_IDX) +
                             (Idx << 12) + DMI.MulAdd;

                } else {

                    dwPrim = (DWORD)MulFD6(Prim, Mul) + DMI.MulAdd;
                }

                dwPrim = (DWORD)MulFD6(dwPrim & PrimMask, PrimMaxMul) |
                         ((DWORD)(dwPrim & ~PrimMask) << LeftShift);

                if (Prim > DMI.BlackChk) {

                    dwPrim |= (DWORD)MulFD6(Power(DivFD6(Prim - DMI.BlackChk,
                                                         PrimKDiv),
                                                  K_REP_POWER),
                                            MAX_K_IDX) << 21;
                }

                *pdw++ = dwPrim;
            }

            for (PrimCur = 0; PrimCur < BF_GRAY_TABLE_COUNT; PrimCur++) {

                DBGP_IF(DBGP_RGBLUTAA,
                        DBGP("COLOR(%04lx:%4ld) %3u = %08lx"
                             ARGU(Index) ARGU(Mul) ARGU(PrimCur)
                             ARGDW(*(pdw - BF_GRAY_TABLE_COUNT + PrimCur))));
            }

        }

    } else {

        DBGP_IF(DBGP_RGBLUTAA, DBGP("** Used Cached %ld bytes pLUT **"
                                ARGDW(sizeof(RGBLUTAA))));
    }

    if ((PrimAdj.Flags & (DCA_ALPHA_BLEND | DCA_CONST_ALPHA)) ==
                         (DCA_ALPHA_BLEND | DCA_CONST_ALPHA)) {

        if (PrevCA != CurCA) {

            LPWORD  pwBGR;
            LPWORD  pCA;


            DBGP_IF(DBGP_CONST_ALPHA,
                    DBGP("** %hs ConstAlpha=%3ld: Re-compute"
                        ARGPTR((DMI.Flags & DMIF_GRAY) ? "GRAY" : "STD")
                        ARGDW(CurCA)));

            pbAB                  = pDCI->pAlphaBlendBGR;
            pwBGR                 = (LPWORD)(pbAB + AB_BGR_SIZE);
            pCA                   = (LPWORD)((LPBYTE)pwBGR + AB_BGR_CA_SIZE);
            pDCI->CurConstAlpha   =
            pDCI->PrevConstAlpha  = (WORD)CurCA;
            PrevCA                = (DMI.Flags & DMIF_GRAY) ? 0xFFFF : 0xFF00;
            CurCA                 = (((CurCA * PrevCA) + 0x7F) / 0xFF);
            PrevCA               -= CurCA;

            for (Index = 0, dwPrim = 0x7F;
                 Index < 256;
                 Index++, dwPrim += CurCA) {

                pCA[Index] = (WORD)(dwPrim / 255);
            }

            if (DMI.Flags & DMIF_GRAY) {

                CopyMemory(pwBGR, pCA, sizeof(WORD) * 256);

            } else {

                Index = 256 * 3;

                while (Index--) {

                    *pwBGR++ = pCA[*pbAB++];
                }
            }

            for (Index = 0, dwPrim = 0x7F;
                 Index < 256;
                 Index++, dwPrim += PrevCA) {

                pCA[Index] = (WORD)(dwPrim / 255);
            }

        } else {

            DBGP_IF(DBGP_CONST_ALPHA,
                    DBGP("** %hs ConstAlpha=%3ld: Use Cache"
                        ARGPTR((DMI.Flags & DMIF_GRAY) ? "GRAY" : "STD")
                        ARGDW(CurCA)));
        }
    }

    DBGP_IF(DBGP_RGBLUTAA,
            DBGP("ComputeRGBLUTAA: PrimAdj.Flags=%08lx"
            ARGDW(pDevClrAdj->PrimAdj.Flags)));

}



#if NO_NEGATIVE_RGB_SCALE


VOID
HTENTRY
ScaleRGB(
    PFD6    pRGB
    )

/*++

Routine Description:

    This function scale out of range RGB back into range and taking the
    lumminance of the color into consideration.

    if any of RGB is less then 0.0 then it will first clamp that to 0.0 and
    it only scale if any of RGB is greater then 1.0

Arguments:

    pRGB    - Pointer to RGB (FD6) prims to be adjust


Return Value:

    VOID


Author:

    08-Mar-1995 Wed 19:19:33 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PFD6    pRGBTmp;
    FD6     MaxClr;
    INT     Idx;


    DEFDBGVAR(FD6,  RGBOld[3])
    DEFDBGVAR(BOOL, Negative = FALSE)



    Idx     = 3;
    pRGBTmp = pRGB;
    MaxClr  = FD6_1;

    while (Idx--) {

        FD6 CurClr;

        //
        // Firstable Clamp the negative component
        //

        if ((CurClr = *pRGBTmp) < FD6_0) {

            *pRGBTmp = FD6_0;

            SETDBGVAR(Negative, TRUE);

        } else if (CurClr > MaxClr) {

            MaxClr = CurClr;
        }

        ++pRGBTmp;

        SETDBGVAR(RGBOld[Idx], CurClr);
    }

    if (MaxClr > FD6_1) {

        //
        // Now Scale it
        //

        *pRGB++ = DivFD6(*pRGB, MaxClr);
        *pRGB++ = DivFD6(*pRGB, MaxClr);
        *pRGB   = DivFD6(*pRGB, MaxClr);

        DBGP_IF(DBGP_SCALE_RGB,
                DBGP("ScaleRGB: %s:%s:%s -> %s:%s:%s, Max=%s%s"
                ARGFD6(RGBOld[2], 1, 6)
                ARGFD6(RGBOld[1], 1, 6)
                ARGFD6(RGBOld[0], 1, 6)
                ARGFD6(*(pRGB - 2), 1, 6)
                ARGFD6(*(pRGB - 1), 1, 6)
                ARGFD6(*(pRGB    ), 1, 6)
                ARGFD6(MaxClr, 1, 6)
                ARG((Negative) ? "*NEG CLAMP*" : "")));
    } else {

        DBGP_IF(DBGP_SCALE_RGB,
            {

                if (Negative) {

                    DBGP("*NEG CLAMP ONLY* ScaleRGB: %s:%s:%s -> %s:%s:%s"
                         ARGFD6(RGBOld[2], 1, 6)
                         ARGFD6(RGBOld[1], 1, 6)
                         ARGFD6(RGBOld[0], 1, 6)
                         ARGFD6(*(pRGB    ), 1, 6)
                         ARGFD6(*(pRGB + 1), 1, 6)
                         ARGFD6(*(pRGB + 2), 1, 6));
                }
            }
        )
    }
}


#else


VOID
HTENTRY
ScaleRGB(
    PFD6    pRGB,
    PFD6    pYrgb
    )

/*++

Routine Description:

    This function scale out of range RGB back into range and taking the
    lumminance of the color into consideration.

    if any of RGB is less then 0.0 then it will first clamp that to 0.0 and
    it only scale if any of RGB is greater then 1.0

Arguments:

    pRGB    - Pointer to RGB (FD6) prims to be adjust

    pYrgb   - Pinter to the Luminance (FD6) of the RGB, if NULL then it is not
              used in the computation


Return Value:

    VOID


Author:

    08-Mar-1995 Wed 19:19:33 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FD6     MaxClr = FD6_1;
    FD6     MinClr = FD6_10;
    FD6     RGBNew[3];
    FD6     RGBOld[3];



    if ((RGBOld[0] = pRGB[0]) > (RGBOld[1] = pRGB[1])) {

        MaxClr = RGBOld[0];
        MinClr = RGBOld[1];

    } else {

        MaxClr = RGBOld[1];
        MinClr = RGBOld[0];
    }

    if ((RGBOld[2] = pRGB[2]) > MaxClr) {

        MaxClr = RGBOld[2];
    }

    if (RGBOld[2] < MinClr) {

        MinClr = RGBOld[2];
    }

    if ((MaxClr <= FD6_1) && (MinClr >= FD6_0)) {

        return;
    }

    if (MinClr >= FD6_1) {

        DBGP_IF((DBGP_SCALE_RGB | DBGP_SCALE_RGB),
                DBGP("** RGB %s:%s:%s is too LIGHT make it WHITE"
                        ARGFD6(RGBOld[0], 1, 6)
                        ARGFD6(RGBOld[1], 1, 6)
                        ARGFD6(RGBOld[2], 1, 6)));

        pRGB[0] =
        pRGB[1] =
        pRGB[2] = FD6_1;

        return;
    }

    if (MaxClr <= FD6_0) {

        DBGP_IF((DBGP_SCALE_RGB | DBGP_SCALE_RGB),
                DBGP("** RGB %s:%s:%s is too DARK make it BLACK"
                        ARGFD6(RGBOld[0], 1, 6)
                        ARGFD6(RGBOld[1], 1, 6)
                        ARGFD6(RGBOld[2], 1, 6)));

        pRGB[0] =
        pRGB[1] =
        pRGB[2] = FD6_0;

        return;
    }

    if (MaxClr < FD6_1) {

        MaxClr = FD6_1;
    }

    if (MinClr > FD6_0) {

        MinClr = FD6_0;
    }

    MaxClr    -= MinClr;
    RGBNew[0]  = DivFD6(RGBOld[0] - MinClr, MaxClr);
    RGBNew[1]  = DivFD6(RGBOld[1] - MinClr, MaxClr);
    RGBNew[2]  = DivFD6(RGBOld[2] - MinClr, MaxClr);

    DBGP_IF(DBGP_SCALE_RGB,
            DBGP("ScaleRGB: %s:%s:%s -> %s:%s:%s, (%s/%s, %s)"
            ARGFD6(RGBOld[0], 1, 6)
            ARGFD6(RGBOld[1], 1, 6)
            ARGFD6(RGBOld[2], 1, 6)
            ARGFD6(RGBNew[0], 1, 6)
            ARGFD6(RGBNew[1], 1, 6)
            ARGFD6(RGBNew[2], 1, 6)
            ARGFD6(MinClr, 1, 6)
            ARGFD6(MaxClr + MinClr, 1, 6)
            ARGFD6(MaxClr, 1, 6)));


    if (pYrgb) {

        FD6 OldY;

        if ((OldY = MulFD6(RGBOld[0], pYrgb[0]) +
                    MulFD6(RGBOld[1], pYrgb[1]) +
                    MulFD6(RGBOld[2], pYrgb[2])) <= FD6_0) {

            DBGP_IF(DBGP_SHOWXFORM_RGB,
                    DBGP("OldY <= 0.0 (%s), Ignore and NO Y Scale"
                        ARGFD6(OldY, 2, 6)));

        } else if (OldY >= FD6_1) {

            DBGP_IF(DBGP_SHOWXFORM_RGB,
                    DBGP("OldY >= 1.0 (%s), Ignore and NO Y Scale"
                        ARGFD6(OldY, 2, 6)));

        } else {

            FD6 NewY;
            FD6 CurRatio;
            FD6 MaxRatio;

            NewY = MulFD6(RGBNew[0], pYrgb[0]) +
                   MulFD6(RGBNew[1], pYrgb[1]) +
                   MulFD6(RGBNew[2], pYrgb[2]);

            DBGP_IF(DBGP_SHOWXFORM_RGB,
                    DBGP("RGBOld=%s:%s:%s [Y=%s] --> New=%s:%s:%s [Y=%s]"
                    ARGFD6(pRGB[0], 1, 6)
                    ARGFD6(pRGB[1], 1, 6)
                    ARGFD6(pRGB[2], 1, 6)
                    ARGFD6(OldY, 1, 6)
                    ARGFD6(RGBNew[0], 1, 6)
                    ARGFD6(RGBNew[1], 1, 6)
                    ARGFD6(RGBNew[2], 1, 6)
                    ARGFD6(NewY, 1, 6)));

            if (OldY != NewY) {

                MaxClr = (RGBNew[0] > RGBNew[1]) ? RGBNew[0] : RGBNew[1];

                if (RGBNew[2] > MaxClr) {

                    MaxClr = RGBNew[2];
                }

                MaxRatio = DivFD6(FD6_1, MaxClr);
                CurRatio = DivFD6(OldY, NewY);

                if (CurRatio > MaxRatio) {

                    CurRatio = MaxRatio;
                }

                RGBNew[0] = MulFD6(RGBNew[0], CurRatio);
                RGBNew[1] = MulFD6(RGBNew[1], CurRatio);
                RGBNew[2] = MulFD6(RGBNew[2], CurRatio);

                DBGP_IF(DBGP_SHOWXFORM_RGB,
                        DBGP("CurRatio%s, MaxRatio=%s, MaxClr=%s"
                        ARGFD6(CurRatio, 1, 6)
                        ARGFD6(MaxRatio, 1, 6)
                        ARGFD6(MaxClr, 1, 6)));
            }
        }
    }

    //
    // Save back and return
    //

    pRGB[0] = RGBNew[0];
    pRGB[1] = RGBNew[1];
    pRGB[2] = RGBNew[2];
}

#endif




LONG
HTENTRY
ComputeBGRMappingTable(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PCOLORTRIAD         pSrcClrTriad,
    PBGR8               pbgr
    )
/*++

Routine Description:

    This functions set up all the DECI4 value in PRIMRGB, PRIMCMY with
    PowerGamma, Brightness, Contrast adjustment and optionally to transform
    to C.I.E. color space and/or do the Colorfulness adjustment.

Arguments:

    pDCI            - Pointer to computed DEVICECOLORINFO

    pDevClrAdj      - Pointer to the pre-computed DEVCLRADJ data structure.

    pSrcClrTriad    - Pointer to the COLORTRIAD strcutrue for computation

    pbgr            - Pointer to the storage for computed BGR table


Return Value:

    Return value LONG

        Count of table generated, if < 0 then it is an error number


Author:

    30-Jan-1991 Wed 13:31:58 created  -by-  Daniel Chou (danielc)


Revision History:

    06-Feb-1992 Thu 21:39:46 updated  -by-  Daniel Chou (danielc)

        Rewrite!

    02-Feb-1994 Wed 17:33:55 updated  -by-  Daniel Chou (danielc)
        Remove unreferenced/unused variable L

    10-May-1994 Tue 11:24:16 updated  -by-  Daniel Chou (danielc)
        Bug# 13329, Memory Leak, Free Up pR_XYZ which I fogot to free it after
        allocated it.

    17-Dec-1998 Thu 16:33:16 updated  -by-  Daniel Chou (danielc)
        Re-organized so it use pbgr now, and it will only generate for color

    15-Feb-1999 Mon 15:40:03 updated  -by-  Daniel Chou (danielc)
        Re-do it only BGR 3 bytes for each entry, and it will generate both
        color or gray scale conversion, all color mapping for coloradjustment
        is done here, this includes internal ICM (when external icm is off)


--*/

{
    PFD6            pPrimA;
    PFD6            pPrimB;
    PFD6            pPrimC;
    LPBYTE          pSrcPrims;
    PCACHERGBTOXYZ  pCRTX;
    PFD6XYZ         pR_XYZ = NULL;
    PFD6XYZ         pG_XYZ;
    PFD6XYZ         pB_XYZ;
    COLORTRIAD      SrcClrTriad;
    PMATRIX3x3      pCMYDyeMasks;
    DWORD           Loop;
    DWORD           CRTXChecksum;
    DWORD           PrimAdjFlags;
    FD6             Prim[3];
    FD6             X;
    FD6             Y;
    FD6             Z;
    FD6             AU;
    FD6             BV;
    FD6             U1;
    FD6             V1;
    FD6             p0;
    FD6             p1;
    FD6             p2;
    FD6             C;
    FD6             W;
    FD6             AutoPrims[3];
    MULDIVPAIR      MDPairs[4];
    MULDIVPAIR      AUMDPairs[3];
    MULDIVPAIR      BVMDPairs[3];
    RGBORDER        RGBOrder;
    INT             TempI;
    INT             TempJ;
    BYTE            DataSet[8];

    DEFDBGVAR(WORD,  ClrNo)
    DEFDBGVAR(BYTE,  dbgR)
    DEFDBGVAR(BYTE,  dbgG)
    DEFDBGVAR(BYTE,  dbgB)

#define _SrcPrimType            DataSet[ 0]
#define _DevBytesPerPrimary     DataSet[ 1]
#define _DevBytesPerEntry       DataSet[ 2]
#define _ColorSpace             DataSet[ 3]
#define _fX                     p0
#define _fY                     p1
#define _fZ                     p2
#define _X15Y3Z                 C
#define _L13                    W

    SETDBGVAR(ClrNo, 0);

    if (pSrcClrTriad) {

        SrcClrTriad  = *pSrcClrTriad;

    } else {

        SrcClrTriad.Type               = COLOR_TYPE_RGB;
        SrcClrTriad.BytesPerPrimary    = 0;
        SrcClrTriad.BytesPerEntry      = 0;
        SrcClrTriad.PrimaryOrder       = PRIMARY_ORDER_RGB;
        SrcClrTriad.PrimaryValueMax    = 0xFF;
        SrcClrTriad.ColorTableEntries  = HT_RGB_CUBE_COUNT;
        SrcClrTriad.pColorTable        = (LPBYTE)&Prim[0];
    }

    if (SrcClrTriad.Type != COLOR_TYPE_RGB) {

        return(HTERR_INVALID_COLOR_TYPE);
    }

    //
    // Two possible cases:
    //
    //  A:  The transform is used for color adjustment only, this is for
    //      HT_AdjustColorTable API call
    //
    //  B:  The halftone is taking places, the final output will be either
    //      Prim1/2 or Prim1/2/3 and each primary must 1 byte long.
    //

    PrimAdjFlags = pDevClrAdj->PrimAdj.Flags;

    ASSERT((PrimAdjFlags & (DCA_HAS_SRC_GAMMA       |
                            DCA_HAS_DEST_GAMMA      |
                            DCA_HAS_BW_REF_ADJ      |
                            DCA_HAS_CONTRAST_ADJ    |
                            DCA_HAS_BRIGHTNESS_ADJ  |
                            DCA_LOG_FILTER          |
                            DCA_NEGATIVE            |
                            DCA_DO_DEVCLR_XFORM)) == 0);

    //
    // We will not do regression (source to destination mapping) for
    //
    //  1. ICM is ON
    //  2. Subtractive with 24bpp
    //  3. Additive surface.
    //

    if (pbgr) {

        _DevBytesPerEntry   = (BYTE)pDevClrAdj->DMI.CTSTDInfo.cbPrim;
        _DevBytesPerPrimary = 1;

        ASSERT(_DevBytesPerEntry == sizeof(BGR8));

    } else {

        return(HTERR_INVALID_COLOR_TYPE);
    }

    if (!(pSrcPrims = (LPBYTE)SrcClrTriad.pColorTable)) {

        return(HTERR_INVALID_COLOR_TABLE);
    }

    //
    // If the total color table entries is less than MIN_CCT_COLORS then
    // we just compute the color directly
    //

    pCRTX = NULL;

    DBGP_IF(DBGP_CCT,
            DBGP("PrimAdjFlags=%08lx" ARGDW(PrimAdjFlags)));

    if (SrcClrTriad.BytesPerPrimary) {

        //
        // Something passed
        //

        RGBOrder = SrcOrderTable[SrcClrTriad.PrimaryOrder];
        pPrimA   = &Prim[RGBOrder.Order[0]];
        pPrimB   = &Prim[RGBOrder.Order[1]];
        pPrimC   = &Prim[RGBOrder.Order[2]];

        DBGP_IF(DBGP_PRIMARY_ORDER,
                DBGP("SOURCE PrimaryOrder: %u [%u] - %u:%u:%u"
                    ARGU(SrcClrTriad.PrimaryOrder)
                    ARGU(RGBOrder.Index)  ARGU(RGBOrder.Order[0])
                    ARGU(RGBOrder.Order[1])  ARGU(RGBOrder.Order[2])));
    }

    //
    // Now compute the cache info
    //

    switch (SrcClrTriad.BytesPerPrimary) {

    case 0:

        SrcClrTriad.BytesPerEntry   = 0;        // stay there!!
        _SrcPrimType                = SRC_BF_HT_RGB;
        SrcClrTriad.PrimaryValueMax = HT_RGB_MAX_COUNT - 1;
        pCRTX                       = pDevClrAdj->pCRTXLevelRGB;

        break;

    case 1:

        _SrcPrimType = SRC_TABLE_BYTE;
        break;

    case 2:

        _SrcPrimType = SRC_TABLE_WORD;
        break;

    case 4:

        _SrcPrimType = SRC_TABLE_DWORD;
        break;

    default:

        return(INTERR_INVALID_SRCRGB_SIZE);
    }

    if (PrimAdjFlags & DCA_NEED_DYES_CORRECTION) {

        pCMYDyeMasks = &(pDevClrAdj->pClrXFormBlock->CMYDyeMasks);
    }

    _ColorSpace = (BYTE)pDevClrAdj->pClrXFormBlock->ColorSpace;

    if (((_ColorSpace == CIELUV_1976) &&
         ((pDevClrAdj->PrimAdj.rgbCSXForm.xW !=
                                pDevClrAdj->PrimAdj.DevCSXForm.xW)    ||
          (pDevClrAdj->PrimAdj.rgbCSXForm.yW !=
                                pDevClrAdj->PrimAdj.DevCSXForm.yW)))  ||
        (PrimAdjFlags & (DCA_HAS_CLRSPACE_ADJ   |
                         DCA_HAS_COLOR_ADJ      |
                         DCA_HAS_TINT_ADJ))) {

        TempI = 1;
        TempJ = (_ColorSpace == CIELUV_1976) ? MULDIV_HAS_DIVISOR :
                                               MULDIV_NO_DIVISOR;
        C     = FD6_1;
        AU    =
        BV    = (PrimAdjFlags & DCA_HAS_COLOR_ADJ) ?
                                pDevClrAdj->PrimAdj.Color : FD6_1;

        if (PrimAdjFlags & DCA_HAS_TINT_ADJ) {

            if (_ColorSpace == CIELAB_1976) {

                AU = FD6xL(AU, 500);
                BV = FD6xL(BV, 200);
            }

            TempI                  = 2;
            TempJ                  = MULDIV_HAS_DIVISOR;
            C                      = pDevClrAdj->PrimAdj.TintSinAngle;
            AUMDPairs[2].Pair1.Mul = MulFD6(BV, -C);
            BVMDPairs[2].Pair1.Mul = MulFD6(AU,  C);
            C                      = pDevClrAdj->PrimAdj.TintCosAngle;

            MAKE_MULDIV_DVSR(AUMDPairs, (FD6)500000000);
            MAKE_MULDIV_DVSR(BVMDPairs, (FD6)200000000);
        }

        AUMDPairs[1].Pair1.Mul = MulFD6(AU, C);
        BVMDPairs[1].Pair1.Mul = MulFD6(BV, C);

        MAKE_MULDIV_INFO(AUMDPairs, TempI, TempJ);
        MAKE_MULDIV_INFO(BVMDPairs, TempI, TempJ);
    }

    DBGP_IF(DBGP_SHOWXFORM_ALL,
            DBGP("iUVw = %s,%s, iRefXYZ = %s, %s, %s"
                ARGFD6(iUw,  1, 6)
                ARGFD6(iVw,  1, 6)
                ARGFD6(iRefXw, 1, 6)
                ARGFD6(iRefYw, 1, 6)
                ARGFD6(iRefZw, 1, 6)));

    DBGP_IF(DBGP_SHOWXFORM_ALL,
            DBGP("oUVw = %s,%s, oRefXYZ = %s, %s, %s"
                ARGFD6(oUw,  1, 6)
                ARGFD6(oVw,  1, 6)
                ARGFD6(oRefXw, 1, 6)
                ARGFD6(oRefYw, 1, 6)
                ARGFD6(oRefZw, 1, 6)));

    if (pCRTX) {

        DBGP_IF(DBGP_CCT,
                DBGP("*** Allocate %u bytes RGB->XYZ xform table ***"
                        ARGU(pCRTX->SizeCRTX)));

        if (pR_XYZ = (PFD6XYZ)HTAllocMem((LPVOID)pDCI,
                                         HTMEM_RGBToXYZ,
                                         NONZEROLPTR,
                                         pCRTX->SizeCRTX)) {

            Loop = (DWORD)(pCRTX->PrimMax + 1);

            //
            // Save current flags back before calling, since CachedRGBToXYZ
            // may change this flags for DCA_xxx
            //

            pCRTX                        = CacheRGBToXYZ(pCRTX,
                                                         pR_XYZ,
                                                         &CRTXChecksum,
                                                         pDevClrAdj);
            pG_XYZ                       = pR_XYZ + Loop;
            pB_XYZ                       = pG_XYZ + Loop;
            SrcClrTriad.PrimaryValueMax  = 0;

            DBGP_IF(DBGP_CCT, DBGP("*** Has RGB->XYZ xform table ***"));

        } else {

            DBGP_IF(DBGP_CCT, DBGP("Allocate RGB->XYZ xform table failed !!"));
        }
    }

    if (SrcClrTriad.PrimaryValueMax == (LONG)FD6_1) {

        SrcClrTriad.PrimaryValueMax = 0;
    }

    //
    // Starting the big Loop, reset AutoCur = AutoMax so it recycle back to
    // 0:0:0
    //

    MAKE_MULDIV_SIZE(MDPairs, 3);
    MAKE_MULDIV_FLAG(MDPairs, MULDIV_NO_DIVISOR);

    AutoPrims[0] =
    AutoPrims[1] =
    AutoPrims[2] = FD6_0;
    Loop         = SrcClrTriad.ColorTableEntries;

    DBGP_IF(DBGP_CCT,
            DBGP("Compute %ld COLOR of %s type [%p]"
                ARGDW(Loop)
                ARG(pSrcPrimTypeName[_SrcPrimType])
                ARGPTR(pSrcPrims)));

    //
    // 0. Get The source prim into the Prim[]
    //

    while (Loop--) {

        switch (_SrcPrimType) {

        case SRC_BF_HT_RGB:

            //
            // This format always in BGR order
            //

            Prim[0] = AutoPrims[0];     // R
            Prim[1] = AutoPrims[1];     // G
            Prim[2] = AutoPrims[2];     // B

            if (++AutoPrims[0] >= (FD6)HT_RGB_MAX_COUNT) {

                AutoPrims[0] = FD6_0;

                if (++AutoPrims[1] >= (FD6)HT_RGB_MAX_COUNT) {

                    AutoPrims[1] = FD6_0;

                    if (++AutoPrims[2] >= (FD6)HT_RGB_MAX_COUNT) {

                        AutoPrims[2] = FD6_0;
                    }
                }
            }

            DBGP_IF(DBGP_SHOWXFORM_ALL, DBGP("HT555: Prim[3]= %2ld:%2ld:%2ld, %s:%s:%s, (%ld / %ld)"
                        ARGDW(Prim[0])
                        ARGDW(Prim[1])
                        ARGDW(Prim[2])
                        ARGFD6(DivFD6(Prim[0], (FD6)(HT_RGB_MAX_COUNT - 1)), 1, 6)
                        ARGFD6(DivFD6(Prim[1], (FD6)(HT_RGB_MAX_COUNT - 1)), 1, 6)
                        ARGFD6(DivFD6(Prim[2], (FD6)(HT_RGB_MAX_COUNT - 1)), 1, 6)
                        ARGDW(HT_RGB_MAX_COUNT)
                        ARGDW(SrcClrTriad.PrimaryValueMax)));

            break;

        case SRC_TABLE_BYTE:

            *pPrimA = (FD6)(*(LPBYTE)(pSrcPrims                     ));
            *pPrimB = (FD6)(*(LPBYTE)(pSrcPrims + (sizeof(BYTE) * 1)));
            *pPrimC = (FD6)(*(LPBYTE)(pSrcPrims + (sizeof(BYTE) * 2)));
            break;

        case SRC_TABLE_WORD:

            *pPrimA = (FD6)(*(LPSHORT)(pSrcPrims                      ));
            *pPrimB = (FD6)(*(LPSHORT)(pSrcPrims + (sizeof(SHORT) * 1)));
            *pPrimC = (FD6)(*(LPSHORT)(pSrcPrims + (sizeof(SHORT) * 2)));
            break;

        case SRC_TABLE_DWORD:

            *pPrimA = (FD6)(*(PFD6)(pSrcPrims                    ));
            *pPrimB = (FD6)(*(PFD6)(pSrcPrims + (sizeof(FD6) * 1)));
            *pPrimC = (FD6)(*(PFD6)(pSrcPrims + (sizeof(FD6) * 2)));
            break;
        }

        SETDBGVAR(dbgR, (BYTE)Prim[0]);
        SETDBGVAR(dbgG, (BYTE)Prim[1]);
        SETDBGVAR(dbgB, (BYTE)Prim[2]);

        pSrcPrims += SrcClrTriad.BytesPerEntry;

        //
        // 1. First convert the Input value to FD6
        //

        if (SrcClrTriad.PrimaryValueMax) {

            Prim[0] = DivFD6(Prim[0], SrcClrTriad.PrimaryValueMax);
            Prim[1] = DivFD6(Prim[1], SrcClrTriad.PrimaryValueMax);
            Prim[2] = DivFD6(Prim[2], SrcClrTriad.PrimaryValueMax);
        }

        //
        // 2: Transform from RGB (gamma correction) -> XYZ -> L*A*B* or L*U*V*
        //    This only done if any of DCA_HAS_COLOR_ADJ or DCA_HAS_TINT_ADJ
        //

        if (PrimAdjFlags & (DCA_HAS_CLRSPACE_ADJ    |
                            DCA_HAS_COLOR_ADJ       |
                            DCA_HAS_TINT_ADJ)) {

            // If we only doing monochrome, then we only need Y/L pair only,
            // else convert it to the XYZ/LAB/LUV
            //

            if (pR_XYZ) {

                X = pR_XYZ[Prim[0]].X +
                    pG_XYZ[Prim[1]].X +
                    pB_XYZ[Prim[2]].X;

                Y = pR_XYZ[Prim[0]].Y +
                    pG_XYZ[Prim[1]].Y +
                    pB_XYZ[Prim[2]].Y;

                Z = pR_XYZ[Prim[0]].Z +
                    pG_XYZ[Prim[1]].Z +
                    pB_XYZ[Prim[2]].Z;

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("Yrgb: %s:%s:%s"
                            ARGFD6(pR_XYZ[Prim[0]].Y, 1, 6)
                            ARGFD6(pG_XYZ[Prim[1]].Y, 1, 6)
                            ARGFD6(pB_XYZ[Prim[2]].Y, 1, 6)));


            } else {

                MAKE_MULDIV_FLAG(MDPairs, MULDIV_NO_DIVISOR);

                MAKE_MULDIV_PAIR(
                            MDPairs, 1,
                            CIE_Xr(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[0]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 2,
                            CIE_Xg(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[1]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 3,
                            CIE_Xb(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[2]);

                X = MulDivFD6Pairs(MDPairs);

                //
                // Compute CIE L from CIE Y tristimulus value
                //
                // L* = (1.16 x f(Y/Yw)) - 0.16
                //
                //                 1/3
                //  f(Y/Yw) = (Y/Yw)                (Y/Yw) >  0.008856
                //  f(Y/Yw) = 9.033 x (Y/Yw)        (Y/Yw) <= 0.008856
                //
                //
                // Our L* is range from 0.0 to 1.0, not 0.0 to 100.0
                //

                MAKE_MULDIV_PAIR(
                            MDPairs, 1,
                            CIE_Yr(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[0]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 2,
                            CIE_Yg(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[1]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 3,
                            CIE_Yb(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[2]);

                Y = MulDivFD6Pairs(MDPairs);

                MAKE_MULDIV_PAIR(
                            MDPairs, 1,
                            CIE_Zr(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[0]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 2,
                            CIE_Zg(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[1]);
                MAKE_MULDIV_PAIR(
                            MDPairs, 3,
                            CIE_Zb(pDevClrAdj->PrimAdj.rgbCSXForm.M3x3),
                            Prim[2]);

                Z = MulDivFD6Pairs(MDPairs);

            }

            switch (_ColorSpace) {

            case CIELUV_1976:

                //
                // U' = 4X / (X + 15Y + 3Z)
                // V' = 9Y / (X + 15Y + 3Z)
                //
                // U* = 13 x L x (U' - Uw)
                // V* = 13 x L x (V' - Vw)
                //

                _X15Y3Z = X + FD6xL(Y, 15) + FD6xL(Z, 3);
                U1      = DivFD6(FD6xL(X, 4), _X15Y3Z) - iUw;
                V1      = DivFD6(FD6xL(Y, 9), _X15Y3Z) - iVw;
                _L13    = FD6xL(CIE_I2L(Y), 13);
                AU      = MulFD6(_L13, U1);
                BV      = MulFD6(_L13, V1);

                MAKE_MULDIV_DVSR(AUMDPairs, _L13);
                MAKE_MULDIV_DVSR(BVMDPairs, _L13);

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("     << UV1: %s:%s [%s:%s], X15Y3Z=%s"
                        ARGFD6(U1,  2, 6)
                        ARGFD6(V1,  2, 6)
                        ARGFD6(U1 + iUw, 2, 6)
                        ARGFD6(V1 + iVw, 2, 6)
                        ARGFD6(_X15Y3Z,  2, 6)));

                break;

            case CIELAB_1976:
            default:

                //
                // CIELAB 1976 L*A*B*
                //
                //  A* = 500 x (fX - fY)
                //  B* = 200 x (fY - fZ)
                //
                //             1/3
                //  fX = (X/Xw)                     (X/Xw) >  0.008856
                //  fX = 7.787 x (X/Xw) + (16/116)  (X/Xw) <= 0.008856
                //
                //             1/3
                //  fY = (Y/Yw)                     (Y/Yw) >  0.008856
                //  fY = 7.787 Y (Y/Yw) + (16/116)  (Y/Yw) <= 0.008856
                //
                //             1/3
                //  fZ = (Z/Zw)                     (Z/Zw) >  0.008856
                //  fZ = 7.787 Z (Z/Zw) + (16/116)  (Z/Zw) <= 0.008856
                //

                fXYZFromXYZ(_fX, X, iRefXw);
                fXYZFromXYZ(_fY, Y, FD6_1);
                fXYZFromXYZ(_fZ, Z, iRefZw);

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("     >> fXYZ: %s:%s:%s"
                        ARGFD6(_fX,  2, 6)
                        ARGFD6(_fY,  2, 6)
                        ARGFD6(_fZ,  2, 6)));

                AU = _fX - _fY;
                BV = _fY - _fZ;

                //
                // DO NOT Translate it now
                //

                if ((AU >= (FD6)-20) && (AU <= (FD6)20) &&
                    (BV >= (FD6)-20) && (BV <= (FD6)20)) {

                    DBGP_IF(DBGP_MONO_PRIM,
                            DBGP("*** MONO PRIMS: %s:%s:%s --> Y=%s"
                                    ARGFD6(DivFD6(dbgR, 255), 1, 6)
                                    ARGFD6(DivFD6(dbgG, 255), 1, 6)
                                    ARGFD6(DivFD6(dbgB, 255), 1, 6)
                                    ARGFD6(Y, 1, 6)));
                }

                break;
            }

            DBGP_IF(DBGP_SHOWXFORM_ALL,
                    DBGP("     XYZ->%s: %s:%s:%s >> L:%s:%s"
                        ARG(pDbgCSName[_ColorSpace])
                        ARGFD6(X,  2, 6)
                        ARGFD6(Y,  1, 6)
                        ARGFD6(Z,  2, 6)
                        ARGFD6(AU, 4, 6)
                        ARGFD6(BV, 4, 6)));

            //
            // 5: Do any Color Adjustments (in LAB/LUV)
            //

            AUMDPairs[1].Pair2 =
            BVMDPairs[2].Pair2 = AU;
            AUMDPairs[2].Pair2 =
            BVMDPairs[1].Pair2 = BV;

            AU = MulDivFD6Pairs(AUMDPairs);
            BV = MulDivFD6Pairs(BVMDPairs);

            //
            // 6: Transform From LAB/LUV->XYZ->RGB with possible gamma
            //    correction
            //
            // L* = (1.16 x f(Y/Yw)) - 0.16
            //
            //                 1/3
            //  f(Y/Yw) = (Y/Yw)                (Y/Yw) >  0.008856
            //  f(Y/Yw) = 9.033 x (Y/Yw)        (Y/Yw) <= 0.008856
            //

            switch (_ColorSpace) {

            case CIELUV_1976:

                //
                // U' = 4X / (X + 15Y + 3Z)
                // V' = 9Y / (X + 15Y + 3Z)
                //
                // U* = 13 x L x (U' - Uw)
                // V* = 13 x L x (V' - Vw)
                //

                if (((V1 = BV + oVw) < FD6_0) ||
                    ((_X15Y3Z = DivFD6(FD6xL(Y, 9), V1)) < FD6_0)) {

                    _X15Y3Z = (FD6)2147000000;
                }

                if ((U1 = AU + oUw) < FD6_0) {

                    X  =
                    U1 = FD6_0;

                } else {

                    X = FD6DivL(MulFD6(_X15Y3Z, U1), 4);
                }

                Z = FD6DivL(_X15Y3Z - X - FD6xL(Y, 15), 3);

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("     >> UV1: %s:%s [%s:%s], X15Y3Z=%s"
                        ARGFD6(U1 - oUw,  2, 6)
                        ARGFD6(V1 - oVw,  2, 6)
                        ARGFD6(U1, 2, 6)
                        ARGFD6(V1, 2, 6)
                        ARGFD6(_X15Y3Z,  2, 6)));

                break;

            case CIELAB_1976:
            default:

                //
                // CIELAB 1976 L*A*B*
                //
                //  A* = 500 x (fX - fY)
                //  B* = 200 x (fY - fZ)
                //
                //             1/3
                //  fX = (X/Xw)                     (X/Xw) >  0.008856
                //  fX = 7.787 x (X/Xw) + (16/116)  (X/Xw) <= 0.008856
                //
                //             1/3
                //  fY = (Y/Yw)                     (Y/Yw) >  0.008856
                //  fY = 7.787 Y (Y/Yw) + (16/116)  (Y/Yw) <= 0.008856
                //
                //             1/3
                //  fZ = (Z/Zw)                     (Z/Zw) >  0.008856
                //  fZ = 7.787 Z (Z/Zw) + (16/116)  (Z/Zw) <= 0.008856
                //

                // _fX = FD6DivL(AU, 500) + _fY;
                // _fZ = _fY - FD6DivL(BV, 200);

                _fX = AU + _fY;
                _fZ = _fY - BV;

                XYZFromfXYZ(X, _fX, oRefXw);
                XYZFromfXYZ(Z, _fZ, oRefZw);

                DBGP_IF(DBGP_SHOWXFORM_ALL,
                        DBGP("     << fXYZ: %s:%s:%s"
                        ARGFD6(_fX,  2, 6)
                        ARGFD6(_fY,  2, 6)
                        ARGFD6(_fZ,  2, 6)));



                break;
            }

            DBGP_IF(DBGP_SHOWXFORM_ALL,
                DBGP("     %s->XYZ: %s:%s:%s << L:%s:%s"
                ARG(pDbgCSName[_ColorSpace])
                ARGFD6(X,  2, 6)
                ARGFD6(Y,  1, 6)
                ARGFD6(Z,  2, 6)
                ARGFD6(AU, 4, 6)
                ARGFD6(BV, 4, 6)));

            MAKE_MULDIV_FLAG(MDPairs, MULDIV_NO_DIVISOR);

            MAKE_MULDIV_PAIR(MDPairs, 1,
                        CIE_Xr(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), X);
            MAKE_MULDIV_PAIR(MDPairs, 2,
                        CIE_Xg(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Y);
            MAKE_MULDIV_PAIR(MDPairs, 3,
                        CIE_Xb(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Z);

            Prim[0] = MulDivFD6Pairs(MDPairs);

            MAKE_MULDIV_PAIR(MDPairs, 1,
                        CIE_Yr(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), X);
            MAKE_MULDIV_PAIR(MDPairs, 2,
                        CIE_Yg(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Y);
            MAKE_MULDIV_PAIR(MDPairs, 3,
                        CIE_Yb(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Z);

            Prim[1] = MulDivFD6Pairs(MDPairs);

            MAKE_MULDIV_PAIR(MDPairs, 1,
                        CIE_Zr(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), X);
            MAKE_MULDIV_PAIR(MDPairs, 2,
                        CIE_Zg(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Y);
            MAKE_MULDIV_PAIR(MDPairs, 3,
                        CIE_Zb(pDevClrAdj->PrimAdj.DevCSXForm.M3x3), Z);

            Prim[2] = MulDivFD6Pairs(MDPairs);

            //
            // Make sure everthing is in the range
            //

            SCALE_PRIM_RGB(Prim, NULL);

            DBGP_IF(DBGP_SHOWXFORM_ALL,
                    DBGP("     XYZ->RGB: %s:%s:%s >> %s:%s:%s"
                        ARGFD6(X,  2, 6) ARGFD6(Y,  1, 6)
                        ARGFD6(Z,  2, 6) ARGFD6(Prim[0], 1, 6)
                        ARGFD6(Prim[1], 1, 6) ARGFD6(Prim[2], 1, 6)));
        }

        //
        // 3: Dye correction if necessary
        //

        if (PrimAdjFlags & DCA_NEED_DYES_CORRECTION) {

            if (PrimAdjFlags & DCA_HAS_BLACK_DYE) {

                MAX_OF_3(W, Prim[0], Prim[1], Prim[2]);

            } else {

                W = FD6_1;
            }

            p0 = W - Prim[0];
            p1 = W - Prim[1];
            p2 = W - Prim[2];

            DBGP_IF(DBGP_DYE_CORRECT,
                    DBGP("    DYE_CORRECT: %s:%s:%s, W=%s --> %s:%s:%s"
                        ARGFD6(Prim[0],  2, 6) ARGFD6(Prim[1],  2, 6)
                        ARGFD6(Prim[2],  2, 6) ARGFD6(W, 1, 6)
                        ARGFD6(p0,  2, 6) ARGFD6(p1,  2, 6)
                        ARGFD6(p2,  2, 6)));

            MAKE_MULDIV_FLAG(MDPairs, MULDIV_NO_DIVISOR);

            MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Xr((*pCMYDyeMasks)), p0);
            MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Xg((*pCMYDyeMasks)), p1);
            MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Xb((*pCMYDyeMasks)), p2);

            Prim[0] = W - MulDivFD6Pairs(MDPairs);

            MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Yr((*pCMYDyeMasks)), p0);
            MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Yg((*pCMYDyeMasks)), p1);
            MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Yb((*pCMYDyeMasks)), p2);

            Prim[1] = W - MulDivFD6Pairs(MDPairs);

            MAKE_MULDIV_PAIR(MDPairs, 1, CIE_Zr((*pCMYDyeMasks)), p0);
            MAKE_MULDIV_PAIR(MDPairs, 2, CIE_Zg((*pCMYDyeMasks)), p1);
            MAKE_MULDIV_PAIR(MDPairs, 3, CIE_Zb((*pCMYDyeMasks)), p2);

            Prim[2] = W - MulDivFD6Pairs(MDPairs);

            DBGP_IF(DBGP_DYE_CORRECT,
                    DBGP("    DYE_CORRECT: %s:%s:%s << %s:%s:%s"
                        ARGFD6(Prim[0],  2, 6) ARGFD6(Prim[1],  2, 6)
                        ARGFD6(Prim[2],  2, 6) ARGFD6(p0,  2, 6)
                        ARGFD6(p1,  2, 6)      ARGFD6(p2,  2, 6)));

            CLAMP_01(Prim[0]);
            CLAMP_01(Prim[1]);
            CLAMP_01(Prim[2]);
        }

        //*******************************************************************
        //
        // 4: Compute Final Device DYE through device color mapping and
        //    Primary/Halftone Cell number computation, The Primaries (ie.
        //    Prim[]) are in ADDITIVE FORMAT
        //
        //*******************************************************************

        //
        // Store in BGRF in this order
        //

        (pbgr  )->r = (BYTE)MulFD6(Prim[0], 0xFF);
        (pbgr  )->g = (BYTE)MulFD6(Prim[1], 0xFF);
        (pbgr++)->b = (BYTE)MulFD6(Prim[2], 0xFF);

        DBGP_IF(DBGP_SHOWXFORM_ALL,
                DBGP("    MAPPING(%3ld:%3ld:%3ld): %s:%s:%s ---> %3ld:%3ld:%3ld"
                    ARGDW(dbgR) ARGDW(dbgG) ARGDW(dbgB)
                    ARGFD6(Prim[0],  2, 6) ARGFD6(Prim[1],  2, 6)
                    ARGFD6(Prim[2],  2, 6) ARGDW((pbgr - 1)->r)
                    ARGDW((pbgr - 1)->g) ARGDW((pbgr - 1)->b)));
    }

    if ((pR_XYZ) && (pCRTX)) {

        if (!pCRTX->pFD6XYZ) {

            DBGP_IF(DBGP_CCT,
                    DBGP("CCT: Allocate %ld bytes RGB->XYZ xform cached table"
                            ARGDW(pCRTX->SizeCRTX)));

            if (!(pCRTX->pFD6XYZ =
                    (PFD6XYZ)HTAllocMem((LPVOID)pDCI,
                                        HTMEM_CacheCRTX,
                                        NONZEROLPTR,
                                        pCRTX->SizeCRTX))) {

                DBGP_IF(DBGP_CCT,
                        DBGP("Allocate %ld bytes of RGB->XYZ cached table failed"
                                ARGDW(pCRTX->SizeCRTX)));
            }
        }

        if (pCRTX->pFD6XYZ) {

            DBGP_IF(DBGP_CCT,
                    DBGP("CCT: *** Save computed RGB->XYZ xform to CACHE ***"));

            pCRTX->Checksum = CRTXChecksum;

            CopyMemory(pCRTX->pFD6XYZ, pR_XYZ, pCRTX->SizeCRTX);
        }
    }

    if (pR_XYZ) {

        DBGP_IF(DBGP_CCT,
                DBGP("ColorTriadSrcToDev: Free Up pR_XYZ local cached table"));

        HTFreeMem(pR_XYZ);
    }

    return((LONG)SrcClrTriad.ColorTableEntries);


#undef _SrcPrimType
#undef _DevBytesPerPrimary
#undef _DevBytesPerEntry
#undef _ColorSpace
#undef _fX
#undef _fY
#undef _fZ
#undef _X15Y3Z
#undef _L13

}


#if DBG


VOID
ShowBGRMC(
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Oct-2000 Fri 17:01:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    i;

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    i = HTGlobal.cBGRMC;

    DBGP_IF(DBGP_BGRMAPTABLE, DBGP("\n================"));

    while (i-- > 0) {

        DBGP_IF(DBGP_BGRMAPTABLE,
                DBGP("    --- %3ld: pMap=%p, Checksum=%08lx, cRef=%4ld"
                    ARGDW(i)
                    ARGPTR(HTGlobal.pBGRMC[i].pMap)
                    ARGDW(HTGlobal.pBGRMC[i].Checksum)
                    ARGDW(HTGlobal.pBGRMC[i].cRef)));
    }

    DBGP_IF(DBGP_BGRMAPTABLE, DBGP("================\n"));

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);
}


    #if 1
        #define SHOW_BGRMC()
    #else
        #define SHOW_BGRMC()    ShowBGRMC()
    #endif
#else
    #define SHOW_BGRMC()
#endif



LONG
TrimBGRMapCache(
    VOID
    )

/*++

Routine Description:

    This function trim the BGRMAPCache back to BGRMC_MAX_COUNT if possible

Arguments:

    VOID


Return Value:

    Total count that removed


Author:

    06-Oct-2000 Fri 14:24:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PBGRMAPCACHE    pSave;
    PBGRMAPCACHE    pCur;
    LONG            cb;
    LONG            Count = 0;
    LONG            cTot;


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    if ((HTGlobal.cBGRMC > BGRMC_MAX_COUNT) && (HTGlobal.cIdleBGRMC)) {

        pSave   =
        pCur    = HTGlobal.pBGRMC;
        cTot    =
        Count   = HTGlobal.cBGRMC;

        while ((cTot--) && (HTGlobal.cBGRMC > BGRMC_MAX_COUNT)) {

            if (pCur->cRef == 0) {

                DBGP_IF(DBGP_BGRMAPTABLE,
                        DBGP("Remove %ld, pMap=%p"
                            ARGDW((DWORD)(pCur - HTGlobal.pBGRMC))
                            ARGPTR(pCur->pMap)));

                HTFreeMem(pCur->pMap);

                --HTGlobal.cBGRMC;
                --HTGlobal.cIdleBGRMC;

            } else {

                if (pSave != pCur) {

                    *pSave = *pCur;
                }

                ++pSave;
            }

            ++pCur;
        }

        DBGP_IF(DBGP_BGRMAPTABLE,
            DBGP("pSave=%p, pCur=%p, (%ld), [%ld / %ld]"
                ARGPTR(pSave) ARGPTR(pCur) ARGDW((DWORD)(pCur - pSave))
                ARGDW((DWORD)(&HTGlobal.pBGRMC[Count] - pCur))
                ARGDW((DWORD)((LPBYTE)&HTGlobal.pBGRMC[Count] - (LPBYTE)pCur))));

        if (Count != HTGlobal.cBGRMC) {

            if ((pCur > pSave)  &&
                ((cb = (LONG)((LPBYTE)&HTGlobal.pBGRMC[Count] -
                              (LPBYTE)pCur)) > 0)) {

                CopyMemory(pSave, pCur, cb);
            }

            Count -= HTGlobal.cBGRMC;

            DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("TriBGRMapCache=%ld" ARGDW(Count)));

        } else {

            DBGP_IF(DBGP_BGRMAPTABLE, DBGP("!!!! TriBGRMapCache=0"));
        }
    }

    DBGP_IF(DBGP_BGRMAPTABLE,
            DBGP("  TTrimBGRMapCache: pBGRMC=%p, cBGRMC=%ld, cIdleBGRMC=%ld, cAllocBGRMC=%ld"
                        ARGPTR(HTGlobal.pBGRMC) ARGDW(HTGlobal.cBGRMC)
                        ARGDW(HTGlobal.cIdleBGRMC) ARGDW(HTGlobal.cAllocBGRMC)));

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    ASSERT(HTGlobal.cBGRMC >= 0);
    ASSERT(HTGlobal.cIdleBGRMC <= HTGlobal.cBGRMC);
    ASSERT(HTGlobal.cIdleBGRMC >= 0);

    SHOW_BGRMC();

    return(Count);
}



PBGR8
FindBGRMapCache(
    PBGR8   pDeRefMap,
    DWORD   Checksum
    )

/*++

Routine Description:

    This function found a BGRMapCache with same checksum and move that
    link to the begining.


Arguments:

    pDeRefMap   - Find pMap for deference (NULL if not)

    Checksum    - Find checksum (only if pDeRefMap == NULL


Return Value:

    PBGR8   - The map that found


Author:

    06-Oct-2000 Fri 13:30:14 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Count;
    PBGR8   pRet = NULL;


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    if ((HTGlobal.pBGRMC) && (Count = HTGlobal.cBGRMC)) {

        PBGRMAPCACHE    pCur = &HTGlobal.pBGRMC[Count - 1];

        while ((Count) && (!pRet)) {

            if (pDeRefMap == pCur->pMap) {

                ASSERT(pCur->cRef);

                pRet = pDeRefMap;

                if (pCur->cRef) {

                    if (--pCur->cRef == 0) {

                        ++HTGlobal.cIdleBGRMC;
                    }
                }

            } else if (pCur->Checksum == Checksum) {

                DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("find Cached %08lx = %p at Index %ld, cRef=%ld"
                            ARGDW(Checksum) ARGPTR(pCur->pMap)
                            ARGDW((DWORD)(pCur - HTGlobal.pBGRMC))
                            ARGDW(pCur->cRef)));

                pRet = pCur->pMap;

                if (pCur->cRef++ == 0) {

                    --HTGlobal.cIdleBGRMC;
                }

                //
                // Move this reference to the end of the list as most recent
                //

                if (Count < HTGlobal.cBGRMC) {

                    BGRMAPCACHE BGRMC = *pCur;

                    CopyMemory(pCur,
                               pCur + 1,
                               (HTGlobal.cBGRMC - Count) * sizeof(BGRMAPCACHE));

                    HTGlobal.pBGRMC[HTGlobal.cBGRMC - 1] = BGRMC;
                }
            }

            --Count;
            --pCur;
        }
    }

    if ((pDeRefMap) && (!pRet)) {

        DBGP_IF(DBGP_BGRMAPTABLE,
                DBGP("Cannot find the pMap=%p that to be DeReference"
                            ARGPTR(pDeRefMap)));
    }

    DBGP_IF(DBGP_BGRMAPTABLE,
                DBGP("%s_BGRMapCache(%p, %08lx): pBGRMC=%p, cBGRMC=%ld, cIdleBGRMC=%ld, cAllocBGRMC=%ld"
                        ARGPTR((pDeRefMap) ? "DEREF" : " FIND")
                        ARGPTR(pDeRefMap) ARGDW(Checksum)
                        ARGPTR(HTGlobal.pBGRMC) ARGDW(HTGlobal.cBGRMC)
                        ARGDW(HTGlobal.cIdleBGRMC) ARGDW(HTGlobal.cAllocBGRMC)));

    if ((HTGlobal.cBGRMC > BGRMC_MAX_COUNT) && (HTGlobal.cIdleBGRMC)) {

        TrimBGRMapCache();
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    ASSERT(HTGlobal.cBGRMC >= 0);
    ASSERT(HTGlobal.cIdleBGRMC <= HTGlobal.cBGRMC);
    ASSERT(HTGlobal.cIdleBGRMC >= 0);

    SHOW_BGRMC();

    return(pRet);
}




BOOL
AddBGRMapCache(
    PBGR8   pMap,
    DWORD   Checksum
    )

/*++

Routine Description:

    Add pMap with Checksum to the cache table


Arguments:




Return Value:




Author:

    06-Oct-2000 Fri 13:29:52 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PBGRMAPCACHE    pBGRMC;
    LONG            cAlloc;
    BOOL            bRet = TRUE;


    ACQUIRE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    if ((HTGlobal.cBGRMC > BGRMC_MAX_COUNT) && (HTGlobal.cIdleBGRMC)) {

        TrimBGRMapCache();
    }

    ASSERT(HTGlobal.cBGRMC <= HTGlobal.cAllocBGRMC);

    if (HTGlobal.cBGRMC >= (cAlloc = HTGlobal.cAllocBGRMC)) {

        DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("AddBGRMapCache() Increase cAllocBGRMC %ld to %ld"
                            ARGDW(HTGlobal.cAllocBGRMC)
                            ARGDW(HTGlobal.cAllocBGRMC + BGRMC_SIZE_INC)));

        cAlloc += BGRMC_SIZE_INC;

        if (pBGRMC = (PBGRMAPCACHE)HTAllocMem((LPVOID)NULL,
                                              HTMEM_BGRMC_CACHE,
                                              LPTR,
                                              cAlloc * sizeof(BGRMAPCACHE))) {

            if (HTGlobal.pBGRMC) {

                CopyMemory(pBGRMC,
                           HTGlobal.pBGRMC,
                           HTGlobal.cBGRMC * sizeof(BGRMAPCACHE));

                HTFreeMem(HTGlobal.pBGRMC);
            }

            HTGlobal.pBGRMC      = pBGRMC;
            HTGlobal.cAllocBGRMC = cAlloc;

        } else {

            DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("AddBGRMapCache() Allocation %ld bytes of Memory Failed"
                        ARGDW(HTGlobal.cAllocBGRMC * sizeof(BGRMAPCACHE))));
        }
    }

    if ((HTGlobal.pBGRMC) &&
        (HTGlobal.cBGRMC < HTGlobal.cAllocBGRMC)) {

        pBGRMC           = &HTGlobal.pBGRMC[HTGlobal.cBGRMC++];
        pBGRMC->pMap     = pMap;
        pBGRMC->Checksum = Checksum;
        pBGRMC->cRef     = 1;

        DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP(" AddBGRMapCache() Added %p (%08lx) to Cache"
                            ARGPTR(pMap) ARGDW(Checksum)));

    } else {

        bRet = FALSE;
    }

    DBGP_IF(DBGP_BGRMAPTABLE,
                DBGP("   AddBGRMapCache: pBGRMC=%p, cBGRMC=%ld, cIdleBGRMC=%ld, cAllocBGRMC=%ld"
                        ARGPTR(HTGlobal.pBGRMC) ARGDW(HTGlobal.cBGRMC)
                        ARGDW(HTGlobal.cIdleBGRMC) ARGDW(HTGlobal.cAllocBGRMC)));

    RELEASE_HTMUTEX(HTGlobal.HTMutexBGRMC);

    ASSERT(HTGlobal.cBGRMC >= 0);
    ASSERT(HTGlobal.cIdleBGRMC <= HTGlobal.cBGRMC);
    ASSERT(HTGlobal.cIdleBGRMC >= 0);

    SHOW_BGRMC();

    return(bRet);
}




LONG
HTENTRY
CreateDyesColorMappingTable(
    PHALFTONERENDER pHR
    )

/*++

Routine Description:

    this function allocate the memory for the dyes color mapping table depends
    on the source surface type information, it then go throug the color table
    and calculate dye densities for each RGB color in the color table.


Arguments:

    pHalftoneRender - Pointer to the HALFTONERENDER data structure.

Return Value:

    a negative return value indicate failue.



    HTERR_INVALID_SRC_FORMAT        - Invalid source surface format, this
                                      function only recongnized 1/4/8/24 bits
                                      per pel source surfaces.

    HTERR_COLORTABLE_TOO_BIG        - can not create the color table to map
                                      the colors to the dyes' densities.

    HTERR_INSUFFICIENT_MEMORY       - not enough memory for the pattern.

    HTERR_INTERNAL_ERRORS_START     - any other negative number indicate
                                      halftone internal failure.

    else                            - size of the color table entries created.


Author:

    29-Jan-1991 Tue 11:13:02 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    PAAHEADER           pAAHdr;
    PDEVICECOLORINFO    pDCI;
    PDEVCLRADJ          pDevClrAdj;
    CTSTD_UNION         CTSTDUnion;
    LONG                Result;


    pDCI                               = pHR->pDeviceColorInfo;
    pDevClrAdj                         = pHR->pDevClrAdj;
    pAAHdr                             = (PAAHEADER)pHR->pAAHdr;
    CTSTDUnion.b                       = pDevClrAdj->DMI.CTSTDInfo;
    CTSTDUnion.b.SrcOrder              =
    pDevClrAdj->DMI.CTSTDInfo.SrcOrder = PRIMARY_ORDER_BGR;

    //
    // Make sure these call are semaphore protected
    //

    ComputeRGBLUTAA(pDCI, pDevClrAdj, &(pDCI->rgbLUT));

    if (!(pDevClrAdj->PrimAdj.Flags & DCA_NO_MAPPING_TABLE)) {

        PBGR8   pBGRMap;
        PBGR8   pNewMap = NULL;
        DWORD   Checksum;


        ASSERT(CTSTDUnion.b.cbPrim == sizeof(BGR8));
        ASSERT(pAAHdr->Flags & AAHF_DO_CLR_MAPPING);


        //
        // Compute checksum for all necessary component that computing it
        //  1. rgbCSXForm (which is sRGB constant in GDI implementation)
        //  2. DevCSXForm
        //  3. ColorAdjustment (illum, colorfulness, tint)
        //

        Checksum = ComputeChecksum((LPBYTE)&pDevClrAdj->PrimAdj.rgbCSXForm,
                                   0x12345678,
                                   sizeof(COLORSPACEXFORM));

        Checksum = ComputeChecksum((LPBYTE)&pDevClrAdj->PrimAdj.DevCSXForm,
                                   Checksum,
                                   sizeof(COLORSPACEXFORM));

        Checksum = ComputeChecksum((LPBYTE)&(pDevClrAdj->ca),
                                   Checksum,
                                   sizeof(pDevClrAdj->ca));

        if (!(pBGRMap = FIND_BGRMAPCACHE(Checksum))) {

            DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("*** No CACHE: Alloc %ld bytes of CACHE pBGRMap ***"
                                ARGDW(SIZE_BGR_MAPPING_TABLE)));

            if (!(pBGRMap =
                  pNewMap = (PBGR8)HTAllocMem((LPVOID)NULL,
                                              HTMEM_BGRMC_MAP,
                                              NONZEROLPTR,
                                              SIZE_BGR_MAPPING_TABLE))) {

                DBGP_IF(DBGP_BGRMAPTABLE,
                        DBGP("\n*** FAILED Alloc %ld bytes of pBGRMap ***\n"));

                return((LONG)HTERR_INSUFFICIENT_MEMORY);
            }
        }

        if (pNewMap) {

            DBGP_IF(DBGP_BGRMAPTABLE,
                    DBGP("Cached map Checksum (%08lx) not found, compute Re-Compute RGB555"
                        ARGDW(Checksum)));

            if ((Result = ComputeBGRMappingTable(pDCI,
                                                 pDevClrAdj,
                                                 NULL,
                                                 pNewMap)) ==
                                                        HT_RGB_CUBE_COUNT) {

                if (!(AddBGRMapCache(pNewMap, Checksum))) {

                    DBGP_IF(DBGP_BGRMAPTABLE,
                            DBGP("Adding BGRMapCache failed, Free pNewMap=%p"
                                    ARGPTR(pNewMap)));

                    HTFreeMem(pNewMap);

                    return((LONG)HTERR_INSUFFICIENT_MEMORY);
                }

            } else {

                DBGP_IF(DBGP_BGRMAPTABLE,
                        DBGP("ColorTriadSrcTodev() Failed, Result=%ld"
                            ARGDW(Result)));

                return(INTERR_INVALID_DEVRGB_SIZE);
            }
        }

        pAAHdr->pBGRMapTable = pBGRMap;
    }

    Result = CachedHalftonePattern(pDCI,
                                   pDevClrAdj,
                                   &(pAAHdr->AAPI),
                                   pAAHdr->ptlBrushOrg.x,
                                   pAAHdr->ptlBrushOrg.y,
                                   (BOOL)(pAAHdr->Flags & AAHF_FLIP_Y));

    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htmapclr.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmapclr.h


Abstract:

    This module contains all halftone color mapping constants for the
    htmapclr.c


Author:
    28-Mar-1992 Sat 20:56:27 updated  -by-  Daniel Chou (danielc)
        Add in ULDECI4 type, to store the stretchfacor (source -> dest)
        add StretchFactor in StretchInfo data structure.
        Add support for StretchFactor (ULDECI4 format), so we can internally
        turn off VGA16 when the bitmap is badly compressed.

    29-Jan-1991 Tue 10:29:04 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/


#ifndef _HTMAPCLR_
#define _HTMAPCLR_

#include "htmath.h"

#define DO_CACHE_DCI            0

//
// Halftone process's DECI4 vlaues for the WHITE/BLACK/GRAY
//

#define DECI4_ONE       (DECI4)10000
#define DECI4_ZERO      (DECI4)0
#define LDECI4_ONE      (LDECI4)10000
#define LDECI4_ZERO     (LDECI4)0
#define STD_WHITE       DECI4_ONE
#define STD_BLACK       DECI4_ZERO
#define LSTD_WHITE      LDECI4_ONE
#define LSTD_BLACK      LDECI4_ZERO

#define __SCALE_FD62B(f,l,d,b)  (BYTE)(((((f)-(l))*(b))+((d)>>1))/(d))
#define RATIO_SCALE(p,l,h)      DivFD6(p - l, h - l)
#define SCALE_FD62B(f,l,h,b)    __SCALE_FD62B(f,l,(h)-(l),b)
#define SCALE_FD6(f,b)          __SCALE_FD62B(f,FD6_0,FD6_1,b)
#define SCALE_FD62B_DIF(c,d,b)  (BYTE)((((c)*(b))+((d)>>1))/(d))
#define SCALE_INT2B(c,r,b)      (BYTE)((((c)*(b))+((r)>>1))/(r))


//
// The following FD6 number are used in the color computation, using #define
// for easy reading
//


#define FD6_1p16            (FD6)1160000
#define FD6_p16             (FD6)160000
#define FD6_p166667         (FD6)166667
#define FD6_7p787           (FD6)7787000
#define FD6_16Div116        (FD6)137931
#define FD6_p008856         (FD6)8856
#define FD6_p068962         (FD6)68962
#define FD6_p079996         (FD6)79996
#define FD6_9p033           (FD6)9033000
#define FD6_p4              (FD6)400000



#define UDECI4_NTSC_GAMMA   (UDECI4)22000
#define FD6_NTSC_GAMMA      UDECI4ToFD6(UDECI4_NTSC_GAMMA)


#define NORMALIZED_WHITE            FD6_1
#define NORMALIZED_BLACK            FD6_0
#define CLIP_TO_NORMALIZED_BW(x)    if ((FD6)(x) < FD6_0) (x) = FD6_0;  \
                                    if ((FD6)(x) > FD6_1) (x) = FD6_1

#define DECI4AdjToFD6(a,f)          (FD6)((FD6)(a) * (FD6)(f) * (FD6)100)

#define VALIDATE_CLR_ADJ(a)         if ((a) < MIN_RGB_COLOR_ADJ) {          \
                                        (a) = MIN_RGB_COLOR_ADJ;            \
                                    } else if ((a) > MAX_RGB_COLOR_ADJ) {   \
                                        (a) = MAX_RGB_COLOR_ADJ; }

#define LOG_INTENSITY(i)            ((FD6)(i) > (FD6)120000) ?              \
                                        (NORMALIZED_WHITE + Log((i))) :     \
                                        (MulFD6((FD6)(i), (FD6)659844L))

#define RANGE_CIE_xy(x,y)   if ((x) < CIE_x_MIN) (x) = CIE_x_MIN; else  \
                            if ((x) > CIE_x_MAX) (x) = CIE_x_MAX;       \
                            if ((y) < CIE_y_MIN) (y) = CIE_y_MIN; else  \
                            if ((y) > CIE_y_MAX) (y) = CIE_y_MAX        \

#define MAX_OF_3(max,a,b,c) if ((c)>((max)=(((a)>(b)) ? (a) : (b)))) (max)=(c)
#define MIN_OF_3(min,a,b,c) if ((c)<((min)=(((a)<(b)) ? (a) : (b)))) (min)=(c)

#define CIE_NORMAL_MONITOR          0
#define CIE_NTSC                    1
#define CIE_CIE                     2
#define CIE_EBU                     3
#define CIE_NORMAL_PRINTER          4


//
// For  1 Bit per pel we have maximum     2 mapping table entries
// For  4 Bit per pel we have maximum    16 mapping table entries
// For  8 Bit per pel we have maximum   256 mapping table entries
// For 16 Bit per pel we have maximum 65536 mapping table entries
//
// For 24 bits per pel, we will clip each color (0 - 255) into 0-15 (16 steps)
// and provided a total 4096 colors.
//

#define CUBE_ENTRIES(c)         ((c) * (c) * (c))
#define HT_RGB_MAX_COUNT        32
#define HT_RGB_CUBE_COUNT       CUBE_ENTRIES(HT_RGB_MAX_COUNT)

#define HT_RGB_R_INC            1
#define HT_RGB_G_INC            HT_RGB_MAX_COUNT
#define HT_RGB_B_INC            (HT_RGB_MAX_COUNT * HT_RGB_MAX_COUNT)


#define VGA256_R_IDX_MAX        5
#define VGA256_G_IDX_MAX        5
#define VGA256_B_IDX_MAX        5
#define VGA256_M_IDX_MAX        25

#define VGA256_CUBE_SIZE        ((VGA256_R_IDX_MAX + 1) *                   \
                                 (VGA256_G_IDX_MAX + 1) *                   \
                                 (VGA256_B_IDX_MAX + 1))
#define VGA256_MONO_SIZE        (VGA256_M_IDX_MAX + 1)

#define VGA256_M_IDX_START      VGA256_CUBE_SIZE

#define VGA256_R_CUBE_INC       1
#define VGA256_G_CUBE_INC       (VGA256_R_IDX_MAX + 1)
#define VGA256_B_CUBE_INC       (VGA256_G_CUBE_INC * (VGA256_G_IDX_MAX + 1))
#define VGA256_W_CUBE_INC       (VGA256_R_CUBE_INC + VGA256_G_CUBE_INC +    \
                                 VGA256_B_CUBE_INC)

#define VGA256_R_INT_INC        (FD6)(FD6_1 / VGA256_R_IDX_MAX)
#define VGA256_G_INT_INC        (FD6)(FD6_1 / VGA256_G_IDX_MAX)
#define VGA256_B_INT_INC        (FD6)(FD6_1 / VGA256_B_IDX_MAX)


#define VGA256_PALETTE_COUNT    (VGA256_CUBE_SIZE + VGA256_MONO_SIZE)

#define RGB555_C_LEVELS         32
#define RGB555_P1_CUBE_INC      (RGB555_C_LEVELS * RGB555_C_LEVELS)
#define RGB555_P2_CUBE_INC      RGB555_C_LEVELS
#define RGB555_P3_CUBE_INC      1


typedef HANDLE                  HTMUTEX;
typedef HTMUTEX                 *PHTMUTEX;


#ifdef UMODE

#define CREATE_HTMUTEX()        (HTMUTEX)CreateMutex(NULL, FALSE, NULL)
#define ACQUIRE_HTMUTEX(x)      WaitForSingleObject((HANDLE)(x), (DWORD)~0)
#define RELEASE_HTMUTEX(x)      ReleaseMutex((HANDLE)(x))
#define DELETE_HTMUTEX(x)       CloseHandle((HANDLE)(x))

#else

#define CREATE_HTMUTEX()        (HTMUTEX)EngCreateSemaphore()
#define ACQUIRE_HTMUTEX(x)      EngAcquireSemaphore((HSEMAPHORE)(x))
#define RELEASE_HTMUTEX(x)      EngReleaseSemaphore((HSEMAPHORE)(x))
#define DELETE_HTMUTEX(x)       EngDeleteSemaphore((HSEMAPHORE)(x))

#endif

#define NTSC_R_INT      299000
#define NTSC_G_INT      587000
#define NTSC_B_INT      114000



typedef struct _RGBTOPRIM {
    BYTE    Flags;
    BYTE    ColorTableType;
    BYTE    SrcRGBSize;
    BYTE    DevRGBSize;
    } RGBTOPRIM;

typedef struct _FD6RGB {
    FD6     R;
    FD6     G;
    FD6     B;
    } FD6RGB, FAR *PFD6RGB;

typedef struct _FD6XYZ {
    FD6     X;
    FD6     Y;
    FD6     Z;
    } FD6XYZ, FAR *PFD6XYZ;

typedef struct _FD6PRIM123 {
    FD6 p1;
    FD6 p2;
    FD6 p3;
    } FD6PRIM123, FAR *PFD6PRIM123;


#define HTCF_STATIC_PTHRESHOLDS         0x01

typedef struct _HTCELL {
    BYTE    Flags;
    BYTE    HTPatIdx;
    WORD    wReserved;
    WORD    cxOrg;
    WORD    cxReal;
    WORD    Width;
    WORD    Height;
    DWORD   Size;
    LPBYTE  pThresholds;
    } HTCELL, *PHTCELL;


#define MAPF_MONO_PRIMS     0x00000001
#define MAPF_SKIP_LABLUV    0x00000002


#if DBG
    #define DO_REGTEST      0
#else
    #define DO_REGTEST      0
#endif


typedef struct _REGDATA {
    WORD    DMin;
    WORD    DMax;
    FD6     LMin;
    FD6     LMax;
    FD6     DMinMul;
    FD6     DMaxAdd;
    FD6     DMaxMul;
    FD6     DenAdd;
    FD6     DenMul;
    } REGDATA, *PREGDATA;

#define REG_DMIN_ADD        FD6_0


#define REG_BASE_GAMMA      (FD6) 932500
#define REG_GAMMA_IDX_BASE  (FD6)1050000
#define MASK8BPP_GAMMA_DIV  (FD6) 932500

#define GET_REG_GAMMA(Idx)  MulFD6(REG_BASE_GAMMA,                          \
                                   RaisePower(REG_GAMMA_IDX_BASE,           \
                                              (FD6)(Idx) - (FD6)3,          \
                                              RPF_INTEXP))

#define K_REP_START         (FD6) 666667
#define K_REP_POWER         (FD6)2000000

//
// Possible values:
//
//  R           G           B
//  -------     -------     -------
//  0.9859      1.0100      0.9859
//  0.9789      1.0150      0.9789
//  0.9720      1.0200      0.9720
//


#define SCM_R_GAMMA_MUL     (FD6) 978900
#define SCM_G_GAMMA_MUL     (FD6)1015000
#define SCM_B_GAMMA_MUL     (FD6) 978900

#define GRAY_MAX_IDX                0xFFFF

#define IDXBGR_2_GRAY_BYTE(p,b,g,r) (BYTE)((p[0+(b)]+p[256+(g)]+p[512+(r)])>>8)
#define BGR_2_GRAY_WORD(b,g,r)      ((b)+(g)+(r))


//
// DEVCLRADJ
//
//  This data structure describe how the color adjustment should be made
//  input RGB color and output device.
//
//  Flags                       - No flag is defined.
//
//  RedPowerAdj                 - The n-th power applied to the red color
//                                before any other color adjustment, this is
//                                a UDECI4 value. (0.0100 - 6.500)
//
//                                  For example if the RED = 0.8 (DECI4=8000)
//                                  and the RedPowerGammaAdjustment = 0.7823
//                                  (DECI4 = 7823) then the red is equal to
//
//                                         0.7823
//                                      0.8        = 0.8398
//
//  GreenPowerAdj               - The n-th power applied to the green color
//                                before any other color adjustment, this is
//                                a UDECI4 value. (0.0100 - 6.5000)
//
//  BluePowerAdj                - The n-th power applied to the blue color
//                                before any other color adjustment, this is
//                                a UDECI4 value. (0.0100 - 6.5000)
//
//                                NOTE: if the PowerGammaAdjustmenst values are
//                                      equal to 1.0 (DECI4 = 10000) then no
//                                      adjustment will be made, since any
//                                      number raised to the 1 will be equal
//                                      to itself, if this number is less than
//                                      0.0100 (ie 100) or greater than 6.5000
//                                      (ie. 65000) then it default to 1.0000
//                                      (ie. 10000) and no adjustment is made.
//
//  BrightnessAdj               - The brightness adjustment, this is a DECI4
//                                number range from -10000 (-1.0000) to
//                                10000 (1.0000).  The brightness is adjusted
//                                by apply to overall intensity for the primary
//                                colors.
//
//  ContrastAdj                 - Primary color contrast adjustment, this is
//                                a DECI4 number range from -10000 (-1.0000)
//                                to 10000 (1.0000).  The primary color
//                                curves are either compressed to the center or
//                                expanded to the black/white.
//
//  BDR                         - The ratio which the black dyes should be
//                                replaced by the non-black dyes, higher the
//                                number more black dyes are used to replace
//                                the non-black dyes.  This may saving the
//                                color dyes but it may also loose color
//                                saturation.  this is a DECI4 number range
//                                from -10000 to 10000 (ie. -1.0000 to 1.0000).
//                                if this value is 0 then no repelacement is
//                                take place.
//
//

typedef struct _CIExy2 {
    UDECI4  x;
    UDECI4  y;
    } CIExy2, *PCIExy2;

typedef struct _CIExy {
    FD6 x;
    FD6 y;
    } CIExy, FAR *PCIExy;

typedef struct _CIExyY {
    FD6 x;
    FD6 y;
    FD6 Y;
    } CIExyY, *PCIExyY;

typedef struct _CIEPRIMS {
    CIExy   r;
    CIExy   g;
    CIExy   b;
    CIExy   w;
    FD6     Yw;
    } CIEPRIMS, FAR *PCIEPRIMS;


#define CIELUV_1976             0
#define CIELAB_1976             1
#define COLORSPACE_MAX_INDEX    1


typedef struct _COLORSPACEXFORM {
    MATRIX3x3   M3x3;
    FD6XYZ      WhiteXYZ;
    FD6RGB      Yrgb;
    FD6         AUw;
    FD6         BVw;
    FD6         xW;
    FD6         yW;
    FD6         YW;
    } COLORSPACEXFORM, FAR *PCOLORSPACEXFORM;


typedef struct _CLRXFORMBLOCK {
    BYTE            Flags;
    BYTE            ColorSpace;
    BYTE            RegDataIdx;
    BYTE            bReserved;
    CIEPRIMS        rgbCIEPrims;
    CIEPRIMS        DevCIEPrims;
    MATRIX3x3       CMYDyeMasks;
    FD6             DevGamma[3];
    } CLRXFORMBLOCK, *PCLRXFORMBLOCK;

typedef struct _PRIMADJ {
    DWORD           Flags;
    FD6             SrcGamma[3];
    FD6             DevGamma[3];
    FD6             Contrast;
    FD6             Brightness;
    FD6             Color;
    FD6             TintSinAngle;
    FD6             TintCosAngle;
    FD6             MinL;
    FD6             MaxL;
    FD6             MinLMul;
    FD6             MaxLMul;
    FD6             RangeLMul;
    COLORSPACEXFORM rgbCSXForm;
    COLORSPACEXFORM DevCSXForm;
    } PRIMADJ, *PPRIMADJ;


#define CRTX_LEVEL_255              0
#define CRTX_LEVEL_RGB              1
#define CRTX_TOTAL_COUNT            2

#define CRTX_PRIMMAX_255            255
#define CRTX_PRIMMAX_RGB            (HT_RGB_MAX_COUNT - 1)
#define CRTX_SIZE_255               (sizeof(FD6XYZ) * (256 * 3))
#define CRTX_SIZE_RGB               (sizeof(FD6XYZ) * (HT_RGB_MAX_COUNT * 3))

typedef struct _CACHERGBTOXYZ {
    DWORD   Checksum;
    PFD6XYZ pFD6XYZ;
    WORD    PrimMax;
    WORD    SizeCRTX;
    } CACHERGBTOXYZ, FAR *PCACHERGBTOXYZ;


#define DCA_HAS_ICM                 0x00000001
#define DCA_HAS_SRC_GAMMA           0x00000002
#define DCA_HAS_DEST_GAMMA          0x00000004
#define DCA_HAS_BW_REF_ADJ          0x00000008
#define DCA_HAS_CONTRAST_ADJ        0x00000010
#define DCA_HAS_BRIGHTNESS_ADJ      0x00000020
#define DCA_HAS_COLOR_ADJ           0x00000040
#define DCA_HAS_TINT_ADJ            0x00000080
#define DCA_LOG_FILTER              0x00000100
#define DCA_NEGATIVE                0x00000200
#define DCA_NEED_DYES_CORRECTION    0x00000400
#define DCA_HAS_BLACK_DYE           0x00000800
#define DCA_DO_DEVCLR_XFORM         0x00001000
#define DCA_MONO_ONLY               0x00002000
#define DCA_USE_ADDITIVE_PRIMS      0x00004000
#define DCA_HAS_CLRSPACE_ADJ        0x00008000
#define DCA_MASK8BPP                0x00010000
#define DCA_REPLACE_BLACK           0x00020000
#define DCA_RGBLUTAA_MONO           0x00040000
#define DCA_BBPF_AA_OFF             0x00080000
#define DCA_ALPHA_BLEND             0x00100000
#define DCA_CONST_ALPHA             0x00200000
#define DCA_XLATE_555_666           0x00400000
#define DCA_AB_PREMUL_SRC           0x00800000
#define DCA_AB_DEST                 0x01000000
#define DCA_XLATE_332               0x02000000
#define DCA_NO_MAPPING_TABLE        0x40000000
#define DCA_NO_ANY_ADJ              0x80000000


#define SIZE_XLATE_555  (((4 << 6) | (4 << 3) | 4) + 1)
#define SIZE_XLATE_666  (((5 << 6) | (5 << 3) | 5) + 1)


#define ADJ_FORCE_MONO              0x0001
#define ADJ_FORCE_NEGATIVE          0x0002
#define ADJ_FORCE_ADDITIVE_PRIMS    0x0004
#define ADJ_FORCE_ICM               0x0008
#define ADJ_FORCE_BRUSH             0x0010
#define ADJ_FORCE_NO_EXP_AA         0x0020
#define ADJ_FORCE_IDXBGR_MONO       0x0040
#define ADJ_FORCE_ALPHA_BLEND       0x0080
#define ADJ_FORCE_CONST_ALPHA       0x0100
#define ADJ_FORCE_AB_PREMUL_SRC     0x0200
#define ADJ_FORCE_AB_DEST           0x0400
#define ADJ_FORCE_DEVXFORM          0x8000



typedef struct _CTSTDINFO {
    BYTE    cbPrim;
    BYTE    SrcOrder;
    BYTE    DestOrder;
    BYTE    BMFDest;
    } CTSTDINFO;

typedef struct _RGBORDER {
    BYTE    Index;
    BYTE    Order[3];
    } RGBORDER;

typedef union _CTSTD_UNION {
    DWORD       dw;
    CTSTDINFO   b;
    } CTSTD_UNION;


#define DMIF_GRAY                   0x01

typedef struct _DEVMAPINFO {
    BYTE        Flags;
    BYTE        LSft[3];
    CTSTDINFO   CTSTDInfo;
    DWORD       Mul[3];
    DWORD       MulAdd;
    RGBORDER    DstOrder;
    FD6         BlackChk;
    } DEVMAPINFO, *PDEVMAPINFO;

typedef struct _DEVCLRADJ {
    HTCOLORADJUSTMENT   ca;
    DEVMAPINFO          DMI;
    PRIMADJ             PrimAdj;
    PCLRXFORMBLOCK      pClrXFormBlock;
    PCACHERGBTOXYZ      pCRTXLevel255;
    PCACHERGBTOXYZ      pCRTXLevelRGB;
    } DEVCLRADJ, FAR *PDEVCLRADJ;

#define SIZE_BGR_MAPPING_TABLE      (sizeof(BGR8) * (HT_RGB_CUBE_COUNT + 2))


//
// Following define must corresponsed to the InputFuncTable[] definitions
//

#define IDXIF_BMF1BPP_START     0
#define IDXIF_BMF16BPP_START    6
#define IDXIF_BMF24BPP_START    9
#define IDXIF_BMF32BPP_START    13


#define BF_GRAY_BITS            8
#define BF_GRAY_TABLE_COUNT     (1 << BF_GRAY_BITS)


#define BFIF_RGB_888            0x01

typedef struct _BFINFO {
    BYTE        Flags;
    BYTE        BitmapFormat;
    BYTE        BitStart[3];
    BYTE        BitCount[3];
    DWORD       BitsRGB[3];
    RGBORDER    RGBOrder;
    } BFINFO, FAR *PBFINFO;


#define LUTAA_HDR_COUNT         6
#define LUTAA_HDR_SIZE          (LUTAA_HDR_COUNT * sizeof(DWORD))

#define GET_LUTAAHDR(h,p)       CopyMemory((LPBYTE)&(h[0]),                 \
                                           (LPBYTE)(p) - LUTAA_HDR_SIZE,    \
                                           LUTAA_HDR_SIZE)

typedef struct _RGBLUTAA {
    DWORD       Checksum;
    DWORD       ExtBGR[LUTAA_HDR_COUNT];
    LONG        IdxBGR[256 * 3];
    } RGBLUTAA, *PRGBLUTAA;


#define LUTSIZE_ANTI_ALIASING   (sizeof(RGBLUTAA))


//
// DEVICECOLORINFO
//
//  This data structure is a collection of the device characteristics and
//  will used by the halftone DLL to carry out the color composition for the
//  designated device.
//
//  HalftoneDLLID               - The ID for the structure, is #define as
//                                HALFTONE_DLL_ID = "DCHT"
//
//  HTCallBackFunction          - a 32-bit pointer to the caller supplied
//                                callback function which used by the halftone
//                                DLL to obtained the source/destination bitmap
//                                pointer durning the halftone process.
//
//  pPrimMonoMappingTable       - a pointer to the PRIMMONO data structure
//                                array, this is the dye density mapping table
//                                for the reduced gamut from 24-bit colors,
//                                initially is NULL, and it will cached only
//                                when the first time the source bitmap is
//                                24-bit per pel.
//
//  pPrimColorMappingTable      - a pointer to the PRIMCOLOR data structure
//                                array, this is the dye density mapping table
//                                for the reduced gamut from 24-bit colors,
//                                initially is NULL, and it will cached only
//                                when the first time the source bitmap is
//                                24-bit per pel.
//
//  Flags                       - Various flag defined the initialization
//                                requirements.
//
//                                  DCIF_HAS_BLACK_DYE
//
//                                      The device has true black dye, for this
//                                      version, this flag always set.
//
//                                  DCIF_ADDITIVE_PRIMS
//
//                                      Specified that final device primaries
//                                      are additively, that is adding device
//                                      primaries will produce lighter result.
//                                      (this is true for monitor device and
//                                      certainly false for the reflect devices
//                                      such as printers).
//
//  pPrimMonoMappingTable       - Pointer to a table which contains the cached
//                                RGB -> Single dye density entries, this table
//                                will be computed and cahced when first time
//                                halftone a 24-bit RGB bitmap to monochrome
//                                surface.
//
//  pPrimMonoMappingTable       - Pointer to a table which contains the cached
//                                RGB -> three dyes densities entries, this
//                                table will be computed and cahced when first
//                                time halftone a 24-bit RGB bitmap to color
//                                surface.
//
//  pHTDyeDensity               - Pointer to an array of DECI4 HTDensity values,
//                                size of the array are MaximumHTDensityIndex.
//
//  Prim3SolidInfo              - Device solid dyes concentration information,
//                                see RIM3SOLIDINFO data structure.
//
//  RGBToXYZ                    - a 3 x 3 matrix used to transform from device
//                                RGB color values to the C.I.E color X, Y, Z
//                                values.
//
//  DeviceResXDPI               - Specified the device horizontal (x direction)
//                                resolution in 'dots per inch' measurement.
//
//  DeviceResYDPI               - Specified the device vertical (y direction)
//                                resolution in 'dots per inch' measurement.
//
//  DevicePelsDPI               - Specified the device pel/dot/nozzle diameter
//                                (if rounded) or width/height (if squared) in
//                                'dots per inch' measurement.
//
//                                This value is measure as if each pel only
//                                touch each at edge of the pel.
//
//  HTPatGamma                  - Gamma for the input RGB value * halftone
//                                pattern gamma correction.
//
//  DensityBWRef                - The reference black/white point for the
//                                device.
//
//  IlluminantIndex             - Specified the default illuminant of the light
//                                source which the object will be view under.
//                                The predefined value has ILLUMINANT_xxxx
//                                form.
//
//  RGAdj                       - Current Red/Green Tint adjustment.
//
//  BYAdj                       - Current Blue/Yellow Tint adjustment.
//
//  HalftonePattern             - the HALFTONEPATTERN data structure.
//
//

#define DCIF_HAS_BLACK_DYE              0x00000001
#define DCIF_ADDITIVE_PRIMS             0x00000002
#define DCIF_NEED_DYES_CORRECTION       0x00000004
#define DCIF_SQUARE_DEVICE_PEL          0x00000008
#define DCIF_CLUSTER_HTCELL             0x00000010
#define DCIF_SUPERCELL_M                0x00000020
#define DCIF_SUPERCELL                  0x00000040
#define DCIF_FORCE_ICM                  0x00000080
#define DCIF_USE_8BPP_BITMASK           0x00000100
#define DCIF_MONO_8BPP_BITMASK          0x00000200
#define DCIF_DO_DEVCLR_XFORM            0x00000400
#define DCIF_CMY8BPPMASK_SAME_LEVEL     0x00000800
#define DCIF_PRINT_DRAFT_MODE           0x00001000
#define DCIF_INVERT_8BPP_BITMASK_IDX    0x00002000
#define DCIF_HAS_DENSITY                0x00004000


typedef struct _CMY8BPPMASK {
    BYTE    cC;
    BYTE    cM;
    BYTE    cY;
    BYTE    Max;
    BYTE    Mask;
    BYTE    SameLevel;
    WORD    PatSubC;
    WORD    PatSubM;
    WORD    PatSubY;
    FD6     MaxMulC;
    FD6     MaxMulM;
    FD6     MaxMulY;
    FD6     KCheck;
    FD6     DenC[6];
    FD6     DenM[6];
    FD6     DenY[6];
    BYTE    bXlate[256];
    BYTE    GenerateXlate;
    BYTE    bReserved[3];
    } CMY8BPPMASK, *PCMY8BPPMASK;


#define AB_BGR_SIZE             (sizeof(BYTE) * 256 * 3)
#define AB_BGR_CA_SIZE          (sizeof(WORD) * 256 * 3)
#define AB_CONST_SIZE           (sizeof(WORD) * 256)
#define AB_CONST_OFFSET         ((AB_BGR_SIZE + AA_BGR_CA_SIZE) / sizeof(WORD))
#define AB_CONST_MAX            0xFF
#define AB_DCI_SIZE             (AB_BGR_SIZE + AB_BGR_CA_SIZE + AB_CONST_SIZE)
#define BYTE2CONSTALPHA(b)      (((LONG)(b) << 8) | 0xFF)

typedef struct _DEVICECOLORINFO {
    DWORD               HalftoneDLLID;
    HTMUTEX             HTMutex;
    _HTCALLBACKFUNC     HTCallBackFunction;
    DWORD               HTInitInfoChecksum;
    DWORD               HTSMPChecksum;
    CLRXFORMBLOCK       ClrXFormBlock;
    HTCELL              HTCell;
    DWORD               Flags;
    WORD                DeviceResXDPI;
    WORD                DeviceResYDPI;
    FD6                 DevPelRatio;
    HTCOLORADJUSTMENT   ca;
    PRIMADJ             PrimAdj;
    CMY8BPPMASK         CMY8BPPMask;
    CACHERGBTOXYZ       CRTX[CRTX_TOTAL_COUNT];
    RGBLUTAA            rgbLUT;
    RGBLUTAA            rgbLUTPat;
    WORD                PrevConstAlpha;
    WORD                CurConstAlpha;
    LPBYTE              pAlphaBlendBGR;
#if DBG
    LPVOID              pMemLink;
    LONG                cbMemTot;
    LONG                cbMemMax;
#endif
    } DEVICECOLORINFO, FAR *PDEVICECOLORINFO;


typedef struct _CDCIDATA {
    DWORD                   Checksum;
    struct _CDCIDATA FAR    *pNextCDCIData;
    CLRXFORMBLOCK           ClrXFormBlock;
    DWORD                   DCIFlags;
    WORD                    DevResXDPI;
    WORD                    DevResYDPI;
    FD6                     DevPelRatio;
    HTCELL                  HTCell;
    } CDCIDATA, FAR *PCDCIDATA;

typedef struct _CSMPBMP {
    struct _CSMPBMP FAR *pNextCSMPBmp;
    WORD                PatternIndex;
    WORD                cxPels;
    WORD                cyPels;
    WORD                cxBytes;
    } CSMPBMP, FAR *PCSMPBMP;

typedef struct _CSMPDATA {
    DWORD                   Checksum;
    struct _CSMPDATA FAR    *pNextCSMPData;
    PCSMPBMP                pCSMPBmpHead;
    } CSMPDATA, FAR *PCSMPDATA;


typedef struct _BGRMAPCACHE {
    PBGR8   pMap;
    LONG    cRef;
    DWORD   Checksum;
    } BGRMAPCACHE, *PBGRMAPCACHE;

#define BGRMC_MAX_COUNT     5
#define BGRMC_SIZE_INC      (BGRMC_MAX_COUNT * 2)

typedef struct _HTGLOBAL {
    HMODULE         hModule;
    HTMUTEX         HTMutexCDCI;
    HTMUTEX         HTMutexCSMP;
    HTMUTEX         HTMutexBGRMC;
    PCDCIDATA       pCDCIDataHead;
    PCSMPDATA       pCSMPDataHead;
    PBGRMAPCACHE    pBGRMC;
    LONG            cBGRMC;
    LONG            cAllocBGRMC;
    LONG            cIdleBGRMC;
    WORD            CDCICount;
    WORD            CSMPCount;
    } HTGLOBAL;



#define R_INDEX     0
#define G_INDEX     1
#define B_INDEX     2

#define X_INDEX     0
#define Y_INDEX     1
#define Z_INDEX     2

//
// For easy coding/reading purpose we will defined following to be used when
// reference to the CIEMATRIX data structure.
//

#define CIE_Xr(Matrix3x3)   Matrix3x3.m[X_INDEX][R_INDEX]
#define CIE_Xg(Matrix3x3)   Matrix3x3.m[X_INDEX][G_INDEX]
#define CIE_Xb(Matrix3x3)   Matrix3x3.m[X_INDEX][B_INDEX]
#define CIE_Yr(Matrix3x3)   Matrix3x3.m[Y_INDEX][R_INDEX]
#define CIE_Yg(Matrix3x3)   Matrix3x3.m[Y_INDEX][G_INDEX]
#define CIE_Yb(Matrix3x3)   Matrix3x3.m[Y_INDEX][B_INDEX]
#define CIE_Zr(Matrix3x3)   Matrix3x3.m[Z_INDEX][R_INDEX]
#define CIE_Zg(Matrix3x3)   Matrix3x3.m[Z_INDEX][G_INDEX]
#define CIE_Zb(Matrix3x3)   Matrix3x3.m[Z_INDEX][B_INDEX]


//
// HALFTONERENDER
//
//  pDeviceColorInfo        - Pointer to the DECICECOLORINFO data structure
//
//  pDevClrAdj              - Pointer to the DEVCLRADJ data structure.
//
//  pBitbltParams           - Pointer to the BITBLTPARAMS data structure
//
//  pSrcSurfaceInfo         - Pointer to the source HTSURFACEINFO data
//                            structure.
//
//  pDestSurfaceInfo        - Pointer to the destination HTSURFACEINFO data
//                            structure.
//
//  pDeviceColorInfo        - Pointer to the DECICECOLORINFO data structure
//
//

typedef struct _HALFTONERENDER {
    PDEVICECOLORINFO    pDeviceColorInfo;
    PDEVCLRADJ          pDevClrAdj;
    PBITBLTPARAMS       pBitbltParams;
    PHTSURFACEINFO      pSrcSI;
    PHTSURFACEINFO      pSrcMaskSI;
    PHTSURFACEINFO      pDestSI;
    LPVOID              pAAHdr;
    LPBYTE              pXlate8BPP;
    BFINFO              BFInfo;
    } HALFTONERENDER, FAR *PHALFTONERENDER;


typedef struct _HT_DHI {
    DEVICEHALFTONEINFO  DHI;
    DEVICECOLORINFO     DCI;
    } HT_DHI, FAR *PHT_DHI;


#define PHT_DHI_DCI_OF(x)   (((PHT_DHI)pDeviceHalftoneInfo)->DCI.x)
#define PDHI_TO_PDCI(x)     (PDEVICECOLORINFO)&(((PHT_DHI)(x))->DCI)
#define PDCI_TO_PDHI(x)     (PDEVICEHALFTONEINFO)((DWORD)(x) -  \
                                                  FIELD_OFFSET(HT_DHI, DCI))



//
// Functions prototype
//

PDEVICECOLORINFO
HTENTRY
pDCIAdjClr(
    PDEVICEHALFTONEINFO pDeviceHalftoneInfo,
    PHTCOLORADJUSTMENT  pHTColorAdjustment,
    PDEVCLRADJ          *ppDevClrAdj,
    DWORD               cbAlooc,
    WORD                ForceFlags,
    CTSTDINFO           CTSTDInfo,
    PLONG               pError
    );


VOID
HTENTRY
ComputeColorSpaceXForm(
    PDEVICECOLORINFO    pDCI,
    PCIEPRIMS           pCIEPrims,
    PCOLORSPACEXFORM    pCSXForm,
    INT                 StdIlluminant
    );

LONG
HTENTRY
ComputeBGRMappingTable(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PCOLORTRIAD         pSrcClrTriad,
    PBGR8               pbgr
    );

LONG
HTENTRY
CreateDyesColorMappingTable(
    PHALFTONERENDER pHalftoneRender
    );

VOID
HTENTRY
ComputeRGBLUTAA(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PRGBLUTAA           prgbLUT
    );

LONG
TrimBGRMapCache(
    VOID
    );


PBGR8
FindBGRMapCache(
    PBGR8   pDeRefMap,
    DWORD   Checksum
    );

#define FIND_BGRMAPCACHE(Checksum)  FindBGRMapCache(NULL, Checksum)
#define DEREF_BGRMAPCACHE(pMap)     FindBGRMapCache(pMap, 0)


BOOL
AddBGRMapCache(
    PBGR8   pMap,
    DWORD   Checksum
    );



#endif  // _HTMAPCLR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htmath.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmath.c


Abstract:

    This module contains the basic math. functions for the halftone
    process.

Author:

    16-Jan-1991 Wed 10:51:27 created  -by-  Daniel Chou (danielc)

[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    02-Feb-1994 Wed 18:08:13 updated  -by-  Daniel Chou (danielc)
        Remove unary unsigned wranings.



--*/

#define DBGP_VARNAME        dbgpHTMath



#define HAS_80x86_EQUIVALENT_CODES

#include "htp.h"
#include "htmath.h"


#define DBGP_MAPPING        0x0001
#define DBGP_CONCAT_M       0x0002

DEF_DBGPVAR(BIT_IF(DBGP_CONCAT_M,   0)  |
            BIT_IF(DBGP_MAPPING,    0))



#if DBG
LPBYTE  pDbgRegMode[] = { "LINEAR", "LOG", "EXP", "POWER" };
#endif


//
// Local definitions only used in this file
//

#define ABSFD6(a)           (FD6)(((a) < 0L) ? -(a) : (a))
#define SWAPFD6(a, b, t)    (t)=(a); (a)=(b); (b)=(t)
#define U16_H_U32(a)        (WORD)((DWORD)(a) >> 16)
#define U16_L_U32(a)        (WORD)((DWORD)(a) & 0xffffL)
#define FD6_LOG_MIN         -FD6_6
#define FD6_LOG_MAX         (FD6)3331930L
#define FD6ToL(n)           (LONG)(n)
#define FD6FromL(n)         (FD6)(n)

#define NEGDW(x)            (DWORD)(-(LONG)(x))
#define MIN_FD6             (FD6)-(LONG)2147483648
#define MAX_FD6             (FD6)(LONG)2147483647



//
// MANTISSATABLE
//
//  This is the look up table for the mantissa portion of the log number, the
//  table range from 1.00 to 10.00 at increment of 0.01 for the look up
//  numbers.  If the requested number has lies between two look up numbers
//  then an interpolation is done using those two look up numbers.
//

#define MANTISSATABLE_SIZE          901


FD6 MantissaTable[MANTISSATABLE_SIZE] = {

    (FD6)0,      (FD6)4321,     //  1.00 - 1.01
    (FD6)8600,   (FD6)12837,    //  1.02 - 1.03
    (FD6)17033,  (FD6)21189,    //  1.04 - 1.05
    (FD6)25306,  (FD6)29384,    //  1.06 - 1.07
    (FD6)33424,  (FD6)37426,    //  1.08 - 1.09
    (FD6)41393,  (FD6)45323,    //  1.10 - 1.11
    (FD6)49218,  (FD6)53078,    //  1.12 - 1.13
    (FD6)56905,  (FD6)60698,    //  1.14 - 1.15
    (FD6)64458,  (FD6)68186,    //  1.16 - 1.17
    (FD6)71882,  (FD6)75547,    //  1.18 - 1.19
    (FD6)79181,  (FD6)82785,    //  1.20 - 1.21
    (FD6)86360,  (FD6)89905,    //  1.22 - 1.23
    (FD6)93422,  (FD6)96910,    //  1.24 - 1.25
    (FD6)100371, (FD6)103804,   //  1.26 - 1.27
    (FD6)107210, (FD6)110590,   //  1.28 - 1.29
    (FD6)113943, (FD6)117271,   //  1.30 - 1.31
    (FD6)120574, (FD6)123852,   //  1.32 - 1.33
    (FD6)127105, (FD6)130334,   //  1.34 - 1.35
    (FD6)133539, (FD6)136721,   //  1.36 - 1.37
    (FD6)139879, (FD6)143015,   //  1.38 - 1.39
    (FD6)146128, (FD6)149219,   //  1.40 - 1.41
    (FD6)152288, (FD6)155336,   //  1.42 - 1.43
    (FD6)158362, (FD6)161368,   //  1.44 - 1.45
    (FD6)164353, (FD6)167317,   //  1.46 - 1.47
    (FD6)170262, (FD6)173186,   //  1.48 - 1.49
    (FD6)176091, (FD6)178977,   //  1.50 - 1.51
    (FD6)181844, (FD6)184691,   //  1.52 - 1.53
    (FD6)187521, (FD6)190332,   //  1.54 - 1.55
    (FD6)193125, (FD6)195900,   //  1.56 - 1.57
    (FD6)198657, (FD6)201397,   //  1.58 - 1.59
    (FD6)204120, (FD6)206826,   //  1.60 - 1.61
    (FD6)209515, (FD6)212188,   //  1.62 - 1.63
    (FD6)214844, (FD6)217484,   //  1.64 - 1.65
    (FD6)220108, (FD6)222716,   //  1.66 - 1.67
    (FD6)225309, (FD6)227887,   //  1.68 - 1.69
    (FD6)230449, (FD6)232996,   //  1.70 - 1.71
    (FD6)235528, (FD6)238046,   //  1.72 - 1.73
    (FD6)240549, (FD6)243038,   //  1.74 - 1.75
    (FD6)245513, (FD6)247973,   //  1.76 - 1.77
    (FD6)250420, (FD6)252853,   //  1.78 - 1.79
    (FD6)255273, (FD6)257679,   //  1.80 - 1.81
    (FD6)260071, (FD6)262451,   //  1.82 - 1.83
    (FD6)264818, (FD6)267172,   //  1.84 - 1.85
    (FD6)269513, (FD6)271842,   //  1.86 - 1.87
    (FD6)274158, (FD6)276462,   //  1.88 - 1.89
    (FD6)278754, (FD6)281033,   //  1.90 - 1.91
    (FD6)283301, (FD6)285557,   //  1.92 - 1.93
    (FD6)287802, (FD6)290035,   //  1.94 - 1.95
    (FD6)292256, (FD6)294466,   //  1.96 - 1.97
    (FD6)296665, (FD6)298853,   //  1.98 - 1.99
    (FD6)301030, (FD6)303196,   //  2.00 - 2.01
    (FD6)305351, (FD6)307496,   //  2.02 - 2.03
    (FD6)309630, (FD6)311754,   //  2.04 - 2.05
    (FD6)313867, (FD6)315970,   //  2.06 - 2.07
    (FD6)318063, (FD6)320146,   //  2.08 - 2.09
    (FD6)322219, (FD6)324282,   //  2.10 - 2.11
    (FD6)326336, (FD6)328380,   //  2.12 - 2.13
    (FD6)330414, (FD6)332438,   //  2.14 - 2.15
    (FD6)334454, (FD6)336460,   //  2.16 - 2.17
    (FD6)338456, (FD6)340444,   //  2.18 - 2.19
    (FD6)342423, (FD6)344392,   //  2.20 - 2.21
    (FD6)346353, (FD6)348305,   //  2.22 - 2.23
    (FD6)350248, (FD6)352183,   //  2.24 - 2.25
    (FD6)354108, (FD6)356026,   //  2.26 - 2.27
    (FD6)357935, (FD6)359835,   //  2.28 - 2.29
    (FD6)361728, (FD6)363612,   //  2.30 - 2.31
    (FD6)365488, (FD6)367356,   //  2.32 - 2.33
    (FD6)369216, (FD6)371068,   //  2.34 - 2.35
    (FD6)372912, (FD6)374748,   //  2.36 - 2.37
    (FD6)376577, (FD6)378398,   //  2.38 - 2.39
    (FD6)380211, (FD6)382017,   //  2.40 - 2.41
    (FD6)383815, (FD6)385606,   //  2.42 - 2.43
    (FD6)387390, (FD6)389166,   //  2.44 - 2.45
    (FD6)390935, (FD6)392697,   //  2.46 - 2.47
    (FD6)394452, (FD6)396199,   //  2.48 - 2.49
    (FD6)397940, (FD6)399674,   //  2.50 - 2.51
    (FD6)401401, (FD6)403121,   //  2.52 - 2.53
    (FD6)404834, (FD6)406540,   //  2.54 - 2.55
    (FD6)408240, (FD6)409933,   //  2.56 - 2.57
    (FD6)411620, (FD6)413300,   //  2.58 - 2.59
    (FD6)414973, (FD6)416641,   //  2.60 - 2.61
    (FD6)418301, (FD6)419956,   //  2.62 - 2.63
    (FD6)421604, (FD6)423246,   //  2.64 - 2.65
    (FD6)424882, (FD6)426511,   //  2.66 - 2.67
    (FD6)428135, (FD6)429752,   //  2.68 - 2.69
    (FD6)431364, (FD6)432969,   //  2.70 - 2.71
    (FD6)434569, (FD6)436163,   //  2.72 - 2.73
    (FD6)437751, (FD6)439333,   //  2.74 - 2.75
    (FD6)440909, (FD6)442480,   //  2.76 - 2.77
    (FD6)444045, (FD6)445604,   //  2.78 - 2.79
    (FD6)447158, (FD6)448706,   //  2.80 - 2.81
    (FD6)450249, (FD6)451786,   //  2.82 - 2.83
    (FD6)453318, (FD6)454845,   //  2.84 - 2.85
    (FD6)456366, (FD6)457882,   //  2.86 - 2.87
    (FD6)459392, (FD6)460898,   //  2.88 - 2.89
    (FD6)462398, (FD6)463893,   //  2.90 - 2.91
    (FD6)465383, (FD6)466868,   //  2.92 - 2.93
    (FD6)468347, (FD6)469822,   //  2.94 - 2.95
    (FD6)471292, (FD6)472756,   //  2.96 - 2.97
    (FD6)474216, (FD6)475671,   //  2.98 - 2.99
    (FD6)477121, (FD6)478566,   //  3.00 - 3.01
    (FD6)480007, (FD6)481443,   //  3.02 - 3.03
    (FD6)482874, (FD6)484300,   //  3.04 - 3.05
    (FD6)485721, (FD6)487138,   //  3.06 - 3.07
    (FD6)488551, (FD6)489958,   //  3.08 - 3.09
    (FD6)491362, (FD6)492760,   //  3.10 - 3.11
    (FD6)494155, (FD6)495544,   //  3.12 - 3.13
    (FD6)496930, (FD6)498311,   //  3.14 - 3.15
    (FD6)499687, (FD6)501059,   //  3.16 - 3.17
    (FD6)502427, (FD6)503791,   //  3.18 - 3.19
    (FD6)505150, (FD6)506505,   //  3.20 - 3.21
    (FD6)507856, (FD6)509203,   //  3.22 - 3.23
    (FD6)510545, (FD6)511883,   //  3.24 - 3.25
    (FD6)513218, (FD6)514548,   //  3.26 - 3.27
    (FD6)515874, (FD6)517196,   //  3.28 - 3.29
    (FD6)518514, (FD6)519828,   //  3.30 - 3.31
    (FD6)521138, (FD6)522444,   //  3.32 - 3.33
    (FD6)523746, (FD6)525045,   //  3.34 - 3.35
    (FD6)526339, (FD6)527630,   //  3.36 - 3.37
    (FD6)528917, (FD6)530200,   //  3.38 - 3.39
    (FD6)531479, (FD6)532754,   //  3.40 - 3.41
    (FD6)534026, (FD6)535294,   //  3.42 - 3.43
    (FD6)536558, (FD6)537819,   //  3.44 - 3.45
    (FD6)539076, (FD6)540329,   //  3.46 - 3.47
    (FD6)541579, (FD6)542825,   //  3.48 - 3.49
    (FD6)544068, (FD6)545307,   //  3.50 - 3.51
    (FD6)546543, (FD6)547775,   //  3.52 - 3.53
    (FD6)549003, (FD6)550228,   //  3.54 - 3.55
    (FD6)551450, (FD6)552668,   //  3.56 - 3.57
    (FD6)553883, (FD6)555094,   //  3.58 - 3.59
    (FD6)556303, (FD6)557507,   //  3.60 - 3.61
    (FD6)558709, (FD6)559907,   //  3.62 - 3.63
    (FD6)561101, (FD6)562293,   //  3.64 - 3.65
    (FD6)563481, (FD6)564666,   //  3.66 - 3.67
    (FD6)565848, (FD6)567026,   //  3.68 - 3.69
    (FD6)568202, (FD6)569374,   //  3.70 - 3.71
    (FD6)570543, (FD6)571709,   //  3.72 - 3.73
    (FD6)572872, (FD6)574031,   //  3.74 - 3.75
    (FD6)575188, (FD6)576341,   //  3.76 - 3.77
    (FD6)577492, (FD6)578639,   //  3.78 - 3.79
    (FD6)579784, (FD6)580925,   //  3.80 - 3.81
    (FD6)582063, (FD6)583199,   //  3.82 - 3.83
    (FD6)584331, (FD6)585461,   //  3.84 - 3.85
    (FD6)586587, (FD6)587711,   //  3.86 - 3.87
    (FD6)588832, (FD6)589950,   //  3.88 - 3.89
    (FD6)591065, (FD6)592177,   //  3.90 - 3.91
    (FD6)593286, (FD6)594393,   //  3.92 - 3.93
    (FD6)595496, (FD6)596597,   //  3.94 - 3.95
    (FD6)597695, (FD6)598791,   //  3.96 - 3.97
    (FD6)599883, (FD6)600973,   //  3.98 - 3.99
    (FD6)602060, (FD6)603144,   //  4.00 - 4.01
    (FD6)604226, (FD6)605305,   //  4.02 - 4.03
    (FD6)606381, (FD6)607455,   //  4.04 - 4.05
    (FD6)608526, (FD6)609594,   //  4.06 - 4.07
    (FD6)610660, (FD6)611723,   //  4.08 - 4.09
    (FD6)612784, (FD6)613842,   //  4.10 - 4.11
    (FD6)614897, (FD6)615950,   //  4.12 - 4.13
    (FD6)617000, (FD6)618048,   //  4.14 - 4.15
    (FD6)619093, (FD6)620136,   //  4.16 - 4.17
    (FD6)621176, (FD6)622214,   //  4.18 - 4.19
    (FD6)623249, (FD6)624282,   //  4.20 - 4.21
    (FD6)625312, (FD6)626340,   //  4.22 - 4.23
    (FD6)627366, (FD6)628389,   //  4.24 - 4.25
    (FD6)629410, (FD6)630428,   //  4.26 - 4.27
    (FD6)631444, (FD6)632457,   //  4.28 - 4.29
    (FD6)633468, (FD6)634477,   //  4.30 - 4.31
    (FD6)635484, (FD6)636488,   //  4.32 - 4.33
    (FD6)637490, (FD6)638489,   //  4.34 - 4.35
    (FD6)639486, (FD6)640481,   //  4.36 - 4.37
    (FD6)641474, (FD6)642465,   //  4.38 - 4.39
    (FD6)643453, (FD6)644439,   //  4.40 - 4.41
    (FD6)645422, (FD6)646404,   //  4.42 - 4.43
    (FD6)647383, (FD6)648360,   //  4.44 - 4.45
    (FD6)649335, (FD6)650308,   //  4.46 - 4.47
    (FD6)651278, (FD6)652246,   //  4.48 - 4.49
    (FD6)653213, (FD6)654177,   //  4.50 - 4.51
    (FD6)655138, (FD6)656098,   //  4.52 - 4.53
    (FD6)657056, (FD6)658011,   //  4.54 - 4.55
    (FD6)658965, (FD6)659916,   //  4.56 - 4.57
    (FD6)660865, (FD6)661813,   //  4.58 - 4.59
    (FD6)662758, (FD6)663701,   //  4.60 - 4.61
    (FD6)664642, (FD6)665581,   //  4.62 - 4.63
    (FD6)666518, (FD6)667453,   //  4.64 - 4.65
    (FD6)668386, (FD6)669317,   //  4.66 - 4.67
    (FD6)670246, (FD6)671173,   //  4.68 - 4.69
    (FD6)672098, (FD6)673021,   //  4.70 - 4.71
    (FD6)673942, (FD6)674861,   //  4.72 - 4.73
    (FD6)675778, (FD6)676694,   //  4.74 - 4.75
    (FD6)677607, (FD6)678518,   //  4.76 - 4.77
    (FD6)679428, (FD6)680336,   //  4.78 - 4.79
    (FD6)681241, (FD6)682145,   //  4.80 - 4.81
    (FD6)683047, (FD6)683947,   //  4.82 - 4.83
    (FD6)684845, (FD6)685742,   //  4.84 - 4.85
    (FD6)686636, (FD6)687529,   //  4.86 - 4.87
    (FD6)688420, (FD6)689309,   //  4.88 - 4.89
    (FD6)690196, (FD6)691081,   //  4.90 - 4.91
    (FD6)691965, (FD6)692847,   //  4.92 - 4.93
    (FD6)693727, (FD6)694605,   //  4.94 - 4.95
    (FD6)695482, (FD6)696356,   //  4.96 - 4.97
    (FD6)697229, (FD6)698101,   //  4.98 - 4.99
    (FD6)698970, (FD6)699838,   //  5.00 - 5.01
    (FD6)700704, (FD6)701568,   //  5.02 - 5.03
    (FD6)702431, (FD6)703291,   //  5.04 - 5.05
    (FD6)704151, (FD6)705008,   //  5.06 - 5.07
    (FD6)705864, (FD6)706718,   //  5.08 - 5.09
    (FD6)707570, (FD6)708421,   //  5.10 - 5.11
    (FD6)709270, (FD6)710117,   //  5.12 - 5.13
    (FD6)710963, (FD6)711807,   //  5.14 - 5.15
    (FD6)712650, (FD6)713491,   //  5.16 - 5.17
    (FD6)714330, (FD6)715167,   //  5.18 - 5.19
    (FD6)716003, (FD6)716838,   //  5.20 - 5.21
    (FD6)717671, (FD6)718502,   //  5.22 - 5.23
    (FD6)719331, (FD6)720159,   //  5.24 - 5.25
    (FD6)720986, (FD6)721811,   //  5.26 - 5.27
    (FD6)722634, (FD6)723456,   //  5.28 - 5.29
    (FD6)724276, (FD6)725095,   //  5.30 - 5.31
    (FD6)725912, (FD6)726727,   //  5.32 - 5.33
    (FD6)727541, (FD6)728354,   //  5.34 - 5.35
    (FD6)729165, (FD6)729974,   //  5.36 - 5.37
    (FD6)730782, (FD6)731589,   //  5.38 - 5.39
    (FD6)732394, (FD6)733197,   //  5.40 - 5.41
    (FD6)733999, (FD6)734800,   //  5.42 - 5.43
    (FD6)735599, (FD6)736397,   //  5.44 - 5.45
    (FD6)737193, (FD6)737987,   //  5.46 - 5.47
    (FD6)738781, (FD6)739572,   //  5.48 - 5.49
    (FD6)740363, (FD6)741152,   //  5.50 - 5.51
    (FD6)741939, (FD6)742725,   //  5.52 - 5.53
    (FD6)743510, (FD6)744293,   //  5.54 - 5.55
    (FD6)745075, (FD6)745855,   //  5.56 - 5.57
    (FD6)746634, (FD6)747412,   //  5.58 - 5.59
    (FD6)748188, (FD6)748963,   //  5.60 - 5.61
    (FD6)749736, (FD6)750508,   //  5.62 - 5.63
    (FD6)751279, (FD6)752048,   //  5.64 - 5.65
    (FD6)752816, (FD6)753583,   //  5.66 - 5.67
    (FD6)754348, (FD6)755112,   //  5.68 - 5.69
    (FD6)755875, (FD6)756636,   //  5.70 - 5.71
    (FD6)757396, (FD6)758155,   //  5.72 - 5.73
    (FD6)758912, (FD6)759668,   //  5.74 - 5.75
    (FD6)760422, (FD6)761176,   //  5.76 - 5.77
    (FD6)761928, (FD6)762679,   //  5.78 - 5.79
    (FD6)763428, (FD6)764176,   //  5.80 - 5.81
    (FD6)764923, (FD6)765669,   //  5.82 - 5.83
    (FD6)766413, (FD6)767156,   //  5.84 - 5.85
    (FD6)767898, (FD6)768638,   //  5.86 - 5.87
    (FD6)769377, (FD6)770115,   //  5.88 - 5.89
    (FD6)770852, (FD6)771587,   //  5.90 - 5.91
    (FD6)772322, (FD6)773055,   //  5.92 - 5.93
    (FD6)773786, (FD6)774517,   //  5.94 - 5.95
    (FD6)775246, (FD6)775974,   //  5.96 - 5.97
    (FD6)776701, (FD6)777427,   //  5.98 - 5.99
    (FD6)778151, (FD6)778874,   //  6.00 - 6.01
    (FD6)779596, (FD6)780317,   //  6.02 - 6.03
    (FD6)781037, (FD6)781755,   //  6.04 - 6.05
    (FD6)782473, (FD6)783189,   //  6.06 - 6.07
    (FD6)783904, (FD6)784617,   //  6.08 - 6.09
    (FD6)785330, (FD6)786041,   //  6.10 - 6.11
    (FD6)786751, (FD6)787460,   //  6.12 - 6.13
    (FD6)788168, (FD6)788875,   //  6.14 - 6.15
    (FD6)789581, (FD6)790285,   //  6.16 - 6.17
    (FD6)790988, (FD6)791691,   //  6.18 - 6.19
    (FD6)792392, (FD6)793092,   //  6.20 - 6.21
    (FD6)793790, (FD6)794488,   //  6.22 - 6.23
    (FD6)795185, (FD6)795880,   //  6.24 - 6.25
    (FD6)796574, (FD6)797268,   //  6.26 - 6.27
    (FD6)797960, (FD6)798651,   //  6.28 - 6.29
    (FD6)799341, (FD6)800029,   //  6.30 - 6.31
    (FD6)800717, (FD6)801404,   //  6.32 - 6.33
    (FD6)802089, (FD6)802774,   //  6.34 - 6.35
    (FD6)803457, (FD6)804139,   //  6.36 - 6.37
    (FD6)804821, (FD6)805501,   //  6.38 - 6.39
    (FD6)806180, (FD6)806858,   //  6.40 - 6.41
    (FD6)807535, (FD6)808211,   //  6.42 - 6.43
    (FD6)808886, (FD6)809560,   //  6.44 - 6.45
    (FD6)810233, (FD6)810904,   //  6.46 - 6.47
    (FD6)811575, (FD6)812245,   //  6.48 - 6.49
    (FD6)812913, (FD6)813581,   //  6.50 - 6.51
    (FD6)814248, (FD6)814913,   //  6.52 - 6.53
    (FD6)815578, (FD6)816241,   //  6.54 - 6.55
    (FD6)816904, (FD6)817565,   //  6.56 - 6.57
    (FD6)818226, (FD6)818885,   //  6.58 - 6.59
    (FD6)819544, (FD6)820201,   //  6.60 - 6.61
    (FD6)820858, (FD6)821514,   //  6.62 - 6.63
    (FD6)822168, (FD6)822822,   //  6.64 - 6.65
    (FD6)823474, (FD6)824126,   //  6.66 - 6.67
    (FD6)824776, (FD6)825426,   //  6.68 - 6.69
    (FD6)826075, (FD6)826723,   //  6.70 - 6.71
    (FD6)827369, (FD6)828015,   //  6.72 - 6.73
    (FD6)828660, (FD6)829304,   //  6.74 - 6.75
    (FD6)829947, (FD6)830589,   //  6.76 - 6.77
    (FD6)831230, (FD6)831870,   //  6.78 - 6.79
    (FD6)832509, (FD6)833147,   //  6.80 - 6.81
    (FD6)833784, (FD6)834421,   //  6.82 - 6.83
    (FD6)835056, (FD6)835691,   //  6.84 - 6.85
    (FD6)836324, (FD6)836957,   //  6.86 - 6.87
    (FD6)837588, (FD6)838219,   //  6.88 - 6.89
    (FD6)838849, (FD6)839478,   //  6.90 - 6.91
    (FD6)840106, (FD6)840733,   //  6.92 - 6.93
    (FD6)841359, (FD6)841985,   //  6.94 - 6.95
    (FD6)842609, (FD6)843233,   //  6.96 - 6.97
    (FD6)843855, (FD6)844477,   //  6.98 - 6.99
    (FD6)845098, (FD6)845718,   //  7.00 - 7.01
    (FD6)846337, (FD6)846955,   //  7.02 - 7.03
    (FD6)847573, (FD6)848189,   //  7.04 - 7.05
    (FD6)848805, (FD6)849419,   //  7.06 - 7.07
    (FD6)850033, (FD6)850646,   //  7.08 - 7.09
    (FD6)851258, (FD6)851870,   //  7.10 - 7.11
    (FD6)852480, (FD6)853090,   //  7.12 - 7.13
    (FD6)853698, (FD6)854306,   //  7.14 - 7.15
    (FD6)854913, (FD6)855519,   //  7.16 - 7.17
    (FD6)856124, (FD6)856729,   //  7.18 - 7.19
    (FD6)857332, (FD6)857935,   //  7.20 - 7.21
    (FD6)858537, (FD6)859138,   //  7.22 - 7.23
    (FD6)859739, (FD6)860338,   //  7.24 - 7.25
    (FD6)860937, (FD6)861534,   //  7.26 - 7.27
    (FD6)862131, (FD6)862728,   //  7.28 - 7.29
    (FD6)863323, (FD6)863917,   //  7.30 - 7.31
    (FD6)864511, (FD6)865104,   //  7.32 - 7.33
    (FD6)865696, (FD6)866287,   //  7.34 - 7.35
    (FD6)866878, (FD6)867467,   //  7.36 - 7.37
    (FD6)868056, (FD6)868644,   //  7.38 - 7.39
    (FD6)869232, (FD6)869818,   //  7.40 - 7.41
    (FD6)870404, (FD6)870989,   //  7.42 - 7.43
    (FD6)871573, (FD6)872156,   //  7.44 - 7.45
    (FD6)872739, (FD6)873321,   //  7.46 - 7.47
    (FD6)873902, (FD6)874482,   //  7.48 - 7.49
    (FD6)875061, (FD6)875640,   //  7.50 - 7.51
    (FD6)876218, (FD6)876795,   //  7.52 - 7.53
    (FD6)877371, (FD6)877947,   //  7.54 - 7.55
    (FD6)878522, (FD6)879096,   //  7.56 - 7.57
    (FD6)879669, (FD6)880242,   //  7.58 - 7.59
    (FD6)880814, (FD6)881385,   //  7.60 - 7.61
    (FD6)881955, (FD6)882525,   //  7.62 - 7.63
    (FD6)883093, (FD6)883661,   //  7.64 - 7.65
    (FD6)884229, (FD6)884795,   //  7.66 - 7.67
    (FD6)885361, (FD6)885926,   //  7.68 - 7.69
    (FD6)886491, (FD6)887054,   //  7.70 - 7.71
    (FD6)887617, (FD6)888179,   //  7.72 - 7.73
    (FD6)888741, (FD6)889302,   //  7.74 - 7.75
    (FD6)889862, (FD6)890421,   //  7.76 - 7.77
    (FD6)890980, (FD6)891537,   //  7.78 - 7.79
    (FD6)892095, (FD6)892651,   //  7.80 - 7.81
    (FD6)893207, (FD6)893762,   //  7.82 - 7.83
    (FD6)894316, (FD6)894870,   //  7.84 - 7.85
    (FD6)895423, (FD6)895975,   //  7.86 - 7.87
    (FD6)896526, (FD6)897077,   //  7.88 - 7.89
    (FD6)897627, (FD6)898176,   //  7.90 - 7.91
    (FD6)898725, (FD6)899273,   //  7.92 - 7.93
    (FD6)899821, (FD6)900367,   //  7.94 - 7.95
    (FD6)900913, (FD6)901458,   //  7.96 - 7.97
    (FD6)902003, (FD6)902547,   //  7.98 - 7.99
    (FD6)903090, (FD6)903633,   //  8.00 - 8.01
    (FD6)904174, (FD6)904716,   //  8.02 - 8.03
    (FD6)905256, (FD6)905796,   //  8.04 - 8.05
    (FD6)906335, (FD6)906874,   //  8.06 - 8.07
    (FD6)907411, (FD6)907949,   //  8.08 - 8.09
    (FD6)908485, (FD6)909021,   //  8.10 - 8.11
    (FD6)909556, (FD6)910091,   //  8.12 - 8.13
    (FD6)910624, (FD6)911158,   //  8.14 - 8.15
    (FD6)911690, (FD6)912222,   //  8.16 - 8.17
    (FD6)912753, (FD6)913284,   //  8.18 - 8.19
    (FD6)913814, (FD6)914343,   //  8.20 - 8.21
    (FD6)914872, (FD6)915400,   //  8.22 - 8.23
    (FD6)915927, (FD6)916454,   //  8.24 - 8.25
    (FD6)916980, (FD6)917506,   //  8.26 - 8.27
    (FD6)918030, (FD6)918555,   //  8.28 - 8.29
    (FD6)919078, (FD6)919601,   //  8.30 - 8.31
    (FD6)920123, (FD6)920645,   //  8.32 - 8.33
    (FD6)921166, (FD6)921686,   //  8.34 - 8.35
    (FD6)922206, (FD6)922725,   //  8.36 - 8.37
    (FD6)923244, (FD6)923762,   //  8.38 - 8.39
    (FD6)924279, (FD6)924796,   //  8.40 - 8.41
    (FD6)925312, (FD6)925828,   //  8.42 - 8.43
    (FD6)926342, (FD6)926857,   //  8.44 - 8.45
    (FD6)927370, (FD6)927883,   //  8.46 - 8.47
    (FD6)928396, (FD6)928908,   //  8.48 - 8.49
    (FD6)929419, (FD6)929930,   //  8.50 - 8.51
    (FD6)930440, (FD6)930949,   //  8.52 - 8.53
    (FD6)931458, (FD6)931966,   //  8.54 - 8.55
    (FD6)932474, (FD6)932981,   //  8.56 - 8.57
    (FD6)933487, (FD6)933993,   //  8.58 - 8.59
    (FD6)934498, (FD6)935003,   //  8.60 - 8.61
    (FD6)935507, (FD6)936011,   //  8.62 - 8.63
    (FD6)936514, (FD6)937016,   //  8.64 - 8.65
    (FD6)937518, (FD6)938019,   //  8.66 - 8.67
    (FD6)938520, (FD6)939020,   //  8.68 - 8.69
    (FD6)939519, (FD6)940018,   //  8.70 - 8.71
    (FD6)940516, (FD6)941014,   //  8.72 - 8.73
    (FD6)941511, (FD6)942008,   //  8.74 - 8.75
    (FD6)942504, (FD6)943000,   //  8.76 - 8.77
    (FD6)943495, (FD6)943989,   //  8.78 - 8.79
    (FD6)944483, (FD6)944976,   //  8.80 - 8.81
    (FD6)945469, (FD6)945961,   //  8.82 - 8.83
    (FD6)946452, (FD6)946943,   //  8.84 - 8.85
    (FD6)947434, (FD6)947924,   //  8.86 - 8.87
    (FD6)948413, (FD6)948902,   //  8.88 - 8.89
    (FD6)949390, (FD6)949878,   //  8.90 - 8.91
    (FD6)950365, (FD6)950851,   //  8.92 - 8.93
    (FD6)951338, (FD6)951823,   //  8.94 - 8.95
    (FD6)952308, (FD6)952792,   //  8.96 - 8.97
    (FD6)953276, (FD6)953760,   //  8.98 - 8.99
    (FD6)954243, (FD6)954725,   //  9.00 - 9.01
    (FD6)955207, (FD6)955688,   //  9.02 - 9.03
    (FD6)956168, (FD6)956649,   //  9.04 - 9.05
    (FD6)957128, (FD6)957607,   //  9.06 - 9.07
    (FD6)958086, (FD6)958564,   //  9.08 - 9.09
    (FD6)959041, (FD6)959518,   //  9.10 - 9.11
    (FD6)959995, (FD6)960471,   //  9.12 - 9.13
    (FD6)960946, (FD6)961421,   //  9.14 - 9.15
    (FD6)961895, (FD6)962369,   //  9.16 - 9.17
    (FD6)962843, (FD6)963316,   //  9.18 - 9.19
    (FD6)963788, (FD6)964260,   //  9.20 - 9.21
    (FD6)964731, (FD6)965202,   //  9.22 - 9.23
    (FD6)965672, (FD6)966142,   //  9.24 - 9.25
    (FD6)966611, (FD6)967080,   //  9.26 - 9.27
    (FD6)967548, (FD6)968016,   //  9.28 - 9.29
    (FD6)968483, (FD6)968950,   //  9.30 - 9.31
    (FD6)969416, (FD6)969882,   //  9.32 - 9.33
    (FD6)970347, (FD6)970812,   //  9.34 - 9.35
    (FD6)971276, (FD6)971740,   //  9.36 - 9.37
    (FD6)972203, (FD6)972666,   //  9.38 - 9.39
    (FD6)973128, (FD6)973590,   //  9.40 - 9.41
    (FD6)974051, (FD6)974512,   //  9.42 - 9.43
    (FD6)974972, (FD6)975432,   //  9.44 - 9.45
    (FD6)975891, (FD6)976350,   //  9.46 - 9.47
    (FD6)976808, (FD6)977266,   //  9.48 - 9.49
    (FD6)977724, (FD6)978181,   //  9.50 - 9.51
    (FD6)978637, (FD6)979093,   //  9.52 - 9.53
    (FD6)979548, (FD6)980003,   //  9.54 - 9.55
    (FD6)980458, (FD6)980912,   //  9.56 - 9.57
    (FD6)981366, (FD6)981819,   //  9.58 - 9.59
    (FD6)982271, (FD6)982723,   //  9.60 - 9.61
    (FD6)983175, (FD6)983626,   //  9.62 - 9.63
    (FD6)984077, (FD6)984527,   //  9.64 - 9.65
    (FD6)984977, (FD6)985426,   //  9.66 - 9.67
    (FD6)985875, (FD6)986324,   //  9.68 - 9.69
    (FD6)986772, (FD6)987219,   //  9.70 - 9.71
    (FD6)987666, (FD6)988113,   //  9.72 - 9.73
    (FD6)988559, (FD6)989005,   //  9.74 - 9.75
    (FD6)989450, (FD6)989895,   //  9.76 - 9.77
    (FD6)990339, (FD6)990783,   //  9.78 - 9.79
    (FD6)991226, (FD6)991669,   //  9.80 - 9.81
    (FD6)992111, (FD6)992554,   //  9.82 - 9.83
    (FD6)992995, (FD6)993436,   //  9.84 - 9.85
    (FD6)993877, (FD6)994317,   //  9.86 - 9.87
    (FD6)994757, (FD6)995196,   //  9.88 - 9.89
    (FD6)995635, (FD6)996074,   //  9.90 - 9.91
    (FD6)996512, (FD6)996949,   //  9.92 - 9.93
    (FD6)997386, (FD6)997823,   //  9.94 - 9.95
    (FD6)998259, (FD6)998695,   //  9.96 - 9.97
    (FD6)999131, (FD6)999565,   //  9.98 - 9.99
    FD6_1                       // 10.00
    };


WORD    MantSearchTable[101] = {

       0,  //  0: 0.000000 - 0.012837,  EndIndex =   3 ( 4)
       2,  //  1: 0.008600 - 0.021189,  EndIndex =   5 ( 4)
       4,  //  2: 0.017033 - 0.033424,  EndIndex =   8 ( 5)
       7,  //  3: 0.029384 - 0.041393,  EndIndex =  10 ( 4)
       9,  //  4: 0.037426 - 0.053078,  EndIndex =  13 ( 5)
      12,  //  5: 0.049218 - 0.060698,  EndIndex =  15 ( 4)
      14,  //  6: 0.056905 - 0.071882,  EndIndex =  18 ( 5)
      17,  //  7: 0.068186 - 0.082785,  EndIndex =  21 ( 5)
      20,  //  8: 0.079181 - 0.093422,  EndIndex =  24 ( 5)
      23,  //  9: 0.089905 - 0.100371,  EndIndex =  26 ( 4)
      25,  // 10: 0.096910 - 0.110590,  EndIndex =  29 ( 5)
      28,  // 11: 0.107210 - 0.120574,  EndIndex =  32 ( 5)
      31,  // 12: 0.117271 - 0.130334,  EndIndex =  35 ( 5)
      34,  // 13: 0.127105 - 0.143015,  EndIndex =  39 ( 6)
      38,  // 14: 0.139879 - 0.152288,  EndIndex =  42 ( 5)
      41,  // 15: 0.149219 - 0.161368,  EndIndex =  45 ( 5)
      44,  // 16: 0.158362 - 0.170262,  EndIndex =  48 ( 5)
      47,  // 17: 0.167317 - 0.181844,  EndIndex =  52 ( 6)
      51,  // 18: 0.178977 - 0.190332,  EndIndex =  55 ( 5)
      54,  // 19: 0.187521 - 0.201397,  EndIndex =  59 ( 6)
      58,  // 20: 0.198657 - 0.212188,  EndIndex =  63 ( 6)
      62,  // 21: 0.209515 - 0.220108,  EndIndex =  66 ( 5)
      65,  // 22: 0.217484 - 0.230449,  EndIndex =  70 ( 6)
      69,  // 23: 0.227887 - 0.240549,  EndIndex =  74 ( 6)
      73,  // 24: 0.238046 - 0.250420,  EndIndex =  78 ( 6)
      77,  // 25: 0.247973 - 0.260071,  EndIndex =  82 ( 6)
      81,  // 26: 0.257679 - 0.271842,  EndIndex =  87 ( 7)
      86,  // 27: 0.269513 - 0.281033,  EndIndex =  91 ( 6)
      90,  // 28: 0.278754 - 0.290035,  EndIndex =  95 ( 6)
      94,  // 29: 0.287802 - 0.301030,  EndIndex = 100 ( 7)
      99,  // 30: 0.298853 - 0.311754,  EndIndex = 105 ( 7)
     104,  // 31: 0.309630 - 0.320146,  EndIndex = 109 ( 6)
     108,  // 32: 0.318063 - 0.330414,  EndIndex = 114 ( 7)
     113,  // 33: 0.328380 - 0.340444,  EndIndex = 119 ( 7)
     118,  // 34: 0.338456 - 0.350248,  EndIndex = 124 ( 7)
     123,  // 35: 0.348305 - 0.361728,  EndIndex = 130 ( 8)
     129,  // 36: 0.359835 - 0.371068,  EndIndex = 135 ( 7)
     134,  // 37: 0.369216 - 0.380211,  EndIndex = 140 ( 7)
     139,  // 38: 0.378398 - 0.390935,  EndIndex = 146 ( 8)
     145,  // 39: 0.389166 - 0.401401,  EndIndex = 152 ( 8)
     151,  // 40: 0.399674 - 0.411620,  EndIndex = 158 ( 8)
     157,  // 41: 0.409933 - 0.421604,  EndIndex = 164 ( 8)
     163,  // 42: 0.419956 - 0.431364,  EndIndex = 170 ( 8)
     169,  // 43: 0.429752 - 0.440909,  EndIndex = 176 ( 8)
     175,  // 44: 0.439333 - 0.450249,  EndIndex = 182 ( 8)
     181,  // 45: 0.448706 - 0.460898,  EndIndex = 189 ( 9)
     188,  // 46: 0.459392 - 0.471292,  EndIndex = 196 ( 9)
     195,  // 47: 0.469822 - 0.480007,  EndIndex = 202 ( 8)
     201,  // 48: 0.478566 - 0.491362,  EndIndex = 210 (10)
     209,  // 49: 0.489958 - 0.501059,  EndIndex = 217 ( 9)
     216,  // 50: 0.499687 - 0.510545,  EndIndex = 224 ( 9)
     223,  // 51: 0.509203 - 0.521138,  EndIndex = 232 (10)
     231,  // 52: 0.519828 - 0.530200,  EndIndex = 239 ( 9)
     238,  // 53: 0.528917 - 0.540329,  EndIndex = 247 (10)
     246,  // 54: 0.539076 - 0.550228,  EndIndex = 255 (10)
     254,  // 55: 0.549003 - 0.561101,  EndIndex = 264 (11)
     263,  // 56: 0.559907 - 0.570543,  EndIndex = 272 (10)
     271,  // 57: 0.569374 - 0.580925,  EndIndex = 281 (11)
     280,  // 58: 0.579784 - 0.591065,  EndIndex = 290 (11)
     289,  // 59: 0.589950 - 0.600973,  EndIndex = 299 (11)
     298,  // 60: 0.599883 - 0.610660,  EndIndex = 308 (11)
     307,  // 61: 0.609594 - 0.620136,  EndIndex = 317 (11)
     316,  // 62: 0.619093 - 0.630428,  EndIndex = 327 (12)
     326,  // 63: 0.629410 - 0.640481,  EndIndex = 337 (12)
     336,  // 64: 0.639486 - 0.650308,  EndIndex = 347 (12)
     346,  // 65: 0.649335 - 0.660865,  EndIndex = 358 (13)
     357,  // 66: 0.659916 - 0.670246,  EndIndex = 368 (12)
     367,  // 67: 0.669317 - 0.680336,  EndIndex = 379 (13)
     378,  // 68: 0.679428 - 0.690196,  EndIndex = 390 (13)
     389,  // 69: 0.689309 - 0.700704,  EndIndex = 402 (14)
     401,  // 70: 0.699838 - 0.710117,  EndIndex = 413 (13)
     412,  // 71: 0.709270 - 0.720159,  EndIndex = 425 (14)
     424,  // 72: 0.719331 - 0.730782,  EndIndex = 438 (15)
     437,  // 73: 0.729974 - 0.740363,  EndIndex = 450 (14)
     449,  // 74: 0.739572 - 0.750508,  EndIndex = 463 (15)
     462,  // 75: 0.749736 - 0.760422,  EndIndex = 476 (15)
     475,  // 76: 0.759668 - 0.770115,  EndIndex = 489 (15)
     488,  // 77: 0.769377 - 0.780317,  EndIndex = 503 (16)
     502,  // 78: 0.779596 - 0.790285,  EndIndex = 517 (16)
     516,  // 79: 0.789581 - 0.800029,  EndIndex = 531 (16)
     530,  // 80: 0.799341 - 0.810233,  EndIndex = 546 (17)
     545,  // 81: 0.809560 - 0.820201,  EndIndex = 561 (17)
     560,  // 82: 0.819544 - 0.830589,  EndIndex = 577 (18)
     576,  // 83: 0.829947 - 0.840106,  EndIndex = 592 (17)
     591,  // 84: 0.839478 - 0.850033,  EndIndex = 608 (18)
     607,  // 85: 0.849419 - 0.860338,  EndIndex = 625 (19)
     624,  // 86: 0.859739 - 0.870404,  EndIndex = 642 (19)
     641,  // 87: 0.869818 - 0.880242,  EndIndex = 659 (19)
     658,  // 88: 0.879669 - 0.890421,  EndIndex = 677 (20)
     676,  // 89: 0.889862 - 0.900367,  EndIndex = 695 (20)
     694,  // 90: 0.899821 - 0.910091,  EndIndex = 713 (20)
     712,  // 91: 0.909556 - 0.920123,  EndIndex = 732 (21)
     731,  // 92: 0.919601 - 0.930440,  EndIndex = 752 (22)
     751,  // 93: 0.929930 - 0.940018,  EndIndex = 771 (21)
     770,  // 94: 0.939519 - 0.950365,  EndIndex = 792 (23)
     791,  // 95: 0.949878 - 0.960471,  EndIndex = 813 (23)
     812,  // 96: 0.959995 - 0.970347,  EndIndex = 834 (23)
     833,  // 97: 0.969882 - 0.980003,  EndIndex = 855 (23)
     854,  // 98: 0.979548 - 0.990339,  EndIndex = 878 (25)
     877,  // 99: 0.989895 - 1.000000,  EndIndex = 900 (24)
     899   // Last MantissaTable[] Index Number - 1
    };

//
// Mantissa Correction Data Bits Usage:
//
//
//       <---High Word---> <----Low Word--->
//  Bit#  3          2          1          0
//       10987654 32109876 54321098 76543210
//       | | | |  | |  |   ||  |  |
//       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
//       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
//       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
//       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
//       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
//       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
//       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
//       | | | +--------------------- x.006-x.007 (0-3) Correct 6
//       | | +----------------------- x.005-x.006 (0-3) Correct 7
//       | +------------------------- x.004-x.005 (0-3) Correct 8
//       +--------------------------- x.003-x.004 (0-3) Correct 9
//

DWORD MantissaCorrectData[MANTISSATABLE_SIZE] = {

    0x269b49ae, 0x169a49aa, 0x159339a6, 0x9ba34ba1, 0x0692399e,  // 1.00-1.04
    0x165a399a, 0x559a4796, 0x1a93c792, 0x5adb398e, 0x4692398b,  // 1.05-1.09
    0x5a934787, 0x15923784, 0x59d33980, 0x5593297d, 0x1252277a,  // 1.10-1.14
    0x269bb776, 0x56933773, 0x55923770, 0x4653276d, 0x1592276a,  // 1.15-1.19
    0x158b2767, 0x46523764, 0x49922761, 0x1992b75e, 0x2692b75b,  // 1.20-1.24
    0x11522559, 0x45922556, 0x56922753, 0x054a2551, 0x158a354e,  // 1.25-1.29
    0x599a374b, 0x458a2749, 0x014a1547, 0x55522544, 0x05492542,  // 1.30-1.34
    0x1652b53f, 0x058aa53d, 0x044a233b, 0x00491539, 0x55522536,  // 1.35-1.39
    0x154a2534, 0x05492532, 0x01492530, 0x5992272d, 0x1992a72b,  // 1.40-1.44
    0x198ab529, 0x55922527, 0x00411526, 0x56522523, 0x56522721,  // 1.45-1.49
    0x01091520, 0x0449231e, 0x0149231c, 0x4549251a, 0x154a9518,  // 1.50-1.54
    0x4651a516, 0x01091315, 0x04492313, 0x454a1511, 0x158aa50f,  // 1.55-1.59
    0x0141230e, 0x1451150c, 0x464aa50a, 0x04491309, 0x454a1507,  // 1.60-1.64
    0x1952a505, 0x05491504, 0x558a2502, 0x41491501, 0x158a94ff,  // 1.65-1.69
    0x050922fe, 0x555124fc, 0x114914fb, 0x564a24f9, 0x454914f8,  // 1.70-1.74
    0x010912f7, 0x455122f5, 0x110914f4, 0x1951a4f2, 0x154994f1,  // 1.75-1.79
    0x410912f0, 0x558a22ee, 0x454a14ed, 0x114912ec, 0x010812eb,  // 1.80-1.84
    0x1551a2e9, 0x1149a2e8, 0x110912e7, 0x010812e6, 0x000102e5,  // 1.85-1.89
    0x454922e3, 0x114914e2, 0x044912e1, 0x044112e0, 0x004102df,  // 1.90-1.94
    0x1551a2dd, 0x518914dc, 0x454914db, 0x444922da, 0x414912d9,  // 1.95-1.99
    0x110912d8, 0x014112d7, 0x040912d6, 0x010812d5, 0x010812d4,  // 2.00-2.04
    0x004102d3, 0x2551a4d1, 0x2551a4d0, 0x000812d0, 0x000812cf,  // 2.05-2.09
    0x595124cd, 0x010812cd, 0x100902cc, 0x044110cb, 0x010902ca,  // 2.10-2.14
    0x410912c9, 0x444112c8, 0x110912c7, 0x450914c6, 0x1449a2c5,  // 2.15-2.19
    0x515112c4, 0x155194c3, 0x000802c3, 0x004102c2, 0x010892c1,  // 2.20-2.24
    0x044910c0, 0x054194bf, 0x154992be, 0x554922bd, 0x004012bd,  // 2.25-2.29
    0x044102bc, 0x414112bb, 0x114992ba, 0x1549a2b9, 0x000810b9,  // 2.30-2.34
    0x044102b8, 0x114112b7, 0x144994b6, 0x000010b6, 0x004102b5,  // 2.35-2.39
    0x414112b4, 0x454912b3, 0x555114b2, 0x040812b2, 0x444812b1,  // 2.40-2.44
    0x550a12b0, 0x000802b0, 0x410902af, 0x450912ae, 0x458994ad,  // 2.45-2.49
    0x104102ad, 0x114892ac, 0x000000ac, 0x100810ab, 0x444812aa,  // 2.50-2.54
    0x1549a2a9, 0x010102a9, 0x110992a8, 0x515192a7, 0x010110a7,  // 2.55-2.59
    0x144992a6, 0x155192a5, 0x410812a5, 0x144992a4, 0x004010a4,  // 2.60-2.64
    0x044892a3, 0x554912a2, 0x104102a2, 0x450912a1, 0x000802a1,  // 2.65-2.69
    0x110902a0, 0x4549949f, 0x4041029f, 0x4509929e, 0x0101009e,  // 2.70-2.74
    0x4449029d, 0x0000109d, 0x4441029c, 0x5549129b, 0x1041029b,  // 2.75-2.79
    0x5149129a, 0x0101029a, 0x45091299, 0x00010299, 0x11099298,  // 2.80-2.84
    0x00001098, 0x44481297, 0x554a1296, 0x44411296, 0x51519295,  // 2.85-2.89
    0x41090295, 0x51519294, 0x04418294, 0x55491293, 0x41081293,  // 2.90-2.94
    0x00000093, 0x04411092, 0x55491491, 0x11081291, 0x1549a290,  // 2.95-2.99
    0x11081290, 0x00000290, 0x1109828f, 0x0008008f, 0x1109908e,  // 3.00-3.04
    0x0000108e, 0x4509128d, 0x1001028d, 0x4541128c, 0x4041028c,  // 3.05-3.09
    0x5449128b, 0x0408928b, 0x5549128a, 0x0448928a, 0x0008008a,  // 3.10-3.14
    0x45091089, 0x00401089, 0x54491288, 0x41010288, 0x45499287,  // 3.15-3.19
    0x41090287, 0x00001087, 0x14489286, 0x01010086, 0x51491285,  // 3.20-3.24
    0x04089285, 0x00000085, 0x11098284, 0x01001084, 0x15099283,  // 3.25-3.29
    0x11010283, 0x51519282, 0x44481282, 0x00080282, 0x45499281,  // 3.30-3.34
    0x10411081, 0x00000281, 0x14489280, 0x40401080, 0x4549927f,  // 3.35-3.39
    0x1109027f, 0x0008027f, 0x1449927e, 0x0441027e, 0x0000027e,  // 3.40-3.44
    0x5141127d, 0x0108027d, 0x1549947c, 0x4448127c, 0x0401027c,  // 3.45-3.49
    0x1549927b, 0x1108927b, 0x1001007b, 0x5509127a, 0x1108127a,  // 3.50-3.54
    0x0040027a, 0x54491279, 0x41090279, 0x00001079, 0x51499278,  // 3.55-3.59
    0x11081078, 0x04001078, 0x45498277, 0x11081077, 0x00400277,  // 3.60-3.64
    0x15099276, 0x44410276, 0x01001076, 0x55091275, 0x11089275,  // 3.65-3.69
    0x04010075, 0x45499274, 0x11098274, 0x00409074, 0x15499273,  // 3.70-3.74
    0x11419273, 0x04081073, 0x00000273, 0x51481272, 0x04418272,  // 3.75-3.79
    0x00080072, 0x54491271, 0x11089271, 0x01001071, 0x00000071,  // 3.80-3.84
    0x45090270, 0x41010270, 0x00080070, 0x4548926f, 0x1108906f,  // 3.85-3.89
    0x1001006f, 0x4549926e, 0x4448926e, 0x1040106e, 0x0000106e,  // 3.90-3.94
    0x5509126d, 0x1109826d, 0x0401006d, 0x0000006d, 0x1448926c,  // 3.95-3.99
    0x1041026c, 0x0040026c, 0x4549926b, 0x4448126b, 0x1041026b,  // 4.00-4.04
    0x0001006b, 0x5449126a, 0x4448126a, 0x0408026a, 0x0000106a,  // 4.05-4.09
    0x45419269, 0x44411069, 0x10080269, 0x45899268, 0x14499268,  // 4.10-4.14
    0x41410268, 0x04080268, 0x00000068, 0x15099267, 0x44410267,  // 4.15-4.19
    0x04080267, 0x55511266, 0x54491266, 0x11089266, 0x10401066,  // 4.20-4.24
    0x00400066, 0x45498265, 0x11098265, 0x10401065, 0x00000265,  // 4.25-4.29
    0x15499264, 0x14489264, 0x41081064, 0x10010064, 0x15499263,  // 4.30-4.34
    0x45411263, 0x11081263, 0x04080263, 0x00080063, 0x51499062,  // 4.35-4.39
    0x14419062, 0x10401062, 0x04000262, 0x51499261, 0x14489261,  // 4.40-4.44
    0x04418261, 0x01009061, 0x00000061, 0x55091260, 0x44489260,  // 4.45-4.49
    0x04418060, 0x00080060, 0x5149945f, 0x4509925f, 0x4441025f,  // 4.50-4.54
    0x4101025f, 0x0008005f, 0x5549125e, 0x4509925e, 0x0448905e,  // 4.55-4.59
    0x4040105e, 0x0008005e, 0x5149925d, 0x1448925d, 0x4441025d,  // 4.60-4.64
    0x4040105d, 0x0008005d, 0x5149925c, 0x1449825c, 0x0441905c,  // 4.65-4.69
    0x4040105c, 0x0008005c, 0x4549925b, 0x5141125b, 0x1108925b,  // 4.70-4.74
    0x4041005b, 0x0001005b, 0x0000005b, 0x5148925a, 0x4448105a,  // 4.75-4.79
    0x4101025a, 0x0400105a, 0x0000005a, 0x55091259, 0x14489259,  // 4.80-4.84
    0x11081059, 0x10080259, 0x00080059, 0x54499258, 0x14498258,  // 4.85-4.89
    0x11410258, 0x10410258, 0x04001058, 0x00000058, 0x15419257,  // 4.90-4.94
    0x14489257, 0x11081057, 0x04080257, 0x40000257, 0x55099256,  // 4.95-4.99
    0x45419256, 0x11419056, 0x44081056, 0x01009056, 0x00000056,  // 5.00-5.04
    0x00000056, 0x15099055, 0x11418255, 0x04089055, 0x04010055,  // 5.05-5.09
    0x00010055, 0x51499254, 0x51481254, 0x45081254, 0x11010254,  // 5.10-5.14
    0x40400254, 0x10000054, 0x55489253, 0x51490253, 0x44481253,  // 5.15-5.19
    0x04418253, 0x01018053, 0x04000053, 0x45499252, 0x55091252,  // 5.20-5.24
    0x14489252, 0x11089052, 0x41010052, 0x40010052, 0x00000052,  // 5.25-5.29
    0x55099251, 0x45099051, 0x44481051, 0x11010251, 0x40400251,  // 5.30-5.34
    0x01000051, 0x15499250, 0x55091250, 0x14489250, 0x11089050,  // 5.35-5.39
    0x10401050, 0x01000250, 0x00001050, 0x5449924f, 0x5148924f,  // 5.40-5.44
    0x1448904f, 0x1108104f, 0x0408824f, 0x0040004f, 0x0000104f,  // 5.45-5.49
    0x5541924e, 0x1449904e, 0x5109024e, 0x0441824e, 0x4040104e,  // 5.50-5.54
    0x1001004e, 0x0000004e, 0x1549924d, 0x4541924d, 0x1141904d,  // 5.55-5.59
    0x0441824d, 0x1040104d, 0x0040024d, 0x0000024d, 0x5549124c,  // 5.60-5.64
    0x5449124c, 0x1141924c, 0x4441024c, 0x1101024c, 0x4040024c,  // 5.65-5.69
    0x0008004c, 0x0000004c, 0x5509924b, 0x1509904b, 0x1141824b,  // 5.70-5.74
    0x1108104b, 0x4101024b, 0x1001004b, 0x1000004b, 0x5541924a,  // 5.75-5.79
    0x1541924a, 0x1448924a, 0x1441824a, 0x0440904a, 0x4040104a,  // 5.80-5.84
    0x0001804a, 0x0000004a, 0x15499249, 0x55091249, 0x14489249,  // 5.85-5.89
    0x44410249, 0x04418249, 0x01018049, 0x00080049, 0x00000249,  // 5.90-5.94
    0x45499248, 0x55091248, 0x51411248, 0x11098248, 0x41081048,  // 5.95-5.99
    0x04080248, 0x00400248, 0x00000248, 0x00000048, 0x55411247,  // 6.00-6.04
    0x45419247, 0x14419047, 0x11089047, 0x10410047, 0x40400247,  // 6.05-6.09
    0x00080047, 0x00000047, 0x55491246, 0x54491246, 0x11419246,  // 6.10-6.14
    0x11418246, 0x41081046, 0x04080246, 0x00408246, 0x10000046,  // 6.15-6.19
    0x00000046, 0x55490245, 0x15099245, 0x45098245, 0x45081045,  // 6.20-6.24
    0x11081045, 0x04088245, 0x00088045, 0x10000045, 0x00000045,  // 6.25-6.29
    0x55491044, 0x15099244, 0x44498244, 0x44481044, 0x10418244,  // 6.30-6.34
    0x10410044, 0x01001044, 0x10000244, 0x00000044, 0x54499243,  // 6.35-6.39
    0x15419243, 0x14489243, 0x11098243, 0x04418243, 0x04089043,  // 6.40-6.44
    0x01018043, 0x00400043, 0x00001043, 0x00000043, 0x55481242,  // 6.45-6.49
    0x15099242, 0x45098242, 0x44481042, 0x10418242, 0x10401042,  // 6.50-6.54
    0x40400242, 0x00080042, 0x00001042, 0x55491241, 0x51499241,  // 6.55-6.59
    0x51481241, 0x14419241, 0x44418241, 0x44401041, 0x04089041,  // 6.60-6.64
    0x04010041, 0x10001041, 0x00000041, 0x00000041, 0x54499240,  // 6.65-6.69
    0x51498240, 0x51411040, 0x51081240, 0x04418240, 0x04089040,  // 6.70-6.74
    0x01018040, 0x40080040, 0x10000040, 0x00000040, 0x5509923f,  // 6.75-6.79
    0x1548923f, 0x5148123f, 0x1448923f, 0x4448103f, 0x1101823f,  // 6.80-6.84
    0x4101003f, 0x4040103f, 0x0008003f, 0x0000023f, 0x0000003f,  // 6.85-6.89
    0x5149923e, 0x1541923e, 0x5448123e, 0x4508123e, 0x1108923e,  // 6.90-6.94
    0x4108103e, 0x0408823e, 0x0401003e, 0x0100023e, 0x0001003e,  // 6.95-6.99
    0x0000003e, 0x5149923d, 0x5509123d, 0x4541923d, 0x5141103d,  // 7.00-7.04
    0x1141823d, 0x1108103d, 0x1101023d, 0x1008023d, 0x0100103d,  // 7.05-7.09
    0x4000023d, 0x0000003d, 0x0000003d, 0x1549903c, 0x1541923c,  // 7.10-7.14
    0x1448923c, 0x5109023c, 0x4441023c, 0x0441823c, 0x0440103c,  // 7.15-7.19
    0x0408023c, 0x0100103c, 0x0001003c, 0x0008003c, 0x5548923b,  // 7.20-7.24
    0x5509923b, 0x5449103b, 0x5141123b, 0x4448923b, 0x1108903b,  // 7.25-7.29
    0x1108103b, 0x4101023b, 0x4040103b, 0x0401003b, 0x0001003b,  // 7.30-7.34
    0x0001003b, 0x5549123a, 0x5549123a, 0x5509123a, 0x4541923a,  // 7.35-7.39
    0x5141103a, 0x1109823a, 0x1108903a, 0x4408103a, 0x1040103a,  // 7.40-7.44
    0x4040023a, 0x0008803a, 0x4000003a, 0x0000003a, 0x45499239,  // 7.45-7.49
    0x51499239, 0x45489239, 0x14498239, 0x45090239, 0x11089239,  // 7.50-7.54
    0x11089039, 0x44081039, 0x10401039, 0x40401039, 0x00088039,  // 7.55-7.59
    0x10000039, 0x00000039, 0x00000039, 0x55491038, 0x55091238,  // 7.60-7.64
    0x45419238, 0x51411038, 0x45081238, 0x44410238, 0x10418238,  // 7.65-7.69
    0x10401038, 0x04080238, 0x01000238, 0x04000238, 0x04000038,  // 7.70-7.74
    0x00000038, 0x55099237, 0x55099237, 0x54491037, 0x45419237,  // 7.75-7.79
    0x11419037, 0x11418237, 0x11089037, 0x44081037, 0x04089037,  // 7.80-7.84
    0x04018037, 0x40080037, 0x00400037, 0x00010037, 0x00000037,  // 7.85-7.89
    0x55491236, 0x45499236, 0x15419236, 0x51489236, 0x11419036,  // 7.90-7.94
    0x51090236, 0x44410236, 0x04418236, 0x04089036, 0x41010036,  // 7.95-7.99
    0x01009036, 0x00400036, 0x00008236, 0x00000036, 0x00000036,  // 8.00-8.04
    0x54499235, 0x55099235, 0x54491035, 0x51419235, 0x14419035,  // 8.05-8.09
    0x11418235, 0x44481035, 0x11088235, 0x10410035, 0x04088235,  // 8.10-8.14
    0x10080035, 0x04001035, 0x00080035, 0x00010035, 0x00000035,  // 8.15-8.19
    0x51499234, 0x54499234, 0x51498234, 0x54490234, 0x14489234,  // 8.20-8.24
    0x11418234, 0x44418234, 0x44081034, 0x10418234, 0x41010034,  // 8.25-8.29
    0x40401034, 0x04001034, 0x04000234, 0x00400034, 0x00000034,  // 8.30-8.34
    0x00000034, 0x55491233, 0x45499233, 0x45489233, 0x54490233,  // 8.35-8.39
    0x14489233, 0x51090233, 0x14418233, 0x11081033, 0x10418233,  // 8.40-8.44
    0x10410033, 0x04080233, 0x40400233, 0x40080033, 0x01000033,  // 8.45-8.49
    0x40000033, 0x00000033, 0x55489232, 0x54499232, 0x15489232,  // 8.50-8.54
    0x45489232, 0x45099032, 0x51411032, 0x51081232, 0x44410232,  // 8.55-8.59
    0x44410232, 0x41080232, 0x04088232, 0x01018032, 0x10010032,  // 8.60-8.64
    0x10001032, 0x00400032, 0x01000032, 0x00000032, 0x51499231,  // 8.65-8.69
    0x45499231, 0x55091231, 0x15099231, 0x51481231, 0x14489231,  // 8.70-8.74
    0x51090231, 0x14418231, 0x11089031, 0x04418031, 0x04409031,  // 8.75-8.79
    0x41010031, 0x01018031, 0x40400031, 0x00400031, 0x00001031,  // 8.80-8.84
    0x00080031, 0x00000031, 0x55489230, 0x55099230, 0x45498230,  // 8.85-8.89
    0x51489230, 0x45099030, 0x45090230, 0x44489230, 0x51081030,  // 8.90-8.94
    0x44410230, 0x11081030, 0x11010230, 0x04088230, 0x04018030,  // 8.95-8.99
    0x40400030, 0x00088030, 0x10000030, 0x00000030, 0x00001030,  // 9.00-9.04
    0x5541922f, 0x1549922f, 0x5449922f, 0x4549822f, 0x5449022f,  // 9.05-9.09
    0x5141122f, 0x1448922f, 0x1441902f, 0x4448102f, 0x4441022f,  // 9.10-9.14
    0x1108022f, 0x1101022f, 0x0408822f, 0x0401802f, 0x4040002f,  // 9.15-9.19
    0x0008802f, 0x0400002f, 0x0400002f, 0x0000002f, 0x0000002f,  // 9.20-9.24
    0x5541922e, 0x5509922e, 0x4549822e, 0x5148922e, 0x1509902e,  // 9.25-9.29
    0x4509822e, 0x1441902e, 0x1441822e, 0x1108902e, 0x1108902e,  // 9.30-9.34
    0x0441802e, 0x0440902e, 0x4101002e, 0x0101802e, 0x4008002e,  // 9.35-9.39
    0x0008802e, 0x0400002e, 0x0400002e, 0x0000002e, 0x0000002e,  // 9.40-9.44
    0x5449922d, 0x5149922d, 0x5541122d, 0x1509922d, 0x5148922d,  // 9.45-9.49
    0x5141902d, 0x1448902d, 0x1141822d, 0x4441102d, 0x4441022d,  // 9.50-9.54
    0x0441822d, 0x4408102d, 0x1040902d, 0x0408802d, 0x1008002d,  // 9.55-9.59
    0x0100102d, 0x0400022d, 0x0008002d, 0x0001002d, 0x0000002d,  // 9.60-9.64
    0x0000002d, 0x5549122c, 0x1549922c, 0x5449922c, 0x5149822c,  // 9.65-9.69
    0x5449022c, 0x5148122c, 0x1448922c, 0x1141902c, 0x1441822c,  // 9.70-9.74
    0x1108902c, 0x1108902c, 0x0441802c, 0x0440902c, 0x4101002c,  // 9.75-9.79
    0x4040102c, 0x0100102c, 0x0040822c, 0x0100002c, 0x0008002c,  // 9.80-9.84
    0x0008002c, 0x0000002c, 0x0000002c, 0x4549922b, 0x4549922b,  // 9.85-9.89
    0x5509922b, 0x5149902b, 0x5449102b, 0x5148122b, 0x1448922b,  // 9.90-9.94
    0x4509022b, 0x5108122b, 0x4441822b, 0x1108102b, 0x4441022b,  // 9.95-9.99
    0x00000000 };


DWORD   Power10ExpNum[] = {

                    1L,
                   10L,
                  100L,
                 1000L,
                10000L,
               100000L,
              1000000L,
             10000000L,
            100000000L,
           1000000000L
        };





FD6
HTENTRY
Log(
    FD6 Number
    )

/*++

Routine Description:

    This functions calculate the common logarithm for the number passed in,
    this is 10 based logarithm.

Arguments:

    Number - the decimal (FD6) number, this is a special format decimal number
             (FD6) it depends on the #define and may be floating number or
             six (6) lower digits as number to the right of the decimal
             points. that is 3 = 0.000003, 10000 = 0.010000, 1232321 = 1.232321
             and so on.

Return Value:

    Now no error value is returned, but it will clip to the FD6 defined limit
    as following:

    FD6_LOG_MAX - if the Number passed in is >= FD6_MAX (ie. 2147.483647)
                  then it returned FD6_LOG_MAX (ie. 3.331930).

    FD6_LOG_MIN - if the Number passed in is less or equal to 0 then it treated
                  passed Number as 0.000001 so the return value will be
                  FD6_LOG_MIN (ie. -6.0)

    othewise    - the approximate logarithm (based 10) number is returnd as
                  a FD6 number.  The accuracy of the returned logarithm number
                  as minimum/maximum errors as

                    maximum error = +0.000005983
                    minimum error = -0.0000009018

Author:

    16-Jan-1991 Wed 14:03:58 created  -by-  Daniel Chou (danielc)

Revision History:

    26-Sep-1991 Thu 12:10:52 updated  -by-  Daniel Chou (danielc)

        Rewrite for more accuracy up to six significant decimal digitis, and
        also make it durable to run under floating point package.


--*/

{
    FD6     Characteristic;                     // characteristics number
    FD6     Mantissa;
    LONG    Rem;
    INT     Quot;


    //
    // Do in-line binary search to find out how many digits of this
    // number (decimal left shift count), at here the range is from
    // 0.000001 to 999.999999, the goal is to make the number range in
    // 100.000000 to 999.999999 and also get its characteristic number.
    //
    //  100.000000  = 0
    //   10.000000  = 1
    //    1.000000  = 2
    //    0.100000  = 3
    //    0.010000  = 4
    //    0.001000  = 5
    //    0.000100  = 6
    //    0.000010  = 7
    //    0.000001  = 8
    //
    // first, find out what the characteristic is
    //

    if (Number >= FD6_p01) {                            // possible 0,1,2,3,4

        if (Number >= FD6_1) {                          // possible 0,1,2

            if (Number >= FD6_10) {                     // possible 0,1

                if (Number >= FD6_100) {                // possible 0

                    if (Number >= FD6_1000) {

                        if (Number >= (FD6_MAX - FD6_p000005)) {

                            return(FD6_LOG_MAX);
                        }

                        Characteristic = FD6_3;
                        Number = FD6DivL(Number, 10);

                    } else {

                        // 100.000000 - 999.000000

                        Characteristic = FD6_2;         // alreay in range
                    }

                } else {                                // possible 1

                    // 10.000000 - 99.999999

                    Characteristic = FD6_1;
                    Number = FD6xL(Number, 10);
                }

            } else {                                    // possible 2

                // 1.000000 - 9.999999

                Characteristic = FD6_0;
                Number = FD6xL(Number, 100);
            }

        } else if (Number >= FD6_p1) {                  // possible 3

            // 0.100000 - 0.999999

            Characteristic = -FD6_1;
            Number = FD6xL(Number, 1000);

        } else {                                        // possible 4

            // 0.010000 - 0.099999

            Characteristic = -FD6_2;
            Number = FD6xL(Number, 10000);
        }

    } else if (Number >= FD6_p0001) {                   // possible 5,6

        if (Number >= FD6_p001) {                       // possible 5

            // 0.001000 - 0.009999

            Characteristic = -FD6_3;
            Number = FD6xL(Number, 100000);

        } else {                                        // possible 6

            // 0.000100 - 0.000999

            Characteristic = -FD6_4;
            Number = FD6xL(Number, 1000000);
        }

    } else if (Number >= FD6_p00001) {                  // possible 7

        // 0.000010 - 0.000099

        Characteristic = -FD6_5;
        Number = FD6xL(Number, 10000000);

    } else if (Number > FD6_0) {                        // possible 8

        // 0.000001 - 0.000009

        Characteristic = -FD6_6;
        Number = FD6xL(Number, 100000000);

    } else {

        return(FD6_LOG_MIN);                            // invalid numbers
    }

    //
    // The number now range from 100.0000 to 999.999999
    //
    //
    //  ASSERT((Number >= FD6_100) && (Number < FD6_1000));
    //

    //
    // The Number now range from 100.000000 - 999.999999 and we need to
    // find the mantissa for it.  The number will be index
    // and/or interpolate from the table as following:
    //
    // Number  123.1234567
    //         |   |
    //         |   +----> 0.1234567 (if non zero) then interpolate with
    //         |          next table entry.
    //         |
    //         +-------> (123 - 100) will be index into the table
    //
    // For example:
    //
    //  Log (1.234567)     = 0.091515
    //
    //      Characteristic = 0.000000
    //            Mantissa = Table[123-100] = 0.089905
    //            Fraction = (Table[124-100] - 0.089905) * 0.456700
    //                     = 0.003517 * 0.4567 = 0.001606
    //              Return = (Characteristic + Mantissa + Fraction) =
    //                     = 0.000000 + 0.089905 + 0.001606 = 0.091511
    //               Error = 0.091515 - 0.091511 = 0.000004
    //
    //      Max/Min Errors are +0.000006/-0.000001
    //

    Mantissa = MantissaTable[Quot = (INT)(Number / FD6_1) - (INT)100];

    if (Rem = (LONG)(Number % FD6_1)) {

        Mantissa += FractionToMantissa((FD6)Rem,
                                       MantissaCorrectData[Quot]);
    }

    return(Characteristic + Mantissa);

}



FD6
HTENTRY
AntiLog(
    FD6 Number
    )

/*++

Routine Description:

    Calculate the antilogarithm for the logarithm number passed in, that is
    this function return the exponent of Number which base 10.

Arguments:

    Number - the logarithm number, this is a special format decimal number
             (FD6) it depends on the #define and may be floating number or
             six (6) lower digits as number to the right of the decimal
             points. that is 3 = 0.000003, 10000 = 0.010000, 1232321 = 1.232321
             and so on.

Return Value:

    Now no error returned, but it clipped the result to the FD6 limit, return
    values as following:

    0.000001    - if the Number is <= -6.0

    FD6_MAX     - if the Number is >= 3.331930 then it return FD6_MAX
                  (ie. 2147.483647).

    othewise    - approximate the antilogarithm (base 10) of the Number passed
                  in. the accuracy of the function is abount +0.000008 to
                  -0.000001.

Author:

    16-Jan-1991 Wed 15:34:17 created  -by-  Daniel Chou (danielc)

Revision History:

    26-Sep-1991 Thu 12:01:06 updated  -by-  Daniel Chou (danielc)

        Rewrite for more accuracy up to six significant decimal digitis, and
        also make it durable to run under floating point package.


--*/

{
    INT     Characteristic;
    INT     Index;
    INT     IndexH;
    INT     IndexL;
    FD6     CurrentMantissa;

    //
    // The number range is from -5.999999 - 3.331928
    // Separate the Number into Characteristic and Mantissa,
    //

    if (Number < FD6_0) {

        if (Number <= FD6_LOG_MIN) {

            return(FD6_p000001);
        }

        Characteristic  = (INT)((Number - (FD6)999999) / FD6_1);
        Number         -= FD6xL(FD6_1, Characteristic);

    } else if (Number >= FD6_1) {

        if (Number >= FD6_LOG_MAX) {

            return(FD6_MAX);
        }

        Characteristic = (INT)((Number + (FD6)999999) / FD6_1);
        Number         = FD6xL(FD6_1, Characteristic) - Number;

    } else {

        Characteristic = 0;
    }

    if (Number) {

        //
        // Do a modified binary search to find the closed low index, the
        // SearchTable[] is a estimate index for the first 2 mantissa digits.
        //

        Index  = (INT)(Number / FD6_p01);           // divide by 0.01 for index
        IndexL = (INT)MantSearchTable[Index++];     // starting estimate index
        IndexH = (INT)(MantSearchTable[Index] + 1); // ending estimate index

        while ((Index = (IndexL + IndexH) >> 1) != IndexL) {

            if (Number < (CurrentMantissa = MantissaTable[Index])) {

                IndexH = Index;

            } else if (Number > CurrentMantissa) {

                IndexL = Index;

            } else {

                Number = FD6_0;
                break;
            }
        }

        if (Number) {                   // Number = 0, if exactly match

            ASSERT((IndexL == Index) && ((IndexL + 1) == IndexH));

            //
            // Here we try to estimate for lower 4 decimal digit Mantissa
            // the table index is the index Mantissa of 0 - 900 (0.00 - 9.00)
            // the interpolate Mantissa is betwen two table indics Mantissas
            // such between 512 and 513 will be Mantissa between 5.12 and 5.13
            //

            Number = MantissaToFraction(Number - MantissaTable[IndexL],
                                        MantissaCorrectData[IndexL]);
        }

        //
        // The Index range is from 0-900
        //
        // Add in 100 to offset the mantissa table, since the first entry
        // is 1.0000
        //

        Number += INTToFD6(Index + 100);
        Characteristic -= 2;

    } else {                        // Number = 0.0, the result is 1.0

        Number = FD6_1;
    }

    //
    // Now we need to shift the decimal point around, if characteristic is
    // positive then we shift the decimal to the right (multiply), if the
    // Mantissa is negative then we shift the decimal point to the left
    // (divide), if it is a zero, then this is the final logarithm Mantissa.
    //

    if (Characteristic < 0) {

        return(FD6DivL(Number, (LONG)Power10ExpNum[-Characteristic]));

    } else if (Characteristic > 0) {

        return(FD6xL(Number, (LONG)Power10ExpNum[Characteristic]));

    } else {

        return(Number);
    }
}





FD6
HTENTRY
RaisePower(
    FD6     BaseNumber,
    FD6     Exponent,
    WORD    Flags
    )

/*++

Routine Description:

    Calculate the power of the base number (BaseNumber^Power).


Arguments:

    BaseNumber  -   The decimal (FD6) number, this is a special format decimal
                    number FD6) it depends on the #define and may be floating
                    number or six (6) lower digits as number to the right of
                    the decimal points. that is 3 = 0.000003, 10000 = 0.010000,
                    1232321 = 1.232321 and so on.

    Exponent    -   The exponent number is nth number to raise power to, it
                    has same format as BaseNumber.

    Flags       -   One or more of the following flags may be specified

                    RPF_RADICAL

                        1: This is a radical expression, the Exponent is
                              equal to 1.0/Exponent that is,

                        0: This is a regular power expression.


                    RPF_INTEXP

                        1: The Exponent field is treated as long integer number
                           rather a FD6 number.

                        0: The Exponent field is a FD6 number


        Note:   When BaseNumber is a negative number.

                1) Expoonent has fraction = .0 (ie. Integer only)

                    The whole BaseNumber is treated as an whole number.

                              2.0                    3.0
                        (-0.6)    = 0.36   and (-0.6)    = -0.216

                2) Exponent has fraction portion.

                    The negative sign is treated as a symbol.

                            2.1        2.1
                        -0.6    = -(0.6   ) = -0.342072


                The ONLY exception is that if Exponent = 0.0, then it returned

                    1.0 - if BaseNumber != 0.0
                    0.0 - if BaseNumber == 0.0 <-- Error Condition


Return Value:

    Now no error value is returned, but it will clip to the FD6 defined limit
    if condition occured as following and in this sequence:


    1)  0.0     - If BaseNumber = 0.0,

                    No error returned if Exponent <= 0.0, this number should
                    is not a real number.

    2)  1.0     - If Exponent = 0.0.

    othewise    - the approximate number for the nth power is returnd as
                  a FD6 number.  The accuracy of the returned logarithm number
                  as minimum/maximum errors as

                    maximum error = +0.000005983
                    minimum error = -0.0000009018

Author:

    16-Jan-1991 Wed 14:03:58 created  -by-  Daniel Chou (danielc)

Revision History:

    26-Sep-1991 Thu 12:10:52 updated  -by-  Daniel Chou (danielc)

        Delete OneOverExponent (BOOL) parameter

        Rewrite for more accuracy up to six significant decimal digitis, and
        also make it durable to run under floating point package.


--*/

{
    BOOL    NegativeBase;
    FD6     PowerNumber;


    //
    // check if any illegal condition exists, and preprocess any necessary
    // data
    //

    if (Flags & RPF_INTEXP) {

        if (Exponent == 1L) {

            return(BaseNumber);
        }

    } else {

        if (Exponent == FD6_1) {

            return(BaseNumber);
        }

        if (!(Exponent % FD6_1)) {

            Exponent /= FD6_1;
            Flags |= RPF_INTEXP;
        }
    }

    if (NegativeBase = (BOOL)(BaseNumber <= FD6_0)) {

        if (!(BaseNumber = -BaseNumber)) {      // 0^-num, 0^0 are illegal!!
                                                // but return as 0.0 now
            return(FD6_0);
        }
    }

    if (!Exponent) {

        return((NegativeBase) ? -FD6_1 : FD6_1);
    }

    //
    //                  y
    // Calculating the x = N with logarithms by solving following formula:
    //
    //      Log(N) = y * Log(x)
    //      ...
    //
    //      N = AntiLog(y * Log(x))
    //
    //  For example:
    //
    //       y           -1.654321
    //      x  = 0.123456           using the above formula we have
    //      -----------------------
    //
    //      Log(N) = y * Log(x)
    //      N      = AntiLog(y * Log(x))
    //
    //  ==> N = AntiLog(-1.654321 * Log(0.123456))
    //  ==> N = AntiLog(-1.654321 * -0.908488)
    //  ==> N = AntiLog(1.502931)
    //  ==> N = 31.836917                       <=== apporoximate FD6 number
    //
    //
    // If base number is 10.0 then do nothing with the logarithm, since
    // Log(10.0) = 1.0
    //

    BaseNumber = (BaseNumber == FD6_10) ? FD6_1 : Log(BaseNumber);

    if (Flags & RPF_INTEXP) {

        //
        // For EVEN interger exponent, the result always positive
        //

        if (!((DWORD)Exponent & 0x01)) {

            NegativeBase = FALSE;
        }

        PowerNumber = AntiLog((Flags & RPF_RADICAL) ?
                                            FD6DivL(BaseNumber, Exponent) :
                                            FD6xL(BaseNumber, Exponent));

    } else {

        PowerNumber = AntiLog((Flags & RPF_RADICAL) ?
                                            DivFD6(BaseNumber, Exponent) :
                                            MulFD6(BaseNumber, Exponent));
    }

    return((NegativeBase) ? -PowerNumber : PowerNumber);
}




BOOL
HTENTRY
ComputeInverseMatrix3x3(
    PMATRIX3x3  pInMatrix,
    PMATRIX3x3  pOutMatrix
    )

/*++

Routine Description:
                                           -1
    This function calculate inverse (Matrix  ) of the input 3x3 matrix

Arguments:

    pInMatrix       - 3 x 3 matrix to be inversed

    pOutMatrix      - Inverse 3 x 3 matrix of the input 3 x 3 matrix.

Return Value:

    The returned value will be TRUE if sucessfully invert the input matrix and
    returned value will be FALSE if there is singular in the input matrix.

    If the returned value is FALSE then the output matrix is not completed.

Author:

    11-Oct-1991 Fri 14:19:59 created    -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    MATRIX3x3   InMatrix;
    MATRIX3x3   OutMatrix;
    FD6         Temp;
    BOOL        NoSigular = TRUE;
    INT         i;
    INT         j;
    INT         k;


    InMatrix = *pInMatrix;                      // do a local copy

    //
    // Clear all to zero and set diagnal to 1.0
    //

    ZeroMemory(&OutMatrix.m[0][0], sizeof(MATRIX3x3));
    OutMatrix.m[0][0] = OutMatrix.m[1][1] = OutMatrix.m[2][2] = FD6_1;

    //
    // Using gaussian elimination.
    //

    for (i = 0; i < 3; i++) {

        for (j = i + 1, k = i; j < 3; j++) {

            if (ABSFD6(InMatrix.m[j][i]) > ABSFD6(InMatrix.m[k][i])) {

                k = j;
            }
        }

        if (InMatrix.m[k][i]) {

            //
            // Now we need to do pivot, we will switch row 'i' and row 'k' if
            // they are not in order.
            //

            if (k != i) {

                for (j = 0; j < 3; j++) {

                    SWAPFD6( InMatrix.m[i][j],  InMatrix.m[k][j], Temp);
                    SWAPFD6(OutMatrix.m[i][j], OutMatrix.m[k][j], Temp);
                }
            }

            //
            // Normalize the row, make the diagonal (ie. Matrix[i][i]) to 1.0
            // that is
            //

            for (j = 0, Temp = InMatrix.m[i][i]; j < 3; j++) {

                InMatrix.m[i][j]  = DivFD6(InMatrix.m[i][j],  Temp);
                OutMatrix.m[i][j] = DivFD6(OutMatrix.m[i][j], Temp);
            }

            //
            // and, zero the non-diagonal items in this column (ie. column i).
            //

            for (j = 0; j < 3; j++) {

                if ((j != i) && (Temp = InMatrix.m[j][i])) {

                    for (k = 0; k < 3; k++) {

                        InMatrix.m[j][k]  -= MulFD6( InMatrix.m[i][k], Temp);
                        OutMatrix.m[j][k] -= MulFD6(OutMatrix.m[i][k], Temp);
                    }
                }
            }

        } else {

            NoSigular = FALSE;
        }
    }

    *pOutMatrix = OutMatrix;

    return(NoSigular);

}




VOID
HTENTRY
ConcatTwoMatrix3x3(
    PMATRIX3x3  pConcat,
    PMATRIX3x3  pMatrix,
    PMATRIX3x3  pOutMatrix
    )

/*++

Routine Description:

    This function concatenate 'pMatrix' to 'pConcat' and output the result in
    'pOutMatrix',  supposed you have

    pConcat = RGB->YIQ and pMatrix = YIQ->XYZ

    then pOutMatrix = RGB->XYZ


Arguments:

    pConcat     - Source matrix to be concat

    pMatrix     - Matrix to concatenate into pConcat

    pOutMatrix  - Concatenated 3 x 3 matrix.

Return Value:

    There is no return value.

Author:

    11-Oct-1991 Fri 14:19:59 created    -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    MATRIX3x3   Concat = *pConcat;
    MATRIX3x3   Matrix = *pMatrix;
    MATRIX3x3   OutMatrix;
    MULDIVPAIR  MDPairs[4];
    INT         i;
    INT         j;


    MAKE_MULDIV_INFO(MDPairs, 3, MULDIV_NO_DIVISOR);

    for (i = 0; i < 3; i++) {

        for (j = 0; j < 3; j++) {

            MAKE_MULDIV_PAIR(MDPairs, 1, Matrix.m[i][0], Concat.m[0][j]);
            MAKE_MULDIV_PAIR(MDPairs, 2, Matrix.m[i][1], Concat.m[1][j]);
            MAKE_MULDIV_PAIR(MDPairs, 3, Matrix.m[i][2], Concat.m[2][j]);

            OutMatrix.m[i][j] = MulDivFD6Pairs(MDPairs);
        }
    }

    DBGP_IF(DBGP_CONCAT_M,
            DBGP("== Concat two 3x3 matrixes ==");
            DBGP("[%s %s %s]   [%s %s %s]   [%s %s %s]"
                ARGFD6(Matrix.m[0][0],2,3)
                ARGFD6(Matrix.m[0][1],2,3)      ARGFD6(Matrix.m[0][2],2,3)
                ARGFD6(Concat.m[0][0],2,3)
                ARGFD6(Concat.m[0][1],2,3)      ARGFD6(Concat.m[0][2],2,3)
                ARGFD6(OutMatrix.m[0][0],2,3)
                ARGFD6(OutMatrix.m[0][1],2,3)   ARGFD6(OutMatrix.m[0][2],2,3));

            DBGP("[%s %s %s] x [%s %s %s] = [%s %s %s]"
                ARGFD6(Matrix.m[1][0],2,3)
                ARGFD6(Matrix.m[1][1],2,3)      ARGFD6(Matrix.m[1][2],2,3)
                ARGFD6(Concat.m[1][0],2,3)
                ARGFD6(Concat.m[1][1],2,3)      ARGFD6(Concat.m[1][2],2,3)
                ARGFD6(OutMatrix.m[1][0],2,3)
                ARGFD6(OutMatrix.m[1][1],2,3)   ARGFD6(OutMatrix.m[1][2],2,3));

            DBGP("[%s %s %s]   [%s %s %s]   [%s %s %s]"
                ARGFD6(Matrix.m[2][0],2,3)
                ARGFD6(Matrix.m[2][1],2,3)      ARGFD6(Matrix.m[2][2],2,3)
                ARGFD6(Concat.m[2][0],2,3)
                ARGFD6(Concat.m[2][1],2,3)      ARGFD6(Concat.m[2][2],2,3)
                ARGFD6(OutMatrix.m[2][0],2,3)
                ARGFD6(OutMatrix.m[2][1],2,3)   ARGFD6(OutMatrix.m[2][2],2,3));
    );


    *pOutMatrix = OutMatrix;
}


#ifndef HT_OK_GEN_80x86_CODES


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Following functions are compiled only if we cannot using 80x86 assembly  //
// equvalent codes                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define U32xU32_U64(uD1, uD2, QH, QL) {                                     \
                                                                            \
    DWORD x0, x1, x2, x3;                                                   \
                                                                            \
    (x0)=(DWORD)((uD1) & 0xFFFF) * (DWORD)((uD2) & 0xFFFF);                 \
    (x1)=(DWORD)((uD1) >>    16) * (DWORD)((uD2) & 0xFFFF);                 \
    (x2)=(DWORD)((uD1) & 0xFFFF) * (DWORD)((uD2) >>    16);                 \
    (QL)=(DWORD)((x0) >> 16) + ((x1) & 0xFFFF) + ((x2) & 0xFFFF);           \
    (x3)=((DWORD)((uD1)>>16) * (DWORD)((uD2)>>16)) + (DWORD)((QL)>>16);     \
    (QL)=(DWORD)((QL) << 16) | ((x0) & 0xFFFF);                             \
    (QH)=(DWORD)((x1) >> 16) + (DWORD)((x2) >> 16) + (x3);                  \
}

#define NEG_U64(QH, QL)                                                     \
        (DWORD)(QH)=(DWORD)~(DWORD)(QH); (DWORD)(QL)=(DWORD)~(DWORD)(QL);   \
	if (!(++((DWORD)(QL)))) { ++((DWORD)(QH)); }

#define U64AddU64(QH, QL, Q0H, Q0L)                                         \
	if (((DWORD)(QL)+=(DWORD)(Q0L))<(DWORD)(Q0L)) { ++((DWORD)(QH)); }  \
        (DWORD)(QH) += (DWORD)(Q0H)

#define U64AddU32(QH, QL, uD)                                               \
	if (((DWORD)(QL)+=(DWORD)(uD))<(DWORD)(uD)) { ++((DWORD)(QH)); }

#define U64DivFD6_1(xH, xL, uD) {                                           \
        DWORD   xT;                                                         \
	if (((DWORD)(xL)+=(DWORD)FD6_p5)<(DWORD)FD6_p5) { ++((DWORD)(xH)); }\
        (DWORD)(uD)=(DWORD)(((xT=(DWORD)((DWORD)(xH) << 12) |               \
                                 (DWORD)((DWORD)(xL) >> 20)) /              \
                             (DWORD)62500) << 16);                          \
        (DWORD)(uD)|=(DWORD)((DWORD)((DWORD)((xT % (DWORD)62500)<<16) |     \
                                     (DWORD)(((DWORD)(xL)>>4) & 0xffffL)) / \
                             (DWORD)62500);  }




FD6
HTENTRY
MulFD6(
    FD6 Multiplicand,
    FD6 Multiplier
    )

/*++

Routine Description:

    This function multiply two FD6 numbers.

Arguments:

    Multiplicand    - The Multiplicand in FD6 format.

    Multiplier      - The Multiplier in FD6 format.


Return Value:

    No error returned, the return value is the products of multiplicand and
    multiplier.


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   xH;
    DWORD   xL;
    DWORD   Result;
    BOOL    Sign;


    if (Sign = (BOOL)(Multiplicand <= 0L)) {

        if (!(Multiplicand = -Multiplicand)) {

            return(0L);                     // if one of them is '0' then...
        }
    }

    if (Multiplier <= 0L) {

        if (Multiplier = -Multiplier) {

            Sign = !Sign;

        } else {

            return(FD6_0);              // if one of them is '0' then...
        }
    }

    if (Multiplicand == FD6_1) {

        Result = Multiplier;

    } else if (Multiplier == FD6_1) {

        Result = Multiplicand;

    } else {

        U32xU32_U64(Multiplicand, Multiplier, xH, xL);
        U64DivFD6_1(xH, xL, Result);
    }

    return((Sign) ? -(FD6)Result : (FD6)Result);
}



DWORD
HTENTRY
U64DivU32RoundUp(
    DWORD   Dividend64H,
    DWORD   Dividend64L,
    DWORD   Divisor32
    )

/*++

Routine Description:

    This function divide a unsigned 64-bit number by a 32-bit unsigned number

Arguments:

    Dividend64H - High 32-bit of a 64-bit unsigned dividend number

    Dividend64L - Low 32-bit of a 64-bit unsigned dividend number

    Divisor32   - 32-bit unsigned divisor number. (must not zero);

Return Value:

    No error returned, the return value is the round up quotient of the
    Divndend/Divisor.

    if Dividend is equal to 0 then a 0 is returned,


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   xH;
    DWORD   xL;
    DWORD   xT;
    DWORD   xR;
    WORD    Correct;
    WORD    DvsrL;
    WORD    DvsrH;
    WORD    QH;
    WORD    QL;



    ASSERT(Divisor32 != 0L);


    if ((xL = Dividend64L + (Divisor32 >> 1)) < Dividend64L) {

        xH = ++Dividend64H;

    } else {

        xH = Dividend64H;
    }

    DvsrH = U16_H_U32(Divisor32);

    if ((DvsrL = U16_L_U32(Divisor32)) && (DvsrH)) {

        //
        // Both DvsrH/DvsrL are non-zero
        //

        xT = (DWORD)(QH = (WORD)(xH / (DWORD)DvsrH)) * (DWORD)DvsrL;
        xR = ((xH - ((DWORD)QH * (DWORD)DvsrH)) << 16) | (DWORD)U16_H_U32(xL);

        if ((LONG)xT < 0L) {

            //
            // The overrun just too high, let's reduce it so we can manage it
            // (we like it to have overrun less then 0x80000000L
            //

            QH -= (Correct = (WORD)((xT - xR) / Divisor32));
            xT -= (DWORD)Correct * Divisor32;
        }

        if ((LONG)(xR -= xT) < 0L) {

            --QH;

            if ((LONG)(xR += Divisor32) < 0L) {

                --QH;

                if ((LONG)(xR += Divisor32) < 0L) {

                    --QH;

                    if ((LONG)(xR += Divisor32) < 0L) {

                        --QH;

                        if ((LONG)(xR += Divisor32) < 0L) {

                            --QH;

                            if ((LONG)(xR += Divisor32) < 0L) {

                                --QH;

                                if ((LONG)(xR += Divisor32) < 0L) {

                                    DWORD   Rem;

                                    QH -= (WORD)(NEGDW(xR) / Divisor32);

                                    if (Rem = (DWORD)(NEGDW(xR) % Divisor32)) {

                                        --QH;
                                        xR = Divisor32 - Rem;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (U16_H_U32(xR) < DvsrH) {

            xT = (DWORD)(QL = (WORD)(xR / (DWORD)DvsrH)) * (DWORD)DvsrL;
            xR = ((xR - ((DWORD)QL * (DWORD)DvsrH)) << 16) | (xL & 0xffffL);

            if (xR < xT) {

                --QL;

                if ((xR += Divisor32) < xT) {

                    --QL;

                    if ((xR += Divisor32) < xT) {

                        --QL;

                        if ((xR += Divisor32) < xT) {

                            --QL;

                            if ((xR += Divisor32) < xT) {

                                QL -= Correct = (WORD)((xT -= xR)/Divisor32);

                                if (xT > (DWORD)Correct * Divisor32) {

                                    --QL;
                                }
                            }
                        }
                    }
                }
            }

        } else {

            xR = ((DWORD)DvsrL << 16) - ((xR << 16) | (xL & 0xffffL));
            QL = (WORD)(xR / Divisor32);

            if (xR > ((DWORD)QL * Divisor32)) {

                ++QL;
            }

            QL = -QL;
        }

    } else if (DvsrL) {

        QH = (WORD)((xH = (xH << 16) | (xL >> 16)) / (DWORD)DvsrL);
        QL = (WORD)((((xH % (DWORD)DvsrL) << 16) | (xL & 0xffffL)) /
                      (DWORD)DvsrL);

    } else {                                // DvsrL = 0

        QH = (WORD)(xH / (DWORD)DvsrH);
        QL = (WORD)((((xH % (DWORD)DvsrH) << 16) | (xL >> 16)) /
                      (DWORD)DvsrH);
    }

    return(((DWORD)QH << 16) | (DWORD)QL);

}




FD6
HTENTRY
DivFD6(
    FD6 Dividend,
    FD6 Divisor
    )

/*++

Routine Description:

    This function divide two FD6 numbers.

Arguments:

    Dividend    - The Dividend in FD6 format.

    Divisor     - The Divosr in FD6 format.

Return Value:

    No error returned, the return value is the round up quotient of the
    Divndend/Divisor.

    if Dividend is equal to 0 then a 0 is returned,
    if Divisor is equal to zero then Dividend is returned.


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   x0;
    DWORD   x1;
    DWORD   xH;
    DWORD   xL;
    BOOL    Sign;


    if (Sign = (BOOL)(Divisor <= FD6_0)) {

        if (!(Divisor = -Divisor)) {

            return((Dividend < 0) ? MAX_FD6 : MIN_FD6);
        }
    }

    if (Divisor == FD6_1) {

        return((Sign) ? -Dividend : Dividend);
    }

    if (Dividend <= 0L) {

        if (Dividend = -Dividend) {

            Sign = (BOOL)!Sign;

        } else {

            return(FD6_0);          // nothing to divide, so return 0
        }
    }

    if (Dividend == Divisor) {

        return((Sign) ? -FD6_1 : FD6_1);
    }

    x0 = (DWORD)U16_L_U32(Dividend) * (DWORD)62500;
    x1 = (DWORD)U16_H_U32(Dividend) * (DWORD)62500;

    xH = (DWORD)U16_H_U32(x1);

    if ((xL = x0 + (x1 << 16)) < x0) {

        ++xH;
    }

    xH = (xH << 4) | (DWORD)(U16_H_U32(xL) >> 12);
    xL <<= 4;

    if (Sign) {

        return(-(FD6)U64DivU32RoundUp(xH, xL, Divisor));

    } else {

        return((FD6)U64DivU32RoundUp(xH, xL, Divisor));
    }
}



FD6
HTENTRY
FD6DivL(
    FD6     Dividend,
    LONG    Divisor
    )

/*++

Routine Description:

    This function divide a FD6 number by a LONG integer.

Arguments:

    Dividend    - The Dividend in FD6 format.

    Divisor     - The Divosr in long format.

Return Value:

    No error returned, the return value is the round up quotient of the
    Divndend/Divisor.

    if Dividend is equal to 0 then a 0 is returned,
    if Divisor is equal to zero then Dividend is returned.


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   Quot;
    BOOL    Sign;


    if (Sign = (BOOL)(Divisor <= 0L)) {

        if (!(Divisor = -Divisor)) {

            return(Dividend);           // can not divide by 0, return as 1
        }
    }

    if (Dividend <= 0L) {

        if (Dividend = -Dividend) {

            Sign = (BOOL)!Sign;

        } else {

            return(FD6_0);          // nothing to divide, so return 0
        }
    }

    Quot = ((DWORD)Dividend + (DWORD)((DWORD)Divisor >> 1)) / (DWORD)Divisor;

    return((Sign) ? -(FD6)Quot : (FD6)Quot);
}



FD6
HTENTRY
MulDivFD6Pairs(
    PMULDIVPAIR pMulDivPair
    )

/*++

Routine Description:

    This function multiply TotalFD6Pairs of FD6 numbers and optional divide by
    passed divisor.

Arguments:

    pMulDivPair - Pointer to array of MULDIVPAIR data structure, the first
                  structure in the array tell the count of the FD6 pairs,
                  a Divisor present flag and a Divisor, the FD6 pairs start
                  from second element in the array.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero then it assume no divisor is present,
    if Count of FD6 pairs is zero then it return FD6_0

Author:

    27-Aug-1992 Thu 18:13:55 updated  -by-  Daniel Chou (danielc)
        Re-write to remove variable argument conflict, and make it only passed
        a pointer to the MULDIVPAIR structure array

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    FD6     Multiplicand;
    FD6     Multiplier;
    FD6     Divisor;
    DWORD   xH;
    DWORD   xL;
    DWORD   xPH;
    DWORD   xPL;
    DWORD   Result;
    BOOL    Sign;
    INT     cFD6Pairs;


    if (!(cFD6Pairs = (INT)pMulDivPair->Pair1.Info.Size)) {

        return(FD6_0);
    }

    Divisor = FD6_0;

    if (pMulDivPair->Pair1.Info.Flag & MULDIV_HAS_DIVISOR) {

        if ((Divisor = pMulDivPair->Pair2) == FD6_1) {

            Divisor = FD6_0;
        }
    }

    xH = xL = (DWORD)0;

    while (cFD6Pairs--) {

        ++pMulDivPair;

        Multiplicand = pMulDivPair->Pair1.Mul;
        Multiplier   = pMulDivPair->Pair2;

        if (Sign = (BOOL)(Multiplicand <= 0L)) {

            if (!(Multiplicand = -Multiplicand)) {

                continue;           // this one will be zero, check next pair
            }
        }

        if (Multiplier <= 0L) {

            if (Multiplier = -Multiplier) {

                Sign = (BOOL)!Sign;

            } else {

                continue;           // this one will be zero, check next pair
            }
        }

        U32xU32_U64(Multiplicand, Multiplier, xPH, xPL);

        if (Sign) {

            NEG_U64(xPH, xPL);
        }

        U64AddU64(xH, xL, xPH, xPL);

    }

    if (Sign = (BOOL)((LONG)xH < 0)) {

        NEG_U64(xH, xL);
    }

    if (Divisor) {

        if (Divisor < FD6_0) {

            Divisor = -Divisor;
            Sign    = !Sign;
        }

        Result = U64DivU32RoundUp(xH, xL, (DWORD)Divisor);

    } else {

        //
        // No Divisor, so just divide it by FD6_1
        //

        U64DivFD6_1(xH, xL, Result);
    }

    return((Sign) ? -(FD6)Result : (FD6)Result);
}



FD6
HTENTRY
FractionToMantissa(
    FD6     Fraction,
    DWORD   CorrectData
    )

/*++

Routine Description:

    This function take decimal fraction and correct the logarithm mantissa
    between x.xxyyyy x.xxzzzz, where fraction is laid between yyyy to zzzz.

Arguments:

    Fraction        - the fraction number after decimal place, because
                      we have mantissa table up to two decimal places, the
                      correction is necessary because logarithm numbers are
                      no linear.  The number is range from 0.000000-0.999999

    CorrectData     - The correction data which from MantissaCorrectData[]

Return Value:

    No error returned, the return value is the Mantissa value for the fraction
    passed in.


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    DWORD   Mantissa;
    DWORD   Rem;
    INT     Loop;
    WORD    Base;
    WORD    Error;
    WORD    NextErr;
    WORD    CorrL;
    WORD    CorrH;


    //
    // Mantissa Correction Data Bits Usage:
    //
    //
    //       <---High Word---> <----Low Word--->
    //  Bit#  3          2          1          0
    //       10987654 32109876 54321098 76543210
    //       | | | |  | |  |   ||  |  |
    //       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    //       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    //       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    //       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    //       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    //       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    //       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    //       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    //       | | +----------------------- x.005-x.006 (0-3) Correct 7
    //       | +------------------------- x.004-x.005 (0-3) Correct 8
    //       +--------------------------- x.003-x.004 (0-3) Correct 9
    //

    CorrL = U16_L_U32(CorrectData);
    CorrH = U16_H_U32(CorrectData);
    Rem   = (DWORD)(Fraction % 100000L);
    Loop  = (INT)(Fraction / 100000L);
    Base  = (WORD)(CorrL & 0x1ff);
    Error = 0;

    NextErr = (WORD)(Base + ((CorrL >>= 9) & 0x07));

    if (Loop--) {

        Error   += NextErr;

        //
        // bit 6, 0x40 = correct 10
        //

        NextErr  = (WORD)(Base + ((CorrL >> 3) & 0x07));

        if (Loop--) {

            Error   += NextErr;
            NextErr  = (WORD)(Base + (CorrH & 0x07));

            if (Loop--) {

                Error   += NextErr;
                NextErr  = (WORD)(Base + ((CorrH >>= 3) & 0x07));

                if (CorrL & 0x40) {

                    CorrH |= 0x2000;        // add in correction 10
                }

                CorrH >>= 1;                // pre-shift for next while

                while (Loop--) {

                    Error += NextErr;
                    NextErr = (WORD)(Base + ((CorrH >>= 2) & 0x03));
                }
            }
        }
    }

    Mantissa = (DWORD)Error +
               ((((Rem * (DWORD)NextErr) >> 1) + 25000L) / 50000L);

    return(FD6FromL(Mantissa));
}




FD6
HTENTRY
MantissaToFraction(
    FD6     Mantissa,
    DWORD   CorrectData
    )

/*++

Routine Description:

    This function take mantissa number and convert it to the decimal fraction

Arguments:

    Mantissa        - the mantissa values which will converted to the the
                      fraction number.

    CorrectData     - The correction data which from MantissaCorrectData[]

Return Value:

    No error returned, the return value is the fraction value for the mantissa
    passed in, it range from 0.000000 - 1.000000


Author:

    10-Oct-1991 Thu 11:14:24 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    static  DWORD   ul100000To900000[] = { 100000L, 200000L, 300000L, 400000L,
                                           500000L, 600000L, 700000L, 800000L,
                                           900000L
                                         };
    DWORD   Fraction;
    SHORT   Index;
    SHORT   Base;
    SHORT   Error;
    SHORT   NextErr;
    WORD    CorrL;
    WORD    CorrH;

    //
    // Mantissa Correction Data Bits Usage:
    //
    //
    //       <---High Word---> <----Low Word--->
    //  Bit#  3          2          1          0
    //       10987654 32109876 54321098 76543210
    //       | | | |  | |  |   ||  |  |
    //       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    //       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    //       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    //       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    //       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    //       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    //       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    //       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    //       | | +----------------------- x.005-x.006 (0-3) Correct 7
    //       | +------------------------- x.004-x.005 (0-3) Correct 8
    //       +--------------------------- x.003-x.004 (0-3) Correct 9
    //

    Error    = (SHORT)FD6ToL(Mantissa);         // only need 16 bits
    CorrL    = U16_L_U32(CorrectData);
    CorrH    = U16_H_U32(CorrectData);
    Base     = (SHORT)(CorrL & 0x1ff);
    Fraction = 0L;

    Index = 1;                                  // assume 1
    NextErr = (WORD)(Base + ((CorrL >>= 9) & 0x07));

    if ((Error -= NextErr) > 0) {

        ++Index;

        //
        // bit 6, 0x40 = correct 10
        //

        NextErr = (WORD)(Base + ((CorrL >> 3) & 0x07));

        if ((Error -= NextErr) > 0) {

            ++Index;
            NextErr = (WORD)(Base + (CorrH & 0x07));

            if ((Error -= NextErr) > 0) {

                ++Index;
                NextErr = (WORD)(Base + ((CorrH >>= 3) & 0x07));

                if (CorrL & 0x40) {

                    CorrH |= 0x2000;        // add in correction 10
                }

                CorrH >>= 1;                // pre-shift for next while

                while ((Error -= NextErr) > 0) {

                    ++Index;
                    NextErr = (WORD)(Base + ((CorrH >>= 2) & 0x03));
                }
            }
        }
    }

    if (Error) {

        --Index;
        Fraction = (((((DWORD)(Error + NextErr) * 50000L) << 1) +
                    (DWORD)(NextErr >> 1)) / (DWORD)NextErr);
    }

    if (Index--) {

        Fraction += ul100000To900000[Index];
    }

    return(FD6FromL(Fraction));
}




DWORD
HTENTRY
ComputeChecksum(
    LPBYTE  pData,
    DWORD   InitialChecksum,
    DWORD   DataSize
    )

/*++

Routine Description:

    This function compute a 32-bit check sum for the pData passed in

Arguments:

    pData           - Pointer to data which checksum to be computed

    InitChecksum    - Initial checksum value, this value can be a checksum
                      value from last computed result, so it can generate a
                      single checksum from a large linked data.

    DataSize        - pData size in bytes


    The Checksum is forming by two 16-bit checksum octets R,S and n is the
    octet number, the addition is performed in one's complement arithmic.

    S(n)     = S(n-1) + Data(n)
    R(n)     = R(n-1) + S(n)

    Checksum = (DWORD)(R << 16) | (DWORDS;


Return Value:

    return value is a 32-bit checksum


Author:

    27-Apr-1992 Mon 18:36:03 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    W2B     w2b;
    WORD    OctetR;
    WORD    OctetS;


    //
    // We using two 16-bit checksum octets with one's complement arithmic
    //

    //
    // 1. Get initial values for OctetR and OctetS
    //

    OctetR = HIWORD(InitialChecksum);
    OctetS = LOWORD(InitialChecksum);

    //
    // 2. Since we doing 16-bit at a time, we will pack high byte with zero
    //    if data size in bytes is odd number
    //

    if (DataSize & 0x01) {

        OctetR += (OctetS += (WORD)*pData++);
    }

    //
    // 3. Now forming checksum 16-bit at a time
    //

    DataSize >>= 1;

    while (DataSize--) {

        w2b.b[0] = *pData++;
        w2b.b[1] = *pData++;

        OctetR += (OctetS += w2b.w);
    }

    return((DWORD)((DWORD)OctetR << 16) | (DWORD)OctetS);
}



#endif  // HT_OK_GEN_80x86_CODES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htmemory.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmemory.h


Abstract:

    This module contains some local definitions for the htmemory.c


Author:

    18-Jan-1991 Fri 17:05:22 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]

    This module may be need to modify when compile with different operating
    environment, such as Windows 3.1

Revision History:


--*/

#ifndef _HTMEMORY_
#define _HTMEMORY_

#define HTMEM_BEGIN                 (DWORD)'00TH'
#define HTMEM_CurCDCIData           (DWORD)'10TH'
#define HTMEM_CurCSMPData           (DWORD)'20TH'
#define HTMEM_CurCSMPBmp            (DWORD)'30TH'
#define HTMEM_pHTPat                (DWORD)'01TH'
#define HTMEM_HT_DHI                (DWORD)'04TH'
#define HTMEM_GetCacheThreshold     (DWORD)'14TH'
#define HTMEM_CacheCRTX             (DWORD)'24TH'
#define HTMEM_pThresholds           (DWORD)'34TH'
#define HTMEM_DyeMappingTable       (DWORD)'44TH'
#define HTMEM_AlphaBlendBGR         (DWORD)'54TH'
#define HTMEM_DevClrAdj             (DWORD)'05TH'
#define HTMEM_RGBToXYZ              (DWORD)'15TH'
#define HTMEM_pSCData               (DWORD)'25TH'
#define HTMEM_BLTAA                 (DWORD)'35TH'
#define HTMEM_EXPAA                 (DWORD)'45TH'
#define HTMEM_SRKAA                 (DWORD)'55TH'
#define HTMEM_EXPREP                (DWORD)'65TH'
#define HTMEM_SRKREP                (DWORD)'75TH'
#define HTMEM_FIXUPDIB              (DWORD)'85TH'
#define HTMEM_BGRMC_CACHE           (DWORD)'06TH'
#define HTMEM_BGRMC_MAP             (DWORD)'16TH'

//
// Checking the memory alignment size
//

#define CB_MEM_ALIGN    sizeof(UINT_PTR)
#define _ALIGN_MEM(x)   (((x) + (CB_MEM_ALIGN) - 1) & ~((CB_MEM_ALIGN) - 1))

#if DBG
    #if SHOW_MEM_ALIGN

        #define ALIGN_MEM(v, x)                                             \
        {                                                                   \
            DBGP("ALIGN_MEM(%6ld, %2ld): %6ld [+%2ld]"                      \
                    ARGDW(x) ARGDW(CB_MEM_ALIGN)  ARGDW(_ALIGN_MEM(x))      \
                    ARGDW(_ALIGN_MEM(x) - (x)));                            \
            (v) = _ALIGN_MEM(x);                                            \
        }

    #else
        #define ALIGN_MEM(v, x)     (v) = _ALIGN_MEM(x)
    #endif
#else
    #define ALIGN_MEM(v, x)     (v) = _ALIGN_MEM(x)
#endif


#define ALIGN_BPP(cx, bbp)      (((((DWORD)(cx)*(DWORD)(bbp))+31L)&~31L)>>3)
#define ASSERT_MEM_ALIGN(x, c)  ASSERT(((UINT_PTR)(x) & (UINT_PTR)((c)-1))==0)


#if DBG

    #ifdef UMODE
        #define DBG_MEMORY_TRACKING     1
    #else
        #define DBG_MEMORY_TRACKING     1
    #endif

#else
    #define DBG_MEMORY_TRACKING         0
#endif


//
// Function Prototype
//

BOOL
HTENTRY
CompareMemory(
    LPBYTE  pMem1,
    LPBYTE  pMem2,
    DWORD   Size
    );


#if DBG_MEMORY_TRACKING


LPVOID
HTFreeMem(
    LPVOID  pMem
    );

LPVOID
HTAllocMem(
    LPVOID  pDCI,
    DWORD   Tag,
    DWORD   Flags,
    DWORD   cb
    );

VOID
DumpMemLink(
    LPVOID  pInfo,
    DWORD   Tag
    );

#define CHK_MEM_LEAK(p,t)           DumpMemLink(p, t)

#else

    #ifdef UMODE
        #define HTAllocMem(p,t,f,c) LocalAlloc(f,c)
        #define HTFreeMem(p)        LocalFree((HLOCAL)(p))
    #else
        #define HTAllocMem(p,t,f,c) EngAllocMem((f==LPTR) ? FL_ZERO_MEMORY :\
                                                            0, (c), (t))
        #define HTFreeMem(p)        (EngFreeMem(p),NULL)
    #endif

#define CHK_MEM_LEAK(p,t)

#endif  // DBG_MEMORY_TRACKING


#endif  // _HTMEMORY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htmemory.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmemory.c


Abstract:

    This module supports the memory allocation functions for the halftone
    process, these functions are provided so that it will compatible with
    window's LocalAlloc/LocalFree memory allocation APIs.


Author:

    18-Jan-1991 Fri 17:02:42 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]

    The memory allocation may be need to change depends on the operating
    system used, currently it is conform to the NT and WIN32, the memory
    address simply treated as flat 32-bit location.

Revision History:


--*/


#define DBGP_VARNAME        dbgpHTMemory


#include "htp.h"
#include "htmapclr.h"



#define DBGP_ALLOC              0x00000001
#define DBGP_SHOWMEMLINK        0x00000002


DEF_DBGPVAR(BIT_IF(DBGP_ALLOC,              0)  |
            BIT_IF(DBGP_SHOWMEMLINK,        0))


#if DBG_MEMORY_TRACKING

#define MEM_TRACK_ID    (DWORD)'HTMT'


typedef struct _MEMLINK {
    DWORD               ID;
    PDEVICECOLORINFO    pDCI;
    LPVOID              pMem;
    DW2W4B              Tag;
    LONG                cb;
    struct _MEMLINK *pNext;
    } MEMLINK, *PMEMLINK;


static DWORD    cbTotAlloc = 0;
static PMEMLINK pMHGlobal = NULL;

LONG        cbMemTot = 0;
LONG        cbMemMax = 0;

#define TAG2DW(t)           ((((t) >> 24) & 0xFF) | (((t) >> 8) & 0xFF00))



VOID
DumpMemLink(
    LPVOID  pInfo,
    DWORD   Tag
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Feb-1999 Wed 20:43:39 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEVICECOLORINFO    pDCI = (PDEVICECOLORINFO)pInfo;
    PMEMLINK            pML;
    BOOL                HasShow = FALSE;


    if (pML = (pDCI) ? pDCI->pMemLink : pMHGlobal) {

        DWORD   dwDbg = DBGP_VARNAME;
        UINT    i = 0;
        LONG    cb = 0;


        if ((Tag) && (Tag != 0xFFFFFFFF)) {

            Tag = TAG2DW(Tag);
        }

        do {

            BOOL    ShouldFree;

            ++i;
            DBGP_VARNAME = dwDbg;

            if (Tag == 0xFFFFFFFF) {

                ShouldFree = FALSE;

            } else if (!Tag) {

                ShouldFree = FALSE;
                DBGP_VARNAME |= DBGP_SHOWMEMLINK;

            } else {

                ShouldFree = (BOOL)(TAG2DW(pML->Tag.dw) >= Tag);

                if (ShouldFree) {

                    DBGP_VARNAME |= DBGP_SHOWMEMLINK;

                } else {

                    DBGP_VARNAME &= ~DBGP_SHOWMEMLINK;
                }
            }

            if ((DBGP_VARNAME & DBGP_SHOWMEMLINK) && (!HasShow)) {

                DBGP_IF(DBGP_SHOWMEMLINK,
                        DBGP("------BEGIN-- cbMemTot=%ld, cbMemMax=%ld----------------"
                            ARGDW((pDCI) ? pDCI->cbMemTot : cbMemTot)
                            ARGDW((pDCI) ? pDCI->cbMemMax : cbMemMax)));

                HasShow = TRUE;
            }

            DBGP_IF(DBGP_SHOWMEMLINK,
                    DBGP("%hsMemLink(%3ld): pDCI=%p, Tag=%c%c%c%c, pMem=%p, cb=%7ld [%7ld]"
                        ARGPTR((ShouldFree) ? "\n*Memory Not Free*\n" : "")
                        ARGDW(i) ARGPTR(pML->pDCI)
                        ARGDW(pML->Tag.b[0])
                        ARGDW(pML->Tag.b[1])
                        ARGDW(pML->Tag.b[2])
                        ARGDW(pML->Tag.b[3])
                        ARGPTR(pML->pMem) ARGDW(pML->cb)
                        ARGDW(cb += pML->cb)));

        } while (pML = pML->pNext);

        if (HasShow) {

            DBGP_IF(DBGP_SHOWMEMLINK,
                    DBGP("------END---------------------------------------\n"));
        }

        DBGP_VARNAME = dwDbg;
    }
}



LPVOID
HTAllocMem(
    LPVOID  pInfo,
    DWORD   Tag,
    DWORD   Flags,
    DWORD   cb
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Feb-1999 Wed 20:16:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEVICECOLORINFO    pDCI = (PDEVICECOLORINFO)pInfo;
    LPBYTE              pb;
    PMEMLINK            pML;
    PMEMLINK            pMH;
    PMEMLINK            *ppMH;
    PLONG               pTot;
    PLONG               pMax;
    DWORD               cbTot;




#ifdef UMODE
    pb = LocalAlloc(Flags, cb + sizeof(MEMLINK));
#else
    pb = EngAllocMem((Flags == LPTR) ? FL_ZERO_MEMORY : 0,
                     cb + sizeof(MEMLINK) ,
                     Tag);

#endif
    if (pDCI) {

        ppMH = &((PMEMLINK)pDCI->pMemLink);
        pTot = &(pDCI->cbMemTot);
        pMax = &(pDCI->cbMemMax);

    } else if (Tag == HTMEM_HT_DHI) {

        pMH  = NULL;
        ppMH = &pMH;

    } else {

        ppMH = &pMHGlobal;
        pTot = &cbMemTot;
        pMax = &cbMemMax;
    }

    if (pb) {

        if (!(pML = *ppMH)) {

            pML   =
            *ppMH = (PMEMLINK)pb;

        } else {

            while (pML->pNext) {

                pML = pML->pNext;
            }

            pML->pNext = (PMEMLINK)pb;
            pML        = pML->pNext;
        }

        pb += sizeof(MEMLINK);

        if ((!pDCI) && (Tag == HTMEM_HT_DHI)) {

            pDCI           = &(((PHT_DHI)pb)->DCI);
            pDCI->pMemLink = *ppMH;
            pDCI->cbMemTot =
            pDCI->cbMemMax = (LONG)cb;
            pMax           = &pDCI->cbMemMax;
            pTot           = &pDCI->cbMemTot;

        } else {

            if ((*pTot += (LONG)cb) > *pMax) {

                *pMax = *pTot;
            }
        }

        pML->ID      = MEM_TRACK_ID;
        pML->pDCI    = pDCI;
        pML->pMem    = pb;
        pML->cb      = (LONG)cb;
        pML->Tag.dw  = Tag;
        pML->pNext   = NULL;

        DBGP_IF(DBGP_ALLOC,
                DBGP("%p=MemoryAlloc(pDCI=%p [%c%c%c%c] %7ld bytes): Tot=%7ld, Max=%7ld"
                    ARGPTR(pb) ARGPTR(pDCI)
                    ARGDW(pML->Tag.b[0]) ARGDW(pML->Tag.b[1])
                    ARGDW(pML->Tag.b[2]) ARGDW(pML->Tag.b[3])
                    ARGDW(cb) ARGDW(*pTot) ARGDW(*pMax)));

        DumpMemLink(pDCI, 0xFFFFFFFF);

    } else {

        DW2W4B  dw4b;

        dw4b.dw = Tag;

        DBGP("*NO MEMORY* Allocate %ld bytes of Tag=%c%c%c%c FAILED"
                ARGDW(cb)
                ARGDW(dw4b.b[0]) ARGDW(dw4b.b[1])
                ARGDW(dw4b.b[2]) ARGDW(dw4b.b[3]));

        DumpMemLink(pDCI, 0);
    }

    return((LPVOID)pb);
}




LPVOID
HTFreeMem(
    LPVOID  pMem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Feb-1999 Wed 20:24:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEVICECOLORINFO    pDCI;
    PLONG               pTot;
    PLONG               pMax;
    PMEMLINK            *ppMH;
    PMEMLINK            pML;
    PMEMLINK            pMP;
    UINT                Found = 0;
    LPVOID              pv;


    if ((pMem)                                              &&
        (pML = (PMEMLINK)((LPBYTE)pMem - sizeof(MEMLINK)))  &&
        (pML->ID == MEM_TRACK_ID)) {

        if (pDCI = pML->pDCI) {

            ppMH = &((PMEMLINK)(pDCI->pMemLink));
            pTot = &pDCI->cbMemTot;
            pMax = &pDCI->cbMemMax;

        } else {

            ppMH = &pMHGlobal;
            pTot = &cbMemTot;
            pMax = &cbMemMax;
        }

    } else {

        DBGP("Error: FreeMemeory(%p) Invalid Memory Address" ARGPTR(pMem));

        return(NULL);
    }

    if ((ppMH) && (pML = pMP = *ppMH)) {

        while ((!Found) && (pML)) {

            if (pML->pMem == pMem) {

                //
                // Find it, take it out from link
                //

                if (pML == *ppMH) {

                    ASSERT(*ppMH == pMP);

                    *ppMH = pML->pNext;
                    Found = 2;

                } else {

                    pMP->pNext = pML->pNext;
                    Found      = 1;
                }

            } else {

                pMP = pML;
                pML = pML->pNext;
            }
        }
    }

    if (!Found) {

        DBGP("Error: FreeMemeory(%p) without Allocating it" ARGPTR(pMem));

        DumpMemLink(pDCI, 0);

    } else {

        (LPBYTE)pMem -= sizeof(MEMLINK);

        if ((*pTot -= pML->cb) < 0) {

            DBGP("Error: FreeMemeory(%p) Free too much memory=%ld"
                    ARGPTR(pMem) ARGDW(*pTot));

            DumpMemLink(pDCI, 0);
        }

        if ((pML->Tag.dw == HTMEM_HT_DHI)       ||
            (pML->Tag.dw == HTMEM_DevClrAdj)    ||
            (*ppMH == NULL)) {

            DumpMemLink(pDCI, pML->Tag.dw);
        }

        DBGP_IF(DBGP_ALLOC,
                DBGP("*%p=MemoryFree(pDCI=%p [%c%c%c%c] %7ld bytes): Tot=%7ld, Max=%7ld"
                    ARGPTR(pML->pMem) ARGPTR(pDCI)
                    ARGDW(pML->Tag.b[0]) ARGDW(pML->Tag.b[1])
                    ARGDW(pML->Tag.b[2]) ARGDW(pML->Tag.b[3])
                    ARGDW(pML->cb) ARGDW(*pTot) ARGDW(*pMax)));

        DumpMemLink(pDCI, 0xFFFFFFFF);

#ifdef UMODE
        pv = (LPVOID)LocalFree((HLOCAL)pMem);
#else
        EngFreeMem(pMem);
        pv = NULL;
#endif
    }

    return((LPVOID)pv);
}


#endif



BOOL
HTENTRY
CompareMemory(
    LPBYTE  pMem1,
    LPBYTE  pMem2,
    DWORD   Size
    )

/*++

Routine Description:

    This is our version of memcmp


Arguments:

    pMem1   - Pointer to the first set of memory to be compared

    pMem2   - Pointer to the second set of memory to be compared

    Size    - Size of pMem1 and pMem2 point


Return Value:

    TRUE if memory is the same, FALSE otherwise

Author:

    13-Mar-1995 Mon 12:07:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    while (Size--) {

        if (*pMem1++ != *pMem2++) {

            return(FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htp.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htp.h


Abstract:

    This module contains all the private data structures, constant used
    by this DLL


Author:

    15-Jan-1991 Tue 21:26:24 created  -by-  Daniel Chou (danielc)

[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:
    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        changed 'CHAR' type to 'SHORT' type, this will make sure if compiled
        under MIPS the default 'unsigned char' will not affect the signed
        operation.

    20-Sep-1991 Fri 19:27:49 updated  -by-  Daniel Chou (danielc)

        Delete #define SRCRGBF_PERCENT_SCREEN_IN_BLUE which will be processes
        at API call level (htapi.c)

    12-Dec-1991 Thu 20:44:05 updated  -by-  Daniel Chou (danielc)

        Move all color adjustments relative things to htmapclr.h

--*/


#ifndef _HTP_
#define _HTP_

#include <stddef.h>
#include <stdarg.h>

#include "windef.h"
#include "wingdi.h"
#include "winbase.h"
#include "winddi.h"

#include "ht.h"

#define HALFTONE_DLL_ID     (DWORD)0x54484344L          // "DCHT"
#define HTENTRY             NEAR                        // local functions

typedef unsigned long       ULDECI4;

#ifndef UMODE

#define qsort   EngSort

#endif  // UMODE


//
// Followings are the internal error IDs, this internal error number are
// all negative number and started at HTERR_INTERNAL_ERRORS_START
//

#define INTERR_STRETCH_FACTOR_TOO_BIG       HTERR_INTERNAL_ERRORS_START
#define INTERR_XSTRETCH_FACTOR_TOO_BIG      HTERR_INTERNAL_ERRORS_START-1
#define INTERR_STRETCH_NEG_OVERHANG         HTERR_INTERNAL_ERRORS_START-2
#define INTERR_COLORSPACE_NOT_MATCH         HTERR_INTERNAL_ERRORS_START-3
#define INTERR_INVALID_SRCRGB_SIZE          HTERR_INTERNAL_ERRORS_START-4
#define INTERR_INVALID_DEVRGB_SIZE          HTERR_INTERNAL_ERRORS_START-5



#if defined(_OS2_) || defined(_OS_20_) || defined(_DOS_)
#define HT_LOADDS   _loadds
#else
#define HT_LOADDS
#endif

#define DIVRUNUP(a, b)      (((a) + ((b) >> 1)) / (b))
#define SWAP(a, b, t)       { (t)=(a); (a)=(b); (b)=(t); }


typedef LPBYTE FAR          *PLPBYTE;


#include "htdebug.h"
#include "htmemory.h"

#define BMF_8BPP_MONO       (BMF_HT_LAST - 1)
#define BMF_8BPP_B332       (BMF_HT_LAST - 2)
#define BMF_8BPP_L555       (BMF_HT_LAST - 3)
#define BMF_8BPP_L666       (BMF_HT_LAST - 4)
#define BMF_8BPP_K_B332     (BMF_HT_LAST - 5)
#define BMF_8BPP_K_L555     (BMF_HT_LAST - 6)
#define BMF_8BPP_K_L666     (BMF_HT_LAST - 7)


#define COLOR_SWAP_23       0x01
#define COLOR_SWAP_12       0x02
#define COLOR_SWAP_13       0x04

typedef struct _RGB4B {
    BYTE    b;
    BYTE    g;
    BYTE    r;
    BYTE    a;
    } RGB4B, *PRGB4B;

typedef struct _BGR3 {
    BYTE    b;
    BYTE    g;
    BYTE    r;
    } BGR3, *PBGR3;

typedef struct _BGR8 {
    BYTE    b;
    BYTE    g;
    BYTE    r;
    } BGR8, *PBGR8;

typedef struct _GRAYF {
    WORD    Gray;
    BYTE    bReserved;
    BYTE    f;
    } GRAYF, *PGRAYF;

typedef struct _BGRF {
    BYTE    b;
    BYTE    g;
    BYTE    r;
    BYTE    f;
} BGRF, *PBGRF;

typedef struct _RGBL {
    LONG    r;
    LONG    g;
    LONG    b;
    } RGBL, *PRGBL;


typedef union _W2B {
    WORD    w;
    BYTE    b[2];
    } W2B, *PW2B;

typedef union _DW2W4B {
    DWORD   dw;
    WORD    w[2];
    BYTE    b[4];
    } DW2W4B, *PDW2W4B;

typedef union _TW6B {
    WORD    w[3];
    BYTE    b[6];
    } TW6B, *PTW6B;

typedef union _QW8B {
    DWORDLONG   qw;
    DWORD       dw[2];
    WORD        w[4];
    BYTE        b[8];
    } QW8B, *PQW8B;



/////////////////////////////////////////////////////////////////////////////

#ifndef i8086
#define i8086   0
#endif

#ifndef i286
#define i286    0
#endif

#ifndef i386
#define i386    0
#endif

#if defined(_OS2_)      ||  /* OS/2 PM 1.x  */  \
    defined(_OS2_20_)   ||  /* OS/2 PM 2.x  */  \
    defined(_DOS_)      ||  /* DOS Win3     */  \
    (i8086 > 0)         ||                      \
    (i286 > 0)          ||                      \
    (i386 > 0)

#define Compile80x86Mode

#ifdef  HAS_80x86_EQUIVALENT_CODES

#ifndef NO_ASM
#define HT_OK_GEN_80x86_CODES
#pragma message("                            <--- *** Using 80x86 assembly equivalent codes.")

#else   // otherwise using C codes

#pragma message("                            <--- *** Compile C codes.")

#endif  // NO_ASM
#endif  // HAS_80x86_EQUIVALENT_CODES

#endif  // 80x86 cpu

/////////////////////////////////////////////////////////////////////////////


#endif  // _HTP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htpat.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htpat.c


Abstract:

    This module contains all the functions which generate the halftone
    patterns (brushs) to be used for later halftone process.


Author:
    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        changed 'CHAR' type to 'BYTE' type, this will make sure if compiled
        under MIPS the default 'unsigned char' will not affect the signed
        operation on the single 8 bits


    15-Jan-1991 Tue 21:09:33 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    Change DrawPatLine() function to DrawCornerLine(), and speed up the
    process by only using integer operation for modified DDA.


--*/


#define DBGP_VARNAME        dbgpHTPat

#include "htp.h"
#include "htmath.h"
#include "htmapclr.h"
#include "htrender.h"
#include "htpat.h"
#include "stdio.h"


#ifdef UMODE
#include <search.h>
#endif


#define DBGP_DRAWLINE           0x00000001
#define DBGP_SHOW_HTCELL        0x00000002
#define DBGP_CACHE_PAT          0x00000004
#define DBGP_GEN_PAT            0x00000008

DEF_DBGPVAR(BIT_IF(DBGP_DRAWLINE,       0)  |
            BIT_IF(DBGP_SHOW_HTCELL,    0)  |
            BIT_IF(DBGP_CACHE_PAT,      0)  |
            BIT_IF(DBGP_GEN_PAT,        0))


#define HTSC_M_CX           91
#define HTSC_M_CY           91
#define HTSC_M_COUNT        (HTSC_M_CX * HTSC_M_CY)
#define HTSC_M_OFFSET_M     (HTSC_M_COUNT * 0)
#define HTSC_M_OFFSET_C     (HTSC_M_COUNT * 1)
#define HTSC_M_OFFSET_Y     (HTSC_M_COUNT * 2)

LPWORD  ppwHTPat[HTPAT_SIZE_MAX_INDEX] = {

            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
        };

extern HTGLOBAL HTGlobal;


CONST BYTE  RGB555Pat[CB_RGB555PAT] = {

    //
    // SuperCell: 65x65x1x0, 35%!, 0.8300, 3.2500, 0%, 05753eba
    //
    // Pattern Checksum = eaeb3b7e
    //

    161,216, 20, 87, 38,198, 19,111,208, 67,201, 75,  4,164, 40,240,  //   0
     12,109,245,159,129, 32,242,100,187, 79,248, 62,177, 78, 24,246,
     43,213, 62,254, 34, 72,188,145, 32, 74,200, 52,233, 62,125, 82,
    201,117, 68,129, 55,208,107,237,174,207, 76,236, 17,189,224,  8,
     78,  0,
    118, 69,200,163,235,137, 75,248, 43,151,103,253,123,226,142, 57,  //   1
    157,210, 87,  6,226, 60,155, 43,125, 25,196,107,236,127,183, 87,
    123,161, 11,116,156,227,103, 52,231,159,108,185,144, 14,176,249,
     57,232,171, 24,250, 81,140, 59, 11,130, 41,196,135, 93, 54,131,
    192,  0,
    246, 42,133, 10,109, 51,193,163,121,220, 21,145, 44, 80,113,192,  //   2
     74,131, 52,199,118,182, 80,223,200,159, 51,150,  2, 60,226, 15,
    192, 76,225,182, 81, 44,209,168, 80, 13,245, 34, 72,202,104, 21,
    154, 42, 94,194,147,  2,183,216, 95,252,161, 99, 50,247,155,217,
     29,  0,
    101,158,211, 75,175,223, 31, 92, 11,175, 85,216,173,208, 15,250,  //   3
     37,224,168, 97, 21,254,139,  9, 71,113,228, 86,211,164,100,143,
    243, 41,131, 22,241,144,  2,115,192,137, 95,178,125,239,159, 72,
    215,119,224, 35,108,206, 46,121,169, 67, 18,230,185, 12,114, 59,
    171,  0,
    225, 64, 27,250,120, 68,143,232,114,240, 47,121, 24, 68,159,121,  //   4
    177,101, 28,208,154, 45,110,177,239, 19,167, 41,128, 29,216, 47,
     86,170,211, 61,106,201, 70,251, 56,226, 39,214,  5, 89, 38,194,
    141,  7,166, 62,241,138, 71,238, 27,210,118,142, 65,161,207, 88,
      5,  0,
    128,195,144, 91,190,  5,199, 53,150, 73,202,157,245,109,221, 77,  //   5
      4,238,137, 61,235, 85,197, 60,122,203, 96,252,175, 92,186,130,
    222, 27, 94,147,181, 29,132,164, 16,151,116, 59,170,135,230, 98,
     57,252,104,190, 90, 20,181,106,149, 81,182, 29,220, 81,134,240,
    181,  0,
     82, 17,230, 45,134,239,110,171, 26,185,  1, 88, 41,176, 55,141,  //   6
    198, 49,188,112, 18,133,223, 24,171, 43,148, 64, 17,231, 58,  7,
    162,117,252, 12,218, 85,232,103,202, 84,181,250, 79,186, 17,125,
    198, 33,150, 48,212,153,228, 35,214, 13,246,112, 50,195, 24,112,
     43,  0,
    246,120,180, 78,172, 24, 72,221, 97,255,122,222,116,207, 21,247,  //   7
     94,158, 73,223,178, 69,151,104,243, 83,220,117,200,140,106,245,
     72,200, 52,161,125, 41,174, 27, 65,224, 18,127, 31,222, 70,237,
    168, 83,224,126,  9,108, 51, 98,183,119, 54,166,234,147, 75,214,
    163,  0,
     51,201,102, 36,212,128,184, 37,145, 66,170, 33,150, 79,164,122,  //   8
     38,233, 11,144, 46,250,  1,188, 37,161,  8,181, 43, 70,209,171,
     32,149,100,225, 71,207,109,248,130,163, 55,206,161, 91,148, 51,
    108, 14,186, 77,241,196,135,255, 62,146,220, 87,  2,117,183, 17,
    135,  0,
     89,  4,156,251, 92, 53,241,108,213, 14,206, 62,245,  7,226, 59,  //   9
    204,132, 90,198,102,127,210, 77,115,233,136, 91,243,156, 12, 86,
    126,237,  3,178, 25,149, 49,170, 16, 97,240, 73,114,188,  2,206,
    159,244,140, 54,152, 26, 67,164,  8,194, 36,132,203, 49,239, 61,
    219,  0,
    170,208,123, 23,187,146,  6,171, 82,159,127, 96,183,138,105,173,  //  10
     19,162, 50,238, 19,172, 60,147,200, 68, 47,211, 24,109,181,229,
     43,194, 85,127,239,100,227, 81,216,186,141, 14,202, 68,254,120,
     26, 93, 36,230,114,186,219, 99,231,113, 72,237,166, 89,155,128,
    105,  0,
     35, 83,234, 67,110,204, 71,222, 29,246, 44,221, 27, 68,199, 79,  //  11
    248,100,179,125, 84,222, 31,245, 11,141,178,103,150,203, 54,139,
    104,158, 54,202, 41,157,  8,139, 37, 87, 48,231,122, 36,154, 64,
    179,213,127,196,  3, 83, 43,155, 33,143,197, 14,111, 40,206, 10,
    244,  0,
    132,192, 48,154,229, 19,135,100,144, 70,198,107,168,238, 12,129,  //  12
     46,195,  4,206, 38,140,182,121, 92,194, 19,255, 34, 75,240, 19,
    218, 30,253,105,185, 73,212,173,115,251,151, 94,181,217, 90,231,
     43,148, 60, 90,170,250,126,191, 81,247, 52,137,176,253, 75,189,
     59,  0,
    224, 11,175, 95, 44,169,249, 50,213,180,  3,142, 47, 91,205,157,  //  13
    222, 66,112,148,252,105, 64,213, 40,230,115, 58,184,143,117,174,
     65,182, 82,140, 21,245, 99, 42,191, 17,209, 61,  9,131, 30,195,
    117,248, 23,219,141, 28, 91,222,  9,164, 94,219, 61, 18,145, 93,
    162,  0,
     73,111,254,139,214, 73,116,162, 20,124, 83,243,186,124, 37,100,  //  14
     18,168,234, 84, 50,197,  8,159,132, 71,148,213, 82,227,  2, 95,
    206,135, 12,212,176, 53,132,206, 74,157,101,138,246,174,103,152,
      6, 94,172,119, 70,213,164, 58,117,203, 27,118,184,227,108,205,
     29,  0,
    134,201, 52, 87,  9,199, 35,236, 76,222,160, 26, 70,227,169,254,  //  15
    136, 74,197, 25,171,122,225, 87,249, 13,179, 30,123, 47,168,249,
     37, 77,234,111, 75,154,235,  1,123,232, 25,203, 45, 76,236, 57,
    220,192, 44,239, 11,130, 40,243,145, 46,234,151, 78, 36,164, 64,
    244,  0,
    169, 18,148,236,118,159, 90,130,174, 32,111,194,139, 15, 84, 50,  //  16
    208, 33,116,142,239, 65, 31,188, 52,204,101,236,158,199, 64,139,
    115,194,144, 40,204, 26, 95,172, 51,186, 87,160,116,190, 21,167,
    127, 71,155,105,168,199,101,180, 62,193,103,  9,249,121,215,  1,
     85,  0,
    233, 75,187, 32,210, 45,231,  5,211, 60,251, 41,219,114,190,141,  //  17
     95,165,229,  9, 96,199,140,108,167, 79,136, 59, 10,106,229, 27,
    217,  7, 68,248,165,123,218, 63,253,136, 43,238,  5,142,209,102,
     32,233, 21,207, 60, 31,226,  4,137, 79,220,168, 67,153, 91,191,
    117,  0,
     29,204,101,137, 61,191,120,162, 86,134,178, 79,163, 47,214,  1,  //  18
    244, 41, 84,207,175, 39,245,  2,226, 47,211,172,245,145, 79,166,
     87,153,189,100, 14, 72,189,144, 12,107,193, 68,215, 94, 61,251,
    185, 81,137, 92,254,140, 77,166,248, 23,128, 47,192, 18,239, 40,
    143,  0,
     63,127,  6,242,166, 77, 19,246, 47,202,102, 11,239, 88,128,173,  //  19
    110,183,143, 50,133, 74,165, 96,131,160, 24,113, 66, 21,212, 51,
    237,118, 33,218,136,234, 32, 97,178,223, 28,158,113,181, 29,131,
     53,157,201, 13,174,110,215, 56,108,160,212, 96,228,118, 74,167,
    212,  0,
    248,156,209, 55, 98,225,149,104,168, 28,229,123,154, 22,226, 81,  //  20
     54,226, 22,251, 94,215, 23,192, 41,254, 83,219,190,156, 99,180,
     23,199, 65,169, 51,180,117,242, 39, 76,139,249, 17,207, 83,169,
    229, 28,115,232, 66, 39,179, 14,195, 66, 39,176, 28,146,202, 48,
    100,  0,
     18, 89, 38,190,140, 31,202, 61,221, 84,175, 63,202,113,164, 33,  //  21
    208,125, 75,152,185, 55,144,231, 76,121,170,  8,128, 37,247,135,
     93,148,255,114, 88,  7,203, 55,145,201,102, 48, 78,122,241,  8,
    103,209, 73,152,124,241, 97,137,232,113,242,130, 85,255, 10,136,
    187,  0,
    125,228,171,105,253, 75,128, 15,118,148,  4,254, 42, 78,241,134,  //  22
    178, 15,195,102,  5,239, 85,126, 12,200, 52,240, 63,196, 72,  1,
    228, 58, 15,189,229,157,128, 90,224,  3,169,226,189,156, 50,194,
    148, 42,180,  4,193, 26,208, 67, 35,172,  3,199, 55,178,102,234,
     66,  0,
    176, 28,134, 57,  1,212,165,191,236, 58,194,107,142,183,  8, 64,  //  23
     97,245, 56,220,120,160, 27,180,216,147,105,162, 98,141,215,162,
    117,177, 84,141, 32, 56,247, 21,180,114, 56,131, 13, 88,220,119,
     69,252, 89,224,110, 59,147,183,217, 85,153,104,223, 21,157, 52,
    208,  0,
    109, 75,234,195,156,101, 40, 91, 27,158, 84,217, 24,226,118,204,  //  24
    155, 37,147, 79,182, 68,225,109, 72, 37,231, 19,221, 39,111, 62,
    209, 34,239,112,213,182,101,154, 48,240,195, 96,247,142, 34,181,
     20,166,131, 36,162,248,116, 10,126, 49,238, 31,145, 75,196,118,
      5,  0,
    251,185, 45,115, 62,243,138,219,122,245, 33,169, 59, 91,172, 49,  //  25
    236,114,213, 22,253, 38,142, 47,241,138, 82,198, 68,169,252, 23,
     87,187,148, 17, 77,138, 62,220,121, 77, 18,167, 44,205, 70,237,
    109,211, 63,190, 78, 29,198, 74,233,176, 91,185,112,247, 36,218,
    155,  0,
     89, 18,144,223, 16,182, 69,  9,184, 55,111,208,131,250, 16,137,  //  26
     74,  9,190,134,102,165,207,116,167, 14,179,107,147,  8,190,135,
    232,108, 55,200,251, 36,194, 25,168,211,129,230, 83,124,169,  1,
    150, 92, 23,230,139,217,104,157, 19,138, 38,209, 11,173, 97,137,
     55,  0,
    164,118,200, 92,161,114,207,147, 86,214,161, 19, 78,193,100,223,  //  27
    197,158, 86, 48,221,  6, 79, 30,212, 66,250, 29,226,124, 91, 42,
    165,  5,127,171, 99,155,119,242, 95, 39, 61,153, 14,199, 90,224,
     56,244,160,106,  6, 89,186, 59,206,107,244, 77,150, 53,190, 22,
    225,  0,
     48,244, 68, 40,238, 30, 58,253, 26,128, 50,239,153, 54,176, 28,  //  28
    119, 42,246,142,193, 98,243,175,129, 93,156, 60,194, 51,242,201,
     64,196,235, 77, 14,231, 74,  2,151,190,218,106,250, 46,130, 37,
    193,125, 64,179,241, 54,143,255, 34,189, 60,125,219, 85,234,106,
    197,  0,
    152,  3,193,146,107,189,121,176, 97,225,180,102,  2,229,143, 90,  //  29
    235,166,106, 22, 67,162,120, 42,230,  1,217,132,102,176, 13,112,
    155, 99, 33,148,197, 47,164,206,105, 31, 75,166, 59,151,217,163,
     95, 11,219, 36,122,204, 18,125, 96,163,  2,199, 40,154,  9,135,
     73,  0,
    188,125, 82,227, 14, 69,230,  5,155, 34, 65,134,209, 84, 41,186,  //  30
     11, 71,211,172,232, 13,200, 83,153,109,181, 20,236, 74,140,221,
     23,250,183, 55,106,218,131, 54,255,132,226,  6,210,109, 72, 20,
    253,146,186, 99,158, 68,175,218, 65,237,107,142,240,103,173,249,
     28,  0,
     92,233, 57,174,119,206,141, 85,202,114,248,186, 46,125,253,108,  //  31
    215,145, 35, 80,116,148, 53,254, 27,203, 51, 88,162, 32,187, 53,
     85,134, 71,229,161, 18, 79,175, 22,189, 88,124,186, 34,227,171,
    114, 54, 81,238,  9,224,101, 26,154, 51,182, 81, 18,194, 43, 89,
    206,  0,
    160, 20,192, 44,152, 23, 57,242, 44,163, 19, 88,154,198, 16,161,  //  32
     49,101,190,249, 48,214,100,168,132, 98,241,134,215, 98,246,111,
    202,170,  6,124, 46,246,116,204, 73,150, 36,239, 80,156,127, 51,
    191,221, 28,121,170, 57,138,211,117,227, 27,205,130, 76,228,136,
     37,  0,
    245,140,107,240, 92,222,181,135, 91,217,131,232, 32, 74,218, 66,  //  33
    240,152,  3,124,163, 16,196, 62,229, 10,159, 73, 16,167, 43,149,
     21,235, 94,214,184, 83,159,  8,240,109,210, 59,174, 15,243, 86,
      3,104,143,193, 83,251, 42,167,  6, 92,161, 67,252,158, 60,179,
    103,  0,
      6, 89,204, 25,163, 67,115, 30,187,  9, 67,176,115,165, 93,136,  //  34
     22,202, 82,215, 67,233,129, 36, 89,199, 58,187,110,202, 79,225,
    123, 63,151, 32,138, 56,224,130, 66,169, 13,129,204, 70,111,205,
    159,248, 44,219, 16,133,203, 72,241,132,215, 38,112, 22,201, 46,
    212,  0,
     72,182, 58,138,216,  1,255,154,212,126,247, 39,205,  5,182,231,  //  35
    112, 48,167,114, 24,151, 95,190,149,117,247, 24,219,137,  3,172,
     46,185,254,112,204, 25,104,191, 35,201, 93,252, 33,142,181, 25,
    129, 80,180, 70,116,176, 29,109,189, 49, 86,191,139,231, 98,127,
    155,  0,
    219,133,249, 35,106,184, 97, 39, 70,101,153, 80,134,243, 52, 73,  //  36
    143,221, 69,242,192, 76,251,  5,218, 31, 84,162, 49, 91,248,107,
    211, 88,  9, 65,149,244,175, 78,232,140, 43,166,101,227, 65,237,
     53,214, 23,147,243, 58,225,141, 16,164,229,  8, 63,179, 16,247,
     35,  0,
    113, 11, 94,198,143, 63,211,134,236, 46,189,224, 32,104,151,199,  //  37
     37,179, 11,138, 38,163, 52,174, 62,124,210,133,228,169, 37,146,
     23,157,221,182, 94, 16, 59,157,  1,116,223, 71,189,  7,120,156,
     98,168,119,198,  5,105,191, 74,255,118, 90,146,209, 82,157, 61,
    170,  0,
     57,228,174, 44,237, 13,168, 25,196,123,  8, 69,175,210, 15,100,  //  38
    255, 80,116,203, 93,227,107,137,234,184, 69, 10,111, 78,197, 57,
    230, 95,128, 38,234,141,212,106,240, 53,153, 22,135,203, 47,217,
     14,246, 46, 73,216,138, 49,158, 40,194, 24,245, 36,124,233, 95,
    208,  0,
    185,131, 72,156, 86,117,229, 70, 99,164,251,114,138, 58,233,160,  //  39
     24,139,224, 56,153, 30,195, 17, 87, 38,156,254,191, 19,238,112,
    174, 62,192, 84,172,119, 34,177, 66,184,214,110,248, 72,126,165,
     69,132,182,110,160, 31,230,119,214, 67,121,160, 71,195,  4,147,
     31,  0,
     89, 17,241, 34,203,139, 36,151,220, 31, 82,199, 23,187, 78,119,  //  40
    191, 63,178,  4,241,130, 82,246,168,217,101, 45,129,176, 68,148,
     12,245, 33,210,  7, 68,251, 94,139, 12, 89, 47,151, 25,232, 93,
    192, 41,223, 11,250, 77,169, 92,  2,168,222, 94,179, 51,217,109,
    254,  0,
    152,206,110,175, 58,252, 83,193, 57,135,175, 45,240,148,  6,206,  //  41
     42,235,104,161, 76,205, 49,141,108,  2,145,197, 59, 99,222, 53,
    207, 90,147,110,227,144,191, 26,200,238,124,188,221, 87,171,  3,
    243,102,146, 69,133,201, 20,235,191,132, 56, 13,231,140, 79,169,
     52,  0,
    120, 39,191,  7, 99,165, 16,111,236,  2,205,110, 66,118,223, 88,  //  42
    152,126, 35,218, 22,114,180, 27,201, 64,227, 21,244,142, 24,166,
    121,189, 45,173, 83, 49,112,162, 71, 45,158, 21, 66,135,211, 60,
    127, 30,210,184, 36, 83,145, 71, 39,100,242,151,112, 38,201, 13,
    219,  0,
     56,236, 85,145,206,122,224,179, 89,156, 74,225,171, 52,178, 32,  //  43
    251, 71,188, 85,138,248, 74,218,155, 93,123,162, 87,188,105,240,
     77,  1,253, 61,197,237, 10,223,127,212, 96,254,193, 31,105,152,
    222,170, 62, 99,227,171,245,122,216,163, 20,203, 67,249,128, 94,
    177,  0,
    144,113, 27,231, 44, 78, 34,132, 22,249, 41,129, 26,242,136,106,  //  44
    183, 20,224,157, 51,169,  7,122, 39,252, 30,215, 55, 10,214, 60,
    142,205, 96,152, 30,120,167, 87, 34,182,  4,140, 90,164,244, 40,
     90, 10,253,137, 15,104, 57,  8,182, 64,139, 96,180, 22,171, 42,
    244,  0,
      1,216,176,126,184,246,154,216, 61,188, 90,164,202, 73, 16,208,  //  45
     53,139,116, 13,234, 96,192,227, 87,188,150,100,198,122,157, 36,
    182, 25,126,228, 86,186, 56,250,146,103,226, 54,205, 12, 76,180,
    206,113,154, 45,215,160,201,145, 98,254, 33,213, 54,135,207,112,
     71,  0,
    201, 97, 48, 83, 12,108, 53,102,161,120,224,  9,103,146,229, 80,  //  46
    170,244, 84,181, 67,125, 33,145, 46,126,  6,240, 64,177, 80,236,
     92,217, 50,192, 17,233,135, 13,205, 41,170, 84,130,231,120,142,
     22,236, 59,181,120, 77, 29,229, 45,195,115,156,238, 90, 11,231,
    166,  0,
     35,147,255,134,221,160,211,  4,243, 39, 74,183,254, 49,180,119,  //  47
      1, 55,198, 34,215,164,249, 69,197,233, 79,143, 35,209, 15,151,
    122, 65,166,107,150, 44,105,192, 85,127,246, 18,181, 42, 65,195,
     55,172, 88,222, 23,243,107,136, 78,167,  3, 82, 38,194,147, 53,
    128,  0,
     80,189, 18,197, 63, 33,121,189, 84,200,148, 30,130, 95, 23,207,  //  48
    153,224, 96,145, 60,103, 19,171,113, 29,172,220, 96,124,254, 58,
    188,232,  5,247, 81,218,176, 30,234, 60,155,113,215,149,252,104,
    220,119,  1,138,196, 67,177,214, 25,235,128,221,178,116,251, 98,
    209,  0,
    233,123, 70,110,167,232, 78,149, 25,127,231, 83,215,163,237, 86,  //  49
     61,124,177, 10,237,153,212, 81,223, 56,125, 20,185, 50,172,110,
     29, 88,138, 46,196, 63,137, 98,165,  8,207, 66, 35, 97,  7,173,
     30,150,249, 95, 46,153, 10, 85,192,104, 50,145, 18, 78, 41,180,
     15,  0,
    156, 29,185,242,  7,144, 53,239,173,102, 42,180,  5, 67,121,187,  //  50
     26,252, 48,201, 82, 42,123,  4,148,183,250, 72,208,132,  7,228,
    198,157,212,111,158, 10,252, 55,213,143, 81,174,239,142,196, 61,
     88,200, 61,174,220,111,247,149, 45,163,249, 98,214,165,222,141,
     63,  0,
     96,216,136, 54, 99,204,124, 12,210, 63,247,117,150,209, 33,142,  //  51
    204,116, 77,159,114,205,169,242, 64,102, 13,149, 92,236, 74,141,
     44, 79, 18,230, 93,177,121,184, 31,105,232, 16,118, 50,226,123,
    240,111, 34,133, 17,193, 38,121,227, 87, 27,198, 44,120,  7,111,
    243,  0,
    201, 41, 82,173,221, 32,187, 90,130,162, 16,194, 46,103,242, 91,  //  52
      7,166,220, 17,246, 27, 95, 44,129,225,187, 44,171, 52,186,101,
    177,207,131, 69, 33,236, 45, 86,225,135, 47,150,190, 79, 14,179,
     39,158,194,235, 86, 58,100,208,  6,188,150, 80,141,245, 75,187,
     26,  0,
    165,129,249, 14,118,153, 66,250, 45,205,109, 70,228,174, 65,185,  //  53
    234, 57,108, 64,123,149,190,216,159, 34, 76,241,122,213, 35,250,
     10,106,243,183,144,115,208,157,  4,196, 85,254, 92,209,146, 96,
    219, 69, 22,104,156,241,179,146, 65,127,234, 13,186, 60,211,132,
     87,  0,
      4, 63,196, 91,234, 51,210,110,149, 27,238,154, 26,136, 14,146,  //  54
     43,126,208,175,232, 51, 84, 20, 98,193,113,157,  2, 77,161,129,
     71,158, 54, 23,203, 64, 24,106,236, 54,176, 21,133, 59,245, 28,
    152,120,229,175,  3,131, 30, 81,253, 34, 93,209,115, 20,155, 42,
    197,  0,
    218,171,113, 31,179,128,  2,183, 58,173, 80,115,217, 86,248,105,  //  55
    219,160, 30, 93,  3,167,222,129,255, 12,214, 52,192,104,222, 28,
    197,220, 88,168, 98,229,136,184, 75,149,110,226,193,  2,123,178,
     56,198, 81, 50,205, 66,220,184,110,204,144, 53,167,219, 95,255,
    107,  0,
    139, 48,228,159, 67,204, 89,239,101,210, 11,195, 41,187, 50,199,  //  56
     19, 68,252,136,203,117, 65,162, 57,178,127, 90,248,133, 66,177,
    101, 15,138,235,  7,175, 40,248, 15,203, 30, 69,160, 94,217, 80,
    233, 10,148,251,124, 98,152, 15, 59,173, 21,242, 78,137, 32,164,
     66,  0,
    237, 86, 20,133,252, 49,154, 23,129, 50,255,133,170,103,149, 85,  //  57
    175,119,188, 73, 39,238, 15,204,109, 40,228, 28,167, 16,233, 45,
    152,255, 49,106,205, 76,130, 97,166,120,244,131, 36,197,146, 46,
    122,191, 92, 32,178, 55,244,123,223,130, 96,194,  1,232, 62,207,
     15,  0,
    112,152,203, 97, 10,181,115,221,190,160, 97, 64, 25,240,  9,216,  //  58
     40,230, 11,146,179,103,150, 80,243,133,173, 64,122,189, 97,200,
    120, 78,183,143, 60,152,225, 61,213, 43, 80,174,235, 73, 20,249,
    172, 26,228,133,213,  8,195, 69, 25,200, 47,141,109,169, 97,128,
    184,  0,
     46,223, 62,173,126,230, 65, 37, 88,  5,199,225,124,191, 93,132,  //  59
    162, 74,111,244, 53,215, 34,178, 60,  5,209, 94,237, 43,146,  4,
    229, 37,214, 12,243, 37,185,  3,115,155,216,  9,114,140,203,106,
     59,113,161, 40, 81,165,102,143,238, 88,173,250, 38,213, 24,247,
     83,  0,
    188,131, 25,244, 40, 91,202,158,246,111,144, 39, 82,160, 49,237,  //  60
     58,210,187, 21,134, 82,196,126,222,153,113, 25,155,210, 89,180,
     57,158,126, 88,166,124, 93,253,177, 32,108, 63,227, 56,163,  7,
    223,196, 70,238,119,218, 29,183, 48,136, 15, 71,199, 57,134,173,
      6,  0,
    238, 99,193, 80,140,179, 45,133, 20,208, 65,188,250, 28,197,118,  //  61
      2,102,147, 69,174,235, 13, 99, 30, 76,241,189, 70,125, 28,235,
    108,210, 23,235, 49,215, 29,132, 76,235,196,130,172, 28,241,131,
     76,143, 14,173, 56,150, 77,230, 99,195,228,119,152,101,231, 62,
    117,  0,
     76, 16,154,212,  3,237,103,217, 57,126,165, 13,117,151, 76,218,  //  62
    166,253, 31,227,115, 54,155,252,193,165, 43,139,  8,253,163, 75,
    149, 68,178,107,184, 71,161,211, 12,143, 42, 73,205, 90,115,187,
     36,255,122,210, 27,247,125,  4,165, 37, 93,177,  6,185, 26,207,
    159,  0,
    184,225, 48,118, 63,151, 35,183, 89,242, 95,219, 55,234, 19,137,  //  63
     48, 86,136,185, 17,202, 70,129, 52,105,217, 95,198,105, 48,206,
      9,238, 41,147,  6,233,108, 58,185, 91,170,251,  3,153, 51,230,
     99,176, 50, 81,112,190, 69,213,134,247, 56,213, 72,253, 84,139,
     33,  0,
     53,104,145,255,178, 94,228,140,  8,172, 35,141,195, 92,187,102,  //  64
    204,177, 39, 73,216,106,177,  4,226,144, 17,159, 38,221,133,170,
     97,129,186, 92,200,136, 20,247,120,220, 22,134, 99,212,182, 26,
    150,  6,197,233,153, 17,167, 44,100, 22,162,108,146, 47,168,113,
    242,  0
};




CONST BYTE  HTSC_SUPERCELL_M[] = {

    //
    // SuperCell: 91x91x3x0, 31%!, 1.4225, 10.0000, 0%, c716938f
    //
    // Pattern Checksum = 7fb46795
    //

    //
    // Magenta
    //

    166,206, 43,184,226,118,151, 71,167, 14,239,124,218,  8,228, 59,  //   0
     28,156,180,255, 89,169,101,230,150, 78,170,126,194,101,141, 28,
    131, 57,120,156, 70, 18,188,136,  9,150,181,210,  6,248, 38,132,
    102,196,162,234, 17,166,108,218, 54, 19,241,178,222, 34,146,245,
     23,219, 47, 71,166,121,217, 19,225,182,125,231,106,132,212, 80,
    122, 55,154,  5,239, 92,201, 17,154, 41,254,
     51,126,239,101, 58, 36,188,221, 56,185, 39,152, 46, 87,147,186,  //   1
    238,105, 48,  4,224, 31,127,195, 60, 33,211, 45,239, 37,213,165,
    220, 88,235, 42,180,125,244, 39,228, 89,114, 75,143,109,198,222,
     66, 35,111,135, 71,243, 41,195,132,169, 89, 66,136,106,183, 72,
    125, 98,140,254,194, 52, 93,190,108, 62,  5,163, 40, 60,155, 37,
    198,254, 73,171,126, 45,228, 67,109,213, 77,
    183, 89, 13,162,134,252, 96, 23,113,137,211, 96,178,206, 39,117,  //   2
     16,139,200, 84,149, 51,218, 13,172,252,142,106, 72,180, 60, 98,
      6,194, 25, 99,223, 81,166, 78, 59,190,219, 26,232, 46,155, 11,
    174,252,207, 25,192,149, 11, 77,234,104,205, 23,251, 58,212,  5,
    235,187, 18, 87,113,  7,241,149, 26,251,207, 76,193,240, 90,175,
     11,140, 99,221, 26,179, 97,142,190,  3,145,
     39,221,199, 66,191,  7,171,145,238, 82,  9,252, 62,133,243, 91,  //   3
    193, 67,232,119,208,175, 75,138,103, 80,  2,200,156, 15,126,249,
    143,171,122,203,145,  2,114,209,152, 13,132,169, 64,186, 85,126,
     93,139, 79, 51,105,220,125,180, 47,  1,156,118,174, 38,159, 90,
    145, 64,215,156,229,177, 70,123,170, 89,142,113, 16,140,215,111,
    233, 51,191, 65,147,215, 20,246, 60,118,237,
    167,138, 27,122,225, 50, 78,216, 30,191,161,106, 27,171,  1,217,  //   4
    151, 35,170, 21, 60,106,247, 42,222,184,123,232, 89,220,189, 84,
     39, 57,242, 74, 47,238,181, 35,243, 91, 47,255, 98,215, 28,239,
    190, 20,167,235,182, 80, 93,255,147,214, 70,235, 87,218,116,202,
     28,177, 43, 79, 29,136, 38,214, 44,187, 29,233,172, 45, 73, 24,
    165,132, 31,241,112, 53,122,169, 32,201, 95,
     10,103,244, 80,151,111,199,122, 69, 49,130,226,189,121, 79, 53,  //   5
    115,251, 92,145,235,  7,151,199, 19,157, 57, 26,146, 62, 33,166,
    225,111,183, 22,161, 96, 58,138,110,198,161,118,  3,133,167, 68,
     42,226,122,  5,140, 33,168, 24, 61,107,188, 32,142, 12, 71,248,
    131,102,243,119,211,192,101,237, 76,119,218, 58, 99,244,129,196,
     62,209,106,172, 14,158,207, 90,227,134, 69,
    175,206, 43,184, 33,241, 18,162,249,208, 92, 34, 67,235,155,199,  //   6
     20,182, 48,200,124,186, 88,119, 70,243,100,186,251,111,202,133,
     12,151, 92,200,126,220,191, 15,226, 25, 67,182,228, 59,206,109,
    147,204, 71,100,245,189,116,206,135,238, 53,126,228,196,157, 20,
     60,198,146,  2,159, 54, 18,144,197,  4,159,131,204,  9,157, 97,
    248,  4, 81,219, 77,250, 63,  6,153, 48,248,
     87,148,118,222, 93,176, 58, 97,143,  5,181,150,205, 13, 89,241,  //   7
    139,103,226, 78, 28, 62,216,169, 34,137,213, 44,131,  6, 90,236,
     71,214, 54,254,  9, 70,107,160, 84,142,209, 33, 87,149, 17,244,
     90, 26,157,212, 64, 40,230,  7, 91,159, 21,177,100, 45, 89,188,
    233, 38, 84,219, 69,241,115,170, 63,255, 87, 32,174, 77,223, 35,
    149,122,186,139, 42,184,125,197,100,181, 33,
    231, 17, 72,161,  2,138,233,195, 45,118,229, 58,107,133,177, 59,  //   8
     38,166,  9,150,248,132, 43,234, 85,181, 14, 76,169,223,182, 49,
    122,165, 32,139,176, 42,239,205, 53,250,103,129,238,195, 47,132,
    190, 54,178, 20,144,102,155, 68,183,217, 77,244,  4,210,140,117,
    162, 99,174, 23,183,141, 86,225, 43,111,191,229, 52,124,183, 67,
    213, 57,232, 18, 96,148, 28,235, 80,215,130,
    107,190,250, 52,213,117, 74, 22,214, 81,168, 20,255, 36,215,119,  //   9
    223, 74,193,106,206, 90,154,  5,202,107,149,240,103, 58,149, 22,
    245,189, 82,110,229, 90,148,123,  4,172, 43,161,  9,112,170, 68,
    218,111,248,128,221,196, 49,249,114, 38,145,119,165, 63,250, 76,
      8,208,124,253,106, 30,205, 12,183,135, 15,147, 98,250, 17, 93,
    163, 28,104,167,203,224, 55,113,160, 10, 59,
    168, 32,140,104,172, 36,187,145,106,242,136, 76,195,147, 67,  4,  //  10
    181,133,234, 47, 18,172,240,115, 63,231, 49,196, 26,124,209, 86,
    106,  1,222,157, 20,186, 37, 69,195, 97,227, 64,212, 79,252, 37,
    160,  2, 89, 38, 75, 10,170,136, 15,199, 54,221, 29,109,179, 33,
    227, 55,150, 73, 49,233,122,159, 92,237, 69,212, 35,195,136,236,
    119,193,252, 50, 72,121,175, 21,255,138,201,
     91, 63,204, 18,226, 85,252, 57,177, 11, 40,225,116, 91,164,246,  //  11
     96, 24, 63,120,189, 78, 31,140,176, 18,128, 91,173,233, 35,178,
    216,147, 74, 50,210,116,247,156,215,133, 19,180,140, 26,192, 95,
    130,230,194,152,233,123,211, 86,230,101,156, 80,189,231, 47,156,
     97,182, 17,215,164,189, 78, 55,202, 23,172,115,158, 73, 41,174,
     12, 82,147,128,  1,242, 92,208, 76, 48,226,
    153,121,235, 72,153,124,  7,205, 88,150,190, 62,171, 16,202, 45,  //  12
    142,206,168,253,134,221, 51,198, 88,219,165,255,  5, 74,152, 61,
    131, 42,251,176,133, 62, 11,105, 30, 77,248, 88,120,223,149, 16,
    180, 57,117, 45,176, 98, 29, 58,165, 40,253,128,  9, 86,116,205,
    137,246, 83,113, 34,138,  5,247,146,103, 50,243,  3,230,107,211,
     55,227, 37,216,191,156, 38,133,189,111, 28,
    194,  5,182, 44,101,211,162, 43,126,231,102,211, 43,239,126, 70,  //  13
    232,110, 82, 12, 57,101,154,247, 26,113, 40, 61,135,196, 99,228,
     12,193,109, 16, 83,233,191,168,224, 49,156,194, 39, 63,107,241,
     78,211, 21,254, 68,141,243,186,120,206, 21,176,216,142,241, 14,
     79, 36,131,234,200, 99,214,117, 34,221,190,134, 92,179,142, 84,
    154,112,173, 96, 24,110, 69,231,  8,169,246,
     55, 85,138,248,171, 27, 81,241,182, 78, 26,131,154, 80,182, 20,  //  14
    157, 37,191,145,210,177,  1,125, 67,190,155,211,110,237, 22,182,
    119, 77,224,165,204,145, 43, 88,135,201,115, 14,237,171,203, 52,
    166,109,153,191,  7,219, 89, 13,147, 61, 88,110, 55, 35,160, 64,
    197,220,162, 11, 63,158, 51,183, 83,159, 66, 32,207, 58, 20,250,
    190,  8,241, 67,166,237,200,148, 59, 89,129,
    230,201,110, 21, 68,224,146,111, 13, 52,187,249,  2,108,226, 95,  //  15
    214, 67,243,113, 45,236, 94,208,146,232, 10, 85,176, 47,161, 55,
    243,154, 30, 64,101, 22,121,255,  3, 68,232, 99,145, 85,  5,138,
     25,233, 63,130,102,164, 46,195,101,241,212,155,196,229,102,177,
    121, 54,103,185, 91,251, 25,224,124, 13,253,113,155,225,122, 36,
     77,127, 45,210,138, 56, 15,117,181,219, 19,
    158, 35,150,216,179,105, 34,201,165,234,121, 65,169,201, 35,136,  //  16
    176,  6, 91,165, 19, 71,162, 49, 31, 96,128,247, 24, 76,220,128,
     93, 48,210,141,244,183,211, 56,179,151, 29,188, 42,213,114,245,
    185, 83, 32,213, 58,203,129,229, 28,172, 45,  1,127, 82, 23,255,
      5,154,237, 26,206,115,144, 76,171,209, 88,182, 10, 81,184,149,
    221,197,159, 90, 33,188, 96,247, 29,140,100,
     72,243, 54, 95,  9,137,254, 58, 90,142, 81,221, 48,146, 74,254,  //  17
     54,124,202,230,134,193,118,251,176,216, 54,153,200,104,147, 10,
    198,163,110,  6, 83, 46,158, 94,116,221, 79,132,251, 65,163, 36,
     99,220,173,141,247, 22, 81,156, 66,113,141,237, 66,186,214,135,
     74,208, 42,139, 67,169,  1,237, 36, 64,143,233, 47,107,242, 66,
     48,101, 16,252,122,222,160, 75,208, 51,188,
      2,177,128,198,234, 51,185,116,218, 10,203, 30,118,235, 15,107,  //  18
    193,154, 47, 27, 82,217, 23, 62,134, 14,194,114, 44,239,183, 82,
    253, 27,231,176,216,132, 13,240, 25,191, 50,168, 17,122,199, 59,
    155,123,  3, 95, 41,121,184,  8,252,197, 89,176, 30,156,109, 38,
    171,115, 88,181,244, 51,212, 96,135,196, 17,120,169,203,136,  2,
    174,231,145,177, 60,  5,134, 44,166,112,221,
    144,104, 25, 64,159, 85, 19,151, 44,172,107,152,194, 91,174,217,  //  19
     22, 95,245,175,109,152, 77,229,102,164, 80,229,  7, 65,118, 36,
    141, 66,129, 55,105,168, 73,197,142, 87,237,107,209, 86,232, 11,
    193, 69,228,196,164,234, 87,212,134, 60, 14,225, 99,246, 63,199,
    238, 17,218,124, 23,107,152,186, 48,242, 94,220, 75, 24, 97,216,
     84,114, 33, 76,214,108,240,195, 15,254, 84,
    214,185,246,142,223,119,203,244, 74,228, 61,251,  7, 50,150,120,  //  20
     72,206,138, 58,227, 11,177,201, 29,245, 89,143,175,214,159,226,
    191, 95,202, 16,248, 34,221,107, 37,175,  6,144, 37,172,140,110,
    244, 35,143, 51, 75,137, 32,108, 44,170,205,132, 53,143,  7, 83,
    145, 52,158, 71,194,231, 75, 11,112,170, 57,153, 42,251,150,190,
     45,137,242,197,126, 25, 91,145, 68,126, 47,
     13, 78, 38,100,  7,173, 40, 98,138, 22,180, 97,136,226, 65,247,  //  21
     37,171,  4, 91,197,125, 44,111,147, 55,186,119, 73, 26,100, 53,
      4,167,224,149, 85,182,138, 65,252,121,212, 62,228, 73, 22,178,
     87,163,102,254, 12,215,192,151,230, 84,114, 21,212,173,223,123,
    184,101,250,  6,166, 37,131,254,199, 25,134,213,185,124, 66, 15,
    222,183, 18, 56,150,179,228, 39,218,187,157,
    239,130,208,164, 60,214, 77,194,164,118, 40,215, 76,177, 24,186,  //  22
    134,221,113,238, 51,156,253, 80,221,  2,210, 36,243,198,148,249,
    124, 72, 40,108,198, 51,  1,165,199, 51, 92,161,195,127,236, 48,
    217, 17,207,122,173, 98, 66,  3,180, 29,242,158, 71, 39, 98, 21,
    232, 30,198,136, 92,213, 57,158, 90,224, 82, 12, 98, 31,235,166,
    107, 70,159, 96,237, 49, 79,169,107, 34, 94,
     54,174, 44,112,250,134, 31,240,  2,224,189,145, 46,117,211,100,  //  23
     81, 56,162, 32,185,100, 14,188,126,165, 95,138, 56,114, 18, 90,
    185,235,136, 21,241,122,230, 81, 22,150,231, 13,105, 59,188, 98,
    133, 62,187, 35, 58,225,125,245,105,142, 50,188,126,253,198,155,
     69,126, 78, 41,228,115,186, 29,125, 41,180,247,158,205, 79,133,
     50,255,117,213, 12,121,207,  3,139,230,196,
    148, 90,225, 25,187, 93,157,111, 70, 52,105, 25,248,161,  6,146,  //  24
    242, 17,206,131, 70,225,139, 39, 62,240, 24,223,185,162,216, 61,
    153, 47,209,169, 63,148, 98,207,109,188, 42,136,247, 35,156,  2,
    249,147, 82,237,154, 19,164, 53,195, 74,225,102,  8, 79,134, 56,
    217,170,238,149,178, 10, 72,205,240,155,109, 58,120, 45,181,225,
     11,197, 31,175, 85,189,146,247, 72, 21,115,
    251, 13,197,131, 65, 10,221,191,135,236,171,207, 94, 61,230, 51,  //  25
    192,125, 92,249, 21,167,207, 91,196,113,151, 77,  8, 96, 37,231,
    117,  9,103, 84,193, 12,178, 37,244,127, 73,168,206, 81,223,109,
    202, 26,174,101,130,197, 89,217, 38,163, 22,209,175,233, 36,187,
      2,107, 52, 22, 83,249,138,103, 22, 64,197,  2,222,145, 26,102,
    160,128, 79,143,243, 29, 63,101,199,165, 47,
    178,123, 81,160,233,177, 45, 84, 18,155, 75, 11,134,197,110,170,  //  26
     33, 72,180,151, 52, 84,117,245, 27,173, 45,206,254,120,173, 72,
    191,248,161,218, 52,255, 78,134, 61,  7,233, 99, 18,120,176, 46,
     71,120,231,  6, 68,251, 26,116,139,247, 84,132, 42,112,157, 98,
    249,146,211,190,100,162, 44,177,215,142,232, 94,191, 71,246, 81,
    213, 55,230, 39,112,168,225, 43,121,221, 86,
    215, 59,242, 39, 97,119,142,252,202,117, 43,242,173, 36, 76,137,  //  27
    213,237,  1,112,229,190, 14,155, 76,231, 98,131, 59,150,209, 29,
    138, 57, 27,132,113, 32,210,167,222,154,198, 52,189,146, 28,238,
    163,196, 40,213,167, 46,151,188, 14, 97,199, 63,167,220, 17,204,
     80, 25, 67,125,221, 61,234, 12, 86,114, 43,168,127, 17,165,117,
    186,  4,154,204, 70, 15,132,184, 10,144, 36,
    158,  1,140,209, 21,194, 68, 24, 93,182,220, 90,119,205,255, 22,  //  28
     98,158, 63,208, 33,142, 56,217,125,  4,180, 32,193, 15, 83,238,
    102,183, 79,232,187,150,103, 15, 87,112, 32,135,253, 67,212, 88,
    138, 61,103,143, 85,223,104,238, 57,218,145, 10,241, 89, 60,133,
    181,113,243,169,  6,148,116,201,165,253, 19, 78,239, 50,217, 35,
     68,250, 99,128,176,213, 95,253, 76,232,112,
     93,191,107,170, 61,239,165,215,149, 52, 15,164, 60,  8,152,185,  //  29
     50,130,188, 92,127,253, 98,171, 66,202,143,245, 68,226,115,161,
      2,214,147, 13, 50, 81,235,193, 52,179,228, 74,107, 14,182,114,
      8,248,175, 23,198,130, 39, 79,156,115, 44,192,109,141,214, 41,
    234,149, 58, 40, 94,210, 32, 79, 50,134,211,182,141,102,193,151,
    124,178, 26, 56,240, 40,149, 54,173, 23,200,
    248, 28, 81,225,133,  9,109, 37,127,241,110,212,141,233,104, 70,  //  30
    240, 13,226, 57,169,  8,198, 26,242, 43,109, 90,170,136, 35,199,
     71,120,244, 93,202,162, 26,121,250,147,  3,205,167,229, 60,151,
    205, 42,126,232, 76, 17,181,209,  7,173,249, 69,163, 19,177, 75,
      8, 96,196,227,178,130,246,156,190, 26,110, 59,  5,229, 61, 13,
    233, 86,209,163, 89,120,  5,203,106,136, 46,
     77,130,202, 39, 76,154,228, 85,203, 63,175, 81, 40,192, 33,122,  //  31
    201,167,108, 35,236, 84,149,116, 81,159,210, 11, 49,191, 95,252,
     45,176, 30,113,224,134, 66,170, 35, 95,119, 54,140, 96, 34,239,
     78,184, 98, 55,157,253,144,118,227, 92, 27,102,205, 59,255,118,
    223,165, 26,109, 71, 19, 52,100,228, 72,241,152,204, 82,130,184,
    103, 39,139, 14,226,192,160,242, 83,219,161,
      7,233,150,110,255,192, 45,179,  5,152, 32,250,131, 78,221,143,  //  32
     23, 85,149,192,119,212, 39,234,187, 21,129,239,116,220, 22,147,
    125,209, 67,168, 47,  5,239,198, 72,220,182,246, 20,200,128,170,
     19,141,217,  1,204,100, 49, 73, 37,195,151,225,129, 35, 82,144,
    201, 53,134,241,158,189,221,141,  7,128,178, 30,107,169,253, 48,
    217,167,243, 74,111, 33, 63,128, 20, 53,183,
    197, 56, 30,178, 13, 64,105,133,236, 88,210,104,184,  4,166, 61,  //  33
    249, 45,223, 10, 64,163, 74,135, 97,226, 55,177, 85,155, 62,188,
     81,  9,236,139,190, 84,105,143, 17,152, 80, 40,162, 69,221, 50,
    115,250, 67,164,131, 27,194,162,245,126, 53,  5,168,218,189, 98,
     31, 78,211,  2, 57,116, 84,175, 46,203, 87, 52,224, 24, 70,153,
     21,121, 59,178,134,206,101,189,231,144, 97,
    115,157, 90,211,140,219,164, 23,196,120, 16,147, 51,235, 92,203,  //  34
    115,170, 98,138,251, 27,204,  2,168, 69,149, 31,204,  4,241,108,
    227,160, 98, 24,250,127,212, 61,235,108,208,135,236,110,  5,187,
     83,196, 32,108,242, 83,219,109, 18,178, 84,242, 70,114, 14,159,
    244,176, 94,147,196,253, 17,211,109,153,250,123,195,145,116,209,
     88,191,  3,221, 45,246, 10,153, 37, 68,249,
    205, 66,243,120, 33, 84,244, 70, 44,172,240, 75,205,129, 35,152,  //  35
     14,189, 53,207, 81,184,112,245, 45,212,101,251,133, 74,171, 35,
     58,128,205, 73, 50,167, 12,185, 36,168, 53, 15, 85,181,148,228,
    137, 52,173,211, 16,175, 43,146, 61,229,105,198,138, 47,232, 63,
    119, 24,223,122, 46, 74,161, 34,231, 62, 15,166, 81, 11,240, 36,
    159,248,104,147, 77,160, 93,216,122,171, 18,
     43,179,  9,167, 51,203,112,144,218, 94, 55,163, 19,177,109,242,  //  36
     74,228, 30,125,160, 56,145, 84,179,120, 22,190, 48,112,211,140,
    197, 20,172,218,110,229, 79,136, 94,255,121,194,220, 35, 57, 95,
     26,237,100,145, 77,126,238, 93,204,129, 14,157, 25,173,207,141,
    196, 55,158, 15,235,180,126, 89,144,102,205, 42,233,104,171, 66,
    132, 81,215, 34,200, 22,184, 50, 82,223,133,
    234,106,142,220, 97,179,  2,187, 30,135,225,117,253, 80,212, 46,  //  37
    134,158,102,241,  9,218, 32,227, 12,152,235, 87,145,228, 26, 95,
    254, 85, 48,124, 25,152, 40,193,218,  3, 63,138,102,163,250,129,
    207,159,  8, 57,218, 36,193,  3,163, 42,217, 78,249,102, 84,  4,
    105,249, 86,204,108, 31,226,198, 52,245,177,117,151, 49,193,228,
      9,181, 61,128,235,106,135,253,  2,190, 95,
     58,208, 30, 74,238,130, 69,251,103,201,  8, 49,144, 27, 99,190,  //  38
      1,203, 60,177, 88,188,102,128,201, 68, 37,167,  7,184, 62,163,
     12,184,144,241,197, 95,246,114, 73,149,175,240, 19, 68,197, 13,
     65,116,192,254,165,107,153, 73,250, 98,174, 52,124,193, 54,235,
    163, 36,133,174, 59,153, 78, 11,157, 38, 83,  3,212, 79,137, 42,
    116,206, 23,168, 86,190, 65,166,110,150, 25,
    164,122,187, 48,155, 26,173, 46,156, 74,168, 92,183,223,159,123,  //  39
     86,226, 24,122,148, 39,234, 58,170, 95,218,123,247,103,135,236,
    119,216,100,  1, 58,177, 17,166, 46,209, 29, 90,203,146,111,177,
    229, 37, 81,130, 22, 66,232,133, 27,202,140,231, 34,146,216, 26,
    123,194, 67,217,  8,250,119,214,105,192,135,237,167, 22,220, 93,
    255,156,105,243, 54, 12,228, 42,214, 68,240,
     79,  5,254,109,213, 83,233,125,221, 26,206,237,125, 61, 18,247,  //  40
     48,140,184,255, 64,206,159, 16,251,115, 46,195, 75, 28,200, 43,
     75, 34,159, 78,221,140, 66,236,132, 99,234,128, 60,231, 34, 89,
    131,203,171, 96,214,185, 11,196,116, 56, 87,  6,186, 72,112,173,
     83,228, 28, 97,135,190, 36,167, 62,224, 28, 94, 61,118,180,149,
     16, 76, 44,131,217,154, 89,128, 19,196,131,
    216,179, 87,139, 16,195,101, 12, 66,136,109, 81, 41,192, 74,206,  //  41
    166,104, 37, 78,  7,115, 84,133, 39,183,142, 13,157,223, 91,152,
    210,175,233,129,188, 30,108,204,  9,186, 40,160,  8,180, 72,163,
    249,  2, 55,240, 40,139,104, 50,224,156,214,121,243,159, 15,254,
     50,148,117,242,168, 64, 92,238, 16,120,176,145,206,241, 32, 58,
    191,223,173,201, 31,116,197,236,175, 99, 36,
     63,149, 32,230,174, 41,145,205,164,249,182,  5,163,240,144, 95,  //  42
      9,197,232,157,220,173,240,203, 70,227, 89,240, 53,121,179,  5,
    115, 53, 24,103, 68,253,148, 86,167, 64,220,107,246,133,208, 26,
    109, 73,152,116,178, 71,236,171, 93, 16,180, 42, 95, 60,211,104,
    187,  5,199, 55, 24,207,126,147,201, 75,245, 52,  7,100,142,232,
     91,122,  3, 67, 99,171,  9, 77, 49,154,245,
     96,203,123, 56, 75,113,245, 54, 95, 30, 62,218,129, 23,112,226,  //  43
     58,124, 80,135, 99, 55, 32,150,  2,110,160, 67,206, 31,236, 70,
    219,139,244,197,  7,172, 46,229, 31,125, 80,201, 44, 90, 55,222,
    142,194,231, 27,211, 16,146, 37,253,135, 76,229,143,192, 40,139,
     73,224,160, 84,111,225,  1, 52,164, 31,108,196,168, 80,201,115,
     36,161,248,143,228, 41,252,145,111,193, 20,
    172,  8,247,156,221,188,  3,171,125,226,153, 87,194, 70,173, 34,  //  44
    187,249, 25,211, 16,196, 77,121,192,219, 22,124,166,103,144, 22,
    188, 87, 60,153,118,216,133, 99,199,249,142, 27,158,189,117,170,
     18, 94, 48,167,108, 86,197,113, 62,204, 29,168, 11,122,231,170,
     21,126, 37,239,142,172, 78,254, 95,215,144, 38,127,252, 17,179,
     60,205, 29, 82,178,133, 62,208, 27,230,132,
    221,108, 49, 93, 27,133, 84,235, 21,200, 44,119,254, 48,210,137,  //  45
     86,158, 48,178,108,228,162,246, 93, 61,184,254, 50,192, 79,247,
    112,169, 15,227, 40, 75, 18,181, 54, 12,176,104,217,  4,232, 49,
    247,126,217, 74,248,157,226,  3,185,123,218,106,249, 73, 31, 89,
    247,183, 97,205, 18, 47,196,134,182, 10,236, 88,208, 57,153, 77,
    240,131,103,220, 16,112,185, 91,160, 52, 78,
     36,150,190,216,169, 53,197,148, 71,101,181, 17,149,105,  6,234,  //  46
    116, 64,218,141, 68,131, 53, 12,175, 31,131, 85,  9,224, 36,155,
     51,215,125,180, 90,203,243,155,119, 86,231, 56,134, 71,102,148,
     79,173,  7,143, 25, 56,130, 77,161, 38, 81,150, 51,202,156,214,
    113, 48,157, 66,125,232,105, 27, 69,121, 53,184, 23,105,228,123,
      9,190,159, 55,197, 44,225,  1,243,123,180,
    240, 65,128, 20,119,230,103, 34,210,136,240, 74,225,183, 79,166,  //  47
     24,182, 96,  9,253, 34,208,146,105,230,152,205,114,172,129,210,
    100, 25, 70,252,142,107, 34, 69,222,185,147, 20,253,165,194, 19,
    210, 41,200,114,187,216, 39,245,104,194,237,  7,182, 92,133, 13,
     70,201,  9,243,171, 81,155,204,240,171,150,230,132,173, 31,201,
     97, 41, 74,244,128,166, 75,143,102,199, 13,
     85,203, 41,249, 78,  9,159,244, 63,  6,161, 36,124, 51,217,132,  //  48
    245, 42,226,150,184,110, 80,238, 38,195, 73, 53,241, 90, 64,  3,
    175,230,152, 44,  6,168,191,135,  9, 46, 95,202, 66,121, 38,239,
    131,101,235, 60,162, 95,140,200, 18, 55,135,101,222, 33,244,188,
    124,226,141,106, 32,220,  7, 57,109, 34, 92, 14, 65,217, 51,166,
    237,153,207,  6, 97,232, 24,206, 40, 66,158,
    136,106,174,145,208,187, 87,127,176,109,216, 93,202,152, 15, 64,  //  49
    102,196,125, 75, 22,202,136,180, 91,124, 13,178, 24,151,197,248,
    138, 85,198,118,220, 61,238, 99,204,234,125,169, 31,223, 81,176,
     53,159, 85, 23,254,  8, 66,166,119,212,179, 24,153,119, 77, 45,
    169, 23, 83,196, 55,181, 91,138,218,185,252,118,188, 96,138, 85,
     20,128,106,180, 52,152,118,177,255,116,216,
     18,238, 29, 71, 45,112, 28,207, 44,238, 56,187, 28,251, 94,206,  //  50
    158,  1, 58,173,234, 46, 72,  4,158,251,209, 97,219,120, 34, 57,
    111, 29, 67,173, 88,128, 25, 52,152, 72, 16,243,101,146,201,109,
      1,222,185,137,104,190,221, 37,241, 90, 65,252, 48,175,217,108,
    233, 63,163,253,136,110,238,160, 17, 76, 49,148,227,  5,249,195,
     66,222, 47,250, 85,211, 46, 92, 10,167, 51,
    185, 91,211,130,233,173,254, 74,155, 17,122,146, 72,115,177, 35,  //  51
    235,139,216, 92,113,154,210,229, 61, 34,140, 45,166, 75,227,186,
    164,233,210, 14,247,160,214,174,110,190,141, 51,184, 12, 62,251,
    134, 74, 33,230, 46,150,114, 74,146,  7,166,124,193, 69,  1,147,
     35,203, 97,  5, 43,213, 24, 60,201,131,178, 24, 78,162,120, 35,
    147,183, 14,138,169, 22,237,133,203, 79,227,
    149, 59,166, 15, 86,147,  1,130,194, 97,180,217,  5,232,138, 70,  //  52
    112, 45,187, 21,243, 32,127, 99,194, 87,176,108,246, 17,135, 93,
     10,133, 55,146, 39,103, 70,  2,255, 30,226, 89,212,121,163, 40,
    172,206,120,164, 89,239, 16,208,181,102,215, 29, 95,209,127,249,
     85,155,129,218,173, 84,196,120,245, 90,217,112,196, 41,212,103,
    241, 87,118,199, 65,111,190, 59,155, 28,124,
      4,251,101,192,219, 53,103,226, 58,235, 69, 41,160, 85,192, 19,  //  53
    168,249, 76,134,167, 59,182, 15,133,235,  8,195, 65,150,215, 47,
    252,101,189, 87,179,222,143,204, 93,131, 58,152, 23,236, 86,218,
     99, 21, 54,213, 29,175, 59,133, 32,233, 53,148,238, 21,164, 58,
    187, 27,240, 56,113,145, 66,164, 43,  2,154, 59,246,135, 64, 22,
    168, 55,219, 30,232,159,  6, 98,213,240,104,
    207, 49,138, 34,121,170,209, 39,167, 23,140,246,105,206, 42,228,  //  54
     88,124, 10,211,101,200, 79,250,160, 57,117,223, 38,105,188, 78,
    127,204, 24,235,118, 18, 56,183, 39,168,209,106,176, 46,141, 10,
    190,153,248,103,145, 79,192,245, 83,128,198, 70,118,179, 42,104,
    217,119, 77, 18,193,248, 11,228,108,189,225, 27, 97,180,235,122,
    208,  3,147, 97,127, 43,249,144, 38, 67,181,
     86,163,223, 70,245, 17, 73,150,111,199, 84,176, 15,124, 68,142,  //  55
    185,221, 51,144, 28,231, 42,110, 30,214,142, 84,165,238,  1,168,
     30,148, 61,161, 77,246,128,100,237, 78,  7,249, 73,204,113,244,
     75,129, 63,198, 20,226,117,  3,168, 42,175, 10,213, 79,244,139,
     10,174,209,159, 99, 42,135,178, 57,140, 80,127,165,  8, 76,154,
     91,188,254, 69,179,207, 79,186,112,159, 30,
    243,112, 10,153,105,201,132,236,  8,224,131, 63,219,154,255,  6,  //  56
     57, 97,172,247, 83,155,127,173,196, 76, 43,190, 24,125, 62,207,
    242, 88,224,  5,186, 48,158,213, 21,145,192,126, 28,157, 59,168,
     34,231,  6,165,127, 51,161, 94,219,113,255, 91,156, 29,191, 66,
    230, 93, 36,123,225, 73,203, 90, 30,255,205, 50,232,199, 44,226,
     58,129, 35,215, 12, 57,134, 19,230,200,132,
     62,189,213, 43,181, 89, 33,177, 61, 99, 28,191, 38, 82,193,113,  //  57
    158,207, 23,115,188,  2,213, 92, 21,227,154,255, 92,220,157,100,
     39,124,198,101,135,207, 29, 64,179,107, 44,219, 96,236, 14,209,
    103,176, 90,213, 68,251, 37,204, 27, 67,144, 39,234,129,107,166,
     50,149,253, 60,168, 21,114,222,159,116, 13,155, 85,114,141,184,
     22,169,100,153,115,164,242, 83, 41, 96, 13,
    171, 34, 82,128,228, 55,253,107,205,165,247,150,106,233, 51, 32,  //  58
    239, 73,138, 41,229, 58, 78,247,140,104,  6,114, 47,181, 15,140,
    189, 67,156, 34,234, 90,121,251, 88,230,169, 70,140,189,120, 80,
    144,222, 38,112,183,145,101,176,134,227,187,100,200,  4,222, 34,
    199,117,  6,205,138,244,182,  7, 69,194, 94,184, 32,250, 14, 98,
    243,204, 80,239, 45,218,104,176,211,154,234,
    137,103,249,155, 15,118,160, 12,139, 41, 75,  4,208,139,171,122,  //  59
    185, 12,220,168, 99,137,166, 37,186, 55,170,200,136, 65,246, 83,
    215, 10,253, 56,165, 16,184,143,  3,130, 31,200, 19, 55,165,254,
     44, 72,137,234, 16, 57,236, 10, 85, 52, 17,164, 54, 82,152, 96,
    238, 75,171, 99, 27, 77, 44,146,240, 48,216,123, 62,202,161, 65,
    123, 50,137, 23,197, 74,  1,139, 53,116, 67,
    193,  4,179, 66,218,196, 69,216, 91,236,183,127, 86, 26, 72,222,  //  60
     96,146, 82, 48,196,239, 15,209,119,231, 71,238, 25,205,120, 32,
    172,105,133,201,114, 70,219, 54,202, 62,159,248, 94,227,104,  3,
    181,202, 28,159, 94,195,118,210,149,249,116,217,135,246,179, 24,
    134,186, 48,237,121,165,200,100,127,161, 26,236,143,105, 37,221,
    192,  6,231,180,119,157, 41,189,244, 19,219,
     91,229,116, 40,100, 29,127,169, 24,115, 50,218,162,251,187, 18,  //  61
     54,248,179,120, 29, 70,128, 97, 42,157, 12,101,148, 89,165,229,
     49,220, 35, 84,173,245, 34,157,108,236, 83,117,147, 47,207,152,
    123, 91,245, 64,220,141, 30, 49,174, 93,191, 69, 20,104, 45,214,
     64, 13,208,144, 60,230, 86,221, 14, 70,177, 79,  3,229,175, 83,
    147,110,166, 60, 90,251,206,107, 81,168, 45,
    157, 25,139,239,151,184,244, 56,227,190,152, 13,105, 41,129,153,  //  62
    204,111,  8,234,208,156,187,250, 77,213,125,191, 40,242,  4,110,
    143, 71,159,209,  9,137, 94,212, 23,179, 39,194, 10,178, 78, 39,
    224, 19,173,127,  6,170, 82,227,129,  1, 44,161,234,201,148,111,
    251,162, 89, 33,183,  1,137, 42,188,252, 97,200,154, 49,125, 18,
    253, 75, 32,210, 13,137, 65, 24,135,199,120,
     59,214, 83,199, 50, 75,  2,104,141, 83, 63,239,195, 69,230,100,  //  63
     33,162, 67,137, 96, 54,  4,142, 25,171, 80,223,160, 76,184, 60,
    197,249, 21,111,235, 49,185,125, 76,133,224, 67,214,128,247,113,
    187, 62,108,209, 45,253,106,199, 62,239,212,118, 85, 53,  6,191,
     81,124,218,108,239, 74,209,162, 57,141,118, 33,245, 90,216,185,
     43,203,141,236,113,182,227,160,216,  7,255,
    179, 38,170, 11,114,222,163,194, 21,211,113, 44,124,166,  1,209,  //  64
     86,226,193, 23,170,217,115,202, 62,239,111, 20, 57,129,214, 20,
    125, 93,182, 58,152, 79,222,  5,246,171, 20,109,161, 28, 56,146,
     32,242,153, 87,186, 67,149, 15,160, 97,141, 24,186,136,232, 68,
    174, 18,152, 52,164,128, 26,111,226, 17,216, 66,129,168, 62,113,
    155, 98, 51,169, 80, 28, 56,118, 40, 77,104,
    228, 92,131,242,156, 81,129,254, 48,171,231,157, 28,246, 77,177,  //  65
    142, 47,122,254, 75, 38,237, 90,155, 34,205,145,249,172, 91,236,
    156, 42,224,121,203, 32,161,103, 43, 63,140,242, 73,222,102,172,
    213, 73,  9,234,132, 23,236,122,185, 47,204, 65,243, 96,160, 29,
    222, 60,245, 31,193, 95,248, 70,181, 88,157,192, 10,205, 30,225,
     15,244,130,  3,191,247, 95,169,240,187,148,
    125, 19,198, 60, 23,207, 35, 66, 99,131,  8, 87,200,137, 51,117,  //  66
    242, 10, 65,184,105,136,173, 11,124,180, 71,101,  7, 47,119, 31,
    203, 77,169, 20, 94,252,132,209,178,219, 86,197,  1,132,192, 17,
     92,130,199, 41,175, 94,202, 32, 83,250,  8,173,125, 44,198,119,
     93,201,130, 80,214,  9,173,136, 38,243,107, 48,237, 96,131,165,
     69,180, 88,223,108,146,202, 45,130, 12, 65,
     47,248,151,106,233,180,118,160,235,208, 56,183,105,215, 15,191,  //  67
     80,164,219,144, 14,222, 68,197,252, 53,224,158,197,228,178, 84,
    130,  2,241,139,190, 67, 13, 82,122, 21,152,106,180, 42,255, 64,
    231,166,106, 61,227,116, 65,163,220,109,152, 88,212, 14, 73,255,
    143,  4,182,103,150, 53,222, 60,201,  4,147,183, 72,151, 38,238,
    108,211, 29,156, 42, 70, 19,228, 88,195,217,
    113,183, 71, 37,137, 89,  6,194, 31, 82,145,250, 38, 66,151,231,  //  68
    109, 36, 93,196, 59,161, 30, 85,108, 21,129, 40, 78,138, 59,255,
    161,212, 65,105, 41,158,224,196, 54,250, 46,232, 71,159,100,147,
     40,208, 16,137,158,  4,214, 44,135, 68,192, 32,143,229,180, 53,
    170, 76,220, 24,243,121, 94,163,124, 86,226, 28,119,214,177, 57,
      7,144, 65,203,234,139,181,106,161, 32,153,
     91,  3,225,172,211, 49,246,139,105,174, 20,119,169,224, 94, 23,  //  69
    179,239,130, 27,248,120,232,141,216,164,190,245,115, 12,200, 23,
    108, 46,151,200,236,123, 33,110,167,136,202, 17,127,219,  9,196,
    121, 79,240,187, 70,252,127,177, 13,230, 49,246,104, 80,116, 19,
    231, 45,126,166, 41,186, 15,251, 43,210,137, 56,250, 12, 81,195,
    126,255,174,115, 14, 79,251, 51,215, 72,235,
    202,137,100, 28,116,162, 75,215, 55,203,227, 69,  5,130,199, 49,  //  70
    143, 65,208, 77,178, 94, 43,187,  1, 61, 92, 31,169,223,146, 87,
    225,187, 25, 75, 12,178, 88,239,  4, 75, 96,169, 57,186, 84,244,
     29,141, 46,102, 29,193, 76,100,201,154,119,174,  3,161,198,134,
     88,204, 99,232, 71,208,143, 82,181, 19, 97,186,161,110,143,229,
     93, 31, 50, 95,197,126,167,  6,115,141, 22,
    170, 45,252,189, 82,229, 17,125, 25,150, 96,181,242, 84,165,111,  //  71
    215,  3,168,117, 12,205,152, 72,126,233,141,207,100, 63, 35,172,
    123, 80,248,130,222, 54,149,191, 61,181,243,117,227, 31,151,108,
    177,219,159,206,121,154, 19,234, 62, 24, 91,214, 57,224, 27,243,
    165, 33,153,  8,132, 98, 47,233,118,148,239, 71, 37,207, 27, 67,
    156,215,191,148,238, 36, 67,208,182,246, 56,
    221, 75,156, 11,131, 41,198,174,251, 80,127, 28, 48,210, 59,237,  //  72
     40, 98,246,148, 63,227, 33,245,105,197, 52,  9,240,130,195,233,
     43,153, 91,167,106,207, 39,121,224,144, 20, 41,142, 69,207, 19,
     55, 94,  7, 64,245, 40,213,109,140,244,191, 73,143,112, 47,100,
     62,186,252, 59,185,225,163,  6, 74,200, 46,218,132, 89,246,172,
     16,124, 62,  3, 87,219,144,102, 43, 88,121,
    148, 30,114,207,239,150,109, 72, 46,162,232,194,147,121, 14,154,  //  73
    129,195, 69, 35,189,132, 95,172, 15,156, 79,186,150, 28, 76,111,
     16,211,185,  5, 68,135,254, 13,103, 53,217, 86,175,252,116,185,
    224,127,233,181, 86,130,164, 54,178, 36,128, 17,252,189,151,209,
    131, 16,110,144, 85, 27,108,215,174, 30,104,166,  2,193,114, 42,
    223, 99,248,162,119,183, 18,230,174, 11,193,
     99,231,175, 51, 68, 89,224,  1,188,114, 12, 62, 90,254,179, 76,  //  74
    224, 24,174,230,103, 18,202, 68,220, 38,253,116, 91,206,166,251,
     61,126, 75,238,201, 29,174, 83,193,158,124,199, 99,  3, 47,140,
     83,163, 38,109, 46,203,  2,229, 82,207, 99,170, 41, 87,  9,237,
     72,195,224, 36,198,246,151, 54,135,254,125, 56,237,148, 61,185,
    140,199, 71, 30,203, 50, 76,129,153,240, 63,
    136,  4, 91,195, 18,165,201,127,243, 94,219,170,206, 34,104,204,  //  75
     58,109,139, 82,157,249, 43,150,127, 92,175, 20,229, 50,  3,137,
    179,224, 24,143, 50, 94,151,220, 43,247, 11, 65,230,154,213, 71,
    247, 12,210,154,241,174, 96,122, 26,155,238, 65,218,130,177, 56,
    164, 96, 49,171,114, 67, 17,191, 84, 11,211,177, 77, 26,230, 92,
      8, 50,172,226, 97,149,253, 38, 90, 25,210,
     41,243,154,121,254,101, 59, 32,155, 44,139, 26,117, 64,141,  6,  //  76
    167,248, 17,191, 50,120,180,237, 59,215,133, 56,161,125,216, 98,
     33, 88,164,106,181,242,115, 25, 74,111,177,143, 29,114,173, 22,
    188,104, 53,134, 19, 72,146,255,187, 48,137,  5,196,108,227, 22,
    119,249,148,  2,210,134,236,102,227,158, 40, 98,137,206,113,160,
    241,127, 83,135,  9,210,107,188,222,123,176,
    193, 76, 46,210, 27,139,227,182, 84,204, 70,246,153,225,188,237,  //  77
    122, 44,212, 68,220,  4, 91, 37,112,  8,190,241, 88,193, 65,154,
    244,192, 57,212, 14, 68,209,138,190,235, 56,208, 77,245, 94, 57,
    127,237,176, 93,225, 40,206, 11, 70,114,228, 96,156, 76, 37,143,
    211, 80, 59,228, 83, 33,172, 42,123, 65,201,242, 15,182, 38, 59,
    211, 20,192,246, 57,174, 65, 12,163, 53,104,
    148,224,107,180, 82,170, 15,114,234,  9,176,103, 20, 85, 36, 55,  //  78
     93,160,132,102,171,128,228,148,207,163, 79, 30,116, 13,230, 41,
    114,  7,141,233,123,161, 48,  2,155, 85, 16,162, 37,135,192,216,
    158, 34, 71,200,117,178, 89,130,220,167, 21,202, 50,184,243, 94,
    170, 16,190,120,182,150, 71,220,181, 19,146, 72,120,223, 88,142,
    175, 69,110,158, 29,123,238,141, 83,246, 27,
     66, 11,132, 35,238, 52,213, 92,148, 51,131,219,198,162,118,181,  //  79
    215, 10,202, 36,255, 64,194, 20, 85,232, 46,153,213,143,179, 83,
    169,205, 96, 40, 84,200,252,102,226,124,214,105,234, 86,  5, 49,
    108,223,  9,144, 48,247,157, 35,194, 93, 67,250,131, 12, 64,200,
     41,132,241, 28, 92,252,  7,137, 92,248,105,192, 47,167,  6,253,
    117, 43,219, 93,229, 81,198, 31,215,129,202,
    174,249,156,204, 97,126,162, 63,194,241, 81, 41, 96,  3,229,140,  //  80
     80,237, 72,153, 95, 25,162, 57,138,118,182,252, 92, 60, 27,238,
    133, 49,248,178, 23,133, 58,180, 74, 27,174, 44,200,153,182,254,
    142, 89,169,236, 82, 23,112, 65,235,144, 31,161,110,229,150,117,
    225, 99,156, 69,210,111,195, 38,212, 60,164, 25,234,136,102,184,
     23,199,134,  1,186,151, 46,110,165,  4, 93,
    120, 47, 73, 16,183, 39,250,  4,123, 30,172,144,253,184, 70, 31,  //  81
    109,170, 21,192,136,221,107,242,202, 31, 69,  3,129,199,112,212,
     18, 75,115,143,225,106,164, 37,198,139,247, 68,123, 22,113, 64,
     27,204, 40,107,208,163,220,179,  7,116,189,216, 46, 80,178, 20,
     57,194,  5,176, 45,146, 77,167,122, 14,204,117, 66,205, 51,227,
     74,163,240, 72, 38,117,217, 75,194, 51,225,
     21,189,216,116,230,143, 80,188,223,102,207, 23,122, 49,154,242,  //  82
    195, 53,120,244, 48, 73,179, 11,155,100,210,162,227, 46,152, 90,
    164,192,216,  8, 65,202, 14,239,113, 56,  6,148,215, 79,233,158,
    219,129,186, 60,136, 14, 52,127, 87,241, 54,100,  2,204, 93,254,
    136, 86,237,125,218, 22,239, 48,227,146, 83,239,157, 30, 95,149,
    123, 49,104,205,159,243, 25,139,254,104,155,
    240,142, 81,163, 50, 20,170, 90, 47,158, 64,229, 87,202,104, 13,  //  83
    136,217, 87,157,  1,214,130, 51, 78,234,115, 39, 72,180, 11,251,
     64, 36, 98,174,236, 81,150, 95,208,172,222, 82,167, 38,194, 16,
    101, 73,  1,241,195, 91,253,199,154, 21,131,171,245,115,158, 43,
    212,154, 34, 60, 94,183,115,200, 93, 39,186,  3,106,183,248, 10,
    212,186, 19,129, 55, 97,183, 64, 16,179, 79,
     54,110,  6,246,100,212,118,231,132, 11,186,140, 18,162,223, 78,  //  84
     44,163, 27,229,111,194, 92,251,173, 28,185,147,242,106,135,201,
    119,224,148, 55, 30,127,188, 43, 72,130, 34,100,250,127, 54,140,
    245,178,147,113, 35,172,106, 31, 68,223,198, 60,142, 33,189, 68,
     10, 99,204,167,250,140,  8, 67,157,255,123, 69,222,132, 63,161,
     41, 85,252,172,213,  8,223,161,118,208, 33,
    227,171,195, 56,140,186, 60, 28,200,241, 80,110,247, 38,126,192,  //  85
    252,103,184, 68,142, 39,162, 22,137,219, 63,  8, 88,216, 32, 52,
    159, 14,112,248,160,215,105,255, 10,231,159,203, 13,182, 97,204,
     66, 29,214, 82,225, 64,137,232,162,110, 83, 25,209, 86,232,123,
    242,178,130, 14, 71, 42,222,178,107, 19,209,171, 49, 25,215,110,
    234,142,102, 36, 74,144,106, 39,237, 86,149,
     95,128, 37,225, 86, 11,255,151, 97, 39,165,207, 58, 91,176,  7,  //  86
     66,131,207, 16,245, 62,222,114, 80, 98,203,126,191,151, 78,183,
    242, 71,187, 87,  1, 69, 35,151,181, 89,117, 60,141, 78,230,  8,
    167,132, 50,182,153, 21,188, 55,  4,185,139,230,112,174, 26,151,
     82, 49,226,113,206,160,123, 33,235, 52,144, 82,245,153, 86,185,
     71,  4,217,157,193,242, 67,189,135,  2,185,
     29, 76,209,152,112,169, 69,114,181, 62,128,  4,185,229,114,148,  //  87
    221, 33, 93,155,106,176,  6,198,237,165, 20,254, 54, 24,234, 95,
    129, 30,208,122,170,197,223,112, 54,206, 19,241,193, 46,160,111,
    218, 94,250, 10,102,236,121,208, 87,244, 49, 16,148, 54,217, 98,
    203, 18, 68,152, 88,244, 76,192,138, 74,198,117, 10,194,123, 22,
    164,199, 54,114, 14,126, 23,220, 53,111,248,
    157,187,  9, 58,235, 33,219,195, 19,236,214,101,139, 43, 73,199,  //  88
     47,171,238, 71,218,131, 85,144, 34, 61,139,103,178,120,162,  5,
    219,149, 59,233, 47, 91,133, 15,234,146, 83,169, 31,123,244, 73,
     33,189, 61,129,201, 74, 42,151,106,164, 73,189,253, 75,  3,184,
    137,249,175, 30,189, 53,  1, 96,211, 15,161,227,101, 48,210,239,
     40,126,247, 78,222,179, 97,147,174,209, 61,
    222, 82,245,129,176, 94,134, 49,144, 87,160, 28,251,164, 20,244,  //  89
    104,136, 11,192, 26, 47,247,180, 95,188,213, 41,226, 64,201,112,
     44,172, 94,138, 27,247,163, 72,177, 45,128,224,102,207, 18,146,
    173,116,223,151, 31,175,252, 11,226, 33,213, 98,124,160,231,118,
     36, 76,111,232,100,137,236,175,114,247, 37, 66,175,145, 68,103,
    149, 87,175, 41,141, 29,250, 44, 86, 13,134,
     24,108,150, 21, 73,205,  2,246,108,203, 77, 59,187, 97,129,175,  //  90
     82,217, 61,115,145,205, 65, 17,120,240,  8, 88,154, 17,244, 77,
    188,253, 11,215,195,111, 52,212,101,251, 28, 63,158, 88,183, 59,
    238,  3, 87, 53,210, 92,137, 69,184,117,146, 52, 13,199, 90, 56,
    168,199,149, 11,210, 36,155, 73, 45,146, 89,200, 25,250,  7,180,
    228, 22,213,108,193, 64,163,121,232,184, 98
    ,

    //
    // Cyan
    //

     87,195,141,  6,185,154, 78,141, 94,121,252, 82,161,226,195,100,  //   0
    255, 12,201,232, 79,126,230, 48, 75,130,102, 34,139, 16,198,152,
     11,188, 37,100,199,228, 68,191,252,151,  8,101,245, 19,204, 85,
     14, 57,206, 26,103, 45,182, 12,227,153,195,233, 57,147,194, 47,
    151,204,111,248, 80, 32, 51,113,181, 17,141, 69, 13,243, 34,145,
    237,216, 26,117, 62,161, 42,241,175,119,158,
    110, 22,176, 62, 98,209, 30,176,197, 25,207,  8,106,137, 63,128,  //   1
    166, 83,109,149, 34,189,155, 21,253,209,171, 86,211,174, 78, 48,
    212, 80,128,156,  2,138, 44,100, 24, 80,231,139, 42,187, 52,234,
    166,123,247, 77,164,208,142, 59,123, 27, 89,127, 32,210, 10,128,
    227, 39,168, 17,199,124,237,149, 60,250, 86,188,113,204, 60,177,
     19, 56,149,248, 14,191,121, 87, 17, 57,245,
    211, 70,224,118,238, 54,127,227, 58,151, 73,173,219, 37,240, 18,  //   2
    215,191, 23,246, 66,218, 82,114,145, 66, 10,243,109, 40,132,255,
    104,170,232, 69,250,114,212,161,220,183, 56,199,116,159, 79,135,
     95,191,  6,114,229, 20, 92,191,215, 50,252,182, 74,241, 85,184,
     98, 64,219,137, 59,170, 89, 22,207,124,167,223, 42,160, 90,126,
    206,104,189, 76,141,235, 32,217,200,146, 33,
    127,168, 36,151, 17,195, 90,  2,107,239,125, 47, 93,200,157, 52,  //   3
     78,124, 49,174,116, 10,177,227, 28,195,120,153, 68,223,183, 24,
    144, 53, 17,186, 33,176, 74, 10,109,132, 28, 91,225,  2,253, 24,
    208, 38,149,177, 43,133,246, 71,159,104,137, 11,160,112,152, 21,
    255,119, 31, 93,242,  2,219,186, 43,101,  5, 76,131,232,  9,255,
     71,164,  4,210,100, 54,132,163,107, 73,181,
      3, 94,248, 78,178,133,255,165,206, 33,188,234,140, 12,114,182,  //   4
    232,147,220, 91,205,139, 49, 99,164, 53,232, 38,199,  6,116, 88,
    221,193,120, 91,219, 49,149,243, 44,174,248,149, 64,175,102,154,
     55,232, 87,214, 64,184,107,  4, 41,228,195, 61,221, 36,197, 70,
    136,166,208,183,153,106,130, 70,143,231,198,153, 35,192,109,150,
     27,225,129, 43,179,220, 75,  8,254, 41,232,
    192,144, 52,204,105, 28, 49, 79,143, 99, 64, 25,180, 80,245, 91,  //   5
     31, 72,  1,159, 35,238,186, 70,248,135, 89,173,100,145,242,163,
     41, 73,246,164,134,105,195, 81,206, 67, 11,109,209, 34,219,120,
    180, 71,138,104, 15,220,154,236,174, 81, 26,123,174, 99,238, 47,
    213,  9, 78, 56, 28,202, 47,253,175, 32, 64,246,101, 62,216, 43,
    180, 97, 63,250,149, 20,169,194, 91,154,109,
     70,214,116, 12,231,159,219,187, 12,244,160,118,210, 48,151,125,  //   6
    208,167,251,123, 62,107, 19,208,112,  4,214, 25,229, 51, 77, 18,
    212,137,  5, 66, 30,238, 15,140,114,161,233,187, 48,144, 74, 26,
    240,  8,195,251,127, 79, 49,131, 98,205,149,246, 73,  1,142,171,
     87,109,246,133,232, 86,164, 10,117, 92,134,180, 25,170,133, 80,
    238,143,200, 32,114, 88,238,123, 28,208, 47,
    245, 34,152,187, 66, 92,121, 59,133,197, 77,228,  4,170, 66,189,  //   7
     16, 89, 47,190,223,169,138, 40,157,192, 71,153,123,185,205,125,
    176,103,227,187,210, 88,179, 41,218, 22, 74,131, 96,247,199,159,
     97,147, 61, 35,157,197, 18,211, 59, 10,109, 41,185,219,118, 23,
    227,146,192, 17,102,146,210, 80,187,228, 15,212,117,237, 10,191,
    114, 17, 77,174,223, 50,141, 65,228,117,175,
    132, 89,235, 40,137,242, 33,212,102, 26, 53,146, 90,254, 33,215,  //   8
    111,230,146, 96, 11, 74,245, 93,231, 51,108,245, 42, 92, 27,252,
     54, 83,146, 45,123,159, 61,235, 96,145,201, 31,172,  7,116, 46,
    225,204,122,186, 91,238,107,145,254,178,223,160, 97, 53,201, 65,
    179, 74, 44,166,218, 72, 21,243,139, 43,161, 56, 86,156, 70,221,
     51,161,243,126,  7,208,186, 16,160, 77, 22,
    167,  5,177,107,205,  9,181,144,249,164,207,112,193,130, 80,138,  //   9
     56,177, 37,209,135,186, 54,205, 17,147,179, 11,216,168,112,152,
     10,236,180, 19,100,248, 11,124,188, 50,226, 83,236,140, 67,178,
     25, 81, 13,229, 55, 24,170, 69, 30,123, 76, 18,241,145, 32,250,
    125,  6,233,113, 50,196, 40,110, 68,199,100,247,188, 41,127,174,
    103,207, 39, 98,156, 69,106,251, 44,200,224,
     63,123,219, 57, 84,163, 52, 76, 40, 95, 15,238, 48, 18,221,165,  //  10
    243,  6, 78,249,111, 26,160,104,128, 83,208, 75,140, 58,195, 79,
    208,128, 68,204,150, 75,213,161, 69,  4,157,105, 54,194,219, 93,
    254,141,175,104,163,127,222,188, 97,151,215, 56,111,189, 81,103,
    164,207, 91,142,252,177,130,165,234,  9,147, 31,113,205, 24,253,
      1,139, 66,194,234, 35,173,124, 81,139, 98,
    248,197, 44,147,253,116,224,191,128,227,171, 70,153,183,107, 29,  //  11
     90,126,194,156, 63,202,239, 46,193,255, 31,122,241, 23,225, 45,
    173, 29,108,225, 47,178, 30,105,202,253,126,188, 16,118, 31,154,
    115, 51,216, 37,249, 87, 57,  3,239, 42,196,132,227,  9,153,212,
     25, 61,188, 31, 75,  2, 95,208, 55,126,221,176, 76,234,151, 61,
     94,229,178, 16,132, 90,216,  3,236,182, 18,
    154, 28, 93,172, 18, 39,142,100,  2,198, 32,133, 91,233, 58,206,  //  12
    147,226, 44,100, 10,131, 86,150,  2,168, 55,156, 94,179,114,143,
     95,244,157,  1,136,115,230, 54,138, 88, 45,215,162,243, 61,184,
      1,199, 72,133, 12,198,141,211,117,161, 87, 36,167, 68,234, 51,
    137,241,157,117,222,155,239, 78, 34,192, 88, 18,139, 45,106,200,
    165, 32,117,249, 72,200,144, 56,157, 41,113,
     74,186,237,108,194,218, 62,245,157, 57,111,248,200,  5,124,176,  //  13
     67, 17,166,236,179,210, 34,232,116, 78,227,196,  7, 69,234, 13,
    211, 37, 65,183,250, 84,190, 13,166,221, 20, 68, 92,135,204, 80,
    236,165,107,224,156, 48,102,170, 74, 24,247,183, 99,128, 22,184,
    109, 86, 10,205, 46,128, 21,175,146,103,252, 60,215,187, 13,127,
    222, 85,155, 55,169, 19,110,226, 87,201,223,
    143,121,  7, 68,131, 89,173, 27, 77,222,177, 49, 81,168, 38,251,  //  14
    103,215,120, 82, 51,112,163, 60,200,132, 35,102,218,127,157, 62,
    177,132,203, 96, 27, 59,149,239, 71,121,185,148,226, 12, 45,103,
    134, 21, 44,182, 90,242, 17,226, 52,205,124,  5,224,197, 85,254,
    166, 55,230,101,170, 64,202,110,227,  6,168,117,157, 94,246, 68,
     38,189,  9,214, 98,240, 41,184,130, 11, 59,
    243, 48,199,230,163, 13,213,126,200, 93,135, 26,153,226, 90,137,  //  15
     53,193, 33,150,253, 19,217,102, 23,248,176,149, 49,186, 26,252,
    109, 76,238,122,162,218,105, 36,203, 98,243, 31,109,173,251,158,
    211, 69,247,123, 62,191,148,121,180, 92,150, 71, 46,153, 36,134,
     17,198,144, 26,192, 92,250, 39, 68,203, 45,234, 21, 56,163,203,
    138,236,106,142, 31,192,154, 78,255,105,173,
     20, 95,152, 60, 38,243,108, 47,153,  7,231,190,115, 18,204,181,  //  16
     13,156,228, 66,189,140, 76,183,147, 57, 90, 16,240,111, 83,198,
     47,168, 20, 52,188,  8,130,180, 63,  3,168, 76,203, 59,125, 38,
     89,177,144,  6,209, 34, 82, 41,253, 16,216,177,244,107,217, 67,
    227,116, 74,240,131, 10,159,135,185, 94,148, 75,132,225,107,  4,
     82, 45,176, 69,224,125, 57, 18,167, 44,209,
    125,181,220,115,140,185, 72,168,254, 61,104, 70,247, 57,121, 74,  //  17
    244, 85,106,  5,122, 40,225, 10,236,113,212,193,133, 54,223,145,
      5,232,137,212, 91,232, 78,254,146,216,123, 44,139,222,  6,194,
    229, 27,103,233,153,114,229,163,104,136, 51, 90,129, 13,185,101,
    168, 47,180, 36,215, 56,224, 29,114,246, 12,212,190, 47,179,145,
    220,120,249, 16,168, 81,209,118,225,140, 67,
    239, 35, 85,  3,209, 92, 18,207, 33,140,216,164, 34,150,221,165,  //  18
     28,132,173,201,236, 88,166,131, 45,170, 34, 68,161, 12,176,119,
     93,192, 67,112,154, 30,172, 55,106, 35,190,247, 96,180, 78,108,
    147, 62,197, 46, 87,184, 20,206, 60,194,231, 22,164,208, 57,143,
      7,249, 88,151,101,123,177, 83,205, 50,171,108, 82, 27,254, 91,
     23,183, 59,150, 94,241, 37,185, 91,  7,193,
     73,144,171,251, 43,150,236,123, 96,178, 12,126,205,101,  1, 65,  //  19
    195,219, 69, 31,152, 51,195,105, 73,220,121,254, 99,233, 74,209,
     53,158, 24,245, 45,199,128, 11,223,163, 82, 11,156, 29,240,167,
     17,255,132,170, 28,245, 67,126,  5,154,100,187, 72, 38,235, 82,
    212,128,189, 16,207, 67,245,  2,158,130, 68,237,141,168, 63,206,
    158, 39,211,108,196,  2,142, 71,246,164,108,
     14,229, 50,131,106,192, 67, 40,199, 75,244, 43, 86,172,236,142,  //  20
     98, 40,119,244,102,216, 16,249,184,  1,152, 25,186, 43,148, 22,
    251,102,205,133, 74,227, 85,189,135, 62,234,113,214, 68,133, 48,
    202,114, 73,211,110,138,176,218, 86,239, 33,134,252,123,158,195,
     25,106, 45,234,161, 28,145,105,234, 36,214, 19,196,102, 14,131,
    110,235, 85,138, 55,222,170, 43,131, 32,211,
    178,105,203, 69,226, 10,173,133,223,156, 58,186,222, 21,117, 49,  //  21
    255,153,179, 20,144, 79,134, 56,144,100,200, 70,125,218,110,179,
    130, 40,176,  2,168,117, 27,246, 98, 19,182,137, 39,196,103,224,
     82,183,  2, 55,235, 14, 97, 38,143,172, 57,197, 91,  1,101, 51,
    140,226, 66,133, 87,187, 57,200, 79,181, 96,123, 43,244,185,221,
     68, 10,168,243, 23,118, 85,195,220, 63,124,
     82, 39,156, 27,164, 82,249, 31,108, 20,100,124,146, 72,211,184,  //  22
     77,  7,229, 67,201,173, 34,219, 83,241, 46,230,156, 85,  6,234,
     66,219, 86,239, 54,213,155, 51,145,221, 46, 90,252,172, 21,155,
     37,140,227,166, 84,156,195,251, 66,108,210, 25,164,220,185,245,
     77,175,202,  5,255,114,217, 42,139, 11,157,233, 65,152, 85, 32,
    149,198, 47, 74,188,152,254, 13,104,160,243,
    194,132,248, 97,214,117,147, 56,178,239,202,  6,250, 40,151, 27,  //  23
    132,203,103,125, 46,238, 96,180, 14,162,114, 18,181, 39,201, 94,
    154, 19,123,148,103, 14,194,113,174, 80,206,152,  4,123, 62,242,
    205,102, 47,128,202, 63, 29,117,183,  8,232,121, 69, 41,129, 15,
    152, 29,112,156, 71,169, 20,120,243,195, 55,204,136,  3,171,117,
    251, 95,133,211,104, 33, 70,135,184, 54, 19,
    226, 75,  8,187, 54, 22,198,218, 88,141, 67,169, 87,191,106,235,  //  24
     85,171, 35,218,159,  4,119,138,209, 77,195,140, 58,242,134,172,
     52,209,190, 61,177,250, 71, 37,239, 16,120,192, 71,232,144, 95,
     10,176,249, 19,108,237,136,206, 45,156, 77,142,247,177, 84,194,
    104,241, 50,225, 36, 98,230,154, 69, 99, 27,113, 80,212,231, 60,
    186, 37,226,  5,162,233,200, 45,238, 96,149,
     29,177,110,230,137,174, 76,  2,126, 40,232, 31,122,224, 52,160,  //  25
     12,246, 66,139, 89,205, 62,251, 50, 28,236, 98,207, 78,112, 11,
    249,101, 32,232, 21,126, 97,212,129, 63,230, 38,109,175, 27,193,
     66,134, 81,212, 54,173, 12, 82,243,103,192, 52, 14,109,228, 47,
    216, 67,179,122,208,186, 59,  7,179,220,162,251,187, 42,103, 21,
    143, 75,175,121, 55, 91,115,148,  3,210,120,
    198, 47,143, 34, 67,246,111,235,167,193, 99,150,180, 20, 74,215,  //  26
    125, 97,190, 19,242,170, 30,189,111,159,128,  4,166, 30,217,186,
     72,149,119, 76,153,221,170,  4,149,182, 93,166,221, 50,213,119,
    228,164, 34,187,142, 95,215,164,129, 20,225,168,209,148, 26,160,
    128,  7,149, 81, 22,143,110,247,127, 37,140, 14, 65,132,161,199,
    238,111, 30,248,195, 16,176,226, 86,173, 60,
     95,234,165,208,103, 24,157, 50, 80, 16,213, 58,240,108,144,185,  //  27
     42,167,228, 50,117, 72,144, 93,214, 64,184, 86,255,140, 56,121,
     23,236,169,208, 41, 87, 55,200, 46,251, 29,140,  8,101,153, 56,
     14,102,238,120, 17,252, 45, 73,198, 64, 38,118, 93, 60,241, 72,
    207, 98,188,251, 56,219, 83,196, 54, 79,200, 93,179,241,  7, 79,
     46,211,155, 62,130,219, 77, 42,134, 25,245,
     67,125,  5, 82,180,216,132,196,224,113,138, 29, 79,205,  8,253,  //  28
     82, 24,106,152,196, 16,226,174, 12,239, 36,198, 43,103,232,171,
    203, 49, 90,  7,185,144,237,122, 84,113,209, 76,242,191, 80,254,
    136,184, 49, 74,200,154,125,  6,237,141,161,255,  3,189,121,176,
     19,232, 41,116,163, 15,173, 30,156,237,115,218, 27,107,217,123,
    183, 87, 11,180, 93, 26,161,252,203,110,155,
    217,193, 54,255,118, 66,  9, 97, 41,161,251,190,128,165, 52,119,  //  29
    209,138,218, 63,237,124, 82, 43,137, 79,148,118,218,160, 14, 85,
    141,108,223,127,253,107, 19,158,223, 11,132,161, 55,121,166, 26,
    202, 89,144,219, 28, 87,230,171,111, 90,191, 73,135,224, 35,104,
    149, 78,137,217, 91,242,131,206,103,  1,173, 67,155, 51,167, 34,
    146,236,114,226,138,197, 53,101,  9,180, 48,
     18,100,163,140, 35,228,150,242,181, 70,  4, 92, 43,218, 96,172,  //  30
     60,182, 10, 94, 35,156,189,252,111,221,177,  8, 93, 65,191, 46,
    248, 19,175, 55, 30, 71,197, 42,180, 64,202, 32,233, 14,223, 68,
     44,229,  1,162,112,186, 50, 75,213, 19, 51,217, 28,162, 58,250,
    182, 30,202,  4, 63,112, 40, 72,229,142, 50,254,133,197, 91,244,
     61, 22,200, 44, 74,233,120,154, 72,227,141,
    173,230, 24,214, 96,170, 56,126, 26,109,210,158,236, 23,141,240,  //  31
     39,108,248,168,204,102,  1, 68,165, 23, 61,245,201,145,236,123,
    162, 74,209,150,217,132,232, 82,139,247,100,178, 86,148,106,181,
    126,170,102,247, 37,139,205, 26,149,240,122,173, 85,111,196, 93,
     53,236,109,165,190,146,222,163, 21, 89,202, 16, 76,226,  9,190,
    130,173,100,157,  1,175, 24,239,190, 37, 83,
    120, 57,130, 72,194, 13,207, 88,192,238,135, 61,111,191, 85,  5,  //  32
    199,151, 66,130, 49,238,136,216, 45,207,105,134, 30, 55,105,  3,
    198, 40,115, 87,182,101,  1,167,108, 18, 49,123,207, 40,216, 81,
    240, 21, 72,196, 65,232, 98,130,182, 57,201, 12,245,140,218,  7,
    123,152, 84, 44,213, 56, 27,192,116,240,179,127,105, 41,150,110,
     72,223, 53,252,115,215, 95, 55,131,106,242,
      3,186,245, 39,148,112,251, 46,155, 75, 22,178, 47,152,225,119,  //  33
     76,229, 15,217, 88, 23,192,116, 90,146,186, 78,166,227,182, 85,
    222,134,242, 13, 46,246,191, 68,222,197,165,239, 62,172,  7,140,
     55,202,131,155, 10,171, 41,253, 15, 83,103,157, 47, 79, 38,164,
    192,220, 21,240,123, 99,248, 82,150, 36, 60,159,219,176,248, 33,
    207, 12,146, 79,167, 37,143,178,220, 29,202,
    143, 98,159, 80,230, 31,167,132, 11,224,103,204,254, 17, 67,180,  //  34
    139, 38,191,108,178,144, 73,231,  9,248, 38,214, 11,128, 44,155,
     23, 62,173,146, 72,154, 30,129, 45,145, 81, 11,131, 94,252,184,
    112, 32,224, 83,113,215, 89,119,210,170,236,128,209,175,233,105,
     27, 67,137,173, 14,183,133,  5,221,101,205, 22, 82, 55,131, 93,
    182,120,232, 26,209, 64,246,  8, 88,160, 67,
     39,197, 16,209,101,188, 67, 96,199,171, 42,136, 80,124,214, 48,  //  35
    247, 94,158, 60,255, 38,164, 54,124,159, 69,111,240, 95,196,254,
    113,191, 93,213,112,225, 92,201,254, 26,115,223,196,158, 25, 79,
    217,167, 64,250,185, 21,160, 49,145, 65, 32, 75,  8,116, 64,148,
    244, 96,205, 55, 90,212, 63,159, 75,174,124,230,147,195,  5,225,
     66, 39,172,104,134,193,112, 49,204,114,253,
     90,222,123, 59,137,  4,213,239, 53,115,242,  1,165,196, 30,112,  //  36
    172, 19,213,122,  5,203,101,182,216, 20,205,178,148, 19, 64,140,
     37,230, 16, 52,181,  8,166, 56,103,162,186, 56, 35,110,228, 48,
    148,  4,120, 36,142, 60,238,194,  3,226,199,137,251,192, 20,214,
     42,165,115,251,148, 32,238,196, 29,253, 14, 94, 38,242,106,163,
    135,203, 81,241, 12, 86,162,235,135, 15,169,
     50,154, 32,180,235,162,121, 37,150, 75,158, 61,233, 95,144,230,  //  37
     81,135, 43,230, 86,130,242, 29, 92,135, 47, 87, 39,232,107,215,
     84,158,121,250,138, 68,239,127, 16,233, 89,138,244, 73,136,200,
     92,241,176,206, 99,219, 77,130, 88,114,163, 92, 39,157, 94,131,
     81,199,  2, 48,178,124, 96, 46,107,135, 57,189,127,170, 24, 55,
    255, 20,157, 47,180,222, 30, 58,181, 76,232,
    190,105,247, 86, 24, 61, 91,184, 22,212,190,110, 27,175, 71,  9,  //  38
    206,188,103,156,184, 46,152, 66,229,165,251,121,208,154,188, 24,
    174, 61,203, 33,100,191, 36,208,146, 65,197,  3,168,208, 15,172,
    116, 45, 80,133, 10,155, 43,174,249, 54, 25,183,219, 56,235,182,
     33,139,230, 79,220, 14,185,145,219,202,156,236, 63,212, 84,191,
    116, 95,217,140, 60,120,152,107,215, 28,124,
      6, 63,136,214,116,200,254,138,227, 96, 13,142,218, 45,244,151,  //  39
     38, 76,248, 13, 71,225, 18,201,113, 12, 58,183,  3, 78, 51,127,
    246,  5,145, 86,235,157,115, 84,178, 33,220,123, 46,105, 60,233,
     28,193,219, 57,245,188,119, 16,203,135,233, 76,118,146, 13,110,
    246, 60,173,101,153, 71,234, 56, 25, 84,  8,101, 40,118,155,224,
     36,176,  9, 85,249,188,  3,240, 90,163,206,
    233,174, 21,155, 44,168, 17, 77, 48,123,249, 64,198,129, 98,212,  //  40
    119,166, 49,137,207, 97,127,170, 75,194,146, 93,235,136,226, 90,
    194,104,226,171, 17, 53,214,  6,250,102,157, 77,192,248,133, 85,
    156,123, 20,168, 85, 34,214, 67, 98,159,  7,198, 32,177, 73,211,
    153, 21,123,201, 29,208,113,162,248,126,175,200,146,246,  2, 60,
    142,239,122,201, 35,102, 68,197,134, 39, 77,
    119, 94,196, 72,234,100,131,178,204,154, 35,167, 88,  5,186, 64,  //  41
     15,223,193,107,174, 53,253, 42,217, 30,243,115, 36,176, 18,165,
     34, 70,126, 62,219,136, 73,163,130, 51,235, 25,148, 10,178,214,
     50,255, 97,143,232,109,148,235,189, 46, 88,130,253,101,194, 42,
     92,190, 73,255, 51,140,  5, 92,190, 66, 35,219, 23, 71,173,102,
    208, 74, 48,167,135,216,172, 22, 58,252,150,
    215, 34,249,122,  9,212, 52,244,  3, 70,222,105,237, 53,162,250,  //  42
    130, 89, 28, 66,232,  1,158,102,135, 83,165, 70,200, 59,217,108,
    236,157,199, 39,183, 95,240, 40,186, 87,202,120,218, 53, 75,113,
     15,175,203, 62,  2,181, 54, 19,126,242,169,211, 52,156,  4,242,
    128,222,  9,149, 89,178,238, 47,138,229,107,134, 87,195,227,133,
     29,186,109,229, 12, 80,114,222,165,105, 14,
     75,159, 58,182,147, 82,161,116, 92,198,130, 19,194,137,109, 23,  //  43
    197,151,242,163,126, 91,208, 26,233,190,  7,221,125,154, 84,139,
     54, 15,255,112,153, 10,198,117,230, 12,167, 42,104,189,241,163,
    131, 78, 30,225,134,210, 96,173, 75, 36,106, 18, 75,230,138, 64,
    169, 45,117,186,221, 59,122,213, 22,169, 56,251,162,118, 15, 55,
    158,252, 21, 72,155,247, 45,142, 84,202,181,
    137,224,107, 26,204, 41,221, 32,236,164, 53,174, 79,215, 44,226,  //  44
     74, 40,109, 16,201, 58,131,172, 64,112,152, 55, 31,237, 11,210,
    189,124, 86, 32,228, 57,142, 33,100,145, 77,253,139, 89, 30, 60,
    234,192,153,107, 72, 39,244,141,197,225,149,186,122,202, 28,106,
    215, 85,236, 35,108, 15,160, 84,197, 79,  6,185, 36, 65,239,182,
     93,123,210,176, 38,124,187,  9,230, 29, 51,
     89,  1,168,234, 95,130,189, 68,141, 14,110,254, 36,157, 99,179,  //  45
    126,168,213, 52,177,225, 19,246, 36,212, 89,254,182, 98,164, 41,
     78,161,217,192,100,176,249, 71,219,188, 28,174,  8,222,149,206,
      6, 95, 45,249,165,191, 14,113, 65,  7, 85,247, 35, 95,178,149,
     14,192,159, 71,136,206,250, 38,117,238,139, 84,202,150,100,214,
     18, 60,141, 88,201, 97,236, 74,121,154,242,
    127,197, 45,141, 63,243,  8,122,177,217, 61,187,128,  7,238, 58,  //  46
     13,252, 85,146,115, 77,153, 93,120,165, 15,141,121, 64,227,115,
    246, 58,  1,144, 64,122, 20,164,125, 53,210,111, 64,184,119, 81,
    173,125,204, 23,121, 93, 57,228,168,214,139, 57,166,219, 48,252,
     66,125, 21,244,172, 62, 95,145,180, 29,211,108,231, 10,130, 72,
    163,237, 33,227,  2,157, 51,175,216, 62,187,
     19,255, 84,214, 20,170,103,227, 84, 30,149, 88,227, 70,201,146,  //  47
    188,106, 34,219, 11,242, 51,182,220, 71,193, 49,218,  6,195, 29,
    138,182, 96,237, 30,189,210, 96,  4,245, 88,152,238, 43, 20,250,
     53,223,147, 66,236,202,156, 31,125, 39,108,203, 15,133, 88,196,
    110,231,151, 97, 30,195,  1,227, 54, 88,157, 23, 59,169,246, 45,
    203, 98,189,118, 70,209,138, 17, 99, 39,107,
    164, 52,155,112,192,133, 41, 59,186,246,116,206, 44,172,114, 37,  //  48
     76,206,159, 63,179,134,206,  4,139, 39,235,101,149, 87,157,100,
    211, 45,128,201,159, 79, 39,226,141,169, 37,201,133, 83,203,140,
    103, 15, 88,180,  4,136, 75,254,198, 94,237,151, 79,233, 27,143,
      4, 57,203, 46,222,129,158,104,203,124,253,189,119, 81,193,110,
     14,150, 53,168,239, 28,110,250,198,144,224,
     67,121,229, 31, 69,250,204,156,129,  4, 58,159, 16, 96,247,131,  //  49
    224, 20,124,235, 97, 33,107, 79,249,111,170, 18,200,250, 50,175,
     16,242, 72, 13,110,248,129, 58,198,112, 70, 16,102,226,167, 47,
    191,154,232,114, 44,221,104, 21,178, 68,  5,175, 43,106,161,226,
    179, 86,136,174,109, 68,247, 28,172, 12, 75, 48,226,143, 31,224,
    128,255, 26, 83,134,184, 66,161, 80, 25,192,
    239,  5,202, 97,163,  9, 91, 35,231,106,193,240,137,210, 72,  2,  //  50
    150,180, 89, 47,200,172,229,157, 28,187, 57,129, 74, 27,115,230,
     84,145,172,223, 36,152,184, 93, 24,230,175,217,156, 64,  1,122,
    240, 72, 33,199,159, 59,187,150, 47,141,210,121,247,188, 74, 35,
    113,212, 24,242, 11,188, 48, 81,233,136,215,154,  3,186, 58, 91,
    175, 70,194,223, 97, 43,211,  6,229,130, 94,
    172,141, 47,182,127,214,115,184, 81,166, 77, 23,111, 51,190,234,  //  51
    104, 65,250,145,  7, 76,128, 53,201, 90,231,161,219,180,138, 58,
    204,119, 49, 91,204, 62,  7,240,120, 45, 84,127, 41,252,185, 90,
     25,209,134, 92,249,125, 10,231,115,243, 90, 58, 21,134,208, 58,
    250,129, 52,160, 87,138,210,155, 99, 40,182,111, 89,243,120,210,
      7,147,116, 16,155,245,118,146, 53,184, 35,
    109,218, 83,241, 64, 44,234,139, 15,211, 38,226,181,145, 26,160,  //  52
     42,192, 26,212,117,244, 20,215,138, 12,120, 46,  3, 86,211, 33,
    161,  6,251,178,139,107,210,166,141,196,238, 10,200,106,139,223,
    162, 50,179, 13, 69,196, 97,205, 70, 25,194,158,222,100,  8,171,
     92,191, 76,221,120,238, 16,114,201, 70, 19,232, 49,169, 23,156,
    241, 60,204, 53,188, 31, 78,204,103,252, 69,
    134, 22,160, 11,148,199, 25, 75,254,113,154, 97, 56,249, 83,112,  //  53
    219,132, 99,160, 67,169, 96,179, 69,254,184, 98,238,154,107,244,
     76,197,110, 20, 74,231, 32, 85, 17, 56,159, 94,149, 58, 21, 75,
    119,246,102,206,142, 31,164, 43,145,174,112, 38, 78,184,238,137,
     33,147,  5,199, 37, 65,177, 45,251,162,119,207,143, 79,196,103,
     36, 91,230,143,106,233,177, 13,161, 24,209,
     63,245,102,216,117, 85,176,152, 53,191, 65,206,122,  8,169,201,  //  54
     63, 11,230, 36,204, 51,236,115, 35,150, 59,136,192, 62, 21,171,
    129, 54,148,223, 42,153,116,198,253,107,187, 26,212,242,170,198,
      8, 62,155, 39,239,119,226, 86,239,  1,207,253,147, 48,111, 70,
    207,233,113,168, 98,148,229, 88,138, 33,187, 95, 11,253, 46,138,
    218,127,167,  9, 73,134, 57,221,129, 92,181,
     35,189, 52,169, 66,246,124,224,  3,134,233, 21,178,223,135, 32,  //  55
    243,144,181, 92,125, 22,143, 77,228,199, 15,220, 38,116,205, 83,
    234, 26,207, 80,184,243, 50,170, 70,135,229, 77,123, 34, 99,144,
    214,129,223, 80,175, 56, 15,183,105,134, 58, 97, 12,220,161, 17,
    175, 40, 62,255, 18,207,118,  9,212, 69,237, 57,176,113,204, 68,
    185, 25, 81,252,197, 27,170, 83, 44,235,150,
     83,222,137, 29,186, 16, 47, 92,185, 81, 42,148, 89, 40, 71,104,  //  56
    174, 81, 47,253,152,219,183,  4,165, 89,125, 79,176,250,147,  8,
    181, 97,164,126,  2, 94,132, 25,221,  5, 48,154,181, 65,230, 45,
     87, 36,185, 11, 96,217,141, 68,213, 32,167,188,119,199, 83,247,
    125, 94,189,132, 84,165, 59,194,109,158, 22,132,231, 31,160,  6,
    241,112,178, 46,153,218,105,248,194, 15,118,
    165,  1, 91,237,107,206,162,217,111,243,173,114,252,188,156,234,  //  57
     15,127,206,  9, 69,101, 59,208,132, 27,235,156, 24, 93, 57,228,
    118, 48,254, 60,218,176,207, 86,158,193, 98,249, 19,205,127,174,
    255,150,113,243,166,117,195, 25,156,245, 79,228, 64, 29,144, 52,
    213,159, 23,224, 50,240,143, 29,245, 87,216, 99,151, 76,224, 95,
    144, 38,224, 94,121, 59,  4,131,156, 69,214,
    252,128,201,156, 59,134, 78, 33,142, 24, 55,197,  6, 60,120,199,  //  58
     54,225, 96,164,193,239,119, 42,249,102,195, 66,224,133,203, 37,
    143,196, 18,111,142, 30, 58,247,114, 60,215,118, 83,148, 30,109,
      2, 63,200, 27, 74, 44,240, 89,114, 43,143, 22,128,175,223,109,
      6, 69,200,100,175,  4, 81,180,129, 40,174,  2,193, 52,129,182,
     69,205,157, 14,243,143,210, 39, 98,188, 49,
    102, 24, 79, 40,222,  8,253,191, 71,164,229, 94,143,213, 22, 91,  //  59
    146,183, 28,137, 54, 24,172,148, 74,177, 49,118,  1,169,107,177,
     71,237, 85,163,231, 99,167, 11,145, 33,167, 11,191,238, 77,218,
    180,232, 99,140,224,151,  5,172,222,190,101,204,248, 94, 39,188,
    148,245,118, 39,136,198,106,221, 72,205, 62,251,117,211, 38,247,
     20,122, 52,190, 69,175, 87,164,233, 18,143,
    173,194,242,115,181, 97,152,119,222, 12,129, 66,238,108,168,241,  //  60
     36, 66,249,114,217, 81,229,  9,205, 30,154,241,207, 80, 28,218,
     11,128,183, 36, 65,200,127,224,185, 89,244,136, 44,169, 54,135,
     92, 20,164, 54,109,209, 65,130, 52, 17,161, 59,  7,140, 71,237,
     85, 32,171,214, 64,234, 50,151, 12,163, 98,139, 25, 89,162,105,
    146,236, 88,220,113, 25,238, 61,121,204, 74,
     33,130, 64,165, 26,215, 37, 56, 96,180,207, 42,176, 30, 63,124,  //  61
    203,106,174,  2,155,195,131, 90,113,222,133, 91, 43,149,250, 97,
    158, 49,209,119,246, 20, 86, 42, 65,208,111, 68,220,100, 23,205,
    153, 48,193,248, 14,184, 98,251,196, 83,236,121,184,217,160, 14,
    127,221, 95, 13,161,123, 27,248,111,216, 35,170,191,230,  9,215,
     62,178,  3,151, 44,188,137,  9,178, 42,239,
    106,220,  5,231,136, 70,198,166,243, 34,112,154, 84,191,223,  9,  //  62
    162, 83,227, 48,101, 61, 38,255,183, 71, 16,175,196, 65,131,192,
     73,231, 95,  4,172,142,194,241,140,  5,177, 34,150,197,119,244,
     71,220,125, 83,135, 42,158, 29,106,140,208, 74, 33,100, 56,205,
    175, 63,144,253, 72,191, 93,174, 55,131,236, 78, 44,126, 69,186,
     39,102,207,125,247, 92,223,108,216, 89,157,
    202, 82,151, 51, 98,247,123,  8,140, 88,217,  1,251,133, 99,147,  //  63
    245, 21,138,206,168,236,148, 14,162, 52,244,105, 29,214,  7,114,
     41,167,136, 69,220,102, 31,116,169, 95,231,127,240, 16, 84,172,
     10,108, 31,169,202,237, 81,213,173,  3, 49,158,254,135,227, 25,
    106, 41,201,108, 44,231,139, 17,198, 87,  7,206,155,239,107,142,
    254,160, 32, 59,169, 15, 69,160, 55,132, 19,
     47,175,113,205,161, 20,183, 75,234, 53,178,120, 65, 23,214, 44,  //  64
     72,189, 64,119, 24, 78,210,122, 95,201,129,159,228, 94,172,237,
    202, 22,251,187, 40,160, 75,212, 53, 23,195, 81, 55,182,140, 44,
    198,147,243, 76, 50,111, 16,134, 68,244,182,109, 20,194, 84,129,
    187,240,  1,169,132, 30,211, 75,241,147,178,103, 62, 15,213, 29,
     73,119,233, 82,212,143,195, 37,228,180,253,
    126, 13,242, 35, 80,217, 49,114,200,155, 27,229,193,162, 89,179,  //  65
    126,221, 38,249,179,109, 44,186, 34,232,  4, 74, 50,139, 36, 67,
    144, 86,108, 55,129,239, 20,179,255,153,119, 29,212, 98,249, 69,
    226, 92,189,  4,227,155,192,221, 40,119, 81,210, 65,151, 40,234,
     70,148, 89,225, 79,183,111,162, 45,116, 25,252,134,196, 93,163,
    222, 14,189,132, 22,102,235,117,  2, 94, 67,
    220,188, 58,129,177,100,144,224, 16, 95,131, 77, 36,116,231,  7,  //  66
     81,159,100,146,  6,231,142,222, 65,152,114,179,199,253,118,191,
     13,209,163,222,  9,196, 83,125, 61,102,226,166,131,  2,161,120,
     18,136, 56,166, 85,126, 30, 96,159,232,146, 10,241,117,181,  9,
    163, 46,118,198, 24,247, 65,  5,224,190, 77,213, 35,173, 50,130,
    199, 56, 92,174,250, 48, 78,170,136,199,159,
    104, 78,149,227,  3,254, 31,168, 61,187,244,158,206, 57,144,192,  //  67
    239, 20,216, 75,198, 54, 93, 12,173, 86,242, 43,104, 10,164, 90,
    241,122, 29, 79,143,104,218,148,  6,202, 43, 72,236,196, 41,217,
    185, 35,239,105,211, 53,252,174, 14, 57,198, 48,171, 86,216,101,
    202,249, 17,145, 54,154,125,177, 94,138, 51,154,109, 71,246,  1,
    100,154,228, 40,117,149,190, 60,241, 22, 52,
    248, 16,209,108, 60,194,125, 87,234,113, 51,  6,107,255, 29, 99,  //  68
     48,135,176, 36,127,165,251,116,215,136, 19,208,153, 69,215, 42,
    147, 64,184,245,169, 59, 35,174,235, 90,183, 22, 88,117, 61,103,
    156, 84,196,140, 20,187, 69,129,218, 86,111,137,221, 29, 54,141,
     66,128, 91,219,190, 83,204, 37,242, 17,197,231, 23,209,119,179,
    237, 34,129, 74,201,  8,220, 30,108,210,144,
    124,184, 37,166, 83,152, 46,203, 11,146,218,172, 83,183,129,167,  //  69
    206, 63,245,103,208, 71, 41,192, 29, 63,184,125, 91,230, 22,197,
    105,229, 47,115, 15,193,249,109, 51,121,155,250,136,176,231, 21,
    254,127, 70, 46,230,154,109, 33,183,148,250, 23, 96,157,245,190,
     39,226,174, 34,112, 10,231, 57,151,105, 80,127,177, 88,152, 27,
     67,210,170, 18,238,104,163,129, 80,172, 41,
     94, 56,137,245,205, 21,241,108,174, 70, 25,119,210, 60, 13,227,  //  70
     89,123,  2,155, 28,225,142, 97,163,220, 79,244, 33,178,137, 77,
    171,  4,153,203, 90,133, 73, 25,144,220, 11, 66,209, 43,151, 79,
    199,  6,217,169, 97, 12,207,238, 76,  2,190, 70,204,121, 17,112,
    166,  4, 70,134,254,165,101,129,211,181,248, 64, 13,235, 51,201,
    143,112, 91,188,142, 85, 36,255,196,  5,234,
    199,228, 76,  7,104,131,161, 53,224, 96,246,150, 38,237, 75,151,  //  71
     31,185,214, 88,179,118, 13,235, 44,121,  2,166, 57,106,250, 49,
    220,131, 70,233, 27,216,157,230,187, 77,198,113, 27, 99,190,114,
     60,149, 37,125,246, 72,139, 43,165,122, 50,236,169, 61,228, 79,
    208, 98,235,187, 50, 77,195, 29, 73,  3, 48,170,138,189,115, 86,
    226, 21,251, 66, 43,224,185, 58,141, 74,155,
     18,110,150,188, 45,213, 85, 26,192,137, 59,195, 94,134,190,109,  //  72
    249, 68,130, 46,247, 67,203,172, 84,151,228, 93,207,127, 13,192,
    102, 25,187, 98,169, 59,113,  1, 98, 34,163,233,142,246, 12,215,
    171,241, 89,182, 54,200,105,186, 92,225,150,110,  9,143,185, 32,
    132,159, 44,104,152, 14,219,139,233,158,122,225, 99, 35,248,  7,
    158, 59,135,204,167,125, 26,102,213,118, 47,
    166,215, 30,234,171, 62,232,167,117,  3,213, 31,170,  8,216, 43,  //  73
    169, 15,223,158, 23,145,101, 55,255, 21,183,136, 24,235,162, 84,
    154,241, 62,137,244, 38,205,171,253,133, 58, 84,178, 48, 73,131,
     50, 23,116,220,  8,160, 34,253, 18,199, 36, 86,202, 49, 99,252,
     59,218, 18,203,242,121,176, 38, 93,194, 82, 24,205, 61,168,122,
    191,218, 36,103,  6, 78,241,159, 12,245,191,
    130, 58, 80, 99,124, 11,144, 90,243, 76,155,110,251, 56,101,147,  //  74
     80,199,112, 90,187,213,  8,130,197,108, 50, 75,193, 67, 44,214,
    124, 37,200,  9,108,152, 71,122, 49,183,224,  7,121,220,151,237,
    100,195,155, 78,134,209,115, 60,140, 68,177,247,128,225,172, 11,
    190,122, 86,141, 28, 91, 63,239,118, 45,253,179,145, 90,212, 45,
     99, 75,152,234,180,207,135, 54,177, 69, 92,
     23,253,193,146,240, 77,185, 24,199, 40,223, 82,126,188,235, 24,  //  75
    226,133, 61,237, 50,120,227,169, 37,146,212,243,103,141,179,  6,
     73,222,163, 83,180,216, 20,235, 91, 23,150,100,203, 30, 85,175,
      2,225, 58,249, 24, 85,233,167,214,119, 13,154, 71, 24,118,150,
     70,228,170, 56,186,215,164,  6,207,141, 76,  8,114,239, 27,142,
    243,176, 29,126, 61, 19,110,233, 33,142,226,
    157,115,  9, 53,204, 38,225,102,133,170, 60,181, 17,150, 74,114,  //  76
    175,  5,160, 33,176, 85, 30, 70,237, 87,  7,155, 39,219,116,254,
    151,110, 53,248, 33, 95,140,166,194,214, 70,244,165, 63,197,113,
     65,137,183, 41,152,187, 45,  4, 95,240, 82,210, 42,217, 90,242,
     44,107,  5,250,110, 37,136,101,180, 33,167,231, 59,158, 79,195,
      2, 65,220, 95,253,164, 80,190, 99,207, 46,
     88,218,181,155, 94,126,160, 49,253, 11, 99,237, 51,199, 32,207,  //  77
     53,252,104,217,135,247,162,106,202,122,177, 65,190, 19, 87, 50,
    187, 27,141,195,121,223, 54, 10,114, 42,127, 34,136, 12,255,145,
    211, 28,120, 90,214,107,135,203,158, 28,193,130,104,159,194, 17,
    179,142,205, 81,153,228, 77,244, 60,221, 94,122,202, 19,225,106,
    132,156,193, 22,139, 51,223,147,  1,122,183,
     17, 61,104, 29,247,  4,209, 71,190,120,153,205,136, 90,244,158,  //  78
    129, 85,182, 18, 68,113,  2,182, 58, 26,250,100,131,237,159,208,
     97,237, 73,  3,161, 69,187,250, 82,160,236,189, 86,178,102, 38,
     82,241,163,231, 10, 73,250, 54,124, 64,171, 54,254, 28, 80,128,
    232, 92, 32,181, 52, 12,192, 25,125,151, 12,185, 49,129,173, 47,
    249, 88, 43,112,210,181, 35, 75,248, 66,229,
    172,124,231,189, 75,173,106,146, 21,222, 41, 78,  1,174,105, 67,  //  79
     13,213, 46,152,193,213, 48,233,132,214,151, 15,200, 76, 37,135,
     13,171,206,108,240, 34, 98,138,216, 57,  3,105,215, 49,225,165,
    200, 14,105, 61,198,161, 26,177,228, 87,212,  8,146,182,223, 55,
    158, 63,244,124,213,145,114,171,212, 42,228, 74,247, 93,208, 73,
     23,213,168,240,  8, 99,126,200,157, 39,138,
    245, 36,149, 52,130,226, 33,241, 93, 59,167,248,124,226, 26,193,  //  80
    237,137,110,243, 25,130, 84,153, 95, 36, 72,223, 49,115,179,230,
     62,122, 42, 82,147,212,171, 17,121,175,203,139, 67,151, 18,118,
     54,150,188, 32,142,115,218, 97, 15,154,110,230, 93, 41,118,  1,
    201,115, 15,165, 94, 60,255, 87, 64,111,177,142, 32,162,  9,147,
    186,121, 55,138, 73,161,235, 16,111,215, 95,
     68,196, 91,207, 14,157, 57,185,127,211,104, 28,197, 57,116,146,  //  81
     40, 72,186, 92, 55,174,254, 12,206,184,106,168,143,240, 18,103,
    211,159,234,185, 23,117, 53,234, 72, 26, 81,228, 31,249,182, 92,
    233,128,252, 91,208, 69, 44,139,245, 42,198, 58,137,240,166,216,
     97,181,220, 48,231, 30,196,  5,159,240, 19, 96,216,113,240, 84,
    228, 98, 31,204,184, 27, 62,178, 80,190,  8,
    162,116, 22,255,118, 95,217, 78,152,  7,183,142, 86,160,214, 88,  //  82
    172,209,  4,145,225,117, 68,160, 42,127,246,  7, 87,196, 67,173,
     35, 78, 11,132,255, 78,204,140,193,244,114,164, 96,129, 63,203,
      3, 73, 41,166,  9,242,171,196, 72,124,168, 22,185, 67, 24, 83,
    148, 22, 76,119,147,175,105,140,204, 50,133,182, 55,193, 65,130,
     18,165,255, 83,115,211,142,251, 31,137,221,
     28,228,180, 78,168,197, 46, 26,251, 82,225, 42,241,  9, 52,253,  //  83
     20,106,240, 43,194, 22,216,111,233, 63, 32,202,128, 39,141,251,
    116,149,221, 89, 43,167,  5, 93, 42,153, 65,188,  8,211, 34,139,
    171,213,111,222,134,101, 35,110,  3,221, 83,250,102,206,133,228,
     41,245,160,203, 13, 74,235, 38, 95,224, 70,252,  1,140, 39,217,
    183, 63,148,  3,228, 46, 90,120,171, 52, 99,
    153, 65,138, 43,  2,141,235,101,163,117, 63,133,178,112,194,125,  //  84
    148, 68,162,126, 87,169, 50, 79,180,141,216, 76,176,230, 96,  2,
    199, 51,171,112,211,135,232,183,125, 14,221, 51,240,156,101,231,
     80, 28,148, 51,185, 64,229,162,206,143, 41,129,  7,156, 47,105,
    191,127, 52, 96,249, 43,199,128,187, 28,119,152, 83,229,161, 80,
    111,210, 40,101,158,181, 18,216, 68,193,243,
     48,215,103,239,207, 64,115,185, 14,210,190, 24, 92,221, 73, 33,  //  85
    231,201, 53,220, 11,243,136,201,  3, 97,163,116, 17, 62,209,167,
     71,237, 17,194, 66, 21,107, 73,249,171, 94,142,118, 41,181, 58,
    122,193,241, 87, 17,203,123, 23, 56, 97,234,179,213, 80,237,169,
     73, 26,221,179,139,110,162, 10, 76,164,210, 22,197,116, 32,244,
     10,135,172,245,128, 61,239,146,108,  5,126,
    176, 13,189, 84,126,171, 31,224, 76,136, 51,234,150, 13,159,187,  //  86
     96, 23,115,178,100,155, 35,117,251, 59,225, 41,247,150,113, 25,
    129, 99,146, 37,247,151,218, 32, 57,208, 25,195, 72,209, 20,244,
    162, 14,104,173,234,153, 81,255,182,151, 15, 60,107, 36,198, 10,
    147,204, 82,  3, 59,222, 88,206,242,104, 49,235, 98,177, 61,189,
     89,225, 52, 78, 13,192, 95, 27,201,229, 81,
    246,112,148, 21, 53,249, 89,149, 40,246,100,171, 67,120,247, 59,  //  87
    135,166,250, 47,208, 68,225, 84,160, 27,181,132, 89,186, 45,243,
    181,211, 82,174,118, 87,191,165,136,104,155, 49,254,102,149, 82,
     47,201, 66,133, 49,106, 34,132, 76,222,117,164,247,144,124, 62,
    252, 97,137,239,169, 31,148, 61, 27,145,184, 65,138, 17,222,145,
    118, 22,186,213,112,227,158, 55,169, 40,144,
     26, 63,202,229,157,193,  9,213,116,162,  3,213, 34,197, 91, 39,  //  88
    209,  2, 76,147, 24,122,180, 19,212,122, 73,207,  6,220, 77,144,
     52,  7,235, 61,206, 51,  6, 93,238, 15,228,120,163,  4,190,126,
    216,145,251,  1,217,167,196,215, 19, 46,189, 81, 24,184, 93,213,
     34,167, 48,116,202, 99,254,189,126,232,  5, 92,248,165, 78, 53,
    252,161, 99,147, 28,134, 77,253,124, 99,210,
    134,170, 96, 32, 73,131,103,173, 62,201, 73,112,238,133,170,230,  //  89
    110,181,224, 97,194,245, 57,142, 91,241, 46,150,105,166, 29,205,
    108,160,124, 21,147,243,131,211, 61,181, 84, 34,215, 60,237, 28,
     97, 37,115,188, 86, 22, 61,147,109,242,135,211, 50,229, 17,160,
    120,192,229, 23, 63,131,  8, 80, 40,165,115,194, 37,121,215,  3,
    197, 37, 66,241, 48,182,  1,203, 31,184, 77,
    219, 46,252,120,218, 43,244, 19,229, 38,145,185, 52, 15, 79, 30,  //  90
    152, 58,129, 41,166,  6,104,203,169, 13,189,228, 62,246,120, 88,
    239, 64,222,179, 84, 31,167,110, 38,125,207,171, 77,143,111,158,
    227,179, 71,151,231,127,248, 88,175, 65,  3,101,170,117, 82,244,
     71,  6, 90,147,180,217,162,227, 97,211, 52,227,153, 87,184,110,
     81,128,171,201, 94,223,105,143, 66,229,  9
    ,

    //
    // Yellow
    //

     28, 84,145,176, 68, 21,101,253, 50,178, 35,225,  7,162, 28,195,  //   0
    152,115, 55,  4,212, 39, 67,148,110,171, 15,235, 84,225, 10,252,
    134, 99,170, 69,224, 90,172, 53,141, 76,132,  7, 97,210,116,241,
     96,176, 49,108,243,183, 68,253,139,171, 55, 23,106,223, 20, 89,
    153, 42,164,121, 98,168,231,111, 22,124, 66,209,107, 41,130,102,
     20, 91,145,189,221, 51,240,151, 31,250, 71,
    127,239, 12,204,129,227,155,  6,204, 94,149,124,201, 58,142, 73,  //   1
     15,173,255,104,126,239, 15,197, 87,253, 51,193, 31,165,107,152,
     59,222, 31,119,154, 18,244,112,220,194, 62,227,143, 21,165, 35,
    147,226, 16,201,133, 47,158, 98, 18,202, 85,248,189, 46,138,232,
     65,247,  3,203, 47,139, 11, 63,217,181,248, 30,148,186,252,158,
    215,121,243, 34,108,138, 85,211,172,114,182,
     50,158,108, 54, 28,192, 78,126,161, 25,245, 44, 83,222,116,238,  //   2
    208, 39, 89,197,160, 86,138,228, 30,126,156, 79,136, 93,218, 41,
    203, 79,147,248, 60,202, 44, 87,156, 38,108,164, 56,246, 87,190,
     80, 64,138, 93, 33,215,126,191, 52,235, 69,122,146, 93,183,116,
     33,180,142, 84,235,184, 81,199,134, 85, 52,120,230, 10, 85, 59,
    180,  4, 69,154,182, 15,194, 70,  7, 95,224,
    206, 78,219,167,249,113, 43,231, 64,213,105,190,164, 21, 65,159,  //   3
    100,134,224, 63, 23,188,105, 55,180,100,218,  2,246,197, 70,172,
      6,112,185, 23, 97,167,119,189, 12,254,185, 26,198,110,132,217,
     20,255,195,163,240, 81, 24,226,116,156,  6,177, 38,240, 15,215,
     78,127,223, 54, 24,120,251, 32,170,  1,157,204, 97, 67,223, 34,
    137,203, 97,223, 41,248,127, 46,237,146, 24,
    173,  1,134, 91, 61,146,183, 27,173,121, 10, 71,137,249,183,  3,  //   4
     56,175, 14,147,245, 43,221,155, 12,203, 59,168, 40,123, 20,243,
    132,227, 46,209,133,237, 31,218,137, 69,127, 82,220,  5,176, 42,
    156,119, 50,  4,112,180, 66,170, 91, 42,196,227, 80,168, 61,153,
    199, 12,106,191,163, 71,149, 98,227, 69,242, 43,141,173,198,100,
    236, 54,168,129, 63,100,163,213,120,185, 69,
    127, 45,240,196, 14,218,100,245, 91,148,237,202, 33, 90,126,206,  //   5
    243,108,194, 76,119,171, 79,129,248, 74,140,228, 84,186,149, 49,
     94,160, 74,173, 15, 62,150, 99, 52,169,237, 48,155,100, 63,238,
     96,184, 75,231,149,211, 14,250,142,217, 98,134, 25,117,223,102,
     43,250,145, 89,238,  7,218, 40,125,194,110,184, 16,117, 25,157,
    122, 29,244, 20,216,192, 74, 26, 84, 35,254,
    189, 83,154,109,172, 52,130,  3,192, 39, 62,174,107,213, 47, 77,  //   6
    148, 42,233, 31,216,  4,204, 37,110,191, 23,119, 54,237,106,212,
    192, 12,253,107,221, 82,197,246,  2,195,111, 18,230,191,127,205,
     11,142,202, 27, 57, 96,126, 40, 79, 11,162, 52,254,191,  3,136,
    176, 75, 25,211, 50,132,174,203, 63,150, 36, 81,207,246, 52,220,
     70,185, 90,151,109,  3,149,235,198,157,101,
     39,231, 66, 27,234, 81,201,162, 74,212,132, 20,233,138,170, 27,  //   7
    189, 82,130,161, 98,143, 66,230,167, 48,156,203,  8,171, 66, 23,
    127, 60,148, 43,125,177, 26,117,157, 91,214,143, 83, 29,165, 55,
     82,248,100,133,173,239,201,154,188,238,119,206, 69,148, 81,235,
     59,203,158,115,184, 80, 28,102,245, 12,232,162, 57,146, 92,192,
      6,135,210, 43,174,251, 65,128, 11, 59,211,
     16,169,117,205,134, 20,241, 45,119,254,102,160, 78, 11,250,118,  //   8
    224,  7,206, 59,252,182,118, 28, 99,213, 90,255,135, 83,222,151,
    240, 89,208,167,  8,237,141, 70,224, 28, 60,176, 51,240,114,219,
     33,157, 47,227, 80, 22, 49,104, 65, 32,174, 18,109,179, 39,209,
     18,128, 97,228, 16,255,148, 55,122,186, 84,126,219, 11,114,163,
    255,105, 57,229,127, 36,104,176,229,110,140,
     82,214, 48,157, 57,181,105,149, 16,179, 30,202, 50,180, 95, 55,  //   9
    152,107,177, 38, 81, 17,200,151,244, 21, 60,111, 38,193, 29,110,
    180, 40,104,227, 80, 58,204, 39,169,104,252,118,205,  8,146, 98,
    193,118,209,  8,188,130,167,230,208,146, 91,216, 49,242,134, 91,
    162,246, 72, 53,167,108,198,223,166, 46,209, 30, 77,176,236, 32,
     79,146,196, 22, 75,186,218, 23, 87,163,247,
    182,131,  5,252, 93,218, 86,198,230, 55, 92,232,147,215,127,195,  //  10
     20,241, 91,215,137,231, 48, 71,127,170,190,147,220,162, 63,230,
      3,142,191, 26,129,183, 98,244,132,194, 14,150, 93,188, 62,246,
     15,168, 71,146,110,253, 73,  1,124, 41,248,116,161,  8,193,118,
     33,186,  4,201,134, 44, 24, 78,  3,108,147,251,191, 43,136, 65,
    225, 15,169, 99,239,151, 56,141,193, 31, 51,
     73,229,103,176, 36,145,  7,128, 80,168,134,112,  1, 81, 37,227,  //  11
     82,168,124, 10,161,101,176,220,  1,104,229, 13, 50, 99,209,131,
     77,251, 87,160,241, 35,156,  6, 78, 45,214, 66,237,128,171, 43,
     79,232, 32,219, 55, 25,199,160, 84,183, 60,198, 70,102,221, 56,
    231,140,105,221, 92,240,188,124,244,183, 70, 15,115, 95,205,159,
    113,209, 45,136,203, 12, 84,245, 99,206,121,
     24,147, 60,204,120,233,172, 59,210, 38,241,181, 61,247,171,142,  //  12
     42, 64,202, 53,242, 23,131, 83,195, 43,136, 75,249,122, 24,175,
     47,200, 14,106, 51,201,115,222,180,107,164, 22, 84, 39,222,120,
    183,130, 98,158,192, 85,137,233, 29,220, 11,139,240,153, 22,164,
     76, 44,178, 25,157, 60,144, 93,158, 52,217,137,167,232,  2, 55,
    182, 89,235, 62,117, 42,181,127,  3,153,238,
    188,213, 17,161, 78, 27,104,247, 18,156, 72, 23,198,118, 15,106,  //  13
    182,254,136,104,185, 76,228, 33,159,245, 96,205,182,153, 70,232,
    144,114,169,225,135, 88, 24,142, 63,240,123,218,191,156,  2, 90,
    215, 48,248,  9,121,241, 39, 62,107,129,174, 84, 34, 63,188,113,
    203,253,120, 74,228, 11,211, 33,232, 19, 81,194, 34, 76,132,250,
     36,148,  9,171,253,155,214, 67,223, 82, 42,
    110, 90,133,248, 47,215,182,135, 92,201,109,224, 89,155,235,206,  //  14
     26, 94, 38,218,153, 50,144,207,111, 56,147, 30, 60,  5,192, 96,
     19,238, 37, 66,207,175,253, 46,202, 13, 78,143, 58,106,255,163,
     20,144,197, 67,167, 78,182,211,159,250, 51,195,216,122,232, 89,
      7,147, 36,193,130,172,113, 66,186,133,113,247, 57,212,176, 94,
    215,125,191,103, 73, 25,109, 46,186,133,170,
      8,227, 40,185, 99,151,  9, 62,229,143, 52,169,132, 44, 82, 63,  //  15
    141,231,168,  4, 90,250, 15, 71,179,  9,225,170,106,240,125,207,
     61,179, 93,155,  1,120, 77,161,100,182, 43,232, 32,204,134, 66,
    208, 92,112, 37,226, 25,143,  5, 68, 85, 24,111,161, 15,145, 50,
    172,216, 63,239, 83, 52,250,147, 98,221,174,  8,104,146, 19,120,
     86, 28,229, 41,218,193,145,238, 18, 74,245,
    139,164, 74,122,231, 72,203,124, 37,183,  5,248, 30,215,164,  8,  //  16
    194,115, 69,211,122,191,106,231,126,196, 80,130,210, 86,156, 33,
    110,213,133,246, 50,228, 21,217,126,245,153,114,177, 93, 24,174,
     43,244,184,134,206,105,234,122,198,222,136,238, 59, 97,249,197,
    101, 20,136,106,  2,183, 24,202, 53, 28, 78,156,229,192, 64,238,
    197,153, 75,166,133,  8, 91,172,121,202, 55,
    216, 28,204, 11,143, 34,161,255, 78,113,203, 93,119,185,102,246,  //  17
     90,156, 46,175, 30,150, 44,166, 28, 64,254, 18, 42,185, 67,251,
    166, 10, 72,183,107,192,138, 41, 67,  5, 90,207, 18,239,111,224,
     76,152,  6, 83, 51,157, 90, 44,164, 17,183, 36,209,177, 68, 28,
    123,236,178,210,158,232,131, 92,164,245,207, 38, 90,126, 44,165,
    102,  4,248,113, 61,243, 48,214, 31,161, 98,
    115,182, 93,244, 57,216, 97, 24,175,236, 59,159,229, 17,137, 41,  //  18
    218, 19,237, 99,219, 66,242, 95,217,158,105,144,229,119, 16,135,
     53,230,121, 26, 62,161, 90,201,169,222,130, 50,164, 64,138,195,
     34,121,202,171,241, 13,179,254,110, 64, 85,154,120,  3,140,224,
    159, 56, 85, 72, 41,111, 63,219,  6,114,137, 67,173,251, 14,209,
    134, 55,189, 31,178,203,142,111, 71,254, 42,
    234, 55,128,156,181,118,192, 56,149, 12,133, 37, 85, 73,200,168,  //  19
    120, 74,189,131, 10,142,199, 20,133, 36,191, 56,162, 91,196,221,
    102,192,154,240,205, 10,245,116, 77, 34,187,249, 79,214,  4,163,
     98,233, 27, 58,141, 79,204, 27,146,192,232, 46,243,100,184, 86,
     37,202, 24,252,146,193, 33,149,182, 48,195, 18,218, 98,149, 72,
    233, 95,216,131, 72,102, 17,225,148,  1,169,
     88, 13,223, 38, 68,  4,230,127,213, 92,224,194,166,252, 26, 60,  //  20
    210,151, 48,253, 78,181,113, 60,175,244, 79,212, 10,245, 44,151,
     23, 81, 36, 99,132, 86,149, 19,232,144,105, 15,150,124, 56,252,
     72,135,210,109,218, 36,132, 84,224,  8,131, 74,189, 39,216,117,
    243,138,174,121, 12,226, 94,243, 71,105,235,152,117, 53,194, 31,
    176, 39,158, 13,235,161, 57,180, 94,199,124,
    212,142,195,108,250, 87,159, 21, 68,181,113, 50,  6,144,115,237,  //  21
    100,  2,173,118, 39,231, 88,207,  7,110, 45,139,103,178, 68,117,
    181,212, 58,220,179, 37,208,176, 66,206, 47,180,224,101,194, 36,
    176, 10,161, 89,183,246, 61,176, 49, 98,211,165, 16,147, 72,170,
      7, 63,101,216, 66,170,132, 18,209,171, 24, 69,204,  1,229,126,
    106,254, 86,112,186, 28,249,121, 37,237, 60,
    166, 98, 27,175,136,200,100,242, 41,151,236, 72,207, 94,186, 35,  //  22
    137,229, 69,201,145, 17,165,127,223,152,196,231, 32,125,218,  8,
    249,133,167,  5,117,255, 91,110, 25,122,242, 83, 61, 23,154,218,
    110,242, 65, 38,122,  1,147,207,124,248, 37,114,202,253, 52,108,
    193,224, 22,187, 84, 51,199,114, 44,135, 94,248,138,171, 86,161,
     18,192,138,209, 51,148, 86,189, 70,154, 29,
    246, 53,225, 77, 14, 47,171,124,207, 79, 14,169,124,228, 51,160,  //  23
     86,180, 23,104,220, 61,249, 42, 93, 26, 65,167, 90,192,153, 83,
     49,107, 75,228, 62,142, 43,234,151,196,  5,136,166,239,130, 78,
     52,144,193,230,168, 99,226, 69, 18,170,146, 61, 94,136, 20,235,
    149, 91,159,131,236,  8,152,255, 76,220,194, 58, 36,105,242, 62,
    218, 45, 73,  3,226,104,205,136, 15,197,118,
      5,181,121,156,237,212, 67, 33,179,111,139,247, 30, 67,196, 11,  //  24
    213,123,247, 49,170,123, 82,159,189,241,126,  1,253, 56, 27,234,
    170,201, 28,154,195, 15,165,203, 58, 93,176, 53,203, 94, 11,181,
    211, 17, 88,133, 22,190, 44,112,197, 87,236,  4,219,181, 87,127,
     31, 54,250, 35,112,209, 95, 37,168,  6,153,119,184,210, 28,133,
    103,180,241,159,124, 62, 22,234,109,221, 77,
    141,209, 62, 35, 96,118,150,250, 19,221, 42,181, 84,146,111,242,  //  25
     97, 41,157, 76,196,  4,205, 32,112,145, 76,214,107,141,205,119,
     13,140,246,102, 88,239, 71,126, 29,226,114,248, 34,121,229, 43,
    152,115,220, 54,248, 79,155,240,139, 32,182,119,154, 38,211,170,
    222,117,198, 87,169, 57,184,133,226,108, 50,236, 12, 88,152,195,
     10,144, 87, 31,178,246,150, 76,174, 48,163,
     33,102,254,190,168,  2,197, 88,142, 58, 99,213,  7,233,164, 53,  //  26
    141,207, 12,235,106,140,224, 73,233, 16,198,155, 38,181, 62, 91,
    224, 68, 43,172,130, 40,215, 99,186,148, 19, 75,156,192, 67, 99,
    253, 33,184,104,147, 34,212,  9, 63,227, 93, 49,232, 70,107, 17,
     62,181,  1,145,217, 26,234, 66, 21,203, 80,176,128,219, 41,249,
     58,228,110,201, 53, 97, 33,209, 10, 85,235,
     57,126, 18,138, 70,231, 52,109,234,191,160,131, 64,202, 91, 17,  //  27
    189, 64,115,173, 33, 89,166, 53,177,102, 44, 70,220, 11,246,135,
    186,107,217,  2,230,182,143,  9,244, 49,208,130,222,  2,171,135,
    199, 71,161,  5,202,121,179,102,128,161,207,144, 11,191,160,240,
    141, 99,228, 55,125, 97,151,114,175,129,244, 27, 63,162,111, 90,
    126,173, 23,222,129,193,162,119,250,132,188,
    226,160,197, 92,214, 32,132,172, 10, 80, 25,254,108, 35,180,122,  //  28
    250,154,220, 46,198,254,116, 22,204,125,248,172,128,101,162, 20,
     54,148,198,121, 60, 26, 79,170,117, 70,182, 91, 51,105,238, 59,
     16,127,240, 91,231, 70, 47,254,194, 16, 57,114,250, 81,130, 39,
    201, 68,159, 23,239,186, 10,250, 43, 69,157,105,202,233, 13,188,
    215, 51,146, 71,  5,239, 43, 65,179, 26, 79,
      6, 67,237, 48,120,184,239, 71,217,121,209, 48,171,140,227, 46,  //  29
     97, 25, 80,143, 73, 11,153,236, 86,158,  7, 84,234, 49,196, 88,
    240, 37, 74,161, 98,251,202, 45,212,142, 13,252,151,205, 26,145,
    225, 81, 46,188,137, 17,162, 94, 38, 82,221,180, 30, 52,228, 95,
     11,253,107,175, 82, 62,208, 91,190,222,  2,184, 46,133, 72,151,
     34, 85,255,182, 83,148,113,226, 96,151,211,
    177,103,140, 11,159, 96, 18,153, 39,185,149, 73,236,  4, 71,212,  //  30
    135,194,238,113,212,181, 59,135, 33,222, 56,187, 21,150,217,114,
    173,208, 18,227,187,124,150,102, 28,230,111,172, 34,124,187, 91,
    175,211,152, 29,108,220,198,143,230,171,126, 96,146,199,169,119,
    184,134, 41,213,141, 29,161,131, 32,112,145, 89,252, 26,195,115,
    234,163, 19,109,219, 36,172, 14,200, 41,120,
    251, 33,207,182,244, 60,197,112,247, 97, 16,116,199, 98,165, 20,  //  31
    177, 52,  8,168, 30,106,219, 96,195,107,143,210,117, 75, 32, 58,
    132, 93,144, 83, 58,  7, 87,241,175, 74, 48,208, 83, 64,243, 44,
    111,  9, 66,250,178, 74, 52,105, 19, 67,246, 11,215, 88, 18, 66,
    219, 57,198,  5,246,111,231, 59,170,242, 53,207,152, 98,218,  5,
     76,203, 60,131,199, 74,236, 57,137,222, 86,
    145,111, 54, 90, 23,135,222, 46,143, 65,225,176, 27,138,249,116,  //  32
     86,226,125, 65,244, 44,157,  3,174,251, 64, 35,175,247,166,224,
     14,254,193, 42,238,179,215, 20,128,200,145,  6,227,136, 15,158,
    228,132,171, 91,126,  2,244,129,211,152, 39,187, 54,130,248,147,
     26,163, 88,122, 66,172, 97,  8,215, 82, 28,125, 64,176, 48,160,
    123, 37,241,177,  9,152,123,194,102,165, 21,
    188,230,152,215,114,165, 74,182,  3,200,157, 59,231, 87, 45,208,  //  33
    158, 99,199,145,184,123,228, 55, 80, 21,130,228, 88,  4,137, 87,
    180,108, 27,166,117,139, 54,161, 93, 56,247,116,163,190,100,199,
     86, 31,207, 39,223,154,189, 45,178, 89,121,162,229,107,175, 74,
    236,101,225,148,191, 42,206,147,118,190,159,238, 10,224,108,237,
    193,144,105, 89, 53,250, 29, 81,  1,238, 62,
     35, 80,  8,177, 40,251, 31,108,235, 80,121, 34,106,150,186, 26,  //  34
     68,241, 42, 77, 13, 89,190,133,237,164,103,190,152,106,199, 46,
    126,213, 77,226, 93, 30,198,112,228, 32,170, 87, 25, 70,255, 49,
    144,238,110,188, 60,102, 30, 77,237,  9,218, 47, 86,  3,205, 44,
    124,181, 22, 49,241, 14, 88,255, 50, 19, 76,199, 90,143, 22, 61,
     81, 27,225,165,211,111,180,227,133,200,115,
    245,135,221, 65,127, 94,203,169,132, 26,253,180,212,  9,243,113,  //  35
    141,  1,161,205,252,110, 22,208, 97, 39,218, 17, 51,243, 24,233,
    157,  7, 50,152,205, 68,251,  4,183,132,213,106,205, 42,113,170,
      4, 95,160, 13,146,233,197,160,114,144,100,193,150,240, 98,158,
     14,209, 84,168,112,140,196,107,177,228,129, 35,113,184,208,157,
    253,178, 57, 19,128, 44, 75,158, 38, 71,153,
    175, 41,109,192,236,154, 10, 63,215, 54,151, 89,128, 75,167, 57,  //  36
    230,185,117, 28,135,176, 47,153, 60,181,137, 75,206,119,177, 70,
    101,187,247,114, 15,168,100,149, 48, 82, 20,241,144,180,225,129,
    215,195, 54,251, 89,118, 16, 56,203, 24,255, 40,126, 30,185, 58,
    246,138, 69,235, 57,220, 77, 24,143, 70,211,172,246, 67, 38,118,
     12,134,108,201,152,233, 11,187, 95,214, 15,
    206, 83,164, 47, 20, 78,229,148,104,190, 14,201, 45,221, 29,205,  //  37
     93, 51,223, 85,212, 75,235,119,223,  5,254, 86,161, 61,144, 36,
    219, 86,139, 57,229,131,190, 65,232,199,160, 75, 11, 95, 32, 59,
     79, 23,134,184, 65,213,137,244, 83,163, 68,177,214, 73,119,219,
    104, 30,201,122, 20,178, 40,165,234,  4,103, 51, 14,135,233, 96,
    216,192, 88,245, 63, 85,206,138,254,112, 60,
    131,  4,246,143,214,184,123, 49,244, 69,115,239,164,105,154,126,  //  38
    174, 18,150, 64, 35,144, 12,194, 73,109,171, 38,220, 21,235,197,
    113,167, 18,199, 83, 31,243, 13, 95,115, 37,188,132,237,158,187,
    244,106,222, 30,156, 45,175,105, 35,229,135, 97, 21,237,166,  8,
    151,187, 51,156,210, 92,243,113, 50,193,139,161,215, 88,177,148,
     76, 34,165,  8,182, 30,120, 56, 19,157,235,
    103,178, 67,117, 57, 98, 32,202, 23,172,143, 81, 33,230,  5, 73,  //  39
    254,105,233,169,191,248,100,165, 27,201,131, 68,185, 99,129,  1,
     51,240, 76,160,216, 50,121,164,221,140,252, 56,209, 65,116, 10,
    141,174, 87,120,242, 92, 12,217,187, 58,  4,203,149, 51, 92,207,
     63, 94,253,  1,110,145, 63,199,130, 89,251, 62,116,194, 56,  2,
    248, 61,219,141,105,239,150,226, 78,184, 34,
    149,221,199, 37,171,249,132,162, 91,215,  9,189, 60,137,185, 50,  //  40
    198, 40,131,  7,112, 66, 39,127,242, 49,226, 10,147,249, 78,178,
    137,194, 30,130,101,181, 90,205, 44, 81,  1,161,100, 27,203,227,
     71, 41,204,  2,179,206,115,150, 79,130,168,247,114,194,140, 34,
    230,129,167, 75,228, 28,172, 38,225, 29,168, 17,236, 36,105,204,
    156, 97,122, 49,207, 79,176, 43,116,203, 91,
     52, 18, 83,139,216,  5, 69,234,112, 55,252,118,214, 96,240,122,  //  41
    157, 81,212, 93,201,158,218,180, 89,151, 78,191,116, 44,209, 66,
    233, 97, 58,255,  5,226,136, 19,152,184,217,125,239,177, 89, 37,
    129,253,155, 69,140, 34, 65,249, 25,227, 85, 44, 74, 11,240,178,
    115, 22,215, 45,192,122,249, 81,150,109,219, 82,126,173,223,132,
     39,183,228, 22,159, 61,  5,211,142, 13,229,
    127,252,164, 25,102,186,147, 19,197,141, 39,158, 23,169, 77, 12,  //  42
    228, 26,172,245, 21,137, 52,  2,114,215, 22,239, 91,174, 24,160,
     14,123,166,203,149, 45, 73,214, 61,112, 34, 75, 18,147,119,196,
    165, 94, 25,235, 99,226,125,165, 60,198, 17,185,222,132, 98, 46,
     67,199,142,101,160, 17, 57,201, 12,179, 52,203,155, 24, 54, 80,
    239, 15,147, 88,253,190,133, 90,244, 69,170,
    105, 64,209,117,242, 89, 45,224, 81,180,102,206, 66,221, 42,184,  //  43
    107, 63,136, 40, 75,229, 97,249,189, 41,129,156, 34,223,140,104,
    213,183, 35, 69,109,237,167, 85,242,195,158,228,200, 62,244,  5,
     54,207,116,185, 53,175,  8,205,104,153,127,100,159, 32,212,169,
    246, 89,  9,237, 70,217,138,113,235, 88,140,  4, 71,255,191,116,
    165, 69,197,113, 31,103,224, 38,154, 29,194,
      1,144, 40,176, 54,203,168,124, 27, 59,239,  2,148,106,131,250,  //  44
    149,214,189,114,160,183,123, 60,161, 74,210,103,181, 64, 87,245,
     49, 81,239,140, 17,189, 34,142,  7, 53, 97,137, 45, 84,170,107,
    223, 74,151, 14,213,144, 83, 47,231, 33,217, 55,252, 67,142, 13,
    119,154,187,126, 39,178, 90,163, 36,191,244,117,212, 95,143,  9,
    203, 45,134,230,161, 55,178,113,200, 93,232,
     76,185,225, 80,152, 25, 95,251,156,202,121, 77,186,237, 17, 78,  //  45
     55,  4, 91,219, 57, 10,207, 32,133,237, 13, 53,252,  6,196,121,
    154,  9,196, 84,223,125, 97,217,179,128,253, 11,187,225, 22,142,
    176, 42,242,127, 67, 32,252,186,139, 87,179,  3,196,114,187, 78,
    223, 34, 63,208,107,243,  5,221, 56,105, 28,167, 43,176, 37,217,
     98,247, 79,  3,212, 77, 26,249, 59,124,160,
    241, 30,122, 13,238,136,213,  6,110, 37,168,222, 28, 93,140,197,  //  46
    166,233,125, 24,254, 89,150,222, 83,173,113,203,138,109,171, 27,
    229,102,170, 38,159, 54,247, 67, 24,209, 75,168,109,134, 51,251,
     96, 19,188,101,223,170,115, 95, 13,243,124, 95,148, 23,234, 47,
    171,103,255,165, 21,148, 72,186,129,155,225, 73,133,230, 64,121,
    160, 29,183,104,144,193,131,164,  9,216, 43,
    108, 86,202,160,103, 41, 67,187, 88,243, 66,136, 49,172,213, 31,  //  47
    114, 41,204,173,134,190,107, 18, 63,196, 35,159, 68,224, 55,211,
     73,129,252, 68,210, 12,173,115,154, 85, 40,229, 27,213, 86,195,
    124,217, 77,159,  3, 74,204,152, 66,164, 42,207,240, 62, 85,145,
    197,  2,138, 45, 96,200,117, 27,252, 85, 15,200,101, 22,184,239,
     73,140,219, 43,240, 16, 96,231, 75,144,197,
    172,135,255, 50,192,230,166,131,208,149, 10,198,110,235, 59, 97,  //  48
    247,148, 71,101, 36, 65,231,160,248,140, 94,237, 19, 85,162,136,
     43,204, 19,117,145,101,202, 35,231,195,124, 67,148, 97,158, 29,
     67,151, 48,245,129, 43,234, 28,196,223, 78, 20,165,129,210, 29,
    122,214, 75,179,238, 54,216,173, 68,208, 50,175,248,152, 94, 36,
    201, 13,118,171, 68,123,205, 31,184,100, 22,
    224, 68,  5, 94,120, 29, 84, 15, 58,116,231, 79,154, 18,129,191,  //  49
      9,178, 49,242,161,206, 26,121, 52,  5,216,128,186, 47,246,  2,
    183, 86,168,220, 56,241, 72,127, 58,  7,173,247,190, 12,226,177,
    238, 10,197,108,211,178, 97,134, 53,111,141,189,104, 46,175,249,
     59,101,232, 19,122,156, 36,105,  7,161,139,109, 68,  3,222,114,
    164, 61,253, 89,215, 38,156, 55,133,245, 59,
    116,190,145,177,214,149,250,175,220, 37,165, 27,253, 71,163,228,  //  50
     76,133,216,119,  1,136, 91,178,209, 79,175, 61,105,209,122, 96,
    230,148,101, 34,188,  4,158,185,244,140, 92, 32, 61,128,105, 43,
    137, 90,172, 21, 57,146, 13,241,170,  9,254, 54,231,  6, 89,154,
     16,189,141, 51,196, 78,225,127,238, 92,218, 41,198,136,174, 48,
    209,101,151, 22,136,185,249,111,212, 12,154,
     26, 45,234, 59, 17, 79, 49,128,102,190, 92,214,125,187, 45,109,  //  51
     24,199, 35, 81,184,225, 40,245,113,153, 34,255, 14,156, 37,201,
     58, 17,245,138, 84,232,109, 25, 76,206,110,219,165,237,197, 74,
    212,112,250, 83,224, 78,204,116, 69,209, 83,155,120,216,195,106,
    229, 73,170,112,251, 10,142,201, 48,178, 19,123,234, 35, 74,243,
    131,  7,224,178, 53, 95,  2, 73,170, 94,199,
     80,208,102,129,242,180,205, 24,229, 63,146, 44, 99,  9,219,142,  //  52
    249,102,171,238, 54,109,166, 76, 12,196, 85,139,180,224, 81,144,
    178,125,197, 41,177, 62,145,223, 48,163, 12,144, 43, 84,  1,156,
     24,147, 33,128,180, 29,161, 39,182,135, 35,187, 27, 72,143, 47,
    128, 37,222, 25, 62,182, 95, 29, 73,146,250, 79,157, 99,189, 28,
     84,192, 43,113,235,199,125,232, 36,131,240,
    139,173, 23,163, 68,108,139, 87,160,  7,241,181,139,200, 86,167,  //  53
     67, 45,149, 12,138,217, 22,141,231, 49,220, 66,115, 59, 22,249,
    101, 49, 75,214,118, 21,203, 95,182,123,255, 79,202,123,179,243,
     62,221,167, 68,233,109,213, 99,245, 59,225, 99,240,172, 14,245,
    163,201, 91,149,207,115,160,244,189,114, 59,183,  9,211,115,162,
    231,141, 76,164, 62, 32,154,194, 65,181, 52,
    106,251, 50,223,  2,213, 45,237,105,203,118, 27, 68,245,111, 15,  //  54
    225,185,116,196, 69, 92,200, 58,180,120,162,  3,238,194,136,207,
      8,233,153, 13,248,168,130, 36,236, 22, 58,177, 31,233, 53,115,
    193, 98, 48,198,  3,151, 55, 16,157,118,  5,139, 52,124,211, 98,
     64,  7,116,234, 72, 16,219, 81,  1,214, 37,226,142, 45,255, 15,
     56,211, 21,248,131,219,100, 23,117,226,  6,
    152, 72,198,134, 95,150,192, 19,174, 42, 87,224,153, 47,176,132,  //  55
     38, 76,215, 30,254,170,116,241, 97, 21,204, 88,151, 32,111, 88,
    165,128,191,109, 91, 52,222, 71,148, 91,159,224, 93,148, 17, 76,
    139, 11,238,135, 93,253,122,221, 76,188,216,166,200, 89, 37,182,
    230,141,188, 30,174,140, 44,123,149,168, 96,121, 69,179, 90,151,
     79,117,182, 93,  8,175, 86,254,146, 76,213,
    192, 19,116,174, 42,247,121, 78,141,254,124,191,  3,216, 92,200,  //  56
    246,147,100, 60,144,  4, 48,154, 39,136,251,108,177, 51,230,182,
     29, 82, 57,227,143,199,  2,117,187,208,114,  6,126,214,175,252,
    163,216,116,181, 42,166, 64,194, 31,102, 46, 77, 24,252,144,108,
     46, 81,248, 51,104,241,186, 71,233, 27,190,238, 23,218,127,206,
    174, 32,229,151,204,114, 44,206, 15,169, 42,
     96,238, 54,227, 80, 28,178, 60,200, 15,158, 64,107,137, 29, 59,  //  57
    112,  7,173,234,121,192,218, 72,228,186, 53, 25,221, 81,146, 63,
    201,254, 38,169, 28, 85,164,249, 20, 62,239, 72,198, 47,107, 64,
     23, 84, 35, 72,204, 22,229,135,163,247,129,229,113,163,  3,209,
    173, 18,159,129,214, 87, 20,208, 51, 84,137, 54,163, 95, 11, 49,
    242,140, 55, 77, 39,233,159,130,104,242,125,
     61,141,201, 12,153,214,104,227, 47, 94,211, 37,243,168,223,192,  //  58
    158,225, 45,201, 20, 88,106,172, 11, 77,163,133,201, 17,243,123,
      4,155,106,213, 68,234,131, 47, 85,179, 37,144,168, 26,232,124,
    210,191,155,246,130,103, 80,  8, 58,184, 13,152, 41,192, 71,127,
    226,102,200, 72,  6,165,120,145,175,242,  6,210,110,248,181, 74,
    109,  3,213,124,182, 13, 67,191, 75, 31,184,
     17,170,111, 92,188,130,  5,146,170,237,110,183, 84, 16,120, 78,  //  59
     23, 95,134, 69,162,247, 26,129,203,120,238, 60,102,161, 45, 96,
    222, 86,194,127, 10,186, 74,220,155,122,211,103,249, 91,184, 55,
    139,100, 50, 11,218,176,150,240,117, 93,211, 72,221, 97,241, 49,
     24,150, 57,228,185,100,249, 35, 96,116,193, 70,148, 29,134,225,
    165,195, 99,251,147,102,239, 46,214,153,227,
     73,247, 33,233, 67, 41,251, 74, 38,131,  9,145, 67,230,153, 47,  //  60
    253,176,214,108, 40,185,148,233, 46, 99,211,  6,188,130,210,176,
    143, 32, 56,236,150,111, 21,200, 32,235, 10, 53,135, 14,152,222,
     19,239,166,121, 76, 25,211, 38,196,156, 25,132,175, 22,141,184,
     87,255,117, 43,134, 27,203, 58,219, 19,157, 41,223, 77,204, 36,
     59,143, 75, 24, 53,198,134,167,  2, 92,118,
    190, 53,157,120,206,174, 99,187,220, 82,202,250, 40,198, 98,184,  //  61
    124, 64,  9,142,228, 96, 55, 80,188, 21,154, 82,250, 30, 77, 14,
    247,120,171, 94, 40,252,174,137,104, 69,150,196, 73,209,112, 41,
     78,200, 62,226,193, 53,109,134, 70,232, 50,251,115, 65,212,108,
    162,203, 11,167,238, 70,158, 81,186,125,254, 94,173, 21,103,125,
    246, 17,210,176,231, 84, 29,108,250,143,210,
     14,138,218,  7, 60,147, 32,125, 20,154, 50,114,172,132,  6,208,  //  62
     34,161,242,189, 23,126,207, 30,167,240,129, 54,172,118,218, 61,
    101,200, 22,217,188, 63, 84, 53,244,187,115,228,169, 49,243,182,
    156,118,  5,140, 96,159,255,185,  1,104,167, 87,199, 10,237, 52,
     32,132, 83,212, 96,192,  4,234,139, 30, 52,197,132,234,163,188,
     90,159,117, 47,155, 63,221,175, 66, 36, 80,
    177,103, 87,167,243,112,230,197, 66,236,188, 90, 31,216, 59, 82,  //  63
    226,111, 92, 48, 72,174,255,141,112, 91,202, 33,230, 95,187,153,
    226, 48,147,125,  3,157,228, 13,167, 46, 25, 90,  1,144, 87, 17,
     97,250,187, 46,236, 14, 89, 45,221,144,207, 41,138,173, 98,151,
    192,234, 61, 23,147,123, 53,107,179, 85,230,109,  2, 80, 58, 12,
    223, 39,235, 93,  5,201,121, 19,195,159,234,
    117,255, 23,201, 41, 88, 10,157,101,134,  2,227,143,103,239,156,  //  64
    134, 20,199,148,219,100, 14, 57,220,  4, 66,164,142, 16, 44,124,
     10,177, 83,246,109, 87,206,140, 94,218,155,252,123,192,232,131,
    205, 27, 68,168,115,213,135,174,117, 64, 18,242,107, 30,206, 86,
      2,104,179,243, 68,200,251,155, 16,204, 61,144,179,246,121,200,
    139, 67,183,125,253,103,148,242, 97,127, 46,
     72,185, 60,144,121,182,210, 54,242, 40,180, 64,165, 18,183, 38,  //  65
     62,175,231,  1,115,163,196, 82,157,190,244, 99,208, 80,254,196,
     74,236, 57,196, 43,177,119, 35,190,128, 63,204,102, 40, 72,174,
     43,149,233, 92, 21,188, 73, 27,236,187, 92,158,195, 72,249,121,
    221,145, 35,119,161, 14, 42, 94,220, 78,167, 28,207, 40,157, 30,
    107,210, 24,162,189, 71, 30, 56,206,  7,222,
     33,151,216, 95,229, 28,138,110,168, 80,211,127,247, 75,116,205,  //  66
    251, 88,125, 54,245, 63, 36,236,116, 45,135, 21,123,172, 60,141,
    109,160, 23,129,223, 17,244, 61,234,  7, 84, 26,164,222, 13,109,
    216, 76,118,210,142, 44,245,154,101, 47,230,120,  7,145, 38,163,
     75,193, 58,210, 90,227,139,181,120, 45,249,124, 96, 66,221, 76,
    244,153, 85, 61, 13,220,156,180, 81,139,173,
    242,124,  2, 48,159, 75,251, 35,218, 17,111, 56, 34,197,145,  7,  //  67
    105,154, 31,191,137, 93,213,145, 18,181, 73,230, 47,218,  1,226,
     29,208, 98,171, 70,150, 90,166,108,158,226,188, 56,147,125,239,
     57,191,  3,178, 65,219,122,  6,180,139, 31,206, 56,227,185, 59,
     16,246,134, 20,173,111, 62,239, 23,188,146,  8,236,189,134,175,
      6, 48,236,143,198, 92,126,230, 36,215,103,
     51,202,101,236,190, 17,173, 84,133,195,158,229,171, 99,222, 49,  //  68
    178,211, 69,227,169, 16,183,106, 67,252,148,191,108,155, 91,175,
     66,135,234,  6,193,110,212, 20,198, 45,134,103,247, 79,203, 40,
    163,133,253, 37,109,169, 92,200, 67,214, 79,174, 85,132,106,208,
     95,166, 78,232, 49,214,  4,160, 82,228, 69,110,161, 57, 21, 97,
    204,122,178,102, 42,242, 20,112, 65,160, 18,
     82,170,140, 65,128,104,205, 61,231, 46, 92,  9,128, 26, 66,244,  //  69
     82,130, 11,108, 44,123,240, 31,208,121,  8, 79, 25,199,124,247,
     39,182, 88, 51,247, 31,136, 55,255, 76, 16,171, 49,  8,179,101,
     23, 86, 98,151,235, 16, 59,251,126, 19,241,152, 12,254, 30,149,
    228,113, 41,188,120,153,101,196,131, 55,170,209, 36,225,120,255,
    155, 64, 24,219,132,169, 54,193,250,130,190,
     58,248, 12,211, 43,239,149,  4,119,184,149,255,212,180,121,155,  //  70
     22,218,162,253,199, 78,157, 52,167, 92,225,164,243, 65, 33,152,
     78,211,122,167,145, 65,224,170,113,150,229,197,118,216,135,245,
    172,220,195, 49,207,130,187, 36, 98,145, 57,111,197, 68,178, 53,
      7,194,142, 17,239, 65, 32,252, 40,217, 21, 94,139, 76,180, 43,
     83,234,188, 80,  1,207, 87,150,  8, 95,226,
     23,111,160, 91,183, 30, 86,169,241, 27, 77, 41,105, 87,206, 42,  //  71
    192,103, 74, 51,142,  5,226,104,193, 61,138, 44,128,209,113,223,
     11,106,238, 18,197,118, 78,  3,190, 92, 26, 67,157, 90, 31, 64,
    111,  9,138, 76, 26,100,150,216,168,227,185, 35,221, 97,136,212,
     81,248, 68,174, 94,202,166,113, 88,185,119,247,190,  9,147,207,
     17,131, 40,152,251,105,125,217, 52,177,122,
    220,198, 48,233,146,115,215, 98, 56,210,135,195,163, 15,236, 69,  //  72
    141,231, 29,186,100,213,131, 28,248, 14,214,181, 80,  6,173, 54,
    189,155, 60, 83, 42,211,160,235, 43,215,131,245, 46,224,190,148,
    234, 57,184,246,167,231, 12, 77, 49,  2, 82,122,154, 15,240,120,
    169, 33,123,224, 50,138, 15,221,143,  8,157, 45, 70,230, 85,114,
    226,174,100,195, 71, 34,185, 25,239, 78,155,
     70,136, 99, 19, 61,252, 13,197,159,114,  7,234, 58,128,172,112,  //  73
      3,169,123,241,159, 42, 70,179,149, 94,115, 31,240,149, 87,254,
    133, 36,206,173,250, 95, 28,137, 72,175,105,165,  5,128, 96, 18,
    201,125, 82, 41,119, 64,189,116,243,133,205,237, 51,188, 66, 26,
     99,205,154,  1,110,245, 74,190, 62,239,102,215,127,170, 34,194,
     71, 50,239, 15,140,226,162, 67,133,195, 40,
      3,187,226,169,125,178, 47,137, 34,247, 95,153, 80,216, 32,249,  //  74
     90,209, 62, 12, 79,200,238,111, 47,229,166,204, 63,107,200, 28,
     99,230, 87,129, 16,146,189,103,248, 13, 61,205, 77,183,249, 52,
    165, 35,225,155,206, 33,142,210, 92,173, 64, 20,162, 85,209,147,
    232, 41, 82,185,210, 37,175,100, 40,202, 31,178, 13, 63,251,158,
      6,150,118,210, 59,114, 93,208, 13,109,254,
    162,113, 32, 77,208,103, 79,223, 72,172, 41,223, 18,193, 55,145,  //  75
    195, 36,150,217,119, 34,142, 17,195, 71,  9,141, 38,224,162,123,
    182,  3,164,106,214, 51,228, 58,122,195,143,232, 32,156,116, 87,
    217,102,137,  3, 92,254, 72, 21,150, 35,194,110,130,251,  5,106,
    177, 60,253,133, 62,152,120,227,161,123, 88,142,235,101,133, 77,
    221, 88,171, 34,181,242, 52,148,234,174, 83,
    217, 47,245,135,  6,237,151,191, 16,130,186,110,140, 94,175,120,  //  76
     68,108,244, 88,188,167, 95,226,158, 85,252,117,189, 84, 13, 65,
    242, 50,222, 64,186, 80,  6,171,218, 25, 94, 48,103,219, 11,145,
    186, 24,242,197,169,113,183,220, 54,247, 97,220,176, 73, 48,194,
    128, 19,169,103, 12,240, 30, 69,  5,254,190, 50,200, 38,207, 23,
    186,106,249, 73,146,  4,199, 29, 74, 44,142,
     68,195,153, 55,186, 65, 33,108,243, 89,209, 51,253, 37,220,  8,  //  77
    231,167, 25,136, 16,250, 49,126, 58,214, 24,160, 51,236,135,205,
     83,144,116, 20,152,235,130,100, 42,150,182,254,132,192, 67,238,
     48,129, 65, 84, 48,146, 10,106,166,127,  7, 66, 25,215,155,235,
     77,213, 89,223,196, 86,184,216,151,105, 22, 72,157,112,168,232,
     58,138, 12,208,123, 96,167,119,221,190, 20,
    128,104, 18,222, 94,139,213,174, 47,158,  2, 72,164,200,103,155,  //  78
     47,197, 63,206,111, 71,210,  7,184,138,109,204, 74,179, 36,165,
     19,210,181,247, 40, 90,163,204,240, 86,118,  1,166, 85, 30,171,
     98,206,159, 19,233,203, 70,231, 78,205,154,238,135, 90,108, 14,
     40,159,119, 27,138,163,104,132, 46,179,208,127,241,  3, 68,126,
     33,163,191, 64,232, 39,250, 86,138,100,247,
    160,231, 75,166,117,253, 11, 80,128,219,112,232,125, 22, 70,241,  //  79
    122, 90,143,228, 40,177,147,103,241, 46, 89,245,  1,122, 93,250,
    112, 67, 34, 96,125,194, 68, 50, 15,188,214, 58, 77,210,233,137,
      6,252,113,178,124, 34,135,186, 25, 45,114,190, 49,174,206,145,
    241,184, 49,246, 80, 42,237, 16, 82,244, 53, 97,217, 83,192,246,
     99,223, 82, 26,154,184, 60,210, 14,178, 52,
      5,183, 42,202, 27, 60,153,198, 36,177, 93,152, 46,188,146, 13,  //  80
    204, 37,185,  4,125,234, 88,199, 31,153,176, 38,146,225,196, 45,
    140,233,169,145,221, 12,245,140,102,156, 31,235,145, 40,119, 71,
    190, 83, 45,215, 95,243, 56,157,251, 85,218, 75, 29,249, 57,117,
     66, 84,141,193,  4,208, 62,189,140,161, 10,173,135, 35,151, 15,
    180, 40,132,200,104, 17,115,156, 45,228, 81,
    243,125,100,140,229,180,109,225, 70,248, 21,206, 80,246,108,225,  //  81
    169,101,255, 79,165, 56, 17,133, 70,226,115,192, 83, 54,157, 16,
    187, 88,  4, 64,179, 44,120,172,228, 86,130,107,199,179, 16,164,
    227, 29,155, 71,  7,192,106, 17,124,173,  9,164,140,101,  2,193,
    217, 16,232, 98,173,130,107,227, 29,115,231, 69,195, 60,215,112,
    143, 66,255, 88,217,137,239, 90,204,120,149,
    189, 54,210, 11, 74, 39, 91,124,  6,139, 57,171, 28,135, 43, 77,  //  82
     29,129,158, 46,219,108,243,171,207, 10, 61,238, 25,208,116, 76,
    227,128,202,255,110, 88,217, 19, 54,177,247, 10, 55, 93,249, 60,
    141,115,204,236,127,166,220, 75,196, 51,232,118,198,227,168,136,
     46,163,119, 34, 56,251, 70,166, 51,207, 95, 25,252,102,169, 47,
    237,187,  1,166, 38, 56,193,  7,169, 24, 64,
     93, 29,167,249,152,200,239,162,189,212,110,237, 85,219,164,191,  //  83
    215, 68, 11,205,137,187, 41, 89,107,144,168, 97,134,175,248, 57,
    172,106, 48, 26,136,199,153, 79,193, 35, 95,162,224,146,112,207,
     20, 94,178, 49, 25, 82,142, 35,240,148, 93, 59, 19, 79, 39, 94,
    253, 70,213,143,205,153, 24,219, 81,147,186,128,156,  6,230, 88,
     29, 95,116,141,232,176, 77,129,252,105,216,
    131,235,114, 89,128, 16, 81, 34, 65, 92,155, 10,194, 73, 16, 97,  //  84
    146,242,178, 84, 25, 73,151,222, 27,253, 44,213,  7, 80, 33,148,
     13,216, 81,163,236,  8, 65,245,119,219,139,204, 28, 72,182, 50,
    168,244, 65,146,190,255, 59,170,108, 14,212,180,242,131,211,187,
    114, 22,177, 76, 12,100,193,116,  2,246, 33, 87,219, 51,118,202,
    162,220,194, 69, 27,106,220, 33,150, 52,174,
    205,  2, 63,196, 55,173,208,138,252, 23,221,125, 52,143,251,123,  //  85
     26, 53,114,229,128,249,  2,193,123, 71,179,112,155,234,196, 94,
    240,138,191, 58,103,180, 38, 99,160,  3, 83, 47,123,238,  6,220,
     89,131,  9,222,101,123,  4,224,189, 46,137,106, 32,157, 62,  9,
    155,222, 44,245,123,232, 53,175,135,201, 59,174,106,191,150, 14,
    131, 56, 19,247,162,126, 58,191, 83,227, 39,
     73,142,164,225, 36,235,109, 50,171,100,187, 37,171,202, 61,218,  //  86
    174,206, 76,164, 39,173,111, 54,157,209, 21,227, 64, 41,118,179,
     48,113, 32,230,130,212,143,224,187, 72,251,195,166, 91,153,119,
     35,212,159, 75, 36,202,155, 92,129, 71,250,162, 69,220,104,241,
    129, 86,103,149,182, 28, 74,223, 38, 92,126,233, 22, 66,250, 77,
    235,107,147, 92,209, 13,243,159,  9,122,162,
    111,255, 26,100,137, 75,153,  3,225,127, 73,244,110, 81,  1,107,  //  87
     47,137,  9,221, 63,199, 87,233, 31, 96,133, 82,185,136,222,  5,
     70,213,169, 14, 75, 44, 85, 17,126, 32,144,103, 14,205, 61,253,
    186, 55,110,246,178, 65,241, 22,215, 30,201, 89, 15,193, 47,181,
     27,169,208,  5, 83,205,152,107,166,241, 13,158,208,137, 33,186,
     42,171,225, 48,186, 72,139,102,198,241, 30,
    215, 87,183,212, 11,194,243, 83,201, 53,160, 14,207,154,233,188,  //  88
    159,247, 99,123,152, 21,214,139,181,243,165,  9,249, 28, 98,165,
    244,150, 96,201,252,162,193,242, 57,217,183, 53,233,130, 24,101,
    164, 21,194,134, 15,104,141, 53,181,146,103,177,234,113,147, 78,
    229, 57,115,241, 50,129,255,  9, 64,190,110, 52, 81,172, 96,117,
    213, 79,  6,121,155, 39,232, 26, 80, 56,179,
      8,136, 56,118,159, 60, 33,117,167, 21,214,138, 65, 43,129, 35,  //  89
     70, 22,196, 42,243, 95,119,  8, 82, 39,112,204, 55,150,212, 76,
    123, 40, 62,141,104, 31, 71,149,105,163, 86,118, 36,177,222,142,
     69,236, 82, 58,217,166,225,122, 77,239,  1, 61,131, 37,253,  8,
    127,185, 30,143,180, 68, 96,196,136, 37,221,133,244,  3,226,151,
     29,132,200,254,101,206,118,183,223,149,103,
    167,224, 38,245, 96,216,183,139, 71,236,112, 89,181,251,104,217,  //  90
     93,228,140,179, 75,162,189,236, 55,213,140, 70,177,120, 50,185,
     21,198,236,  1,187,126,212,  9,234, 26,200,248,158, 73, 46,194,
      2,125,210,154, 32, 85,  8,197, 38,114,217,156,202, 73,165,199,
    101,216, 74,232, 19,211, 40,156,237, 82,165, 20,179, 74,198, 54,
    237,176, 61, 22, 77,166, 10, 73,128, 44,205
};


CONST BYTE  Cluster2x2[] = { 1, 2 };

CONST BYTE  Cluster4x4[] = { 7,  1,  2,  5,
                             6,  3,  4,  8 };

CONST BYTE  Cluster6x6[] = { 12,  9,  6,  7, 10, 14,
                             17,  5,  1,  2, 15, 18,
                             11,  8,  3,  4, 13, 16 };

CONST BYTE  Cluster8x8[] = { 28, 18, 14,  5,  9, 16, 19, 21,
                             29, 27,  1,  2,  6, 10, 22, 32,
                             30, 26,  3,  4,  7, 11, 23, 31,
                             25, 20, 13,  8, 12, 15, 17, 24 };

CONST BYTE  Cluster10x10[] = { 36, 28, 25, 21, 10, 11, 22, 26, 30, 38,
                               45, 37, 20,  9,  1,  2, 12, 31, 42, 46,
                               50, 41, 19,  8,  3,  4,  5, 40, 47, 49,
                               43, 35, 18, 16,  7,  6, 13, 33, 44, 48,
                               34, 27, 24, 17, 15, 14, 23, 29, 32, 39 };

CONST BYTE  Cluster12x12[] = {

                50, 48, 39, 36, 32, 24, 13, 25, 33, 37, 41, 49,
                67, 59, 47, 31, 23, 12,  5, 14, 26, 42, 57, 61,
                70, 68, 53, 22, 11,  1,  2,  6, 15, 56, 62, 69,
                71, 64, 54, 21, 10,  3,  4,  7, 16, 55, 65, 72,
                63, 58, 44, 30, 20,  9,  8, 17, 27, 45, 60, 66,
                52, 43, 40, 35, 29, 19, 18, 28, 34, 38, 46, 51 };

CONST BYTE  Cluster14x14[] = {

                76, 68, 58, 53, 48, 38, 23, 22, 37, 43, 47, 50, 54, 62,
                88, 82, 73, 59, 39, 24, 15, 14, 21, 36, 42, 55, 70, 78,
                94, 92, 83, 69, 25, 16, 12,  5, 13, 20, 35, 63, 79, 90,
                98, 97, 86, 74, 26, 11,  1,  2,  6, 19, 34, 75, 87, 95,
                96, 91, 81, 64, 27, 10,  3,  4,  7, 18, 33, 66, 84, 93,
                89, 80, 72, 56, 44, 28,  9,  8, 17, 32, 41, 60, 71, 85,
                77, 65, 57, 52, 49, 45, 29, 30, 31, 40, 46, 51, 61, 67 };

CONST BYTE  Cluster16x16[] = {

         93, 82, 74, 67, 64, 60, 52, 33, 34, 35, 53, 61, 65, 69, 77, 94,
        110,102, 87, 73, 59, 51, 32, 24, 13, 25, 36, 54, 70, 85, 97,105,
        122,115,101, 81, 50, 31, 23, 12,  5, 14, 26, 37, 78, 98,113,117,
        127,121,109, 91, 49, 22, 11,  1,  2,  6, 15, 38, 89,106,118,125,
        128,119,107, 92, 48, 21, 10,  3,  4,  7, 16, 39, 90,111,123,126,
        120,114, 99, 79, 47, 30, 20,  9,  8, 17, 27, 40, 83,103,116,124,
        108,100, 86, 71, 58, 46, 29, 19, 18, 28, 41, 55, 75, 88,104,112,
         95, 80, 72, 66, 63, 57, 45, 44, 43, 42, 56, 62, 68, 76, 84, 96 };


#define REAL_PAT_CX(x)      ((x) + ((PAT_CX_ADD / (x)) * (x)))
#define FINAL_PAT_CX(x)     (REAL_PAT_CX(x) + PAT_CX_ADD)
#define PAT_DATA(x,y,p)     (x), (y), sizeof(p), (p)

CONST STDHTPAT    DefStdHTPat[HTPAT_SIZE_MAX_INDEX / 2] = {

        { PAT_DATA(        2,         2, Cluster2x2)       },
        { PAT_DATA(        4,         4, Cluster4x4)       },
        { PAT_DATA(        6,         6, Cluster6x6)       },
        { PAT_DATA(        8,         8, Cluster8x8)       },
        { PAT_DATA(       10,        10, Cluster10x10)     },
        { PAT_DATA(       12,        12, Cluster12x12)     },
        { PAT_DATA(       14,        14, Cluster14x14)     },
        { PAT_DATA(       16,        16, Cluster16x16)     },
        { PAT_DATA(HTSC_M_CX, HTSC_M_CY, HTSC_SUPERCELL_M) }
    };

const MONOPATRATIO MonoPatRatio[] = {

                {  2680,  2589 },       // 15 degree
                {  5774,  5000 },       // 30 degree
                { 10000,  7071 },       // 45 degree
                { 17321,  8660 },       // 60 degree
                { 37321,  9659 }        // 75 degree
            };


#if DBG


VOID
DbgShowThresholds(
    LPBYTE  pTitle,
    LPWORD  pwPat,
    UINT    cx,
    UINT    cy
    )

/*++

Routine Description:

    This is a debug functions which show all the HTCELL Infomation

Arguments:

    pHTCell - HTCELL to be displayed


Return Value:

    VOID


Author:

    01-Feb-1995 Wed 14:24:45 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    //
    // Output some information
    //

    DBGP_IF(DBGP_SHOW_HTCELL,
        {
            LPBYTE  pbBuf;
            BYTE    Buf[1024];
            UINT    xLoop;
            UINT    yLoop;
            UINT    cData;
            UINT    cRow;


            DBGP("\n*** %hs ****\n\n%ldx%ld=%ld\n\n"
                    ARGPTR(pTitle)
                    ARGDW(cx) ARGDW(cy)
                    ARGDW(cx * cy));

            yLoop = (UINT)cy;

            while (yLoop--) {

                xLoop  = (UINT)cx;
                pbBuf  = Buf;
                cData  = 0;
                cRow   = 0;

                while (xLoop--) {

                    pbBuf += sprintf(pbBuf, "%04lx:%04lx:%04lx ",
                                        (DWORD)pwPat[0],
                                        (DWORD)pwPat[1],
                                        (DWORD)pwPat[2]);

                    pwPat += 3;

                    if ((pbBuf >= &Buf[250]) || (xLoop == 0)) {

                        DBGP(Buf);

                        pbBuf = Buf;
                        cData = 0;
                        ++cRow;
                    }
                }

                if (cRow > 1) {

                    DBGP("");
                }
            }
        }
    )
}

#endif



VOID
HTENTRY
RotateHTPatXY(
    LPWORD  pPatSrc,
    LPWORD  pPatDst,
    UINT    cx,
    UINT    cy,
    UINT    cyNext,
    UINT    x,
    UINT    y
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-May-1998 Tue 18:45:03 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWORD  pwS;
    LPWORD  pwD;
    UINT    cbCX;
    UINT    cCX;
    UINT    cCY;


    cCY              = cy;
    (LPBYTE)pPatSrc += ((y * cyNext) + x) * SIZE_PER_PAT;
    cyNext          *= SIZE_PER_PAT;
    cbCX             = cx * SIZE_PER_PAT;

    DBGP_IF(DBGP_SHOW_HTCELL,
        DBGP("RotatePatXY: %p --> %p, %ld x %ld, Offset=(%ld, %ld)"
                ARGPTR(pPatSrc) ARGPTR(pPatDst) ARGDW(cx) ARGDW(cy)
                ARGDW(x) ARGDW(y)));

    while (cCY--) {

        pwS              = pPatSrc;
        (LPBYTE)pPatSrc += cyNext;
        pwD              = pPatDst;
        (LPBYTE)pPatDst += cyNext;
        cCX              = cx - x;

        while (cCX--) {

            *pwD  = *pwS;
            pwS  += COUNT_PER_PAT;
            pwD  += COUNT_PER_PAT;
        }

        (LPBYTE)pwS -= cbCX;
        cCX          = x;

        while (cCX--) {

            *pwD  = *pwS;
            pwS  += COUNT_PER_PAT;
            pwD  += COUNT_PER_PAT;
        }

        if (++y == cy) {

            y                = 0;
            (LPBYTE)pPatSrc -= (cy * cyNext);
        }
    }
}




VOID
HTENTRY
RotateHTPat45(
    LPBYTE  pPatSrc,
    LPWORD  pPatDst,
    UINT    cx,
    UINT    cy,
    UINT    cMax,
    UINT    cyNext,
    BOOL    SplitThreshold
    )

/*++

Routine Description:

    This function rotate the pattern 45 degree by copy first top half
    and exchange left/right


Arguments:

    pHTCell - Pointer to the cell to be rotated


Return Value:

    VOID


Author:

    07-Mar-1995 Tue 17:45:09 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWORD  pPatDst1;
    LPWORD  pPatDst2;
    UINT    xLoop;
    UINT    yLoop;
    UINT    cxHalf;
    UINT    cAdd;
    UINT    PatSrc;
    UINT    cbCX;
    UINT    cbDst2Off;
    WORD    wPat;

    ASSERT((cx & 0x01) == 0);
    ASSERT((cy & 0x01) == 0);


    cAdd         = cMax;
    cMax       <<= 1;
    yLoop        = (UINT)(cy >> 1);
    cxHalf       = (UINT)(cx >> 1);
    cbDst2Off    = (((yLoop * cyNext) + cxHalf) * SIZE_PER_PAT);
    cyNext      *= SIZE_PER_PAT;
    cbCX         = cx * SIZE_PER_PAT;

    while (yLoop--) {

        //
        // for each scan line, we need to swap first half of the bytes
        // with second half of the bytes, this will make the halftone
        // pattern as 45 degree angle.
        //

        pPatDst1          = pPatDst;
        pPatDst2          = (LPWORD)((LPBYTE)pPatDst1 + cbDst2Off);
        (LPBYTE)pPatDst  += cyNext;
        xLoop             = cx;

        while (xLoop--) {

            //
            // Make range from 1 to MAX_PAT_IDX
            //

            PatSrc     = (UINT)((((UINT)*pPatSrc++ << 1) * MAX_BGR_IDX) + cAdd);
            *pPatDst1  =
            wPat       = (WORD)(PatSrc / cMax);
            *pPatDst2  = (WORD)((SplitThreshold) ?
                                    ((PatSrc - MAX_BGR_IDX) / cMax) : wPat);
            pPatDst1  += COUNT_PER_PAT;
            pPatDst2  += COUNT_PER_PAT;

            if (xLoop == cxHalf) {

                (LPBYTE)pPatDst2 -= cbCX;
            }
        }
    }
}




VOID
HTENTRY
ExpandHTPatX(
    LPWORD  pwSrc,
    UINT    cx,
    UINT    cy,
    UINT    cxExp
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Nov-1998 Wed 11:06:43 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    cx    *= SIZE_PER_PAT;
    cxExp *= SIZE_PER_PAT;

    if (cxExp > cx) {

        while (cy--) {

            LPWORD  pwD;
            UINT    cbCopy;
            UINT    cbRem;

            pwD     = (LPWORD)((LPBYTE)pwSrc + cx);
            cbRem   = cxExp - cx;
            cbCopy  = 0;

            while (cbRem -= cbCopy) {

                cbCopy = (cbRem > cx) ? cx : cbRem;

                CopyMemory(pwD, pwSrc, cbCopy);

                (LPBYTE)pwD += cbCopy;
            }

            (LPBYTE)pwSrc += cxExp;
        }
    }
}




INT
__cdecl
SCDataCompare(
    const void  *pA,
    const void  *pB
    )
{
    return((INT)(((PSCDATA)pA)->Value) - (INT)(((PSCDATA)pB)->Value));
}



BOOL
GenerateWORDPat(
    LPBYTE  pPatR,
    LPBYTE  pPatG,
    LPBYTE  pPatB,
    LPWORD  pwDst,
    UINT    cxReal,
    UINT    cx,
    UINT    cy
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    27-Aug-1998 Thu 17:17:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE  ppSrc[3];
    LPBYTE  pbAlloc;
    LPWORD  pw;
    UINT    cxAdd;
    DWORD   Count;


    ppSrc[0] = pPatB;
    ppSrc[1] = pPatG;
    ppSrc[2] = pPatR;

    //
    // Since the cx is add one to the real cx so sub on now
    //

    cxAdd = cx - cxReal;
    Count = cxReal * cy;

    if (pbAlloc = (LPBYTE)HTAllocMem(NULL,
                                     HTMEM_pSCData,
                                     LPTR,
                                     Count * sizeof(SCDATA))) {

        PSCDATA pSC;
        LPBYTE  pb;
        UINT    iPat;
        UINT    jPat;
        DWORD   i;
        DWORD   j;
        UINT    x;
        UINT    y;
        WORD    Idx;
        DWORD   MaxV;
        DWORD   VAdd;
        BYTE    PreV;

        for (iPat = 0; iPat < 3; iPat++) {

            pSC = (PSCDATA)pbAlloc;
            i   = iPat;
            pb  = ppSrc[iPat];
            y   = cy;

            while (y--) {

                x = cxReal;

                while (x--) {

                    (pSC  )->Value  = *pb++;
                    (pSC++)->Index  = (WORD)i;
                    i              += COUNT_PER_PAT;
                }

                i += (COUNT_PER_PAT * cxAdd);
            }

            pSC = (PSCDATA)pbAlloc;

            qsort((LPVOID)pSC, Count, sizeof(SCDATA), SCDataCompare);

            Idx  = 0;
            MaxV = (DWORD)pSC[Count - 1].Value;
            VAdd = MaxV >> 1;
            PreV = 0;
            i    = Count;

            while (i--) {

                if (pSC->Value != PreV) {

                    PreV = pSC->Value;
                    Idx  = (WORD)((((DWORD)PreV * MAX_BGR_IDX) + VAdd) / MaxV);
                }

                pwDst[(pSC++)->Index] = Idx;
            }

            ASSERT(Idx == MAX_BGR_IDX);

        }

        //
        // Now copy the last one from the first pixel
        //

        ExpandHTPatX(pwDst, cxReal, cy, cx);

        HTFreeMem(pbAlloc);

        return(TRUE);
    }

    return(FALSE);
}



BOOL
Generate_HTSC_WORD(
    PHTCELL pHTCell
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    27-Aug-1998 Thu 17:17:13 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWORD      pwPat;
    LPBYTE      pbC;
    LPBYTE      pbM;
    LPBYTE      pbY;
    PSTDHTPAT   pStdHTPat;
    DWORD       dw;
    HTCELL      HTCell;
    UINT        RotX;
    UINT        RotY;


    if (pHTCell->HTPatIdx >= HTPAT_SIZE_USER) {

        ASSERT(pHTCell->HTPatIdx < HTPAT_SIZE_USER);

        return(FALSE);
    }

    ACQUIRE_HTMUTEX(HTGlobal.HTMutexCDCI);

    if (!(pHTCell->pThresholds = (LPBYTE)ppwHTPat[pHTCell->HTPatIdx])) {

        HTCell = *pHTCell;

        if ((dw = (DWORD)HTCell.HTPatIdx) > 9) {

            dw += 'A' - '9' - 1;
        }

        dw        = (dw << 24) + HTMEM_pHTPat;
        pStdHTPat = (PSTDHTPAT)&DefStdHTPat[HTCell.HTPatIdx >> 1];
        pbC       = (LPBYTE)pStdHTPat->pbSrcPat;

        DBGP_IF(DBGP_GEN_PAT,
                DBGP("Allocating %ld bytes for HTPatIdx=%ld, %ldx%ld, cxOrg=%ld, cxReal=%ld"
                ARGDW(HTCell.Size)
                ARGDW(HTCell.HTPatIdx)
                ARGDW(HTCell.Width) ARGDW(HTCell.Height)
                ARGDW(HTCell.cxOrg) ARGDW(HTCell.cxReal)));

        if (pwPat = (LPWORD)HTAllocMem(NULL, dw, LPTR, HTCell.Size)) {

            if (HTCell.HTPatIdx <= HTPAT_SIZE_16x16_M) {

                //
                // The first pattern to make is M/G, the second C/R and third is Y/B
                // and the pattern order in the pattern is BGR or YMC
                // so we need to make in offset of 1, 2, 0
                //

                dw = (DWORD)HTCell.cxOrg;

                ASSERT((dw * (HTCell.Height/2)) == (DWORD)pStdHTPat->cbSrcPat);

                RotateHTPat45(pbC,
                              pwPat + 1,
                              (UINT)dw,
                              (UINT)HTCell.Height,
                              (UINT)pStdHTPat->cbSrcPat,
                              (UINT)HTCell.Width,
                              TRUE);
#if DBG
                DbgShowThresholds("RotateHTPat45",
                                  pwPat,
                                  HTCell.Width,
                                  HTCell.Height);
#endif
                RotX = (UINT)((HTCell.HTPatIdx & 0x01) ? (dw >> 1) : 0);
                RotY = 0;

                RotateHTPatXY((LPWORD)pwPat + 1,
                              (LPWORD)pwPat + 2,
                              (UINT)dw,
                              (UINT)HTCell.Height,
                              (UINT)HTCell.Width,
                              RotX,
                              RotY);
#if DBG
                DbgShowThresholds("RotateHTPatXY 1",
                                  pwPat,
                                  HTCell.Width,
                                  HTCell.Height);
#endif
                if (HTCell.HTPatIdx & 0x01) {

                    RotX = (UINT)(dw >> 2);
                    RotY = (UINT)(HTCell.Height >> 2);

                } else {

                    RotX =
                    RotY = 0;
                }

                RotateHTPatXY((LPWORD)pwPat + 1,
                              (LPWORD)pwPat + 0,
                              (UINT)dw,
                              (UINT)HTCell.Height,
                              (UINT)HTCell.Width,
                              RotX,
                              RotY);
#if DBG
                DbgShowThresholds("RotateHTPatXY 2",
                                  pwPat,
                                  HTCell.Width,
                                  HTCell.Height);
#endif
                ExpandHTPatX(pwPat,
                             (UINT)dw,
                             (UINT)HTCell.Height,
                             (UINT)HTCell.Width);
#if DBG
                DbgShowThresholds("ExpandHTPatX",
                                  pwPat,
                                  HTCell.Width,
                                  HTCell.Height);
#endif

            } else {

                if (HTCell.HTPatIdx == HTPAT_SIZE_SUPERCELL) {

                    pbC =
                    pbM =
                    pbY = (LPBYTE)pbC + HTSC_M_OFFSET_M;

                } else {

                    pbY = (LPBYTE)pbC + HTSC_M_OFFSET_Y;
                    pbM = (LPBYTE)pbC + HTSC_M_OFFSET_M;
                    pbC = (LPBYTE)pbC + HTSC_M_OFFSET_C;
                }

                ASSERT(HTCell.cxReal == HTCell.cxOrg);

                if (!(GenerateWORDPat(pbC,
                                      pbM,
                                      pbY,
                                      pwPat,
                                      HTCell.cxOrg,
                                      HTCell.Width,
                                      HTCell.Height))) {

                    HTFreeMem(pwPat);
                    pwPat = NULL;
                }
            }
        }

        ppwHTPat[HTCell.HTPatIdx] = pwPat;
        pHTCell->pThresholds      = (LPBYTE)pwPat;
    }

    RELEASE_HTMUTEX(HTGlobal.HTMutexCDCI);

    return((pHTCell->pThresholds) ? TRUE : FALSE);
}



LONG
HTENTRY
ComputeHTCell(
    WORD                HTPatternIndex,
    PHALFTONEPATTERN    pHalftonePattern,
    PDEVICECOLORINFO    pDCI
    )

/*++

Routine Description:

    This function creates the halftone threshold pattern and places them in
    to supplied buffer.

Arguments:

    HTPatternIndex      - index to the internal halftone pattern, if this
                          number is not 0xffff.

    pHalftonePattern    - pointer to user's halftone pattern

    pDCI                - pointer to the DEVICECOLORINFO data structure.  This
                          structure describes the required halftone pattern.


Return Value:

    The return value is the size of the pattern copied or a zero
    to indicate failure.

Author:

    21-Jan-1991 Mon 12:47:48 created  -by-  Daniel Chou (danielc)

    30-Mar-1995 Thu 13:56:45 updated  -by-  Daniel Chou (danielc)
        Adding new brush regression

    22-Oct-1997 Wed 20:01:53 updated  -by-  Daniel Chou (danielc)
        Remove Regression but using computation in the HTMapClr.c


Revision History:


--*/

{
    LPBYTE      pPatSrc;
    LPBYTE      pPatABC[3];
    PATINFO     PatInfo;
    DWORD       Checksum;
    DWORD       cbPat;
    DWORD       dw;
    DWORD       DCIFlags;


    ZeroMemory(&PatInfo, sizeof(PATINFO));

    if (HTPatternIndex > HTPAT_SIZE_MAX_INDEX) {

        return(HTERR_INVALID_HTPATTERN_INDEX);
    }

    PatInfo.HTCell.HTPatIdx = (BYTE)HTPatternIndex;

    //
    // Setup basic PatInfo information
    //


    if (pDCI) {

        DCIFlags = pDCI->Flags & ~(DCIF_CLUSTER_HTCELL |
                                   DCIF_SUPERCELL      |
                                   DCIF_SUPERCELL_M);
    }

    if (HTPatternIndex == HTPAT_SIZE_USER) {

        if ((!pHalftonePattern) ||
            (pHalftonePattern->cbSize != sizeof(HALFTONEPATTERN))) {

            return(HTERR_INVALID_HALFTONE_PATTERN);
        }

        pPatABC[0]            = pHalftonePattern->pHTPatA;
        pPatABC[1]            = pHalftonePattern->pHTPatB;
        pPatABC[2]            = pHalftonePattern->pHTPatC;
        PatInfo.HTCell.cxOrg  = (WORD)pHalftonePattern->Width;
        PatInfo.HTCell.Height = (WORD)pHalftonePattern->Height;
        cbPat                 = (DWORD)PatInfo.HTCell.cxOrg *
                                (DWORD)PatInfo.HTCell.Height;

        if (!(pPatSrc = pPatABC[0])) {

            if (!(pPatSrc = pPatABC[1])) {

                if (!(pPatSrc = pPatABC[2])) {

                    return(HTERR_INVALID_HALFTONE_PATTERN);
                }
            }
        }

        if ((!pPatABC[0]) || (!pPatABC[1]) || (!pPatABC[2])) {

            pPatABC[0] =
            pPatABC[1] =
            pPatABC[2] = pPatSrc;
            dw         = (DWORD)'Usr1';

        } else {

            if ((pPatABC[0] == pPatABC[1]) && (pPatABC[0] == pPatABC[2])) {

                dw = (DWORD)'Usr2';

            } else {

                dw = (DWORD)'Usr3';
            }

            if (!pPatABC[0]) {

                pPatABC[0] = pPatSrc;
            }

            if (!pPatABC[1]) {

                pPatABC[1] = pPatSrc;
            }

            if (!pPatABC[2]) {

                pPatABC[2] = pPatSrc;
            }
        }

        Checksum = ComputeChecksum((LPBYTE)&HTPatternIndex,
                                   dw,
                                   sizeof(HTPatternIndex));
        Checksum = ComputeChecksum((LPBYTE)pPatSrc, Checksum, cbPat);

        if (dw == (DWORD)'Usr3') {

            Checksum = ComputeChecksum((LPBYTE)pPatABC[1], Checksum, cbPat);
            Checksum = ComputeChecksum((LPBYTE)pPatABC[2], Checksum, cbPat);
        }

    } else {

        Checksum = ComputeChecksum((LPBYTE)&HTPatternIndex,
                                   'HTSC',
                                   sizeof(HTPatternIndex));

        if (HTPatternIndex == HTPAT_SIZE_SUPERCELL) {

            DCIFlags |= DCIF_SUPERCELL;

        } else if (HTPatternIndex == HTPAT_SIZE_SUPERCELL_M) {

            DCIFlags |= DCIF_SUPERCELL_M;
        }

        HTPatternIndex        >>= 1;
        PatInfo.HTCell.cxOrg    = (WORD)DefStdHTPat[HTPatternIndex].cx;
        PatInfo.HTCell.Height   = (WORD)DefStdHTPat[HTPatternIndex].cy;
        PatInfo.HTCell.Flags    = HTCF_STATIC_PTHRESHOLDS;
    }

    PatInfo.HTCell.cxReal = (WORD)REAL_PAT_CX(PatInfo.HTCell.cxOrg);
    PatInfo.HTCell.Width  = (WORD)FINAL_PAT_CX(PatInfo.HTCell.cxOrg);
    PatInfo.HTCell.Size   = (DWORD)PatInfo.HTCell.Width *
                            (DWORD)PatInfo.HTCell.Height * SIZE_PER_PAT;

    DBGP_IF((DBGP_CACHE_PAT | DBGP_GEN_PAT),
            DBGP("HTCell(%3ldx%3ld): pDCI=%p, Idx=%2ld, cxOrg=%3ld, cxReal=%3ld, Size=%ld"
                ARGDW(PatInfo.HTCell.Width) ARGDW(PatInfo.HTCell.Height)
                ARGPTR(pDCI) ARGDW(PatInfo.HTCell.HTPatIdx)
                ARGDW(PatInfo.HTCell.cxOrg) ARGDW(PatInfo.HTCell.cxReal)
                ARGDW(PatInfo.HTCell.Size)));

    ASSERT(PatInfo.HTCell.cxReal > PAT_CX_ADD);

    //
    // Add width by one because we want to be able to do two pixel at end, and
    // pattern always in 3 plane mode
    //

    if (!pDCI) {

        //
        // Return checksum if pDCI passed is NULL
        //

        return(ComputeChecksum((LPBYTE)&PatInfo, Checksum, sizeof(PATINFO)));
    }

    //
    // Allocate the memory for the pattern buffer which we will stored the
    // final halftone pattern for this device.
    //

    if (PatInfo.HTCell.Flags & HTCF_STATIC_PTHRESHOLDS) {

        PatInfo.HTCell.pThresholds = NULL;

    } else {

        if (!(PatInfo.HTCell.pThresholds =
                                    (LPBYTE)HTAllocMem(pDCI,
                                                       HTMEM_pThresholds,
                                                       NONZEROLPTR,
                                                       PatInfo.HTCell.Size))) {

            return(HTERR_INSUFFICIENT_MEMORY);
        }

        if (!(GenerateWORDPat(pPatABC[0],
                              pPatABC[1],
                              pPatABC[2],
                              (LPWORD)PatInfo.HTCell.pThresholds,
                              (UINT)PatInfo.HTCell.cxOrg,
                              (UINT)PatInfo.HTCell.Width,
                              (UINT)PatInfo.HTCell.Height))) {

            HTFreeMem(PatInfo.HTCell.pThresholds);
            return(HTERR_INSUFFICIENT_MEMORY);
        }
    }

    pDCI->Flags  = DCIFlags;
    pDCI->HTCell = PatInfo.HTCell;

    return(PatInfo.HTCell.Size);
}




VOID
HTENTRY
DrawCornerLine(
    LPBYTE  pPattern,
    WORD    cxPels,
    WORD    cyPels,
    WORD    BytesPerScanLine,
    WORD    LineWidthPels,
    BOOL    FlipY
    )

/*++

Routine Description:

    This function draw a line from lower left corner to the upper right
    corner, to draw a line from upper left corner to the lower right corner
    just set the FlipY to true.

    This is the modified integer DDA algorithm which the line always symmetry,
    it make the line look less starsteps, if need to draw line from specified
    (x1, y1) to (x2, y2) then this function can be modified whih only changed
    to the startingt/end points for calculating the ErrorInc/ErrorDec/Error
    and Length parameters.

        Origin X, Y     - at first pel of last scan line and the X moving to
                          the right and Y moving to the top.

        Color           - only black/white where white=0, and black=1

Arguments:

    pPattern            - The pointer to the buffer, it must already initialize
                          to all zero and must have the size in bytes of
                          BytesPerScanLine * cyPels

    cxPels              - The width in pels of the visible area in the pattern.

    cyPels              - The height of the pattern buffer in scan line.

    BytesPerScanLine    - Total bytes of one scan line.

    LineWidthPels       - The line width in pels which will be draw into the
                          pattern buffer, (pen width).

    FlipY               - If true then the final pattern will be up-side-down


Return Value:

    No return value


Author:

    24-May-1991 Fri 22:30:43 created  -by-  Daniel Chou (danielc)


Revision History:

    20-Sep-1991 Fri 18:14:28 updated  -by-  Daniel Chou (danielc)

        Updated so it only using interger operation only (fast) and plus
        modified DDA so it will symmetric for better line constant brightness,
        the parameters for this call is reduced by assuming that the line
        is always drawing from corner to corner only.



--*/

{
    LPBYTE  pCurPat;
    INT     NextScanLine;
    INT     x;
    INT     y;
    INT     xLast;
    INT     yLast;
    INT     MinPels;
    INT     TotalPels;
    INT     xyInc[2];
    INT     Error;
    INT     ErrorInc;
    INT     ErrorDec;
    INT     Length;
    BYTE    DestMask;
    BYTE    DestByte;


    ASSERT((LineWidthPels) && (LineWidthPels <= cxPels));

    if (!LineWidthPels) {

        return;
    }

    if ((cxPels == 1) || (cyPels == 1) || (LineWidthPels >= cxPels)) {

        FillMemory(pPattern, BytesPerScanLine * cyPels, 0xff);
        return;
    }

    if (FlipY) {

        //
        // Flip the Y, draw from top/left, it located at first line
        //

        NextScanLine = (INT)BytesPerScanLine;

    } else {

        //
        // no Y flip so we have to draw from the lower left corner, and its
        // buffer location is at last scan line
        //

        pPattern += ((LONG)BytesPerScanLine * (LONG)(cyPels - 1));
        NextScanLine = -(INT)BytesPerScanLine;
    }

    //
    // Calculate the X/Y increment and initial error values, remember we must
    // always truncate the XInc/YInc values. how this works is that we keep a
    // fixed floating point version of the error terms (15-bit fixed point
    // value, one unit of fixed value is 0.000031) and has bit 15 (ie. 0x8000)
    // as the overrun indicator, if after the X/Y increment and this bit is
    // set then X/Y will need to increment by 1.
    //
    // At first we initialize the X/Y error terms to the half of the slope
    // different, this way the DDA lines will be balanced distributed
    // for the pels in the line resulting better constant line brightness and
    // less stairsteps than the round up type of error term for reqular DDA.
    //
    // For drawing from starting points (x1, x2) to (x2, y2) (ie. point at
    // (x2, y2) is exclusive) then using following changes
    //
    //  xLast = x = x1;
    //  yLast = y = y1;
    //
    //  change 'cxPels' to '(x2 - x1)' when calcaulate Inc/Dec/Error terms
    //  change 'cyPels' to '(y2 - y1)' when calcaulate Inc/Dec/Error terms
    //

    if (cxPels >= cyPels) {

        xyInc[0] = 1;
        xyInc[1] = 0;
        ErrorDec = (INT)cxPels;
        ErrorInc = (INT)cyPels;

    } else {

        xyInc[0] = 0;
        xyInc[1] = 1;
        ErrorDec = (INT)cyPels;
        ErrorInc = (INT)cxPels;
    }

    Length    = ErrorDec;               // DeltaX = total run (larger one)
    ErrorDec += ErrorDec;               // Delta2X
    Error     = ErrorInc - ErrorDec;    // DeltaY - Delta2X (initlal negative)
    ErrorInc += ErrorInc;               // Delta2Y

    MinPels = (INT)LineWidthPels - 1;

    if (cxPels > cyPels) {

        if ((MinPels -= (INT)(cxPels / cyPels)) < 0) {

            MinPels = 0;
        }
    }

    TotalPels = MinPels;
    xLast     =
    yLast     =
    x         =
    y         = 0;

    DBGP_IF(DBGP_DRAWLINE,
            DBGP("[%3u:%3u]: pPat=%p, Err=%d, Inc=%d, Dec=%d, Pels=%d)"
                ARGW(cxPels)
                ARGW(cyPels)
                ARG(pPattern)
                ARGS(Error)
                ARGS(ErrorInc)
                ARGS(ErrorDec)
                ARGW(LineWidthPels)));

    //
    // The single pel version of modified integer DDA for all octants is as
    // following:
    //                                      ;
    //  while (Length--) {                  ; do until all DeltaX finished
    //                                      ;
    //      PlotPoint(x, y);                ; Ploting point at (x,y)
    //                                      ;
    //      x += xyInc[0];                  ; Increment either x or y by one
    //      y += xyInc[1];                  ; unit depends on which octant.
    //                                      ;
    //      if ((Error += ErrorInc) >= 0) { ; adding error terms for shorter
    //                                      ; axis, integer sign operation.
    //          x     += xyInc[1];          ; adding either x or y by one if
    //          y     += xyInc[0];          ; 'pel' is closer to the slop.
    //          Error -= ErrorDec;          ; reset the error term
    //      }                               ;
    //  }
    //


    while (Length--) {                          // do all the DeltaX pels

        ++TotalPels;

        x += xyInc[0];                          // x=running number 0-up
        y += xyInc[1];                          // y only need 0/1

        if ((Error += ErrorInc) >= 0) {

            x     += xyInc[1];
            y     += xyInc[0];
            Error -= ErrorDec;
        }

        if (y != yLast) {

            ASSERT(y <= (INT)cyPels);

            DestMask  = (BYTE)(0x80 >> (xLast & 0x07));     // starting mask
            pCurPat   = pPattern + (xLast >> 3);            // byte start
            DestByte  = (BYTE)0x00;                         // start w/0

            DBGP_IF(DBGP_DRAWLINE,
                    DBGP("3u: Plot(%3d, %3d) %3d Pels, Next(x,y)=(%3d,%3d), Error=%d"
                            ARGS(Length)
                            ARGS(xLast)
                            ARGS(yLast)
                            ARGS(TotalPels)
                            ARGW(x)
                            ARGW(y)
                            ARGS(Error)));

            while (TotalPels--) {

                DestByte |= DestMask;

                if (++xLast >= (INT)cxPels) {

                    //
                    // If we wrap around, we have get the old data byte back
                    // since first byte may already has some on bits.
                    //

                    *pCurPat = DestByte;
                    DestByte = *(pCurPat = pPattern);
                    DestMask = (BYTE)0x80;
                    xLast    = 0;

                } else if (!(DestMask >>= 1)) {

                    *pCurPat++ = DestByte;
                    DestMask   = 0x80;
                    DestByte   = 0x00;
                }
            }

            //
            // Since we using DestByte as temparory data area, we need to make
            // sure that last modified data byte is saved back to the buffer,
            // to do that we only need to check if Mask=0x80, because if the
            // mask is equal to 0x80 then we just saved the byte, otherwise
            // we are in middle of the byte processing, we could do this by
            // extra checking for (TotalPels == 0) but this should check
            // at outside of the (DestMask >>= 1) loop to reduced the overhead.
            //

            if (DestMask != (BYTE)0x80) {

                *pCurPat = DestByte;                // last one if any
            }

            pPattern += NextScanLine;               // next scan line start
            xLast     = x;                          // remember this one
            yLast     = y;                          // reset y
            TotalPels = MinPels;
        }
    }

    ASSERT(y == (INT)cyPels);
}




LONG
HTENTRY
CreateStandardMonoPattern(
    PDEVICECOLORINFO    pDeviceColorInfo,
    PSTDMONOPATTERN     pStdMonoPat
    )

/*++

Routine Description:

    This function create standard pre-defined monochrome pattern to a
    1 bit per pel bitmap, alignment of each bitmap scan line to the
    specified

Arguments:

    pDeviceColorInfo    - Pointer to the DEVICECOLORINFO data structure, this
                          is used to get the device resolution information

    pStdMonoPat         - Pointer to the STDMONOPATTERN data structure.


    NOTE: The pStdMonoPat->PatternIndex must be < HT_SMP_0_PERCENT_SCREEN


Return Value:

    Retrun value will be the size of the final pattern, it will be <= 0 if an
    error occurred and the return value is the halftone error code.

    If the pPattern field in the pStdMonoPat data structure then only the
    pattern size is returned.

Author:

    24-May-1991 Fri 12:39:33 created  -by-  Daniel Chou (danielc)


Revision History:

    18-Sep-1991 Wed 18:49:50 updated  -by-  Daniel Chou (danielc)

        Fixed the bugs for the HORZ_VERT cross lines which has bad LineHeight
        and LineWidh variables,

        adding 2 decimal points accuracy when calculation the device pels to
        prevent run away intermediate result.



--*/

{
    LPBYTE          pPat;
    LPBYTE          pTempPat;
    STDMONOPATTERN  StdMonoPat;
    MONOPATRATIO    PatRatio;
    WORD            DeviceResXDPI;
    WORD            DeviceResYDPI;
    WORD            DevicePelsDPI;
    DWORD           DevPelSub;
    WORD            Index;
    WORD            Loop;
    WORD            LineMode;
    LONG            PatSize;
    DWORD           YPels2;                 // retain 2 decimal points
    DWORD           LineWidth2;             // retain 2 decimal points
    DWORD           LineHeight2;            // retain 2 decimal points
    DWORD           LineSpace2;             // retain 2 decimal points
    WORD            LineWidthPels;
    WORD            LineHeightPels;
    BOOL            FlipY;
    BYTE            Mask;
    BYTE            TempByte;


    StdMonoPat = *pStdMonoPat;

    ASSERTMSG("CreateStdMonoPattern: PatIndex >= HT_SMP_PERCENT_SCREEN(0)",
               StdMonoPat.PatternIndex < HT_SMP_PERCENT_SCREEN(0));

    DeviceResXDPI = pDeviceColorInfo->DeviceResXDPI;
    DeviceResYDPI = pDeviceColorInfo->DeviceResYDPI;
    // DevicePelsDPI = pDeviceColorInfo->DevicePelsDPI;
    DevPelSub     = DivFD6(100, pDeviceColorInfo->DevPelRatio) - 100;

    FlipY = (BOOL)((StdMonoPat.Flags & SMP_TOPDOWN) ? FALSE : TRUE);

    if (!StdMonoPat.LineWidth) {

        StdMonoPat.LineWidth = DEFAULT_SMP_LINE_WIDTH;
    }

    if (!StdMonoPat.LinesPerInch) {

        StdMonoPat.LinesPerInch = DEFAULT_SMP_LINES_PER_INCH;
    }

    LineSpace2  = (DWORD)DIVRUNUP((DWORD)DeviceResXDPI * 100L,
                                 (DWORD)StdMonoPat.LinesPerInch);
    LineWidth2  = (DWORD)DIVRUNUP((DWORD)StdMonoPat.LineWidth *
                                                        (DWORD)DeviceResXDPI,
                                  10L);

    switch (StdMonoPat.PatternIndex) {

    case HT_SMP_HORZ_LINE:
    case HT_SMP_VERT_LINE:
    case HT_SMP_HORZ_VERT_CROSS:

        YPels2 = LineSpace2;                        // default cyPels size

        StdMonoPat.cxPels = (WORD)DIVRUNUP(LineSpace2, 100L);

        if (StdMonoPat.PatternIndex == HT_SMP_HORZ_LINE) {

            // Maximize to the width size of the alignbytes

            StdMonoPat.cxPels = (WORD)StdMonoPat.ScanLineAlignBytes << 3;

        } else if (StdMonoPat.PatternIndex == HT_SMP_VERT_LINE) {

            YPels2 = 800L;                          // using 8 pels
        }

        break;

    case HT_SMP_DIAG_15_LINE_UP:
    case HT_SMP_DIAG_15_LINE_DOWN:
    case HT_SMP_DIAG_15_CROSS:
    case HT_SMP_DIAG_30_LINE_UP:
    case HT_SMP_DIAG_30_LINE_DOWN:
    case HT_SMP_DIAG_30_CROSS:
    case HT_SMP_DIAG_45_LINE_UP:
    case HT_SMP_DIAG_45_LINE_DOWN:
    case HT_SMP_DIAG_45_CROSS:
    case HT_SMP_DIAG_60_LINE_UP:
    case HT_SMP_DIAG_60_LINE_DOWN:
    case HT_SMP_DIAG_60_CROSS:
    case HT_SMP_DIAG_75_LINE_UP:
    case HT_SMP_DIAG_75_LINE_DOWN:
    case HT_SMP_DIAG_75_CROSS:

        Index = StdMonoPat.PatternIndex - (WORD)HT_SMP_DIAG_15_LINE_UP;

        if (LineMode = (WORD)(Index % 3)) {

            FlipY = !FlipY;                 //  Down or Cross
        }

        PatRatio = MonoPatRatio[Index / 3];

        StdMonoPat.cxPels = (WORD)DIVRUNUP(LineSpace2 * 100L,
                                             (DWORD)PatRatio.Distance);

        YPels2 = (DWORD)DIVRUNUP((DWORD)PatRatio.YSize * LineSpace2,
                                 (DWORD)PatRatio.Distance);

        LineWidth2 = (DWORD)DIVRUNUP(LineWidth2 * 10000L,
                                     (DWORD)PatRatio.Distance);

        break;

    default:                    // all other percentage density

        //
        // 04-Aug-2000 Fri 10:31:59 updated  -by-  Daniel Chou (danielc)
        //  All other non HT_SMP_xxxx should not be here, we already has
        //  a ASSERTMSG at begining of this function
        //

        return(0);
    }

    //
    // Now LineWidth2 = width of the line in pels (2 decimal points) and
    // we have to compensate the size of pels which at most time is greater
    // than its 'resolution', but since the distance between two device pels
    // is assume to be its point 'resolution' so actually we just have to
    // compensate the left/right edges of the total line width, the first
    // and last pels that is.
    //
    //  ResPels to reduced = (SizePel / SizeResolution)
    //                     = (PelDPI / ResDPI) - 1.0
    //

    LineWidth2 -= DevPelSub;
#if 0

    if (DevicePelsDPI) {

        DBGP("<<< XPels=%ld, ResX=%ld, Width=%ld, Ratio=%s, Sub=%ld, New=%ld"
                ARGDW(DevicePelsDPI) ARGDW(DeviceResXDPI)
                ARGDW(LineWidth2) ARGFD6(pDeviceColorInfo->DevPelRatio, 1, 6)
                ARGDW(DevPelSub) ARGDW(LineWidth2 - DevPelSub));

        LineWidth2 -= (DWORD)DIVRUNUP((DWORD)DevicePelsDPI * 100L,
                                      (DWORD)DeviceResXDPI) - (DWORD)100;

        DBGP(">>> XPels=%ld, ResX=%ld, Width=%ld"
                ARGDW(DevicePelsDPI) ARGDW(DeviceResXDPI)
                ARGDW(LineWidth2));
    }
#endif

    //
    // Adjust YPels2 for the non-equal X/Y aspect ratio, the ratio is based
    // one the XDPI
    //

    if (DeviceResXDPI != DeviceResYDPI) {

        YPels2 = (DWORD)DIVRUNUP(YPels2 * (DWORD)DeviceResYDPI,
                                 (DWORD)DeviceResXDPI);
    }

    //
    // Convert to device pels and check all the zero term, the LineHeightPels
    // only check later for the HORZ/VERT/HORZ_VERT_CROSS line types
    //

    if (!StdMonoPat.cxPels) {

        ++StdMonoPat.cxPels;
    }

    if (!(StdMonoPat.cyPels = (WORD)DIVRUNUP(YPels2, 100))) {

        ++StdMonoPat.cyPels;
    }

    if ((LineWidthPels = (WORD)DIVRUNUP(LineWidth2, 100)) >
                                                        StdMonoPat.cxPels) {

        LineWidthPels = (WORD)(StdMonoPat.cxPels - 1);
    }

    if (!LineWidthPels) {

        ++LineWidthPels;
    }

    //
    // calculate the buffer size for storing the pattern
    //

    StdMonoPat.BytesPerScanLine = (WORD)
                ComputeBytesPerScanLine((UINT)BMF_1BPP,
                                        (UINT)StdMonoPat.ScanLineAlignBytes,
                                        (DWORD)StdMonoPat.cxPels);
    PatSize = (LONG)(StdMonoPat.BytesPerScanLine * StdMonoPat.cyPels);


    ASSERTMSG("StdMonoPattern Size Too big", PatSize < 0x10000L);

    if (pPat = StdMonoPat.pPattern) {

        ZeroMemory(pPat, (WORD)PatSize);

        switch (StdMonoPat.PatternIndex) {

        case HT_SMP_VERT_LINE:
        case HT_SMP_HORZ_VERT_CROSS:

            Index    = (StdMonoPat.cxPels - (Loop = LineWidthPels)) >> 1;
            pTempPat = pPat + (Index >> 3);
            Mask     = (BYTE)(0x80 >> (Index & 0x07));
            TempByte = (BYTE)0;

            //
            // Do this for the first row then copy the rest
            //

            while (Loop--) {

                TempByte |= Mask;

                if ((!(Mask >>= 1)) || (!Loop)) {

                    *pTempPat++ = TempByte;
                    TempByte    = (BYTE)0;
                    Mask        = (BYTE)0x80;
                }
            }

            for (Index = 0, pTempPat = pPat;
                 Index < StdMonoPat.cyPels;
                 Index++) {

                CopyMemory(pTempPat, pPat, StdMonoPat.BytesPerScanLine);
                pTempPat += StdMonoPat.BytesPerScanLine;
            }

            //
            // Fall through
            //

        case HT_SMP_HORZ_LINE:

            if (StdMonoPat.PatternIndex != HT_SMP_VERT_LINE) {

                //
                // Set Line Height according to the size of device Y
                // resolution and its pel resolution. (see above for
                // resolution pels reduction)
                //

                LineHeight2 = (DWORD)DIVRUNUP((DWORD)StdMonoPat.LineWidth *
                                                        (DWORD)DeviceResYDPI,
                                              10L) - DevPelSub;
#if 0
                if (DevicePelsDPI) {

                    LineHeight2 -= (DWORD)DIVRUNUP((DWORD)DevicePelsDPI * 100L,
                                                   (DWORD)DeviceResYDPI) -
                                   (DWORD)100;
                }
#endif
                if ((LineHeightPels = (WORD)DIVRUNUP(LineHeight2, 100)) >=
                                                        StdMonoPat.cyPels) {

                    LineHeightPels = (WORD)(StdMonoPat.cyPels - 1);
                }

                if (!LineHeightPels) {

                    ++LineHeightPels;
                }

                FillMemory(pPat + (((StdMonoPat.cyPels -
                                     LineHeightPels) >> 1) *
                                 StdMonoPat.BytesPerScanLine),
                           LineHeightPels * StdMonoPat.BytesPerScanLine,
                           0xff);
            }

            break;

        case HT_SMP_DIAG_15_LINE_UP:
        case HT_SMP_DIAG_15_LINE_DOWN:
        case HT_SMP_DIAG_15_CROSS:
        case HT_SMP_DIAG_30_LINE_UP:
        case HT_SMP_DIAG_30_LINE_DOWN:
        case HT_SMP_DIAG_30_CROSS:
        case HT_SMP_DIAG_45_LINE_UP:
        case HT_SMP_DIAG_45_LINE_DOWN:
        case HT_SMP_DIAG_45_CROSS:
        case HT_SMP_DIAG_60_LINE_UP:
        case HT_SMP_DIAG_60_LINE_DOWN:
        case HT_SMP_DIAG_60_CROSS:
        case HT_SMP_DIAG_75_LINE_UP:
        case HT_SMP_DIAG_75_LINE_DOWN:
        case HT_SMP_DIAG_75_CROSS:

            DrawCornerLine(StdMonoPat.pPattern,
                           StdMonoPat.cxPels,
                           StdMonoPat.cyPels,
                           StdMonoPat.BytesPerScanLine,
                           LineWidthPels,
                           FlipY);

            if (LineMode == 2) {                // cross section

                pTempPat = pPat + ((StdMonoPat.cyPels - 1) *
                                   StdMonoPat.BytesPerScanLine);

                //
                // Make the up-side-down mirror which create a cross section
                //

                Index = StdMonoPat.cyPels >> 1;

                while (Index--) {

                    Loop = StdMonoPat.BytesPerScanLine;

                    while (Loop--) {

                        *pPat++ = *pTempPat++ = (*pPat | *pTempPat);
                    }

                    pTempPat -= (StdMonoPat.BytesPerScanLine << 1);
                }

                pPat = StdMonoPat.pPattern;             // restore address
            }

            break;

        default:                    // all other percentage density

            break;
        }

        if (StdMonoPat.Flags & SMP_0_IS_BLACK) {

            Index = (WORD)PatSize;

            while (Index--) {

                *pPat++ ^= 0xff;
            }
        }
    }

    *pStdMonoPat = StdMonoPat;


    return(PatSize);

}



LONG
HTENTRY
CachedHalftonePattern(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PAAPATINFO          pAAPI,
    LONG                PatX,
    LONG                PatY,
    BOOL                FlipYPat
    )

/*++

Routine Description:

    This function create a cached pattern depends on the source color table,
    if the source color table only has one entry and we are using the pattern
    solid fill then the cached table will be the final color mask bits, else
    the color table will be the color threshold values.

    Note: the cached pattern will rotate both X, Y direction to aligned with
          destination so that first pel/scanline in the cached pattern will
          be corresponsed to the first pel in the destination.

Arguments:

    pHR - Pointer to the HALFTONERENDER data structure.


Return Value:

    The return value will be <= 0 if an error occurred and the return value is
    the error code, otherwise the return value is the size of the cached
    pattern allocated.

Author:

    05-Mar-1991 Tue 11:08:18 created  -by-  Daniel Chou (danielc)


Revision History:

    07-Jun-1991 Fri 17:23:16 updated  -by-  Daniel Chou (danielc)
        Fixed pattern solid fill's pattern alignment problems


--*/

{
    HTCELL      HTCell;
    AAPATINFO   AAPI;
    LONG        cxPat;
    LONG        cbPat;
    LONG        x;
    LONG        y;


    //
    // If pDCI->HTCell.pThresholds == NULL then we need to make the pattern
    // now
    //


    if (pDCI->HTCell.pThresholds == NULL) {

        ASSERT((pDCI->HTCell.Flags & HTCF_STATIC_PTHRESHOLDS) &&
               (pDCI->HTCell.HTPatIdx < HTPAT_SIZE_USER));

        if (!(Generate_HTSC_WORD(&(pDCI->HTCell)))) {

            return(HTERR_INSUFFICIENT_MEMORY);
        }
    }

    HTCell = pDCI->HTCell;

    //
    // We will always make the pattern width is multiple of 8, this will make
    // the output process faster.
    //

    AAPI.DstOrder = pDevClrAdj->DMI.DstOrder;

    //
    // Figure out the 555 pattern first
    //

    MOD_PAT_XY(x, PatX, CX_RGB555PAT);
    MOD_PAT_XY(y, PatY, CY_RGB555PAT);

    AAPI.pbPat555  = (LPBYTE)RGB555Pat + (CX_SIZE_RGB555PAT * y) + x;
    AAPI.cyNext555 = CX_SIZE_RGB555PAT;
    AAPI.cbEnd555  = CX_RGB555PAT - x - 1;

    if (FlipYPat) {

        AAPI.pbWrap555 = (LPBYTE)RGB555Pat - CX_SIZE_RGB555PAT + x;
        AAPI.pbBeg555  = AAPI.pbWrap555 + CB_RGB555PAT;
        AAPI.cyNext555 = -CX_SIZE_RGB555PAT;

    } else {

        AAPI.pbWrap555 = (LPBYTE)RGB555Pat + CB_RGB555PAT + x;
        AAPI.pbBeg555  = AAPI.pbWrap555 - CB_RGB555PAT;
        AAPI.cyNext555 = CX_SIZE_RGB555PAT;
    }

    DBGP_IF(DBGP_CACHE_PAT,
            DBGP("555: Orgin=(%ld, %ld)->(%ld, %ld), pbPat=%p->%p, cyNext=%ld, cbEnd=%ld, "
                ARGDW(PatX) ARGDW(PatY) ARGDW(x) ARGDW(y)
                ARGPTR(RGB555Pat) ARGPTR(AAPI.pbPat555)
                ARGDW(AAPI.cyNext555) ARGDW(AAPI.cbEnd555)));

    //
    // Figure out the ABC pattern now
    //

    cxPat  = (LONG)HTCell.Width * SIZE_PER_PAT;
    cbPat  = (LONG)HTCell.Height * cxPat;

    MOD_PAT_XY(x, PatX, HTCell.cxReal);
    MOD_PAT_XY(y, PatY, HTCell.Height);

    x              *= SIZE_PER_PAT;
    AAPI.pbPatBGR   = (LPBYTE)HTCell.pThresholds + (y * cxPat) + x;
    AAPI.cbWrapBGR  = -(LONG)HTCell.cxReal * SIZE_PER_PAT;
    AAPI.cbEndBGR   = -AAPI.cbWrapBGR - x;

    DBGP_IF(DBGP_CACHE_PAT,
        DBGP("HTCell=%ld (%ld) x %ld, cbPat=%ld, pbPat=%p, Flags=%04lx"
            ARGDW(HTCell.Width) ARGDW(HTCell.cxReal) ARGDW(HTCell.Height)
            ARGDW(HTCell.Size) ARGPTR(HTCell.pThresholds)
            ARGDW(HTCell.Flags)));

    if (FlipYPat) {

        AAPI.pbWrapBGR = (LPBYTE)HTCell.pThresholds - cxPat + x;
        AAPI.pbBegBGR   = AAPI.pbWrapBGR + cbPat;
        AAPI.cyNextBGR = -cxPat;

    } else {

        AAPI.pbWrapBGR  = (LPBYTE)HTCell.pThresholds + cbPat + x;
        AAPI.pbBegBGR   = AAPI.pbWrapBGR - cbPat;
        AAPI.cyNextBGR  = cxPat;
    }

    *pAAPI = AAPI;

    DBGP_IF(DBGP_CACHE_PAT,
            DBGP("BGR[%ld=%ld:%ld:%ld]: Org=(%ld, %ld)->(%ld, %ld), pbPat=%p->%p"
                ARGDW(AAPI.DstOrder.Index)      ARGDW(AAPI.DstOrder.Order[0])
                ARGDW(AAPI.DstOrder.Order[1])   ARGDW(AAPI.DstOrder.Order[2])
                ARGDW(PatX) ARGDW(PatY)
                ARGDW(x / SIZE_PER_PAT) ARGDW(y)
                ARGPTR(HTCell.pThresholds) ARGPTR(AAPI.pbPatBGR)));

    DBGP_IF(DBGP_CACHE_PAT,
            DBGP("pbBeg=%p, pbWrap=%p, cyNext=%ld, cbEnd=%ld, cbWrap=%ld"
                ARGPTR(AAPI.pbBegBGR) ARGPTR(AAPI.pbWrapBGR)
                ARGDW(AAPI.cyNextBGR) ARGDW(AAPI.cbEndBGR)
                ARGDW(AAPI.cbWrapBGR)));



    return((LONG)cbPat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htmath.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htmath.h


Abstract:


    This module contains the declaration of the halftone math module.


Author:
    28-Mar-1992 Sat 20:57:11 updated  -by-  Daniel Chou (danielc)
        Support FD6 decimal fixed format (upgrade forom UDECI4) for internal
        usage.

    16-Jan-1991 Wed 11:01:46 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    10-Oct-1991 Thu 10:00:56 updated  -by-  Daniel Chou (danielc)

        Delete MANTISSASEARCHTABLE structure which repalced with one time
        loop up.


--*/



#ifndef _HTMATH_
#define _HTMATH_

#ifdef  HTMATH_LIB

#undef  HTENTRY
#define HTENTRY     FAR

#ifdef  ASSERT
#undef  ASSERT
#endif

#ifdef  ASSERTMSG
#undef  ASSERTMSG
#endif

#define ASSERT(exp)     assert(exp)
#define ASSERTMSG(msg)  assert(msg)

#include <assert.h>

#endif

//
// Define Fix Decimal 6 places type, the FD6 Number is a FIXED 6 decimal point
// number.  For example 123456 = 0.123456 -12345678 = -12.345678, because the
// FD6 number using total of 32-bit signed number this leads to maximum FD6
// number = 2147.4836476 and minimum FD6 number is -2147.483648
//
//

typedef long            FD6;
typedef FD6 FAR         *PFD6;

#define SIZE_FD6        sizeof(FD6)

#define FD6_0           (FD6)0
#define FD6_1           (FD6)1000000


#define FD6_p000001     (FD6)(FD6_1 / 1000000)
#define FD6_p000005     (FD6)(FD6_1 / 200000)
#define FD6_p00001      (FD6)(FD6_1 / 100000)
#define FD6_p00005      (FD6)(FD6_1 / 20000)
#define FD6_p0001       (FD6)(FD6_1 / 10000)
#define FD6_p0005       (FD6)(FD6_1 / 2000)
#define FD6_p001        (FD6)(FD6_1 / 1000)
#define FD6_p005        (FD6)(FD6_1 / 200
#define FD6_p01         (FD6)(FD6_1 / 100)
#define FD6_p05         (FD6)(FD6_1 / 20)
#define FD6_p1          (FD6)(FD6_1 / 10)
#define FD6_p5          (FD6)(FD6_1 / 2)
#define FD6_2           (FD6)(FD6_1 * 2)
#define FD6_3           (FD6)(FD6_1 * 3)
#define FD6_4           (FD6)(FD6_1 * 4)
#define FD6_5           (FD6)(FD6_1 * 5)
#define FD6_6           (FD6)(FD6_1 * 6)
#define FD6_7           (FD6)(FD6_1 * 7)
#define FD6_8           (FD6)(FD6_1 * 8)
#define FD6_9           (FD6)(FD6_1 * 9)
#define FD6_10          (FD6)(FD6_1 * 10)
#define FD6_100         (FD6)(FD6_1 * 100)
#define FD6_1000        (FD6)(FD6_1 * 1000)



#define FD6_MIN         (FD6)-2147483648
#define FD6_MAX         (FD6)2147483647

#define UDECI4ToFD6(x)  (FD6)((FD6)(DWORD)(x) * (FD6)100)
#define DECI4ToFD6(x)   (FD6)((FD6)(x) * (FD6)100)
#define INTToFD6(i)     (FD6)((LONG)(i) * (LONG)FD6_1)


//
// MATRIX3x3
//
//  a 3 x 3 matrix definitions as
//
//      | Xr Xg Xb |   | Matrix[0][0]  Matrix[0][1]  Matrix[0][2] |
//      | Yr Yg Yb | = | Matrix[1][0]  Matrix[1][1]  Matrix[1][2] |
//      | Zr Zg Zb |   | Matrix[2][0]  Matrix[2][1]  Matrix[2][2] |
//
//  Notice each number is a FD6 value.
//

typedef struct _MATRIX3x3 {
    FD6     m[3][3];
    } MATRIX3x3, FAR *PMATRIX3x3;

//
// This is used for the MulDivFD6Pairs()'s TotalFD6Pairs parameter
//

typedef struct _MULDIVCOUNT {
    WORD    Size;
    WORD    Flag;
    } MULDIVCOUNT;

typedef struct _MULDIVPAIR {
    union {
        MULDIVCOUNT Info;
        FD6         Mul;
        } Pair1;

    FD6 Pair2;
    } MULDIVPAIR, FAR *PMULDIVPAIR;


#define MULDIV_NO_DIVISOR               0x0000
#define MULDIV_HAS_DIVISOR              0x0001

#define MAKE_MULDIV_SIZE(ap, c)         (ap)[0].Pair1.Info.Size=(WORD)(c)
#define MAKE_MULDIV_FLAG(ap, f)         (ap)[0].Pair1.Info.Flag=(WORD)(f)
#define MAKE_MULDIV_INFO(ap,c,f)        MAKE_MULDIV_SIZE(ap, c);            \
                                        MAKE_MULDIV_FLAG(ap, f)
#define MAKE_MULDIV_DVSR(ap,dvsr)       (ap)[0].Pair2=(FD6)(dvsr)
#define MAKE_MULDIV_PAIR(ap,i,p1,p2)    (ap)[i].Pair1.Mul=(p1);             \
                                        (ap)[i].Pair2=(p2)

//
// Following defined is used for the RaisePower()
//
//

#define RPF_RADICAL      W_BITPOS(0)
#define RPF_INTEXP       W_BITPOS(1)


#define Power(b,i)      RaisePower((FD6)(b), (FD6)(i), 0)
#define Radical(b,i)    RaisePower((FD6)(b), (FD6)(i), RPF_RADICAL)

#define Square(x)       MulFD6((x), (x))
#define SquareRoot(x)   RaisePower((FD6)(x), (FD6)2, RPF_RADICAL | RPF_INTEXP)
#define CubeRoot(x)     RaisePower((FD6)(x), (FD6)3, RPF_RADICAL | RPF_INTEXP)

//
// Following two marcos make up the Nature Logarithm and Exponential functions
// the nature logarithm has base approximate to 2.718282 (2.718281828)
//
//  LogNature(x)   = Log10(x) / Log10(2.718281828)
//                 = Log10(x) / (1.0 / 0.434294482)
//                 = Log10(x) * 2.302585093
//                 = Log10(x) * 2.302585        <== FD6 Approximation
//
//                              x
//  Exponential(x) = 2.718281828
//                 = Power(2.718282, x)         <== FD6 Approximation
//

#define NATURE_LOG_BASE     (FD6)2718282
#define NATURE_LOG_SCALE    (FD6)2302585
#define LogN(x)             (FD6)MulFD6(Log((x), NATURE_LOG_SCALE)
#define Exp(x)              (FD6)Power(NATURE_LOG_BASE, (x))

//
// These functions are defined as macros for faster excess
//
// Radical is the root function which 'x' is the Radicand, Index is the
// radical index
//


//
// This macro multiply a FD6 number by a LONG integer.  The 'Num' is FD6
// Number, and 'l' is a long integer.
//

#define FD6xL(Num, l)       (FD6)((LONG)(Num) * (LONG)l)


//
// CIE Y <-> L Conversion
//

#define CIE_L2I(L)      (((L) > (FD6)79996) ?                               \
                            Cube(DivFD6((L) + (FD6)160000, (FD6)1160000)) : \
                            DivFD6((L), (FD6)9033000))
#define CIE_y3I2L(Y,y3) (((Y) > (FD6)8856) ?                                \
                            MulFD6((y3),(FD6)1160000) - (FD6)160000  :      \
                            MulFD6((Y), (FD6)9033000))
#define CIE_I2L(Y)      CIE_y3I2L(Y, CubeRoot(Y))


//
// Function Prototype
//

#ifdef HT_OK_GEN_80x86_CODES

FD6
HTENTRY
Cube(
    FD6 Number
    );

#else

#define Cube(x)     MulFD6((x), Square(x))

#endif


FD6
HTENTRY
Log(
    FD6 Number
    );

FD6
HTENTRY
AntiLog(
    FD6 Number
    );

FD6
HTENTRY
RaisePower(
    FD6     BaseNumber,
    FD6     Exponent,
    WORD    Flags
    );


BOOL
HTENTRY
ComputeInverseMatrix3x3(
    PMATRIX3x3  pInMatrix,
    PMATRIX3x3  pOutMatrix
    );

VOID
HTENTRY
ConcatTwoMatrix3x3(
    PMATRIX3x3  pConcat,
    PMATRIX3x3  pMatrix,
    PMATRIX3x3  pOutMatrix
    );

FD6
HTENTRY
MulFD6(
    FD6 Multiplicand,
    FD6 Multiplier
    );

FD6
HTENTRY
DivFD6(
    FD6 Dividend,
    FD6 Divisor
    );

FD6
HTENTRY
FD6DivL(
    FD6     Dividend,
    LONG    Divisor
    );

FD6
HTENTRY
MulDivFD6Pairs(
    PMULDIVPAIR pMulDivPair
    );

FD6
HTENTRY
FractionToMantissa(
    FD6     Fraction,
    DWORD   CorrectData
    );

FD6
HTENTRY
MantissaToFraction(
    FD6     Mantissa,
    DWORD   CorrectData
    );

DWORD
HTENTRY
ComputeChecksum(
    LPBYTE  pData,
    DWORD   InitialChecksum,
    DWORD   DataSize
    );


#endif  // _HTMATH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htpat.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htpat.h


Abstract:

    This module contains the local structures, constants definitions for the
    htpat.c


Author:
    23-Oct-1997 Thu 15:14:14 updated  -by-  Daniel Chou (danielc)
        Re-write regress for color mapping

    23-Apr-1992 Thu 20:01:55 updated  -by-  Daniel Chou (danielc)
        1. Changed SHIFTMASK data structure.

            A. changed the NextDest[] from 'CHAR' to SHORT, this is will make
               sure if compiled under MIPS the default 'unsigned char' will
               not affect the signed operation.

            B. Change Shift1st From 'BYTE' to 'WORD'

    28-Mar-1992 Sat 20:58:07 updated  -by-  Daniel Chou (danielc)
        Add all the functions which related the device pel/intensities
        regression analysis.

    18-Jan-1991 Fri 16:53:41 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    20-Sep-1991 Fri 18:09:50 updated  -by-  Daniel Chou (danielc)

        Change DrawPatLine() prototype to DrawCornerLine()

    13-Apr-1992 Mon 18:40:44 updated  -by-  Daniel Chou (danielc)
        Rewrite MakeHalftoneBrush()

--*/


#ifndef _HTPAT_
#define _HTPAT_


#define MOD_PAT_XY(s,xy,c)  if (((s) = (SHORT)(xy)%(c)) < 0) { (s) += (c); }


typedef struct _PATINFO {
    LPBYTE  pYData;
    HTCELL  HTCell;
    } PATINFO, FAR *PPATINFO;


typedef struct _SCDATA {
    BYTE    Value;
    BYTE    xSubC;
    WORD    Index;
    } SCDATA, FAR *PSCDATA;

typedef struct _STDHTPAT {
    BYTE        cx;
    BYTE        cy;
    WORD        cbSrcPat;
    CONST BYTE  *pbSrcPat;
    } STDHTPAT, *PSTDHTPAT;


//
// This is the default using by the NT GDI
//

#define DEFAULT_SMP_LINE_WIDTH      8           // 0.008 inch
#define DEFAULT_SMP_LINES_PER_INCH  15          // 15 lines per inch


typedef struct _MONOPATRATIO {
    UDECI4  YSize;
    UDECI4  Distance;
    } MONOPATRATIO;


#define CACHED_PAT_MIN_WIDTH        64
#define CACHED_PAT_MAX_WIDTH        256


#define CHB_TYPE_PACK8              0
#define CHB_TYPE_PACK2              1
#define CHB_TYPE_BYTE               2
#define CHB_TYPE_WORD               3
#define CHB_TYPE_DWORD              4

#define CX_RGB555PAT                65
#define CY_RGB555PAT                65
#define CX_SIZE_RGB555PAT           (CX_RGB555PAT + 1)
#define CB_RGB555PAT                (CX_SIZE_RGB555PAT * CY_RGB555PAT)


typedef struct _AAPATINFO {
    LPBYTE      pbPatBGR;           // Starting pattern scan X/Y offset
    LPBYTE      pbWrapBGR;          // point of wrapping of whole pattern
    LPBYTE      pbBegBGR;           // Whole pattern wrapping location
    LONG        cyNextBGR;          // cb to next pattern scan
    LONG        cbEndBGR;           // cb to the LAST PAT of scan from pbPatBGR
    LONG        cbWrapBGR;          // cb to wrap from LAST PATTERN
    RGBORDER    DstOrder;           // Destination order
    LPBYTE      pbPat555;           // Starting pattern scan X/Y offset
    LPBYTE      pbWrap555;          // point of wrapping of whole pattern
    LPBYTE      pbBeg555;           // Whole pattern wrapping location
    LONG        cyNext555;          // cb to next pattern scan
    LONG        cbEnd555;           // cb to the LAST PAT of scan from pbPat555
    } AAPATINFO, *PAAPATINFO;

#define MAX_BGR_IDX             0xFFF
#define MAX_K_IDX               ((MAX_BGR_IDX + 2) / 3)
#define PAT_CX_ADD              7
#define CB_PAT                  sizeof(WORD)
#define COUNT_PER_PAT           3
#define SIZE_PER_PAT            (CB_PAT * COUNT_PER_PAT)
#define INC_PPAT(p,i)           (LPBYTE)(p) += (i * SIZE_PER_PAT)
#define GETPAT(p, Order, Idx)                                               \
            (DWORD)*((LPWORD)((LPBYTE)(p) + Order + (Idx * SIZE_PER_PAT)))
#define GETMONOPAT(p, Idx)      GETPAT(p, 2, Idx)



//
// Function Prototype
//

LONG
HTENTRY
ComputeHTCell(
    WORD                HTPatternIndex,
    PHALFTONEPATTERN    pHalftonePattern,
    PDEVICECOLORINFO    pDeviceColorInfo
    );

VOID
HTENTRY
DrawCornerLine(
    LPBYTE  pPattern,
    WORD    cxPels,
    WORD    cyPels,
    WORD    BytesPerScanLine,
    WORD    LineWidthPels,
    BOOL    FlipY
    );

LONG
HTENTRY
CreateStandardMonoPattern(
    PDEVICECOLORINFO    pDeviceColorInfo,
    PSTDMONOPATTERN     pStdMonoPat
    );

LONG
HTENTRY
CachedHalftonePattern(
    PDEVICECOLORINFO    pDCI,
    PDEVCLRADJ          pDevClrAdj,
    PAAPATINFO          pAAPI,
    LONG                PatX,
    LONG                PatY,
    BOOL                FlipYPat
    );


#endif  // _HTPAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htrender.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htrender.c


Abstract:

    This module contains all low levels halftone rendering functions.


Author:

    22-Jan-1991 Tue 12:49:03 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    12-Jan-1999 Tue 11:09:50 updated  -by-  Daniel Chou (danielc)


--*/

#define DBGP_VARNAME        dbgpHTRender



#include "htp.h"
#include "htmapclr.h"
#include "htpat.h"
#include "limits.h"
#include "htalias.h"
#include "htrender.h"
#include "htstret.h"
#include "htgetbmp.h"
#include "htsetbmp.h"

#define DBGP_BFINFO         0x00000001
#define DBGP_FUNC           0x00000002
#define DBGP_AAHT_MEM       0x00000004



DEF_DBGPVAR(BIT_IF(DBGP_BFINFO,         0)  |
            BIT_IF(DBGP_FUNC,           0)  |
            BIT_IF(DBGP_AAHT_MEM,       0))


extern CONST RGBORDER   SrcOrderTable[PRIMARY_ORDER_MAX + 1];
extern const RGBORDER   DstOrderTable[PRIMARY_ORDER_MAX + 1];
extern CONST BYTE       RGB666Xlate[];
extern CONST BYTE       CMY666Xlate[];
extern CONST BYTE       RGB555Xlate[];
extern CONST BYTE       CMY555Xlate[];
extern CONST LPBYTE     p8BPPXlate[];

#define COLOR_SWAP_BC       0x01
#define COLOR_SWAP_AB       0x02
#define COLOR_SWAP_AC       0x04


#if DBG

CHAR    *pOrderName[] = { "RGB", "RBG", "GRB", "GBR", "BGR", "BRG" };

#endif


#define BFINFO_BITS_A       BFInfo.BitsRGB[0]
#define BFINFO_BITS_B       BFInfo.BitsRGB[1]
#define BFINFO_BITS_C       BFInfo.BitsRGB[2]

#define PHR_BFINFO_BITS_A   pHR->BFInfo.BitsRGB[0]
#define PHR_BFINFO_BITS_B   pHR->BFInfo.BitsRGB[1]
#define PHR_BFINFO_BITS_C   pHR->BFInfo.BitsRGB[2]



BOOL
HTENTRY
ValidateRGBBitFields(
    PBFINFO pBFInfo
    )

/*++

Routine Description:

    This function determined the RGB primary order from the RGB bit fields

Arguments:

    pBFInfo - Pointer to the BFINFO data structure, following field must
              set before the call

                BitsRGB[0]    = Red Bits
                BitsRGB[1]    = Green Bits
                BitsRGB[2]    = Blue Bits
                BitmapFormat  = BMF_16BPP/BMF_24BPP/BMF_32BPP
                RGB1stBit     = Specifed PRIMARY_ORDER_xxx ONLY for BMF_1BPP,
                                BMF_4BPP, BMF_8BPP, BMF_24BPP

              requested order.


Return Value:

    FALSE if BitsRGB[] or BitmapFormat passed are not valid

    else TRUE and following fields are returned

        BitsRGB[]       - corrected mask bits
        BitmapFormat    - BMF_16BPP/BMF_24BPP/BMF_32BPP
        Flags           - BFIF_xxxx
        SizeLUT         - Size of LUT table
        BitStart[]      - Starting bits for each of RGB
        BitCount[]      - Bits Count for each of RGB
        RGBOrder        - Current RGB order, for BMF_1BPP, BMF_4BPP, BMF_8BPP
                          and BMF_24BPP the RGBOrder.Index must specified a
                          PRIMARY_ORDER_xxx, for BMF_16BPP, BMF_32BPP the
                          RGBOrder.Index will be set by this function
        RGB1stBit       - The bit start for first on bit in BitsRGB[]
        GrayShr[]       - The right shift count so that most significant bit
                          of each RGB color is aligned to bit 7 if the total
                          bit count of RGB is greater than 8 otherwise this
                          value is 0, it is used when construct the monochrome
                          Y value.

Author:

    03-Mar-1993 Wed 12:33:22 created  -by-  Daniel Chou (danielc)


Revision History:

    06-Apr-1993 Tue 12:15:58 updated  -by-  Daniel Chou (danielc)
        Add 24bpp support for any other order than BGR


--*/

{
    BFINFO  BFInfo = *pBFInfo;
    DWORD   AllBits;
    DWORD   PrimBits;
    INT     Index;
    BYTE    BitCount;
    BYTE    BitStart;


    switch (BFInfo.BitmapFormat) {

    case BMF_1BPP:
    case BMF_4BPP:
    case BMF_8BPP:

        BFInfo.RGBOrder    = SrcOrderTable[BFInfo.RGBOrder.Index];
        BFInfo.BitCount[0] =
        BFInfo.BitCount[1] =
        BFInfo.BitCount[2] = 8;
        PrimBits           = (DWORD)0x000000ff;
        BitStart           = 0;

        for (Index = 0; Index < 3; Index++) {

            BitCount                    = BFInfo.RGBOrder.Order[Index];
            BFInfo.BitsRGB[BitCount]    = PrimBits;
            BFInfo.BitStart[BitCount]   = BitStart;
            PrimBits                  <<= 8;
            BitStart                   += 8;
        }

        break;

    case BMF_16BPP:
    case BMF_16BPP_555:
    case BMF_16BPP_565:

        BFInfo.BitsRGB[0] &= 0xffff;
        BFInfo.BitsRGB[1] &= 0xffff;
        BFInfo.BitsRGB[2] &= 0xffff;

        //
        // FALL THROUGH to compute
        //

    case BMF_24BPP:
    case BMF_32BPP:

        //
        // The bit fields cannot be overlaid
        //

        if (!(AllBits = (BFInfo.BitsRGB[0] |
                         BFInfo.BitsRGB[1] |
                         BFInfo.BitsRGB[2]))) {

            DBGP_IF(DBGP_BFINFO, DBGP("ERROR: BitsRGB[] all zeros"));

            return(FALSE);
        }

        if ((BFInfo.BitsRGB[0] & BFInfo.BitsRGB[1]) ||
            (BFInfo.BitsRGB[0] & BFInfo.BitsRGB[2]) ||
            (BFInfo.BitsRGB[1] & BFInfo.BitsRGB[2])) {

            DBGP_IF(DBGP_BFINFO,
                    DBGP("ERROR: BitsRGB[] Overlay: %08lx:%08lx:%08lx"
                        ARGDW(BFInfo.BitsRGB[0])
                        ARGDW(BFInfo.BitsRGB[1])
                        ARGDW(BFInfo.BitsRGB[2])));

            return(FALSE);
        }

        //
        // Now Check the bit count, we will allowed bit count to be 0
        //

        for (Index = 0; Index < 3; Index++) {

            BitStart =
            BitCount = 0;

            if (PrimBits = BFInfo.BitsRGB[Index]) {

                while (!(PrimBits & 0x01)) {

                    PrimBits >>= 1;         // get to the first bit
                    ++BitStart;
                }

                do {

                    ++BitCount;

                } while ((PrimBits >>= 1) & 0x01);

                if (PrimBits) {

                    //
                    // The bit fields is not contiguous
                    //

                    DBGP_IF(DBGP_BFINFO,
                            DBGP("ERROR: BitsRGB[%u]=%08lx is not contiguous"
                                    ARGU(Index)
                                    ARGDW(BFInfo.BitsRGB[Index])));

                    return(FALSE);
                }
            }

            BFInfo.BitStart[Index] = BitStart;
            BFInfo.BitCount[Index] = BitCount;

            if (!BitCount) {

                DBGP_IF(DBGP_BFINFO,
                        DBGP("WARNING: BitsRGB[%u] is ZERO"
                             ARGU(Index)));
            }
        }

        if ((AllBits == 0x00FFFFFF)     &&
            (BFInfo.BitCount[0] == 8)   &&
            (BFInfo.BitCount[1] == 8)   &&
            (BFInfo.BitCount[2] == 8)) {

            BFInfo.Flags |= BFIF_RGB_888;
        }

        //
        // Check what primary order is this, remember the Primary Order we
        // are checking is source, the source order defines is
        //
        //  PRIMARY_ORDER_ABC
        //                |||
        //                ||+---- Highest memory location
        //                |+----- middle memory location
        //                +------ lowest memory location
        //

        if ((BFINFO_BITS_A < BFINFO_BITS_B) &&
            (BFINFO_BITS_A < BFINFO_BITS_C)) {

            //
            // A is the smallest, so ABC or ACB
            //

            Index = (INT)((BFINFO_BITS_B < BFINFO_BITS_C) ? PRIMARY_ORDER_ABC :
                                                            PRIMARY_ORDER_ACB);

        } else if ((BFINFO_BITS_B < BFINFO_BITS_A) &&
                   (BFINFO_BITS_B < BFINFO_BITS_C)) {

            //
            // B is the smallest, so BAC or BCA
            //

            Index = (INT)((BFINFO_BITS_A < BFINFO_BITS_C) ? PRIMARY_ORDER_BAC :
                                                            PRIMARY_ORDER_BCA);

        } else {

            //
            // C is the smallest, so CAB or CBA
            //

            Index = (INT)((BFINFO_BITS_A < BFINFO_BITS_B) ? PRIMARY_ORDER_CAB :
                                                            PRIMARY_ORDER_CBA);
        }

        BFInfo.RGBOrder = SrcOrderTable[Index];

        break;

    default:

        DBGP("ERROR: Invalid BFInfo.BitmapFormat=%u"
                            ARGDW(pBFInfo->BitmapFormat));

        return(FALSE);
    }

    //
    // Put it back to return to the caller
    //

    *pBFInfo = BFInfo;

    //
    // Output some helpful information
    //

    DBGP_IF(DBGP_BFINFO,
            DBGP("============ BFINFO: BMP Format=%ld ==========="
                        ARGDW(pBFInfo->BitmapFormat));
            DBGP("   BitsRGB[] = 0x%08lx:0x%08lx:0x%08lx"
                             ARGDW(pBFInfo->BitsRGB[0])
                             ARGDW(pBFInfo->BitsRGB[1])
                             ARGDW(pBFInfo->BitsRGB[2]));
            DBGP("       Flags = 0x%02x %s"
                            ARGU(pBFInfo->Flags)
                            ARGPTR((pBFInfo->Flags & BFIF_RGB_888) ?
                                    "BFIF_RGB_888" : ""));
            DBGP("  RGBOrder[] = %2u - %2u:%2u:%2u [PRIMARY_ORDER_%hs]"
                            ARGU(pBFInfo->RGBOrder.Index)
                            ARGU(pBFInfo->RGBOrder.Order[0])
                            ARGU(pBFInfo->RGBOrder.Order[1])
                            ARGU(pBFInfo->RGBOrder.Order[2])
                            ARGPTR(pOrderName[pBFInfo->RGBOrder.Index]));
            DBGP("  BitStart[] = %2u:%2u:%2u"
                            ARGU(pBFInfo->BitStart[0])
                            ARGU(pBFInfo->BitStart[1])
                            ARGU(pBFInfo->BitStart[2]));
            DBGP("  BitCount[] = %2u:%2u:%2u"
                            ARGU(pBFInfo->BitCount[0])
                            ARGU(pBFInfo->BitCount[1])
                            ARGU(pBFInfo->BitCount[2])));

    return(TRUE);
}



LONG
HTENTRY
ValidateHTSI(
    PHALFTONERENDER pHR,
    UINT            ValidateMode
    )

/*++

Routine Description:

    This function read the HTSurfaceInfo and set it to the pHTCBParams

Arguments:

    pHR             - ponter to HALFTONERENDER data structure

    ValiateMode     - VALIDATE_HTSC_SRC/VALIDATE_HTSI_DEST/VALIDATE_HTSI_MASK

Return Value:

    >= 0     - Sucessful
    <  0     - HTERR_xxxx error codes

Author:

    28-Jan-1991 Mon 09:55:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPDWORD             pBitsRGB;
    PHTSURFACEINFO      pHTSI;
    COLORTRIAD          ColorTriad;
    RGBORDER            RGBOrder;
    DWORD               MaxColors;
    BYTE                MaxBytesPerEntry;



    switch (ValidateMode) {

    case VALIDATE_HTSI_MASK:

        if (pHTSI = pHR->pSrcMaskSI) {

            if (pHTSI->SurfaceFormat != BMF_1BPP) {

                return(HTERR_INVALID_SRC_MASK_FORMAT);
            }
        }

        break;

    case VALIDATE_HTSI_DEST:

        if (!(pHTSI = pHR->pDestSI)) {

            return(HTERR_NO_DEST_HTSURFACEINFO);
        }

        pHR->pXlate8BPP = NULL;

        switch(pHTSI->SurfaceFormat) {

        case BMF_1BPP:

            break;

        case BMF_8BPP_VGA256:

            //
            // Check if we have xlate table for the 8bpp device
            //

            if (pHTSI->pColorTriad) {

                ColorTriad = *(pHTSI->pColorTriad);

                if ((ColorTriad.pColorTable)                &&
                    (ColorTriad.ColorTableEntries == 256)   &&
                    (ColorTriad.PrimaryValueMax   == 255)   &&
                    (ColorTriad.BytesPerEntry     == 1)     &&
                    (ColorTriad.Type == COLOR_TYPE_RGB)) {

                    pHR->pXlate8BPP = (LPBYTE)ColorTriad.pColorTable;
                }
            }

            break;

        case BMF_4BPP:
        case BMF_4BPP_VGA16:
        case BMF_16BPP_555:
        case BMF_16BPP_565:
        case BMF_24BPP:
        case BMF_32BPP:

            break;

        default:

            return(HTERR_INVALID_DEST_FORMAT);
        }

        break;

    case VALIDATE_HTSI_SRC:

        if (!(pHTSI = pHR->pSrcSI)) {

            return(HTERR_NO_SRC_HTSURFACEINFO);
        }

        if (!(pHTSI->pColorTriad)) {

            return(HTERR_NO_SRC_COLORTRIAD);
        }

        ColorTriad = *(pHTSI->pColorTriad);

        //
        // We will accept other color type (ie. YIQ/XYZ/LAB/LUV) when graphic
        // system has type defined for the api, currently halftone can handle
        // all these types for 16bpp/24bpp/32bpp sources.
        //

        if (ColorTriad.Type > COLOR_TYPE_MAX) {

            return(HTERR_INVALID_COLOR_TYPE);
        }

        MaxColors                  = 0;
        MaxBytesPerEntry           = 4;
        pHR->BFInfo.RGBOrder.Index = (BYTE)ColorTriad.PrimaryOrder;

        switch(pHR->BFInfo.BitmapFormat = (BYTE)pHTSI->SurfaceFormat) {

        case BMF_1BPP:

            MaxColors = 2;
            break;

        case BMF_4BPP:

            MaxColors = 16;
            break;

        case BMF_8BPP:

            MaxColors = 256;
            break;

        case BMF_16BPP:

            MaxBytesPerEntry = 2;       // and fall through

        case BMF_32BPP:

            //
            // 16BPP/32BPP bit fields type of input the parameter of
            // COLORTRIAD must
            //
            //  Type                = COLOR_TYPE_RGB
            //  BytesPerPrimary     = 0
            //  BytesPerEntry       = (16BPP=2, 32BPP=4)
            //  PrimaryOrder        = *Ignored*
            //  PrimaryValueMax     = *Ignored*
            //  ColorTableEntries   = 3
            //  pColorTable         = Point to 3 DWORD RGB bit masks
            //

            if ((ColorTriad.Type != COLOR_TYPE_RGB)             ||
                (ColorTriad.BytesPerEntry != MaxBytesPerEntry)  ||
                (ColorTriad.ColorTableEntries != 3)             ||
                ((pBitsRGB = (LPDWORD)ColorTriad.pColorTable) == NULL)) {

                return(HTERR_INVALID_COLOR_TABLE);
            }

            PHR_BFINFO_BITS_A = *(pBitsRGB + 0);
            PHR_BFINFO_BITS_B = *(pBitsRGB + 1);
            PHR_BFINFO_BITS_C = *(pBitsRGB + 2);

            break;

        case BMF_24BPP:

            //
            // 24BPP must has COLORTRIAD as
            //
            //  Type                = COLOR_TYPE_xxxx
            //  BytesPerPrimary     = 1
            //  BytesPerEntry       = 3;
            //  PrimaryOrder        = PRIMARY_ORDER_xxxx
            //  PrimaryValueMax     = 255
            //  ColorTableEntries   = *Ignorde*
            //  pColorTable         = *Ignored*
            //

            if ((ColorTriad.Type != COLOR_TYPE_RGB)             ||
                (ColorTriad.BytesPerPrimary != 1)               ||
                (ColorTriad.BytesPerEntry != 3)                 ||
                (ColorTriad.PrimaryOrder > PRIMARY_ORDER_MAX)   ||
                (ColorTriad.PrimaryValueMax != 255)) {

                return(HTERR_INVALID_COLOR_ENTRY_SIZE);
            }

            RGBOrder          = SrcOrderTable[ColorTriad.PrimaryOrder];
            PHR_BFINFO_BITS_A = (DWORD)0xFF << (RGBOrder.Order[0] << 3);
            PHR_BFINFO_BITS_B = (DWORD)0xFF << (RGBOrder.Order[1] << 3);
            PHR_BFINFO_BITS_C = (DWORD)0xFF << (RGBOrder.Order[2] << 3);

            DBGP_IF(DBGP_BFINFO,
                    DBGP("24BPP Order=%ld [%ld:%ld:%ld]"
                        ARGDW(RGBOrder.Index)
                        ARGDW(RGBOrder.Order[0])
                        ARGDW(RGBOrder.Order[1])
                        ARGDW(RGBOrder.Order[2])));

            break;

        default:

            return(HTERR_INVALID_SRC_FORMAT);
        }

        //
        // This is a source surface, let's check the color table format
        //

        if (MaxColors) {

            if (ColorTriad.BytesPerPrimary != 1) {

                return(HTERR_INVALID_COLOR_TABLE_SIZE);
            }

            if (ColorTriad.BytesPerEntry < 3) {

                return(HTERR_INVALID_COLOR_ENTRY_SIZE);
            }

            if (ColorTriad.PrimaryOrder > PRIMARY_ORDER_MAX) {

                return(HTERR_INVALID_PRIMARY_ORDER);
            }

            if (!ColorTriad.pColorTable) {

                return(HTERR_INVALID_COLOR_TABLE);
            }

            if ((ColorTriad.ColorTableEntries > MaxColors) ||
                (!ColorTriad.ColorTableEntries)) {

                return(HTERR_INVALID_COLOR_TABLE_SIZE);
            }

            if ((ColorTriad.BytesPerPrimary != 1)       ||
                (ColorTriad.PrimaryValueMax != 255)) {

                return(HTERR_INVALID_PRIMARY_VALUE_MAX);
            }
        }

        if (!ValidateRGBBitFields(&(pHR->BFInfo))) {

            return(HTERR_INVALID_COLOR_TABLE);
        }

        break;
    }

    return(1);
}




LONG
HTENTRY
ComputeBytesPerScanLine(
    UINT            SurfaceFormat,
    UINT            AlignmentBytes,
    DWORD           WidthInPel
    )

/*++

Routine Description:

    This function calculate total bytes needed for a single scan line in the
    bitmap according to its format and alignment requirement.

Arguments:

    SurfaceFormat   - Surface format of the bitmap, this is must one of the
                      standard format which defined as SURFACE_FORMAT_xxx

    AlignmentBytes  - This is the alignment bytes requirement for one scan
                      line, this number can be range from 0 to 65535, some
                      common ones are:

                        0, 1    - Alignment in 8-bit boundary (BYTE)
                        2       - Alignment in 16-bit boundary (WORD)
                        3       - Alignment in 24-bit boundary
                        4       - Alignment in 32-bit boundary (DWORD)
                        8       - Alignment in 64-bit boundary (QWROD)

    WidthInPel      - Total Pels per scan line in the bitmap.

Return Value:

    The return value is the total bytes in one scan line if it is greater than
    zero, some error conditions may be exists when the return value is less
    than or equal to 0.

    Return Value == 0   - The WidthInPel is <= 0

    Return Value  < 0   - Invalid Surface format is passed.


Author:

    14-Feb-1991 Thu 10:03:35 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{

    DWORD   BytesPerScanLine;
    DWORD   OverhangBytes;


    if (WidthInPel <= 0L) {

        return(0L);
    }

    switch (SurfaceFormat) {

    case BMF_1BPP:

        BytesPerScanLine = (WidthInPel + 7L) >> 3;
        break;

    case BMF_4BPP_VGA16:
    case BMF_4BPP:

        BytesPerScanLine = (WidthInPel + 1) >> 1;
        break;

    case BMF_8BPP:
    case BMF_8BPP_VGA256:
    case BMF_8BPP_MONO:
    case BMF_8BPP_B332:
    case BMF_8BPP_L555:
    case BMF_8BPP_L666:
    case BMF_8BPP_K_B332:
    case BMF_8BPP_K_L555:
    case BMF_8BPP_K_L666:

        BytesPerScanLine = WidthInPel;
        break;

    case BMF_16BPP:
    case BMF_16BPP_555:
    case BMF_16BPP_565:

        BytesPerScanLine = WidthInPel << 1;
        break;

    case BMF_24BPP:

        BytesPerScanLine = WidthInPel + (WidthInPel << 1);
        break;

    case BMF_32BPP:

        BytesPerScanLine = WidthInPel << 2;
        break;

    default:

        return(0);

    }

    if ((AlignmentBytes <= 1) ||
        (!(OverhangBytes = BytesPerScanLine % (DWORD)AlignmentBytes))) {

        return((LONG)BytesPerScanLine);

    } else {

        return((LONG)BytesPerScanLine +
               (LONG)AlignmentBytes - (LONG)OverhangBytes);
    }

}




BOOL
HTENTRY
IntersectRECTL(
    PRECTL  prclA,
    PRECTL  prclB
    )

/*++

Routine Description:

    This function intersect prclA and prclB and write the result back to
    prclA, it return TRUE if two rect are intersected


Arguments:




Return Value:




Author:

    01-Apr-1998 Wed 20:41:00 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    RECTL   rcl;


    if ((rcl.left = prclA->left) < prclB->left) {

        rcl.left = prclB->left;
    }

    if ((rcl.top = prclA->top) < prclB->top) {

        rcl.top = prclB->top;
    }

    if ((rcl.right = prclA->right) > prclB->right) {

        rcl.right = prclB->right;
    }

    if ((rcl.bottom = prclA->bottom) > prclB->bottom) {

        rcl.bottom = prclB->bottom;
    }

    *prclA = rcl;

    return((rcl.right > rcl.left) && (rcl.bottom > rcl.top));
}




LONG
HTENTRY
ComputeByteOffset(
    UINT    SurfaceFormat,
    LONG    xLeft,
    LPBYTE  pPixelInByteSkip
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Apr-1998 Mon 22:51:28 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BYTE    BitOff = 0;


    switch (SurfaceFormat) {

    case BMF_1BPP:

        BitOff   = (BYTE)(xLeft & 0x07);
        xLeft  >>= 3;

        break;

    case BMF_4BPP_VGA16:
    case BMF_4BPP:

        BitOff   = (BYTE)(xLeft & 0x01);
        xLeft  >>= 1;

        break;

    case BMF_8BPP:
    case BMF_8BPP_VGA256:
    case BMF_8BPP_MONO:
    case BMF_8BPP_B332:
    case BMF_8BPP_L555:
    case BMF_8BPP_L666:
    case BMF_8BPP_K_B332:
    case BMF_8BPP_K_L555:
    case BMF_8BPP_K_L666:

        break;

    case BMF_16BPP:
    case BMF_16BPP_555:
    case BMF_16BPP_565:

        xLeft  <<= 1;
        break;

    case BMF_24BPP:

        xLeft  += (xLeft << 1);
        break;

    case BMF_32BPP:

        xLeft  <<= 2;
        break;

    default:

        return(0);
    }

    *pPixelInByteSkip = BitOff;

    return(xLeft);
}



VOID
GetDstBFInfo(
    PAAHEADER   pAAHdr,
    PABINFO     pABInfo,
    BYTE        DstSurfFormat,
    BYTE        DstOrder
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Feb-1999 Fri 13:37:22 created  -by-  Daniel Chou (danielc)


Revision History:

    08-Aug-2000 Tue 18:34:22 updated  -by-  Daniel Chou (danielc)
        Fixing bug for alpha blending, in gray scale mode, the destination
        can only be 1bpp or 8bpp mask mono, so when we read back from the
        destination to do alpha blending, it will double color mapping pixels.
        In gray scale mode, the input function will map the source RGB value
        to gray value with the current device transform, color adjustment and
        so on, so if we read back from destination then this transform is not
        desired.


--*/

{
    LPBYTE      pbPal;
    BFINFO      BFInfo;
    DWORD       Tmp;


    ZeroMemory(&BFInfo, sizeof(BFINFO));
    pbPal = NULL;

    switch (BFInfo.BitmapFormat = (BYTE)DstSurfFormat) {

    case BMF_16BPP_555:

        BFINFO_BITS_A = 0x7c00;
        BFINFO_BITS_B = 0x03e0;
        BFINFO_BITS_C = 0x001F;

        break;

    case BMF_16BPP_565:

        BFINFO_BITS_A  = 0xF800;
        BFINFO_BITS_B  = 0x07e0;
        BFINFO_BITS_C  = 0x001F;
        break;

    case BMF_24BPP:
    case BMF_32BPP:

        BFINFO_BITS_A  = 0x00FF0000;
        BFINFO_BITS_B  = 0x0000FF00;
        BFINFO_BITS_C  = 0x000000FF;
        break;

    default:

        pbPal    = (LPBYTE)pABInfo->pDstPal;
        DstOrder = (pABInfo->Flags & ABIF_DSTPAL_IS_RGBQUAD) ?
                                    PRIMARY_ORDER_BGR : PRIMARY_ORDER_RGB;
        break;
    }

    if (!pbPal) {

        if (DstOrder & COLOR_SWAP_BC) {

            XCHG(BFINFO_BITS_B, BFINFO_BITS_C, Tmp);
        }

        if (DstOrder & COLOR_SWAP_AB) {

            XCHG(BFINFO_BITS_A, BFINFO_BITS_B, Tmp);

        } else if (DstOrder & COLOR_SWAP_AC) {

            XCHG(BFINFO_BITS_A, BFINFO_BITS_C, Tmp);
        }

        ValidateRGBBitFields(&BFInfo);
    }

    ComputeInputColorInfo(pbPal,
                          4,
                          DstOrder,
                          &BFInfo,
                          &(pAAHdr->DstSurfInfo));

    //
    // We only do this if this is a 1bpp, 8bpp devices
    //

    SetGrayColorTable(NULL, &(pAAHdr->DstSurfInfo));
}




LONG
HTENTRY
AAHalftoneBitmap(
    PHALFTONERENDER pHR
    )

/*++

Routine Description:

    This function read the 1/4/8/24 bits per pel source bitmap and composed it
    (compress or expand if necessary) into PRIMCOLOR data structures array for
    later halftone rendering.

Arguments:

    pHalftoneRender     - Pointer to the HALFTONERENDER data structure.


Return Value:

    The return value will be < 0 if an error encountered else it will be
    1L.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define bm8i    (*(PBM8BPPINFO)&pAAHdr->prgbLUT->ExtBGR[3])

    PDEVICECOLORINFO    pDCI;
    PDEVCLRADJ          pDevClrAdj;
    AAOUTPUTFUNC        AAOutputFunc;
    AACYFUNC            AACYFunc;
    AAOUTPUTINFO        AAOutputInfo;
    PAAHEADER           pAAHdr;
    LONG                Result;
    BOOL                IsReleaseSem;


    DBG_TIMER_BEG(TIMER_SETUP);

    pDCI       = pHR->pDeviceColorInfo;
    pDevClrAdj = pHR->pDevClrAdj;
    pAAHdr     = (PAAHEADER)pHR->pAAHdr;

    if (((Result = ValidateHTSI(pHR, VALIDATE_HTSI_SRC)) < 0)   ||
        ((Result = ValidateHTSI(pHR, VALIDATE_HTSI_DEST)) < 0)  ||
        ((Result = ValidateHTSI(pHR, VALIDATE_HTSI_MASK)) < 0)  ||
        ((Result = SetupAAHeader(pHR, pDCI, pAAHdr, &AACYFunc)) <= 0)) {

        //================================================================
        // Release SEMAPHORE NOW and return error
        //================================================================

        RELEASE_HTMUTEX(pDCI->HTMutex);
        return(Result);
    }

    if (IsReleaseSem =
                (BOOL)((Result = CreateDyesColorMappingTable(pHR)) > 0)) {

        LPBYTE      pOut;
        LONG        cFirst;
        LONG        BitOff;
        LONG        cOut;
        RGBORDER    DstOrder;
        DWORD       AAHFlags;
        DWORD       DCAFlags;
        BYTE        DstSurfFmt;
        BYTE        DMIFlags;


        DstSurfFmt = pDevClrAdj->DMI.CTSTDInfo.BMFDest;
        DMIFlags   = pDevClrAdj->DMI.Flags;
        AAHFlags   = pAAHdr->Flags;
        pOut       = pAAHdr->DstSurfInfo.pb;
        cOut       = pAAHdr->pAAInfoCX->cOut;
        DstOrder   = pAAHdr->AAPI.DstOrder;
        DCAFlags   = (DWORD)pDevClrAdj->PrimAdj.Flags;


        ZeroMemory(&AAOutputInfo, sizeof(AAOUTPUTINFO));

        if (DCAFlags & DCA_XLATE_332) {

            AAOutputInfo.pXlate8BPP = pDCI->CMY8BPPMask.bXlate;
        }

        if (AAHFlags & AAHF_USE_DCI_DATA) {

            IsReleaseSem = FALSE;

            DBGP_IF(DBGP_FUNC, DBGP("AAHF_USE_DCI_DATA"));

            if (AAHFlags & AAHF_ALPHA_BLEND) {

                ASSERT(pDCI->pAlphaBlendBGR);

                pAAHdr->pAlphaBlendBGR = pDCI->pAlphaBlendBGR;

                if (AAHFlags & AAHF_CONST_ALPHA) {

                    pAAHdr->pAlphaBlendBGR += AB_BGR_SIZE;
                }
            }

        } else {

            CopyMemory(pAAHdr->prgbLUT, &(pDCI->rgbLUT), sizeof(RGBLUTAA));

            if (AAHFlags & AAHF_ALPHA_BLEND) {

                if (AAHFlags & AAHF_CONST_ALPHA) {

                    CopyMemory(pAAHdr->pAlphaBlendBGR,
                               (LPBYTE)(pDCI->pAlphaBlendBGR + AB_BGR_SIZE),
                               (AB_BGR_CA_SIZE + AB_CONST_SIZE));

                } else {

                    CopyMemory(pAAHdr->pAlphaBlendBGR,
                               pDCI->pAlphaBlendBGR,
                               AB_BGR_SIZE);
                }
            }

            //============================================================
            // Release SEMAPHORE NOW for pDCI when we halftone the output
            //============================================================

            RELEASE_HTMUTEX(pDCI->HTMutex);
        }

        if (pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY) {

            ASSERT((DstSurfFmt == BMF_1BPP) ||
                   (DstSurfFmt == BMF_8BPP_MONO));

            SetGrayColorTable(pAAHdr->pIdxBGR, &(pAAHdr->SrcSurfInfo));
        }

        if (pAAHdr->FUDI.cbbgr) {

            InitializeFUDI(pAAHdr);
        }

        DBGP_IF(DBGP_FUNC,
                DBGP("\ncOut=%ld, pOutputBuf=%p-%p, (%ld), pOut=%p"
                        ARGDW(cOut) ARGPTR(pAAHdr->pOutputBeg)
                        ARGPTR(pAAHdr->pOutputEnd)
                        ARGDW(pAAHdr->pOutputEnd - pAAHdr->pOutputBeg)
                        ARGPTR(pOut)));

        --pAAHdr->pOutputBeg;

        switch (DstSurfFmt) {

        case BMF_1BPP:

            AAOutputInfo.bm.XorMask = (AAHFlags & AAHF_ADDITIVE) ? 0x00 : 0xFF;

            if (BitOff = (LONG)pAAHdr->DstSurfInfo.BitOffset) {

                cFirst = 8 - BitOff;

                if ((cOut -= cFirst) < 0) {

                    //
                    // Only One byte
                    //

                    cFirst                  += cOut;
                    cOut                     = -cOut;
                    AAOutputInfo.bm.LSFirst  = (BYTE)cOut;
                    cOut                     = 0;
                }

                AAOutputInfo.bm.cFirst = (BYTE)cFirst;
            }

            if (AAOutputInfo.bm.cLast = (BYTE)(cOut & 0x7)) {

                pAAHdr->pOutputEnd -= AAOutputInfo.bm.cLast;
            }

            DBGP_IF(DBGP_FUNC,
                DBGP("1BPP: DstBitOff=%ld, cFirst=%ld, XorMask=0x%02lx, LSFirst=%ld, cLast=%ld [%ld]"
                    ARGDW(BitOff)
                    ARGDW(AAOutputInfo.bm.cFirst)
                    ARGDW(AAOutputInfo.bm.XorMask)
                    ARGDW(AAOutputInfo.bm.LSFirst)
                    ARGDW(AAOutputInfo.bm.cLast)
                    ARGDW(pAAHdr->pOutputEnd - pAAHdr->pOutputBeg)));

            ASSERT(pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY);

            AAOutputFunc = (AAOUTPUTFUNC)OutputAATo1BPP;

            break;

        case BMF_4BPP:
        case BMF_4BPP_VGA16:

            //
            // 4BPP do pre-increment
            //

            AAOutputInfo.bm.XorMask = (AAHFlags & AAHF_ADDITIVE) ? 0x00 : 0x77;

            if (pAAHdr->DstSurfInfo.BitOffset) {

                AAOutputInfo.bm.cFirst = 1;
                --cOut;
            }

            if (cOut & 0x01) {

                AAOutputInfo.bm.cLast = 1;
                --pAAHdr->pOutputEnd;
            }

            AAOutputFunc = (AAOUTPUTFUNC)((DstSurfFmt ==  BMF_4BPP) ?
                                            OutputAATo4BPP : OutputAAToVGA16);
            break;

        case BMF_8BPP_MONO:

            ASSERT(pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY);

            AAOutputInfo.bm.XorMask = bm8i.Data.bXor;
            AAOutputFunc            = (AAOUTPUTFUNC)OutputAATo8BPP_MONO;
            break;

        case BMF_8BPP_B332:

            AAOutputFunc = (DCAFlags & DCA_XLATE_332) ?
                                            OutputAATo8BPP_B332_XLATE :
                                            OutputAATo8BPP_B332;

            break;

        case BMF_8BPP_K_B332:

            AAOutputFunc = (DCAFlags & DCA_XLATE_332) ?
                                            OutputAATo8BPP_K_B332_XLATE :
                                            OutputAATo8BPP_K_B332;

            break;

        case BMF_8BPP_L555:
        case BMF_8BPP_L666:
        case BMF_8BPP_K_L555:
        case BMF_8BPP_K_L666:

            ASSERT(DCAFlags & DCA_XLATE_555_666);

            GET_P8BPPXLATE(AAOutputInfo.pXlate8BPP, bm8i);

            AAOutputFunc = (AAOUTPUTFUNC)(((DstSurfFmt == BMF_8BPP_L555) ||
                                           (DstSurfFmt == BMF_8BPP_L666)) ?
                                OutputAATo8BPP_XLATE : OutputAATo8BPP_K_XLATE);
            break;

        case BMF_8BPP_VGA256:

            AAOutputInfo.pXlate8BPP = BuildVGA256Xlate(pHR->pXlate8BPP,
                                                       pAAHdr->pXlate8BPP);

            AAOutputFunc = (AAOUTPUTFUNC)OutputAAToVGA256;

            break;

        case BMF_16BPP_555:
        case BMF_16BPP_565:

            //
            // Find out if we are in DWORD boundary
            //

            if ((UINT_PTR)pOut & 0x03) {

                AAOutputInfo.bm.cFirst = 1;
                --cOut;
            }

            if (cOut & 0x01) {

                AAOutputInfo.bm.cLast = 1;
                --pAAHdr->pOutputEnd;
            }

            switch (DstOrder.Index) {

            case PRIMARY_ORDER_RGB:

                AAOutputFunc = (DstSurfFmt == BMF_16BPP_555) ?
                                    (AAOUTPUTFUNC)OutputAATo16BPP_555_RGB :
                                    (AAOUTPUTFUNC)OutputAATo16BPP_565_RGB;
                break;

            case PRIMARY_ORDER_BGR:

                AAOutputFunc = (DstSurfFmt == BMF_16BPP_555) ?
                                    (AAOUTPUTFUNC)OutputAATo16BPP_555_BGR :
                                    (AAOUTPUTFUNC)OutputAATo16BPP_565_BGR;
                break;

            default:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo16BPP_ExtBGR;
                break;
            }

            break;

        case BMF_24BPP:

            AAOutputInfo.bgri.iR = DstOrder.Order[0];
            AAOutputInfo.bgri.iG = DstOrder.Order[1];
            AAOutputInfo.bgri.iB = DstOrder.Order[2];

            switch (AAOutputInfo.bgri.Order = DstOrder.Index) {

            case PRIMARY_ORDER_RGB:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo24BPP_RGB;
                break;

            case PRIMARY_ORDER_BGR:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo24BPP_BGR;
                break;

            default:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo24BPP_ORDER;
                break;
            }

            DBGP_IF(DBGP_FUNC,
                    DBGP("24BPP: Order=%ld, iR=%ld, iG=%ld, iB=%ld"
                        ARGDW(DstOrder.Index)
                        ARGDW(AAOutputInfo.bgri.iR)
                        ARGDW(AAOutputInfo.bgri.iG)
                        ARGDW(AAOutputInfo.bgri.iB)));

            break;

        case BMF_32BPP:

            AAOutputInfo.bgri.iR = DstOrder.Order[0];
            AAOutputInfo.bgri.iG = DstOrder.Order[1];
            AAOutputInfo.bgri.iB = DstOrder.Order[2];

            switch (AAOutputInfo.bgri.Order = DstOrder.Index) {

            case PRIMARY_ORDER_RGB:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo32BPP_RGB;
                break;

            case PRIMARY_ORDER_BGR:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo32BPP_BGR;
                break;

            default:

                AAOutputFunc = (AAOUTPUTFUNC)OutputAATo32BPP_ORDER;
                break;
            }

            DBGP_IF(DBGP_FUNC,
                    DBGP("32BPP: Order=%ld, iR=%ld, iG=%ld, iB=%ld"
                        ARGDW(DstOrder.Index)
                        ARGDW(AAOutputInfo.bgri.iR)
                        ARGDW(AAOutputInfo.bgri.iG)
                        ARGDW(AAOutputInfo.bgri.iB)));

            break;

        default:

            ASSERTMSG("Invalid Bitmap format", TRUE);

            AAOutputFunc = (AAOUTPUTFUNC)NULL;
            Result       = HTERR_INVALID_DEST_FORMAT;
            break;
        }

        if (pAAHdr->AAOutputFunc = AAOutputFunc) {

            pAAHdr->AAOutputInfo = AAOutputInfo;

            if (pAAHdr->Flags & AAHF_ALPHA_BLEND) {

                GetDstBFInfo(pAAHdr,
                             pHR->pBitbltParams->pABInfo,
                             DstSurfFmt,
                             DstOrder.Index);
            }

            DBGP_IF(DBGP_FUNC,
                    DBGP("*%s (%p), cOut=%ld, pOut=%p-%p, (%ld), c1st=%ld, XM=%02lx, Bit1st=%02lx, cLast=%02lx, pXlate=%p"
                        ARGPTR(GetAAOutputFuncName(AAOutputFunc))
                        ARGPTR(AAOutputFunc)
                        ARGDW(pAAHdr->pAAInfoCX->cOut)
                        ARGPTR(pAAHdr->pOutputBeg)
                        ARGPTR(pAAHdr->pOutputEnd)
                        ARGDW(pAAHdr->pOutputEnd - pAAHdr->pOutputBeg)
                        ARGDW(AAOutputInfo.bm.cFirst)
                        ARGDW(AAOutputInfo.bm.XorMask)
                        ARGDW(AAOutputInfo.bm.LSFirst)
                        ARGDW(AAOutputInfo.bm.cLast)
                        ARGPTR(pAAHdr->AAOutputInfo.pXlate8BPP)));

            DBG_TIMER_END(TIMER_SETUP);

            Result = AACYFunc(pAAHdr);

            DBG_TIMER_BEG(TIMER_SETUP);
        }

        if ((AAHFlags & AAHF_DO_CLR_MAPPING) && (pAAHdr->pBGRMapTable)) {

            DEREF_BGRMAPCACHE(pAAHdr->pBGRMapTable);
        }

        DBGP_IF(DBGP_AAHT_MEM,
                DBGP("AAHT: pHR=%ld, pDevClrAdj=%ld, pAAInfoX/Y=%ld:%ld, pAAHdr=%ld, Total=%ld"
                    ARGDW(sizeof(HALFTONERENDER))
                    ARGDW(sizeof(DEVCLRADJ)) ARGDW(pAAHdr->pAAInfoCX->cbAlloc)
                    ARGDW(pAAHdr->pAAInfoCY->cbAlloc) ARGDW(pAAHdr->cbAlloc)
                    ARGDW(sizeof(HALFTONERENDER) +
                          sizeof(DEVCLRADJ) + pAAHdr->pAAInfoCX->cbAlloc +
                          pAAHdr->pAAInfoCY->cbAlloc + pAAHdr->cbAlloc)));
    }

    if (!IsReleaseSem) {

        //============================================================
        // Release SEMAPHORE NOW since we did not release it yet
        //============================================================

        RELEASE_HTMUTEX(pDCI->HTMutex);
    }

    HTFreeMem(pAAHdr->pAAInfoCX);
    HTFreeMem(pAAHdr->pAAInfoCY);

    DBG_TIMER_END(TIMER_SETUP);

    return(Result);

#undef  bm8i
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htrender.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htrender.h


Abstract:

    This module contains halftone rendering declarations


Author:
    28-Mar-1992 Sat 20:58:50 updated  -by-  Daniel Chou (danielc)
        Update for VGA16 support, so it intenally compute at 4 primaries.

    22-Jan-1991 Tue 12:46:48 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/



#ifndef _HTRENDER_
#define _HTRENDER_




#define GET_PHTSI_CXSIZE(pHTSI)     (pHTSI->ScanLineDelta)


#define VALIDATE_HTSI_SRC           0
#define VALIDATE_HTSI_DEST          1
#define VALIDATE_HTSI_MASK          2



//
// Function prototypes
//


BOOL
HTENTRY
ValidateRGBBitFields(
    PBFINFO pBFInfo
    );

LONG
HTENTRY
ValidateHTSI(
    PHALFTONERENDER pHR,
    UINT            ValidateMode
    );

LONG
HTENTRY
ComputeBytesPerScanLine(
    UINT            SurfaceFormat,
    UINT            AlignmentBytes,
    DWORD           WidthInPel
    );

BOOL
HTENTRY
IntersectRECTL(
    PRECTL  prclA,
    PRECTL  prclB
    );

LONG
HTENTRY
ComputeByteOffset(
    UINT    SurfaceFormat,
    LONG    xLeft,
    LPBYTE  pPixelInByteSkip
    );

LONG
HTENTRY
AAHalftoneBitmap(
    PHALFTONERENDER pHR
    );


#endif  // _HTRENDER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htsetbmp.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htsetbmp.h


Abstract:

    This module contains all local definitions for the htsetbmp.c


Author:
    28-Mar-1992 Sat 20:59:29 updated  -by-  Daniel Chou (danielc)
        Add Support for VGA16, and also make output only 1 destinaiton pointer
        for 3 planer.

    03-Apr-1991 Wed 10:32:00 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:



--*/


#ifndef _HTSETBMP_
#define _HTSETBMP_


//
//**************************************************************************
// Anti-Aliasing macros that getting the primary color table
//**************************************************************************


#define _DEF_LUTAAHDR                                                       \
    DWORD       ExtBGR[LUTAA_HDR_COUNT]


#define DEF_COPY_LUTAAHDR                                                   \
    _DEF_LUTAAHDR;                                                          \
    GET_LUTAAHDR(ExtBGR, pIdxBGR)


#define PPAT_NEXT(pCur, pEnd, cbWrap)                                       \
{                                                                           \
    if (((LPBYTE)(pCur) += SIZE_PER_PAT) >= (LPBYTE)(pEnd)) {               \
                                                                            \
        (LPBYTE)(pCur) += (cbWrap);                                         \
    }                                                                       \
}

#define PPAT_NEXT_CONTINUE(pCur, pEnd, cbAdd, cbWrap)                       \
{                                                                           \
    if (((LPBYTE)(pCur) += (cbAdd)) < (LPBYTE)(pEnd)) {                     \
                                                                            \
        continue;                                                           \
    }                                                                       \
                                                                            \
    (LPBYTE)(pCur) += (cbWrap);                                             \
}


//
// Access to BGRF's MACROs
//

#define _GET_B_CLR(pClr)            (pIdxBGR[      (UINT)(pClr)->b])
#define _GET_G_CLR(pClr)            (pIdxBGR[256 + (UINT)(pClr)->g])
#define _GET_R_CLR(pClr)            (pIdxBGR[512 + (UINT)(pClr)->r])


#define GET_GRAY_PRIM(pClr)         (DWORD)(_GET_B_CLR(pClr) +              \
                                            _GET_G_CLR(pClr) +              \
                                            _GET_R_CLR(pClr))

#define GET_GRAY_IDX(pClr,pPat,i)   (GET_GRAY_PRIM(pClr)-GETMONOPAT(pPat, i))

#define _GET_B_IDX(pClr,pPat,i)     (_GET_B_CLR(pClr) - GETPAT(pPat, 0, i))
#define _GET_G_IDX(pClr,pPat,i)     (_GET_G_CLR(pClr) - GETPAT(pPat, 2, i))
#define _GET_R_IDX(pClr,pPat,i)     (_GET_R_CLR(pClr) - GETPAT(pPat, 4, i))

//
//**************************************************************************
// 1BPP Macros
//**************************************************************************


#define GRAY_GRAY_PRIM(pClr)         (DWORD)(((pClr)->Gray ^ 0xFFFF) >> 4)

#define GRAY_GRAY_IDX(pClr,pPat,i)   (GRAY_GRAY_PRIM(pClr)-GETMONOPAT(pPat, i))



#define GRAY_1BPP_COPY(pPat, dwMask) (GRAY_GRAY_IDX(pbgrf, pPat, 0) & (dwMask))

#define _GRAY_1BPP_BIT(pPat, Idx, M) (GRAY_GRAY_IDX(pbgrf+Idx, pPat, Idx) & (M))


#define GRAY_1BPP_COPY_BYTE(pPat)                                            \
    (BYTE)((_GRAY_1BPP_BIT(pPat, 0, 0x800000) |                              \
            _GRAY_1BPP_BIT(pPat, 1, 0x400000) |                              \
            _GRAY_1BPP_BIT(pPat, 2, 0x200000) |                              \
            _GRAY_1BPP_BIT(pPat, 3, 0x100000) |                              \
            _GRAY_1BPP_BIT(pPat, 4, 0x080000) |                              \
            _GRAY_1BPP_BIT(pPat, 5, 0x040000) |                              \
            _GRAY_1BPP_BIT(pPat, 6, 0x020000) |                              \
            _GRAY_1BPP_BIT(pPat, 7, 0x010000)) >> 16)

#define GET_1BPP_MASK_BYTE(pbgrf)   (BYTE)(((pbgrf + 0)->f & 0x80) |        \
                                           ((pbgrf + 1)->f & 0x40) |        \
                                           ((pbgrf + 2)->f & 0x20) |        \
                                           ((pbgrf + 3)->f & 0x10) |        \
                                           ((pbgrf + 4)->f & 0x08) |        \
                                           ((pbgrf + 5)->f & 0x04) |        \
                                           ((pbgrf + 6)->f & 0x02) |        \
                                           ((pbgrf + 7)->f & 0x01))

//
//**************************************************************************
// 4BPP Macros
//**************************************************************************

#define _GET_4BPP_CLR_COPY_NIBBLE(pPat, b, g, r, mb, mg, mr, XM)            \
            ((BYTE)((((b-GETPAT(pPat, 0, 0)) & ExtBGR[mb]) |                \
                     ((g-GETPAT(pPat, 2, 0)) & ExtBGR[mg]) |                \
                     ((r-GETPAT(pPat, 4, 0)) & ExtBGR[mr])) >> 16) ^ (XM))

#define _GET_4BPP_CLR_COPY_BYTE(pPat, b1, g1, r1, b2, g2, r2, XM)           \
            ((BYTE)((((b1-GETPAT(pPat, 0, 0)) & ExtBGR[0]) |                \
                     ((g1-GETPAT(pPat, 2, 0)) & ExtBGR[1]) |                \
                     ((r1-GETPAT(pPat, 4, 0)) & ExtBGR[2]) |                \
                     ((b2-GETPAT(pPat, 0, 1)) & ExtBGR[3]) |                \
                     ((g2-GETPAT(pPat, 2, 1)) & ExtBGR[4]) |                \
                     ((r2-GETPAT(pPat, 4, 1)) & ExtBGR[5])) >> 16) ^ (XM))


#define GET_4BPP_CLR_COPY_HIDX(pDst, pPat, pbgrf, XorMask)                  \
{                                                                           \
    *pDst = (*pDst & 0x0F) |                                                \
             _GET_4BPP_CLR_COPY_NIBBLE(pPat,                                \
                                      _GET_B_CLR(pbgrf),                    \
                                      _GET_G_CLR(pbgrf),                    \
                                      _GET_R_CLR(pbgrf), 0, 1, 2, XorMask); \
}

#define GET_4BPP_CLR_COPY_LIDX(pDst, pPat, pbgrf, XorMask)                  \
{                                                                           \
    *pDst = (*pDst & 0xF0) |                                                \
             _GET_4BPP_CLR_COPY_NIBBLE(pPat,                                \
                                      _GET_B_CLR(pbgrf),                    \
                                      _GET_G_CLR(pbgrf),                    \
                                      _GET_R_CLR(pbgrf), 3, 4, 5, XorMask); \
}

#define GET_4BPP_CLR_COPY_BYTE(pDst, pPat, XorMask)                         \
{                                                                           \
    *pDst = _GET_4BPP_CLR_COPY_BYTE(pPat,                                   \
                                    _GET_B_CLR(pbgrf),                      \
                                    _GET_G_CLR(pbgrf),                      \
                                    _GET_R_CLR(pbgrf),                      \
                                    _GET_B_CLR(pbgrf+1),                    \
                                    _GET_G_CLR(pbgrf+1),                    \
                                    _GET_R_CLR(pbgrf+1), XorMask);          \
}


//
//**************************************************************************
// VGA16 Macros
//**************************************************************************

#define _GET_VGA16_CLR_COPY_NIBBLE(pPat, b, g, r, mb, mg, mr, XM)           \
        VGA16Xlate[((((b-GETPAT(pPat, 0, 0)) & ExtBGR[mb]) |                \
                     ((g-GETPAT(pPat, 2, 0)) & ExtBGR[mg]) |                \
                     ((r-GETPAT(pPat, 4, 0)) & ExtBGR[mr])) >> 16) ^ (XM)]

#define _GET_VGA16_CLR_COPY_BYTE(pPat, b1, g1, r1, b2, g2, r2, XM)          \
        VGA16Xlate[((((b1-GETPAT(pPat, 0, 0)) & ExtBGR[0]) |                \
                     ((g1-GETPAT(pPat, 2, 0)) & ExtBGR[1]) |                \
                     ((r1-GETPAT(pPat, 4, 0)) & ExtBGR[2]) |                \
                     ((b2-GETPAT(pPat, 0, 1)) & ExtBGR[3]) |                \
                     ((g2-GETPAT(pPat, 2, 1)) & ExtBGR[4]) |                \
                     ((r2-GETPAT(pPat, 4, 1)) & ExtBGR[5])) >> 16) ^ (XM)]


#define GET_VGA16_CLR_COPY_HIDX(pDst, pPat, pbgrf, XorMask)                 \
{                                                                           \
    *pDst = (*pDst & 0x0F) |                                                \
             _GET_VGA16_CLR_COPY_NIBBLE(pPat,                               \
                                      _GET_B_CLR(pbgrf),                    \
                                      _GET_G_CLR(pbgrf),                    \
                                      _GET_R_CLR(pbgrf), 0, 1, 2, XorMask); \
}

#define GET_VGA16_CLR_COPY_LIDX(pDst, pPat, pbgrf, XorMask)                 \
{                                                                           \
    *pDst = (*pDst & 0xF0) |                                                \
             _GET_VGA16_CLR_COPY_NIBBLE(pPat,                               \
                                      _GET_B_CLR(pbgrf),                    \
                                      _GET_G_CLR(pbgrf),                    \
                                      _GET_R_CLR(pbgrf), 3, 4, 5, XorMask); \
}

#define GET_VGA16_CLR_COPY_BYTE(pDst, pPat, XorMask)                        \
{                                                                           \
    *pDst = _GET_VGA16_CLR_COPY_BYTE(pPat,                                  \
                                    _GET_B_CLR(pbgrf),                      \
                                    _GET_G_CLR(pbgrf),                      \
                                    _GET_R_CLR(pbgrf),                      \
                                    _GET_B_CLR(pbgrf+1),                    \
                                    _GET_G_CLR(pbgrf+1),                    \
                                    _GET_R_CLR(pbgrf+1), XorMask);          \
}


//
//**************************************************************************
// VGA256 8BPP Macros
//**************************************************************************

#define GET_VGA256_IDX_CLR_XLATE(pDst, pPat, p1, p2, p3, pXlate)            \
{                                                                           \
    *pDst++ = pXlate[((((DWORD)p1 - GETPAT(pPat, 0, 0)) >>  6) & 0x1c0) |   \
                     ((((DWORD)p2 - GETPAT(pPat, 2, 0)) >>  9) & 0x038) |   \
                     ((((DWORD)p3 - GETPAT(pPat, 4, 0)) >> 12) & 0x007)];   \
}

#define _GET_VGA256_CLR_COPY_XLATE(pPat, pXlate, b, g, r)                   \
            pXlate[(((b - GETPAT(pPat, 0, 0)) & 0x1c00000) |                \
                    ((g - GETPAT(pPat, 2, 0)) & 0x0380000) |                \
                    ((r - GETPAT(pPat, 4, 0)) & 0x0070000)) >> 16]


#define GET_VGA256_CLR_COPY_XLATE(pPat, pXlate)                             \
            _GET_VGA256_CLR_COPY_XLATE(pPat, pXlate,                        \
                                       _GET_B_CLR(pbgrf),                   \
                                       _GET_G_CLR(pbgrf),                   \
                                       _GET_R_CLR(pbgrf))

#define GET_VGA256_GRAY_COPY(pPat)  (BYTE)(GET_GRAY_IDX(pbgrf, pPat, 0) >> 12)

#define GET_VGA256_GRAY_COPY_XLATE(pPat, pXlate)                            \
                                pXlate[GET_GRAY_IDX(pbgrf, pPat, 0) >> 12]


//
//**************************************************************************
// Mask 8BPP Macros
//**************************************************************************

#define GET_P8BPPXLATE(p, bm8i)                                             \
    ASSERT((bm8i).Data.pXlateIdx <= XLATE_IDX_MAX);                         \
    p = p8BPPXlate[(bm8i).Data.pXlateIdx]

#define _GET_MASK8BPP_K_332(b, g, r, pXlate)                                \
        (BYTE)((((r-PatC) & (PatC-ExtBGR[2]) & 0xe0000) |                   \
                ((g-PatM) & (PatM-ExtBGR[1]) & 0x1c000) |                   \
                ((b-PatY) & (PatY-ExtBGR[0]) & 0x03000))>>12)

#define _GET_MASK8BPP_332(pDst, pPat, b, g, r, pXlate)                      \
        *pDst = (BYTE)((((b-GETPAT(pPat,0,0))&0x030000) |                   \
                        ((g-GETPAT(pPat,2,0))&0x1C0000) |                   \
                        ((r-GETPAT(pPat,4,0))&0xE00000))>>16)

#define _GET_MASK8BPP_K_332_XLATE(b, g, r, pXlate)                          \
        (BYTE)pXlate[((((r-PatC) & (PatC-ExtBGR[2]) & 0xe0000) |            \
                       ((g-PatM) & (PatM-ExtBGR[1]) & 0x1c000) |            \
                       ((b-PatY) & (PatY-ExtBGR[0]) & 0x03000))>>12)]

#define _GET_MASK8BPP_332_XLATE(pDst, pPat, b, g, r, pXlate)                \
        *pDst = (BYTE)pXlate[((((b-GETPAT(pPat,0,0))&0x030000) |            \
                               ((g-GETPAT(pPat,2,0))&0x1C0000) |            \
                               ((r-GETPAT(pPat,4,0))&0xE00000))>>16)]

#define _GET_MASK8BPP_XLATE(pDst, pPat, b, g, r, pXlate)                    \
        *pDst = (BYTE)pXlate[((((b-GETPAT(pPat,0,0))&0x0070000) |           \
                               ((g-GETPAT(pPat,2,0))&0x0380000) |           \
                               ((r-GETPAT(pPat,4,0))&0x1c00000))>>16)]

#define _GET_MASK8BPP_K_XLATE(b, g, r, pXlate)                              \
        (BYTE)pXlate[((((r-PatC) & (PatC-ExtBGR[2]) & 0x1c0000) |           \
                       ((g-PatM) & (PatM-ExtBGR[1]) & 0x038000) |           \
                       ((b-PatY) & (PatY-ExtBGR[0]) & 0x007000)) >> 12)]


#define _GET_MASK8BPP_REP_K(pDst, pPat, b, g, r, BMACRO, pMacData)          \
{                                                                           \
    DWORD   u;                                                              \
    DWORD   PatC;                                                           \
    DWORD   PatM;                                                           \
    DWORD   PatY;                                                           \
    DWORD   irgb[4];                                                        \
    DWORD   dwDst;                                                          \
    BYTE    bDst;                                                           \
                                                                            \
    dwDst    = ((irgb[0] = r) < (irgb[1] = g)) ? 0 : 1;                     \
    irgb[2]  =                                                              \
    irgb[3]  = b;                                                           \
    dwDst   |= ((irgb[dwDst] < irgb[2]) ? 0 : 1) << 1;                      \
    u        = irgb[dwDst] >> 21;                                           \
    PatY     = (DWORD)GETPAT(pPat, 0, 0);                                   \
    PatM     = (DWORD)GETPAT(pPat, 2, 0);                                   \
    PatC     = (DWORD)GETPAT(pPat, 4, 0);                                   \
    bDst     = bm8i.Data.bBlack;                                            \
                                                                            \
    if ((u < PatC) && (u < PatM) && (u < PatY)) {                           \
                                                                            \
        bDst = BMACRO(irgb[2], irgb[1], irgb[0], pMacData);                 \
    }                                                                       \
                                                                            \
    *pDst = bDst;                                                           \
}


#define GET_MASK8BPP(pDst, pPat, bMac, pMacData)                            \
            bMac(pDst, pPat,                                                \
                 _GET_B_CLR(pbgrf), _GET_G_CLR(pbgrf),  _GET_R_CLR(pbgrf),  \
                 pMacData)

#define GET_MASK8BPP_REP_K(pDst, pPat, bMac, pMacData)                      \
            _GET_MASK8BPP_REP_K(pDst, pPat,                                 \
                                _GET_B_CLR(pbgrf),                          \
                                _GET_G_CLR(pbgrf),                          \
                                _GET_R_CLR(pbgrf),                          \
                                bMac, pMacData)

#define GET_MASK8BPP_MONO(pDst, pPat, g1, bXor)                             \
            *pDst = (BYTE)(((g1)-GETMONOPAT(pPat, 0)) >> 12) ^ (bXor)


//
//**************************************************************************
// 16BPP_555 Macros/16BPP_565
//**************************************************************************

#define _GET_16BPP_COPY_W_MASK(pPat, b, g, r, bm, gm, rm, xm)               \
            (WORD)((((((b) - GETPAT(pPat, 0, 0)) & (bm)) |                  \
                     (((g) - GETPAT(pPat, 2, 0)) & (gm)) |                  \
                     (((r) - GETPAT(pPat, 4, 0)) & (rm))) ^ (xm)) >> 16)

#define _GET_16BPP_COPY_DW_MASK(pPat, b1, g1, r1, b2, g2, r2, bm,gm,rm,xm)  \
            ((DWORD)((((((b1) - GETPAT(pPat, 0, 0)) & (bm)) |               \
                       (((g1) - GETPAT(pPat, 2, 0)) & (gm)) |               \
                       (((r1) - GETPAT(pPat, 4, 0)) & (rm))) >> 16)   |     \
                     ( (((b2) - GETPAT(pPat, 0, 1)) & (bm)) |               \
                       (((g2) - GETPAT(pPat, 2, 1)) & (gm)) |               \
                       (((r2) - GETPAT(pPat, 4, 1)) & (rm)))) ^ (xm))

#define GET_16BPP_COPY_W_MASK(pPat, bm, gm, rm, xm)                         \
            _GET_16BPP_COPY_W_MASK(pPat,                                    \
                                   _GET_B_CLR(pbgrf),                       \
                                   _GET_G_CLR(pbgrf),                       \
                                   _GET_R_CLR(pbgrf),                       \
                                   bm, gm, rm, xm)

#define GET_16BPP_COPY_DW_MASK(pPat, bm, gm, rm, xm)                        \
            _GET_16BPP_COPY_DW_MASK(pPat,                                   \
                                    _GET_B_CLR(pbgrf),                      \
                                    _GET_G_CLR(pbgrf),                      \
                                    _GET_R_CLR(pbgrf),                      \
                                    _GET_B_CLR(pbgrf + 1),                  \
                                    _GET_G_CLR(pbgrf + 1),                  \
                                    _GET_R_CLR(pbgrf + 1),                  \
                                    bm, gm, rm, xm)



//
// Functions prototype
//


VOID
HTENTRY
OutputAATo1BPP(
    PAAHEADER       pAAHdr,
    PGRAYF          pbgrf,
    PGRAYF          pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );


VOID
HTENTRY
OutputAATo4BPP(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAAToVGA16(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

LPBYTE
HTENTRY
BuildVGA256Xlate(
    LPBYTE  pXlate,
    LPBYTE  pNewXlate
    );

VOID
HTENTRY
OutputAAToVGA256(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_B332(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_K_B332(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_B332_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_K_B332_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_K_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_MONO(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo8BPP_MONO(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_ExtBGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_555_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_555_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_565_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo16BPP_565_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo24BPP_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo24BPP_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo24BPP_ORDER(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo32BPP_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo32BPP_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

VOID
HTENTRY
OutputAATo32BPP_ORDER(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    );

LONG
HTENTRY
CreateHalftoneBrushPat(
    PDEVICECOLORINFO    pDCI,
    PCOLORTRIAD         pColorTriad,
    PDEVCLRADJ          pDevClrAdj,
    LPBYTE              pDest,
    LONG                cbDestNext
    );


#if DBG

LPSTR
GetAAOutputFuncName(
    AAOUTPUTFUNC    AAOutputFunc
    );

#endif


#endif  // _HTSETBMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htstret.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htstret.c


Abstract:

    This module contains stretching functions to setup the parameters for
    compress or expanding the bitmap.


Author:

    24-Jan-1991 Thu 10:08:11 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/

#define DBGP_VARNAME        dbgpHTStret



#include "htp.h"
#include "htmapclr.h"
#include "htpat.h"
#include "htalias.h"
#include "htrender.h"
#include "htgetbmp.h"
#include "htsetbmp.h"
#include "htstret.h"
#include "limits.h"


#define DBGP_PSD                0x00000001
#define DBGP_EXP                0x00000002
#define DBGP_AAHT_MEM           0x00000004
#define DBGP_EXPAND             0x00000008
#define DBGP_SRK2               0x00000010


DEF_DBGPVAR(BIT_IF(DBGP_PSD,        0)  |
            BIT_IF(DBGP_EXP,        0)  |
            BIT_IF(DBGP_AAHT_MEM,   0)  |
            BIT_IF(DBGP_EXPAND,     0)  |
            BIT_IF(DBGP_SRK2,       0))


CONST WORD BGR555Idx[] = {

    0x0100,0x011f,0x013e,0x015d,0x017c,0x019c,0x01bb,0x01da,
    0x01f9,0x0218,0x0237,0x0256,0x0275,0x0295,0x02b4,0x02d3,
    0x02f2,0x0311,0x0330,0x034f,0x036e,0x038d,0x03ad,0x03cc,
    0x03eb,0x040a,0x0429,0x0448,0x0467,0x0486,0x04a6,0x04c5,
    0x04e4,0x0503,0x0522,0x0541,0x0560,0x057f,0x059e,0x05be,
    0x05dd,0x05fc,0x061b,0x063a,0x0659,0x0678,0x0697,0x06b7,
    0x06d6,0x06f5,0x0714,0x0733,0x0752,0x0771,0x0790,0x07af,
    0x07cf,0x07ee,0x080d,0x082c,0x084b,0x086a,0x0889,0x08a8,
    0x08c8,0x08e7,0x0906,0x0925,0x0944,0x0963,0x0982,0x09a1,
    0x09c0,0x09e0,0x09ff,0x0a1e,0x0a3d,0x0a5c,0x0a7b,0x0a9a,
    0x0ab9,0x0ad9,0x0af8,0x0b17,0x0b36,0x0b55,0x0b74,0x0b93,
    0x0bb2,0x0bd1,0x0bf1,0x0c10,0x0c2f,0x0c4e,0x0c6d,0x0c8c,
    0x0cab,0x0cca,0x0cea,0x0d09,0x0d28,0x0d47,0x0d66,0x0d85,
    0x0da4,0x0dc3,0x0de2,0x0e02,0x0e21,0x0e40,0x0e5f,0x0e7e,
    0x0e9d,0x0ebc,0x0edb,0x0efb,0x0f1a,0x0f39,0x0f58,0x0f77,
    0x0f96,0x0fb5,0x0fd4,0x0ff3,0x1013,0x1032,0x1051,0x1070,
    0x108f,0x10ae,0x10cd,0x10ec,0x110c,0x112b,0x114a,0x1169,
    0x1188,0x11a7,0x11c6,0x11e5,0x1204,0x1224,0x1243,0x1262,
    0x1281,0x12a0,0x12bf,0x12de,0x12fd,0x131d,0x133c,0x135b,
    0x137a,0x1399,0x13b8,0x13d7,0x13f6,0x1415,0x1435,0x1454,
    0x1473,0x1492,0x14b1,0x14d0,0x14ef,0x150e,0x152e,0x154d,
    0x156c,0x158b,0x15aa,0x15c9,0x15e8,0x1607,0x1626,0x1646,
    0x1665,0x1684,0x16a3,0x16c2,0x16e1,0x1700,0x171f,0x173f,
    0x175e,0x177d,0x179c,0x17bb,0x17da,0x17f9,0x1818,0x1837,
    0x1857,0x1876,0x1895,0x18b4,0x18d3,0x18f2,0x1911,0x1930,
    0x1950,0x196f,0x198e,0x19ad,0x19cc,0x19eb,0x1a0a,0x1a29,
    0x1a48,0x1a68,0x1a87,0x1aa6,0x1ac5,0x1ae4,0x1b03,0x1b22,
    0x1b41,0x1b61,0x1b80,0x1b9f,0x1bbe,0x1bdd,0x1bfc,0x1c1b,
    0x1c3a,0x1c59,0x1c79,0x1c98,0x1cb7,0x1cd6,0x1cf5,0x1d14,
    0x1d33,0x1d52,0x1d72,0x1d91,0x1db0,0x1dcf,0x1dee,0x1e0d,
    0x1e2c,0x1e4b,0x1e6a,0x1e8a,0x1ea9,0x1ec8,0x1ee7,0x1f06,
    0x1f25,0x1f44,0x1f63,0x1f83,0x1fa2,0x1fc1,0x1fe0,0x1fff
    };


CONST WORD GrayIdxWORD[] = {

    0x0000,0x0101,0x0202,0x0303,0x0404,0x0505,0x0606,0x0707,
    0x0808,0x0909,0x0a0a,0x0b0b,0x0c0c,0x0d0d,0x0e0e,0x0f0f,
    0x1010,0x1111,0x1212,0x1313,0x1414,0x1515,0x1616,0x1717,
    0x1818,0x1919,0x1a1a,0x1b1b,0x1c1c,0x1d1d,0x1e1e,0x1f1f,
    0x2020,0x2121,0x2222,0x2323,0x2424,0x2525,0x2626,0x2727,
    0x2828,0x2929,0x2a2a,0x2b2b,0x2c2c,0x2d2d,0x2e2e,0x2f2f,
    0x3030,0x3131,0x3232,0x3333,0x3434,0x3535,0x3636,0x3737,
    0x3838,0x3939,0x3a3a,0x3b3b,0x3c3c,0x3d3d,0x3e3e,0x3f3f,
    0x4040,0x4141,0x4242,0x4343,0x4444,0x4545,0x4646,0x4747,
    0x4848,0x4949,0x4a4a,0x4b4b,0x4c4c,0x4d4d,0x4e4e,0x4f4f,
    0x5050,0x5151,0x5252,0x5353,0x5454,0x5555,0x5656,0x5757,
    0x5858,0x5959,0x5a5a,0x5b5b,0x5c5c,0x5d5d,0x5e5e,0x5f5f,
    0x6060,0x6161,0x6262,0x6363,0x6464,0x6565,0x6666,0x6767,
    0x6868,0x6969,0x6a6a,0x6b6b,0x6c6c,0x6d6d,0x6e6e,0x6f6f,
    0x7070,0x7171,0x7272,0x7373,0x7474,0x7575,0x7676,0x7777,
    0x7878,0x7979,0x7a7a,0x7b7b,0x7c7c,0x7d7d,0x7e7e,0x7f7f,
    0x8080,0x8181,0x8282,0x8383,0x8484,0x8585,0x8686,0x8787,
    0x8888,0x8989,0x8a8a,0x8b8b,0x8c8c,0x8d8d,0x8e8e,0x8f8f,
    0x9090,0x9191,0x9292,0x9393,0x9494,0x9595,0x9696,0x9797,
    0x9898,0x9999,0x9a9a,0x9b9b,0x9c9c,0x9d9d,0x9e9e,0x9f9f,
    0xa0a0,0xa1a1,0xa2a2,0xa3a3,0xa4a4,0xa5a5,0xa6a6,0xa7a7,
    0xa8a8,0xa9a9,0xaaaa,0xabab,0xacac,0xadad,0xaeae,0xafaf,
    0xb0b0,0xb1b1,0xb2b2,0xb3b3,0xb4b4,0xb5b5,0xb6b6,0xb7b7,
    0xb8b8,0xb9b9,0xbaba,0xbbbb,0xbcbc,0xbdbd,0xbebe,0xbfbf,
    0xc0c0,0xc1c1,0xc2c2,0xc3c3,0xc4c4,0xc5c5,0xc6c6,0xc7c7,
    0xc8c8,0xc9c9,0xcaca,0xcbcb,0xcccc,0xcdcd,0xcece,0xcfcf,
    0xd0d0,0xd1d1,0xd2d2,0xd3d3,0xd4d4,0xd5d5,0xd6d6,0xd7d7,
    0xd8d8,0xd9d9,0xdada,0xdbdb,0xdcdc,0xdddd,0xdede,0xdfdf,
    0xe0e0,0xe1e1,0xe2e2,0xe3e3,0xe4e4,0xe5e5,0xe6e6,0xe7e7,
    0xe8e8,0xe9e9,0xeaea,0xebeb,0xecec,0xeded,0xeeee,0xefef,
    0xf0f0,0xf1f1,0xf2f2,0xf3f3,0xf4f4,0xf5f5,0xf6f6,0xf7f7,
    0xf8f8,0xf9f9,0xfafa,0xfbfb,0xfcfc,0xfdfd,0xfefe,0xffff
    };


#define GET_555IDX(b,g,r,s) (((((LONG)BGR555Idx[b]-(s)) & 0x1F00) << 2) |   \
                             ((((LONG)BGR555Idx[g]-(s)) & 0x1F00) >> 3) |   \
                             ((((LONG)BGR555Idx[r]-(s))         ) >> 8))


#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)           // EBP modified with inline asm
#endif




VOID
HTENTRY
MappingBGR(
    PBGR8   pbgr,
    LONG    cbgr,
    PBGR8   pBGRMapTable,
    LPBYTE  pbPat555
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Dec-1998 Thu 12:37:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#if defined(_X86_)

    _asm {

        push    ebp

        cld
        mov     edi, pbgr
        mov     ecx, cbgr
        mov     esi, pBGRMapTable
        mov     ebx, pbPat555

LoadPat555:
        movzx   ebp, BYTE PTR [ebx]
        inc     ebx

BGRLoop:
        movzx   eax, BYTE PTR [edi]
        movzx   eax, WORD PTR BGR555Idx[eax * 2];
        sub     eax, ebp
        shl     ah, 2

        movzx   edx, BYTE PTR [edi + 1]
        movzx   edx, WORD PTR BGR555Idx[edx * 2];
        sub     edx, ebp
        xor     dl, dl
        shr     edx, 3
        or      dh, ah

        movzx   eax, BYTE PTR [edi + 2]
        movzx   eax, WORD PTR BGR555Idx[eax * 2];
        sub     eax, ebp
        or      dl, ah
        lea     edx, DWORD PTR [edx * 2 + edx]

        mov     ax, WORD PTR [esi + edx]
        stosw
        mov     al, BYTE PTR [esi + edx + 2]
        stosb

        dec     ecx
        jz      Done

        movzx   ebp, BYTE PTR [ebx]
        inc     ebx
        or      ebp, ebp
        jnz     BGRLoop
        sub     ebx, CX_SIZE_RGB555PAT
        jmp     LoadPat555

Done:
        pop     ebp
    }

#else
    PBGR8   pbgrEnd;
    LONG    Pat555;


    pbgrEnd = pbgr + cbgr;
    Pat555  = (LONG)*pbPat555++;

    do {

        *pbgr = pBGRMapTable[GET_555IDX(pbgr->b, pbgr->g, pbgr->r, Pat555)];

        if (!(Pat555 = (LONG)*pbPat555++)) {

            Pat555 = (LONG)*(pbPat555 -= CX_SIZE_RGB555PAT);
        }

    } while (++pbgr < pbgrEnd);

#endif
}



VOID
HTENTRY
MappingBGRF(
    PBGRF   pbgrf,
    PBGRF   pbgrfEnd,
    PBGR8   pBGRMapTable,
    LPBYTE  pbPat555
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Dec-1998 Thu 12:37:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#if defined(_X86_)

    _asm {

        push    ebp

        cld
        mov     edi, pbgrf
        mov     ecx, pbgrfEnd
        mov     esi, pBGRMapTable
        mov     ebx, pbPat555

LoadPat555:
        movzx   ebp, BYTE PTR [ebx]
        inc     ebx

BGRLoop:
        movzx   eax, BYTE PTR [edi]
        movzx   eax, WORD PTR BGR555Idx[eax * 2];
        sub     eax, ebp
        shl     ah, 2

        movzx   edx, BYTE PTR [edi + 1]
        movzx   edx, WORD PTR BGR555Idx[edx * 2];
        sub     edx, ebp
        xor     dl, dl
        shr     edx, 3
        or      dh, ah

        movzx   eax, BYTE PTR [edi + 2]
        movzx   eax, WORD PTR BGR555Idx[eax * 2];
        sub     eax, ebp
        or      dl, ah
        lea     edx, DWORD PTR [edx * 2 + edx]

        mov     ax, WORD PTR [esi + edx]
        stosw
        mov     al, BYTE PTR [esi + edx + 2]
        stosb
        inc     edi

        cmp     edi, ecx
        jae     Done

        movzx   ebp, BYTE PTR [ebx]
        inc     ebx
        or      ebp, ebp
        jnz     BGRLoop
        sub     ebx, CX_SIZE_RGB555PAT
        jmp     LoadPat555

Done:
        pop     ebp
    }

#else
    LONG    Pat555;


    Pat555  = (LONG)*pbPat555++;

    do {

        *(PBGR8)pbgrf = *(PBGR8)(pBGRMapTable + GET_555IDX(pbgrf->b,
                                                           pbgrf->g,
                                                           pbgrf->r,
                                                           Pat555));

        if (!(Pat555 = (LONG)*pbPat555++)) {

            Pat555 = (LONG)*(pbPat555 -= CX_SIZE_RGB555PAT);
        }

    } while (++pbgrf < pbgrfEnd);

#endif
}




VOID
AlphaBlendBGRF(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Feb-1999 Fri 15:18:26 created  -by-  Daniel Chou (danielc)


Revision History:

    06-Sep-2000 Wed 11:13:59 updated  -by-  Daniel Chou (danielc)
        Adding the supports for pre-multiply source alpha and optimized for
        different alphablending cases

--*/

{
#define pGrayF  ((PGRAYF)pbgrf)
#define pwBGR   ((LPWORD)pbBGR)
#define pbDst   ((LPBYTE)pDstBGR)

    PBGRF   pbgrf;
    PBGRF   pbgrfEnd;
    LPBYTE  pbBGR;
    PBGR8   pDstBGR;
    DWORD   AAHFlags;
    DWORD   r;
    DWORD   g;
    DWORD   b;
    BOOL    DoGray;


    //
    // Start Alpha Blend
    //

    AAHFlags = pAAHdr->Flags;
    DoGray   = (BOOL)(pAAHdr->SrcSurfInfo.Flags & AASIF_GRAY);
    pbgrf    = (PBGRF)pAAHdr->pRealOutBeg;
    pbgrfEnd = (PBGRF)pAAHdr->pRealOutEnd;
    pbBGR    = pAAHdr->pAlphaBlendBGR;

    //
    // Read in the destination first
    //

    pAAHdr->DstSurfInfo.InputFunc(&(pAAHdr->DstSurfInfo),
                                  pDstBGR = pAAHdr->pInputBeg);

    if (AAHFlags & AAHF_CONST_ALPHA) {

        //
        // Const alpha blending case, we only need to read the destination
        // and blend it with compute/cached constant alpha table
        //

        if (AAHFlags & AAHF_HAS_MASK) {

            if (DoGray) {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        GET_CONST_ALPHA_GRAY(pbgrf, pbDst, pwBGR);
                    }

                    ++pbDst;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        GET_CONST_ALPHA_BGR(pbgrf, pDstBGR, pwBGR);
                    }

                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);
            }

        } else {

            if (DoGray) {

                do {

                    GET_CONST_ALPHA_GRAY(pbgrf, pbDst, pwBGR);
                    ++pbDst;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    GET_CONST_ALPHA_BGR(pbgrf, pDstBGR, pwBGR);
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);
            }
        }

    } else {

        LPBYTE      pCA;
        LONG        CA;
        WORD        DstGray;
        BYTE        bCA;

        //
        // This is per-pixel alpha blending, we first read the source alpha
        // channel information, the source may be stretched (expand, same or
        // shrinked)
        //

        pAAHdr->GetAVCYFunc(pAAHdr);

        pCA = (LPBYTE)pAAHdr->pSrcAV;

        if (DoGray) {

            //
            // This is gray scale destination case
            //

            if (AAHFlags & AAHF_HAS_MASK) {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        DstGray = GRAY_B2W(*pbDst);

                        switch (*pCA) {

                        case 0:

                            GET_GRAY_AB_DST(pGrayF->Gray, DstGray);
                            break;

                        case 0xFF:

                            GET_GRAY_AB_SRC(pGrayF->Gray, DstGray);
                            break;

                        default:

                            pGrayF->Gray = GET_GRAY_ALPHA_BLEND(pGrayF->Gray,
                                                                DstGray,
                                                                *pCA);
                        }
                    }

                    ++pCA;
                    ++pbDst;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    DstGray = GRAY_B2W(*pbDst++);

                    switch (*pCA) {

                    case 0:

                        GET_GRAY_AB_DST(pGrayF->Gray, DstGray);
                        break;

                    case 0xFF:

                        GET_GRAY_AB_SRC(pGrayF->Gray, DstGray);
                        break;

                    default:

                        pGrayF->Gray = GET_GRAY_ALPHA_BLEND(pGrayF->Gray,
                                                            DstGray,
                                                            *pCA);
                    }

                    ++pCA;

                } while (++pbgrf < pbgrfEnd);
            }

        } else if (AAHFlags & AAHF_AB_DEST) {

            PBGRF   pbgrfDst;

            //
            // This is color RGB alpha blend WITH alpha channel blending.
            // so we already read from the destination into the BGR order in
            // pDstBGR, and pCA points to the alpha value in the source
            // pbgrf is current source stretching/aliasing result.  We need to
            // get destination alpha channel information from pbgrfDst->f
            //
            // The source and destination both is 32bpp and we also need to
            // update the destination alpha value
            //

            pbgrfDst = (PBGRF)pAAHdr->DstSurfInfo.pb;

            if (AAHFlags & AAHF_HAS_MASK) {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        switch (bCA = *pCA) {

                        case 0:

                            GET_AB_BGR_DST(pbgrf, pbBGR, pDstBGR);
                            GET_AB_DEST_CA_DST(bCA, pbgrfDst->f);
                            break;

                        case 0xFF:

                            GET_AB_BGR_SRC(pbgrf, pbBGR, pDstBGR);
                            GET_AB_DEST_CA_SRC(bCA, pbgrfDst->f);
                            break;

                        default:

                            CA = GET_CA_VALUE(bCA);
                            GET_AB_DEST_CA(bCA, pbgrfDst->f, CA);
                            GET_ALPHA_BLEND_BGR(pbgrf, pbBGR, pDstBGR, CA);
                            break;
                        }
                    }

                    ++pCA;
                    ++pbgrfDst;
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    switch (bCA = *pCA++) {

                    case 0:

                        GET_AB_BGR_DST(pbgrf, pbBGR, pDstBGR);
                        GET_AB_DEST_CA_DST(bCA, pbgrfDst->f);
                        break;

                    case 0xFF:

                        GET_AB_BGR_SRC(pbgrf, pbBGR, pDstBGR);
                        GET_AB_DEST_CA_SRC(bCA, pbgrfDst->f);
                        break;

                    default:

                        CA = GET_CA_VALUE(bCA);
                        GET_AB_DEST_CA(bCA, pbgrfDst->f, CA);
                        GET_ALPHA_BLEND_BGR(pbgrf, pbBGR, pDstBGR, CA);
                        break;
                    }

                    ++pbgrfDst;
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);
            }

        } else {

            //
            // This is color RGB alpha blend only without alpha channel blend
            // so we already read from the destination into the BGR order in
            // pDstBGR, and pCA points to the alpha value in the source
            // pbgrf is current source stretching/aliasing result
            //

            if (AAHFlags & AAHF_HAS_MASK) {

                do {

                    if (PBGRF_HAS_MASK(pbgrf)) {

                        switch (*pCA) {

                        case 0:

                            GET_AB_BGR_DST(pbgrf, pbBGR, pDstBGR);
                            break;

                        case 0xFF:

                            GET_AB_BGR_SRC(pbgrf, pbBGR, pDstBGR);
                            break;

                        default:

                            CA = GET_CA_VALUE(*pCA);
                            GET_ALPHA_BLEND_BGR(pbgrf, pbBGR, pDstBGR, CA);
                            break;
                        }
                    }

                    ++pCA;
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);

            } else {

                do {

                    switch (*pCA) {

                    case 0:

                        GET_AB_BGR_DST(pbgrf, pbBGR, pDstBGR);
                        break;

                    case 0xFF:

                        GET_AB_BGR_SRC(pbgrf, pbBGR, pDstBGR);
                        break;

                    default:

                        CA = GET_CA_VALUE(*pCA);
                        GET_ALPHA_BLEND_BGR(pbgrf, pbBGR, pDstBGR, CA);
                        break;
                    }

                    ++pCA;
                    ++pDstBGR;

                } while (++pbgrf < pbgrfEnd);
            }
        }
    }

#undef pbDst
#undef pwBGR
#undef pGrayF
}



LONG
HTENTRY
TileDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pGrayF  ((PGRAYF)pOut)
#define pbIn    ((LPBYTE)pIn)
#define pwIn    ((LPWORD)pInCur)

    AAHEADER    AAHdr;
    LPWORD      pwGray;
    LONG        cyLoop;
    LONG        xSrcBeg;
    LONG        xSrcInc;
    LONG        cxAvai;
    LONG        cxFirst;


    AAHdr   = *pAAHdr;
    pwGray  = (LPWORD)AAHdr.pAAInfoCY->pbExtra;
    cyLoop  = AAHdr.DstSurfInfo.cy;
    xSrcBeg = (LONG)AAHdr.pAAInfoCX->iSrcBeg;
    xSrcInc = xSrcBeg * ((AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) ? sizeof(WORD) :
                                                                  sizeof(BGR8));
    cxFirst = AAHdr.SrcSurfInfo.cx - xSrcBeg;

    while (cyLoop--) {

        PBGR8   pIn;
        PBGR8   pInCur;
        PBGR8   pOut;
        LONG    cInCur;
        LONG    cOutCur;
        LONG    cxAvai;


        pIn = GetFixupScan(&AAHdr, AAHdr.pInputBeg);

        if (AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) {

            cxAvai = AAHdr.SrcSurfInfo.cx;
            pwIn   = pwGray;

            while (cxAvai--) {

                *pwIn++ = GRAY_B2W(*pbIn++);
            }

            pIn = (PBGR8)pwGray;
        }

        pInCur  = (PBGR8)((LPBYTE)pIn + xSrcInc);
        pOut    = (PBGR8)AAHdr.pAABufBeg;
        cOutCur = AAHdr.DstSurfInfo.cx;
        cxAvai  = cxFirst;

        while (cOutCur) {

            if ((cInCur = cxAvai) > cOutCur) {

                cInCur = cOutCur;
            }

            cxAvai   = AAHdr.SrcSurfInfo.cx;
            cOutCur -= cInCur;

            if (AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) {

                while (cInCur--) {

                    pGrayF->Gray  = *pwIn++;
                    (LPBYTE)pOut += AAHdr.AABufInc;
                }

            } else {

                while (cInCur--) {

                    *pOut         = *pInCur++;
                    (LPBYTE)pOut += AAHdr.AABufInc;
                }
            }

            pInCur = pIn;
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);

#undef  pGrayF
#undef  pbIn
#undef  pwIn
}



VOID
HTENTRY
GrayCopyDIB_CXGray(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    14-Apr-1999 Wed 15:22:05 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    do {

        pOut->Gray = GRAY_B2W(*pIn++);

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




VOID
HTENTRY
GrayRepDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    WORD        wGray;


    pRep     = pAAInfo->Src.pRep;
    pRepEnd  = pAAInfo->Src.pRepEnd;
    cRep     = 1;

    do {

        if (--cRep == 0) {

            cRep  = (DWORD)pRep->c;
            wGray = GRAY_B2W(*pIn);

            if (pRep < pRepEnd) {

                ++pRep;
                ++pIn;
            }
        }

        pOut->Gray = wGray;

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




VOID
HTENTRY
RepDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    BGR8        bgr8;



    pRep    = pAAInfo->Src.pRep;
    pRepEnd = pAAInfo->Src.pRepEnd;
    cRep    = 1;

    do {

        if (--cRep == 0) {

            cRep = (DWORD)pRep->c;
            bgr8 = *pIn;

            if (pRep < pRepEnd) {

                ++pRep;
                ++pIn;
            }
        }

        *pOut = bgr8;

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




LONG
HTENTRY
RepDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    PBGRF       pAABufBeg;
    PBGRF       pAABufEnd;
    LONG        AABufInc;



    pAAInfo  = AAHdr.pAAInfoCY;
    pRep     = pAAInfo->Src.pRep;
    pRepEnd  = pAAInfo->Src.pRepEnd;
    cRep     = 1;

    if (AAHdr.Flags & AAHF_ALPHA_BLEND) {

        pAABufBeg = (PBGRF)pAAInfo->pbExtra;
        pAABufEnd = (PBGRF)((PBGR8)pAAInfo->pbExtra + AAHdr.DstSurfInfo.cx);
        AABufInc  = sizeof(BGR8);

    } else {

        pAABufBeg = AAHdr.pAABufBeg;
        pAABufEnd = AAHdr.pAABufEnd;
        AABufInc  = AAHdr.AABufInc;
    }

    while (AAHdr.DstSurfInfo.cy--) {

        if (--cRep == 0) {

            cRep = (DWORD)pRep->c;

            if (pRep < pRepEnd) {

                AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                               GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                               (PBGR8)pAABufBeg,
                               (LPBYTE)pAABufEnd,
                               AABufInc);

                ++pRep;
            }
        }

        if (AAHdr.Flags & AAHF_ALPHA_BLEND) {

            CopyDIB_CX(NULL,
                       (PBGR8)pAABufBeg,
                       (PBGR8)AAHdr.pAABufBeg,
                       (LPBYTE)AAHdr.pAABufEnd,
                       AAHdr.AABufInc);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(pAAHdr->DstSurfInfo.cy);
}




VOID
HTENTRY
CopyDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    26-Jun-1998 Fri 11:33:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    do {

        *pOut = *pIn++;

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}



LONG
HTENTRY
BltDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr;
    PBGR8       pIn;
    LONG        cLoop;

    AAHdr = *pAAHdr;
    cLoop = AAHdr.pAAInfoCY->cOut;

    while (cLoop--) {

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)AAHdr.pAABufBeg,
                       (LPBYTE)AAHdr.pAABufEnd,
                       AAHdr.AABufInc);

        if (AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) {

            PBGRF   pbgrf;

            pbgrf = AAHdr.pRealOutBeg;

            do {

                ((PGRAYF)pbgrf)->Gray = GRAY_B2W(pbgrf->b);

            } while (++pbgrf < AAHdr.pRealOutEnd);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}



VOID
HTENTRY
GraySkipDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Apr-1999 Mon 12:57:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;


    pRep    = pAAInfo->Src.pRep;
    pRepEnd = pAAInfo->Src.pRepEnd;

    do {

        ASSERT(pRep < pRepEnd);

        pIn        += pRep++->c;
        pOut->Gray  = GRAY_B2W(*(pIn - 1));

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




VOID
HTENTRY
SkipDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Apr-1999 Mon 12:57:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;


    pRep    = pAAInfo->Src.pRep;
    pRepEnd = pAAInfo->Src.pRepEnd;

    do {

        ASSERT(pRep < pRepEnd);

        pIn   += pRep++->c;
        *pOut  = *(pIn - 1);

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}





LONG
HTENTRY
SkipDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Apr-1999 Mon 12:58:00 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PAAINFO     pAAInfo;
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    LONG        cRep;


    pAAInfo = AAHdr.pAAInfoCY;
    pRep    = pAAInfo->Src.pRep;
    pRepEnd = pAAInfo->Src.pRepEnd;

    while (AAHdr.DstSurfInfo.cy--) {

        ASSERT(pRep < pRepEnd);

        //
        // Skip the source scan lines (cRep - 1) by calling GetFixupScan()
        // with a NULL buffer pointer, !!!! we must not alter the
        // SrcSurfInfo.pb at here
        //

        cRep = (LONG)(pRep++->c);

        while (--cRep > 0) {

            GetFixupScan(&AAHdr, NULL);
        }

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)AAHdr.pAABufBeg,
                       (LPBYTE)AAHdr.pAABufEnd,
                       AAHdr.AABufInc);

        OUTPUT_AA_CURSCAN;
    }

    return(pAAHdr->DstSurfInfo.cy);
}




VOID
HTENTRY
ShrinkDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PSHRINKDATA pSD;
    PLONG       pMap;
    PLONG       pMap256X;
    PBGR8       pInEnd;
    RGBL        rgbOut[3];
    RGBL        rgbT;
    UINT        Mul;
    UINT        cPreLoad;



    pInEnd = pIn + pAAInfo->cIn;

    if (Mul = (UINT)pAAInfo->PreMul) {

        rgbOut[2].r  = MULRGB(pIn->r, Mul);
        rgbOut[2].g  = MULRGB(pIn->g, Mul);
        rgbOut[2].b  = MULRGB(pIn->b, Mul);
        pIn         += pAAInfo->PreSrcInc;

    } else {

        ZeroMemory(&rgbOut[2], sizeof(rgbOut[2]));
    }

    pSD      = (PSHRINKDATA)(pAAInfo->pAAData);
    pMap256X = pAAInfo->pMapMul;
    cPreLoad = (UINT)pAAInfo->cPreLoad;

    while (cPreLoad) {

        Mul  = (UINT)((pSD++)->Mul);
        pMap = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul         &= SDF_MUL_MASK;
            rgbOut[2].r += (rgbT.r = MULRGB(pIn->r, Mul));
            rgbOut[2].g += (rgbT.g = MULRGB(pIn->g, Mul));
            rgbOut[2].b += (rgbT.b = MULRGB(pIn->b, Mul));

            CopyMemory(&rgbOut[0], &rgbOut[1], sizeof(rgbOut[0]) * 2);

            rgbOut[2].r  = pMap[(pIn  )->r] - rgbT.r;
            rgbOut[2].g  = pMap[(pIn  )->g] - rgbT.g;
            rgbOut[2].b  = pMap[(pIn++)->b] - rgbT.b;

            --cPreLoad;

        } else {

            rgbOut[2].r += pMap[(pIn  )->r];
            rgbOut[2].g += pMap[(pIn  )->g];
            rgbOut[2].b += pMap[(pIn++)->b];
        }
    }

    if (pAAInfo->cPreLoad == 1) {

        rgbOut[0] = rgbOut[1];
    }

    while (Mul = (UINT)((pSD++)->Mul)) {

        pMap = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul         &= SDF_MUL_MASK;
            rgbOut[2].r += (rgbT.r = MULRGB(pIn->r, Mul));
            rgbOut[2].g += (rgbT.g = MULRGB(pIn->g, Mul));
            rgbOut[2].b += (rgbT.b = MULRGB(pIn->b, Mul));

            SHARPEN_PRGB_LR(pOut, rgbOut[0], rgbOut[1], rgbOut[2], DI_R_SHIFT);

            (LPBYTE)pOut += OutInc;

            CopyMemory(&rgbOut[0], &rgbOut[1], sizeof(rgbOut[0]) * 2);

            rgbOut[2].r = pMap[(pIn  )->r] - rgbT.r;
            rgbOut[2].g = pMap[(pIn  )->g] - rgbT.g;
            rgbOut[2].b = pMap[(pIn++)->b] - rgbT.b;

        } else {

            rgbOut[2].r += pMap[(pIn  )->r];
            rgbOut[2].g += pMap[(pIn  )->g];
            rgbOut[2].b += pMap[(pIn++)->b];
        }
    }

    ASSERT(pIn == pInEnd);

    if ((LPBYTE)pOut == (pOutEnd - OutInc)) {

        SHARPEN_PRGB_LR(pOut, rgbOut[0], rgbOut[1], rgbOut[1], DI_R_SHIFT);
    }
}




LONG
HTENTRY
ShrinkDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This function shrink the scanline down first in Y direction from source
    bitmap when it is done for group of scanlines then it call AXFunc to
    compose current scanline (it may be Shrink(CX) or Expand(CX)) to the
    final output BGR8 buffer

    The shrink is done by sharpen the current pixel first.



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr;
    PSHRINKDATA pSD;
    SHRINKDATA  sd;
    PBGR8       pIBuf;
    PBGR8       pICur;
    PBGR8       pOCur;
    PRGBL       prgbIn[3];
    PRGBL       prgb0;
    PRGBL       prgb1;
    PRGBL       prgb2;
    PRGBL       prgb2End;
    PLONG       pMap;
    PLONG       pMapMul;
    PLONG       pMapMul2;
    PLONG       pMap256Y;
    RGBL        rgbT;
    BGR8        rgbCur;
    LONG        cbrgbY;
    LONG        Mul;
    LONG        cAAData;
    BOOL        CopyFirst;
    LONG        cyOut;
    INT         cPreLoad;
    BYTE        Mask;

    //
    // Adding 3 to each side of pIBuf for ExpandDIB_CX
    //

    AAHdr     = *pAAHdr;
    pMap256Y  = AAHdr.pAAInfoCY->pMapMul;
    pMapMul   = (PLONG)(AAHdr.pAAInfoCY->pbExtra);
    pMapMul2  = pMapMul + 256;
    cbrgbY    = (LONG)(AAHdr.SrcSurfInfo.cx * sizeof(RGBL));
    prgbIn[0] = (PRGBL)(pMapMul2 + 256);
    prgbIn[1] = (PRGBL)((LPBYTE)prgbIn[0] + cbrgbY);
    prgbIn[2] = (PRGBL)((LPBYTE)prgbIn[1] + cbrgbY);
    pIBuf     = (PBGR8)((LPBYTE)prgbIn[2] + cbrgbY) + 3;

    ASSERT_MEM_ALIGN(prgbIn[0], sizeof(LONG));
    ASSERT_MEM_ALIGN(prgbIn[1], sizeof(LONG));
    ASSERT_MEM_ALIGN(prgbIn[2], sizeof(LONG));

    if (Mul = AAHdr.pAAInfoCY->PreMul) {

        pMap   = pMapMul;
        rgbT.r = -Mul;

        do {

            pMap[0] = (rgbT.r += Mul);

        } while (++pMap < pMapMul2);

        pICur    = GetFixupScan(&AAHdr, AAHdr.pInputBeg);
        pOCur    = pIBuf;
        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        do {

            prgb2->r     = pMapMul[(pICur  )->r];
            prgb2->g     = pMapMul[(pICur  )->g];
            prgb2->b     = pMapMul[(pICur++)->b];

        } while (++prgb2 < prgb2End);

        //
        // The AAInputFunc() will increment the pointer, so reduced it
        //

        if (!(AAHdr.pAAInfoCY->PreSrcInc)) {

            AAHdr.Flags |= AAHF_GET_LAST_SCAN;
        }
    }

    pSD       = (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData);
    cPreLoad  = (INT)AAHdr.pAAInfoCY->cPreLoad;
    CopyFirst = (BOOL)(cPreLoad == 1);
    cAAData   = AAHdr.pAAInfoCY->cAAData;
    cyOut     = 0;

    while (cAAData--) {

        pICur    = GetFixupScan(&AAHdr, AAHdr.pInputBeg);
        sd       = *pSD++;
        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);
        Mask     = GET_SDF_LARGE_MASK(sd.Mul);

        if (sd.Mul & SDF_DONE) {

            //
            // Build current Mul Table
            //

            Mul    = (LONG)(sd.Mul & SDF_MUL_MASK);
            pMap   = pMapMul;
            rgbT.r = -Mul;
            rgbT.b = (LONG)(pMap256Y[1] - Mul + (LONG)(Mask & 0x01));
            rgbT.g = -rgbT.b;

            do {

                pMap[  0] = (rgbT.r += Mul);
                pMap[256] = (rgbT.g += rgbT.b);

            } while (++pMap < pMapMul2);

            //
            // Finished a scanline, so to see if have prev/next to sharpen with
            //

            prgb0 = prgbIn[0];
            prgb1 = prgbIn[1];

            if (cPreLoad-- > 0) {

                do {

                    prgb2->r     += pMapMul[pICur->r];
                    prgb2->g     += pMapMul[pICur->g];
                    prgb2->b     += pMapMul[pICur->b];
                    prgb0->r      = pMapMul[pICur->r + 256];
                    prgb0->g      = pMapMul[pICur->g + 256];
                    prgb0->b      = pMapMul[pICur->b + 256];

                    ++pICur;
                    prgb0++;

                } while (++prgb2 < prgb2End);

                if (CopyFirst) {

                    CopyMemory(prgb1, prgbIn[2], cbrgbY);
                    CopyFirst = FALSE;
                }

            } else {

                pOCur = pIBuf;

                do {

                    rgbCur    = *pICur++;
                    prgb2->r += pMapMul[rgbCur.r];
                    prgb2->g += pMapMul[rgbCur.g];
                    prgb2->b += pMapMul[rgbCur.b];

                    SHARPEN_PRGB_LR(pOCur,
                                    (*prgb0),
                                    (*prgb1),
                                    (*prgb2),
                                    DI_R_SHIFT);

                    prgb0->r = pMapMul[rgbCur.r + 256];
                    prgb0->g = pMapMul[rgbCur.g + 256];
                    prgb0->b = pMapMul[rgbCur.b + 256];

                    ++pOCur;
                    ++prgb0;
                    ++prgb1;

                } while (++prgb2 < prgb2End);

                AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                               pIBuf,
                               (PBGR8)AAHdr.pAABufBeg,
                               (LPBYTE)AAHdr.pAABufEnd,
                               AAHdr.AABufInc);

                OUTPUT_AA_CURSCAN;

                ++cyOut;
            }

            prgb2     = prgbIn[0];
            prgbIn[0] = prgbIn[1];
            prgbIn[1] = prgbIn[2];
            prgbIn[2] = prgb2;

        } else {

            pMap = (PLONG)((LPBYTE)pMap256Y + GET_SDF_LARGE_OFF(sd.Mul));

            do {

                prgb2->r     += pMap[(pICur  )->r];
                prgb2->g     += pMap[(pICur  )->g];
                prgb2->b     += pMap[(pICur++)->b];

            } while (++prgb2 < prgb2End);
        }
    }

    if (AAHdr.DstSurfInfo.pb != AAHdr.pOutLast) {

        //
        // Do the last line if exist
        //

        pOCur    = pIBuf;
        prgb0    = prgbIn[0];
        prgb2    = prgbIn[1];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        do {

            SHARPEN_PRGB_LR(pOCur,
                            (*prgb0),
                            (*prgb2),
                            (*prgb2),
                            DI_R_SHIFT);

            ++prgb0;
            ++pOCur;

        } while (++prgb2 < prgb2End);

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       pIBuf,
                       (PBGR8)AAHdr.pAABufBeg,
                       (LPBYTE)AAHdr.pAABufEnd,
                       AAHdr.AABufInc);

        OUTPUT_AA_CURSCAN;

        ++cyOut;
    }

    ASSERTMSG("Shrink: cScan not equal", cyOut == AAHdr.DstSurfInfo.cy);

    return(cyOut);
}





VOID
HTENTRY
SrkYDIB_SrkCX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PSHRINKDATA pSD;
    PLONG       pMap;
    PLONG       pMap256X;
    BGR8        rgbIn;
    RGBL        rgbOut;
    RGBL        rgbT;
    UINT        Mul;


    if (Mul = (UINT)pAAInfo->PreMul) {

        rgbOut.r  = MULRGB(pIn->r, Mul);
        rgbOut.g  = MULRGB(pIn->g, Mul);
        rgbOut.b  = MULRGB(pIn->b, Mul);
        pIn      += pAAInfo->PreSrcInc;

    } else {

        ZeroMemory(&rgbOut, sizeof(rgbOut));
    }

    pSD      = (PSHRINKDATA)(pAAInfo->pAAData);
    pMap256X = pAAInfo->pMapMul;

    while (Mul = (UINT)((pSD++)->Mul)) {

        pMap   = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));
        rgbIn  = *pIn++;

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul         &= SDF_MUL_MASK;
            rgbOut.r    += (rgbT.r = MULRGB(rgbIn.r, Mul));
            rgbOut.g    += (rgbT.g = MULRGB(rgbIn.g, Mul));
            rgbOut.b    += (rgbT.b = MULRGB(rgbIn.b, Mul));

            RGB_DIMAX_TO_BYTE(pOut, rgbOut, pOut++);

            rgbOut.r     = pMap[rgbIn.r] - rgbT.r;
            rgbOut.g     = pMap[rgbIn.g] - rgbT.g;
            rgbOut.b     = pMap[rgbIn.b] - rgbT.b;

        } else {

            rgbOut.r += pMap[rgbIn.r];
            rgbOut.g += pMap[rgbIn.g];
            rgbOut.b += pMap[rgbIn.b];
        }
    }
}




LONG
HTENTRY
ShrinkDIB_CY_SrkCX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This function shrink the scanline down first in Y direction from source
    bitmap when it is done for group of scanlines then it call AXFunc to
    compose current scanline (it may be Shrink(CX) or Expand(CX)) to the
    final output BGR8 buffer

    The shrink is done by sharpen the current pixel first.



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr;
    PSHRINKDATA pSD;
    PBGR8       pICur;
    PBGR8       pOCur;
    PRGBL       prgbIn[4];
    PRGBL       prgb0;
    PRGBL       prgb1;
    PRGBL       prgb2;
    PRGBL       prgb1End;
    PRGBL       prgb2End;
    PLONG       pMap;
    PLONG       pMapMul;
    PLONG       pMapMul2;
    PLONG       pMap256Y;
    RGBL        rgbT;
    BGR8        rgbIn;
    LONG        cbrgbY;
    LONG        cyOut;
    UINT        cPreLoad;
    UINT        cPLCX;
    UINT        LargeInc;
    UINT        Mul;


    AAHdr     = *pAAHdr;
    pMap256Y  = AAHdr.pAAInfoCY->pMapMul;
    pMapMul   = (PLONG)(AAHdr.pAAInfoCY->pbExtra);
    pMapMul2  = pMapMul + 256;
    cbrgbY    = (LONG)((AAHdr.pAAInfoCX->cAADone + 2) * sizeof(RGBL));
    prgbIn[0] = (PRGBL)(pMapMul2 + 256);
    prgbIn[1] = (PRGBL)((LPBYTE)prgbIn[0] + cbrgbY);
    prgbIn[2] = (PRGBL)((LPBYTE)prgbIn[1] + cbrgbY);

    ++prgbIn[0];
    ++prgbIn[1];
    ++prgbIn[2];

    cbrgbY -= (sizeof(RGBL) * 2);
    cPLCX   = (UINT)(AAHdr.pAAInfoCX->cPreLoad - 1);

    if (Mul = (UINT)AAHdr.pAAInfoCY->PreMul) {

        SrkYDIB_SrkCX(AAHdr.pAAInfoCX,
                      GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                      pICur = AAHdr.pInputBeg);

        pMap   = pMapMul;
        rgbT.r = -(LONG)Mul;

        do {

            pMap[0] = (rgbT.r += Mul);

        } while (++pMap < pMapMul2);

        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        do {

            prgb2->r = pMapMul[(pICur  )->r];
            prgb2->g = pMapMul[(pICur  )->g];
            prgb2->b = pMapMul[(pICur++)->b];

        } while (++prgb2 < prgb2End);

        //
        // The AAInputFunc() will increment the pointer, so reduced it
        //

        if (!(AAHdr.pAAInfoCY->PreSrcInc)) {

            AAHdr.Flags |= AAHF_GET_LAST_SCAN;
        }
    }

    pSD       = (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData);
    cPreLoad  = (UINT)AAHdr.pAAInfoCY->cPreLoad;
    cyOut     = 0;

    while (cPreLoad) {

        Mul      = (UINT)(pSD++)->Mul;
        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        DBGP_IF(DBGP_PSD,
                DBGP("pSD[%3ld]=%4ld, Flags=0x%04lx"
                    ARGDW(pSD - (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData) - 1)
                    ARGDW(Mul & DI_NUM_MASK) ARGDW(Mul & ~DI_NUM_MASK)));

        SrkYDIB_SrkCX(AAHdr.pAAInfoCX,
                      GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                      pICur = AAHdr.pInputBeg);

        if (Mul & SDF_DONE) {

            //
            // Build current Mul Table
            //

            LargeInc  = GET_SDF_LARGE_INC(Mul);
            Mul      &= SDF_MUL_MASK;
            pMap      = pMapMul;
            rgbT.r    = -(LONG)Mul;
            rgbT.b    = (LONG)(pMap256Y[1] - Mul + LargeInc);
            rgbT.g    = -rgbT.b;

            do {

                pMap[  0] = (rgbT.r += Mul);
                pMap[256] = (rgbT.g += rgbT.b);

            } while (++pMap < pMapMul2);

            //
            // Finished a scanline, so to see if have prev/next to sharpen with
            //

            prgbIn[3] =
            prgb0     = prgbIn[0];

            do {

                (prgb2  )->r += pMapMul[(pICur  )->r      ];
                (prgb2  )->g += pMapMul[(pICur  )->g      ];
                (prgb2  )->b += pMapMul[(pICur  )->b      ];
                (prgb0  )->r  = pMapMul[(pICur  )->r + 256];
                (prgb0  )->g  = pMapMul[(pICur  )->g + 256];
                (prgb0++)->b  = pMapMul[(pICur++)->b + 256];

            } while (++prgb2 < prgb2End);

            prgbIn[0] = prgbIn[1];
            prgbIn[1] = prgbIn[2];
            prgbIn[2] = prgbIn[3];

            --cPreLoad;

        } else {

            pMap = (PLONG)((LPBYTE)pMap256Y + GET_SDF_LARGE_OFF(Mul));

            do {

                prgb2->r += pMap[(pICur  )->r];
                prgb2->g += pMap[(pICur  )->g];
                prgb2->b += pMap[(pICur++)->b];

            } while (++prgb2 < prgb2End);
        }
    }

    if (AAHdr.pAAInfoCY->cPreLoad == 1) {

        CopyMemory(prgbIn[0], prgbIn[1], cbrgbY);
    }

    while (Mul = (UINT)((pSD++)->Mul)) {

        prgb2    = prgbIn[2];
        prgb2End = (PRGBL)((LPBYTE)prgb2 + cbrgbY);

        DBGP_IF(DBGP_PSD,
                DBGP("pSD[%3ld]=%4ld, Flags=0x%04lx"
                    ARGDW(pSD - (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData) - 1)
                    ARGDW(Mul & DI_NUM_MASK) ARGDW(Mul & ~DI_NUM_MASK)));

        SrkYDIB_SrkCX(AAHdr.pAAInfoCX,
                      GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                      pICur = AAHdr.pInputBeg);

        if (Mul & SDF_DONE) {

            //
            // Build current Mul Table
            //

            LargeInc  = GET_SDF_LARGE_INC(Mul);
            Mul      &= SDF_MUL_MASK;
            pMap      = pMapMul;
            rgbT.r    = -(LONG)Mul;
            rgbT.b    = (LONG)(pMap256Y[1] - Mul + LargeInc);
            rgbT.g    = -rgbT.b;

            do {

                pMap[  0] = (rgbT.r += Mul);
                pMap[256] = (rgbT.g += rgbT.b);

            } while (++pMap < pMapMul2);

            //
            // Finished a scanline, so to see if have prev/next to sharpen with
            //

            prgbIn[3]    =
            prgb0        = prgbIn[0];
            prgb1        = prgbIn[1];
            prgb1End     = (PRGBL)((LPBYTE)prgb1 + cbrgbY);
            *(prgb1End ) = *(prgb1End - 1);
            pOCur        = (PBGR8)AAHdr.pAABufBeg;

            if (cPLCX) {

                rgbIn         = *pICur++;
                (prgb2  )->r += pMapMul[rgbIn.r      ];
                (prgb2  )->g += pMapMul[rgbIn.g      ];
                (prgb2++)->b += pMapMul[rgbIn.b      ];
                (prgb0  )->r  = pMapMul[rgbIn.r + 256];
                (prgb0  )->g  = pMapMul[rgbIn.g + 256];
                (prgb0++)->b  = pMapMul[rgbIn.b + 256];
                ++prgb1;

            } else {

                *(prgb1 - 1) = *prgb1;
            }

            do {

                rgbIn         = *pICur++;
                (prgb2  )->r += pMapMul[rgbIn.r];
                (prgb2  )->g += pMapMul[rgbIn.g];
                (prgb2  )->b += pMapMul[rgbIn.b];

                SHARPEN_PRGB_LRTB(pOCur, prgb0, prgb1, prgb2, DI_R_SHIFT);

                (prgb0  )->r  = pMapMul[rgbIn.r + 256];
                (prgb0  )->g  = pMapMul[rgbIn.g + 256];
                (prgb0++)->b  = pMapMul[rgbIn.b + 256];

                ++prgb1;
                ++prgb2;

            } while (((LPBYTE)pOCur += AAHdr.AABufInc) !=
                                                    (LPBYTE)AAHdr.pAABufEnd);

            if (prgb2 < prgb2End) {

                rgbIn       = *pICur;
                (prgb2)->r += pMapMul[rgbIn.r      ];
                (prgb2)->g += pMapMul[rgbIn.g      ];
                (prgb2)->b += pMapMul[rgbIn.b      ];
                (prgb0)->r  = pMapMul[rgbIn.r + 256];
                (prgb0)->g  = pMapMul[rgbIn.g + 256];
                (prgb0)->b  = pMapMul[rgbIn.b + 256];
            }

            prgbIn[0] = prgbIn[1];
            prgbIn[1] = prgbIn[2];
            prgbIn[2] = prgbIn[3];

            OUTPUT_AA_CURSCAN;

            ++cyOut;

        } else {

            pMap = (PLONG)((LPBYTE)pMap256Y + GET_SDF_LARGE_OFF(Mul));

            do {

                prgb2->r += pMap[(pICur  )->r];
                prgb2->g += pMap[(pICur  )->g];
                prgb2->b += pMap[(pICur++)->b];

            } while (++prgb2 < prgb2End);
        }
    }

    if (AAHdr.DstSurfInfo.pb != AAHdr.pOutLast) {

        //
        // Do the last line if exist
        //

        prgb0         = prgbIn[0];
        prgb1         = prgbIn[1];
        prgb1End      = (PRGBL)((LPBYTE)prgb1 + cbrgbY);
        *(prgb1End )  = *(prgb1End - 1);
        pOCur         = (PBGR8)AAHdr.pAABufBeg;

        *(prgb1 - 1)  = *prgb1;
        prgb0        += cPLCX;
        prgb1        += cPLCX;

        do {

            SHARPEN_PRGB_LRTB(pOCur, prgb0, prgb1, prgb1, DI_R_SHIFT);

            ++prgb0;
            ++prgb1;

        } while (((LPBYTE)pOCur += AAHdr.AABufInc) != (LPBYTE)AAHdr.pAABufEnd);

        OUTPUT_AA_CURSCAN;

        ++cyOut;
    }

    ASSERTMSG("Shrink: cScan not equal", cyOut == AAHdr.DstSurfInfo.cy);

    return(cyOut);
}




PBGR8
HTENTRY
SharpenInput(
    DWORD   AAHFlags,
    PBGR8   pbgrS,
    PBGR8   pbgr0,
    PBGR8   pbgr1,
    PBGR8   pbgr2,
    LONG    cbBGRIn
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Apr-1998 Fri 15:06:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PBGR8   pSBeg;
    PBGR8   pSEnd;
    PBGR8   pbgr1End;


    pSBeg    = pbgrS;
    pSEnd    = (PBGR8)((LPBYTE)pbgrS + cbBGRIn);
    pbgr1End = (PBGR8)((LPBYTE)pbgr1 + cbBGRIn);

    if (AAHFlags & AAHF_BBPF_AA_OFF) {

        pSBeg = pbgr1;
        pSEnd = pbgr1End;

    } else {

        *(pbgr1 - 1) = *pbgr1;
        *pbgr1End    = *(pbgr1End - 1);

#if defined(_X86_)

        _asm {

            push    ebp

            cld

            mov     edi, pbgrS
            mov     ebx, pbgr0
            mov     esi, pbgr1
            mov     edx, pbgr2
            mov     ebp, pbgr1End
            jmp     DoLoop

Special1:
            shr     eax, 24
            not     al
            jmp     StoreClr1
Special2:
            shr     eax, 24
            not     al
            jmp     StoreClr2
Special3:
            shr     eax, 24
            not     al
            jmp     StoreClr3

DoLoop:
            movzx   eax, BYTE PTR [esi]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx]
            sub     eax, ecx

            sar     eax, 3
            or      ah, ah
            jnz     Special1
StoreClr1:
            stosb
            movzx   eax, BYTE PTR [esi + 1]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 3 + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 3 + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 1]
            sub     eax, ecx

            sar     eax, 3
            or      ah, ah
            jnz     Special2
StoreClr2:
            stosb
            movzx   eax, BYTE PTR [esi + 2]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 3 + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 3 + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 2]
            sub     eax, ecx

            sar     eax, 3
            or      ah, ah
            jnz     Special3
StoreClr3:
            stosb

            add     ebx, 3
            add     edx, 3
            add     esi, 3

            cmp     esi, ebp
            jb      DoLoop

            pop     ebp
        }

#else
        while (pbgr1 < pbgr1End) {

            SHARPEN_PRGB_LRTB(pbgrS, pbgr0, pbgr1, pbgr2, 0);

            ++pbgrS;
            ++pbgr0;
            ++pbgr1;
            ++pbgr2;
        }
#endif
    }

    *(pSBeg - 3) =
    *(pSBeg - 2) =
    *(pSBeg - 1) = *pSBeg;
    *(pSEnd    ) =
    *(pSEnd + 1) = *(pSEnd - 1);

    return(pSBeg);
}




VOID
HTENTRY
ExpandDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAINFO      AAI = *pAAInfo;
    PBGR8       pInEnd;
    PEXPDATA    pED;
    BGR8        rgbIn[8];
    RGBL        rgbOut;
    UINT        cPreLoad;
    UINT        cAAData;
    UINT        Idx;


    pInEnd        = pIn + AAI.cIn + 2;
    *(pInEnd - 0) =
    *(pInEnd - 1) =
    *(pInEnd - 2) = *(pInEnd - 3);
    rgbIn[5]      = *pIn;
    INC_PIN_BY_1ST_LEFT(pIn, AAI.Flags);

    rgbIn[6] = *pIn++;
    cPreLoad = (UINT)AAI.cPreLoad;
    cAAData  = (UINT)(cPreLoad >> 4);

    if ((!(cPreLoad &= 0x0F)) && (cAAData)) {

        rgbIn[6] = rgbIn[5];
        ++cPreLoad;
        --cAAData;
        --pIn;
    }

    Idx = 4 - cPreLoad;

    while (cPreLoad--) {

        CopyMemory(&rgbIn[0], &rgbIn[1], sizeof(rgbIn[0]) * 6);

        rgbIn[6] = *pIn++;

        if (AAI.Flags & AAIF_EXP_NO_SHARPEN) {

            rgbIn[3] = rgbIn[5];

        } else {

            SHARPEN_RGB_LR(rgbIn[3], rgbIn[4], rgbIn[5], rgbIn[6], 0);
        }

        DBGP_IF(DBGP_EXP, DBGP("ExpDIB: PreLoad=%ld, pIn=%8lx"
                                        ARGDW(cPreLoad) ARGPTR(pIn)));
    }

    rgbIn[7] = rgbIn[Idx--];

    while (cAAData--) {

        rgbIn[Idx--] = rgbIn[7];
    }

    pED         = (PEXPDATA)(AAI.pAAData);
    pOutEnd    += OutInc;

    do {

        EXPDATA ed = *pED++;


        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            CopyMemory(&rgbIn[0], &rgbIn[1], sizeof(rgbIn[0]) * 6);

            rgbIn[6] = *pIn++;

            if (AAI.Flags & AAIF_EXP_NO_SHARPEN) {

                rgbIn[3] = rgbIn[5];

            } else {

                SHARPEN_RGB_LR(rgbIn[3], rgbIn[4], rgbIn[5], rgbIn[6], 0);
            }

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        rgbOut.r = MULRGB(rgbIn[3].r, ed.Mul[3]);
        rgbOut.g = MULRGB(rgbIn[3].g, ed.Mul[3]);
        rgbOut.b = MULRGB(rgbIn[3].b, ed.Mul[3]);

        if (ed.Mul[2]) {

            rgbOut.r += MULRGB(rgbIn[2].r, ed.Mul[2]);
            rgbOut.g += MULRGB(rgbIn[2].g, ed.Mul[2]);
            rgbOut.b += MULRGB(rgbIn[2].b, ed.Mul[2]);

            if (ed.Mul[1]) {

                rgbOut.r += MULRGB(rgbIn[1].r, ed.Mul[1]);
                rgbOut.g += MULRGB(rgbIn[1].g, ed.Mul[1]);
                rgbOut.b += MULRGB(rgbIn[1].b, ed.Mul[1]);

                if (ed.Mul[0]) {

                    rgbOut.r += MULRGB(rgbIn[0].r, ed.Mul[0]);
                    rgbOut.g += MULRGB(rgbIn[0].g, ed.Mul[0]);
                    rgbOut.b += MULRGB(rgbIn[0].b, ed.Mul[0]);
                }
            }
        }

        RGB_DIMAX_TO_BYTE(pOut, rgbOut, pOut);

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);

    ASSERT(pIn <= pInEnd);
}




VOID
HTENTRY
ExpYDIB_ExpCX(
    PEXPDATA    pED,
    PBGR8       pIn,
    PBGR8       pOut,
    PBGR8       pOutEnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    RGBL        rgbOut;

    do {

        UINT    Mul;
        EXPDATA ed = *pED++;


        INC_PIN_BY_EDF_LOAD_PIXEL(pIn, ed.Mul[0]);

        Mul      = (UINT)ed.Mul[3];
        rgbOut.r = MULRGB(pIn->r, Mul);
        rgbOut.g = MULRGB(pIn->g, Mul);
        rgbOut.b = MULRGB(pIn->b, Mul);

        if (Mul = (UINT)ed.Mul[2]) {

            rgbOut.r += MULRGB((pIn - 1)->r, Mul);
            rgbOut.g += MULRGB((pIn - 1)->g, Mul);
            rgbOut.b += MULRGB((pIn - 1)->b, Mul);

            if (Mul = (UINT)ed.Mul[1]) {

                rgbOut.r += MULRGB((pIn - 2)->r, Mul);
                rgbOut.g += MULRGB((pIn - 2)->g, Mul);
                rgbOut.b += MULRGB((pIn - 2)->b, Mul);

                if (Mul = (UINT)(ed.Mul[0] & ~(EDF_LOAD_PIXEL |
                                               EDF_NO_NEWSRC))) {

                    rgbOut.r += MULRGB((pIn - 3)->r, Mul);
                    rgbOut.g += MULRGB((pIn - 3)->g, Mul);
                    rgbOut.b += MULRGB((pIn - 3)->b, Mul);
                }
            }
        }

        RGB_DIMAX_TO_BYTE(pOut, rgbOut, pOut);

    } while (++pOut != pOutEnd);
}



LONG
HTENTRY
ExpandDIB_CY_ExpCX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This funtion anti-alias the bitmap by query scanlines from CX direction
    (may be Shrink(CX) or Expand(CX)) then compose current scanlines and output
    it to real BGR8 final buffer,

    The complication is need to have scanline one before current destination
    scanline, this may be because the source is not available or because the
    clipping is done on destination.

    Since the anti-alias for expanding requred at least four surounding
    scanlines to compose current scanline, it required large amount of
    memory to retain the prevous result scanlines

    The expanding is by sharpen the source pixel first before anti-aliasing
    smooth through

    prgbIn[0] - Previous un-sharpen source scan
                AND Last The 4th composition sharpened scan after sharpen
    prgbIn[1] - Current un-sharpen source scan
    prgbIn[2] - Next un-sharpen source scan
    prgbIn[3] - The 1st composition sharpened scan
    prgbIn[4] - The 2nd composition sharpened scan
    prgbIn[5] - The 3rd composition sharpened scan


    Exp=Load Sharpen Exp
    Srk=Load Srk Sharpen
    Cpy=Load Cpy


    Exp_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX) SharpenY ExpY
    Exp_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX) SharpenY ExpY
    Exp_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         ) SharpenY ExpY

    Srk_CY:Exp_CX   InputCX SrkY SharpenY Exp_CX:(LoadX SharpenX     ExpX)
    Srk_CY:Srk_CX   InputCX SrkY SharpenY Srk_CX:(LoadX     SrkX SharpenX)
    Srk_CY:Cpy_CX   InputCX SrkY SharpenY Cpy_CX:(LoadX     CpyX         )

    Cpy_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX)
    Cpy_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX)
    Cpy_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         )



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    PEXPDATA    pEDCX;
    PBGR8       prgbOut[4];
    PBGR8       prgbS;
    PLONG       pMap;
    PLONG       pMap0;
    PLONG       pMap0End;
    PBGR8       prgbIn0;
    PBGR8       prgbIn1;
    PBGR8       prgbIn2;
    PBGR8       prgb0;
    PBGR8       prgb1;
    PBGR8       prgb2;
    PBGR8       prgb3;
    PBGR8       pOCur;
    EXPDATA     ed;
    LONG        cb1stSharpen;
    LONG        cbrgbY;
    LONG        cbrgbIn;
    LONG        cAAData;
    LONG        cPreLoad;
    UINT        IdxOut;

    //
    // Figure out the horizontal scan line increment
    //

    pAAInfo  = AAHdr.pAAInfoCX;
    cPreLoad = (LONG)(pAAInfo->cPreLoad & 0x0F) - 1 +
               (LONG)((pAAInfo->Flags & AAIF_EXP_HAS_1ST_LEFT) ? 1 : 0);

    pEDCX        = (PEXPDATA)(pAAInfo->pAAData);
    pAAInfo      = AAHdr.pAAInfoCY;
    pMap0        = (PLONG)pAAInfo->pbExtra;
    pMap0End     = pMap0 + 256;
    cbrgbIn      = AAHdr.SrcSurfInfo.cx * sizeof(BGR8);
    cbrgbY       = AAHdr.DstSurfInfo.cx * sizeof(BGR8);
    prgbOut[0]   = (PBGR8)(pMap0 + (256 * 4));
    prgbOut[1]   = (PBGR8)((LPBYTE)prgbOut[0] + cbrgbY);
    prgbOut[2]   = (PBGR8)((LPBYTE)prgbOut[1] + cbrgbY);
    prgbOut[3]   = (PBGR8)((LPBYTE)prgbOut[2] + cbrgbY);
    prgbIn0      = (PBGR8)((LPBYTE)prgbOut[3] + cbrgbY) + 3;
    prgbIn1      = (PBGR8)((LPBYTE)prgbIn0    + cbrgbIn) + 6;
    prgbIn2      = (PBGR8)((LPBYTE)prgbIn1    + cbrgbIn) + 6;
    prgbS        = AAHdr.pInputBeg + 3;
    cb1stSharpen = (LONG)(sizeof(BGR8) * cPreLoad);
    IdxOut     = ~0;

    DBGP_IF(DBGP_AAHT_MEM,
            DBGP("prgbIn=%p:%p:%p, prgbOut=%p:%p:%p:%p, prgbS=%p, cb1stSharpen=%ld"
                ARGPTR(prgbIn0) ARGPTR(prgbIn1) ARGPTR(prgbIn2)
                ARGPTR(prgbOut[0]) ARGPTR(prgbOut[1]) ARGPTR(prgbOut[2])
                ARGPTR(prgbOut[3]) ARGPTR(prgbS) ARGDW(cb1stSharpen)));

    //
    // Always read first source
    //

    DBGP_IF(DBGP_EXPAND, DBGP("\nExpand: PRE-LOAD FIRST SCAN"));

    GetFixupScan(&AAHdr, prgbIn1);

    if (pAAInfo->Flags & AAIF_EXP_HAS_1ST_LEFT) {

        DBGP_IF(DBGP_EXPAND, DBGP("Expand: LOAD FIRST LEFT"));

        GetFixupScan(&AAHdr, prgbIn2);

    } else {

        DBGP_IF(DBGP_EXPAND, DBGP("Expand: COPY FIRST LEFT"));

        CopyMemory(prgbIn2, prgbIn1, cbrgbIn);
    }

    //
    // cPreLoad: Low 4 bits means real load, high 4 bit means imaginary load
    //

    DBGP_IF(DBGP_EXPAND,
        DBGP("cPreLoad=%02lx: AAData[0]=%6ld:%6ld:%6ld:%6ld, %hs"
                ARGDW(pAAInfo->cPreLoad)
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[0] &
                            ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC))
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[1])
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[2])
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[3])
                ARGPTR((((PEXPDATA)(pAAInfo->pAAData))->Mul[0] & EDF_LOAD_PIXEL) ?
                        "Load Pixel" : "")));

    cPreLoad = (LONG)pAAInfo->cPreLoad;
    cAAData  = (LONG)(cPreLoad >> 4);
    cPreLoad = (cPreLoad & 0x0F) + cAAData;

    while (cPreLoad--) {

        //
        // Scroll up one input scan line
        //

        prgb0   = prgbIn0;
        prgbIn0 = prgbIn1;
        prgbIn1 = prgbIn2;
        prgbIn2 = prgb0;
        prgb3   = prgbOut[++IdxOut & 0x03];

        if (cAAData-- > 0) {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("FAKE SCAN: cPreLoad=%ld/cAAData=%ld, Compose IdxOut=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)
                            ARGDW(IdxOut & 0x03)));

            CopyMemory(prgbIn2, prgbIn1, cbrgbIn);

        } else {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("REAL SCAN: cPreLoad=%ld, Compose IdxOut=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(IdxOut & 0x03)));

            GetFixupScan(&AAHdr, prgbIn2);
        }

        prgbS = SharpenInput(AAHdr.Flags,
                             prgbS,
                             prgbIn0,
                             prgbIn1,
                             prgbIn2,
                             cbrgbIn);

        ExpYDIB_ExpCX(pEDCX,
                      (PBGR8)((LPBYTE)prgbS + cb1stSharpen),
                      prgb3,
                      (PBGR8)((LPBYTE)prgb3 + cbrgbY));
    }

    pED     = (PEXPDATA)(pAAInfo->pAAData);
    cAAData = pAAInfo->cAAData;

    while (cAAData--) {

        LONG    Mul0;
        LONG    Mul1;
        LONG    Mul2;
        LONG    Mul3;


        ed = *pED++;

        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            prgb0   = prgbIn0;
            prgbIn0 = prgbIn1;
            prgbIn1 = prgbIn2;
            prgbIn2 = GetFixupScan(&AAHdr, prgb0);
            prgbS   = SharpenInput(AAHdr.Flags,
                                   prgbS,
                                   prgbIn0,
                                   prgbIn1,
                                   prgbIn2,
                                   cbrgbIn);

            prgb3   = prgbOut[++IdxOut & 0x03];

            ExpYDIB_ExpCX(pEDCX,
                          (PBGR8)((LPBYTE)prgbS + cb1stSharpen),
                          prgb3,
                          (PBGR8)((LPBYTE)prgb3 + cbrgbY));

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        //
        // Build Mul Table here
        //

        pMap  = pMap0;
        Mul0  = -ed.Mul[0];
        Mul1  = -ed.Mul[1];
        Mul2  = -ed.Mul[2];
        Mul3  = -ed.Mul[3];
        prgb3 = prgbOut[(IdxOut    ) & 0x03];
        prgb2 = prgbOut[(IdxOut - 1) & 0x03];
        pOCur = (PBGR8)AAHdr.pAABufBeg;

        if (ed.Mul[0]) {

            prgb1 = prgbOut[(IdxOut - 2) & 0x03];
            prgb0 = prgbOut[(IdxOut - 3) & 0x03];

            GET_EXP_PC(PMAP_EXP4, GET_EXP4, INC_EXP4, pOCur);

        } else if (ed.Mul[1]) {

            prgb1 = prgbOut[(IdxOut - 2) & 0x03];

            GET_EXP_PC(PMAP_EXP3, GET_EXP3, INC_EXP3, pOCur);

        } else if (ed.Mul[2]) {

            GET_EXP_PC(PMAP_EXP2, GET_EXP2, INC_EXP2, pOCur);

        } else {

            GET_EXP_PC(PMAP_EXP1, GET_EXP1, INC_EXP1, pOCur);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}




LONG
HTENTRY
ExpandDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This funtion anti-alias the bitmap by query scanlines from CX direction
    (may be Shrink(CX) or Expand(CX)) then compose current scanlines and output
    it to real BGR8 final buffer,

    The complication is need to have scanline one before current destination
    scanline, this may be because the source is not available or because the
    clipping is done on destination.

    Since the anti-alias for expanding requred at least four surounding
    scanlines to compose current scanline, it required large amount of
    memory to retain the prevous result scanlines

    The expanding is by sharpen the source pixel first before anti-aliasing
    smooth through

    prgbIn[0] - Previous un-sharpen source scan
                AND Last The 4th composition sharpened scan after sharpen
    prgbIn[1] - Current un-sharpen source scan
    prgbIn[2] - Next un-sharpen source scan
    prgbIn[3] - The 1st composition sharpened scan
    prgbIn[4] - The 2nd composition sharpened scan
    prgbIn[5] - The 3rd composition sharpened scan


    Exp=Load Sharpen Exp
    Srk=Load Srk Sharpen
    Cpy=Load Cpy


    Exp_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX) SharpenY ExpY
    Exp_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX) SharpenY ExpY
    Exp_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         ) SharpenY ExpY

    Srk_CY:Exp_CX   InputCX SrkY SharpenY Exp_CX:(LoadX SharpenX     ExpX)
    Srk_CY:Srk_CX   InputCX SrkY SharpenY Srk_CX:(LoadX     SrkX SharpenX)
    Srk_CY:Cpy_CX   InputCX SrkY SharpenY Cpy_CX:(LoadX     CpyX         )

    Cpy_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX)
    Cpy_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX)
    Cpy_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         )



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PEXPDATA    pED;
    PBGR8       prgbIn[6];
    PLONG       pMap;
    PLONG       pMap0;
    PLONG       pMap0End;
    PBGR8       prgb0;
    PBGR8       prgb1;
    PBGR8       prgb2;
    PBGR8       prgb3;
    PBGR8       prgb4;
    PBGR8       prgb5;
    PBGR8       pOCur;
    LPBYTE      prgbYEnd;
    LONG        cbrgbY;
    LONG        cAAData;
    LONG        cPreLoad;


    pMap0      = (PLONG)AAHdr.pAAInfoCY->pbExtra;
    pMap0End   = pMap0 + 256;
    cbrgbY     = (AAHdr.DstSurfInfo.cx + 6) * (LONG)sizeof(BGR8);
    prgbIn[0]  = (PBGR8)(pMap0 + (256 * 4)) + 3;
    prgbIn[1]  = (PBGR8)((LPBYTE)prgbIn[0] + cbrgbY);
    prgbIn[2]  = (PBGR8)((LPBYTE)prgbIn[1] + cbrgbY);
    prgbIn[3]  = (PBGR8)((LPBYTE)prgbIn[2] + cbrgbY);
    prgbIn[4]  = (PBGR8)((LPBYTE)prgbIn[3] + cbrgbY);
    prgbIn[5]  = (PBGR8)((LPBYTE)prgbIn[4] + cbrgbY);
    cbrgbY    -= (sizeof(BGR8) * 6);

    //
    // Always read first source
    //

    DBGP_IF(DBGP_EXPAND, DBGP("\nLoad First Scan"));

    AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                   GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                   prgbIn[4],
                   (LPBYTE)prgbIn[4] + cbrgbY,
                   sizeof(BGR8));


    //
    // Load the PRE-SOURCE LEFT first source first
    //

    if (AAHdr.pAAInfoCY->Flags & AAIF_EXP_HAS_1ST_LEFT) {

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       prgbIn[5],
                       (LPBYTE)prgbIn[5] + cbrgbY,
                       sizeof(BGR8));

        DBGP_IF(DBGP_EXPAND, DBGP("Load First Left"));

    } else {

        CopyMemory(prgbIn[5], prgbIn[4], cbrgbY);

        DBGP_IF(DBGP_EXPAND, DBGP("Copy First Left"));
    }

    cPreLoad = (LONG)AAHdr.pAAInfoCY->cPreLoad;
    cAAData  = (LONG)(cPreLoad >> 4);
    cPreLoad = (cPreLoad & 0x0F) + cAAData;

    while (cPreLoad--) {

        //
        // Scroll up prgbIn by one scan
        //

        prgb5 = prgbIn[0];

        CopyMemory(&prgbIn[0], &prgbIn[1], sizeof(prgbIn[0]) * 5);

        prgbIn[5] = prgb5;
        prgb3     = prgbIn[3];
        prgb4     = prgbIn[4];
        prgb5     = prgbIn[5];
        prgbYEnd  = (LPBYTE)prgb5 + cbrgbY;

        if (cAAData-- > 0) {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("FAKE SCAN: cPreLoad=%ld/cAAData=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)));

            CopyMemory(prgb5, prgb4, cbrgbY);

        } else {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("REAL SCAN: cPreLoad=%ld/cAAData=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)));

            AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                           GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                           prgb5,
                           prgbYEnd,
                           sizeof(BGR8));
        }

        DBGP_IF(DBGP_EXPAND,
                DBGP("Compose Sharpen Scan=%ld" ARGDW(cPreLoad + 1)));

        //
        // Now, let's sharpen the input
        //

        if (AAHdr.Flags & AAHF_BBPF_AA_OFF) {

            CopyMemory(prgb3, prgb4, cbrgbY);

        } else {

            do {

                SHARPEN_PRGB_LR(prgb3, (*prgb3), (*prgb4), (*prgb5), 0);

                prgb3++;
                prgb4++;

            } while (++prgb5 < (PBGR8)prgbYEnd);
        }
    }

    pED      = (PEXPDATA)(AAHdr.pAAInfoCY->pAAData);
    cAAData  = AAHdr.pAAInfoCY->cAAData;

    while (cAAData--) {

        EXPDATA ed = *pED++;
        LONG    Mul0;
        LONG    Mul1;
        LONG    Mul2;
        LONG    Mul3;


        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            prgb5 = prgbIn[0];

            CopyMemory(&prgbIn[0], &prgbIn[1], sizeof(prgbIn[0]) * 5);

            prgbIn[5] = prgb5;
            prgb3     = prgbIn[3];
            prgb4     = prgbIn[4];
            prgb5     = prgbIn[5];
            prgbYEnd  = (LPBYTE)prgb5 + cbrgbY;

            AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                           GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                           prgb5,
                           prgbYEnd,
                           sizeof(BGR8));

            if (AAHdr.Flags & AAHF_BBPF_AA_OFF) {

                CopyMemory(prgb3, prgb4, cbrgbY);

            } else {

                do {

                    SHARPEN_PRGB_LR(prgb3, (*prgb3), (*prgb4), (*prgb5), 0);

                    prgb3++;
                    prgb4++;

                } while (++prgb5 < (PBGR8)prgbYEnd);
            }

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        //
        // Build Mul Table here
        //

        pMap  = pMap0;
        Mul0  = -ed.Mul[0];
        Mul1  = -ed.Mul[1];
        Mul2  = -ed.Mul[2];
        Mul3  = -ed.Mul[3];
        prgb3 = prgbIn[3];
        prgb2 = prgbIn[2];
        pOCur = (PBGR8)AAHdr.pAABufBeg;

        if (ed.Mul[0]) {

            prgb1 = prgbIn[1];
            prgb0 = prgbIn[0];

            GET_EXP_PC(PMAP_EXP4, GET_EXP4, INC_EXP4, pOCur);

        } else if (ed.Mul[1]) {

            prgb1 = prgbIn[1];

            GET_EXP_PC(PMAP_EXP3, GET_EXP3, INC_EXP3, pOCur);

        } else if (ed.Mul[2]) {

            GET_EXP_PC(PMAP_EXP2, GET_EXP2, INC_EXP2, pOCur);

        } else {

            GET_EXP_PC(PMAP_EXP1, GET_EXP1, INC_EXP1, pOCur);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}


//
// Monochrome routine
//


LPBYTE
HTENTRY
GraySharpenInput(
    DWORD   AAHFlags,
    LPBYTE  pbS,
    LPBYTE  pb0,
    LPBYTE  pb1,
    LPBYTE  pb2,
    LONG    cbIn
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Apr-1998 Fri 15:06:58 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE   pSBeg;
    LPBYTE   pSEnd;
    LPBYTE   pb1End;


    pSBeg  = pbS;
    pSEnd  = (LPBYTE)((LPBYTE)pbS + cbIn);
    pb1End = (LPBYTE)((LPBYTE)pb1 + cbIn);

    if (AAHFlags & AAHF_BBPF_AA_OFF) {

        pSBeg = pb1;
        pSEnd = pb1End;

    } else {

        *(pb1 - 1) = *pb1;
        *pb1End    = *(pb1End - 1);

#if defined(_X86_)

        _asm {


            cld

            mov     edi, pbS
            mov     ebx, pb0
            mov     esi, pb1
            mov     edx, pb2
            mov     eax, cbIn
            shr     eax, 2
            jz      DoneLoop1
            push    ebp
            mov     ebp, eax
            jmp     DoLoop1

DoSP1:      shr     eax, 24
            not     al
            jmp     StoreClr1

DoSP2:      shr     eax, 24
            not     al
            jmp     StoreClr2

DoSP3:      shr     eax, 24
            not     al
            jmp     StoreClr3

DoSP4:      shr     eax, 24
            not     al
            jmp     StoreClr4
DoLoop1:
            movzx   eax, BYTE PTR [esi]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP1
StoreClr1:
            stosb
            movzx   eax, BYTE PTR [esi + 1]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1 + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1 + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 1]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP2
StoreClr2:
            stosb
            movzx   eax, BYTE PTR [esi + 2]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1 + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1 + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 2]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 2]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP3
StoreClr3:
            stosb
            movzx   eax, BYTE PTR [esi + 3]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1 + 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1 + 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx + 3]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx + 3]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP4
StoreClr4:
            stosb
            add     ebx, 4
            add     edx, 4
            add     esi, 4
            dec     ebp
            jnz     DoLoop1
            pop     ebp
DoneLoop1:
            mov     eax, cbIn
            and     eax, 3
            jz      DoneLoop2
            push    ebp
            mov     ebp, eax
            jmp     DoLoop2

DoSP5:      shr     eax, 24
            not     al
            jmp     StoreClr5
DoLoop2:
            movzx   eax, BYTE PTR [esi]
            lea     eax, [eax * 2 + eax]
            shl     eax, 2
            movzx   ecx, BYTE PTR [esi - 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [esi + 1]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [ebx]
            sub     eax, ecx
            movzx   ecx, BYTE PTR [edx]
            sub     eax, ecx
            sar     eax, 3
            or      ah, ah
            jnz     DoSP5
StoreClr5:
            stosb
            inc     esi
            inc     ebx
            inc     edx
            dec     ebp
            jnz     DoLoop2
            pop     ebp
DoneLoop2:
        }

#else
        while (pb1 < pb1End) {

            SHARPEN_PB_LRTB(pbS, pb0, pb1, pb2, 0);

            ++pbS;
            ++pb0;
            ++pb1;
            ++pb2;
        }
#endif
    }

    *(pSBeg - 3) =
    *(pSBeg - 2) =
    *(pSBeg - 1) = *pSBeg;
    *(pSEnd    ) =
    *(pSEnd + 1) = *(pSEnd - 1);

    return(pSBeg);
}



VOID
HTENTRY
GrayCopyDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    26-Jun-1998 Fri 11:33:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    do {

        *pOut = *pIn++;

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}



VOID
HTENTRY
GrayExpYDIB_ExpCX(
    PEXPDATA    pED,
    LPBYTE      pIn,
    LPBYTE      pOut,
    LPBYTE      pOutEnd
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    do {

        EXPDATA ed = *pED++;
        LONG    Gray;
        UINT    Mul;


        INC_PIN_BY_EDF_LOAD_PIXEL(pIn, ed.Mul[0]);

        Mul  = (UINT)ed.Mul[3];
        Gray = MULRGB(*pIn, Mul);

        if (Mul = (UINT)ed.Mul[2]) {

            Gray += MULRGB(*(pIn - 1), Mul);

            if (Mul = (UINT)ed.Mul[1]) {

                Gray += MULRGB(*(pIn - 2), Mul);

                if (Mul = (UINT)(ed.Mul[0] & ~(EDF_LOAD_PIXEL |
                                               EDF_NO_NEWSRC))) {

                    Gray += MULRGB(*(pIn - 3), Mul);
                }
            }
        }

        GRAY_DIMAX_TO_BYTE(pOut, Gray);

    } while (++pOut != pOutEnd);
}




LONG
HTENTRY
GrayExpandDIB_CY_ExpCX(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This funtion anti-alias the bitmap by query scanlines from CX direction
    (may be Shrink(CX) or Expand(CX)) then compose current scanlines and output
    it to real BGR8 final buffer,

    The complication is need to have scanline one before current destination
    scanline, this may be because the source is not available or because the
    clipping is done on destination.

    Since the anti-alias for expanding requred at least four surounding
    scanlines to compose current scanline, it required large amount of
    memory to retain the prevous result scanlines

    The expanding is by sharpen the source pixel first before anti-aliasing
    smooth through

    prgbIn[0] - Previous un-sharpen source scan
                AND Last The 4th composition sharpened scan after sharpen
    prgbIn[1] - Current un-sharpen source scan
    prgbIn[2] - Next un-sharpen source scan
    prgbIn[3] - The 1st composition sharpened scan
    prgbIn[4] - The 2nd composition sharpened scan
    prgbIn[5] - The 3rd composition sharpened scan


    Exp=Load Sharpen Exp
    Srk=Load Srk Sharpen
    Cpy=Load Cpy


    Exp_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX) SharpenY ExpY
    Exp_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX) SharpenY ExpY
    Exp_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         ) SharpenY ExpY

    Srk_CY:Exp_CX   InputCX SrkY SharpenY Exp_CX:(LoadX SharpenX     ExpX)
    Srk_CY:Srk_CX   InputCX SrkY SharpenY Srk_CX:(LoadX     SrkX SharpenX)
    Srk_CY:Cpy_CX   InputCX SrkY SharpenY Cpy_CX:(LoadX     CpyX         )

    Cpy_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX)
    Cpy_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX)
    Cpy_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         )



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PAAINFO     pAAInfo;
    PEXPDATA    pED;
    PEXPDATA    pEDCX;
    LPBYTE      pbOut[4];
    LPBYTE      pbS;
    PLONG       pMap;
    PLONG       pMap0;
    PLONG       pMap0End;
    LPBYTE      pbIn0;
    LPBYTE      pbIn1;
    LPBYTE      pbIn2;
    LPBYTE      pb0;
    LPBYTE      pb1;
    LPBYTE      pb2;
    LPBYTE      pb3;
    PGRAYF      pOCur;
    EXPDATA     ed;
    LONG        cb1stSharpen;
    LONG        cbY;
    LONG        cbIn;
    LONG        cAAData;
    LONG        cPreLoad;
    UINT        IdxOut;

    //
    // Figure out the horizontal scan line increment
    //

    pAAInfo  = AAHdr.pAAInfoCX;
    cPreLoad = (LONG)(pAAInfo->cPreLoad & 0x0F) - 1 +
               (LONG)((pAAInfo->Flags & AAIF_EXP_HAS_1ST_LEFT) ? 1 : 0);

    pEDCX        = (PEXPDATA)(pAAInfo->pAAData);
    pAAInfo      = AAHdr.pAAInfoCY;
    pMap0        = (PLONG)pAAInfo->pbExtra;
    pMap0End     = pMap0 + 256;
    cbIn         = AAHdr.SrcSurfInfo.cx * sizeof(BYTE);
    cbY          = AAHdr.DstSurfInfo.cx * sizeof(BYTE);
    pbOut[0]     = (LPBYTE)(pMap0 + (256 * 4));
    pbOut[1]     = (LPBYTE)((LPBYTE)pbOut[0] + cbY);
    pbOut[2]     = (LPBYTE)((LPBYTE)pbOut[1] + cbY);
    pbOut[3]     = (LPBYTE)((LPBYTE)pbOut[2] + cbY);
    pbIn0        = (LPBYTE)((LPBYTE)pbOut[3] + cbY) + 3;
    pbIn1        = (LPBYTE)((LPBYTE)pbIn0    + cbIn) + 6;
    pbIn2        = (LPBYTE)((LPBYTE)pbIn1    + cbIn) + 6;
    pbS          = (LPBYTE)AAHdr.pInputBeg + 3;
    cb1stSharpen = (LONG)(sizeof(BYTE) * cPreLoad);
    IdxOut       = ~0;

    DBGP_IF(DBGP_AAHT_MEM,
            DBGP("pbIn=%p:%p:%p, pbOut=%p:%p:%p:%p, pbS=%p, cb1stSharpen=%ld"
                ARGPTR(pbIn0) ARGPTR(pbIn1) ARGPTR(pbIn2)
                ARGPTR(pbOut[0]) ARGPTR(pbOut[1]) ARGPTR(pbOut[2])
                ARGPTR(pbOut[3]) ARGPTR(pbS) ARGDW(cb1stSharpen)));

    //
    // Always read first source
    //

    DBGP_IF(DBGP_EXPAND, DBGP("\nExpand: PRE-LOAD FIRST SCAN"));

    GetFixupScan(&AAHdr, (PBGR8)pbIn1);

    if (pAAInfo->Flags & AAIF_EXP_HAS_1ST_LEFT) {

        DBGP_IF(DBGP_EXPAND, DBGP("Expand: LOAD FIRST LEFT"));

        GetFixupScan(&AAHdr, (PBGR8)pbIn2);

    } else {

        DBGP_IF(DBGP_EXPAND, DBGP("Expand: COPY FIRST LEFT"));

        CopyMemory(pbIn2, pbIn1, cbIn);
    }

    //
    // cPreLoad: Low 4 bits means real load, high 4 bit means imaginary load
    //

    DBGP_IF(DBGP_EXPAND,
        DBGP("cPreLoad=%02lx: AAData[0]=%6ld:%6ld:%6ld:%6ld, %hs"
                ARGDW(pAAInfo->cPreLoad)
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[0] &
                            ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC))
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[1])
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[2])
                ARGDW(((PEXPDATA)(pAAInfo->pAAData))->Mul[3])
                ARGPTR((((PEXPDATA)(pAAInfo->pAAData))->Mul[0] & EDF_LOAD_PIXEL) ?
                        "Load Pixel" : "")));

    cPreLoad = (LONG)pAAInfo->cPreLoad;
    cAAData  = (LONG)(cPreLoad >> 4);
    cPreLoad = (cPreLoad & 0x0F) + cAAData;

    while (cPreLoad--) {

        //
        // Scroll up one input scan line
        //

        pb0   = pbIn0;
        pbIn0 = pbIn1;
        pbIn1 = pbIn2;
        pbIn2 = pb0;
        pb3   = pbOut[++IdxOut & 0x03];

        if (cAAData-- > 0) {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("FAKE SCAN: cPreLoad=%ld/cAAData=%ld, Compose IdxOut=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)
                            ARGDW(IdxOut & 0x03)));

            CopyMemory(pbIn2, pbIn1, cbIn);

        } else {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("REAL SCAN: cPreLoad=%ld, Compose IdxOut=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(IdxOut & 0x03)));

            GetFixupScan(&AAHdr, (PBGR8)pbIn2);
        }

        pbS = GraySharpenInput(AAHdr.Flags,
                               pbS,
                               pbIn0,
                               pbIn1,
                               pbIn2,
                               cbIn);

        GrayExpYDIB_ExpCX(pEDCX,
                          (LPBYTE)((LPBYTE)pbS + cb1stSharpen),
                          (LPBYTE)pb3,
                          (LPBYTE)((LPBYTE)pb3 + cbY));

    }

    pED     = (PEXPDATA)(pAAInfo->pAAData);
    cAAData = pAAInfo->cAAData;

    while (cAAData--) {

        LONG    Mul0;
        LONG    Mul1;
        LONG    Mul2;
        LONG    Mul3;


        ed = *pED++;

        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            pb0   = pbIn0;
            pbIn0 = pbIn1;
            pbIn1 = pbIn2;
            pbIn2 = (LPBYTE)GetFixupScan(&AAHdr, (PBGR8)pb0);
            pbS   = GraySharpenInput(AAHdr.Flags,
                                     pbS,
                                     pbIn0,
                                     pbIn1,
                                     pbIn2,
                                     cbIn);
            pb3   = pbOut[++IdxOut & 0x03];

            GrayExpYDIB_ExpCX(pEDCX,
                              (LPBYTE)((LPBYTE)pbS + cb1stSharpen),
                              (LPBYTE)pb3,
                              (LPBYTE)((LPBYTE)pb3 + cbY));

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        //
        // Build Mul Table here
        //

        pMap  = pMap0;
        Mul0  = -ed.Mul[0];
        Mul1  = -ed.Mul[1];
        Mul2  = -ed.Mul[2];
        Mul3  = -ed.Mul[3];
        pb3   = pbOut[(IdxOut    ) & 0x03];
        pb2   = pbOut[(IdxOut - 1) & 0x03];
        pOCur = (PGRAYF)AAHdr.pAABufBeg;

        if (ed.Mul[0]) {

            pb1 = pbOut[(IdxOut - 2) & 0x03];
            pb0 = pbOut[(IdxOut - 3) & 0x03];

            GRAY_GET_EXP_PC(PMAP_EXP4, GRAY_GET_EXP4, GRAY_INC_EXP4, pOCur);

        } else if (ed.Mul[1]) {

            pb1 = pbOut[(IdxOut - 2) & 0x03];

            GRAY_GET_EXP_PC(PMAP_EXP3, GRAY_GET_EXP3, GRAY_INC_EXP3, pOCur);

        } else if (ed.Mul[2]) {

            GRAY_GET_EXP_PC(PMAP_EXP2, GRAY_GET_EXP2, GRAY_INC_EXP2, pOCur);

        } else {

            GRAY_GET_EXP_PC(PMAP_EXP1, GRAY_GET_EXP1, GRAY_INC_EXP1, pOCur);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}




VOID
HTENTRY
GrayExpandDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAINFO      AAI = *pAAInfo;
    LPBYTE      pInEnd;
    PEXPDATA    pED;
    BYTE        GrayIn[8];
    LONG        Gray;
    UINT        cPreLoad;
    UINT        cAAData;
    UINT        Idx;


    pInEnd        = pIn + AAI.cIn + 2;
    *(pInEnd - 0) =
    *(pInEnd - 1) =
    *(pInEnd - 2) = *(pInEnd - 3);
    GrayIn[5]     = *pIn;
    INC_PIN_BY_1ST_LEFT(pIn, AAI.Flags);

    GrayIn[6] = *pIn++;
    cPreLoad = (UINT)AAI.cPreLoad;
    cAAData  = (UINT)(cPreLoad >> 4);

    if ((!(cPreLoad &= 0x0F)) && (cAAData)) {

        GrayIn[6] = GrayIn[5];
        ++cPreLoad;
        --cAAData;
        --pIn;
    }

    Idx = 4 - cPreLoad;

    while (cPreLoad--) {

        CopyMemory(&GrayIn[0], &GrayIn[1], sizeof(GrayIn[0]) * 6);

        GrayIn[6] = *pIn++;

        if (AAI.Flags & AAIF_EXP_NO_SHARPEN) {

            GrayIn[3] = GrayIn[5];

        } else {

            SHARPEN_GRAY_LR(GrayIn[3], GrayIn[4], GrayIn[5], GrayIn[6], 0);
        }

        DBGP_IF(DBGP_EXP, DBGP("ExpDIB: PreLoad=%ld, pIn=%8lx"
                                        ARGDW(cPreLoad) ARGPTR(pIn)));
    }

    GrayIn[7] = GrayIn[Idx--];

    while (cAAData--) {

        GrayIn[Idx--] = GrayIn[7];
    }

    pED         = (PEXPDATA)(AAI.pAAData);
    pOutEnd    += OutInc;

    do {

        EXPDATA ed = *pED++;


        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            CopyMemory(&GrayIn[0], &GrayIn[1], sizeof(GrayIn[0]) * 6);

            GrayIn[6] = *pIn++;

            if (AAI.Flags & AAIF_EXP_NO_SHARPEN) {

                GrayIn[3] = GrayIn[5];

            } else {

                SHARPEN_GRAY_LR(GrayIn[3], GrayIn[4], GrayIn[5], GrayIn[6], 0);
            }

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        Gray = MULRGB(GrayIn[3], ed.Mul[3]);

        if (ed.Mul[2]) {

            Gray += MULRGB(GrayIn[2], ed.Mul[2]);

            if (ed.Mul[1]) {

                Gray += MULRGB(GrayIn[1], ed.Mul[1]);

                if (ed.Mul[0]) {

                    Gray += MULRGB(GrayIn[0], ed.Mul[0]);
                }
            }
        }

        GRAY_DIMAX_TO_BYTE(pOut, Gray);

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);

    ASSERT(pIn <= pInEnd);
}




LONG
HTENTRY
GrayExpandDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This funtion anti-alias the bitmap by query scanlines from CX direction
    (may be Shrink(CX) or Expand(CX)) then compose current scanlines and output
    it to real BGR8 final buffer,

    The complication is need to have scanline one before current destination
    scanline, this may be because the source is not available or because the
    clipping is done on destination.

    Since the anti-alias for expanding requred at least four surounding
    scanlines to compose current scanline, it required large amount of
    memory to retain the prevous result scanlines

    The expanding is by sharpen the source pixel first before anti-aliasing
    smooth through

    prgbIn[0] - Previous un-sharpen source scan
                AND Last The 4th composition sharpened scan after sharpen
    prgbIn[1] - Current un-sharpen source scan
    prgbIn[2] - Next un-sharpen source scan
    prgbIn[3] - The 1st composition sharpened scan
    prgbIn[4] - The 2nd composition sharpened scan
    prgbIn[5] - The 3rd composition sharpened scan


    Exp=Load Sharpen Exp
    Srk=Load Srk Sharpen
    Cpy=Load Cpy


    Exp_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX) SharpenY ExpY
    Exp_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX) SharpenY ExpY
    Exp_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         ) SharpenY ExpY

    Srk_CY:Exp_CX   InputCX SrkY SharpenY Exp_CX:(LoadX SharpenX     ExpX)
    Srk_CY:Srk_CX   InputCX SrkY SharpenY Srk_CX:(LoadX     SrkX SharpenX)
    Srk_CY:Cpy_CX   InputCX SrkY SharpenY Cpy_CX:(LoadX     CpyX         )

    Cpy_CY:Exp_CX   Exp_CX:(LoadX SharpenX     ExpX)
    Cpy_CY:Srk_CX   Srk_CX:(LoadX     SrkX SharpenX)
    Cpy_CY:Cpy_CX   Cpy_CX:(LoadX     CpyX         )



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr = *pAAHdr;
    PEXPDATA    pED;
    LPBYTE      pbIn[6];
    PLONG       pMap;
    PLONG       pMap0;
    PLONG       pMap0End;
    LPBYTE      pb0;
    LPBYTE      pb1;
    LPBYTE      pb2;
    LPBYTE      pb3;
    LPBYTE      pb4;
    LPBYTE      pb5;
    PGRAYF      pOCur;
    LPBYTE      pbYEnd;
    LONG        cbScan;
    LONG        cAAData;
    LONG        cPreLoad;


    pMap0     = (PLONG)AAHdr.pAAInfoCY->pbExtra;
    pMap0End  = pMap0 + 256;
    cbScan    = (AAHdr.DstSurfInfo.cx + 6) * (LONG)sizeof(BYTE);
    pbIn[0]   = (LPBYTE)(pMap0 + (256 * 4)) + 3;
    pbIn[1]   = (LPBYTE)((LPBYTE)pbIn[0] + cbScan);
    pbIn[2]   = (LPBYTE)((LPBYTE)pbIn[1] + cbScan);
    pbIn[3]   = (LPBYTE)((LPBYTE)pbIn[2] + cbScan);
    pbIn[4]   = (LPBYTE)((LPBYTE)pbIn[3] + cbScan);
    pbIn[5]   = (LPBYTE)((LPBYTE)pbIn[4] + cbScan);
    cbScan   -= (sizeof(BYTE) * 6);

    //
    // Always read first source
    //

    DBGP_IF(DBGP_EXPAND, DBGP("\nLoad First Scan"));

    AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                   GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                   (PBGR8)pbIn[4],
                   (LPBYTE)pbIn[4] + cbScan,
                   sizeof(BYTE));


    //
    // Load the PRE-SOURCE LEFT first source first
    //

    if (AAHdr.pAAInfoCY->Flags & AAIF_EXP_HAS_1ST_LEFT) {

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)pbIn[5],
                       (LPBYTE)pbIn[5] + cbScan,
                       sizeof(BYTE));

        DBGP_IF(DBGP_EXPAND, DBGP("Load First Left"));

    } else {

        CopyMemory(pbIn[5], pbIn[4], cbScan);

        DBGP_IF(DBGP_EXPAND, DBGP("Copy First Left"));
    }

    cPreLoad = (LONG)AAHdr.pAAInfoCY->cPreLoad;
    cAAData  = (LONG)(cPreLoad >> 4);
    cPreLoad = (cPreLoad & 0x0F) + cAAData;

    while (cPreLoad--) {

        //
        // Scroll up pbIn by one scan
        //

        pb5 = pbIn[0];

        CopyMemory(&pbIn[0], &pbIn[1], sizeof(pbIn[0]) * 5);

        pbIn[5] = pb5;
        pb3     = pbIn[3];
        pb4     = pbIn[4];
        pb5     = pbIn[5];
        pbYEnd  = (LPBYTE)pb5 + cbScan;

        if (cAAData-- > 0) {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("FAKE SCAN: cPreLoad=%ld/cAAData=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)));

            CopyMemory(pb5, pb4, cbScan);

        } else {

            DBGP_IF(DBGP_EXPAND,
                    DBGP("REAL SCAN: cPreLoad=%ld/cAAData=%ld"
                            ARGDW(cPreLoad + 1) ARGDW(cAAData + 1)));

            AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                           GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                           (PBGR8)pb5,
                           pbYEnd,
                           sizeof(BYTE));
        }

        DBGP_IF(DBGP_EXPAND,
                DBGP("Compose Sharpen Scan=%ld" ARGDW(cPreLoad + 1)));

        //
        // Now, let's sharpen the input
        //

        if (AAHdr.Flags & AAHF_BBPF_AA_OFF) {

            CopyMemory(pb3, pb4, cbScan);

        } else {

            do {

                SHARPEN_PGRAY_LR(pb3, (*pb3), (*pb4), (*pb5), 0);

                pb3++;
                pb4++;

            } while (++pb5 < (LPBYTE)pbYEnd);
        }
    }

    pED      = (PEXPDATA)(AAHdr.pAAInfoCY->pAAData);
    cAAData  = AAHdr.pAAInfoCY->cAAData;

    while (cAAData--) {

        EXPDATA ed = *pED++;
        LONG    Mul0;
        LONG    Mul1;
        LONG    Mul2;
        LONG    Mul3;


        if (ed.Mul[0] & EDF_LOAD_PIXEL) {

            pb5 = pbIn[0];

            CopyMemory(&pbIn[0], &pbIn[1], sizeof(pbIn[0]) * 5);

            pbIn[5] = pb5;
            pb3     = pbIn[3];
            pb4     = pbIn[4];
            pb5     = pbIn[5];
            pbYEnd  = (LPBYTE)pb5 + cbScan;

            AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                           GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                           (PBGR8)pb5,
                           pbYEnd,
                           sizeof(BYTE));

            if (AAHdr.Flags & AAHF_BBPF_AA_OFF) {

                CopyMemory(pb3, pb4, cbScan);

            } else {

                do {

                    SHARPEN_PGRAY_LR(pb3, (*pb3), (*pb4), (*pb5), 0);

                    pb3++;
                    pb4++;

                } while (++pb5 < (LPBYTE)pbYEnd);
            }

            ed.Mul[0] &= ~(EDF_LOAD_PIXEL | EDF_NO_NEWSRC);
        }

        //
        // Build Mul Table here
        //

        pMap  = pMap0;
        Mul0  = -ed.Mul[0];
        Mul1  = -ed.Mul[1];
        Mul2  = -ed.Mul[2];
        Mul3  = -ed.Mul[3];
        pb3   = pbIn[3];
        pb2   = pbIn[2];
        pOCur = (PGRAYF)AAHdr.pAABufBeg;

        if (ed.Mul[0]) {

            pb1 = pbIn[1];
            pb0 = pbIn[0];

            GRAY_GET_EXP_PC(PMAP_EXP4, GRAY_GET_EXP4, GRAY_INC_EXP4, pOCur);

        } else if (ed.Mul[1]) {

            pb1 = pbIn[1];

            GRAY_GET_EXP_PC(PMAP_EXP3, GRAY_GET_EXP3, GRAY_INC_EXP3, pOCur);

        } else if (ed.Mul[2]) {

            GRAY_GET_EXP_PC(PMAP_EXP2, GRAY_GET_EXP2, GRAY_INC_EXP2, pOCur);

        } else {

            GRAY_GET_EXP_PC(PMAP_EXP1, GRAY_GET_EXP1, GRAY_INC_EXP1, pOCur);
        }

        OUTPUT_AA_CURSCAN;
    }

    return(AAHdr.DstSurfInfo.cy);
}



VOID
HTENTRY
GrayShrinkDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PSHRINKDATA pSD;
    PLONG       pMap;
    PLONG       pMap256X;
    LPBYTE      pInEnd;
    LONG        GrayOut[3];
    LONG        GrayT;
    UINT        Mul;
    UINT        cPreLoad;



    pInEnd = pIn + pAAInfo->cIn;

    if (Mul = (UINT)pAAInfo->PreMul) {

        GrayOut[2]  = MULRGB(*pIn, Mul);
        pIn        += pAAInfo->PreSrcInc;

    } else {

        ZeroMemory(&GrayOut[2], sizeof(GrayOut[2]));
    }

    pSD      = (PSHRINKDATA)(pAAInfo->pAAData);
    pMap256X = pAAInfo->pMapMul;
    cPreLoad = (UINT)pAAInfo->cPreLoad;

    while (cPreLoad) {

        Mul  = (UINT)((pSD++)->Mul);
        pMap = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul        &= SDF_MUL_MASK;
            GrayOut[2] += (GrayT = MULRGB(*pIn, Mul));

            CopyMemory(&GrayOut[0], &GrayOut[1], sizeof(GrayOut[0]) * 2);

            GrayOut[2] = pMap[*pIn++] - GrayT;

            --cPreLoad;

        } else {

            GrayOut[2] += pMap[*pIn++];
        }
    }

    if (pAAInfo->cPreLoad == 1) {

        GrayOut[0] = GrayOut[1];
    }

    while (Mul = (UINT)((pSD++)->Mul)) {

        pMap = (PLONG)((LPBYTE)pMap256X + GET_SDF_LARGE_OFF(Mul));

        if (Mul & SDF_DONE) {

            //
            // Finished a pixel
            //

            Mul        &= SDF_MUL_MASK;
            GrayOut[2] += (GrayT = MULRGB(*pIn, Mul));

            SHARPEN_PGRAY_LR(pOut,
                             GrayOut[0],
                             GrayOut[1],
                             GrayOut[2],
                             DI_R_SHIFT);

            (LPBYTE)pOut += OutInc;

            CopyMemory(&GrayOut[0], &GrayOut[1], sizeof(GrayOut[0]) * 2);

            GrayOut[2] = pMap[*pIn++] - GrayT;

        } else {

            GrayOut[2] += pMap[*pIn++];
        }
    }

    ASSERT(pIn == pInEnd);

    if ((LPBYTE)pOut == (pOutEnd - OutInc)) {

       SHARPEN_PGRAY_LR(pOut,
                        GrayOut[0],
                        GrayOut[1],
                        GrayOut[1],
                        DI_R_SHIFT);
    }
}



LONG
HTENTRY
GrayShrinkDIB_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:

    This function shrink the scanline down first in Y direction from source
    bitmap when it is done for group of scanlines then it call AXFunc to
    compose current scanline (it may be Shrink(CX) or Expand(CX)) to the
    final output BGR8 buffer

    The shrink is done by sharpen the current pixel first.



Arguments:




Return Value:




Author:

    11-Jul-1997 Fri 14:26:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER    AAHdr;
    PSHRINKDATA pSD;
    SHRINKDATA  sd;
    LPBYTE      pIBuf;
    LPBYTE      pIBufEnd;
    LPBYTE      pICur;
    PGRAYF      pOCur;
    PLONG       pGrayIn[3];
    PLONG       pGray0;
    PLONG       pGray1;
    PLONG       pGray2;
    PLONG       pGray2End;
    PLONG       pMap;
    PLONG       pMapMul;
    PLONG       pMapMul2;
    PLONG       pMap256Y;
    RGBL        GrayT;
    LONG        cbGrayY;
    LONG        Mul;
    LONG        cAAData;
    BOOL        CopyFirst;
    LONG        cyOut;
    INT         cPreLoad;
    BYTE        Mask;

    DEFDBGVAR(LONG, MulTot)

    //
    // Adding 3 to each side of pIBuf for ExpandDIB_CX
    //

    AAHdr      = *pAAHdr;
    pMap256Y   = AAHdr.pAAInfoCY->pMapMul;
    pMapMul    = (PLONG)(AAHdr.pAAInfoCY->pbExtra);
    pMapMul2   = pMapMul + 256;
    cbGrayY    = (LONG)(AAHdr.DstSurfInfo.cx * sizeof(LONG));
    pGrayIn[0] = (PLONG)(pMapMul2 + 256);
    pGrayIn[1] = (PLONG)( (LPBYTE)pGrayIn[0] + cbGrayY);
    pGrayIn[2] = (PLONG)( (LPBYTE)pGrayIn[1] + cbGrayY);
    pIBuf      = (LPBYTE)((LPBYTE)pGrayIn[2] + cbGrayY);
    pIBufEnd   = pIBuf + AAHdr.DstSurfInfo.cx;

    ASSERT_MEM_ALIGN(pGrayIn[0], sizeof(LONG));
    ASSERT_MEM_ALIGN(pGrayIn[1], sizeof(LONG));
    ASSERT_MEM_ALIGN(pGrayIn[2], sizeof(LONG));

    if (Mul = AAHdr.pAAInfoCY->PreMul) {

        pMap   = pMapMul;
        GrayT.r = -Mul;

        do {

            pMap[0] = (GrayT.r += Mul);

        } while (++pMap < pMapMul2);

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)(pICur = pIBuf),
                       pIBufEnd,
                       sizeof(BYTE));

        pGray2    = pGrayIn[2];
        pGray2End = (PLONG)((LPBYTE)pGray2 + cbGrayY);

        do {

            *pGray2 = pMapMul[*pICur++];

        } while (++pGray2 < pGray2End);

        //
        // The AAInputFunc() will increment the pointer, so reduced it
        //

        if (!(AAHdr.pAAInfoCY->PreSrcInc)) {

            AAHdr.Flags |= AAHF_GET_LAST_SCAN;
        }
    }

    pSD       = (PSHRINKDATA)(AAHdr.pAAInfoCY->pAAData);
    cPreLoad  = (INT)AAHdr.pAAInfoCY->cPreLoad;
    CopyFirst = (BOOL)(cPreLoad == 1);
    cAAData   = AAHdr.pAAInfoCY->cAAData;
    cyOut     = 0;

    SETDBGVAR(MulTot, Mul);

    while (cAAData--) {

        AAHdr.AACXFunc(AAHdr.pAAInfoCX,
                       GetFixupScan(&AAHdr, AAHdr.pInputBeg),
                       (PBGR8)(pICur = pIBuf),
                       pIBufEnd,
                       sizeof(BYTE));

        sd        = *pSD++;
        pGray2    = pGrayIn[2];
        pGray2End = (PLONG)((LPBYTE)pGray2 + cbGrayY);
        Mask      = GET_SDF_LARGE_MASK(sd.Mul);

        if (sd.Mul & SDF_DONE) {

            //
            // Build current Mul Table
            //

            Mul     = (LONG)(sd.Mul & SDF_MUL_MASK);
            pMap    = pMapMul;
            GrayT.r = -Mul;
            GrayT.b = (LONG)(pMap256Y[1] - Mul + (LONG)(Mask & 0x01));
            GrayT.g = -GrayT.b;

            do {

                pMap[  0] = (GrayT.r += Mul);
                pMap[256] = (GrayT.g += GrayT.b);

            } while (++pMap < pMapMul2);

            //
            // Finished a scanline, so to see if have prev/next to sharpen with
            //

            pGray0 = pGrayIn[0];
            pGray1 = pGrayIn[1];

            if (cPreLoad-- > 0) {

                do {

                    *pGray2   += pMapMul[*pICur];
                    *pGray0++  = pMapMul[*pICur++ + 256];

                } while (++pGray2 < pGray2End);

                if (CopyFirst) {

                    CopyMemory(pGray1, pGrayIn[2], cbGrayY);
                    CopyFirst = FALSE;
                }

            } else {

                pOCur = (PGRAYF)AAHdr.pAABufBeg;

                do {

                    *pGray2 += pMapMul[*pICur];

                    SHARPEN_PWGRAY_LR(pOCur, (*pGray0), (*pGray1), (*pGray2));

                    (LPBYTE)pOCur += AAHdr.AABufInc;
                    *pGray0++      = pMapMul[*pICur++ + 256];
                    ++pGray1;

                } while (++pGray2 < pGray2End);

                DBGP_IF(DBGP_SRK2,
                        DBGP("*%ld**In=%3lx, Mul=%08lx [%08lx], (%p)           Gray=%8lx [%08lx]"
                            ARGDW((cPreLoad > 0) ? cPreLoad : 0)
                            ARGDW(*pIBuf) ARGDW(Mul)
                            ARGDW(MulTot += Mul)
                            ARGPTR(pGrayIn[2])
                            ARGDW(*pGrayIn[2]) ARGDW(pMapMul[*(pICur - 1)])));

                DBGP_IF(DBGP_SRK2,
                        DBGP("   *In=%3lx, Mul=%08lx [%08lx], (%p) Gray=%8lx [%08lx]"
                            ARGDW(*pIBuf) ARGDW(sd.Mul & SDF_MUL_MASK)
                            ARGDW(MulTot = GrayT.b)
                            ARGPTR(pGrayIn[0])
                            ARGDW(*pGrayIn[0])
                            ARGDW(pMapMul[*(pICur - 1) + 256])));


                OUTPUT_AA_CURSCAN;

                ++cyOut;
            }

            pGray2     = pGrayIn[0];
            pGrayIn[0] = pGrayIn[1];
            pGrayIn[1] = pGrayIn[2];
            pGrayIn[2] = pGray2;

        } else {

            pMap = (PLONG)((LPBYTE)pMap256Y + GET_SDF_LARGE_OFF(sd.Mul));

            do {

                *pGray2 += pMap[*pICur++];

            } while (++pGray2 < pGray2End);

            DBGP_IF(DBGP_SRK2,
                    DBGP("    In=%3lx, Mul=%08lx [%08lx], (%p) Gray=%8lx [%08lx]"
                        ARGDW(*pIBuf) ARGDW(sd.Mul & SDF_MUL_MASK)
                        ARGDW(MulTot += (sd.Mul & SDF_MUL_MASK))
                        ARGPTR(pGrayIn[2])
                        ARGDW(*pGrayIn[2]) ARGDW(pMap[*(pICur - 1)])));
        }

    }

    if (AAHdr.DstSurfInfo.pb != AAHdr.pOutLast) {

        pOCur     = (PGRAYF)AAHdr.pAABufBeg;
        pGray0    = pGrayIn[0];
        pGray2    = pGrayIn[1];
        pGray2End = (PLONG)((LPBYTE)pGray2 + cbGrayY);

        do {

            SHARPEN_PWGRAY_LR(pOCur, (*pGray0), (*pGray2), (*pGray2));

            (LPBYTE)pOCur += AAHdr.AABufInc;
            ++pGray0;

        } while (++pGray2 < pGray2End);

        OUTPUT_AA_CURSCAN;

        ++cyOut;
    }

    ASSERTMSG("Shrink: cScan not equal", cyOut == AAHdr.DstSurfInfo.cy);

    return(cyOut);
}



//
//****************************************************************************
// Following ae defines and functions for VERY FAST Anti-Aliasing expansion,
// the Fast mode is turn on when is stretching up and both X and Y is less or
// equal to 500%
//****************************************************************************
//


#define MAC_FROM_2(Mac, pO, p1, p2, cCX)                                    \
{                                                                           \
    LONG    Count;                                                          \
                                                                            \
    Count  = cCX >> 2;                                                      \
    cCX   &= 0x03;                                                          \
                                                                            \
    while (Count--) {                                                       \
                                                                            \
        *(pO + 0) = (BYTE)Mac((*(p1+0)), (*(p2+0)));                        \
        *(pO + 1) = (BYTE)Mac((*(p1+1)), (*(p2+1)));                        \
        *(pO + 2) = (BYTE)Mac((*(p1+2)), (*(p2+2)));                        \
        *(pO + 3) = (BYTE)Mac((*(p1+3)), (*(p2+3)));                        \
                                                                            \
        pO += 4;                                                            \
        p1 += 4;                                                            \
        p2 += 4;                                                            \
    }                                                                       \
                                                                            \
    while (cCX--) {                                                         \
                                                                            \
        *pO++ = (BYTE)Mac((*p1), (*p2));                                    \
                                                                            \
        ++p1;                                                               \
        ++p2;                                                               \
    }                                                                       \
}


#define MAC_FROM_3(Mac, pO, p1, p2, p3, cCX)                                \
{                                                                           \
    LONG    Count;                                                          \
                                                                            \
    Count  = cCX >> 2;                                                      \
    cCX   &= 0x03;                                                          \
                                                                            \
    while (Count--) {                                                       \
                                                                            \
        *(pO + 0) = (BYTE)Mac((*(p1+0)), (*(p2+0)), (*(p3+0)));             \
        *(pO + 1) = (BYTE)Mac((*(p1+1)), (*(p2+1)), (*(p3+1)));             \
        *(pO + 2) = (BYTE)Mac((*(p1+2)), (*(p2+2)), (*(p3+2)));             \
        *(pO + 3) = (BYTE)Mac((*(p1+3)), (*(p2+3)), (*(p3+3)));             \
                                                                            \
        pO += 4;                                                            \
        p1 += 4;                                                            \
        p2 += 4;                                                            \
        p3 += 4;                                                            \
    }                                                                       \
                                                                            \
    while (cCX--) {                                                         \
                                                                            \
        *pO++ = (BYTE)Mac((*p1), (*p2), (*p3));                             \
                                                                            \
        ++p1;                                                               \
        ++p2;                                                               \
        ++p3;                                                               \
    }                                                                       \
}




VOID
HTENTRY
Do5225(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_5225, pO, p1, p2, p3, cCX);
}



VOID
HTENTRY
Do1141(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_1141, pO, p1, p2, p3, cCX);
}



VOID
HTENTRY
Do3121(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_3121, pO, p1, p2, p3, cCX);
}



VOID
HTENTRY
Do6251(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_6251, pO, p1, p2, p3, cCX);
}




VOID
HTENTRY
Do3263(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LPBYTE  p3,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_3(CLR_3263, pO, p1, p2, p3, cCX);
}



VOID
HTENTRY
Do1319(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_2(CLR_1319, pO, p1, p2, cCX);
}



VOID
HTENTRY
Do35(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_2(CLR_35, pO, p1, p2, cCX);
}



VOID
HTENTRY
Do13(
    LPBYTE  pO,
    LPBYTE  p1,
    LPBYTE  p2,
    LONG    cCX
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1999 Thu 18:57:47 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    MAC_FROM_2(CLR_13, pO, p1, p2, cCX);
}




VOID
HTENTRY
GrayFastExpAA_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    WORD        wIn[3];


    pRep     = pAAInfo->Src.pRep;
    pRepEnd  = pAAInfo->Src.pRepEnd;
    cRep     = 1;
    pIn     += pAAInfo->Src.cPrevSrc;
    wIn[1]   = GRAY_B2W(*(pIn - 1));
    wIn[2]   = GRAY_B2W(*pIn++);

    do {

        ASSERT(pRep < pRepEnd);

        cRep   = (DWORD)pRep++->c;
        wIn[0] = wIn[1];
        wIn[1] = wIn[2];
        wIn[2] = GRAY_B2W(*pIn++);

        switch (cRep) {

        case 1:

            GRAY_MACRO3(pOut, CLR_5225, wIn[0], wIn[1], wIn[2]);
            break;

        case 2:

            GRAY_MACRO(pOut, CLR_13, wIn[0], wIn[1]);
            (LPBYTE)pOut += OutInc;
            GRAY_MACRO(pOut, CLR_13, wIn[2], wIn[1]);
            break;

        case 3:

            GRAY_MACRO(pOut, CLR_35,    wIn[0], wIn[1]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_1141, wIn[0], wIn[1], wIn[2]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO(pOut, CLR_35,    wIn[2], wIn[1]);

            break;

        case 4:

            GRAY_MACRO(pOut, CLR_35,    wIn[0], wIn[1]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_3121, wIn[0], wIn[1], wIn[2]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_3121, wIn[2], wIn[1], wIn[0]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO(pOut, CLR_35,    wIn[2], wIn[1]);

            break;

        case 5:

            GRAY_MACRO(pOut, CLR_1319,  wIn[0], wIn[1]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_6251, wIn[0], wIn[1], wIn[2]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_3263, wIn[0], wIn[1], wIn[2]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO3(pOut, CLR_6251, wIn[2], wIn[1], wIn[0]);
            (LPBYTE)pOut += OutInc;

            GRAY_MACRO(pOut, CLR_1319,  wIn[2], wIn[1]);

            break;

        default:

            DBGP("GrayFastExpCX Error: Invalid cRep=%ld" ARGDW(cRep));
            ASSERT(cRep <= FAST_MAX_CX);
            break;
        }

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}



VOID
HTENTRY
FastExpAA_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:54:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PREPDATA    pRep;
    PREPDATA    pRepEnd;
    DWORD       cRep;
    BGR8        bgr8[3];



    pRep     = pAAInfo->Src.pRep;
    pRepEnd  = pAAInfo->Src.pRepEnd;
    cRep     = 1;
    pIn     += pAAInfo->Src.cPrevSrc;
    bgr8[1]  = *(pIn - 1);
    bgr8[2]  = *pIn++;

    do {
        //  Bug 27036: ensure loop is exited
        INT_PTR  EntriesRemain = (pOutEnd - (LPBYTE)pOut) / OutInc ;

        if (pRep >= pRepEnd) {

            DBGP("pRep Too big=%ld" ARGDW(pRep - pRepEnd + 1));
            ASSERT(pRep < pRepEnd);
            break;  //  Bug 27036: ensure loop is exited
        }

        cRep    = (DWORD)pRep++->c;

        //  Bug 27036: ensure loop is exited
        if(cRep > (DWORD)EntriesRemain)
            cRep = (DWORD)EntriesRemain ;

        bgr8[0] = bgr8[1];
        bgr8[1] = bgr8[2];
        bgr8[2] = *pIn++;

        switch (cRep) {

        case 1:

            BGR_MACRO3(pOut, CLR_5225, bgr8[0], bgr8[1], bgr8[2]);
            break;

        case 2:

            BGR_MACRO(pOut, CLR_13, bgr8[0], bgr8[1]);
            (LPBYTE)pOut += OutInc;
            BGR_MACRO(pOut, CLR_13, bgr8[2], bgr8[1]);
            break;

        case 3:

            BGR_MACRO(pOut, CLR_35,    bgr8[0], bgr8[1]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_1141, bgr8[0], bgr8[1], bgr8[2]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO(pOut, CLR_35,    bgr8[2], bgr8[1]);

            break;

        case 4:

            BGR_MACRO(pOut, CLR_35,    bgr8[0], bgr8[1]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_3121, bgr8[0], bgr8[1], bgr8[2]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_3121, bgr8[2], bgr8[1], bgr8[0]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO(pOut, CLR_35,    bgr8[2], bgr8[1]);

            break;

        case 5:

            BGR_MACRO(pOut, CLR_1319,  bgr8[0], bgr8[1]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_6251, bgr8[0], bgr8[1], bgr8[2]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_3263, bgr8[0], bgr8[1], bgr8[2]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO3(pOut, CLR_6251, bgr8[2], bgr8[1], bgr8[0]);
            (LPBYTE)pOut += OutInc;

            BGR_MACRO(pOut, CLR_1319,  bgr8[2], bgr8[1]);

            break;

        default:

            DBGP("FastExpCX Error: Invalid cRep=%ld" ARGDW(cRep));
            ASSERT(cRep <= FAST_MAX_CX);
            break;
        }

    } while (((LPBYTE)pOut += OutInc) != pOutEnd);
}




LONG
HTENTRY
FastExpAA_CY(
    PAAHEADER   pAAHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    09-Dec-1998 Wed 15:32:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    AAHEADER        AAHdr = *pAAHdr;
    AASHARPENFUNC   AASPFunc;
    FASTEXPAACXFUNC FastExpAACXFunc;
    LPBYTE          pIn[6];
    PAAINFO         pAAInfo;
    PREPDATA        pRep;
    PREPDATA        pRepEnd;
    LPBYTE          pCur;
    PBGRF           pAABufBeg;
    PBGRF           pAABufEnd;
    LONG            AABufInc;
    LONG            cRep;
    LONG            iRep;
    LONG            cbSrc;
    LONG            iY;
    LONG            cbCX;


    //
    // Fixup the CX first, the *pRep and *(pRepEnd - 1) are fixed, pAABufBeg and
    // pAABufEnd are expanded so we do not need to check the cRep during each
    // of CX functions
    //

    pAAInfo            = AAHdr.pAAInfoCX;
    pRep               = pAAInfo->Src.pRep;
    pRepEnd            = pAAInfo->Src.pRepEnd;
    pAABufBeg          = AAHdr.pAABufBeg;
    pAABufEnd          = AAHdr.pAABufEnd;
    AABufInc           = AAHdr.AABufInc;
    pRep->c           += pAAInfo->Src.cFirstSkip;
    (pRepEnd - 1)->c  += pAAInfo->Src.cLastSkip;
    (LPBYTE)pAABufBeg -= ((LONG)pAAInfo->Src.cFirstSkip * AABufInc);
    (LPBYTE)pAABufEnd += ((LONG)pAAInfo->Src.cLastSkip * AABufInc);

    //
    // Working on the CY now, fixup *(pRepEnd - 1) so it check the correct
    // cRep
    //

    pAAInfo            = AAHdr.pAAInfoCY;
    pRep               = pAAInfo->Src.pRep;
    pRepEnd            = pAAInfo->Src.pRepEnd;
    (pRepEnd - 1)->c  += pAAInfo->Src.cLastSkip;
    cbSrc              = (AAHdr.SrcSurfInfo.Flags & AASIF_GRAY) ? sizeof(BYTE) :
                                                                  sizeof(BGR8);
    pIn[0]             = pAAInfo->pbExtra + (cbSrc * 3);
    cbCX               = (LONG)AAHdr.SrcSurfInfo.cbCX + (cbSrc * 6);
    pIn[1]             = (LPBYTE)pIn[0] + cbCX;
    pIn[2]             = (LPBYTE)pIn[1] + cbCX;
    pIn[3]             = (LPBYTE)pIn[2] + cbCX;
    pIn[4]             = (LPBYTE)pIn[3] + cbCX;
    cbCX              -= (cbSrc * 6);

    if (cbSrc == 1) {

        AASPFunc        = (AASHARPENFUNC)GraySharpenInput;
        FastExpAACXFunc = (FASTEXPAACXFUNC)GrayFastExpAA_CX;

    } else {

        AASPFunc        = (AASHARPENFUNC)SharpenInput;
        FastExpAACXFunc = (FASTEXPAACXFUNC)FastExpAA_CX;
    }

    iY = (LONG)pAAInfo->Src.cPrevSrc;

    GetFixupScan(&AAHdr, (PBGR8)pIn[3]);

    if (--iY < 0) {

        AAHdr.Flags |= AAHF_GET_LAST_SCAN;
    }

    GetFixupScan(&AAHdr, (PBGR8)pIn[4]);

    if (--iY < 0) {

        AAHdr.Flags |= AAHF_GET_LAST_SCAN;
    }

    iY               = -3;
    AAHdr.pInputBeg += 3;

    do {

        pCur   = pIn[0];
        pIn[0] = pIn[1];
        pIn[1] = pIn[2];
        pIn[2] = pIn[3];
        pIn[3] = pIn[4];
        pIn[4] = pCur;

        GetFixupScan(&AAHdr, (PBGR8)pCur);

        AASPFunc(0, pIn[2], pIn[2], pIn[3], pIn[4], cbCX);

        if (++iY < 0) {

            continue;
        }

        iRep =
        cRep = (LONG)pRep++->c;

        if (!iY) {

            cRep += pAAInfo->Src.cFirstSkip;
        }

        pCur = (LPBYTE)AAHdr.pInputBeg;

        while ((iRep--) && (AAHdr.DstSurfInfo.cy)) {

            switch (cRep) {

            case 1:

                Do5225(pCur, pIn[0], pIn[1], pIn[2], cbCX);
                break;

            case 2:

                Do13(pCur, (iRep == 1) ? pIn[0] : pIn[2], pIn[1], cbCX);
                break;

            case 3:

                if (iRep == 1) {

                    Do1141(pCur, pIn[0], pIn[1], pIn[2], cbCX);

                } else {

                    Do35(pCur, (iRep == 2) ? pIn[0] : pIn[2], pIn[1], cbCX);
                }

                break;

            case 4:

                switch (iRep) {

                case 3:

                    Do35(pCur, pIn[0], pIn[1], cbCX);
                    break;

                case 2:

                    Do3121(pCur, pIn[0], pIn[1], pIn[2], cbCX);
                    break;

                case 1:

                    Do3121(pCur, pIn[2], pIn[1], pIn[0], cbCX);
                    break;

                case 0:

                    Do35(pCur, pIn[2], pIn[1], cbCX);
                    break;
                }

                break;

            case 5:

                switch (iRep) {

                case 4:

                    Do1319(pCur, pIn[0], pIn[1], cbCX);
                    break;

                case 3:

                    Do6251(pCur, pIn[0], pIn[1], pIn[2], cbCX);
                    break;

                case 2:

                    Do3263(pCur, pIn[0], pIn[1], pIn[2], cbCX);
                    break;

                case 1:

                    Do6251(pCur, pIn[2], pIn[1], pIn[0], cbCX);
                    break;

                case 0:

                    Do1319(pCur, pIn[2], pIn[1], cbCX);
                    break;

                }

                break;

            default:

                DBGP("FastExpCY Invalid cRep=%ld" ARGDW(cRep));
                ASSERT(cRep <= FAST_MAX_CY);

                break;
            }

            CopyMemory(pCur - cbSrc, pCur, cbSrc);
            CopyMemory(pCur + cbCX, pCur + cbCX - cbSrc, cbSrc);

            FastExpAACXFunc(AAHdr.pAAInfoCX,
                            pCur,
                            (LPBYTE)pAABufBeg,
                            (LPBYTE)pAABufEnd,
                            AABufInc);

            OUTPUT_AA_CURSCAN;

            --AAHdr.DstSurfInfo.cy;
        }

    } while (AAHdr.DstSurfInfo.cy);

    return(pAAHdr->DstSurfInfo.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htsort.c ===
/******************************Module*Header*******************************\
* Module Name: sort.c
*
*
* Created: 20-Mar-1995 09:52:19
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993 Microsoft Corporation
*
*
\**************************************************************************/

#include "htp.h"

typedef struct _SORTSTACK
{
    ULONG iStart;
    ULONG c;
} SORTSTACK;

#define MAXSORT 20

typedef struct _SORTDATA
{
    PBYTE     pjBuf;
    ULONG     iStack;
    ULONG     cjElem;
    SORTCOMP  pfnComp;
    SORTSTACK sStack[MAXSORT];

} SORTDATA;

/******************************Public*Routine******************************\
* vSortSwap()
*
*   Swap the data pointed to by pj1 and pj2, each containing cj bytes.
*
*   Note: this assumes cj is a multiple of 4.
*
*   NOTE: vSortSwap should be inline.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSortSwap(
    PBYTE pj1,
    PBYTE pj2,
    ULONG cj)
{
    PLONG pl1 = (PLONG)pj1;
    PLONG pl2 = (PLONG)pj2;

    do
    {
        LONG l;

        l    = *pl1;
        *pl1++ = *pl2;
        *pl2++ = l;

    } while (cj -= 4);
}

/******************************Public*Routine******************************\
* vSortPush()
*
*   Add a range to the stack to be sorted.
*
*   If there are 0 or 1 elements, just return, sorting done.
*   If there are 2, 3, 4, or 5 elements, just do a bubble sort. sorting done.
*   If the stack is full, just do a bubble sort. sorting done.
*   Otherwise, add a new range to the stack.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSortPush(
    SORTDATA *psd,
    ULONG    iStart,
    ULONG    c)
{
    PBYTE  pj   = psd->pjBuf + iStart;

#if DBGSORT
    DbgPrintf("vSortPush - iStack = %ld, iStart = %ld, c = %ld\n",psd->iStack,iStart,c);
#endif

    if (c > psd->cjElem)
    {
        ULONG i,j;
        ULONG cjElem = psd->cjElem;

        //for (i = 0; i < (c - cjElem); i += cjElem)
        {
        //    if ((*psd->pfnComp)(&pj[i],&pj[i+cjElem]) > 0)
            {
                if ((c <= (4 * psd->cjElem)) || (psd->iStack == MAXSORT))
                {
                    // we have 4 or fewer elements.  Just do a buble sort.  With 4 elements
                    // this will be a 6 compares and upto 6 swaps.
                    // We make c-1 passes over then entire array.  Each pass guarantees that
                    // the next smallest element is shifted to location i.  After the first pass
                    // the smallest element is in location 0.  After the second pass the second
                    // smallest element is in location 1. etc.


                #if DBGSORT
                    if (c > (4 * cjElem))
                        DbgPrintf("******* Stack too deep: c = %ld\n",c / cjElem);
                #endif

                    for (i = 0; i < (c - cjElem); i += cjElem)
                        for (j = c - cjElem; j > i; j -= cjElem)
                            if ((*psd->pfnComp)(&pj[j-cjElem],&pj[j]) > 0)
                                vSortSwap(&pj[j-cjElem],&pj[j],cjElem);
                }
                else
                {
                    psd->sStack[psd->iStack].iStart = iStart;
                    psd->sStack[psd->iStack].c      = c;
                    psd->iStack++;
                }
        //        break;
            }
        }
    }
}

/******************************Public*Routine******************************\
*
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vDrvSort(
    PBYTE pjBuf,
    ULONG c,
    ULONG cjElem,
    SORTCOMP pfnComp)
{
    SORTDATA sd;

#if DBGSORT
    ULONG cOrg = c;
    ULONG i;

    DbgPrintf("\n\nvDrvSort - c = %d\n",c);

#endif

    if (cjElem & 3)
        return;

    sd.pjBuf   = pjBuf;
    sd.iStack  = 0;
    sd.pfnComp = pfnComp;
    sd.cjElem  = cjElem;

    vSortPush(&sd,0,c * cjElem);

    while (sd.iStack)
    {
        PBYTE pj;
        ULONG iStart;
        ULONG iLow;
        ULONG iHi;

        --sd.iStack;
        iStart = sd.sStack[sd.iStack].iStart;
        pj     = &pjBuf[iStart];
        c      = sd.sStack[sd.iStack].c;

    #if DBGSORT

        for (i = 0; i < cOrg;++i)
            vPrintElem(&pjBuf[i * cjElem]);
        DbgPrintf("\n");

        DbgPrintf("iStart = %ld, c = %ld, iStack = %lx - ",iStart/cjElem,c/cjElem,sd.iStack);

        for (i = 0; i < c;i += cjElem)
            vPrintElem(&pj[i]);
        DbgPrintf("\n");

    #endif

        // pick a random value to use for dividing.  Don't use the first since this
        // will reduce the chances of worst case if the list is sorted in reverse order.

        vSortSwap(&pj[0],&pj[(c / cjElem) / 2 * cjElem],cjElem);

        // initialize the starting and ending indexes.  Note that all operations
        // use cjElem as the increment instead of 1.

        iLow = 0;
        iHi  = c - cjElem;

        // divide the array into two pieces, all elements <= before current one

        for (;;)
        {
            // while (pj[iHi] > pj[0]))

            while ((iHi > iLow) && ((*pfnComp)(&pj[iHi],&pj[0]) >= 0))
                iHi -= cjElem;

            // while (pj[iLow] <= pj[0]))

            while ((iLow < iHi) && ((*pfnComp)(&pj[iLow],&pj[0]) <= 0))
                iLow += cjElem;

            if (iHi == iLow)
                break;

            vSortSwap(&pj[iLow],&pj[iHi],cjElem);

            iHi -= cjElem;
            //if (iLow < iHi)
            //    iLow += cjElem;

        #if DBGSORT
            DbgPrintf("\tiLow = %ld, iHi = %ld\n",iLow/cjElem,iHi/cjElem);
        #endif
        }

        // now add the two pieces to stack
        // 0 -> (iLow - 1), (iLow + 1) -> (c - 1)

        if (iLow != 0)
        {
            vSortSwap(&pj[0],&pj[iLow],cjElem);
            if (iLow > 1)
                vSortPush(&sd,iStart,iLow);
        }

        c = c - iLow - cjElem;
        if (c > 1)
            vSortPush(&sd,iStart + iLow + cjElem,c);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htstret.h ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htstret.h


Abstract:

    This module has private definition for htstret.c


Author:

    24-Jan-1991 Thu 10:11:10 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:


--*/


#ifndef _HTSTRET_
#define _HTSTRET_


#define MULRGB(b,l)     (LONG)((LONG)(b) * (LONG)(l))
#define MULQW(a,b)      ((DWORDLONG)(a) * (DWORDLONG)(b))


#define INC_PIN_BY_1ST_LEFT(p,f)        (p) += ((f) & AAIF_EXP_HAS_1ST_LEFT)
#define INC_PIN_BY_EDF_LOAD_PIXEL(p,f)  (p) += ((f) >> 15)


#define PMAP_EXP4(Max)                                                      \
{                                                                           \
    do {                                                                    \
                                                                            \
        *(pMap +   0) = (Mul0 += ed.Mul[0]);                                \
        *(pMap + 256) = (Mul1 += ed.Mul[1]);                                \
        *(pMap + 512) = (Mul2 += ed.Mul[2]);                                \
        *(pMap + 768) = (Mul3 += ed.Mul[3]) + ((Max) >> 1);                 \
                                                                            \
    } while (++pMap < pMap0End);                                            \
}

#define PMAP_EXP3(Max)                                                      \
{                                                                           \
    do {                                                                    \
                                                                            \
        *(pMap + 256) = (Mul1 += ed.Mul[1]);                                \
        *(pMap + 512) = (Mul2 += ed.Mul[2]);                                \
        *(pMap + 768) = (Mul3 += ed.Mul[3]) + ((Max) >> 1);                 \
                                                                            \
    } while (++pMap < pMap0End);                                            \
}


#define PMAP_EXP2(Max)                                                      \
{                                                                           \
    do {                                                                    \
                                                                            \
        *(pMap + 512) = (Mul2 += ed.Mul[2]);                                \
        *(pMap + 768) = (Mul3 += ed.Mul[3]) + ((Max) >> 1);                 \
                                                                            \
    } while (++pMap < pMap0End);                                            \
}


#define PMAP_EXP1(Max)                                                      \
{                                                                           \
    do {                                                                    \
                                                                            \
        *(pMap + 768) = (Mul3 += ed.Mul[3]) + ((Max) >> 1);                 \
                                                                            \
    } while (++pMap < pMap0End);                                            \
}


#define INC_EXP4()      { ++prgb3; ++prgb2; ++prgb1; ++prgb0;  }
#define INC_EXP3()      { ++prgb3; ++prgb2; ++prgb1; }
#define INC_EXP2()      { ++prgb3; ++prgb2;  }
#define INC_EXP1()      { ++prgb3;  }

#define INC2_EXP4()     { prgb3 += 4; prgb2 += 4; prgb1 += 4; prgb0 += 4;  }
#define INC2_EXP3()     { prgb3 += 4; prgb2 += 4; prgb1 += 4; }
#define INC2_EXP2()     { prgb3 += 4; prgb2 += 4;  }
#define INC2_EXP1()     { prgb3 += 4;  }


#define GET_EXP4(cType, c, rs)                                              \
            (cType)(((pMap0[prgb3->c + 768]) +                              \
                     (pMap0[prgb2->c + 512]) +                              \
                     (pMap0[prgb1->c + 256]) +                              \
                     (pMap0[prgb0->c      ])) >> (rs))

#define GET_EXP3(cType, c, rs)                                              \
            (cType)(((pMap0[prgb3->c + 768]) +                              \
                     (pMap0[prgb2->c + 512]) +                              \
                     (pMap0[prgb1->c + 256])) >> (rs))

#define GET_EXP2(cType, c, rs)                                              \
            (cType)(((pMap0[prgb3->c + 768]) +                              \
                     (pMap0[prgb2->c + 512])) >> (rs))

#define GET_EXP1(cType, c, rs)                                              \
            (cType)(((pMap0[prgb3->c + 768])) >> (rs))


#define GET_EXP_PC(MacMap, MacMul, MacIncPtr, pDst)                         \
{                                                                           \
    MacMap(DI_MAX_NUM);                                                     \
                                                                            \
    do {                                                                    \
                                                                            \
        pDst->r = MacMul(BYTE, r, DI_R_SHIFT);                              \
        pDst->g = MacMul(BYTE, g, DI_R_SHIFT);                              \
        pDst->b = MacMul(BYTE, b, DI_R_SHIFT);                              \
                                                                            \
        MacIncPtr();                                                        \
                                                                            \
    } while (((LPBYTE)pDst += AAHdr.AABufInc) != (LPBYTE)AAHdr.pAABufEnd);  \
}



#define GRAY_INC_EXP4() { ++pb3; ++pb2; ++pb1; ++pb0;  }
#define GRAY_INC_EXP3() { ++pb3; ++pb2; ++pb1; }
#define GRAY_INC_EXP2() { ++pb3; ++pb2;  }
#define GRAY_INC_EXP1() { ++pb3;  }


#define GRAY_GET_EXP4(cType, rs)                                            \
            (cType)(((pMap0[*pb3 + 768]) +                                  \
                     (pMap0[*pb2 + 512]) +                                  \
                     (pMap0[*pb1 + 256]) +                                  \
                     (pMap0[*pb0      ])) >> (rs))

#define GRAY_GET_EXP3(cType, rs)                                            \
            (cType)(((pMap0[*pb3 + 768]) +                                  \
                     (pMap0[*pb2 + 512]) +                                  \
                     (pMap0[*pb1 + 256])) >> (rs))

#define GRAY_GET_EXP2(cType, rs)                                            \
            (cType)(((pMap0[*pb3 + 768]) +                                  \
                     (pMap0[*pb2 + 512])) >> (rs))

#define GRAY_GET_EXP1(cType, rs)                                            \
            (cType)(((pMap0[*pb3 + 768])) >> (rs))


#define GRAY_GET_EXP_PC(MacMap, MacMul, MacIncPtr, pDst)                    \
{                                                                           \
    MacMap((DI_MAX_NUM >> 4));                                              \
                                                                            \
    do {                                                                    \
                                                                            \
        pDst->Gray = MacMul(WORD, (DI_R_SHIFT - 8));                        \
                                                                            \
        MacIncPtr();                                                        \
                                                                            \
    } while (((LPBYTE)pDst += AAHdr.AABufInc) != (LPBYTE)AAHdr.pAABufEnd);  \
}



#define OUTPUT_AA_CURSCAN                                                   \
{                                                                           \
    ASSERT(((LPBYTE)AAHdr.DstSurfInfo.pb >= AAHdr.pOutBeg) &&               \
           ((LPBYTE)AAHdr.DstSurfInfo.pb <= AAHdr.pOutEnd));                \
                                                                            \
    if (AAHdr.Flags & AAHF_HAS_MASK) {                                      \
                                                                            \
        DBG_TIMER_BEG(TIMER_MASK);                                          \
                                                                            \
        AAHdr.AAMaskCYFunc(&AAHdr);                                         \
                                                                            \
        DBG_TIMER_BEG(TIMER_MASK);                                          \
    }                                                                       \
                                                                            \
    DBG_TIMER_BEG(TIMER_OUTPUT);                                            \
                                                                            \
    if (AAHdr.Flags & AAHF_ALPHA_BLEND) {                                   \
                                                                            \
        AlphaBlendBGRF(&AAHdr);                                             \
    }                                                                       \
                                                                            \
    if (AAHdr.Flags & AAHF_DO_DST_CLR_MAPPING) {                            \
                                                                            \
        MappingBGRF((PBGRF)AAHdr.pRealOutBeg,                               \
                    (PBGRF)AAHdr.pRealOutEnd,                               \
                    (PBGR8)AAHdr.pBGRMapTable,                              \
                    (LPBYTE)AAHdr.AAPI.pbPat555);                           \
                                                                            \
        if ((AAHdr.AAPI.pbPat555 += AAHdr.AAPI.cyNext555) ==                \
                                                AAHdr.AAPI.pbWrap555) {     \
                                                                            \
            AAHdr.AAPI.pbPat555 = AAHdr.AAPI.pbBeg555;                      \
        }                                                                   \
    }                                                                       \
                                                                            \
    AAHdr.AAOutputFunc(&AAHdr,                                              \
                       AAHdr.pOutputBeg,                                    \
                       AAHdr.pOutputEnd,                                    \
                       AAHdr.DstSurfInfo.pb,                                \
                       AAHdr.pIdxBGR,                                       \
                       AAHdr.AAPI.pbPatBGR,                                 \
                       AAHdr.AAPI.pbPatBGR + AAHdr.AAPI.cbEndBGR,           \
                       AAHdr.AAPI.cbWrapBGR,                                \
                       AAHdr.AAOutputInfo);                                 \
                                                                            \
    if ((AAHdr.AAPI.pbPatBGR += AAHdr.AAPI.cyNextBGR) ==                    \
                                                AAHdr.AAPI.pbWrapBGR) {     \
                                                                            \
        AAHdr.AAPI.pbPatBGR = AAHdr.AAPI.pbBegBGR;                          \
    }                                                                       \
                                                                            \
    AAHdr.DstSurfInfo.pb += AAHdr.DstSurfInfo.cyNext;                       \
                                                                            \
    DBG_TIMER_END(TIMER_OUTPUT);                                            \
}


#define _SHARPEN_CLR_LRTB(cS, cL, cC, cR, cT, cB, ExtraRS)                  \
{                                                                           \
    register LONG   c;                                                      \
                                                                            \
    if (((c) = (((LONG)(cC) << 3) + ((LONG)(cC) << 2) -                     \
                (LONG)(cL) - (LONG)(cR) - (LONG)(cT) -                      \
                (LONG)(cB)) >> (ExtraRS + 3)) & 0xFF00) {                   \
                                                                            \
        (c) = (LONG)~((DWORD)(c) >> 24);                                    \
    }                                                                       \
                                                                            \
    (cS) = (BYTE)(c);                                                       \
}


#define _SHARPEN_CLR_LR(cS, cL, cC, cR, ExtraRS)                            \
{                                                                           \
    register LONG   c;                                                      \
                                                                            \
    if (((c) = (((LONG)(cC) << 2) + ((LONG)(cC) << 1) -                     \
                (LONG)(cL) - (LONG)(cR)) >> (ExtraRS + 2)) & 0xFF00) {      \
                                                                            \
        (c) = (LONG)~((DWORD)(c) >> 24);                                    \
    }                                                                       \
                                                                            \
    (cS) = (BYTE)(c);                                                       \
}


#define _SHARPEN_WCLR_LR(cS, cL, cC, cR, ExtraRS)                           \
{                                                                           \
    register LONG   c;                                                      \
                                                                            \
    if (((c) = (((LONG)(cC) << 2) + ((LONG)(cC) << 1) -                     \
                (LONG)(cL) - (LONG)(cR)) >> (ExtraRS + 2)) & 0xFF0000) {    \
                                                                            \
        (c) = (LONG)~((DWORD)(c) >> 16);                                    \
    }                                                                       \
                                                                            \
    (cS) = (WORD)(c);                                                       \
}


#define SHARPEN_RGB_LR(rgbSP, rgbL, rgbC, rgbR, ExtraRS)                    \
{                                                                           \
    _SHARPEN_CLR_LR((rgbSP).b, (rgbL).b, (rgbC).b, (rgbR).b, ExtraRS);      \
    _SHARPEN_CLR_LR((rgbSP).g, (rgbL).g, (rgbC).g, (rgbR).g, ExtraRS);      \
    _SHARPEN_CLR_LR((rgbSP).r, (rgbL).r, (rgbC).r, (rgbR).r, ExtraRS);      \
}


#define SHARPEN_PRGB_LR(prgbSP, rgbL, rgbC, rgbR, ExtraRS)                  \
{                                                                           \
    _SHARPEN_CLR_LR((prgbSP)->b, (rgbL).b, (rgbC).b, (rgbR).b, ExtraRS);    \
    _SHARPEN_CLR_LR((prgbSP)->g, (rgbL).g, (rgbC).g, (rgbR).g, ExtraRS);    \
    _SHARPEN_CLR_LR((prgbSP)->r, (rgbL).r, (rgbC).r, (rgbR).r, ExtraRS);    \
}


#define SHARPEN_GRAY_LR(GraySP, GrayL, GrayC, GrayR, ExtraRS)               \
{                                                                           \
    _SHARPEN_CLR_LR(GraySP, GrayL, GrayC, GrayR, ExtraRS);                  \
}


#define SHARPEN_PGRAY_LR(pbSP, bL, bC, bR, ExtraRS)                         \
{                                                                           \
    _SHARPEN_CLR_LR(*(pbSP), (bL), bC, bR, ExtraRS);                        \
}

#define SHARPEN_PWGRAY_LR(pSP, bL, bC, bR)                                  \
{                                                                           \
    _SHARPEN_WCLR_LR((pSP)->Gray, (bL), bC, bR, (DI_R_SHIFT - 8));          \
}


#define SHARPEN_PRGB_LRTB(pS, pT, pC, pB, ExtraRS)                          \
{                                                                           \
    _SHARPEN_CLR_LRTB(((pS)    )->b,                                        \
                      ((pC) - 1)->b,                                        \
                      ((pC)    )->b,                                        \
                      ((pC) + 1)->b,                                        \
                      ((pT)    )->b,                                        \
                      ((pB)    )->b,                                        \
                      ExtraRS);                                             \
                                                                            \
    _SHARPEN_CLR_LRTB(((pS)    )->g,                                        \
                      ((pC) - 1)->g,                                        \
                      ((pC)    )->g,                                        \
                      ((pC) + 1)->g,                                        \
                      ((pT)    )->g,                                        \
                      ((pB)    )->g,                                        \
                      ExtraRS);                                             \
                                                                            \
    _SHARPEN_CLR_LRTB(((pS)    )->r,                                        \
                      ((pC) - 1)->r,                                        \
                      ((pC)    )->r,                                        \
                      ((pC) + 1)->r,                                        \
                      ((pT)    )->r,                                        \
                      ((pB)    )->r,                                        \
                      ExtraRS);                                             \
}


#define RGB_DIMAX_TO_BYTE(prgb, rgbL, prgbLast)                             \
{                                                                           \
    prgb->r       = (BYTE)(((DWORD)(rgbL.r)+(DI_MAX_NUM>>1)) >> DI_R_SHIFT);\
    prgb->g       = (BYTE)(((DWORD)(rgbL.g)+(DI_MAX_NUM>>1)) >> DI_R_SHIFT);\
    (prgbLast)->b = (BYTE)(((DWORD)(rgbL.b)+(DI_MAX_NUM>>1)) >> DI_R_SHIFT);\
}


#define SHARPEN_PB_LRTB(pS, pT, pC, pB, ExtraRS)                            \
{                                                                           \
    _SHARPEN_CLR_LRTB(*((pS)    ),                                          \
                      *((pC) - 1),                                          \
                      *((pC)    ),                                          \
                      *((pC) + 1),                                          \
                      *((pT)    ),                                          \
                      *((pB)    ),                                          \
                      ExtraRS);                                             \
}

#define GRAY_DIMAX_TO_BYTE(pb, Gray)                                        \
{                                                                           \
    *(pb) = (BYTE)(((DWORD)(Gray) + (DI_MAX_NUM >> 1)) >> DI_R_SHIFT);             \
}


//
// GET_ALPHA_BLEND(s,d,a) is based on (s=Src, d=Dst, c=Alpha)
//  d = (s * a) + (1 - a) * d
//    = (s * a) + d - (d * a)
//    = d + (s * a) - (d * a)
//    = d + (s - d) * a
//  This macro will do the [(s - d) * a] by shifting to left of 16 bits to
//  obtain more precisions.
//
// GET_GRAY_ALPHA_BLEND(s,d,a) is same as GET_ALPHA_BLEND() except it is
// using only 12 bits for precision, because gray level is already 16 bits
// and a LONG can only up to 31 bits plus a sign bit
//
// GET_AB_DEST_CA(s,d,a) is based on (s=Src, d=Dst, srcAlpha)
// GET_AB_DEST(s,d) is based on (s=Src Alpha, d=Dst Alpha)
//  d = s + (1 - s) * d
//    = s + d - (s * d)
//  This macro will do the [(s * d)] by shifting to left of 16 bits to
//  obtain more precisions.
//
//

#define __B2W(b)                ((WORD)GrayIdxWORD[b])
#define GRAY_B2W(b)             (WORD)__B2W(b)
#define GET_CA_VALUE(b)         (LONG)__B2W(b)
#define _GET_GRAY_CA_VALUE(b)   ((LONG)__B2W(b) >> 4)

#define GET_GRAY_AB_SRC(s,d)
#define GET_GRAY_AB_DST(s,d)    (s)=(d)
#define GET_GRAY_ALPHA_BLEND(s,d,a)                                         \
        (s) = (WORD)(((LONG)(d) + (((((LONG)(s)-(LONG)(d))                  \
                    * _GET_GRAY_CA_VALUE(a)) + 0x800) >> 12)))

#define _GET_BGR_BLEND(s,d,a)                                               \
        (BYTE)(((LONG)(d)+(((((LONG)(s)-(LONG)(d))*(LONG)(a))+0x8000) >> 16)))

#define GET_AB_BGR_SRC(pS, pbXlate, pD)                                     \
{                                                                           \
    pS->b = (BYTE)pbXlate[pS->b];                                           \
    pS->g = (BYTE)pbXlate[pS->g];                                           \
    pS->r = (BYTE)pbXlate[pS->r];                                           \
}

#define GET_AB_BGR_DST(pS, pbXlate, pD)     *(PBGR8)(pS) = *(PBGR8)(pD)
#define GET_ALPHA_BLEND_BGR(pS, pbXlate, pD, a)                             \
{                                                                           \
    pS->b = (BYTE)_GET_BGR_BLEND(pbXlate[pS->b +   0], pD->b, a);           \
    pS->g = (BYTE)_GET_BGR_BLEND(pbXlate[pS->g + 256], pD->g, a);           \
    pS->r = (BYTE)_GET_BGR_BLEND(pbXlate[pS->r + 512], pD->r, a);           \
}

#define GET_AB_DEST_CA_SRC(s,d)     (d)=(s)
#define GET_AB_DEST_CA_DST(s,d)

#define GET_AB_DEST_CA(s,d,a)                                               \
        (d)=(BYTE)(((LONG)(s)+(LONG)(d)-((((LONG)(d)*(LONG)(a))+0x8000)>>16)))

#define GET_AB_DEST(s,d)                                                    \
        (BYTE)(((LONG)(s)+(LONG)(d)-((((LONG)(d)*GET_CA_VALUE(s))+0x8000)>>16)))

#define _GET_CONST_ALPHA(a, b, p)   (BYTE)(((a) + p[(b) + (256 * 3)]) >> 8)
#define _GRAY_CONST_ALPHA(a, b, p)  (WORD)(((a) + p[(b) + (256 * 3)]))

#define GET_CONST_ALPHA_BGR(pS, pD, pwBGR)                                  \
{                                                                           \
    pS->b = _GET_CONST_ALPHA(pwBGR[pS->b +   0], pD->b, pwBGR);             \
    pS->g = _GET_CONST_ALPHA(pwBGR[pS->g + 256], pD->g, pwBGR);             \
    pS->r = _GET_CONST_ALPHA(pwBGR[pS->r + 512], pD->r, pwBGR);             \
}

#define GET_CONST_ALPHA_GRAY(pS, pbD, pwBGR)                                \
        ((PGRAYF)pS)->Gray = _GRAY_CONST_ALPHA(pwBGR[pS->g], *pbD, pwBGR)




typedef LPBYTE (HTENTRY *AASHARPENFUNC)(DWORD   AAHFlags,
                                        LPBYTE  pS,
                                        LPBYTE  pT,
                                        LPBYTE  pC,
                                        LPBYTE  pB,
                                        LONG    cbIn);


typedef VOID (HTENTRY *FASTEXPAACXFUNC)(PAAINFO   pAAInfo,
                                        LPBYTE    pIn,
                                        LPBYTE    pOut,
                                        LPBYTE    pOutEnd,
                                        LONG      OutInc);

#define _MUL1(x)        ((LONG)(x))
#define _MUL2(x)        ((LONG)(x)<<1)
#define _MUL3(x)        (_MUL2(x)+(LONG)(x))
#define _MUL4(x)        ((LONG)(x)<<2)
#define _MUL5(x)        (_MUL4(x)+_MUL1(x))
#define _MUL6(x)        (_MUL4(x)+_MUL2(x))
#define _MUL8(x)        ((LONG)(x)<<3)
#define _MUL10(x)       (_MUL8(x)+_MUL2(x))
#define _MUL12(x)       (_MUL8(x)+_MUL4(x))
#define _MUL16(x)       ((LONG)(x)<<4)
#define _MUL22(x)       (_MUL16(x)+_MUL6(x))
#define _MUL24(x)       (_MUL4(_MUL6(x)))
#define _MUL14(x)       (_MUL16(x)-_MUL2(x))


#define CLR_13(l,c)     ((_MUL1(l)+_MUL3(c)+2) >> 2)
#define CLR_35(l,c)     ((_MUL3(l)+_MUL5(c)+4) >> 3)
#define CLR_1319(l,c)   ((_MUL4(_MUL3(l)+_MUL5(c))+_MUL1(l)-_MUL1(c)+16)>>5)

#define CLR_1141(l,c,r) ((_MUL1(l)+_MUL14(c)+_MUL1(r)+8) >> 4)
#define CLR_5225(l,c,r) ((_MUL5(_MUL1(l)+_MUL1(r))+_MUL22(c)+16) >> 5)
#define CLR_3121(l,c,r) ((_MUL3(l)+_MUL12(c)+_MUL1(r)+8) >> 4)
#define CLR_6251(l,c,r) ((_MUL6(l)+_MUL24(c)+_MUL1(c)+_MUL1(r)+16) >> 5)
#define CLR_3263(l,c,r) ((_MUL3(_MUL1(l)+_MUL1(r))+_MUL24(c)+_MUL2(c)+16)>>5)


#define BGR_MACRO(pO, Mac, cl, cc)                                          \
{                                                                           \
    pO->r = (BYTE)Mac((cl).r, (cc).r);                                      \
    pO->g = (BYTE)Mac((cl).g, (cc).g);                                      \
    pO->b = (BYTE)Mac((cl).b, (cc).b);                                      \
}

#define BGR_MACRO3(pO, Mac, cl, cc, cr)                                     \
{                                                                           \
    pO->r = (BYTE)Mac((cl).r, (cc).r, (cr).r);                              \
    pO->g = (BYTE)Mac((cl).g, (cc).g, (cr).g);                              \
    pO->b = (BYTE)Mac((cl).b, (cc).b, (cr).b);                              \
}

#define GRAY_MACRO(pO, Mac, cl, cc)                                         \
{                                                                           \
    pO->Gray = (WORD)Mac((cl), (cc));                                       \
}

#define GRAY_MACRO3(pO, Mac, cl, cc, cr)                                    \
{                                                                           \
    pO->Gray = (WORD)Mac((cl), (cc), (cr));                                 \
}



//
// Function Prototype
//

VOID
HTENTRY
MappingBGR(
    PBGR8   pbgr,
    LONG    cbgr,
    PBGR8   pBGRMapTable,
    LPBYTE  pbPat555
    );


VOID
HTENTRY
MappingBGRF(
    PBGRF   pbgrf,
    PBGRF   pbgrfEnd,
    PBGR8   pBGRMapTable,
    LPBYTE  pbPat555
    );


PBGR8
HTENTRY
SharpenInput(
    DWORD   AAHFlags,
    PBGR8   pbgrS,
    PBGR8   pbgr0,
    PBGR8   pbgr1,
    PBGR8   pbgr2,
    LONG    cbBGRIn
    );

LPBYTE
HTENTRY
GraySharpenInput(
    DWORD   AAHFlags,
    LPBYTE  pbS,
    LPBYTE  pb0,
    LPBYTE  pb1,
    LPBYTE  pb2,
    LONG    cbIn
    );

LONG
HTENTRY
TileDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
RepDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
RepDIB_CY(
    PAAHEADER   pAAHdr
    );

LONG
HTENTRY
FastExpAA_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
SkipDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
SkipDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
CopyDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
BltDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ShrinkDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
ShrinkDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
SrkYDIB_SrkCX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut
    );

LONG
HTENTRY
ShrinkDIB_CY_SrkCX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
ExpandDIB_CX(
    PAAINFO pAAInfo,
    PBGR8   pIn,
    PBGR8   pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

VOID
HTENTRY
ExpYDIB_ExpCX(
    PEXPDATA    pED,
    PBGR8       pIn,
    PBGR8       pOut,
    PBGR8       pOutEnd
    );

LONG
HTENTRY
ExpandDIB_CY_ExpCX(
    PAAHEADER   pAAHdr
    );

LONG
HTENTRY
ExpandDIB_CY(
    PAAHEADER   pAAHdr
    );


//
// Gray functions
//


VOID
HTENTRY
GrayRepDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

VOID
HTENTRY
GraySkipDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

VOID
HTENTRY
GrayCopyDIB_CXGray(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    PGRAYF  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

VOID
HTENTRY
GrayCopyDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
GrayExpandDIB_CY_ExpCX(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
GrayExpandDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
GrayExpandDIB_CY(
    PAAHEADER   pAAHdr
    );

VOID
HTENTRY
GrayShrinkDIB_CX(
    PAAINFO pAAInfo,
    LPBYTE  pIn,
    LPBYTE  pOut,
    LPBYTE  pOutEnd,
    LONG    OutInc
    );

LONG
HTENTRY
GrayShrinkDIB_CY(
    PAAHEADER   pAAHdr
    );

#endif  // _HTSTRET_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\i386\htp.inc ===
COMMENT `


Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htrbmp.asm


Abstract:

    This function is the equivelant codes in the htp.h


Author:
    05-Apr-1991 Fri 15:55:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:

    28-Mar-1992 Sat 21:06:23 updated  -by-  Daniel Chou (danielc)
        Update for PRIMCOLOR/PRIMMONO data structure and other structures for
        VGA16 support, it also now support 6553500% stretchs.



`




PRIMMONO STRUC
    MonoPrim1       DB  ?
    MonoPrim2       DB  ?
PRIMMONO ENDS

PRIMMONO_COUNT STRUC
    PMC_Count       DW  ?
    PMC_Prim1       DB  ?
    PMC_Prim2       DB  ?
PRIMMONO_COUNT ENDS


PRIMCOLOR STRUC
    ClrPrim1        DB  ?
    ClrPrim2        DB  ?
    ClrPrim3        DB  ?
    ClrPrim4        DB  ?
    ClrPrim5        DB  ?
    ClrPrim6        DB  ?
PRIMCOLOR ENDS

PRIMCOLOR_COUNT STRUC
    PCC_Count       DW  ?
    PCC_Prim1       DB  ?
    PCC_Prim2       DB  ?
    PCC_Prim3       DB  ?
    PCC_Prim4       DB  ?
    PCC_Prim5       DB  ?
    PCC_Prim6       DB  ?
PRIMCOLOR_COUNT ENDS

SIZE_PMC                equ     4
SIZE_PCC                equ     8


RGB555LUTM  STRUC
    LUTM_rs0        DB  ?
    LUTM_rs1        DB  ?
    LUTM_rs2        DB  ?
    LUTM_rs3        DB  ?
    LUTM_wIdx0      DW  256 dup(?)
    LUTM_wIdx1      DW  256 dup(?)
    LUTM_wIdx2      DW  256 dup(?)
    LUTM_Map        DD  ?
RGB555LUTM  ENDS


RGB555LUTC  STRUC
    LUTC_rs0        DB  ?
    LUTC_rs1        DB  ?
    LUTC_rs2        DB  ?
    LUTC_rs3        DB  ?
    LUTC_wIdx0      DW  256 dup(?)
    LUTC_wIdx1      DW  256 dup(?)
    LUTC_wIdx2      DW  256 dup(?)
    LUTC_bIdx0      DB  256 dup(?)
    LUTC_bIdx1      DB  256 dup(?)
    LUTC_bIdx2      DB  256 dup(?)
    LUTC_Map        DD  ?
RGB555LUTC  ENDS

LUT_RS_SIZE             equ     4
LUT_WIDX0               equ     (LUT_RS_SIZE)
LUT_WIDX1               equ     (LUT_WIDX0 + (256 * 2))
LUT_WIDX2               equ     (LUT_WIDX1 + (256 * 2))
LUT_BIDX0               equ     (LUT_WIDX2 + (256 * 2))
LUT_BIDX1               equ     (LUT_BIDX0 + (256 * 1))
LUT_BIDX2               equ     (LUT_BIDX1 + (256 * 1))
LUT_MONOMAP             equ     LUT_BIDX0
LUT_COLORMAP            equ     (LUT_BIDX2 + (256 * 1))


VGA256_C_IDX_MAX        equ     5
VGA256_M_IDX_MAX        equ     20
VGA256_C_LEVELS         equ     (VGA256_C_IDX_MAX + 1)
VGA256_M_LEVELS         equ     (VGA256_M_IDX_MAX + 1)

VGA256_R_CUBE_INC       equ     1
VGA256_G_CUBE_INC       equ     VGA256_C_LEVELS
VGA256_B_CUBE_INC       equ     (VGA256_G_CUBE_INC * VGA256_G_CUBE_INC)

RGB555_C_LEVELS         equ     32
RGB555_B_CUBE_INC       equ     1
RGB555_G_CUBE_INC       equ     RGB555_C_LEVELS
RGB555_R_CUBE_INC       equ     (RGB555_G_CUBE_INC * RGB555_G_CUBE_INC)




BMF_1BPP_3PLANES        equ     0
BMF_1BPP                equ     1
BMF_4BPP                equ     2
BMF_8BPP                equ     3
BMF_16BPP               equ     4
BMF_24BPP               equ     5
BMF_32BPP               equ     6
BMF_4BPP_VGA16          equ     255
BMF_8BPP_VGA256         equ     254
BMF_16BPP_555           equ     253


HTBRUSHDATA STRUC
    Flags               DB  ?
    SurfaceFormat       DB  ?
    ScanLinePadBytes    DW  ?
    cxHTCell            DB  ?
    cyHTCell            DB  ?
    SizePerPlane        DW  ?
HTBRUSHDATA ENDS


CAOTBAINFO  STRUC
    CAOTBA_BytesCount   DW  ?
    CAOTBA_Flags        DW  ?
CAOTBAINFO  ENDS


CAOTBAF_INVERT          equ     01h
CAOTBAF_COPY            equ     02h



;
; SRCMASKINFO
;
;  This data structure is passed to the source mask preparation function.
;
;  CompressLines       - Total lines need to be merge for the source mask.
;
;  FirstSrcMaskSkips   - The total bits in the first source mask byte to be
;                        skipped.
;
;  SourceMask          - The starting source mask's offset mask's shift to the
;                        left by 1
;
;  SourcOffsetMask     - The starting source offset's mask, not left shift 1.
;
;                        HR.XStretch.StretchRatio.StretchSize.
;  OffsetCount         - Location of the .COUNT in the PRIMMONO_COUNT or
;                        PRIMCOLOR_COUNT data structure, if this field is
;                        0xff, then evey PRIMxxxx_COUNT count is 1, that is
;                        the source is not compressed.
;
;  OffsetPrim1         - Location of the .Prim1 in the PRIMMONO_COUNT or
;                        PRIMCOLOR_COUNT data structure, the Prim2/Prim3/Prim4
;                        must followed in that order if they exist.
;
;  ColorInfoIncrement  - The PRIM_COLOR/PRIM_MONO incrementments, it may be
;                        negative.
;
;  StretchSize         - Total Stretch need to be masked
;
;
;
;

SMIF_XCOUNT_IS_ONE          equ 01h

SRCMASKINFO STRUC
    SMI_Flags               DB  ?
    SMI_FirstSrcMaskSkips   DB  ?
    SMI_OffsetCount         DB  ?
    SMI_CountTocSkip        DB  ?
    SMI_ColorInfoIncrement  DW  ?
    SMI_StretchSize         DW  ?
SRCMASKINFO ENDS



IFIF_GET_FIRST_BYTE     equ     01h
IFIF_INIT_SRC_READ      equ     02h
IFIF_XCOUNT_IS_ONE      equ     04h
IFIF_HAS_SRC_MASK       equ     08h

INFUNCINFO  STRUC
    IFI_ColorInfoIncrement  DW  ?
    IFI_BMF1BPP1stShift     DB  ?
    IFI_Flags               DB  ?
INFUNCINFO  ENDS


OUTFUNCINFO STRUC
    OFI_pXlate8BPP      DD  ?
    OFI_pPrimMap        DD  ?
    OFI_p555Pat         DD  ?
    OFI_cx555Pat        DW  ?
    OFI_OrgX555Pat      DW  ?
    OFI_PatWidthBytes   DW  ?
    OFI_PatOrgX         DW  ?
    OFI_pPatA           DD  ?
    OFI_pPatB           DD  ?
    OFI_pPatC           DD  ?
OUTFUNCINFO ENDS


PRIM_COUNT_SPECIAL      equ      8000h
PRIM_COUNT_CHECK_SKIP   equ      8000h
PRIM_COUNT_END_SCAN     equ     0ffffh


MAX_HTPATTERN_WIDTH     equ     32
LOCAL_PATTERN_DWSIZE    =       ((MAX_HTPATTERN_WIDTH + (16 + 3)) / 4)


VGA256_COLORCUBE_COUNT  equ     216

IF DBG

extrn   DbgPrintf:PROC

ENDIF


IF1


DBG_FILENAME    macro  FileName

IF DBG
    .DATA
    DbgFileName     db  '&FileName.asm',0
ENDIF

ENDM



__@@ASSERT_OPCODE equ <>
__@@ASSERT_OP1    equ <>
__@@ASSERT_OP2    equ <>
__@@C_PushCount     = 0


__@@AssertOpCode    macro   OpCode,Op1,Op2
    __@@ASSERT_OPCODE   CATSTR  <&OpCode>,<      >
    __@@ASSERT_OPCODE   SUBSTR  __@@ASSERT_OPCODE, 1, 5
    __@@ASSERT_OP1      CATSTR  <&Op1>
    __@@ASSERT_OP2      CATSTR  <&Op2>
ENDM


__@@DoPush  MACRO   Param
    IFNB <Param>

%       IF ((.TYPE Param) AND 00004h)                   ;; if constant value
            IF i8086
                __@@EMIT <mov  >    _AX, <Param>
                __@@EMIT <push >    _AX
            ELSE
                __@@EMIT <push >    <Param>
            ENDIF
        ELSE
            IF i8086 or i286
                SegName CATSTR <ds,es,ss,cs>
            ELSE
                SegName CATSTR <>
            ENDIF

            __@@VALID_REG? <__@@DoPush>, <Param>,SegName,<_AX,_BX,_CX,_DX,_SI,_DI,_BP,_SP>
%           __@@EMIT <push >    <Param>
        ENDIF

        __@@C_PushCount = __@@C_PushCount + 1
    ENDIF
ENDM


;
; __@@C_PARAMS_PUSH     push a register or a constant number
;

__@@C_PARAMS_PUSH  MACRO   IsPointer, Name
    IFNB <Name>
        IF IsPointer
            IF i8086 or i286
                __@@DoPush  <SEG    Name>
            ENDIF

            __@@DoPush  <OFFSET Name>
        ELSE
            __@@DoPush  <Name>
        ENDIF
    ENDIF
ENDM


;
; __@@C_PARAMS_POP      restore the stack of count after C call.
;


__@@C_PARAMS_POP   Macro   PopCount
    IF PopCount LT 3
        REPT    PopCount
            __@@EMIT <pop  >    %_CX
        ENDM
ELSE
        __@@EMIT <add  >    %_SP, %(PopCount * REG_MAX_SIZE)
ENDIF

ENDM


;
; DBGP  debug output macro
;

DBGP_IF macro   Print, Msg, p1, p2, p3, p4, p5, p6, p7, p8
        LOCAL   LocalMsg


IF DBG AND Print

        .DATA

LocalMsg    db  '&Msg',0

        .CODE

        PUSH_ALL

        __@@C_PushCount = 0                     ;; reset

        __@@C_PARAMS_PUSH   0, <p8>
        __@@C_PARAMS_PUSH   0, <p7>
        __@@C_PARAMS_PUSH   0, <p6>
        __@@C_PARAMS_PUSH   0, <p5>
        __@@C_PARAMS_PUSH   0, <p4>
        __@@C_PARAMS_PUSH   0, <p3>
        __@@C_PARAMS_PUSH   0, <p2>
        __@@C_PARAMS_PUSH   0, <p1>
        __@@C_PARAMS_PUSH   1, <LocalMsg>

        __@@EMIT <call >    DbgPrintf

        __@@C_PARAMS_POP    __@@C_PushCount

        POP_ALL
ENDIF

ENDM

;
; ASSERT    Assert when Flag is not true, if NOT in debug mode, it will
;           load _AX with ErrNo and jump to the ExitLoc
;

ASSERT  macro   OpCode,Flag,Mode,ErrNo,ExitLoc,Msg,p1,p2,p3,p4,p5,p6,p7,p8
        LOCAL   AssertMsg, SkipNext


    IsDbgOnly = 0

    IFIDNI <Mode>,<DBG_ONLY>
        IsMode = 1
    ELSE
        IFIDNI <Mode>,<!ALWAYS!>
            IsMode = 0
        ELSE
            IF1
                %OUT Error: ASSERT(&Mode), Valid are <DBG_ONLY>, <!ALWAYS!>
            ENDIF
            .ERR
            EXITM
        ENDIF
    ENDIF


    __@@AssertOpCode    OpCode

    JTrueStr    CATSTR <J>,<&Flag>,<     >
    JTrueStr    SUBSTR JTrueStr,1,5


IF DBG

        .DATA
AssertMsg   db  13, 10, '!ERROR: (%d), failed in <%s>'
            db  13, 10, 'ASSERT: &Msg', 13, 10,0

        .CODE

%       __@@EMIT <__@@ASSERT_OPCODE>    <__@@ASSERT_OP1>, <__@@ASSERT_OP2>
%       __@@EMIT <JTrueStr>             <SHORT SkipNext>

        PUSH_ALL

        __@@C_PushCount = 0


        __@@C_PARAMS_PUSH   0, <p8>
        __@@C_PARAMS_PUSH   0, <p7>
        __@@C_PARAMS_PUSH   0, <p6>
        __@@C_PARAMS_PUSH   0, <p5>
        __@@C_PARAMS_PUSH   0, <p4>
        __@@C_PARAMS_PUSH   0, <p3>
        __@@C_PARAMS_PUSH   0, <p2>
        __@@C_PARAMS_PUSH   0, <p1>

        __@@C_PARAMS_PUSH   1, <DbgFileName>
        __@@C_PARAMS_PUSH   0, <ErrNo>
        __@@C_PARAMS_PUSH   1, <AssertMsg>

        __@@EMIT <call >    DbgPrintf

        __@@C_PARAMS_POP    __@@C_PushCount

        POP_ALL

        __@@EMIT <INT  >    3
        __@@EMIT <jmp  >    <ExitLoc>

ELSE
    IF IsDbgOnly
%      __@@EMIT <__@@ASSERT_OPCODE>     <__@@ASSERT_OP1>, <__@@ASSERT_OP2>
%      __@@EMIT <JTrueStr>              <SHORT SkipNext>

        __@@EMIT <mov  >    _AX, <ErrNo>
        __@@EMIT <jmp  >    <ExitLoc>
    ENDIF
ENDIF

SkipNext:

ENDM


ENDIF       ;; IF1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\htsetbmp.c ===
/*++

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htsetbmp.c


Abstract:

    This module is used to provide set of functions to set the bits into the
    final destination bitmap.


Author:
    11-Nov-1998 Wed 09:27:34 updated  -by-  Daniel Chou (danielc)
        Re-write for anti-aliasing

    28-Mar-1992 Sat 20:59:29 updated  -by-  Daniel Chou (danielc)
        Add Support for VGA16, and also make output only 1 destinaiton pointer
        for 3 planer.


    03-Apr-1991 Wed 10:28:50 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:

    11-Jan-1999 Mon 16:07:37 updated  -by-  Daniel Chou (danielc)
        re-structure



--*/


#define DBGP_VARNAME        dbgpHTSetBmp

#include "htp.h"
#include "htmapclr.h"
#include "htrender.h"
#include "htpat.h"
#include "htdebug.h"
#include "htalias.h"
#include "htstret.h"
#include "htsetbmp.h"


#define DBGP_VGA256XLATE        0x00000001
#define DBGP_BRUSH              0x00000002


DEF_DBGPVAR(BIT_IF(DBGP_VGA256XLATE,    0)  |
            BIT_IF(DBGP_BRUSH,          0))


CONST BYTE VGA16Xlate[120] = {

        0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf0,
        0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,
        0xef,0xee,0xed,0xec,0xeb,0xea,0xe9,0xe0,
        0xef,0xee,0xed,0xec,0xeb,0xea,0xe9,0xe8,
        0xdf,0xde,0xdd,0xdc,0xdb,0xda,0xd9,0xd0,
        0xdf,0xde,0xdd,0xdc,0xdb,0xda,0xd9,0xd8,
        0xcf,0xce,0xcd,0xcc,0xcb,0xca,0xc9,0xc0,
        0xcf,0xce,0xcd,0xcc,0xcb,0xca,0xc9,0xc8,
        0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb0,
        0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,
        0xaf,0xae,0xad,0xac,0xab,0xaa,0xa9,0xa0,
        0xaf,0xae,0xad,0xac,0xab,0xaa,0xa9,0xa8,
        0x9f,0x9e,0x9d,0x9c,0x9b,0x9a,0x99,0x90,
        0x9f,0x9e,0x9d,0x9c,0x9b,0x9a,0x99,0x98,
        0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x00 
    };

//
// Xlate table has 3 bits for each of C=6-8, M=3-5, Y=0-2
//
// For 5:5:5,  1 0010 0100 = 0x124 = 0-292  (293 Entries)
// for 6:6:6,  1 0110 1101 = 0x169 = 0-365  (366 Entries)
//

CONST BYTE VGA256Xlate[SIZE_XLATE_666] = {

        215,214,213,212,211,210,210,210,209,208,207,206,205,204,204,204,
        203,202,201,200,199,198,198,198,197,196,195,194,193,192,192,192,
        191,190,189,188,187,186,186,186,185,184,183,182,181,180,180,180,
        185,184,183,182,181,180,180,180,185,184,183,182,181,180,180,180,
        179,178,177,176,175,174,174,174,173,172,171,170,169,168,168,168,
        167,166,165,164,163,162,162,162,161,160,159,158,157,156,156,156,
        155,154,153,152,151,150,150,150,149,148,147,146,145,144,144,144,
        149,148,147,146,145,144,144,144,149,148,147,146,145,144,144,144,
        143,142,141,140,139,138,138,138,137,136,135,134,133,132,132,132,
        131,130,129,128,127,126,126,126,125,124,123,122,121,120,120,120,
        119,118,117,116,115,114,114,114,113,112,111,110,109,108,108,108,
        113,112,111,110,109,108,108,108,113,112,111,110,109,108,108,108,
        107,106,105,104,103,102,102,102,101,100, 99, 98, 97, 96, 96, 96,
         95, 94, 93, 92, 91, 90, 90, 90, 89, 88, 87, 86, 85, 84, 84, 84,
         83, 82, 81, 80, 79, 78, 78, 78, 77, 76, 75, 74, 73, 72, 72, 72,
         77, 76, 75, 74, 73, 72, 72, 72, 77, 76, 75, 74, 73, 72, 72, 72,
         71, 70, 69, 68, 67, 66, 66, 66, 65, 64, 63, 62, 61, 60, 60, 60,
         59, 58, 57, 56, 55, 54, 54, 54, 53, 52, 51, 50, 49, 48, 48, 48,
         47, 46, 45, 44, 43, 42, 42, 42, 41, 40, 39, 38, 37, 36, 36, 36,
         41, 40, 39, 38, 37, 36, 36, 36, 41, 40, 39, 38, 37, 36, 36, 36,
         35, 34, 33, 32, 31, 30, 30, 30, 29, 28, 27, 26, 25, 24, 24, 24,
         23, 22, 21, 20, 19, 18, 18, 18, 17, 16, 15, 14, 13, 12, 12, 12,
         11, 10,  9,  8,  7,  6,  6,  6,  5,  4,  3,  2,  1,  0
    };


CONST BYTE CMY555Xlate[SIZE_XLATE_555] = {

          0,  1,  2,  3,  4,  4,  4,  4,  5,  6,  7,  8,  9,  9,  9,  9,
         10, 11, 12, 13, 14, 14, 14, 14, 15, 16, 17, 18, 19, 19, 19, 19,
         20, 21, 22, 23, 24, 24, 24, 24, 20, 21, 22, 23, 24, 24, 24, 24,
         20, 21, 22, 23, 24, 24, 24, 24, 20, 21, 22, 23, 24, 24, 24, 24,
         25, 26, 27, 28, 29, 29, 29, 29, 30, 31, 32, 33, 34, 34, 34, 34,
         35, 36, 37, 38, 39, 39, 39, 39, 40, 41, 42, 43, 44, 44, 44, 44,
         45, 46, 47, 48, 49, 49, 49, 49, 45, 46, 47, 48, 49, 49, 49, 49,
         45, 46, 47, 48, 49, 49, 49, 49, 45, 46, 47, 48, 49, 49, 49, 49,
         50, 51, 52, 53, 54, 54, 54, 54, 55, 56, 57, 58, 59, 59, 59, 59,
         60, 61, 62, 63, 64, 64, 64, 64, 65, 66, 67, 68, 69, 69, 69, 69,
         70, 71, 72, 73, 74, 74, 74, 74, 70, 71, 72, 73, 74, 74, 74, 74,
         70, 71, 72, 73, 74, 74, 74, 74, 70, 71, 72, 73, 74, 74, 74, 74,
         75, 76, 77, 78, 79, 79, 79, 79, 80, 81, 82, 83, 84, 84, 84, 84,
         85, 86, 87, 88, 89, 89, 89, 89, 90, 91, 92, 93, 94, 94, 94, 94,
         95, 96, 97, 98, 99, 99, 99, 99, 95, 96, 97, 98, 99, 99, 99, 99,
         95, 96, 97, 98, 99, 99, 99, 99, 95, 96, 97, 98, 99, 99, 99, 99,
        100,101,102,103,104,104,104,104,105,106,107,108,109,109,109,109,
        110,111,112,113,114,114,114,114,115,116,117,118,119,119,119,119,
        120,121,122,123,124
    };

CONST BYTE RGB555Xlate[SIZE_XLATE_555] = {

        190,189,188,187,186,186,186,186,185,184,183,182,181,181,181,181,
        180,179,178,177,176,176,176,176,175,174,173,172,171,171,171,171,
        170,169,168,167,166,166,166,166,170,169,168,167,166,166,166,166,
        170,169,168,167,166,166,166,166,170,169,168,167,166,166,166,166,
        165,164,163,162,161,161,161,161,160,159,158,157,156,156,156,156,
        155,154,153,152,151,151,151,151,150,149,148,147,146,146,146,146,
        145,144,143,142,141,141,141,141,145,144,143,142,141,141,141,141,
        145,144,143,142,141,141,141,141,145,144,143,142,141,141,141,141,
        140,139,138,137,136,136,136,136,135,134,133,132,131,131,131,131,
        130,129,127,126,125,125,125,125,124,123,122,121,120,120,120,120,
        119,118,117,116,115,115,115,115,119,118,117,116,115,115,115,115,
        119,118,117,116,115,115,115,115,119,118,117,116,115,115,115,115,
        114,113,112,111,110,110,110,110,109,108,107,106,105,105,105,105,
        104,103,102,101,100,100,100,100, 99, 98, 97, 96, 95, 95, 95, 95,
         94, 93, 92, 91, 90, 90, 90, 90, 94, 93, 92, 91, 90, 90, 90, 90,
         94, 93, 92, 91, 90, 90, 90, 90, 94, 93, 92, 91, 90, 90, 90, 90,
         89, 88, 87, 86, 85, 85, 85, 85, 84, 83, 82, 81, 80, 80, 80, 80,
         79, 78, 77, 76, 75, 75, 75, 75, 74, 73, 72, 71, 70, 70, 70, 70,
         69, 68, 67, 66, 65 
    };

CONST BYTE CMY666Xlate[SIZE_XLATE_666] = {

          0,  1,  2,  3,  4,  5,  5,  5,  6,  7,  8,  9, 10, 11, 11, 11,
         12, 13, 14, 15, 16, 17, 17, 17, 18, 19, 20, 21, 22, 23, 23, 23,
         24, 25, 26, 27, 28, 29, 29, 29, 30, 31, 32, 33, 34, 35, 35, 35,
         30, 31, 32, 33, 34, 35, 35, 35, 30, 31, 32, 33, 34, 35, 35, 35,
         36, 37, 38, 39, 40, 41, 41, 41, 42, 43, 44, 45, 46, 47, 47, 47,
         48, 49, 50, 51, 52, 53, 53, 53, 54, 55, 56, 57, 58, 59, 59, 59,
         60, 61, 62, 63, 64, 65, 65, 65, 66, 67, 68, 69, 70, 71, 71, 71,
         66, 67, 68, 69, 70, 71, 71, 71, 66, 67, 68, 69, 70, 71, 71, 71,
         72, 73, 74, 75, 76, 77, 77, 77, 78, 79, 80, 81, 82, 83, 83, 83,
         84, 85, 86, 87, 88, 89, 89, 89, 90, 91, 92, 93, 94, 95, 95, 95,
         96, 97, 98, 99,100,101,101,101,102,103,104,105,106,107,107,107,
        102,103,104,105,106,107,107,107,102,103,104,105,106,107,107,107,
        108,109,110,111,112,113,113,113,114,115,116,117,118,119,119,119,
        120,121,122,123,124,125,125,125,126,127,128,129,130,131,131,131,
        132,133,134,135,136,137,137,137,138,139,140,141,142,143,143,143,
        138,139,140,141,142,143,143,143,138,139,140,141,142,143,143,143,
        144,145,146,147,148,149,149,149,150,151,152,153,154,155,155,155,
        156,157,158,159,160,161,161,161,162,163,164,165,166,167,167,167,
        168,169,170,171,172,173,173,173,174,175,176,177,178,179,179,179,
        174,175,176,177,178,179,179,179,174,175,176,177,178,179,179,179,
        180,181,182,183,184,185,185,185,186,187,188,189,190,191,191,191,
        192,193,194,195,196,197,197,197,198,199,200,201,202,203,203,203,
        204,205,206,207,208,209,209,209,210,211,212,213,214,215
    };



CONST BYTE RGB666Xlate[SIZE_XLATE_666] = {

        235,234,233,232,231,230,230,230,229,228,227,226,225,224,224,224,
        223,222,221,220,219,218,218,218,217,216,215,214,213,212,212,212,
        211,210,209,208,207,206,206,206,205,204,203,202,201,200,200,200,
        205,204,203,202,201,200,200,200,205,204,203,202,201,200,200,200,
        199,198,197,196,195,194,194,194,193,192,191,190,189,188,188,188,
        187,186,185,184,183,182,182,182,181,180,179,178,177,176,176,176,
        175,174,173,172,171,170,170,170,169,168,167,166,165,164,164,164,
        169,168,167,166,165,164,164,164,169,168,167,166,165,164,164,164,
        163,162,161,160,159,158,158,158,157,156,155,154,153,152,152,152,
        151,150,149,148,147,146,146,146,145,144,143,142,141,140,140,140,
        139,138,137,136,135,134,134,134,133,132,131,130,129,128,128,128,
        133,132,131,130,129,128,128,128,133,132,131,130,129,128,128,128,
        127,126,125,124,123,122,122,122,121,120,119,118,117,116,116,116,
        115,114,113,112,111,110,110,110,109,108,107,106,105,104,104,104,
        103,102,101,100, 99, 98, 98, 98, 97, 96, 95, 94, 93, 92, 92, 92,
         97, 96, 95, 94, 93, 92, 92, 92, 97, 96, 95, 94, 93, 92, 92, 92,
         91, 90, 89, 88, 87, 86, 86, 86, 85, 84, 83, 82, 81, 80, 80, 80,
         79, 78, 77, 76, 75, 74, 74, 74, 73, 72, 71, 70, 69, 68, 68, 68,
         67, 66, 65, 64, 63, 62, 62, 62, 61, 60, 59, 58, 57, 56, 56, 56,
         61, 60, 59, 58, 57, 56, 56, 56, 61, 60, 59, 58, 57, 56, 56, 56,
         55, 54, 53, 52, 51, 50, 50, 50, 49, 48, 47, 46, 45, 44, 44, 44,
         43, 42, 41, 40, 39, 38, 38, 38, 37, 36, 35, 34, 33, 32, 32, 32,
         31, 30, 29, 28, 27, 26, 26, 26, 25, 24, 23, 22, 21, 20 
    };

CONST LPBYTE  p8BPPXlate[] = { (LPBYTE)CMY555Xlate,           // 00
                               (LPBYTE)CMY666Xlate,           // 01
                               (LPBYTE)RGB555Xlate,           // 10
                               (LPBYTE)RGB666Xlate };         // 11



CONST DWORD dwGrayIdxHB[] = {

    0x0ff010,0x0fe020,0x0fd030,0x0fc040,0x0fb050,0x0fa060,0x0f9070,0x0f8080,
    0x0f7090,0x0f60a0,0x0f50b0,0x0f40c0,0x0f30d0,0x0f20e0,0x0f10f0,0x0f0100,
    0x0ef110,0x0ee120,0x0ed130,0x0ec140,0x0eb150,0x0ea160,0x0e9170,0x0e8180,
    0x0e7190,0x0e61a0,0x0e51b0,0x0e41c0,0x0e31d0,0x0e21e0,0x0e11f0,0x0e0200,
    0x0df210,0x0de220,0x0dd230,0x0dc240,0x0db250,0x0da260,0x0d9270,0x0d8280,
    0x0d7290,0x0d62a0,0x0d52b0,0x0d42c0,0x0d32d0,0x0d22e0,0x0d12f0,0x0d0300,
    0x0cf310,0x0ce320,0x0cd330,0x0cc340,0x0cb350,0x0ca360,0x0c9370,0x0c8380,
    0x0c7390,0x0c63a0,0x0c53b0,0x0c43c0,0x0c33d0,0x0c23e0,0x0c13f0,0x0c0400,
    0x0bf410,0x0be420,0x0bd430,0x0bc440,0x0bb450,0x0ba460,0x0b9470,0x0b8480,
    0x0b7490,0x0b64a0,0x0b54b0,0x0b44c0,0x0b34d0,0x0b24e0,0x0b14f0,0x0b0500,
    0x0af510,0x0ae520,0x0ad530,0x0ac540,0x0ab550,0x0aa560,0x0a9570,0x0a8580,
    0x0a7590,0x0a65a0,0x0a55b0,0x0a45c0,0x0a35d0,0x0a25e0,0x0a15f0,0x0a0600,
    0x09f610,0x09e620,0x09d630,0x09c640,0x09b650,0x09a660,0x099670,0x098680,
    0x097690,0x0966a0,0x0956b0,0x0946c0,0x0936d0,0x0926e0,0x0916f0,0x090700,
    0x08f710,0x08e720,0x08d730,0x08c740,0x08b750,0x08a760,0x089770,0x088780,
    0x087790,0x0867a0,0x0857b0,0x0847c0,0x0837d0,0x0827e0,0x0817f0,0x080800,
    0x07f810,0x07e820,0x07d830,0x07c840,0x07b850,0x07a860,0x079870,0x078880,
    0x077890,0x0768a0,0x0758b0,0x0748c0,0x0738d0,0x0728e0,0x0718f0,0x070900,
    0x06f910,0x06e920,0x06d930,0x06c940,0x06b950,0x06a960,0x069970,0x068980,
    0x067990,0x0669a0,0x0659b0,0x0649c0,0x0639d0,0x0629e0,0x0619f0,0x060a00,
    0x05fa10,0x05ea20,0x05da30,0x05ca40,0x05ba50,0x05aa60,0x059a70,0x058a80,
    0x057a90,0x056aa0,0x055ab0,0x054ac0,0x053ad0,0x052ae0,0x051af0,0x050b00,
    0x04fb10,0x04eb20,0x04db30,0x04cb40,0x04bb50,0x04ab60,0x049b70,0x048b80,
    0x047b90,0x046ba0,0x045bb0,0x044bc0,0x043bd0,0x042be0,0x041bf0,0x040c00,
    0x03fc10,0x03ec20,0x03dc30,0x03cc40,0x03bc50,0x03ac60,0x039c70,0x038c80,
    0x037c90,0x036ca0,0x035cb0,0x034cc0,0x033cd0,0x032ce0,0x031cf0,0x030d00,
    0x02fd10,0x02ed20,0x02dd30,0x02cd40,0x02bd50,0x02ad60,0x029d70,0x028d80,
    0x027d90,0x026da0,0x025db0,0x024dc0,0x023dd0,0x022de0,0x021df0,0x020e00,
    0x01fe10,0x01ee20,0x01de30,0x01ce40,0x01be50,0x01ae60,0x019e70,0x018e80,
    0x017e90,0x016ea0,0x015eb0,0x014ec0,0x013ed0,0x012ee0,0x011ef0,0x010f00,
    0x00ff10,0x00ef20,0x00df30,0x00cf40,0x00bf50,0x00af60,0x009f70,0x008f80,
    0x007f90,0x006fa0,0x005fb0,0x004fc0,0x003fd0,0x002fe0,0x001ff0,0x001000 
    };

CONST WORD wGrayIdxLB[] = {

    0x0fef,0x0fdf,0x0fcf,0x0fbf,0x0faf,0x0f9f,0x0f8f,0x0f7f,
    0x0f6f,0x0f5f,0x0f4f,0x0f3f,0x0f2f,0x0f1f,0x0f0f,0x0eff,
    0x0eef,0x0edf,0x0ecf,0x0ebf,0x0eaf,0x0e9f,0x0e8f,0x0e7f,
    0x0e6f,0x0e5f,0x0e4f,0x0e3f,0x0e2f,0x0e1f,0x0e0f,0x0dff,
    0x0def,0x0ddf,0x0dcf,0x0dbf,0x0daf,0x0d9f,0x0d8f,0x0d7f,
    0x0d6f,0x0d5f,0x0d4f,0x0d3f,0x0d2f,0x0d1f,0x0d0f,0x0cff,
    0x0cef,0x0cdf,0x0ccf,0x0cbf,0x0caf,0x0c9f,0x0c8f,0x0c7f,
    0x0c6f,0x0c5f,0x0c4f,0x0c3f,0x0c2f,0x0c1f,0x0c0f,0x0bff,
    0x0bef,0x0bdf,0x0bcf,0x0bbf,0x0baf,0x0b9f,0x0b8f,0x0b7f,
    0x0b6f,0x0b5f,0x0b4f,0x0b3f,0x0b2f,0x0b1f,0x0b0f,0x0aff,
    0x0aef,0x0adf,0x0acf,0x0abf,0x0aaf,0x0a9f,0x0a8f,0x0a7f,
    0x0a6f,0x0a5f,0x0a4f,0x0a3f,0x0a2f,0x0a1f,0x0a0f,0x09ff,
    0x09ef,0x09df,0x09cf,0x09bf,0x09af,0x099f,0x098f,0x097f,
    0x096f,0x095f,0x094f,0x093f,0x092f,0x091f,0x090f,0x08ff,
    0x08ef,0x08df,0x08cf,0x08bf,0x08af,0x089f,0x088f,0x087f,
    0x086f,0x085f,0x084f,0x083f,0x082f,0x081f,0x080f,0x07ff,
    0x07f0,0x07e0,0x07d0,0x07c0,0x07b0,0x07a0,0x0790,0x0780,
    0x0770,0x0760,0x0750,0x0740,0x0730,0x0720,0x0710,0x0700,
    0x06f0,0x06e0,0x06d0,0x06c0,0x06b0,0x06a0,0x0690,0x0680,
    0x0670,0x0660,0x0650,0x0640,0x0630,0x0620,0x0610,0x0600,
    0x05f0,0x05e0,0x05d0,0x05c0,0x05b0,0x05a0,0x0590,0x0580,
    0x0570,0x0560,0x0550,0x0540,0x0530,0x0520,0x0510,0x0500,
    0x04f0,0x04e0,0x04d0,0x04c0,0x04b0,0x04a0,0x0490,0x0480,
    0x0470,0x0460,0x0450,0x0440,0x0430,0x0420,0x0410,0x0400,
    0x03f0,0x03e0,0x03d0,0x03c0,0x03b0,0x03a0,0x0390,0x0380,
    0x0370,0x0360,0x0350,0x0340,0x0330,0x0320,0x0310,0x0300,
    0x02f0,0x02e0,0x02d0,0x02c0,0x02b0,0x02a0,0x0290,0x0280,
    0x0270,0x0260,0x0250,0x0240,0x0230,0x0220,0x0210,0x0200,
    0x01f0,0x01e0,0x01d0,0x01c0,0x01b0,0x01a0,0x0190,0x0180,
    0x0170,0x0160,0x0150,0x0140,0x0130,0x0120,0x0110,0x0100,
    0x00f0,0x00e0,0x00d0,0x00c0,0x00b0,0x00a0,0x0090,0x0080,
    0x0070,0x0060,0x0050,0x0040,0x0030,0x0020,0x0010,0x0000
    };


extern CONST WORD GrayIdxWORD[];

#define GRAY_W2DW(l, h)         (dwGrayIdxHB[h] + (DWORD)wGrayIdxLB[l])

#define PBGRF_2_GRAYDW(pbgrf)   GRAY_W2DW((pbgrf)->b, (pbgrf)->g)



//
//**************************************************************************
// Monochrome 1BPP Output Functions
//**************************************************************************


VOID
HTENTRY
OutputAATo1BPP(
    PAAHEADER       pAAHdr,
    PGRAYF          pbgrf,
    PGRAYF          pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    UINT    Loop;
    DW2W4B  Dst;

#define XorMask (AAOutputInfo.bm.XorMask)


    if (Loop = (UINT)AAOutputInfo.bm.cFirst) {

        Dst.dw = 0;

        while (Loop--) {

            Dst.b[0] = (++pbgrf)->f;
            Dst.dw   = GRAY_1BPP_COPY(pbPat, 0x010000) | (Dst.dw << 1);

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }

        //
        // Dst.b[1] = Destination mask (1) for wanted bits
        // Dst.b[2] = Destination bits
        //
        // Shift left for LeftShift is in case that we only have 1 byte and
        // the last bit not at bit 0
        //

        Dst.b[0]   = 0;
        Dst.dw   <<= AAOutputInfo.bm.LSFirst;
        *pbDst++   = (*pbDst & ~Dst.b[1]) | ((Dst.b[2] ^ XorMask) & Dst.b[1]);
    }

    pbgrf -= 7;

    if (pAAHdr->Flags & AAHF_HAS_MASK) {

#if defined(_X86_)

        _asm {

                cld
                mov     ebx, pbgrf
                mov     esi, pbPat
                mov     edi, pbDst
                mov     ecx, pbPatEnd
                mov     ch, XorMask
BYTELoopMask:
                add     ebx, 32
                cmp     ebx, pInEnd
                jae     DoneLoopMask

                xor     ax, ax
                cmp     BYTE PTR [ebx + 3], 0
                jz      BIT1
                or      ah, 0x80
                mov     dx, WORD PTR [ebx + 0]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  0]
BIT1:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 4 + 3], 0
                jz      BIT2
                or      ah, 0x40
                mov     dx, WORD PTR [ebx + 4]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  6]
BIT2:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 8 + 3], 0
                jz      BIT3
                or      ah, 0x20
                mov     dx, WORD PTR [ebx + 8]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  12]
BIT3:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 12 + 3], 0
                jz      BIT4
                or      ah, 0x10
                mov     dx, WORD PTR [ebx + 12]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  18]
BIT4:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 16 + 3], 0
                jz      BIT5
                or      ah, 0x08
                mov     dx, WORD PTR [ebx + 16]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  24]
BIT5:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 20 + 3], 0
                jz      BIT6
                or      ah, 0x04
                mov     dx, WORD PTR [ebx + 20]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  30]
BIT6:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 24 + 3], 0
                jz      BIT7
                or      ah, 0x02
                mov     dx, WORD PTR [ebx + 24]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  36]
BIT7:
                rcl     al, 1
                cmp     BYTE PTR [ebx + 28 + 3], 0
                jz      BIT8
                or      ah, 0x01
                mov     dx, WORD PTR [ebx + 28]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  42]
BIT8:
                rcl     al, 1
                xor     al, ch                      ;; do xor mask
                and     al, ah                      ;; mask out src 0 bits
                not     ah                          ;; invert
                and     BYTE PTR [edi], ah          ;; mask out dst 0 bits
                or      BYTE PTR [edi], al
                inc     edi
                add     esi, 48
                cmp     esi, pbPatEnd
                jb      BYTELoopMask
                add     esi, cbWrapBGR
                jmp     BYTELoopMask
DoneLoopMask:
                mov     pbgrf, ebx
                mov     pbPat, esi
                mov     pbDst, edi
        }
#else
        while ((pbgrf += 8) < pInEnd) {

            Dst.b[0] = GET_1BPP_MASK_BYTE(pbgrf);
            *pbDst++ = (*pbDst & ~Dst.b[0]) |
                       ((GRAY_1BPP_COPY_BYTE(pbPat) ^ XorMask) & Dst.b[0]);

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, (SIZE_PER_PAT * 8), cbWrapBGR);
        }
#endif

    } else {

#if defined(_X86_)

        _asm {

                cld
                mov     ebx, pbgrf
                mov     esi, pbPat
                mov     edi, pbDst
                mov     ecx, pbPatEnd
                mov     ah, XorMask
BYTELoop:
                add     ebx, 32
                cmp     ebx, pInEnd
                jae     DoneLoop

                xor     al, al
                mov     dx, WORD PTR [ebx + 0]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  0]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 4]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  6]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 8]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  12]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 12]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  18]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 16]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  24]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 20]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  30]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 24]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  36]
                rcl     al, 1

                mov     dx, WORD PTR [ebx + 28]
                not     dx
                shr     dx, 4
                cmp     dx, WORD PTR [esi + 2 +  42]
                rcl     al, 1

                xor     al, ah
                stosb
                add     esi, 48
                cmp     esi, ecx
                jb      BYTELoop
                add     esi, cbWrapBGR
                jmp     BYTELoop
DoneLoop:
                mov     pbgrf, ebx
                mov     pbPat, esi
                mov     pbDst, edi
        }
#else
        while ((pbgrf += 8) < pInEnd) {

            *pbDst++ = GRAY_1BPP_COPY_BYTE(pbPat) ^ XorMask;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, (SIZE_PER_PAT * 8), cbWrapBGR);
        }
#endif
    }

    if (Loop = (UINT)AAOutputInfo.bm.cLast) {

        Dst.dw                 = 0;
        AAOutputInfo.bm.LSFirst = (BYTE)(8 - Loop);

        while (Loop--) {

            Dst.b[0] = pbgrf->f;
            Dst.dw   = GRAY_1BPP_COPY(pbPat, 0x010000) | (Dst.dw << 1);

            ++pbgrf;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }

        //
        // Dst.b[1] = Destination mask (1) for wanted bits
        // Dst.b[2] = Destination bits
        //
        // Shift left for (LeftShift) is for the last un-make bits
        //

        Dst.b[0]   = 0;
        Dst.dw   <<= AAOutputInfo.bm.LSFirst;
        *pbDst     = (*pbDst & ~Dst.b[1]) | ((Dst.b[2] ^ XorMask) & Dst.b[1]);
    }

#undef XorMask
}


//
//**************************************************************************
// Standard 4BPP (RGB/CMY) Output Functions
//**************************************************************************


VOID
HTENTRY
OutputAATo4BPP(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DW2W4B  dw4b;
    DEF_COPY_LUTAAHDR;


    dw4b.dw = 0;

    if (AAOutputInfo.bm.XorMask) {

        dw4b.dw = 0x77700777;
    }

    if (AAOutputInfo.bm.cFirst) {

        if (PBGRF_HAS_MASK(++pbgrf)) {

            GET_4BPP_CLR_COPY_LIDX(pbDst, pbPat, pbgrf, dw4b.b[1]);
        }

        ++pbDst;

        PPAT_NEXT(pbPat, pbPatEnd, cbWrapBGR);
    }

    --pbgrf;

    if (pAAHdr->Flags & AAHF_HAS_MASK) {

        while ((pbgrf += 2) < pInEnd) {

            switch (((pbgrf->f) & 0x02) | ((pbgrf + 1)->f & 0x01)) {

            case 0:

                break;

            case 1:

                GET_4BPP_CLR_COPY_LIDX(pbDst, pbPat, pbgrf + 1, dw4b.b[1]);
                break;

            case 2:

                GET_4BPP_CLR_COPY_HIDX(pbDst, pbPat, pbgrf, dw4b.b[2]);
                break;

            case 3:
            default:

                GET_4BPP_CLR_COPY_BYTE(pbDst, pbPat, dw4b.b[0]);
                break;
            }

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR);
        }

    } else {

        while ((pbgrf += 2) < pInEnd) {

            GET_4BPP_CLR_COPY_BYTE(pbDst++, pbPat, dw4b.b[0]);

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR);
        }
    }

    if ((AAOutputInfo.bm.cLast) && (PBGRF_HAS_MASK(pbgrf))) {

        GET_4BPP_CLR_COPY_HIDX(pbDst, pbPat, pbgrf, dw4b.b[2]);
    }
}

//
//**************************************************************************
// VGA16 4BPP Output Functions
//**************************************************************************


VOID
HTENTRY
OutputAAToVGA16(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    LPDWORD         pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DW2W4B  dw4b;
    DEF_COPY_LUTAAHDR;


    dw4b.dw = 0;

    if (AAOutputInfo.bm.cFirst) {

        if (PBGRF_HAS_MASK(++pbgrf)) {

            GET_VGA16_CLR_COPY_LIDX(pbDst, pbPat, pbgrf, 0x07);
        }

        ++pbDst;

        PPAT_NEXT(pbPat, pbPatEnd, cbWrapBGR);
    }

    --pbgrf;

    if (pAAHdr->Flags & AAHF_HAS_MASK) {

        while ((pbgrf += 2) < pInEnd) {

            switch (((pbgrf->f) & 0x02) | ((pbgrf + 1)->f & 0x01)) {

            case 0:

                break;

            case 1:

                GET_VGA16_CLR_COPY_LIDX(pbDst, pbPat, pbgrf + 1, 0x07);
                break;

            case 2:

                GET_VGA16_CLR_COPY_HIDX(pbDst, pbPat, pbgrf, 0x70);
                break;

            case 3:
            default:

                GET_VGA16_CLR_COPY_BYTE(pbDst, pbPat, 0x77);
                break;
            }

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR);
        }

    } else {

        while ((pbgrf += 2) < pInEnd) {

            GET_VGA16_CLR_COPY_BYTE(pbDst++, pbPat, 0x77);

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR);
        }
    }

    if ((AAOutputInfo.bm.cLast) && (PBGRF_HAS_MASK(pbgrf))) {

        GET_VGA16_CLR_COPY_HIDX(pbDst, pbPat, pbgrf, 0x70);
    }
}


//
//**************************************************************************
// VGA 256 8BPP Output Functions
//**************************************************************************



LPBYTE
HTENTRY
BuildVGA256Xlate(
    LPBYTE  pXlate,
    LPBYTE  pNewXlate
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-May-1998 Wed 14:02:56 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    if (pXlate) {

        UINT    i;
        LPBYTE  pVGA256Xlate;
        LPBYTE  pRet;

        ASSERTMSG("Has pXlate8BPP but buffer is NULL", pNewXlate);

        DBGP_IF(DBGP_VGA256XLATE, DBGP("Build New Xlate 256"));

        if (pRet = pNewXlate) {

            pVGA256Xlate = (LPBYTE)VGA256Xlate;
            i            = sizeof(VGA256Xlate);

            while (i--) {

                DBGP_IF(DBGP_VGA256XLATE,
                        DBGP("Xlate8BPP (%3ld) ---> %3ld --> %3ld"
                            ARGDW(i) ARGDW(pXlate[i])
                            ARGDW(pXlate[*pVGA256Xlate])));

                *pNewXlate++ = pXlate[*pVGA256Xlate++];
            }
        }

        return(pRet);

    } else {

        ASSERTMSG("No pXlate8BPP but buffer is Not NULL", pNewXlate==NULL);
        DBGP_IF(DBGP_VGA256XLATE, DBGP("Use Default VGA256Xlate"));

        return((LPBYTE)VGA256Xlate);
    }
}



VOID
HTENTRY
OutputAAToVGA256(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    if (pAAHdr->Flags & AAHF_HAS_MASK) {

        while (++pbgrf < pInEnd) {

            if (PBGRF_HAS_MASK(pbgrf)) {

                *pbDst = GET_VGA256_CLR_COPY_XLATE(pbPat,
                                                   AAOutputInfo.pXlate8BPP);
            }

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }

    } else {

        while (++pbgrf < pInEnd) {

            *pbDst++ = GET_VGA256_CLR_COPY_XLATE(pbPat,
                                                 AAOutputInfo.pXlate8BPP);
            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }
    }
}


//
//**************************************************************************
// Mask 8BPP Output Functions
//**************************************************************************

#define bm8i    (*(PBM8BPPINFO)&ExtBGR[3])


VOID
HTENTRY
OutputAATo8BPP_B332(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP(pbDst,
                         pbPat,
                         _GET_MASK8BPP_332,
                         NULL);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }
}



VOID
HTENTRY
OutputAATo8BPP_K_B332(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP_REP_K(pbDst,
                               pbPat,
                               _GET_MASK8BPP_K_332,
                               NULL);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }

}



VOID
HTENTRY
OutputAATo8BPP_B332_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP(pbDst,
                         pbPat,
                         _GET_MASK8BPP_332_XLATE,
                         AAOutputInfo.pXlate8BPP);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }
}



VOID
HTENTRY
OutputAATo8BPP_K_B332_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP_REP_K(pbDst,
                               pbPat,
                               _GET_MASK8BPP_K_332_XLATE,
                               AAOutputInfo.pXlate8BPP);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }

}



VOID
HTENTRY
OutputAATo8BPP_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP(pbDst,
                         pbPat,
                         _GET_MASK8BPP_XLATE,
                         AAOutputInfo.pXlate8BPP);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }
}



VOID
HTENTRY
OutputAATo8BPP_K_XLATE(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;


    while (++pbgrf < pInEnd) {

        if (PBGRF_HAS_MASK(pbgrf)) {

            GET_MASK8BPP_REP_K(pbDst,
                               pbPat,
                               _GET_MASK8BPP_K_XLATE,
                               AAOutputInfo.pXlate8BPP);
        }

        ++pbDst;

        PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
    }
}

#undef bm8i



VOID
HTENTRY
OutputAATo8BPP_MONO(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    if (pAAHdr->Flags & AAHF_HAS_MASK) {

        while (++pbgrf < pInEnd) {

            if (PBGRF_HAS_MASK(pbgrf)) {

                GET_MASK8BPP_MONO(pbDst,
                                  pbPat,
                                  PBGRF_2_GRAYDW(pbgrf),
                                  AAOutputInfo.bm.XorMask);
            }

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }

    } else {

        while (++pbgrf < pInEnd) {

            GET_MASK8BPP_MONO(pbDst,
                              pbPat,
                              PBGRF_2_GRAYDW(pbgrf),
                              AAOutputInfo.bm.XorMask);

            ++pbDst;

            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);
        }
    }
}



//
//**************************************************************************
// 16BPP_555/16BPP_565 Output Functions
//**************************************************************************


#define OUTPUTAATO16BPP_MASK(BM, GM, RM, XorM)                              \
{                                                                           \
    if (AAOutputInfo.bm.cFirst) {                                           \
                                                                            \
        if (PBGRF_HAS_MASK(++pbgrf)) {                                      \
                                                                            \
            *pwDst = GET_16BPP_COPY_W_MASK(pbPat, BM, GM, RM, XorM);        \
        }                                                                   \
                                                                            \
        ++pwDst;                                                            \
                                                                            \
        PPAT_NEXT(pbPat, pbPatEnd, cbWrapBGR);                              \
    }                                                                       \
                                                                            \
    if (pAAHdr->Flags & AAHF_HAS_MASK) {                                    \
                                                                            \
        while (++pbgrf < pInEnd) {                                          \
                                                                            \
            if (PBGRF_HAS_MASK(pbgrf)) {                                    \
                                                                            \
                *pwDst = GET_16BPP_COPY_W_MASK(pbPat, BM, GM, RM, XorM);    \
            }                                                               \
                                                                            \
            ++pwDst;                                                        \
                                                                            \
            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT, cbWrapBGR);   \
        }                                                                   \
                                                                            \
    } else {                                                                \
                                                                            \
        --pbgrf;                                                            \
                                                                            \
        while ((pbgrf += 2) < pInEnd) {                                     \
                                                                            \
            *((LPDWORD)pwDst)++ = GET_16BPP_COPY_DW_MASK(pbPat,             \
                                                         BM,                \
                                                         GM,                \
                                                         RM,                \
                                                         XorM);             \
                                                                            \
            PPAT_NEXT_CONTINUE(pbPat, pbPatEnd, SIZE_PER_PAT*2, cbWrapBGR); \
        }                                                                   \
    }                                                                       \
                                                                            \
    if ((AAOutputInfo.bm.cLast) && (PBGRF_HAS_MASK(pbgrf))) {               \
                                                                            \
        *pwDst = GET_16BPP_COPY_W_MASK(pbPat, BM, GM, RM, XorM);            \
    }                                                                       \
}


VOID
HTENTRY
OutputAATo16BPP_ExtBGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    DEF_COPY_LUTAAHDR;

    OUTPUTAATO16BPP_MASK(ExtBGR[0], ExtBGR[1], ExtBGR[2], ExtBGR[3]);
}



VOID
HTENTRY
OutputAATo16BPP_555_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO16BPP_MASK(0x001F0000, 0x03e00000, 0x7c000000, 0x7FFF7FFF);
}



VOID
HTENTRY
OutputAATo16BPP_555_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO16BPP_MASK(0x7c000000, 0x03e00000, 0x001F0000, 0x7FFF7FFF);
}




VOID
HTENTRY
OutputAATo16BPP_565_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO16BPP_MASK(0x001F0000, 0x07e00000, 0xF8000000, 0xFFFFFFFF);
}




VOID
HTENTRY
OutputAATo16BPP_565_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPWORD          pwDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO16BPP_MASK(0xF8000000, 0x07e00000, 0x001F0000, 0xFFFFFFFF);
}

//
//**************************************************************************
// 24BPP/32 Output Functions
//**************************************************************************


#define OUTPUTAATO24_32BPP(iR, iG, iB, cbNext)                              \
{                                                                           \
    if (pAAHdr->Flags & AAHF_HAS_MASK) {                                    \
                                                                            \
        while (++pbgrf < pInEnd) {                                          \
                                                                            \
            if (PBGRF_HAS_MASK(pbgrf)) {                                    \
                                                                            \
                pbDst[iR] = ~(BYTE)_GET_R_CLR(pbgrf);                       \
                pbDst[iG] = ~(BYTE)_GET_G_CLR(pbgrf);                       \
                pbDst[iB] = ~(BYTE)_GET_B_CLR(pbgrf);                       \
            }                                                               \
                                                                            \
            pbDst += cbNext;                                                \
        }                                                                   \
                                                                            \
    } else {                                                                \
                                                                            \
        while (++pbgrf < pInEnd) {                                          \
                                                                            \
            pbDst[iR]  = ~(BYTE)_GET_R_CLR(pbgrf);                          \
            pbDst[iG]  = ~(BYTE)_GET_G_CLR(pbgrf);                          \
            pbDst[iB]  = ~(BYTE)_GET_B_CLR(pbgrf);                          \
            pbDst     += cbNext;                                            \
        }                                                                   \
    }                                                                       \
}



VOID
HTENTRY
OutputAATo24BPP_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{

    OUTPUTAATO24_32BPP(2, 1, 0, 3);
}



VOID
HTENTRY
OutputAATo24BPP_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO24_32BPP(0, 1, 2, 3);
}


VOID
HTENTRY
OutputAATo24BPP_ORDER(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    UINT    iR;
    UINT    iG;
    UINT    iB;

    iR = (UINT)AAOutputInfo.bgri.iR;
    iG = (UINT)AAOutputInfo.bgri.iG;
    iB = (UINT)AAOutputInfo.bgri.iB;


    OUTPUTAATO24_32BPP(iR, iG, iB, 3);
}



VOID
HTENTRY
OutputAATo32BPP_RGB(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{

    OUTPUTAATO24_32BPP(2, 1, 0, 4);
}



VOID
HTENTRY
OutputAATo32BPP_BGR(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    OUTPUTAATO24_32BPP(0, 1, 2, 4);
}


VOID
HTENTRY
OutputAATo32BPP_ORDER(
    PAAHEADER       pAAHdr,
    PBGRF           pbgrf,
    PBGRF           pInEnd,
    LPBYTE          pbDst,
    PLONG           pIdxBGR,
    LPBYTE          pbPat,
    LPBYTE          pbPatEnd,
    LONG            cbWrapBGR,
    AAOUTPUTINFO    AAOutputInfo
    )
{
    UINT    iR;
    UINT    iG;
    UINT    iB;

    iR = (UINT)AAOutputInfo.bgri.iR;
    iG = (UINT)AAOutputInfo.bgri.iG;
    iB = (UINT)AAOutputInfo.bgri.iB;


    OUTPUTAATO24_32BPP(iR, iG, iB, 4);
}


//
//****************************************************************************
// BRUSH Generation FUNCTION
//****************************************************************************
//



LONG
HTENTRY
CreateHalftoneBrushPat(
    PDEVICECOLORINFO    pDCI,
    PCOLORTRIAD         pColorTriad,
    PDEVCLRADJ          pDevClrAdj,
    LPBYTE              pDest,
    LONG                cbDestNext
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    26-Feb-1997 Wed 13:23:52 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE          pPat;
    LPBYTE          pB;
    PLONG           pIdxBGR;
    LPBYTE          pXlate8BPP;
    AAPATINFO       AAPI;
    DW2W4B          dw4b;
    DWORD           dwB;
    DWORD           dwG;
    DWORD           dwR;
    DWORD           DCAFlags;
    LONG            Result;
    BGR8            bgr;
    UINT            cCX;
    UINT            cCY;
    UINT            Count;
    UINT            uTmp;
    BYTE            XorMask;
    BYTE            DestFormat;

    _DEF_LUTAAHDR;

#define pW      ((LPWORD)pB)
#define pDW     ((LPDWORD)pB)
#define bm8i    (*(PBM8BPPINFO)&ExtBGR[3])

    //
    // Compute the rgbLUTAA then compute the BGR
    //

    ComputeRGBLUTAA(pDCI, pDevClrAdj, &(pDCI->rgbLUTPat));

    Result = INTERR_INVALID_DEVRGB_SIZE;

    if ((ComputeBGRMappingTable(pDCI, pDevClrAdj, pColorTriad, &bgr) != 1) ||
        ((Result = CachedHalftonePattern(pDCI,
                                         pDevClrAdj,
                                         &AAPI,
                                         0,
                                         0,
                                         FALSE)) <= 0)) {


        //-------------------------------------------------------------
        // Release the semaphore and return error
        //-------------------------------------------------------------

        RELEASE_HTMUTEX(pDCI->HTMutex);
        return(Result);
    }

    //
    // Copy down the ExtBGR and release the semaphore now
    //

    cCX     = (UINT)pDCI->HTCell.cxReal;
    cCY     = (UINT)pDCI->HTCell.Height;
    pIdxBGR = pDCI->rgbLUTPat.IdxBGR;

    //
    // Copy down the necessary infomation
    //

    GET_LUTAAHDR(ExtBGR, pIdxBGR);

    DestFormat = pDevClrAdj->DMI.CTSTDInfo.BMFDest;

    if ((DCAFlags = pDevClrAdj->PrimAdj.Flags) & DCA_XLATE_555_666) {

        GET_P8BPPXLATE(pXlate8BPP, bm8i);
    }

    if (DCAFlags & DCA_XLATE_332) {

        pXlate8BPP = pDCI->CMY8BPPMask.bXlate;
    }

    dwB = _GET_B_CLR(&bgr);
    dwG = _GET_G_CLR(&bgr);
    dwR = _GET_R_CLR(&bgr);

    //----------------------------------------------------------------------
    // Release Semaphore now before we compose the pattern brush
    //----------------------------------------------------------------------

    RELEASE_HTMUTEX(pDCI->HTMutex);

    DBGP_IF(DBGP_BRUSH,
            DBGP("DstOrder=%ld [%ld:%ld:%ld], bgr=%08lx:%08lx:%08lx, ExtBGR=%08lx:%08lx:%08lx %08lx:%08lx:%08lx"
                ARGDW(AAPI.DstOrder.Index)
                ARGDW(AAPI.DstOrder.Order[0])
                ARGDW(AAPI.DstOrder.Order[1])
                ARGDW(AAPI.DstOrder.Order[2])
                ARGDW(dwB) ARGDW(dwG) ARGDW(dwR)
                ARGDW(ExtBGR[0]) ARGDW(ExtBGR[1]) ARGDW(ExtBGR[2])
                ARGDW(ExtBGR[3]) ARGDW(ExtBGR[4]) ARGDW(ExtBGR[5])));

    switch (DestFormat = pDevClrAdj->DMI.CTSTDInfo.BMFDest) {

    case BMF_1BPP:

        //
        // Use only Green/Magenta Pattern
        //

        dwB     = ((dwR + dwG + dwB) ^ GRAY_MAX_IDX) >> 4;
        XorMask = (DCAFlags & DCA_USE_ADDITIVE_PRIMS) ? 0x00 : 0xFF;

#if defined(_X86_)

        _asm {
                mov     esi, AAPI.pbPatBGR
                mov     edi, pDest
                cld
                mov     edx, dwB
                mov     ah, XorMask
CYLoop:
                push    esi
                push    edi
                mov     ebx, cCX
                mov     ecx, ebx
                shr     ecx, 3
                jz      DoBIT
BYTELoop:
                xor     al, al
                cmp     dx, WORD PTR [esi + 2 +  0]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 +  6]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 12]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 18]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 24]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 30]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 36]
                rcl     al, 1
                cmp     dx, WORD PTR [esi + 2 + 42]
                rcl     al, 1
                xor     al, ah
                stosb
                add     esi, 48
                dec     ecx
                jnz     BYTELoop
DoBIT:
                and     ebx, 7
                jz      DoneLoop
                mov     ecx, 8
                sub     ecx, ebx
                xor     al, al
BITLoop:
                cmp     dx, WORD PTR [esi + 2]
                rcl     al, 1
                add     esi, 6
                dec     ebx
                jnz     BITLoop
                xor     al, ah
                shl     al, cl
                stosb
DoneLoop:
                pop     edi
                pop     esi
                add     esi, AAPI.cyNextBGR
                add     edi, cbDestNext
                dec     cCY
                jnz     CYLoop
        }
#else
        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX >> 3;

            while (Count--) {

                *pB++ = (BYTE)((((dwB - GETMONOPAT(pPat, 0)) & 0x800000) |
                                ((dwB - GETMONOPAT(pPat, 1)) & 0x400000) |
                                ((dwB - GETMONOPAT(pPat, 2)) & 0x200000) |
                                ((dwB - GETMONOPAT(pPat, 3)) & 0x100000) |
                                ((dwB - GETMONOPAT(pPat, 4)) & 0x080000) |
                                ((dwB - GETMONOPAT(pPat, 5)) & 0x040000) |
                                ((dwB - GETMONOPAT(pPat, 6)) & 0x020000) |
                                ((dwB - GETMONOPAT(pPat, 7)) & 0x010000))
                               >> 16) ^ XorMask;

                INC_PPAT(pPat, 8);
            }

            if (Count = cCX & 0x07) {

                dw4b.dw = 0;
                uTmp    = 8 - Count;

                while (Count--) {

                    dw4b.dw = ((dwB - GETMONOPAT(pPat, 0)) & 0x10000) |
                              (dw4b.dw << 1);

                    INC_PPAT(pPat, 1);
                }

                dw4b.b[2]  ^= XorMask;
                dw4b.dw   <<= uTmp;
                *pB         = dw4b.b[2];
            }
        }
#endif

        break;

    case BMF_4BPP:

        XorMask = (DCAFlags & DCA_USE_ADDITIVE_PRIMS) ? 0x00 : 0x77;

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX >> 1;

            while (Count--) {

                *pB++ = _GET_4BPP_CLR_COPY_BYTE(pPat,
                                                dwB, dwG, dwR, dwB, dwG, dwR,
                                                XorMask);
                INC_PPAT(pPat, 2);
            }

            if (cCX & 0x01) {

                *pB = _GET_4BPP_CLR_COPY_NIBBLE(pPat, dwB, dwG, dwR,
                                                0, 1, 2, XorMask);
            }
        }

        break;

    case BMF_4BPP_VGA16:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX >> 1;

            while (Count--) {

                *pB++ = _GET_VGA16_CLR_COPY_BYTE(pPat,
                                                 dwB, dwG, dwR, dwB, dwG, dwR,
                                                 0x77);
                INC_PPAT(pPat, 2);
            }

            if (cCX & 0x01) {

                *pB = _GET_VGA16_CLR_COPY_NIBBLE(pPat, dwB, dwG, dwR,
                                                 0, 1, 2, 0x70);
            }
        }

        break;

    case BMF_8BPP_MONO:

        dw4b.dw = dwB + dwR + dwG;
        dwB     = GRAY_W2DW(dw4b.b[0], dw4b.b[1]);

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX;

            while (Count--) {

                GET_MASK8BPP_MONO(pB, pPat, dwB, bm8i.Data.bXor);

                ++pB;

                INC_PPAT(pPat, 1);
            }
        }

        break;

    case BMF_8BPP_B332:

        if (DCAFlags & DCA_XLATE_332) {

            while (cCY--) {

                pPat           = AAPI.pbPatBGR;
                AAPI.pbPatBGR += AAPI.cyNextBGR;
                pB             = pDest;
                pDest         += cbDestNext;
                Count          = cCX;

                while (Count--) {

                    _GET_MASK8BPP_332_XLATE(pB, pPat, dwB,dwG,dwR, pXlate8BPP);

                    ++pB;

                    INC_PPAT(pPat, 1);
                }
            }

        } else {

            while (cCY--) {

                pPat           = AAPI.pbPatBGR;
                AAPI.pbPatBGR += AAPI.cyNextBGR;
                pB             = pDest;
                pDest         += cbDestNext;
                Count          = cCX;

                while (Count--) {

                    _GET_MASK8BPP_332(pB, pPat, dwB, dwG, dwR, NULL);

                    ++pB;

                    INC_PPAT(pPat, 1);
                }
            }
        }

        break;

    case BMF_8BPP_K_B332:

        if (DCAFlags & DCA_XLATE_332) {

            while (cCY--) {

                pPat           = AAPI.pbPatBGR;
                AAPI.pbPatBGR += AAPI.cyNextBGR;
                pB             = pDest;
                pDest         += cbDestNext;
                Count          = cCX;

                while (Count--) {

                    _GET_MASK8BPP_REP_K(pB,
                                        pPat,
                                        dwB,
                                        dwG,
                                        dwR,
                                        _GET_MASK8BPP_K_332_XLATE,
                                        pXlate8BPP);

                    ++pB;

                    INC_PPAT(pPat, 1);
                }
            }

        } else {

            while (cCY--) {

                pPat           = AAPI.pbPatBGR;
                AAPI.pbPatBGR += AAPI.cyNextBGR;
                pB             = pDest;
                pDest         += cbDestNext;
                Count          = cCX;

                while (Count--) {

                    _GET_MASK8BPP_REP_K(pB,
                                        pPat,
                                        dwB,
                                        dwG,
                                        dwR,
                                        _GET_MASK8BPP_K_332,
                                        NULL);

                    ++pB;

                    INC_PPAT(pPat, 1);
                }
            }
        }

        break;

    case BMF_8BPP_L555:
    case BMF_8BPP_L666:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX;

            while (Count--) {

                _GET_MASK8BPP_XLATE(pB, pPat, dwB, dwG, dwR, pXlate8BPP);

                ++pB;

                INC_PPAT(pPat, 1);
            }
        }

        break;

    case BMF_8BPP_K_L555:
    case BMF_8BPP_K_L666:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX;

            while (Count--) {

                _GET_MASK8BPP_REP_K(pB,
                                    pPat,
                                    dwB,
                                    dwG,
                                    dwR,
                                    _GET_MASK8BPP_K_XLATE,
                                    pXlate8BPP);

                ++pB;

                INC_PPAT(pPat, 1);
            }
        }

        break;

    case BMF_8BPP_VGA256:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pB             = pDest;
            pDest         += cbDestNext;
            Count          = cCX;

            while (Count--) {

                *pB++ = _GET_VGA256_CLR_COPY_XLATE(pPat,
                                                   VGA256Xlate,
                                                   dwB,
                                                   dwG,
                                                   dwR);

                INC_PPAT(pPat, 1);
            }
        }

        break;

    case BMF_16BPP_555:
    case BMF_16BPP_565:

        while (cCY--) {

            pPat           = AAPI.pbPatBGR;
            AAPI.pbPatBGR += AAPI.cyNextBGR;
            pDW            = (LPDWORD)pDest;
            pDest         += cbDestNext;
            Count          = cCX >> 1;

            while (Count--) {

                *pDW++ = _GET_16BPP_COPY_DW_MASK(pPat,
                                                 dwB, dwG, dwR,
                                                 dwB, dwG, dwR,
                                                 ExtBGR[0],
                                                 ExtBGR[1],
                                                 ExtBGR[2],
                                                 ExtBGR[3]);

                INC_PPAT(pPat, 2);
            }

            if (cCX & 0x01) {

                *pW = _GET_16BPP_COPY_W_MASK(pPat,
                                             dwB, dwG, dwR,
                                             ExtBGR[0],
                                             ExtBGR[1],
                                             ExtBGR[2],
                                             ExtBGR[3]);
            }
        }

        break;

    case BMF_24BPP:
    case BMF_32BPP:

        pB                         = pDest;
        pB[AAPI.DstOrder.Order[0]] = ~(BYTE)dwR;
        pB[AAPI.DstOrder.Order[1]] = ~(BYTE)dwG;
        pB[AAPI.DstOrder.Order[2]] = ~(BYTE)dwB;

        if (DestFormat == BMF_24BPP) {

            dwB = 3;
            dwG = (cCX << 1) + cCX;

        } else {

            dwB   = 4;
            dwG   = (cCX << 2);
            pB[3] = 0;

        }

        pB    += (uTmp = dwB);
        Count  = dwG;

        while (Count -= uTmp) {

            if ((uTmp = dwB) > Count) {

                uTmp = Count;
            }

            CopyMemory(pB, pDest, uTmp);

            pB  += uTmp;
            dwB += uTmp;
        }

        //
        // Now copy down the remaining scanlines from first scanline
        //

        pB = pDest;

        while (--cCY) {

            CopyMemory(pDest += cbDestNext, pB, dwG);
        }

        break;

    default:

        return(HTERR_INVALID_DEST_FORMAT);
    }

    return(Result);


#undef  bm8i
#undef  pW
#undef  pDW
}


#if DBG


LPSTR
GetAAOutputFuncName(
    AAOUTPUTFUNC    AAOutputFunc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    06-Jan-1999 Wed 19:11:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo1BPP) {

        return("OutputAATo1BPP");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo4BPP) {

        return("OutputAATo4BPP");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAAToVGA16) {

        return("OutputAAToVGA16");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAAToVGA256) {

        return("OutputAAToVGA256");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_B332) {

        return("OutputAATo8BPP_B332");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_B332_XLATE) {

        return("OutputAATo8BPP_B332_XLATE");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_XLATE) {

        return("OutputAATo8BPP_XLATE");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_K_XLATE) {

        return("OutputAATo8BPP_K_XLATE");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_K_B332) {

        return("OutputAATo8BPP_K_B332");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_K_B332_XLATE) {

        return("OutputAATo8BPP_K_B332_XLATE");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo8BPP_MONO) {

        return("OutputAATo8BPP_MONO");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_ExtBGR) {

        return("OutputAATo16BPP_ExtBGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_555_RGB) {

        return("OutputAATo16BPP_555_RGB");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_555_BGR) {

        return("OutputAATo16BPP_555_BGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_565_RGB) {

        return("OutputAATo16BPP_565_RGB");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo16BPP_565_BGR) {

        return("OutputAATo16BPP_565_BGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo24BPP_RGB) {

        return("OutputAATo24BPP_RGB");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo24BPP_BGR) {

        return("OutputAATo24BPP_BGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo24BPP_ORDER) {

        return("OutputAATo24BPP_ORDER");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo32BPP_RGB) {

        return("OutputAATo32BPP_RGB");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo32BPP_BGR) {

        return("OutputAATo32BPP_BGR");

    } else if (AAOutputFunc == (AAOUTPUTFUNC)OutputAATo32BPP_ORDER) {

        return("OutputAATo32BPP_ORDER");

    } else {

        return("ERROR: Unknow Function");
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\i386\htrbmp.asm ===
PAGE 60, 132
    TITLE   Reading 1/4/8/16/24/32 bits per pel bitmap

COMMENT `


Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htrbmp.asm


Abstract:

    This module provided a set of functions which read the 1/4/8/16/24/32
    bits per pel bitmap and composed it into the PRIMMONO_COUNT or
    PRIMCOLOR_COUNT data structure array

    This function is the equivelant codes in the htgetbmp.c


Author:
    23-Apr-1992 Thu 20:51:24 updated  -by-  Daniel Chou (danielc)
        1. Remove IFIF_MASK_SHIFT_MASK and replaced it with BMF1BPP1stShift
        2. Delete IFI_StretchSize
        3. Change IFI_ColorInfoIncrement from 'CHAR' to 'SHORT'


    05-Apr-1991 Fri 15:55:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:
        28-Mar-1992 Sat 21:07:45 updated  -by-  Daniel Chou (danielc)
            Rewrite all 1/4/8/16/24/32 to PrimMono/PrimColor input functions
            using macro so only one version of source need to be maintained.


        16-Jan-1992 Thu 21:29:34 updated  -by-  Daniel Chou (danielc)

            1) Fixed typo on macro PrimColor24_32BPP, it should be
               BPTR_ES[_DI] not BPTR_ES[DI]

            2) Fixed BMF1BPPToPrimColor's BSXEAX to BSXE cl

               VCInitSrcRead:  BSXEAX cl -> BSXE cl

            3) Fixed BMF4BPPToPrimColor's codes which destroy AL on second
               run.



`


        .XLIST
        INCLUDE i386\i80x86.inc
        .LIST


IF  HT_ASM_80x86


;------------------------------------------------------------------------------
        .XLIST
        INCLUDE i386\htp.inc
        .LIST
;------------------------------------------------------------------------------

        .CODE


SUBTTL  CopyAndOrTwoByteArray
PAGE

COMMENT `

Routine Description:

    This function take source/destination bytes array and apply Copy/Or/And
    functions to these byte arrays and store the result in the pDest byte
    array.

Arguments:

    pDest       - Pointer to the destination byte array

    pSource     - Pointer to the source byte array

    CAOTBAInfo  - CAOTBAINFO data structure which specified size and operation
                  for the source/destination

Return Value:

    No return value

Author:

    18-Mar-1991 Mon 13:48:51 created  -by-  Daniel Chou (danielc)


Revision History:

`

@BEG_PROC   CopyAndOrTwoByteArray   <pDest:DWORD,       \
                                     pSource:DWORD,     \
                                     CAOTBAInfo:DWORD>

                @ENTER  _DS _SI _DI             ; Save environment registers

                LDS_SI  pSource
                LES_DI  pDest

                mov     _DX, 2
                MOVZX_W _CX, CAOTBAInfo.CAOTBA_BytesCount
                mov     ax, CAOTBAInfo.CAOTBA_Flags
                test    ax, CAOTBAF_COPY
                jnz     short DoCopy

;============================================================================
; MERGE COPY:
;============================================================================

DoMergeCopy:    test    ax, CAOTBAF_INVERT      ; need invert?
                jz      short DoOrCopy

;==============================================================================
; NOT OR the source to the destination
;==============================================================================

DoNotOrCopy:    shr     _CX, 1                          ; has byte?
                jnc     short NotOrCopy1

                lodsb
                not     al
                or      BPTR_ES[_DI], al
                inc     _DI
                or      _CX, _CX

IFE ExtRegSet

NotOrCopy1:     jz      short AllDone

NotOrCopyLoop:  lodsw
                not     ax
                or      BPTR_ES[_DI], ax
                add     _DI, 2
                loop    NotOrCopyLoop
                jmp     short AllDone
ELSE

NotOrCopy1:     shr     _CX, 1
                jnc     short NotOrCopy2
                lodsw
                not     ax
                or      WPTR_ES[_DI], ax
                add     _DI, 2
                or      _CX, _CX

NotOrCopy2:     jz      short AllDone

NotOrCopyLoop:  lodsd
                not     _AX
                or      DPTR [_DI], _AX
                add     _DI, 4
                loop    NotOrCopyLoop
                jmp     short AllDone
ENDIF



;==============================================================================
; OR in the source to the destination
;==============================================================================

DoOrCopy:       shr     _CX, 1                          ; has byte?
                jnc     short OrCopy1

                lodsb
                or      BPTR_ES[_DI], al
                inc     _DI
                or      _CX, _CX

IFE ExtRegSet

OrCopy1:        jz      short AllDone

OrCopyLoop:     lodsw
                or      BPTR_ES[_DI], ax
                add     _DI, 2
                loop    OrCopyLoop
                jmp     short AllDone
ELSE

OrCopy1:        shr     _CX, 1
                jnc     short OrCopy2
                lodsw
                or      WPTR_ES[_DI], ax
                add     _DI, 2
                or      _CX, _CX

OrCopy2:        jz      short AllDone

OrCopyLoop:     lodsd
                or      DPTR [_DI], _AX
                add     _DI, 4
                loop    OrCopyLoop
                jmp     short AllDone
ENDIF



;============================================================================
; COPY:
;============================================================================

DoCopy:         test    ax, CAOTBAF_INVERT      ; need invert?
                jz      short PlaneCopy

InvertCopy:     shr     _CX, 1                          ; has byte?
                jnc     short InvertCopy1
                lodsb
                not     al
                stosb
                or      _CX, _CX                        ; still zero

IFE ExtRegSet

InvertCopy1:    jz      short AllDone

InvertCopyLoop: lodsw
                not     ax
                stosw
                loop    InvertCopyLoop
                jmp     short AllDone
ELSE

InvertCopy1:    shr     _CX, 1
                jnc     short InvertCopy2
                lodsw
                not     ax
                stosw
                or      _CX, _CX                        ; still zero

InvertCopy2:    jz      short AllDone

InvertCopyLoop: lodsd
                not     _AX
                stosd
                loop    InvertCopyLoop
                jmp     short AllDone
ENDIF

PlaneCopy:      MOVS_CB _CX, al                 ; al is not used now


AllDone:        @EXIT                       ; restore environment and return


@END_PROC


SUBTTL  SetSourceMaskToPrim1
PAGE

COMMENT `

Routine Description:

    This function set the source mask bits into the PRIMMONO/PRIMCOLOR's Prim1,
    if the source need to be skipped (not modified on the destination) then
    the Prim1 will be PRIM_INVALID_DENSITY, else 0

Arguments:

    pSource     - Pointer to the byte array which each pel corresponds to one
                  source mask pel.

    pColorInfo  - Pointer to either PRIMCOLOR_COUNT or PRIMMONO_COUNT data
                  structure array

    SrcMaskInfo - SRCMASKINFO data structure which specified the format and
                  size of pColorInfo and other mask information

Return Value:

    No Return value

Author:

    18-Mar-1991 Mon 13:48:51 created  -by-  Daniel Chou (danielc)


Revision History:

`


@BEG_PROC   SetSourceMaskToPrim1    <pSource:DWORD,     \
                                     pColorInfo:DWORD,  \
                                     SrcMaskInfo:QWORD>

;
; Register Usage:
;
;  al       = Source
;  ah       = Source remained bit count
;  bx       = Free register
;  dx       = Current Count
;  _CX      = ColorInfoIncrement
;  _BP      = StretchSize
;  _DI      = Count Location
;  _SI      = pSource
;
;

                @ENTER  _DS _SI _DI _BP         ; Save environment registers

                LDS_SI  pSource
                LES_DI  pColorInfo

                mov     cl, SrcMaskInfo.SMI_FirstSrcMaskSkips
                mov     ah, 8                           ; 8-bit load
                sub     ah, cl                          ; dh=remained bits
                lodsb
                not     al                              ; for easy compute
                shl     al, cl                          ; shift to aligned

SetPointer:     MOVZX_W _CX, SrcMaskInfo.SMI_OffsetCount
                add     _DI, _CX                        ; _DI=pPrim1
                MOVSX_W _CX, SrcMaskInfo.SMI_ColorInfoIncrement
                MOVZX_W _DX, SrcMaskInfo.SMI_StretchSize
                test    SrcMaskInfo.SMI_Flags, SMIF_XCOUNT_IS_ONE
                mov     _BP, _DX
                jnz     short OneXCount

;============================================================================
; We have variable count, one or more source mask bits per stretch, the source
; mask 1=Overwrite, 0=Leave alone, to make life easier we will flip the source byte
; when we loaded,
;
; a left shift will casue carry bit to be set, then we do a 'SBB  reg, reg'
; instructions, this will make
;
;   reg = 0xff if carry set     (original=0  :Leave alone)
;   ret = 0x00 if carry clear   (original=1  :overwrite)
;
; during the PrimCount compsitions, we will or in clear CH with AL source byte
; (we only care bit 7), later we can just do a left shift to get that merge
; bit.
;

VarCount:       mov     dx, WPTR_ES[_DI]                ; dx=Count
                and     dx, NOT PRIM_COUNT_SPECIAL
                xor     bh, bh                          ; clear ch for use
                jmp     short VC1

VCLoad:         lodsB
                not     al
                mov     ah, 8                           ; fall through
VC1:
                dec     ah
                jl      short VCLoad
                or      bh, al                          ; or in bit 7
                shl     al, 1
                dec     dx
                jnz     short VC1                       ; repeat PrimCount
                shl     bh, 1
                jnc     VC_And
VC_Or:                                                  ; bit 7 of ch=1/0
                or      WPTR_ES[_DI], PRIM_COUNT_SPECIAL
                add     _DI, _CX
                dec     _BP
                jnz     short VarCount                  ; repeat stretch
                jmp     short AllDone
VC_And:
                and     WPTR_ES[_DI], NOT PRIM_COUNT_SPECIAL
                add     _DI, _CX
                dec     _BP
                jnz     short VarCount                  ; repeat stretch
                jmp     short AllDone


;============================================================================
; We only have one count, 1 source mask bit per stretch, the source mask
; 1=Overwrite, 0=Leave alone, to make life easier we will flip the source byte
; when we loaded,
;
; a left shift will casue carry bit to be set, then we do a 'SBB  reg, reg'
; instructions, this will make
;
;   reg = 0xff if carry set     (original=0  :Leave alone)
;   ret = 0x00 if carry clear   (original=1  :overwrite)
;

OXCLoad:        lodsB
                not     al
                mov     ah, 8                           ; fall through

OneXCount:      dec     ah
                jl      short OXCLoad
                shl     al, 1
                jc      SHORT OneXCountOr
OneXCountAnd:
                and     WPTR_ES[_DI], NOT PRIM_COUNT_SPECIAL
                add     _DI, _CX                        ; increment pPrim1
                dec     _BP
                jnz     short OneXCount
                jmp     SHORT AllDone
OneXCountOr:
                or      WPTR_ES[_DI], PRIM_COUNT_SPECIAL
                add     _DI, _CX                        ; increment pPrim1
                dec     _BP
                jnz     short OneXCount

AllDone:        @EXIT                       ; restore environment and return


@END_PROC




;*****************************************************************************
; START LOCAL MACROS
;*****************************************************************************


.XLIST

_PMAPPING               equ <_DX>
_PMONOMAP               equ <_PMAPPING + LUT_MONOMAP>
_PCOLORMAP              equ <_PMAPPING + LUT_COLORMAP>
_PWIDX0                 equ <_PMAPPING + LUT_WIDX0>
_PWIDX1                 equ <_PMAPPING + LUT_WIDX1>
_PWIDX2                 equ <_PMAPPING + LUT_WIDX2>
_PBIDX0                 equ <_PMAPPING + LUT_BIDX0>
_PBIDX1                 equ <_PMAPPING + LUT_BIDX1>
_PBIDX2                 equ <_PMAPPING + LUT_BIDX2>

LUT_RS0                 equ <[_PMAPPING].LUTC_rs0>
LUT_RS1                 equ <[_PMAPPING].LUTC_rs1>
LUT_RS2                 equ <[_PMAPPING].LUTC_rs2>



;
; The following macros used only in this files, and it will make it easy to
; handle all xBPP->MONO/COLOR cases during the translation
;
;
;============================================================================
;
;  __@@MappingFromAX:
;
;   Monochrome mapping: pMonoMapping[_AX + OFFSET].MonoPrim1
;                       pMonoMapping[_AX + OFFSET].MonoPrim2
;
;   Color mapping:      pColorMapping[_AX + OFFSET].ClrPrim1
;                       pColorMapping[_AX + OFFSET].ClrPrim2
;                       pColorMapping[_AX + OFFSET].ClrPrim3
;                       pColorMapping[_AX + OFFSET].ClrPrim4
;                       pColorMapping[_AX + OFFSET].ClrPrim5
;                       pColorMapping[_AX + OFFSET].ClrPrim6
;


__@@MappingFromAX   MACRO   ColorName

    IFIDNI <ColorName>, <MONO>
%       __@@EMIT <mov  > ax, <WPTR [_PMAPPING + (_AX*2)].MonoPrim1>
%       __@@EMIT <mov  > <WPTR_ES[_DI].PMC_Prim1>, ax
    ELSE
%       __@@EMIT <mov  > <WPTR [_DI].PCC_Prim5>, ax
    ENDIF
ENDM

__@@MappingFromBX   MACRO   ColorName

    IFIDNI <ColorName>, <MONO>
%       __@@EMIT <mov  > bx, <WPTR [_PMAPPING + (_BX*2)].MonoPrim1>
%       __@@EMIT <mov  > <WPTR_ES[_DI].PMC_Prim1>, bx
    ELSE
%       __@@EMIT <mov  > <WPTR [_DI].PCC_Prim5>, bx
    ENDIF
ENDM

;
;============================================================================
;
; __@@4BP_IDX(Mode):  AL = AL >> 4   (Mode = 1st_Nibble)
;                     AL = AL & 0x0f (Mode = 2nd_Nibble)
;

__@@4BPP_IDX    MACRO   Index

    IFIDNI <Index>, <1ST_NIBBLE>
        __@@EMIT <mov  > ch, al
        __@@EMIT <or   > ch, 80h                        ;; ah=second nibble
        IF i8086
            __@@EMIT <shr  > al, 1
            __@@EMIT <shr  > al, 1
            __@@EMIT <shr  > al, 1
            __@@EMIT <shr  > al, 1
        ELSE
            __@@EMIT <shr  > al, 4
        ENDIF
    ELSE
        IFIDNI <Index>, <2ND_NIBBLE>
            __@@EMIT <mov  > al, ch
            __@@EMIT <and  > al, 0fh
            __@@EMIT <xor  > ch, ch
        ELSE
            IF1
                %OUT ERROR __@@4BPP_IDX: Valid parameter 1 are <1ST_NIBBLE>,<2ND_NIBBLE>
            ENDIF
            .ERR
            EXITM
            EXITM
        ENDIF
    ENDIF
ENDM




;
; __@@SKIP_1BPP(Count): Move _SI to the last pel of the skipped pels, and
;                       update the AH source mask to to the last skipped pels.
;

__@@SKIP_1BPP   MACRO   XCount
                LOCAL   SkipLoop, OverByte, DoneSkip

    IFIDNI <XCount>, <VAR>
SkipLoop:
        __@@EMIT <shl  > ax, 1                          ;; shift left by 1
        __@@EMIT <jc   > <SHORT OverByte>
        __@@EMIT <dec  > _BP
        __@@EMIT <jnz  > <SHORT SkipLoop>
        __@@EMIT <jmp  > <SHORT DoneSkip>
OverByte:
        ;;
        ;; 18-Feb-1998 Wed 20:43:19 updated  -by-  Daniel Chou (danielc)
        ;;  Bug Fix, we supposed to pre-shift the mask by 1 when we
        ;;  load the new byte
        ;;
        __@@EMIT <dec  > _BP                            ;; FIX!!!
        ;;
        __@@EMIT <xchg > _BP, _CX                       ;; save CX
        __@@EMIT <mov  > _BX, _CX
        __@@EMIT <shr  > _BX, 3
        __@@EMIT <add  > _SI, _BX
        __@@EMIT <and  > _CX, 7
        __@@EMIT <mov  > ah, 1
        __@@EMIT <lodsb>
        __@@EMIT <shl  > ax, cl
        __@@EMIT <mov  > _CX, _BP                       ;; restore CX
    ELSE
        __@@EMIT <shl  > ax, 1
        __@@EMIT <jnc  > <SHORT DoneSkip>
        __@@EMIT <lodsb>
        __@@EMIT <mov  > ah, 1
    ENDIF

DoneSkip:

ENDM



;
; __@@SKIP_4BPP(Count): Move _SI to the last pel of the skipped pels, and
;                       update the CH source mask to to the last skipped pels.
;
; __@@SKIP_4BPP: skip total BP count/1 pels for the 4bpp source, the source
;                byte is the current source, so we will never care about the
;                second nibble, since if we skip second nibble the next source
;                will cause a new byte to be loaded. if we skip up to the
;                first nibble then we have to load the new source and prepare
;                the second nibble because next pel will be on second nibble.
;

__@@SKIP_4BPP   MACRO XCount
                LOCAL   DoSkip1, DoSkip2, DoneSkip

    IFIDNI <XCount>, <VAR>
        __@@EMIT <or   > ch, ch                         ;; 0x80=has nibble2
        __@@EMIT <jns  > <SHORT DoSkip1>
        __@@EMIT <dec  > _BP                            ;;
DoSkip1:
        __@@EMIT <xor  > ch, ch                         ;; at byte boundary
        __@@EMIT <or   > _BP, _BP
        __@@EMIT <jz   > <SHORT DoneSkip>               ;; next auto load
        __@@EMIT <mov  > _BX, _BP
        __@@EMIT <shr  > _BP, 1
        __@@EMIT <add  > _SI, _BP
        __@@EMIT <test > bl, 1                          ;; need 2nd nibble?
        __@@EMIT <jz   > <SHORT DoneSkip>               ;; noop! next auto load
    ELSE
        __@@EMIT <xor  > ch, 80h                        ;; ch=0x80 = nibble2
        __@@EMIT <jns  > <SHORT DoneSkip>
    ENDIF

    __@@EMIT <lodsB>
    __@@4BPP_IDX    <1ST_NIBBLE>

DoneSkip:

ENDM


;
; __@@SKIP_8BPP(Count): _SI = _SI + (Count)
;

__@@SKIP_8BPP   MACRO   XCount
    IFIDNI <XCount>,<VAR>
%       __@@EMIT <add  > _SI, _BP                       ;; extended bit cleared
    ELSE
%       __@@EMIT <inc  > _SI
    ENDIF
ENDM



__@@SKIP_16BPP  MACRO   XCount, BitCount

    IFIDNI <XCount>,<VAR>
%       __@@EMIT <lea  > _SI, <[_SI+(_BP*2)]>
    ELSE
%       __@@EMIT <add  > _SI, 2
    ENDIF
ENDM


__@@SKIP_24BPP  MACRO   XCount, BitCount

    IFIDNI <XCount>,<VAR>
%       __@@EMIT <lea  > _BP, <[_BP+(_BP*2)]>
%       __@@EMIT <add  > _SI, _BP
    ELSE
%       __@@EMIT <add  > _SI, 3
    ENDIF
ENDM


__@@SKIP_32BPP  MACRO   XCount, BitCount

    IFIDNI <XCount>,<VAR>
%       __@@EMIT <lea  > _SI, <[_SI+(_BP*4)]>
    ELSE
%       __@@EMIT <add  > _SI, 4
    ENDIF
ENDM



;
; __@@PRIM_1BPP: MONO LOAD : BL = pMonoMapping[(Mask & Src) ? 1 : 0]
;                MONO AVE  : BL = AVE(BL, pMonoMapping[(Mask & Src) ? 1 : 0])
;
;                COLOR LOAD: BL = pColorMapping[(Mask & Src) ? 1 : 0]
;                            BH = pColorMapping[(Mask & Src) ? 1 : 0]
;                            DL = pColorMapping[(Mask & Src) ? 1 : 0]
;                COLOR AVE : BL = AVE(BL, pColorMapping[(Mask & Src) ? 1 : 0])
;                            BH = AVE(BH, pColorMapping[(Mask & Src) ? 1 : 0])
;                            DL = AVE(DL, pColorMapping[(Mask & Src) ? 1 : 0])
;

__@@PRIM_1BPP   MACRO ColorName

    ;;
    ;; If Bit 7 of EAX is 1 (0x80) then ebp=0xffffffff
    ;; If Bit 7 of EAX is 0 (0x00) then ebp=0x00000000
    ;;

    __@@EMIT <xor  > _BX, _BX
    __@@EMIT <bt   > _AX, 7
    __@@EMIT <adc  > _BX, 0

    __@@MappingFromBX <ColorName>

ENDM


;
; __@@PRIM_4BPP: MONO LOAD : BL = pMonoMapping[Nibble]
;                MONO AVE  : BL = AVE(BL, pMonoMapping[Nibble]
;
;                COLOR LOAD: BL = pColorMapping[Nibble]
;                            BH = pColorMapping[Nibble]
;                            DL = pColorMapping[Nibble]
;                COLOR AVE : BL = AVE(BL, pColorMapping[Nibble])
;                            BH = AVE(BH, pColorMapping[Nibble])
;                            DL = AVE(DH, pColorMapping[Nibble])
;

__@@PRIM_4BPP   MACRO ColorName

    BZXEAX  al

    __@@MappingFromAX   ColorName

ENDM



;
; __@@PRIM_8BPP:     MONO LOAD: BL = pMonoMapping[Src BYTE/WORD]
;
;                   COLOR LOAD: BL = pColorMapping[Src BYTE/WORD]
;                   ColorMapping[Src BYTE/WORD]
;                               DL = pColorMapping[Src BYTE/WORD]
;

__@@PRIM_8BPP   MACRO ColorName

    __@@EMIT <lodsB>
    BZXEAX  al

    __@@MappingFromAX   ColorName

ENDM


__@@PRIM_1632BPP    MACRO BitCount, ColorName

    IFIDNI <BitCount>, <16>
        __@@EMIT <lodsW>                                            ;;  5
    ELSE
        __@@EMIT <lodsD>                                            ;;  5
    ENDIF

    IFIDNI <ColorName>, <MONO>
        __@@EMIT <mov  > ebx, eax                                   ;;  3
        __@@EMIT <shr  > ebx, cl                                    ;;  3
        __@@EMIT <movzx> ebx, bl                                    ;;  3
%       __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>             ;;  4
        __@@EMIT <ror  > ecx, 8                                     ;;  3
        __@@EMIT <mov  > ebx, eax                                   ;;  3
        __@@EMIT <shr  > ebx, cl                                    ;;  3
        __@@EMIT <movzx> ebx, bl                                    ;;  3
%       __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>             ;;  4
        __@@EMIT <ror  > ecx, 8                                     ;;  3
        __@@EMIT <shr  > eax, cl                                    ;;  3
        __@@EMIT <movzx> eax, al                                    ;;  3
%       __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>             ;;  4
        __@@EMIT <ror  > ecx, 16                                    ;;  3
%       __@@EMIT <mov  > ax, <WPTR [_PMONOMAP + (_BP * 2)].MonoPrim1>
%       __@@EMIT <mov  > <WPTR_ES[_DI].PMC_Prim1>, ax
    ELSE
        IFIDNI <ColorName>, <COLOR_GRAY>
            __@@EMIT <mov  > ebx, eax                               ;;  3
            __@@EMIT <shr  > ebx, cl                                ;;  3
            __@@EMIT <movzx> ebx, bl                                ;;  3
%           __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
            __@@EMIT <ror  > ecx, 8                                 ;;  3
            __@@EMIT <mov  > ebx, eax                               ;;  3
            __@@EMIT <shr  > ebx, cl                                ;;  3
            __@@EMIT <movzx> ebx, bl                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
            __@@EMIT <ror  > ecx, 8                                 ;;  3
            __@@EMIT <shr  > eax, cl                                ;;  3
            __@@EMIT <movzx> eax, al                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
%           __@@EMIT <mov  > <DPTR [_DI].PCC_Prim1>, 0
        ELSE
            __@@EMIT <mov  > ebx, eax                               ;;  3
            __@@EMIT <shr  > ebx, cl                                ;;  3
            __@@EMIT <movzx> ebx, bl                                ;;  3
%           __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
%           __@@EMIT <mov  > bl, <BPTR [_PBIDX0 + ebx]>             ;;  4
%           __@@EMIT <mov  > <BPTR_ES[_DI].PCC_Prim1>, bl
            __@@EMIT <ror  > ecx, 8                                 ;;  3
            __@@EMIT <mov  > ebx, eax                               ;;  3
            __@@EMIT <shr  > ebx, cl                                ;;  3
            __@@EMIT <movzx> ebx, bl                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
%           __@@EMIT <mov  > bl, <BPTR [_PBIDX1 + ebx]>             ;;  4
            __@@EMIT <ror  > ecx, 8                                 ;;  3
            __@@EMIT <shr  > eax, cl                                ;;  3
            __@@EMIT <movzx> eax, al                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
%           __@@EMIT <mov  > bh, <BPTR [_PBIDX2 + eax]>             ;;  4
%           __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim2>, bx
        ENDIF

        __@@EMIT <ror  > ecx, 16                                    ;;  3
%       __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim5>, bp
    ENDIF
ENDM


__@@PRIM_24BPP    MACRO ColorName

    __@@EMIT <lodsW>                                                ;;  5

    IFIDNI <ColorName>, <MONO>
        __@@EMIT <movzx> ebx, al                                    ;;  3
%       __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>             ;;  4
        __@@EMIT <movzx> ebx, ah                                    ;;  3
%       __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>             ;;  4
        __@@EMIT <lodsB>
        __@@EMIT <movzx> eax, al                                    ;;  3
%       __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>             ;;  4
%       __@@EMIT <mov  > ax, <WPTR [_PMONOMAP + (_BP * 2)].MonoPrim1>
%       __@@EMIT <mov  > <WPTR_ES[_DI].PMC_Prim1>, ax
    ELSE
        IFIDNI <ColorName>, <COLOR_GRAY>
            __@@EMIT <movzx> ebx, al                                ;;  3
%           __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
            __@@EMIT <movzx> ebx, ah                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
            __@@EMIT <lodsB>
            __@@EMIT <movzx> eax, al                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
%           __@@EMIT <mov  > <DPTR [_DI].PCC_Prim1>, 0
        ELSE
            __@@EMIT <movzx> ebx, al                                ;;  3
%           __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
%           __@@EMIT <mov  > bl, <BPTR [_PBIDX0 + ebx]>             ;;  4
%           __@@EMIT <mov  > <BPTR_ES[_DI].PCC_Prim1>, bl
            __@@EMIT <movzx> ebx, ah                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
%           __@@EMIT <mov  > bl, <BPTR [_PBIDX1 + ebx]>             ;;  4
            __@@EMIT <lodsB>
            __@@EMIT <movzx> eax, al                                ;;  3
%           __@@EMIT <add  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
%           __@@EMIT <mov  > bh, <BPTR [_PBIDX2 + eax]>             ;;  4
%           __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim2>, bx
        ENDIF

%       __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim5>, bp
    ENDIF
ENDM



__@@PRIM_24BPP_COPY MACRO

    __@@EMIT <lodsW>                                        ;;  5
    __@@EMIT <movzx> ebx, al                                ;;  3
    __@@EMIT <mov  > bp, <WPTR [_PWIDX0 + (ebx*2)]>         ;;  4
    __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim1>, bp
    __@@EMIT <movzx> ebx, ah                                ;;  3
    __@@EMIT <mov  > bp, <WPTR [_PWIDX1 + (ebx*2)]>         ;;  4
    __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim3>, bp
    __@@EMIT <lodsB>
    __@@EMIT <movzx> eax, al                                ;;  3
    __@@EMIT <mov  > bp, <WPTR [_PWIDX2 + (eax*2)]>         ;;  4
    __@@EMIT <mov  > <WPTR_ES[_DI].PCC_Prim5>, bp
ENDM


;
; Load next source (bits/byte) and translate/mapping it to the Prims
;
; 1BPP:
;    Mono: AH=Mask (carry = load)
;          AL=SourceByte (bit 7) -----> BL:BH/(AVE BL, BH=Destroyed)
;
;   Color: AH=Mask (carry = load)
;          AL=SourceByte (bit 7) -----> BL:BH:DH:DL/(AVE BL, BH=Destroyed)
;
; 4BPP:    AH=Mask (bit 7/0-3=nibble2)
;          AL=Current Nibble
;
;    Mono: AL=SrcByte, AH=CLEAR    ---> BL/(AVE BL, BH=Destroyed)
;
;   Color: AL=SrcByte, AH=CLEAR    ---> BL:BH:DH/(AVE BL:BH:DH)
;
; 8BPP:
;    Mono: BYTE DS:SI ----------------> DH/(AVE DH)
;
;   Color: BYTE DS:SI ----------------> BL:BH:DH/(AVE BL:BH:DH)
;
; 16BPP:
;    Mono: WORD DS:SI ----------------> DH/(AVE DH)
;
;   Color: WORD DS:SI ----------------> BL:BH:DH/(AVE BL:BH:DH)
;
; 24BPP:
;    Mono: DS:SI (3 bytes) -----------> DH/(AVE DH)
;
;   Color: DS:SI (3 bytes) -----------> BL:BH:DH/(AVE BL:BH:DH)
;
; 32BPP:
;    Mono: DS:SI (4 bytes) -----------> DH/(AVE DH)
;
;   Color: DS:SI (4 bytes) -----------> BL:BH:DH/(AVE BL:BH:DH)
;


;
; PRIM_SKIP?(Label):    Jmp to 'Label' if BL (Prim1) is PRIM_INVALID_DENSITY,
;                       this causing the source pel location to be skipped and
;                       destination to be preserved.
;
;   NOTE: The Label is consider a SHORT jmp label, if a full jump (32k) is
;         required then it should have another full jump label and have this
;         'label' jump to the full jump location then transfer to the final
;         desired location.
;

PRIM_SKIP?  MACRO XCount, JmpSkip

    IFB <JmpSkip>
        IF1
            %OUT Error: <PRIM_SKIP?> has no jmp label
        ENDIF
        .ERR
        EXITM
    ENDIF

%   __@@EMIT <cmp  > _BP, PRIM_COUNT_SPECIAL
%   __@@EMIT <jae  > <SHORT JmpSkip>

ENDM



;
; PRIM_END?(Label):     Jmp to 'Label' if BL/BH (Prim1/Prim2) both are
;                       PRIM_INVALID_DENSITY, this indicate the PrimCount is
;                       at end of the list, the 'Label' should specified the
;                       function EXIT location.
;
;   NOTE: The Label is consider a SHORT jmp label, if a full jump (32k) is
;         required then it should have another full jump label and have this
;         'label' jump to the full jump location then transfer to the final
;         desired location.
;

PRIM_END?   MACRO XCount, JmpEnd

    IFB <JmpEnd>
        IF1
            %OUT Error: <PRIM_END?> has no jmp label
        ENDIF
        .ERR
        EXITM
    ENDIF

%   __@@EMIT <cmp  > _BP, PRIM_COUNT_END_SCAN
%   __@@EMIT <jz   > <SHORT JmpEnd>

    IFIDNI <XCount>, <VAR>
        __@@EMIT <and  > _BP, <NOT PRIM_COUNT_SPECIAL>
    ENDIF
ENDM



;
; PRIM_NEXT(ColorName): Advance _DI by ColorInfoIncrement amount (dl or _DX),
;                       the increment may be negative.
;

PRIM_NEXT   MACRO
%   __@@EMIT <add  > _DI, [_SP]
ENDM


;
; PRIM_LOAD:    Load PrimCount to register
;

PRIM_LOAD   MACRO

%   __@@EMIT <movzx> _BP, <WPTR [_DI]>

ENDM



;
; LOAD_PROC(BitCount, JmpPrimLoad):  Defined a special source loading function,
;                                   The 'JmpPrimLoad' label is a SHORT label
;                                   and it must immediately follow coreesponse
;                                   LOAD_PROC?? macro.
;
;   This macro is used to defined a function to load next source byte for the
;   1BPP, 4BPP, since it has more than 1 source pel in a single byte, this may
;   save the source loading time, for the BPP, this macro generate no code
;

LOAD_PROC   MACRO   LabelName, BitCount, JmpPrimLoad

    IFB <LabelName>
        IF1
            %OUT Error: <LOAD_PROC> has no defined label
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFB <JmpPrimLoad>
        IF1
            %OUT Error: <LOAD_PROC> has no 'jump load' label
        ENDIF
        .ERR
        EXITM
    ENDIF


    IFIDNI <BitCount>,<1>
&LabelName:
        __@@EMIT <lodsB>
        __@@EMIT <mov  > ah, 1                              ;; byte boundary
        __@@EMIT <jmp  > <SHORT JmpPrimLoad>
    ELSE
        IFIDNI <BitCount>,<4>
&LabelName:
            __@@EMIT <lodsB>                                ;; previous 1
            __@@4BPP_IDX    <1ST_NIBBLE>
            __@@EMIT <jmp  > <SHORT JmpPrimLoad>
        ENDIF
    ENDIF

ENDM



;
; LOAD_PROC??(BitCount, JmpLoadProc): Check if need to load 1BPP/4BPP source
;                                    byte, the 'JmpLoadProc' must defined and
;                                    corresponse to where this label is jump
;                                    from.  For other BPP it generate no code.
;

LOAD_PROC??  MACRO   BitCount, JmpLoadProc

    IFB <JmpLoadProc>
        IF1
            %OUT Error: <LOAD_PROC> has no JmpLoadProc label
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <BitCount>,<1>
        __@@EMIT <shl  > ax, 1
        __@@EMIT <jc   > <SHORT JmpLoadProc>
    ELSE
        IFIDNI <BitCount>,<4>
            __@@EMIT <or   > ch, ch
            __@@EMIT <jns  > <SHORT JmpLoadProc>            ;; bit before XOR
            __@@4BPP_IDX     <2ND_NIBBLE>                   ;; do 2nd nibble
        ENDIF
    ENDIF
ENDM


;
; TO_LAST_VAR_SRC(BitCount): Skip the source pels according to the xBPP, it will
;                           advance the source (_SI) to the last pels of the
;                           variable count and re-adjust its source mask (if
;                           one needed).
;

TO_LAST_VAR_SRC MACRO   BitCount
                LOCAL   DoneSkip

    ;;__@@VALID_PARAM? <SKIP_SRC>, 1, BitCount,<1,4,8,16,24,24COPY,32>

%   __@@EMIT <dec  > _BP

    IFIDNI <BitCount>, <1>
        __@@EMIT <jz   > <SHORT DoneSkip>
        __@@SKIP_1BPP    <VAR>
    ELSE
        IFIDNI <BitCount>, <4>
            __@@EMIT <jz   > <SHORT DoneSkip>
            __@@SKIP_4BPP    <VAR>
        ELSE
            IFIDNI <BitCount>, <8>
                __@@SKIP_8BPP   <VAR>
            ELSE
                IFIDNI <BitCount>, <16>
                    __@@SKIP_16BPP   <VAR>
                ELSE
                    IFIDNI <BitCount>, <32>
                        __@@SKIP_32BPP   <VAR>
                    ELSE
                        __@@SKIP_24BPP   <VAR>
                    ENDIF
                ENDIF
            ENDIF
        ENDIF
    ENDIF

DoneSkip:

ENDM



;
; SKIP_SRC(BitCount, XCount):    Skip the source pels according to the xBPP
;                               and (VAR/SINGLE) specified, it will advance the
;                               source (_SI) and re-adjust its source mask (if
;                               one needed).
;

SKIP_SRC    MACRO   BitCount, XCount

    ;;__@@VALID_PARAM? <SKIP_SRC>, 1, BitCount,<1,4,8,16,24,24COPY,32>
    ;;__@@VALID_PARAM? <SKIP_SRC>, 2, XCount, <SINGLE, VAR>

    IFIDNI <BitCount>, <1>
        __@@SKIP_1BPP   XCount
    ELSE
        IFIDNI <BitCount>, <4>
            __@@SKIP_4BPP   XCount
        ELSE
            IFIDNI <BitCount>, <8>
                __@@SKIP_8BPP   XCount
            ELSE
                IFIDNI <BitCount>, <16>
                    __@@SKIP_16BPP  XCount
                ELSE
                    IFIDNI <BitCount>, <32>
                        __@@SKIP_32BPP  XCount
                    ELSE
                        __@@SKIP_24BPP  XCount
                    ENDIF
                ENDIF
            ENDIF
        ENDIF
    ENDIF
ENDM

;
; SRC_TO_PRIMS(BitCount,Order, ColorName,GrayColor):
;       Load or blendign a source pels, it handle all BPP cases, and
;       MONO/COLOR/GRAY cases.
;

SRC_TO_PRIMS    MACRO   BitCount, ColorName

    __@@VALID_PARAM? <SRC_TO_PRIMS>, 1, BitCount,   <1,4,8,16,24,24COPY,32>
    __@@VALID_PARAM? <SRC_TO_PRIMS>, 2, ColorName,  <MONO,COLOR,COLOR_GRAY>


    IFIDNI <BitCount>, <1>
        __@@PRIM_1BPP   ColorName
    ELSE
        IFIDNI <BitCount>, <4>
            __@@PRIM_4BPP   ColorName
        ELSE
            IFIDNI <BitCount>, <8>
                __@@PRIM_8BPP   ColorName
            ELSE
                IFIDNI <BitCount>, <16>
                    __@@PRIM_1632BPP  <16>, ColorName
                ELSE
                    IFIDNI <BitCount>, <24COPY>
                        __@@PRIM_24BPP_COPY
                    ELSE
                        IFIDNI <BitCount>, <24>
                            __@@PRIM_24BPP  ColorName
                        ELSE
                            __@@PRIM_1632BPP    <32>, ColorName
                        ENDIF
                    ENDIF
                ENDIF
            ENDIF
        ENDIF
    ENDIF
ENDM



;
; BMFToPrimCount:   The Main function Macro, this macro setup all xBPP cases,
;                   and handle all MONO/COLOR cases, also it prepare special
;                   cased for 1BPP/4BPP, read/blending the source and terminate
;                   the function.
;

BMFToPrimCount  MACRO   BitCount, DoRS, ColorName

    __@@VALID_PARAM? <BMFToPrimCount>, 1, BitCount,   <1,4,8,16,24,24COPY,32>
    __@@VALID_PARAM? <BMFToPrimCount>, 2, DoRS,       <LOAD_RS,NO_RS>
    __@@VALID_PARAM? <BMFToPrimCount>, 3, ColorName,  <MONO,COLOR,COLOR_GRAY>

;===========================================================================
; Registers Usage:
;
; _SI       = pSource
; _DI       = pPrimCount
; _DX       = pMapping
; _AX       = Source Load register
;             (except 1BPP, AL=Current Source Byte, AH=Source Mask
;                     4BPP, AL=1st Nibble)          AH=0)
; bl:bh     = Prim1/2
;  ch       = for 4bpp CH=Source Load Mask
;  cl       = Free register
; [_SP]     = ColorInfoIncrement
; _BP       = VAR:  PrimCount.COUNT durning the skips, else FREE register
;===========================================================================
;===========================================================================
; 1BPP Special Setup:
;
;   AL=Current Source Byte, AH=Source Mask,
;
;   if the first loop does not cause a source byte to load (AH != 0x01) then
;   AL must preloaded with current source byte.
;
; 4BPP Special Setup:
;
;   CH=0x01 Load.  CH=0x00, data in AL, if CH=0x00 then AL must preloaded.
;
;===========================================================================



        @ENTER  _DS _SI _DI _BP      ; Save environment registers

        ;
        ; Except 1BPP --> MONO, we will swap a temporary stack so that ss:sp
        ; is point to the mapping area, and ss:sp is allowed for 256 bytes
        ; consecutive pushes.
        ;

%       MOVSX_W _AX, <WPTR InFuncInfo.IFI_ColorInfoIncrement>   ;; dx=Increment
%       __@@EMIT <push > _AX                                    ;; [_SP]=Inc.

        __@@EMIT <mov  > cl, InFuncInfo.IFI_BMF1BPP1stShift     ;; cl=1st shift
        __@@EMIT <mov  > ch, InFuncInfo.IFI_Flags               ;; ch=flags

        LDS_SI  pSource                                     ;; _SI=Source

        IFIDNI <ColorName>,<MONO>
            LES_DI  pPrimMonoCount                          ;; _DI=PrimCount
        ELSE
            LES_DI  pPrimColorCount
        ENDIF


        IFIDNI <ColorName>, <MONO>
%           __@@EMIT <mov  > _PMAPPING, <DWORD PTR pMonoMapping>
        ELSE
%           __@@EMIT <mov  > _PMAPPING, <DWORD PTR pColorMapping>
        ENDIF

        __@@EMIT <mov  > bl, ch                             ;; BL=flag

        IFIDNI <BitCount>,<1>                               ;; 1bpp special
            __@@EMIT <mov  > ah, 1                          ;; get mask siift
            __@@EMIT <test > bl, IFIF_GET_FIRST_BYTE        ;; need 1st byte
            __@@EMIT <jz   > <SHORT DoneLoad1BPP>
            __@@EMIT <lodsB>                                ;; get first byte
DoneLoad1BPP:
            __@@EMIT <shl  > ax, cl
        ELSE
            IFIDNI <BitCount>, <4>                          ;; 4 bpp special
                __@@EMIT <xor  > ch, ch                     ;; ready to carry
                __@@EMIT <test > bl, IFIF_GET_FIRST_BYTE    ;; need 1st byte?
                __@@EMIT <jz   > <SHORT DoneSpecial>
                __@@EMIT <lodsB>
                __@@EMIT <mov  > ch, al
                __@@EMIT <or   > ch, 80h
            ENDIF
        ENDIF

DoneSpecial:


        ;;
        ;; xx0 - cl=rs0/rs1/rs2
        ;; xyz - cl=rs0, ch=rs1-rs0, ecl=rs2-rs1
        ;; bgr - ecx = 0
        ;;

        IFIDNI <DoRS>, <LOAD_RS>                            ;; cl=rs0
            ;;
            ;; becase we will shift the source register (eax) for each of
            ;; the right shift, so we will shift the rs1/rs2 by differences
            ;;
%           __@@EMIT <movzx> ecx, <BPTR LUT_RS1>            ;;  cl=rs1
%           __@@EMIT <mov  > ch, <BPTR LUT_RS2>             ;;  ch=rs2
            __@@EMIT <shl  > ecx, 8                         ;; ecl=rs2-rs1
%           __@@EMIT <mov  > cl, <BPTR LUT_RS0>             ;;  ch=rs1,cl=rs0
        ENDIF

        WZXE    ax                                          ;; clear extended
        BZXE    bl                                          ;; clear extended
        WZXE    bp                                          ;; clear extended

        __@@EMIT <test > bl, IFIF_XCOUNT_IS_ONE             ;; single count?
        __@@EMIT <jnz  > <SHORT SCInit>
        __@@EMIT <jmp  > <VCInit>


;-----------------------------------------------------------------------------
; Case 2: Single Count Initial source read
;-----------------------------------------------------------------------------

JmpAllDone:
        jmp             AllDone

SCInitSkip:
        PRIM_END?       <SINGLE>, <JmpAllDone>
        SKIP_SRC        BitCount, <SINGLE>

SCInitNext:
        PRIM_NEXT

SCInit:
        PRIM_LOAD                                       ; initial load all
        PRIM_SKIP?      <SINGLE>, <SCInitSkip>

        LOAD_PROC??     BitCount, <SCInitLoad>          ; special load?

SCInitSrcRead:
        SRC_TO_PRIMS    BitCount,ColorName

        jmp             short SCInitNext

        LOAD_PROC       <SCInitLoad>,BitCount,<SCInitSrcRead>    ; must defined


;*****************************************************************************
;* EXIT AT HERE                                                              *
;*****************************************************************************

AllDone:
%       __@@EMIT <pop  > _DX                ; restore stack pointer

        @EXIT                               ; restore environment and return

;-----------------------------------------------------------------------------
; Case 4: Variable Count Initial source read
;-----------------------------------------------------------------------------


VCInitSkip:
        PRIM_END?       <VAR>, <AllDone>
        SKIP_SRC        BitCount, <VAR>                 ; skip current one
VCInitNext:
        PRIM_NEXT
VCInit:
        PRIM_LOAD
        PRIM_SKIP?      <VAR>, <VCInitSkip>             ;
        TO_LAST_VAR_SRC BitCount
        LOAD_PROC??     BitCount,<VCInitLoad>

VCInitSrcRead:
        SRC_TO_PRIMS    BitCount, ColorName

        jmp             short VCInitNext            ; check next

        LOAD_PROC       <VCInitLoad>,BitCount,<VCInitSrcRead>



ENDM



.LIST




;*****************************************************************************
; END LOCAL MACROS
;*****************************************************************************
;

@BEG_PROC   BMF1_ToPrimMono <pSource:DWORD,         \
                             pPrimMonoCount:DWORD,  \
                             pMonoMapping:DWORD,    \
                             InFuncInfo:DWORD>

            BMFToPrimCount  <1>, <NO_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------


@BEG_PROC   BMF4_ToPrimMono <pSource:DWORD,         \
                             pPrimMonoCount:DWORD,  \
                             pMonoMapping:DWORD,    \
                             InFuncInfo:DWORD>

            BMFToPrimCount  <4>, <NO_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------


@BEG_PROC   BMF8_ToPrimMono <pSource:DWORD,         \
                             pPrimMonoCount:DWORD,  \
                             pMonoMapping:DWORD,    \
                             InFuncInfo:DWORD>

            BMFToPrimCount  <8>, <NO_RS>, <MONO>
@END_PROC

;*****************************************************************************

@BEG_PROC   BMF1_ToPrimColor    <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <1>, <NO_RS>, <COLOR>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF4_ToPrimColor    <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <4>, <NO_RS>, <COLOR>
@END_PROC

;-----------------------------------------------------------------------------


@BEG_PROC   BMF8_ToPrimColor    <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <8>, <NO_RS>, <COLOR>
@END_PROC

;*****************************************************************************

@BEG_PROC   BMF16_ToPrimMono    <pSource:DWORD,        \
                                 pPrimMonoCount:DWORD, \
                                 pMonoMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <16>, <LOAD_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF16_ToPrimColorGRAY   <pSource:DWORD,         \
                                     pPrimColorCount:DWORD, \
                                     pColorMapping:DWORD,   \
                                     InFuncInfo:DWORD>

            BMFToPrimCount  <16>, <LOAD_RS>, <COLOR_GRAY>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF16_ToPrimColor   <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <16>, <LOAD_RS>, <COLOR>
@END_PROC

;*****************************************************************************

@BEG_PROC   BMF24_ToPrimMono    <pSource:DWORD,        \
                                 pPrimMonoCount:DWORD, \
                                 pMonoMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <24>, <NO_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF24_ToPrimColorGRAY   <pSource:DWORD,         \
                                     pPrimColorCount:DWORD, \
                                     pColorMapping:DWORD,   \
                                     InFuncInfo:DWORD>

            BMFToPrimCount  <24>, <NO_RS>, <COLOR_GRAY>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF24_ToPrimColor   <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <24>, <NO_RS>, <COLOR>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF24_ToPrimColor_COPY   <pSource:DWORD,         \
                                      pPrimColorCount:DWORD, \
                                      pColorMapping:DWORD,   \
                                      InFuncInfo:DWORD>

            BMFToPrimCount  <24COPY>, <NO_RS>, <COLOR>
@END_PROC

;*****************************************************************************

@BEG_PROC   BMF32_ToPrimMono    <pSource:DWORD,        \
                                 pPrimMonoCount:DWORD, \
                                 pMonoMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <32>, <LOAD_RS>, <MONO>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF32_ToPrimColorGRAY   <pSource:DWORD,         \
                                     pPrimColorCount:DWORD, \
                                     pColorMapping:DWORD,   \
                                     InFuncInfo:DWORD>

            BMFToPrimCount  <32>, <LOAD_RS>, <COLOR_GRAY>
@END_PROC

;-----------------------------------------------------------------------------

@BEG_PROC   BMF32_ToPrimColor   <pSource:DWORD,         \
                                 pPrimColorCount:DWORD, \
                                 pColorMapping:DWORD,   \
                                 InFuncInfo:DWORD>

            BMFToPrimCount  <32>, <LOAD_RS>, <COLOR>
@END_PROC


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


            MATCH_ENTER_EXIT?           ; Check if we missed anything



ENDIF       ; HT_ASM_80x86



END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\i386\htstub.asm ===
PAGE 60, 132
    TITLE   Stub for halftone DLL

COMMENT `


Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htstub.asm


Abstract:

    This module is provided as necessary for OS/2 as a DLL entry point


Author:

    05-Apr-1991 Fri 15:55:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:

`



        .XLIST
        INCLUDE i386\i80x86.inc
        .LIST


        EndFunctionName CATSTR <>

IF  HT_ASM_80x86

NeedStub = 0

IFDEF _OS2_
NeedStub = 1
ENDIF

IFDEF _OS_20_
NeedStub = 1
ENDIF

IF NeedStub

        EndFunctionName CATSTR <HalftoneInitProc>

        .CODE

extrn   HalftoneInitProc:FAR

HalftoneDLLEntry    proc FAR

        push    di                              ; push the hModule
        call    HalftoneInitProc
        pop     bx                              ; C calling convention
        ret

HalftoneDLLEntry    ENDP

ENDIF       ; NeedStub
ENDIF       ; HT_ASM_80x86

% END EndFunctionName                           ; make this one at offset 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\i386\htwbmp.asm ===
PAGE 60, 132
    TITLE   Setting 1/4 bits per pel bitmap or 3 planes-1BPP bitmap


COMMENT `

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htwbmp.asm

Abstract:

    This module is used to provide set of functions to set the bits into the
    final destination bitmap, the input to these function are data structures
    (PRIMMONO_COUNT, PRIMCOLOR_COUNT and other pre-calculated data values).

    This function is the equivelant codes in the htsetbmp.c

Author:

    03-Apr-1991 Wed 10:28:50 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:
    06-Nov-1992 Fri 16:04:18 updated  -by-  Daniel Chou (danielc)
        Fixed bug in VarCountOutputToVGA256 which clear 'ah' (xor _AX, _AX)
        while we still need to use it.


    28-Mar-1992 Sat 21:09:42 updated  -by-  Daniel Chou (danielc)
        Rewrite all output functions, add in VGA16 support.


`


        .XLIST
        INCLUDE i386\i80x86.inc
        .LIST

IF  0

IF  HT_ASM_80x86


;------------------------------------------------------------------------------
        .XLIST
        INCLUDE i386\htp.inc
        .LIST
;------------------------------------------------------------------------------

        DBG_FILENAME    i386\htwbmp


        .CODE

VGA16ColorIndex     db  000h, 077h, 077h, 088h, 088h, 0ffh  ; MONO

                    db  000h, 000h, 000h, 011h, 033h, 077h  ; RY     0
                    db  000h, 000h, 011h, 033h, 077h, 088h  ; RY     6
                    db  000h, 000h, 011h, 033h, 088h, 0ffh  ; RY    18

                    db  000h, 011h, 033h, 099h, 0bbh, 077h  ; RY    24
                    db  011h, 033h, 099h, 0bbh, 077h, 088h  ; RY    30
                    db  011h, 033h, 099h, 0bbh, 088h, 0ffh  ; RY    36

                    db  000h, 000h, 000h, 011h, 055h, 077h  ; RM    42
                    db  000h, 000h, 011h, 055h, 077h, 088h  ; RM    48
                    db  000h, 000h, 011h, 055h, 088h, 0ffh  ; RM    54

                    db  000h, 011h, 055h, 099h, 0ddh, 077h  ; RM    60
                    db  011h, 055h, 099h, 0ddh, 077h, 088h  ; RM    66
                    db  011h, 055h, 099h, 0ddh, 088h, 0ffh  ; RM    72

                    db  000h, 000h, 000h, 022h, 033h, 077h  ; GY    78
                    db  000h, 000h, 022h, 033h, 077h, 088h  ; GY    84
                    db  000h, 000h, 022h, 033h, 088h, 0ffh  ; GY    90

                    db  000h, 022h, 033h, 0aah, 0bbh, 077h  ; GY    96
                    db  022h, 033h, 0aah, 0bbh, 077h, 088h  ; GY   102
                    db  022h, 033h, 0aah, 0bbh, 088h, 0ffh  ; GY   108

                    db  000h, 000h, 000h, 022h, 066h, 077h  ; GC   114
                    db  000h, 000h, 022h, 066h, 077h, 088h  ; GC   120
                    db  000h, 000h, 022h, 066h, 088h, 0ffh  ; GC   126

                    db  000h, 022h, 066h, 0aah, 0eeh, 077h  ; GC   132
                    db  022h, 066h, 0aah, 0eeh, 077h, 088h  ; GC   138
                    db  022h, 066h, 0aah, 0eeh, 088h, 0ffh  ; GC   144

                    db  000h, 000h, 000h, 044h, 055h, 077h  ; BM   150
                    db  000h, 000h, 044h, 055h, 077h, 088h  ; BM   156
                    db  000h, 000h, 044h, 055h, 088h, 0ffh  ; BM

                    db  000h, 044h, 055h, 0cch, 0ddh, 077h  ; BM   162
                    db  044h, 055h, 0cch, 0ddh, 077h, 088h  ; BM   168
                    db  044h, 055h, 0cch, 0ddh, 088h, 0ffh  ; BM   174

                    db  000h, 000h, 000h, 044h, 066h, 077h  ; BC   180
                    db  000h, 000h, 044h, 066h, 077h, 088h  ; BC   186
                    db  000h, 000h, 044h, 066h, 088h, 0ffh  ; BC   192

                    db  000h, 044h, 066h, 0cch, 0eeh, 077h  ; BC   198
                    db  044h, 066h, 0cch, 0eeh, 077h, 088h  ; BC   204
                    db  044h, 066h, 0cch, 0eeh, 088h, 0ffh  ; BC   210



;******************************************************************************
; Following EQUATES and MACROS only used in this file
;******************************************************************************


VGA256_SSSP_XLAT_TABLE  equ     0
VGA256_XLATE_TABLE_SIZE equ     256


;                                87654321
;------------------------------------------
HTPAT_STK_MASK          equ     (0ffh)
HTPAT_NOT_STK_MASK      equ     (NOT HTPAT_STK_MASK)
HTPAT_STK_MASK_SIZE     equ     (HTPAT_STK_MASK + 1)

HTPAT_BP_SIZE           equ     (REG_MAX_SIZE * 1)
HTPAT_BP_OLDSTK         equ     (REG_MAX_SIZE * 2)
HTPAT_BP_DATA1          equ     (REG_MAX_SIZE * 3)

HTPAT_STK_SIZE_EXTRA    equ     (REG_MAX_SIZE * 3)

HTPAT_SP_SIZE           equ     (HTPAT_STK_SIZE_EXTRA - HTPAT_BP_SIZE)
HTPAT_SP_OLDSTK         equ     (HTPAT_STK_SIZE_EXTRA - HTPAT_BP_OLDSTK)
HTPAT_SP_DATA1          equ     (HTPAT_STK_SIZE_EXTRA - HTPAT_BP_DATA1)


.XLIST


@ENTER_PAT_TO_STK   MACRO   Format
                    LOCAL   StkSizeOk, DoneSetUp

    __@@VALID_PARAM? <PAT_TO_STK>, 1, Format, <1BPP, 3PLANES, 4BPP, VGA16, VGA256, 16BPP>


    @ENTER  _DS _SI _DI _BP                        ;; Save environment/registers

    __@@EMIT <xor  > _CX, _CX
    __@@EMIT <mov  > cx, <OutFuncInfo.OFI_PatWidthBytes>

    __@@EMIT <mov  > _AX, _SP                      ;; get stack location
    __@@EMIT <mov  > _DX, _AX                      ;; save it
    __@@EMIT <and  > _AX, <HTPAT_STK_MASK>         ;; how many bytes avai
    __@@EMIT <inc  > _AX                           ;; this many bytes
    __@@EMIT <cmp  > _AX, _CX                      ;; enough for pattern?
    __@@EMIT <jae  > <SHORT StkSizeOk>
    __@@EMIT <add  > _AX, <HTPAT_STK_MASK_SIZE>    ;; add this more
StkSizeOk:
    __@@EMIT <dec  > _AX                           ;; back one
    __@@EMIT <sub  > _SP, _AX                      ;; reduced it
    __@@EMIT <mov  > _DI, _SP                      ;; _DI point to the pPattern
    __@@EMIT <sub  > _SP, <HTPAT_STK_SIZE_EXTRA>   ;; reduced again
    __@@EMIT <mov  > <[_DI-HTPAT_BP_SIZE]>, _CX    ;; save the pattern size
    __@@EMIT <mov  > <[_DI-HTPAT_BP_OLDSTK]>, _DX  ;; save old stk pointer

    IFIDNI <Format>,<3PLANES>
        IFE ExtRegSet
            __@@EMIT <mov  > _AX, <WPTR OutFuncInfo.OFI_BytesPerPlane>
        ELSE
            __@@EMIT <mov  > _AX, OutFuncInfo.OFI_BytesPerPlane
        ENDIF

        __@@EMIT <mov  > <[_DI-HTPAT_BP_DATA1]>, _AX
    ENDIF

    ;
    ; now staring coping the pattern to stack
    ;

    MOV_SEG     es, ss, ax
    LDS_SI      pPattern
    MOVS_CB     _CX, dl                             ;; copy the pattern

    __@@EMIT <mov  > _BX, _DI                       ;; _BX point to the pattern start

    IFIDNI <Format>, <VGA256>
        IFE ExtRegSet
            __@@EMIT <mov  > _AX, <WPTR OutFuncInfo.OFI_BytesPerPlane + 2>
            or      _AX, _AX
            jz      SHORT DoneXlateTable
            mov     _CX, VGA256_XLATE_TABLE_SIZE
            sub     _SP, _CX
            mov     _DI, _SP
            LDS_SI  OutFuncInfo.OFI_BytesPerPlane
            MOVS_CB _CX, dl
        ELSE
            __@@EMIT <mov  > _AX, OutFuncInfo.OFI_BytesPerPlane
        ENDIF
    ENDIF

DoneXlateTable:

    IFIDNI <Format>, <1BPP>
        LDS_SI  pPrimMonoCount
    ELSE
        LDS_SI  pPrimColorCount                     ;; _SI=pPrimColorCount
    ENDIF

    LES_DI  pDest

    __@@EMIT <mov  > _BP, _BX                       ;; _BP=Pattern Start


ENDM


@EXIT_PAT_STK_RESTORE MACRO

    __@@EMIT <mov  > _BP, _SP
    __@@EMIT <mov  > _SP, <[_BP + HTPAT_SP_OLDSTK]>
    @EXIT

ENDM


WRAP_BP_PAT??   MACRO   EndWrapLoc
                Local   DoneWrap

    IFB <EndWrapLoc>
        __@@EMIT <test > bp, <HTPAT_STK_MASK>
        __@@EMIT <jnz  > <SHORT DoneWrap>
        __@@EMIT <add  > _BP, <[_BP-HTPAT_BP_SIZE]>    ;; add in pattern size
    ELSE
        __@@EMIT <test > bp, <HTPAT_STK_MASK>
        __@@EMIT <jnz  > <SHORT EndWrapLoc>
        __@@EMIT <add  > _BP, <[_BP-HTPAT_BP_SIZE]>    ;; add in pattern size
        __@@EMIT <jmp  > <SHORT EndWrapLoc>
    ENDIF

DoneWrap:

ENDM


SAVE_1BPP_DEST  MACRO

;
; Save Prim1 (DL) to Plane
;

    __@@EMIT <not  > dl                             ; invert bit
    __@@EMIT <mov  > <BPTR_ES[_DI]>, dl             ; Save Dest

ENDM


SAVE_1BPP_MASKDEST  MACRO

;
; Save Prim1 (DL) with Mask (DH, 1=Preserved, 0=Overwrite) to Dest
;

    __@@EMIT <and  > <BPTR_ES[_DI]>, dh             ; Mask overwrite bits
    __@@EMIT <not  > dx                             ; invert bit/mask
    __@@EMIT <and  > dl, dh
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM


SAVE_VGA16_DEST  MACRO

;
; Save Prim1/2/3 (DL) to Plane
;

    __@@EMIT <mov  > dh, dl
    __@@EMIT <add  > dh, 11h
    __@@EMIT <and  > dh, 88h
    __@@EMIT <or   > dl, dh
    __@@EMIT <not  > dl
    __@@EMIT <mov  > <BPTR_ES[_DI]>, dl             ; Save Dest

ENDM


SAVE_VGA16_DEST_HIGH MACRO

;
; Save Prim1 (DL) high nibble only, preserved low nibble
;


    __@@EMIT <and  > <BPTR_ES[_DI]>, 0fh            ; Mask overwrite bits
    __@@EMIT <mov  > dh, dl
    __@@EMIT <inc  > dh
    __@@EMIT <and  > dh, 08h
    __@@EMIT <or   > dl, dh
    __@@EMIT <not  > dl                             ; invert bit/mask
    __@@EMIT <shl  > dl, 4
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM


SAVE_VGA16_DEST_LOW  MACRO

;
; Save Prim1 (DL) low nibble only, preserved high nibble
;


    __@@EMIT <and  > <BPTR_ES[_DI]>, 0f0h           ; Mask overwrite bits
    __@@EMIT <mov  > dh, dl
    __@@EMIT <inc  > dh
    __@@EMIT <and  > dh, 08h
    __@@EMIT <or   > dl, dh
    __@@EMIT <xor  > dl, 0fh                        ; invert bit/mask
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM


SAVE_4BPP_DEST  MACRO

;
; Save Prim1/2/3 (DL) to Plane
;

    __@@EMIT <xor  > dl, 77h
    __@@EMIT <mov  > <BPTR_ES[_DI]>, dl             ; Save Dest

ENDM


SAVE_4BPP_DEST_HIGH MACRO
                    LOCAL   DoneVGA

;
; Save Prim1 (DL) high nibble only, preserved low nibble
;


    __@@EMIT <and  > <BPTR_ES[_DI]>, 0fh            ; Mask overwrite bits
    __@@EMIT <xor  > dl, 07h                        ; Invert bits
    __@@EMIT <shl  > dl, 4                          ; move to high nibble
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM


SAVE_4BPP_DEST_LOW  MACRO
                    LOCAL   DoneVGA
;
; Save Prim1 (DL) low nibble only, preserved high nibble
;


    __@@EMIT <and  > <BPTR_ES[_DI]>, 0f0h           ; Mask overwrite bits
    __@@EMIT <xor  > dl, 07h                        ; invert bit/mask
    __@@EMIT <or   > <BPTR_ES[_DI]>, dl             ; Save Plane1=Prim3

ENDM



SAVE_3PLANES_DEST  MACRO   UseAX

;
; Save Prim1/2/3 (CL:CH:DL) to Plane3/2/1
;

    IFB <UseAX>
        __@@EMIT <push > _BP                        ; save Prim1/2
    ELSE
        __@@EMIT <mov  > _AX, _BP                   ; save _BP
    ENDIF

    __@@EMIT <and  > _BP, <HTPAT_NOT_STK_MASK>      ; to HTPAT_BP_xxx
    __@@EMIT <mov  > _BP, <[_BP - HTPAT_BP_DATA1]>  ; size of plane

    __@@EMIT <not  > cx                             ; invert the bits
    __@@EMIT <not  > dl                             ; invert bit

    __@@EMIT <mov  > <BPTR_ES[      _DI]>, dl       ; Save Plane1=Prim3
    __@@EMIT <mov  > <BPTR_ES[_BP + _DI]>, ch       ; save Plane2=Prim2

    IFE ExtRegSet
        __@@EMIT <add  > _BP, _BP                   ; goto plane3
        __@@EMIT <mov  > <BPTR_ES[_BP+_DI]>, cl     ; save Plane3=Prim1
    ELSE
        __@@EMIT <mov  > <BPTR_ES[(_BP*2)+_DI]>, cl ; save Plane3=Prim1
    ENDIF

    IFB <UseAX>
        __@@EMIT <pop  > _BP                        ; restore _BP
    ELSE
        __@@EMIT <mov  > _BP, _AX                   ; restore _BP
    ENDIF

ENDM



SAVE_3PLANES_MASKDEST  MACRO   UseAX
;
; Save Prim1/2/3 (CL:CH:DL) with Mask (DH, 1=Preserved, 0=Overwrite) to
; Plane3/2/1
;

    IFB <UseAX>
        __@@EMIT <push > _BP                        ; save Prim1/2
    ELSE
        __@@EMIT <mov  > _AX, _BP                   ; save _BP
    ENDIF

    __@@EMIT <and  > _BP, <HTPAT_NOT_STK_MASK>      ; to HTPAT_BP_xxx
    __@@EMIT <mov  > _BP, <[_BP - HTPAT_BP_DATA1]>  ; size of plane

    __@@EMIT <not  > cx                             ; invert the bits
    __@@EMIT <not  > dx                             ; invert bit/mask
    __@@EMIT <and  > cl, dh                         ; mask preserved bits
    __@@EMIT <and  > ch, dh
    __@@EMIT <and  > dl, dh
    __@@EMIT <not  > dh                             ; for dest mask

    __@@EMIT <and  > <BPTR_ES[      _DI]>, dh       ; Mask overwrite bits
    __@@EMIT <or   > <BPTR_ES[      _DI]>, dl       ; Save Plane1=Prim3

    __@@EMIT <and  > <BPTR_ES[_BP + _DI]>, dh       ; Mask overwrite bits
    __@@EMIT <or   > <BPTR_ES[_BP + _DI]>, ch       ; save Plane2=Prim2

    IFE ExtRegSet
        __@@EMIT <add  > _BP, _BP                       ; goto plane3
        __@@EMIT <and  > <BPTR_ES[_BP + _DI]>, dh       ; Mask overwrite bits
        __@@EMIT <or   > <BPTR_ES[_BP + _DI]>, cl       ; save Plane3=Prim1
    ELSE
        __@@EMIT <and  > <BPTR_ES[(_BP*2) + _DI]>, dh   ; Mask overwrite bits
        __@@EMIT <or   > <BPTR_ES[(_BP*2) + _DI]>, cl   ; save Plane3=Prim1
    ENDIF

    IFB <UseAX>
        __@@EMIT <pop  > _BP                        ; restore _BP
    ELSE
        __@@EMIT <mov  > _BP, _AX                   ; restore _BP
    ENDIF
ENDM


.LIST



SUBTTL  SingleCountOutputTo1BPP
PAGE

COMMENT `


Routine Description:

    This function output to the BMF_1BPP destination surface from
    PRIMMONO_COUNT data structure array.

Arguments:

    pPrimMonoCount  - Pointer to the PRIMMONO_COUNT data structure array.

    pDest           - Pointer to first modified destination byte

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


`


@BEG_PROC   SingleCountOutputTo1BPP <pPrimMonoCount:DWORD,  \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;
; Register Usage:
;
; _SI           = pPrimMonoCount
; _DI           = pDestination
; _BP           = Self host pPattern
; al:ah         = Prim1/2
; dl            = DestByte
; dh            = DestMask


        @ENTER_PAT_TO_STK   <1BPP>      ; _BP=Pat location, fall throug to load

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _DX, 1ffh               ; dh=Mask (1=Mask, 0=Not Mask)
        MOVZX_W _CX, <WPTR [_SI]>       ; load extended
        sub     _BP, _CX                ; back the _BP
        shl     _DX, cl                 ; set first mask
        xor     dl, dl                  ; clear Prim1
        jmp     short LoadByte


;============================================================================
; EOF encountered, if Mask (DH) is equal to 0x01 then we just starting the new
; byte, which we just have exactly end at last byte boundary (no last byte
; mask), otherwise, shift all destination byte to left by count, then mask it
;============================================================================
; EOF encountered, if count is 0, then there is no last byte mask, so just
; exit, otherwise, shift all destination byte to left by count, then mask it
;============================================================================

EOFDest:
        cmp     dh, 1
        jz      short AllDone                   ; finished

EOFDestMask:
        mov     cx, WPTR [_SI]                  ; get LastByteSkips

        xor     ah, ah                          ; ax=0xffff now, clear ah
        shl     ax, cl                          ; ah=LastByteMask
        shl     dx, cl                          ; shift Mask+Prim1
        or      dh, ah                          ; add in dh=mask
        cmp     dh, 0ffh                        ; if dh=0xff then all masked
        jz      short AllDone

        SAVE_1BPP_MASKDEST                      ; save last byte

AllDone:
        @EXIT_PAT_STK_RESTORE


;==========================================================================
; An invalid density is encountered, (0xff to indicate the stretch must not
; update to the destination), if this is the last stretch then do 'EOFDest'
; otherwise set mask bits until the byte boundary is encountered then fall
; through to load next byte, if a byte boundary is before count are exausted
; then save that mask byte and it will automatically skip rest of the pels.
;==========================================================================

InvDensity:
        cmp     al, ah
        jz      short EOFDest                   ; EOF
        add     dx, dx
        inc     dh                              ; add in mask, 'C' not changed
        jc      short DoneOneByte               ; finished? if not fall through

LoadByte:
        add     _SI, SIZE_PMC                   ; sizeof(PRIMMONO_COUNT)
        mov     ax, WPTR [_SI+2]                ; al:ah=Prim 1/2
        dec     _BP                             ; ready to access pattern
        cmp     al, PRIM_INVALID_DENSITY
        jz      short InvDensity
        cmp     al, BPTR[_BP]                   ; check with pattern
        adc     dx, dx
        jnc     short LoadByte

DoneOneByte:
        or      dh, dh                          ; any mask?
        jnz     short HasDestMask

        SAVE_1BPP_DEST                          ; save it, no jmp

ReadyNextByte:
        inc     _DI
        mov     _DX, 0100h                      ; dh=0x01=Boundary test bit

        WRAP_BP_PAT??   <LoadByte>

HasDestMask:
        cmp     dh, 0ffh
        jz      short ReadyNextByte             ;

        SAVE_1BPP_MASKDEST                      ; save it with DH=mask

        jmp     short ReadyNextByte


@END_PROC



SUBTTL  VarCountOutputTo1BPP
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_1BPP destination surface from
    PRIMMONO_COUNT data structure array.

Arguments:

    pPrimMonoCount  - Pointer to the PRIMMONO_COUNT data structure array.

    pDest           - Pointer to first modified destination byte

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


`


@BEG_PROC   VarCountOutputTo1BPP    <pPrimMonoCount:DWORD,  \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;
; Register Usage:
;
; _SI           = pPrimMonoCount
; _DI           = pDestination
; _BP           = Self host pPattern
; cx            = PrimMonoCount.Count
; al:ah         = Prim1/2
; dl            = DestByte
; dh            = DestMask
;


        @ENTER_PAT_TO_STK   <1BPP>      ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _DX, 1ffh               ; dh=Mask (1=Mask, 0=Not Mask)
        MOVZX_W _CX, <WPTR [_SI]>       ; load extended
        sub     _BP, _CX                ; back the _BP
        shl     _DX, cl                 ; set first mask
        xor     dl, dl                  ; clear Prim1
        jmp     short LoadByte

;============================================================================
; EOF encountered, if Mask (DH) is equal to 0x01 then we just starting the new
; byte, which we just have exactly end at last byte boundary (no last byte
; mask), otherwise, shift all destination byte to left by count, then mask it
;============================================================================
; EOF encountered, if count is 0, then there is no last byte mask, so just
; exit, otherwise, shift all destination byte to left by count, then mask it
;============================================================================

EOFDest:
        jcxz    short AllDone                   ; if cx=0 then done

EOFDestMask:
        xor     ah, ah                          ; ax=0xffff now, clear ah
        shl     ax, cl                          ; ah=LastByteMask
        shl     dx, cl                          ; shift Mask+Prim1
        or      dh, ah                          ; add in dh=mask
        cmp     dh, 0ffh                        ; if dh=0xff then all masked
        jz      short AllDone

        SAVE_1BPP_MASKDEST                      ; save it with DH=mask

AllDone:
        @EXIT_PAT_STK_RESTORE                   ; restore original SP

;==========================================================================
; An invalid density is encountered, (0xff to indicate the stretch must not
; update to the destination), if this is the last stretch then do 'EOFDest'
; otherwise set mask bits until the byte boundary is encountered then fall
; through to load next byte, if a byte boundary is before count are exausted
; then save that mask byte and it will automatically skip rest of the pels.
;==========================================================================

InvDensity:
        cmp     al, ah
        jz      short EOFDest                   ; done
InvDensityLoop:
        dec     _BP
        add     dx, dx
        inc     dh                              ; add in mask, 'C' not changed
        jc      short DoneOneByte
        dec     cx
        jnz     short InvDensityLoop            ; !!! FALL THROUGH

LoadByte:
        add     _SI, SIZE_PMC                   ; sizeof(PRIMMONO_COUNT)
        mov     cx, WPTR [_SI]                  ; cx=Count
        mov     ax, WPTR [_SI+2]                ; al:ah=Prim1/2
        cmp     al, PRIM_INVALID_DENSITY        ; a skip?, if yes go do it
        jz      short InvDensity
        inc     cx                              ; make it no jump
MakeByte:
        dec     cx
        jz      short LoadByte
        dec     _BP                             ; ready to access pattern
        mov     ah, BPTR[_BP]                   ; get pattern
        cmp     al, ah
        adc     dx, dx
        jnc     short MakeByte                  ; if carry then byte boundary

DoneOneByte:
        or      dh, dh                          ; any mask?
        jnz     short HasDestMask               ; yes

        SAVE_1BPP_DEST                          ; save it

ReadyNextByte:
        inc     _DI                             ; ++pDest
        mov     _DX, 0100h                      ; dh=0x01, dl=0x00

        WRAP_BP_PAT??   <MakeByte>

;=============================================================================
; Mask the destination by DH mask, (1 bit=Mask), if whole destiantion byte is
; masked then just increment the pDest
;=============================================================================

HasDestMask:
        cmp     dh, 0ffh
        jz      short DoneDestMask

        SAVE_1BPP_MASKDEST                      ; save it with DH=mask

DoneDestMask:
        cmp     al, PRIM_INVALID_DENSITY        ; is last one a skip stretch?
        jnz     short ReadyNextByte
        cmp     cx, 1                           ; more than 0 count?
        jbe     short ReadyNextByte             ; no, continue

        ;
        ;*** FALL THROUGH
        ;

;============================================================================
; skip the 'cx-1' count of pels on the destination (SI is post decrement so
; we must only skip 'cxi-1' count), it will skip the 'pDest', set up next
; pDest mask, also it will aligned the destination pattern pointer (_BP)
;===========================================================================

SkipDestPels:
        inc     _DI                             ; update to current pDest

        dec     cx                              ; back one
        WZXE    cx                              ; zero extended
        mov     _AX, _CX                        ; _AX=_CX=Count
        and     cl, 7
        ;===============================================================
        mov     _DX, 1ffh                       ; ready to shift
        shl     _DX, cl                         ; Boundary Bit + MASK
        xor     dl, dl                          ; clear Prim1
        ;================================================================
        mov     _CX, _AX                        ; get count again
        shr     _CX, 3
        add     _DI, _CX                        ; pDest += (Count >> 3)
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     LoadByte



@END_PROC



SUBTTL  SingleCountOutputTo3Planes
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_1BPP_3PLANES destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    18-Jun-1991 Tue 12:00:35 updated  -by-  Daniel Chou (danielc)
        Fixed destination masking bugs, it should be 0xff/0x00 rather 0x77

`


@BEG_PROC   SingleCountOutputTo3Planes  <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>


;
; Register Usage:
;
; _SI       = pPrimMonoCount
; _BP       = Self host pPattern
; _SP       = Some saved environment (Old BP to get to the local variable)
; bl:bh:al  = Prim 1/2/3
; cl:ch:dl  = Current Destination Byte, 0x88 is the mask bit indicator
; dh        = Dest Mask
;
;   Prim1 -> pPlane3 <---- Highest bit
;   Prim2 -> pPlane2
;   Prim3 -> pPlane1 <---- Lowest bit
;
; Local Variable access from Old BP, BytesPerPlane
;


        @ENTER_PAT_TO_STK   <3PLANES>   ; _BP=Pat location, fall throug to load

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _DX, 1ffh               ; dh=Mask (1=Mask, 0=Not Mask)
        MOVZX_W _CX, <WPTR [_SI]>       ; load extended
        sub     _BP, _CX                ; back the _BP
        shl     _DX, cl                 ; set first mask
        xor     dl, dl
        xor     _CX, _CX                ; clear cx now
        jmp     short LoadByte


;============================================================================
; EOF encountered, if Mask (DH) is equal to 0x01 then we just starting the new
; byte, which we just have exactly end at last byte boundary (no last byte
; mask), otherwise, shift all destination byte to left by count, then mask it
;============================================================================
; EOF encountered, if count is 0, then there is no last byte mask, so just
; exit, otherwise, shift all destination byte to left by count, then mask it
;============================================================================

EOFDest:
        cmp     dh, 1
        jz      short AllDone                   ; finished

EOFDestMask:
        mov     ax, cx                          ; save Prim1/2=al:ah
        mov     cx, WPTR [_SI]                  ; get LastByteSkips

        xor     bh, bh                          ; bx=0xffff now, clear bh
        shl     bx, cl                          ; bh=LastByteMask
        shl     dx, cl                          ; shift Mask+Prim3
        or      dh, bh                          ; add in dh=mask
        cmp     dh, 0ffh                        ; if dh=0xff then all masked
        jz      short AllDone

        shl     ax, cl                          ; shift Prim1/2
        mov     cx, ax                          ; restore cl:ch=Prim1/2

        SAVE_3PLANES_MASKDEST <UseAX>           ; save last byte

AllDone:
        @EXIT_PAT_STK_RESTORE                   ; exit/restore env/stack


;==========================================================================
; An invalid density is encountered, (0xff to indicate the stretch must not
; update to the destination), if this is the last stretch then do 'EOFDest'
; otherwise set mask bits until the byte boundary is encountered then fall
; through to load next byte, if a byte boundary is before count are exausted
; then save that mask byte and it will automatically skip rest of the pels.
;==========================================================================

InvDensity:
        cmp     bl, bh
        jz      short EOFDest                   ; EOF
        add     cx, cx
        add     dx, dx
        inc     dh                              ; add in mask, 'C' not changed
        jc      short DoneOneByte               ; finished? if not fall through

LoadByte:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                ; bl:bh:al:ah=Prim 1/2/3/4
        mov     ax, WPTR [_SI+4]
        dec     _BP                             ; ready to access pattern
        cmp     bl, PRIM_INVALID_DENSITY
        jz      short InvDensity
        mov     ah, BPTR[_BP]                   ; get pattern
        cmp     bl, ah
        adc     cl, cl
        cmp     bh, ah
        adc     ch, ch
        cmp     al, ah
        adc     dx, dx
        jnc     short LoadByte

DoneOneByte:
        or      dh, dh                          ; any mask?
        jnz     short HasDestMask

        SAVE_3PLANES_DEST <UseAX>               ; save it, no jmp

ReadyNextByte:
        inc     _DI
        xor     _CX, _CX                        ; clear destination
        mov     _DX, 0100h                      ; dh=0x01=Boundary test bit

        WRAP_BP_PAT??   <LoadByte>

HasDestMask:
        cmp     dh, 0ffh
        jz      short ReadyNextByte             ;

        SAVE_3PLANES_MASKDEST <UseAX>           ; save it with DH=mask

        jmp     short ReadyNextByte


@END_PROC



SUBTTL  VarCountOutputTo3Planes
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_1BPP_3PLANES destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    18-Jun-1991 Tue 12:00:35 updated  -by-  Daniel Chou (danielc)
        Fixed destination masking bugs, it should be 0xff/0x00 rather 0x77


`



@BEG_PROC   VarCountOutputTo3Planes <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;
; Register Usage:
;
; _SI       = pPrimColorCount
; _BP       = Self host pPattern
; _SP       = Some saved environment (Old BP to get to the local variable)
; di        = pPlane1
; bl:bh:al  = Prim 1/2/3
; cl:ch:dl  = Current Destination Byte, 0x88 is the mask bit indicator
; dh        = Dest Mask
;
;   Prim1 -> pPlane3 <---- Highest bit
;   Prim2 -> pPlane2
;   Prim3 -> pPlane1 <---- Lowest bit
;
; Local Variable access from Old BP, BytesPerPlane
;


        @ENTER_PAT_TO_STK   <3PLANES>   ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _DX, 1ffh               ; dh=Mask (1=Mask, 0=Not Mask)
        MOVZX_W _CX, <WPTR [_SI]>       ; load extended
        sub     _BP, _CX                ; back the _BP
        shl     _DX, cl                 ; set first mask
        xor     dl, dl
        xor     _CX, _CX                ; clear cx now
        jmp     short FirstLoadByte

;============================================================================
; EOF encountered, if Mask (DH) is equal to 0x01 then we just starting the new
; byte, which we just have exactly end at last byte boundary (no last byte
; mask), otherwise, shift all destination byte to left by count, then mask it
;============================================================================
; EOF encountered, if count is 0, then there is no last byte mask, so just
; exit, otherwise, shift all destination byte to left by count, then mask it
;============================================================================

EOFDest:
        or      si, si
        jz      short AllDone

EOFDestMask:
        xchg    si, cx                          ; si=Prim1/2, cx=Last Skips

        xor     bh, bh                          ; bx=0xffff now, clear bh
        shl     bx, cl                          ; bh=LastByteMask
        shl     dx, cl                          ; shift Mask+Prim3
        or      dh, bh                          ; add in dh=mask
        cmp     dh, 0ffh                        ; if dh=0xff then all masked
        jz      short AllDone

        shl     si, cl                          ; shift Prim1/2
        mov     cx, si                          ; restore cl:ch=Prim1/2

        SAVE_3PLANES_MASKDEST                   ; save it with DH=mask

AllDone:
        pop     _SI                             ; pop the source pointer push
        @EXIT_PAT_STK_RESTORE                   ; restore original SP

;==========================================================================
; An invalid density is encountered, (0xff to indicate the stretch must not
; update to the destination), if this is the last stretch then do 'EOFDest'
; otherwise set mask bits until the byte boundary is encountered then fall
; through to load next byte, if a byte boundary is before count are exausted
; then save that mask byte and it will automatically skip rest of the pels.
;==========================================================================

InvDensity:
        cmp     bl, bh
        jz      short EOFDest                   ; done
InvDensityLoop:
        dec     _BP
        add     cx, cx
        add     dx, dx
        inc     dh                              ; add in mask, 'C' not changed
        jc      short DoneOneByte
        dec     si
        jnz     short InvDensityLoop            ; !!! FALL THROUGH

LoadByte:
        pop     _SI                             ; restore _SI
FirstLoadByte:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        push    _SI                             ; save _SI
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim1/2
        mov     ax, WPTR [_SI+4]                ; al:ah=Prim3/4
        mov     si, WPTR [_SI]                  ; si=Count
        cmp     bl, PRIM_INVALID_DENSITY        ; a skip?, if yes go do it
        jz      short InvDensity
        inc     si                              ; make it no jump
MakeByte:
        dec     si
        jz      short LoadByte
        dec     _BP                             ; ready to access pattern
        mov     ah, BPTR[_BP]                   ; get pattern
        cmp     bl, ah
        adc     cl, cl
        cmp     bh, ah
        adc     ch, ch
        cmp     al, ah
        adc     dx, dx
        jnc     short MakeByte                  ; if carry then byte boundary

DoneOneByte:
        or      dh, dh                          ; any mask?
        jnz     short HasDestMask               ; yes

        SAVE_3PLANES_DEST                       ; save it

ReadyNextByte:
        inc     _DI                             ; ++pDest
        xor     _CX, _CX                        ; clear destination
        mov     _DX, 0100h                      ; dh=0x01, dl=0x00

        WRAP_BP_PAT??   <MakeByte>

;=============================================================================
; Mask the destination by DH mask, (1 bit=Mask), if whole destiantion byte is
; masked then just increment the pDest
;=============================================================================

HasDestMask:
        cmp     dh, 0ffh
        jz      short DoneDestMask

        SAVE_3PLANES_MASKDEST                   ; save it with DH=mask

DoneDestMask:
        cmp     bl, PRIM_INVALID_DENSITY        ; is last one a skip stretch?
        jnz     short ReadyNextByte
        cmp     si, 1                           ; more than 0 count?
        jbe     short ReadyNextByte             ; no, continue

        ;
        ;*** FALL THROUGH
        ;

;============================================================================
; skip the 'si-1' count of pels on the destination (SI is post decrement so
; we must only skip 'si-1' count), it will skip the 'pDest', set up next
; pDest mask, also it will aligned the destination pattern pointer (_BP)
;===========================================================================

SkipDestPels:
        inc     _DI                             ; update to current pDest

        dec     si                              ; back one
        WZXE    si                              ; zero extended
        mov     cx, si
        and     cl, 7
        ;===============================================================
        mov     _DX, 1ffh                       ; ready to shift
        shl     _DX, cl
        xor     dl, dl                          ; clear Prim3
        xor     _CX, _CX                        ; clear Prim1/2
        ;================================================================
        mov     _BX, _SI
        shr     _BX, 3
        add     _DI, _BX
        mov     _BX, _BP
        and     _BX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _BX                        ; clear _BP mask=pPattern
        sub     _BX, _SI                        ; see if > 0?
        jg      short DoneSkipDestPels
        mov     _SI, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _BX, _SI
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _BX                        ; _BP=pCurPat
        jmp     LoadByte


@END_PROC




SUBTTL  SingleCountOutputTo4BPP
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


`

@BEG_PROC   SingleCountOutputTo4BPP <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; bl:bh:al:ah   : Prim 1/2/3/4          =====> Bit 2:1:0
; dl            : DestByte
; dh            : scratch register
; ch            : PRIM_INVALID_DENSITY
; cl            : PRIM_INVALID_DENSITY --> CX = PRIMCOUNT_EOF
;==========================================


        @ENTER_PAT_TO_STK   <4BPP>                  ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        mov     _CX, PRIMCOUNT_EOF
        xor     _DX, _DX                            ; clear mask/dest
        cmp     WPTR [_SI], dx                      ; check if begin with skip
        jnz     short InvDensityHStart              ; has first skip

LoadByteH:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, ch                              ; invalid?
        jz      short InvDensityH
        mov     ax, WPTR [_SI+4]                    ; al:ah=Prim 3/4

MakeByteH:
        dec     _BP
        mov     dh, BPTR [_BP]
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

LoadByteL:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, ch                              ; invalid?
        jz      short InvDensityL
        mov     ax, WPTR [_SI+4]                    ; al:ah=Prim 3/4

MakeByteL:
        add     dl, dl
        dec     _BP
        mov     dh, BPTR [_BP]
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        SAVE_4BPP_DEST

ReadyNextByte:
        inc     _DI
        xor     _DX, _DX

        WRAP_BP_PAT?? <LoadByteH>

;=============================================================================
; The high nibble need to be skipped, (byte boundary now), if bl=bh=INVALID
; then we are done else set the mask=0xf0 (high nibble) and if count > 1 then
; continune load LOW nibble
;=============================================================================

InvDensityH:
        cmp     bl, bh                          ; end?
        jz      short AllDone                   ; exactly byte boundary
InvDensityHStart:
        dec     _BP                             ; update pCurPat
LoadByteL2:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim 1/2
        cmp     bl, ch                          ; invalid?
        jz      short DoneDestMask
        mov     ax, WPTR [_SI+4]                ; al:ah=Prim 3/4

MakeByteL2:
        add     dl, dl                          ; skip high bit
        mov     dh, BPTR [_BP-1]                ; load next pattern
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        SAVE_4BPP_DEST_LOW                      ; fall through

DoneDestMask:
        dec     _BP
        cmp     bx, cx                          ; done?
        jnz     short ReadyNextByte
        jmp     short AllDone

InvDensityL:
        SAVE_4BPP_DEST_HIGH
        dec     _BP
        cmp     bx, cx
        jnz     short ReadyNextByte

AllDone:
        @EXIT_PAT_STK_RESTORE


@END_PROC




SUBTTL  VarCountOutputTo4BPP
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

`

@BEG_PROC   VarCountOutputTo4BPP    <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>

;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cx            : PrimColorCount.Count
; bl:bh:al:ah   : Prim 1/2/3/4         =====> Bit 2:1:0
; dl            : DestByte
; dh            : Scratch Register
;==========================================


        @ENTER_PAT_TO_STK   <4BPP>          ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        xor     _DX, _DX                            ; clear mask/dest
        mov     cx, WPTR [_SI]
        or      cx, cx
        jnz     short InvDensityHStart              ; has first skip

LoadByteH:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                      ; cx=count
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short InvDensityH
        mov     ax, WPTR [_SI+4]                    ; al:ah=Prim 3/4
        inc     cx

LoadByteH1:
        dec     cx
        jz      short LoadByteH

MakeByteH:
        dec     _BP
        mov     dh, BPTR [_BP]
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        dec     cx                                  ;
        jz      short LoadByteL

MakeByteL:
        add     dl, dl                              ; skip high bit
        dec     _BP
        mov     dh, BPTR [_BP]
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        SAVE_4BPP_DEST

ReadyNextByte:
        inc     _DI
        xor     _DX, _DX

        WRAP_BP_PAT?? <LoadByteH1>


;=============================================================================
; The high nibble need to be skipped, (byte boundary now), if bl=bh=INVALID
; then we are done else set the mask=0xf0 (high nibble) and if count > 1 then
; continune load LOW nibble
;=============================================================================

LoadByteL:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                  ; cx=count
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim 1/2
        mov     ax, WPTR [_SI+4]                ; al:ah=Prim 3/4
        cmp     bl, PRIM_INVALID_DENSITY        ; invalid?
        jnz     short MakeByteL

        SAVE_4BPP_DEST_HIGH                     ; save only high nibble

        jmp     short DoneDestMask

InvDensityH:
        cmp     bl, bh                          ; end?
        jz      short AllDone                   ; exactly byte boundary

InvDensityHStart:
        dec     _BP                             ; update pCurPat
        dec     cx
        jnz     short DoneDestMask

LoadByteL2:
        add     _SI, SIZE_PCC                   ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                  ; cx=count
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY        ; invalid?
        jz      short DoneDestMask
        mov     ax, WPTR [_SI+4]                ; al:ah=Prim 3/4

MakeByteL2:
        add     dl, dl                          ; skip high bit
        mov     dh, BPTR [_BP-1]                ; load next pattern
        cmp     bl, dh
        adc     dl, dl
        cmp     bh, dh
        adc     dl, dl
        cmp     al, dh
        adc     dl, dl

        SAVE_4BPP_DEST_LOW                      ; fall through

DoneDestMask:
        dec     _BP
        cmp     bl, PRIM_INVALID_DENSITY        ; is last one a skip stretch?
        jnz     short ReadyNextByte
        cmp     bl, bh                          ; end?
        jz      short AllDone
        cmp     cx, 1
        jbe     short ReadyNextByte

;============================================================================
; skip the 'cx-1' count of pels on the destination (SI is post decrement so
; we must only skip 'cx-1' count), it will skip the 'pDest', set up next
; pDest mask, also it will aligned the destination pattern pointer (_BP)
;===========================================================================

SkipDestPels:
        inc     _DI                             ; update to current pDest
        xor     _DX, _DX                        ;

        dec     cx
        WZXE    cx                              ; zero extended
        mov     _AX, _CX
        shr     _CX, 1                          ; see if carry
        sbb     dh, dh                          ; -1=skip high nibble
        add     _DI, _CX                        ; 2 pels per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        or      dh, dh
        jnz     short LoadByteL2
        jmp     LoadByteH

AllDone:
        @EXIT_PAT_STK_RESTORE


@END_PROC




SUBTTL  SingleCountOutputToVGA16
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_VGA16 destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


`

@BEG_PROC   SingleCountOutputToVGA16    <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>

;
; VGA 16 Standard table
;
;   0,   0,   0,    0000    0   Black
;   0,  ,0,   0x80  0001    1   Dark Red
;   0,   0x80,0,    0010    2   Dark Green
;   0,  ,0x80,0x80  0011    3   Dark Yellow
;   0x80 0,   0,    0100    4   Dark Blue
;   0x80,0,   0x80  0101    5   Dark Magenta
;   0x80 0x80,0,    0110    6   Dark Cyan
;   0x80,0x80,0x80  0111    7   Gray 50%
;
;   0xC0,0xC0,0xC0  1000    8   Gray 75%
;   0,  ,0,   0xFF  1001    9   Red
;   0,   0xFF,0,    1010    10  Green
;   0,  ,0xFF,0xFF  1011    11  Yellow
;   0xFF 0,   0,    1100    12  Blue
;   0xFF,0,   0xFF  1101    13  Magenta
;   0xFF 0xFF,0,    1110    14  Cyan
;   0xFF,0xFF,0xFF  1111    15  White
;
;==========================================
; Register Usage:
;
; _SI               : pPrimColorCount
; _DI               : pDest
; _BP               : Current pPattern, self wrappable
; bl:bh:dl:dh       : Prim 1/2/5/6  Prim6 is Index for VGA16ColorIndex[]
; cl                : PRIM_INVALID_DENSITY
; ch                : ZERO (0)
; al                : Pattern/Low Nibble
; ah                : High nibble
;
; Prim1 = Initial VGA16ColorIndex[]
; Prim2 = Color Thresholds for VGA16ColorIndex[Prim1]
; Prim3 = Color Thresholds for VGA16ColorIndex[Prim1-1]
; Prim4 = Color Thresholds for VGA16ColorIndex[Prim1-2]
; Prim5 = Color Thresholds for VGA16ColorIndex[Prim1-3]
; Prim6 = Color Thresholds for VGA16ColorIndex[Prim1-4]
; ELSE                         VGA16ColorIndex[Prim1-5]
;=========================================================================
;


        @ENTER_PAT_TO_STK   <VGA16>                 ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        xor     _BX, _BX                        ; clear high word
        sub     _SI, SIZE_PCC
        cmp     WPTR [_SI + SIZE_PCC], bx       ; check if begin with skip
        mov     cl, PRIM_INVALID_DENSITY
        jz      SHORT DoHNibble
        add     _SI, SIZE_PCC
        jmp     SHORT SkipPelsH_2               ; skip from the first pel

AllDone:
        @EXIT_PAT_STK_RESTORE


SkipPelsH:
        add     _SI, (SIZE_PCC * 2)
        mov     bx, WPTR [_SI+2]
        cmp     bl, PRIM_INVALID_DENSITY
        jnz     SHORT LoadHNibble

SkipPelsH_1:
        cmp     bl, bh
        jz      SHORT AllDone

SkipPelsH_2:
        sub     _BP, 2

SkipPelsL:
        mov     bx, WPTR [_SI+SIZE_PCC+2]
        cmp     bl, PRIM_INVALID_DENSITY
        jz      SHORT SkipPelsL_1

        mov     ah, BPTR_ES[_DI]                ; start from Low nibble so
        mov     cl, BPTR [_BP]                  ; get pattern
        jmp     SHORT LoadLNibble               ; we must load current dest

SaveLNibbleAndSkip:
        and     BPTR_ES[_DI], 0fh               ; clear high nibble
        and     ah, 0f0h                        ; clear low nibble
        or      BPTR_ES[_DI], ah                ; save it in

SkipPelsL_1:
        cmp     bl, bh
        jz      SHORT AllDone
        inc     _DI                             ; skip the destination

        WRAP_BP_PAT?? <SkipPelsH>               ; repeat until no more skips



DoHNibble:
        add     _SI, (SIZE_PCC * 2)
        mov     bx, WPTR [_SI+2]                ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY
        jz      SHORT SkipPelsH_1

LoadHNibble:
        sub     _BP, 2
        mov     cx, WPTR [_BP]

;
;===================================================================
        ;  2    4     6
        ; +-+ +--+  +--+
        ;  1  2  3  4  5
        ; bh:cl:ch:dl:dh
        ;--------------------------

IFE ExtRegSet
        mov     dx, WPTR [_SI+4]                ; Color 2/3
        cmp     dh, ch                          ; first split in the middle
        jae     SHORT GetH1                     ; [ie. binary search/compare]
        mov     dx, WPTR [_SI+6]                ; now check if Prim4/5
ELSE
        mov     _DX, DPTR [_SI+4]
        cmp     dh, ch                          ; first split in the middle
        jae     SHORT GetH1                     ; [ie. binary search/compare]
        shr     _DX, 16
ENDIF

        cmp     dl, ch
        sbb     bl, 3                           ; one of  -3/-4/-5
        cmp     dh, ch
        jmp     SHORT GetH2

GetH1:  cmp     bh, ch                          ; it is white
        jae     SHORT GetHNibble
        dec     bl
        cmp     dl, ch

GetH2:  sbb     bl, 0

;
;===================================================================
;

GetHNibble:
        xor     bh, bh
        mov     ah, BPTR cs:VGA16ColorIndex[_BX]


DoLNibble:
        mov     bx, WPTR [_SI+SIZE_PCC+2]       ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY
        jz      SHORT SaveLNibbleAndSkip

LoadLNibble:

;
;===================================================================
        ;  2    4     6
        ; +-+ +--+  +--+
        ;  1  2  3  4  5
        ; bh:cl:ch:dl:dh
        ;--------------------------

IFE ExtRegSet
        mov     dx, WPTR [_SI+SIZE+PCC+4]       ; Color 2/3
        cmp     dh, cl                          ; first split in the middle
        jae     SHORT GetL1                     ; [ie. binary search/compare]
        mov     dx, WPTR [_SI+SIZE+PCC+6]       ; now check if Prim4/5
ELSE
        mov     _DX, DPTR [_SI+SIZE_PCC+4]
        cmp     dh, cl                          ; first split in the middle
        jae     SHORT GetL1                     ; [ie. binary search/compare]
        shr     _DX, 16
ENDIF

        cmp     dl, cl
        sbb     bl, 3                           ; one of  -3/-4/-5
        cmp     dh, cl
        jmp     SHORT GetL2

GetL1:  cmp     bh, cl                          ; it is white
        jae     SHORT GetLNibble
        dec     bl
        cmp     dl, cl

GetL2:  sbb     bl, 0

;
;===================================================================
;

GetLNibble:

        xor     bh, bh
        mov     al, BPTR cs:VGA16ColorIndex[_BX]
        and     ax, 0f00fh
        or      al, ah
        stosb

        WRAP_BP_PAT??   <DoHNibble>



@END_PROC





SUBTTL  VarCountOutputToVGA16
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

`

@BEG_PROC   VarCountOutputToVGA16   <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;
; VGA 16 Standard table
;
;   0,   0,   0,    0000    0   Black
;   0,  ,0,   0x80  0001    1   Dark Red
;   0,   0x80,0,    0010    2   Dark Green
;   0,  ,0x80,0x80  0011    3   Dark Yellow
;   0x80 0,   0,    0100    4   Dark Blue
;   0x80,0,   0x80  0101    5   Dark Magenta
;   0x80 0x80,0,    0110    6   Dark Cyan
;   0x80,0x80,0x80  0111    7   Gray 50%
;
;   0xC0,0xC0,0xC0  1000    8   Gray 75%
;   0,  ,0,   0xFF  1001    9   Red
;   0,   0xFF,0,    1010    10  Green
;   0,  ,0xFF,0xFF  1011    11  Yellow
;   0xFF 0,   0,    1100    12  Blue
;   0xFF,0,   0xFF  1101    13  Magenta
;   0xFF 0xFF,0,    1110    14  Cyan
;   0xFF,0xFF,0xFF  1111    15  White
;
;==========================================
; Register Usage:
;
; _SI               : pPrimColorCount
; _DI               : pDest
; _BP               : Current pPattern, self wrappable
; ax                : PrimColorCount.Count
; bl:bh:cl:ch:dl:dh : Prim 1/2/3/4/5/6
;==========================================
; Prim1 = Initial VGA16ColorIndex[]
; Prim2 = Color Thresholds for VGA16ColorIndex[Prim1]
; Prim3 = Color Thresholds for VGA16ColorIndex[Prim1-1]
; Prim4 = Color Thresholds for VGA16ColorIndex[Prim1-2]
; Prim5 = Color Thresholds for VGA16ColorIndex[Prim1-3]
; Prim6 = Color Thresholds for VGA16ColorIndex[Prim1-4]
; ELSE                         VGA16ColorIndex[Prim1-5]
;=========================================================================
;


        @ENTER_PAT_TO_STK   <VGA16>             ; _BP=Pat location

;=============================================================================
; the DH has two uses, it contains the mask bits (1 bit=Mask), and it also
; contains an extra bit to do a byte boundary test, every time we shift the
; mask left by one, the boundary bit get shift to left, when first time a
; carry is produced then we know we finished one byte. at here we set up the
; dh=FirstMask + Aligned boundary bit
;=============================================================================

        xor     _BX, _BX
        cmp     WPTR [_SI], 0
        jnz     SHORT SkipPelsH_2

        JMP     LoadPrimH                       ; start the process

SkipPelsContinue:
        or      dh, dh
        jz      SHORT SkipPelsH

SkipPelsL:
        cmp     bl, bh
        jz      SHORT AllDone

        xor     dh, dh                          ; clear indicator

        dec     _BP
        WRAP_BP_PAT??

        inc     _DI
        MOVZX_W _BX, <WPTR [_SI]>               ; get skip count
        dec     _BX                             ; only one
        jz      SHORT TrySkipNext
        jmp     SHORT SkipBXPels

AllDone:
        @EXIT_PAT_STK_RESTORE

SkipPelsH:
        cmp     bl, bh                          ; end?
        jz      SHORT AllDone

SkipPelsH_2:
        MOVZX_W _BX, <WPTR [_SI]>               ; get skip count

SkipBXPels:
        mov     _CX, _BX
        shr     _CX, 1                          ; see if carry
        sbb     dh, dh                          ; -1=skip high nibble
        add     _DI, _CX                        ; 2 pels per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _BX                        ; see if > 0? (_BX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _BX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _BX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat

TrySkipNext:
        add     _SI, SIZE_PCC
        mov     bx, WPTR [_SI+2]
        cmp     bl, PRIM_INVALID_DENSITY        ; still invalid ?
        jz      SHORT SkipPelsContinue

        or      dh, dh                          ; skip high nibble?
        jz      SHORT LoadPrimHStart            ; no

        mov     cx, WPTR [_SI+4]                ; cl:ch=Prim 3/4
        mov     dx, WPTR [_SI+6]                ; dl:dh=Prim 5/6
        push    _SI
        mov     si, WPTR [_SI]                  ; si=count
        and     BPTR_ES[_DI], 0f0h              ; clear low nibble first!!!
        jmp     SHORT DoLNibble


PopSI_LoadPrimH:
        pop     _SI

LoadPrimH:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      SHORT SkipPelsH

LoadPrimHStart:
        mov     cx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4
        mov     dx, WPTR [_SI+6]                    ; al:ah=Prim 5/6

        push    _SI
        mov     si, WPTR [_SI]                      ; si=count
        inc     si

DoHNibble:
        dec     si
        jz      SHORT PopSI_LoadPrimH

        dec     _BP
        mov     ah, BPTR [_BP]
        mov     al, bl                              ; initial condition

        ;
        ;  1  2  3  4  5
        ; bh:cl:ch:dl:dh
        ;----------------------

        cmp     ch, ah
        jae     SHORT GetH1
        cmp     dl, ah
        sbb     al, 3
        cmp     dh, ah
        jmp     SHORT GetH2

GetH1:  cmp     bh, ah
        jae     SHORT GetHNibble
        dec     al
        cmp     cl, ah

GetH2:  sbb     al, 0

GetHNibble:
        BZXEAX  al
        mov     al, BPTR cs:VGA16ColorIndex[_AX]
        and     al, 0f0h

        dec     si
        jz      SHORT PopSI_LoadPrimL

SaveHNibbleL0:
        mov     BPTR_ES[_DI], al                    ; save high nibble

DoLNibble:
        dec     _BP
        mov     ah, BPTR [_BP]
        mov     al, bl                              ; initial condition

        ;
        ;  1  2  3  4  5
        ; bh:cl:ch:dl:dh
        ;----------------------

        cmp     ch, ah
        jae     SHORT GetL1
        cmp     dl, ah
        sbb     al, 3
        cmp     dh, ah
        jmp     SHORT GetL2

GetL1:  cmp     bh, ah
        jae     SHORT GetLNibble
        dec     al
        cmp     cl, ah

GetL2:  sbb     al, 0

GetLNibble:
        BZXEAX  al
        mov     al, BPTR cs:VGA16ColorIndex[_AX]
        and     al, 0fh
        or      BPTR_ES[_DI], al                    ; or in the low nibble
        inc     _DI

        WRAP_BP_PAT??   <DoHNibble>

PopSI_LoadPrimL:
        pop     _SI
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY
        jz      SHORT SaveAH_SkipPelsL

        mov     cx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4
        mov     dx, WPTR [_SI+6]                    ; al:ah=Prim 5/6
        push    _SI
        mov     si, WPTR [_SI]                      ; si=count
        jmp     SHORT SaveHNibbleL0

SaveAH_SkipPelsL:                                   ; need to save current AL
        and     BPTR_ES[_DI], 0fh                   ; clear high nibble
        or      BPTR_ES[_DI], al                    ; move high nibble in
        jmp     SkipPelsL


@END_PROC




SUBTTL  SingleCountOutputToVGA256
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_VGA256 destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format


`

@BEG_PROC   SingleCountOutputToVGA256   <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cl:ch:dl:dh   : Prim 1/2/3/4 ====> R/G/B/IDX
; _BX           : Scratch register
; _AX           : Scratch register
;==========================================
;
        @ENTER_PAT_TO_STK   <VGA256>                ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The VGA256's color table is constructed as BGR and 6 steps for each primary
; color.
;
;   The BGR Mask = 0x24:0x06:0x01
;============================================================================

        cld                                         ; clear direction
        or      _AX, _AX
        jz      SHORT V256_NoXlate

V256_HasXlate:

IFE ExtRegSet
        mov     _BX, _SP                            ; the table on the stack
ELSE
        mov     _BX, _AX                            ; _AX point to xlate table
ENDIF

V256_XlateByteLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2 B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_XlateInvDensity

        mov     dh, BPTR [_BP]                      ; al=pattern
        dec     dh                                  ; make it cmp al, cl work

        cmp     dh, cl
        sbb     ah, ah                              ; al=0xff or 0
        cmp     dh, ch
        sbb     al, al
        and     ax, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)                              ; dh:dl=36:6

        mov     cx, WPTR [_SI+4]                    ; cl:ch=Prim 3/4 R/I

        cmp     dh, cl
        adc     al, ah
        add     al, ch

        ;
        ; for extended register set _BX point to the translation table
        ; otherwise ss:bx point to the translation table
        ;

IFE ExtRegSet
        xlat    _SS:VGA256_SSSP_XLAT_TABLE
ELSE
        xlatb
ENDIF
        stosb

        WRAP_BP_PAT?? <V256_XlateByteLoop>

V256_XlateInvDensity:
        cmp     cl, ch
        jz      short V256_XlateAllDone

        inc     _DI
        WRAP_BP_PAT?? <V256_XlateByteLoop>

V256_XlateAllDone:

IFE ExtRegSet
        add     _SP, VGA256_XLATE_TABLE_SIZE
ENDIF

;===================================================================

AllDone:
        @EXIT_PAT_STK_RESTORE

;===================================================================


V256_NoXlate:

        mov     bx, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)

V256_ByteLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI+2]                    ; cl:ch=Prim 1/2 B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_InvDensity

        mov     dh, BPTR [_BP]                      ; dh=pattern
        dec     dh                                  ; make it cmp dh, T work

        cmp     dh, cl
        sbb     ah, ah                              ; ah=0xff or 0
        cmp     dh, ch
        sbb     al, al                              ; al=0xff or 0x00
        and     ax, bx                              ; bh:bl=36:6

        mov     cx, WPTR [_SI+4]                    ; cl:ch=Prim 3/4 R/I

        cmp     dh, cl
        adc     al, ah
        add     al, ch
        stosb

        WRAP_BP_PAT?? <V256_ByteLoop>

V256_InvDensity:
        cmp     cl, ch
        jz      short AllDone

        inc     _DI
        WRAP_BP_PAT?? <V256_ByteLoop>


@END_PROC




SUBTTL  VarCountOutputToVGA256
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format

    19-Mar-1993 Fri 18:53:56 updated  -by-  Daniel Chou (danielc)
        1. When we push _SI and jmp to VGA256_InvDensity we fogot to that
           si now is run as count rather than _CX

`

@BEG_PROC   VarCountOutputToVGA256  <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cx            : PrimColorCount.Count
; bl:bh:dl:dh   : Prim 1/2/3/4 ====> R/G/B/IDX
; al            : DestByte
; ah            : Scratch Register
;==========================================
;

        @ENTER_PAT_TO_STK   <VGA256>                ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The VGA256's color table is constructed as BGR and 6 steps for each primary
; color.
;============================================================================

        cld                                         ; clear direction

IFE ExtRegSet
        mov     _BX, _SP                            ; the table on the stack
ELSE
        mov     _BX, _AX                            ; _AX point to xlate table
ENDIF
        or      _AX, _AX
        jnz     SHORT V256_XlateStart
        jmp     V256_NoXlate


        ;======== THIS PORTION is for xlate table

V256_XlateByteLoop:
        pop     _SI                                 ; restore SI

V256_XlateStart:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        push    _SI                                 ; save again

        mov     cx, WPTR [_SI+2]                    ; cl:ch=Prim 1/2  B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_XlateInvDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4  R/I
        mov     si, WPTR [_SI]                      ; count
        inc     si

V256_XlateCountLoop:

        dec     si
        jz      short V256_XlateByteLoop

        dec     _BP
        mov     ah, BPTR [_BP]                      ; ah=Pattern
        dec     ah                                  ; make cmp ah, bl works

        cmp     ah, cl
        sbb     al, al
        and     al, VGA256_B_CUBE_INC               ; AL=0 or 36  Prim1

        cmp     ah, dl                              ; Do Prim 3 first
        adc     al, dh                              ; al=InitValue+Prim1+Prim3

        cmp     ah, ch                              ; do Prim 2 now
        sbb     ah, ah
        and     ah, VGA256_G_CUBE_INC
        add     al, ah

        ;
        ; for extended register set _BX point to the translation table
        ; otherwise ss:bx point to the translation table
        ;

IFE ExtRegSet
        xlat    _SS:VGA256_SSSP_XLAT_TABLE
ELSE
        xlatb
ENDIF

        stosb

V256_XlateReadyNextByte:

        WRAP_BP_PAT?? <V256_XlateCountLoop>


V256_XlateInvDensity:
        cmp     cl, ch                          ; all done?
        jz      SHORT V256_XlateAllDone
        dec     _BP
        inc     _DI

        MOVZX_W _CX, <WPTR [_SI]>
        mov     _SI, _CX                        ; we expect count in si
        cmp     _CX, 1
        jbe     short V256_XlateReadyNextByte

        ;=========

        dec     _CX
        mov     _AX, _CX
        add     _DI, _CX                        ; 1 pel per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short V256_XlateDoneSkipPels    ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
V256_XlateSkipLoop:
        add     _CX, _AX
        jle     short V256_XlateSkipLoop        ; do until > 0
V256_XlateDoneSkipPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     V256_XlateByteLoop              ; repeat the process

V256_XlateAllDone:
        pop     _SI                             ; restore last _SI

IFE ExtRegSet
        add     _SP, VGA256_XLATE_TABLE_SIZE
ENDIF

;======================================================================

AllDone:
        @EXIT_PAT_STK_RESTORE

;======================================================================


V256_NoXlate:

V256_ByteLoop:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                      ; cx=count
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2  B/G
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_InvDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4  R/I

        inc     cx

V256_CountLoop:

        dec     cx
        jz      short V256_ByteLoop

        dec     _BP
        mov     ah, BPTR [_BP]                      ; ah=Pattern
        dec     ah                                  ; make cmp ah, bl works

        cmp     ah, bl
        sbb     al, al
        and     al, VGA256_B_CUBE_INC               ; AL=0 or 36  Prim1

        cmp     ah, dl                              ; Do Prim 3 first
        adc     al, dh                              ; al=InitValue+Prim1+Prim3

        cmp     ah, bh                              ; do Prim 2 now
        sbb     ah, ah
        and     ah, VGA256_G_CUBE_INC
        add     al, ah
        stosb

ReadyNextByte:

        WRAP_BP_PAT?? <V256_CountLoop>


V256_InvDensity:
        cmp     bl, bh                          ; all done?
        jz      short AllDone
        dec     _BP
        inc     _DI
        cmp     cx, 1
        jbe     short ReadyNextByte

SkipDestPels:
        dec     cx
        WZXE    cx                              ; zero extended
        mov     _AX, _CX
        add     _DI, _CX                        ; 1 pel per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     V256_ByteLoop                   ; repeat the process



@END_PROC



SUBTTL  SingleCountOutputTo16BPP_555
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_16BPP_555 destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format


`

@BEG_PROC   SingleCountOutputTo16BPP_555    <pPrimColorCount:DWORD, \
                                             pDest:DWORD,           \
                                             pPattern:DWORD,        \
                                             OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; ax            : Initial RGB color range from 0-32k (15 bits as 5:5:5)
; dh            : pattern
; bl:bh:dl      : Prim1/2/3
; ch            : PRIM_INVALID_DENSITY
; cl            : PRIM_INVALID_DENSITY --> CX = PRIMCOUNT_EOF
;--------------------------------------------------------------------
;

        @ENTER_PAT_TO_STK   <16BPP>                ; _BP=Pat location

;============================================================================
; Since we are in WORD boundary, we should never have an invalid density to
; start with
;
; The 16BPP_555's color table is constructed as 32 steps for each primary color
;============================================================================

        cld                                         ; clear direction
        mov     cx, (RGB555_R_CUBE_INC or RGB555_G_CUBE_INC)

WordLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short InvalidDensity

        mov     dh, BPTR [_BP]                      ; dh=pattern
        dec     dh                                  ; make 'cmp dh, bl' works

        cmp     dh, bl
        sbb     ah, ah                              ; ah=0x00 or 0x04
        cmp     dh, bh
        sbb     al, al                              ; al=0x00 or 0x20 ax=0x420
        and     ax, cx                              ; mask with cx= 0x0420

        cmp     dh, BPTR [_SI+4]
        adc     ax, WPTR [_SI+6]                    ; ax+carry+initial index

        stosw

        WRAP_BP_PAT?? <WordLoop>

InvalidDensity:
        cmp     bl, bh
        jz      short AllDone

        inc     _DI
        WRAP_BP_PAT?? <WordLoop>

AllDone:
        @EXIT_PAT_STK_RESTORE


@END_PROC




SUBTTL  VarCountOutputTo16BPP_555
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format


`

@BEG_PROC   VarCountOutputTo16BPP_555   <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount, si=Temp Init Index
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; ax            : Initial RGB color range from 0-32k (15 bits as 5:5:5)
; dh            : pattern
; bl:bh:dl      : Prim1/2/3
; cx            : PrimColorCount.Count
;==========================================
;

        @ENTER_PAT_TO_STK   <16BPP>                 ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The 16BPP_555's color table is constructed as BGR and 6 steps for each
; primary color.
;============================================================================

        cld                                         ; clear direction
        jmp     short InitStart

WordLoop:
        pop     _SI                                 ; restore _SI
InitStart:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        push    _SI                                 ; save _SI

        mov     cx, WPTR [_SI]                      ; cx=count
        mov     bx, WPTR [_SI+2]                    ; bx=Prim 1/2/3

        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short InvalidDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4
        mov     si, WPTR [_SI+6]                    ; si=initial index

        inc     cx                                  ; pre-enter

CountLoop:
        dec     cx
        jz      SHORT WordLoop

        dec     _BP
        mov     dh, BPTR [_BP]                      ; bl=pattern
        dec     dh                                  ; make cmp bl, dh works

        cmp     dh, bl
        sbb     ah, ah                              ; ah=0/0x40
        cmp     dh, bh
        sbb     al, al
        and     ax, (RGB555_R_CUBE_INC or RGB555_G_CUBE_INC)    ; mask=0x420
        cmp     dh, dl
        adc     ax, si                              ; carry+ax+initial index

        stosw

ReadyNextByte:

        WRAP_BP_PAT?? <CountLoop>

InvalidDensity:
        cmp     bl, bh                          ; all done?
        jz      short AllDone
        dec     _BP
        add     _DI, 2                          ; 16-bit per pel
        cmp     cx, 1
        jbe     SHORT ReadyNextByte

SkipDestPels:
        dec     cx
        WZXE    cx                              ; zero extended
        mov     _AX, _CX
        add     _DI, _CX                        ; 16-bit per pel
        add     _DI, _CX                        ;
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     WordLoop                        ; repeat the process,

AllDone:
        pop     _SI                             ; restore _SI
        @EXIT_PAT_STK_RESTORE


@END_PROC



ENDIF       ; HT_ASM_80x86

ENDIF       ; 0



END





VOID
HTENTRY
VarCountOutputToVGA256(
    PPRIMCOLOR_COUNT    pPrimColorCount,
    LPBYTE              pDest,
    LPBYTE              pPattern,
    OUTFUNCINFO         OutFuncInfo
    )

/*++

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    ppDest          - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:


--*/


{
    LPBYTE          pCurPatA;
    LPBYTE          pEndPatA;
    LPBYTE          pCurPatB;
    LPBYTE          pCurPatC;
    LPBYTE          pXlate;
    PRIMCOLOR_COUNT PCC;
    LPBYTE          pCur555Pat;
    LPBYTE          pEnd555Pat;
    BYTE            bTmp;
    WORD            Idx;
    PRIMCOLOR_COUNT PCCX;


    //
    // Since we are in byte boundary, we should never get the first one is
    // invalid
    //

    if (!(pXlate = (LPBYTE)OutFuncInfo.pXlate8BPP)) {

        pXlate = (LPBYTE)DefHTXlate8BPP;
    }

    SET_555PAT;

    if (pPattern) {

        LPBYTE  pRotPatA;
        BYTE    bPat;


        SET_ROTPAT;

        while (TRUE) {

            PCC = *(++pPrimColorCount);

            if (PCC.Count >= PRIM_COUNT_SPECIAL) {

                if (PCC.Count == PRIM_COUNT_END_SCAN) {

                    return;     // EOF
                }

                pDest += PCC.cSkip;         // advance destination

                SKIP_ROTPAT(PCC.cSkip);
                SKIP_555PAT(PCC.cSkip);

            } else {

                GET_555_COLOR_IDXPCC(PCCX);

                while (PCC.Count--) {

                    GET_555_COLOR(PCCX, FALSE);

                    *pDest++ = GET_VGA256_INDEX(PCCX,
                                                ROTPAT_A,
                                                ROTPAT_B,
                                                ROTPAT_C);

                    WRAP_ROTPAT;
                }
            }
        }

    } else {

        UINT    SkipCount;


        SET_PATABC(TRUE);

        while (TRUE) {

            PCC = *(++pPrimColorCount);

            if (PCC.Count >= PRIM_COUNT_SPECIAL) {

                if (PCC.Count == PRIM_COUNT_END_SCAN) {

                    return;     // EOF
                }

                pDest += PCC.cSkip;         // advance destination

                SKIP_PATABC(PCC.cSkip, SkipCount);
                SKIP_555PAT(PCC.cSkip);

            } else {

                GET_555_COLOR_IDXPCC(PCCX);

                while (PCC.Count--) {

                    GET_555_COLOR(PCCX, FALSE);

                    *pDest++ = GET_VGA256_INDEX(PCCX,
                                                *pCurPatA,
                                                *pCurPatB,
                                                *pCurPatC);

                    WRAP_PATABC;
                }
            }
        }
    }
}


VOID
HTENTRY
SingleCountOutputToVGA256(
    PPRIMCOLOR_COUNT    pPrimColorCount,
    LPBYTE              pDest,
    LPBYTE              pPattern,
    OUTFUNCINFO         OutFuncInfo
    )

/*++

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination planes pointers.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed the first 'Dest = Prim1234.b[4]' to 'Dest = Prim1234.b[3]'
           mistake.


--*/

{
    LPBYTE          pCurPatA;
    LPBYTE          pEndPatA;
    LPBYTE          pCurPatB;
    LPBYTE          pCurPatC;
    LPBYTE          pXlate;
    PRIMCOLOR_COUNT PCC;
    LPBYTE          pCur555Pat;
    LPBYTE          pEnd555Pat;
    BYTE            bTmp;
    WORD            Idx;
    PRIMCOLOR_COUNT PCCX;


    //
    // Since we are in byte boundary, we should never get the first one is
    // invalid
    //

    if (!(pXlate = (LPBYTE)OutFuncInfo.pXlate8BPP)) {

        pXlate = (LPBYTE)DefHTXlate8BPP;
    }

    SET_555PAT;

    if (pPattern) {

        LPBYTE  pRotPatA;
        BYTE    bPat;


        SET_ROTPAT;

        while (TRUE) {

            PCC = *(++pPrimColorCount);

            if (PCC.Count >= PRIM_COUNT_SPECIAL) {

                if (PCC.Count == PRIM_COUNT_END_SCAN) {

                    return;     // EOF
                }

            } else {

                GET_555_COLOR(PCCX, TRUE);

                *pDest = GET_VGA256_INDEX(PCCX,
                                          ROTPAT_A,
                                          ROTPAT_B,
                                          ROTPAT_C);
            }

            ++pDest;

            WRAP_ROTPAT;
        }

    } else {

        SET_PATABC(TRUE);

        while (TRUE) {

            PCC = *(++pPrimColorCount);

            if (PCC.Count >= PRIM_COUNT_SPECIAL) {

                if (PCC.Count == PRIM_COUNT_END_SCAN) {

                    return;     // EOF
                }

            } else {

                GET_555_COLOR(PCCX, TRUE);

                *pDest = GET_VGA256_INDEX(PCCX,
                                          *pCurPatA,
                                          *pCurPatB,
                                          *pCurPatC);
            }

            ++pDest;

            WRAP_PATABC;
        }
    }
}


@BEG_PROC   SingleCountOutputToVGA256   <pPrimColorCount:DWORD, \
                                         pDest:DWORD,           \
                                         pPattern:DWORD,        \
                                         OutFuncInfo:QWORD>

OUTFUNCINFO STRUC
    OFI_pXlate8BPP      DD  ?
    OFI_pPrimMap        DD  ?
    OFI_p555Pat         DD  ?
    OFI_PatWidthBytes   DW  ?
    OFI_PatOrgX         DW  ?
    OFI_pPatA           DD  ?
    OFI_pPatB           DD  ?
    OFI_pPatC           DD  ?
OUTFUNCINFO ENDS


#define ROTPAT_A    (pCurPatA[bPat = *pRotPatA])
#define ROTPAT_B    (pCurPatB[bPat])
#define ROTPAT_C    (pCurPatC[bPat])



SET_ROTPAT MACRO

    __@@EMIT <mov  > _AX, pPattern
    __@@EMIT <mov  > _BP, _AX
    __@@EMIT <movzx> _BX, OutFuncInfo.PatWidthBytes
    __@@EMIT <add  > _AX, _BX
    __@@EMIT <mov  > pEndPatA, _AX
    __@@EMIT <movzx> _AX, OutFuncInfo.PatOrgX
    __@@EMIT <add > _BP, _AX
ENDM


SKIP_ROTPAT MACRO   Count
                    Local   DoneSkip

    __@@EMIT <xor  > _DX, _DX,
    __@@EMIT <movzx> _AX, WPTR Count
    __@@EMIT <div  > OutFuncInfo.PatWidthBytes
    __@@EMIT <add  > _BP, _DX
    __@@EMIT <cmp  > _BP, pEndPatA
    __@@EMIT <jb   > <SHORT DoneWrap>
    __@@EMIT <sub > _BP, OutFuncInfo.PatWidthBytes
DoneSkip:

ENDM

WRAP_ROTPAT MACRO   EndWrapLoc
                    Local   DoneWrap

    IFB <EndWrapLoc>
        __@@EMIT <inc  > _BP
        __@@EMIT <cmp  > _BP, pEndPatA
        __@@EMIT <jb   > <SHORT DoneWrap>
        __@@EMIT <sub  > _BP, OutFuncInfo.PatWidthBytes
    ELSE
        __@@EMIT <inc  > _BP
        __@@EMIT <cmp  > _BP, pEndPatA
        __@@EMIT <jb   > <SHORT EndWrapLoc>
        __@@EMIT <sub  > _BP, OutFuncInfo.PatWidthBytes
        __@@EMIT <jmp  > <SHORT EndWrapLoc>
    ENDIF

DoneWrap:

ENDM

#define GET_555_COLOR(pc, GetPCCIdx)                                        \
{                                                                           \
    if (OutFuncInfo.cx555Pat) {                                             \
                                                                            \
        if (PCC.Color.Prim1 > (bTmp = *pCur555Pat)) {                       \
                                                                            \
            Idx = PCC.Color.w2b.wPrim + HT_RGB_B_INC;                       \
                                                                            \
        } else {                                                            \
                                                                            \
            Idx = PCC.Color.w2b.wPrim;                                      \
        }                                                                   \
                                                                            \
        if (PCC.Color.Prim2 > bTmp) {                                       \
                                                                            \
            Idx += HT_RGB_G_INC;                                            \
        }                                                                   \
                                                                            \
        if (PCC.Color.Prim3 > bTmp) {                                       \
                                                                            \
            Idx += HT_RGB_R_INC;                                            \
        }                                                                   \
                                                                            \
        if (++pCur555Pat >= pEnd555Pat) {                                   \
                                                                            \
            pCur555Pat -= OutFuncInfo.cx555Pat;                             \
        }                                                                   \
                                                                            \
        if (Idx >= HT_RGB_CUBE_COUNT) {                                     \
                                                                            \
            DBGP("Idx = %04x, wPrim=%04x (%u:%u:%u) [%u]"                   \
                ARGU(Idx) ARGU(PCC.Color.w2b.wPrim)                         \
                ARGU(PCC.Color.Prim1)                                       \
                ARGU(PCC.Color.Prim2)                                       \
                ARGU(PCC.Color.Prim3)                                       \
                ARGU(bTmp));                                                \
                                                                            \
            Idx = HT_RGB_CUBE_COUNT;                                        \
        }                                                                   \
                                                                            \
        pc.Color = *((PPRIMCOLOR)OutFuncInfo.pPrimMap + Idx);               \
                                                                            \
    } else if (GetPCCIdx) {                                                 \
                                                                            \
        pc.Color = *((PPRIMCOLOR)OutFuncInfo.pPrimMap+PCC.Color.w2b.wPrim); \
    }                                                                       \
}

;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; ecx, edx      ; color and count
; _BX           ; 555 pattern, self wrap able
; _AX           : Scratch register
;==========================================
cl   = Prim1
ch   = Prim2
ecl  = Prim3
ech  = Flags


GET_V256_IDX    MACRO
    __@@EMIT <movzx> eax, BPTR [_BP]

    __@@EMIT <cmp  > al, cl
    __@@EMIT <sbb  > bh, bh                              ; al=0xff or 0
    __@@EMIT <cmp  > al, ch
    __@@EMIT <sbb  > bl, bl
    __@@EMIT <and  > bx, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)                              ; dh:dl=36:6
    __@@EMIT <cmp  > al, ecl
    __@@EMIT <adc  > bl, bh

    __@@EMIT <add  > al, ch

    __@@EMIT <rol  > ecx, 16
    __@@EMIT <rcr  > _BX, 5
    __@@EMIT <cmp  > al, ch
    __@@EMIT <rcr  > _BX, 5
    __@@EMIT <cmp  > al, cl
    __@@EMIT <rcr  > _BX, 6
    __@@EMIT <add  > _BX, _DX
    __@@EMIT <add  > _BX, _DX
    __@@EMIT <shl  > _BX, 1



ENDM

GET_555_COLOR   MACRO   <IsGetIdx>

    __@@EMIT <or   > _BX, _BX
    __@@EMIT <jnc  > GetIndex
    __@@EMIT <mov  > al, BPTR [_BX]
    __@@EMIT <ror  > ecx, 16
    __@@EMIT <cmp  > al, cl
    __@@EMIT <rcr  > _BX, 5
    __@@EMIT <rol  > ecx, 16
    __@@EMIT <cmp  > al, ch
    __@@EMIT <rcr  > _BX, 5
    __@@EMIT <cmp  > al, cl
    __@@EMIT <rcr  > _BX, 6
    __@@EMIT <movzx) _AX, dx
    __@@EMIT <add  > _BX, _AX
    __@@EMIT <shl  > _BX, 1
    __@@EMIT <mov  > DPTR [_BX + (_BX * 2)]







ENDM

        GET_555_COLOR   <TRUE>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cl:ch:dl:dh   : Prim 1/2/3/4 ====> R/G/B/IDX
; _BX           : Scratch register
; _AX           : Scratch register
;==========================================
;
        @ENTER_PAT_TO_STK   <VGA256>                ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The VGA256's color table is constructed as BGR and 6 steps for each primary
; color.
;
;   The BGR Mask = 0x24:0x06:0x01
;============================================================================

        cld                                         ; clear direction

        LDS_SI  pPrimColorCount                     ;; _SI=pPrimColorCount
        LES_DI  pDest


        or      _AX, _AX
        jz      SHORT V256_NoXlate

V256_XlateByteLoop:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     ecx, DPTR [SI]
        cmp     cx, PRIM_COUNT_SPECIAL
        jae     V256_Skip

        GET_555_COLOR   <TRUE>

        GET_V256_IDX

        xlatb

        WRAP_ROTPAT <V256_XlateByteLoop>

V256_Skip:
        cmp     cx, PRIM_COUNT_END_SCAN
        jz      short V256_XlateAllDone
        inc     _DI

        WRAP_ROTPAT     <V256_XlateByteLoop>

V256_XlateAllDone:





























IFE ExtRegSet
        mov     _BX, _SP                            ; the table on the stack
ELSE
        mov     _BX, _AX                            ; _AX point to xlate table
ENDIF

V256_XlateByteLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2 B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_XlateInvDensity

        mov     dh, BPTR [_BP]                      ; al=pattern
        dec     dh                                  ; make it cmp al, cl work

        cmp     dh, cl
        sbb     ah, ah                              ; al=0xff or 0
        cmp     dh, ch
        sbb     al, al
        and     ax, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)                              ; dh:dl=36:6

        mov     cx, WPTR [_SI+4]                    ; cl:ch=Prim 3/4 R/I

        cmp     dh, cl
        adc     al, ah
        add     al, ch

        ;
        ; for extended register set _BX point to the translation table
        ; otherwise ss:bx point to the translation table
        ;

IFE ExtRegSet
        xlat    _SS:VGA256_SSSP_XLAT_TABLE
ELSE
        xlatb
ENDIF
        stosb

        WRAP_BP_PAT?? <V256_XlateByteLoop>

V256_XlateInvDensity:
        cmp     cl, ch
        jz      short V256_XlateAllDone

        inc     _DI
        WRAP_BP_PAT?? <V256_XlateByteLoop>

V256_XlateAllDone:

IFE ExtRegSet
        add     _SP, VGA256_XLATE_TABLE_SIZE
ENDIF

;===================================================================

AllDone:
        @EXIT_PAT_STK_RESTORE

;===================================================================


V256_NoXlate:

        mov     bx, ((VGA256_B_CUBE_INC shl 8) or VGA256_G_CUBE_INC)

V256_ByteLoop:
        dec     _BP                                 ; do this one first

        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI+2]                    ; cl:ch=Prim 1/2 B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_InvDensity

        mov     dh, BPTR [_BP]                      ; dh=pattern
        dec     dh                                  ; make it cmp dh, T work

        cmp     dh, cl
        sbb     ah, ah                              ; ah=0xff or 0
        cmp     dh, ch
        sbb     al, al                              ; al=0xff or 0x00
        and     ax, bx                              ; bh:bl=36:6

        mov     cx, WPTR [_SI+4]                    ; cl:ch=Prim 3/4 R/I

        cmp     dh, cl
        adc     al, ah
        add     al, ch
        stosb

        WRAP_BP_PAT?? <V256_ByteLoop>

V256_InvDensity:
        cmp     cl, ch
        jz      short AllDone

        inc     _DI
        WRAP_BP_PAT?? <V256_ByteLoop>


@END_PROC




SUBTTL  VarCountOutputToVGA256
PAGE

COMMENT `

Routine Description:

    This function output to the BMF_4BPP destination surface from
    PRIMCOLOR_COUNT data structure array.

Arguments:

    pPrimColorCount - Pointer to the PRIMCOLOR_COUNT data structure array.

    pDest           - Pointer to the destination plane.

    pPattern        - Pointer to the starting pattern byte for the current
                      destination scan line.

    OutFuncInfo     - OUTFUNCINFO data structure.

Return Value:

    No return value.

Author:

    24-Jan-1991 Thu 11:47:08 created  -by-  Daniel Chou (danielc)


Revision History:

    01-Jun-1992 Mon 15:32:00 updated  -by-  Daniel Chou (danielc)
        1. Fixed so that Prims match the device's BGR color table format rather
           than RGB format

    19-Mar-1993 Fri 18:53:56 updated  -by-  Daniel Chou (danielc)
        1. When we push _SI and jmp to VGA256_InvDensity we fogot to that
           si now is run as count rather than _CX

`

@BEG_PROC   VarCountOutputToVGA256  <pPrimColorCount:DWORD, \
                                     pDest:DWORD,           \
                                     pPattern:DWORD,        \
                                     OutFuncInfo:QWORD>


;==========================================
; Register Usage:
;
; _SI           : pPrimColorCount
; _DI           : pDest
; _BP           : Current pPattern, self wrappable
; cx            : PrimColorCount.Count
; bl:bh:dl:dh   : Prim 1/2/3/4 ====> R/G/B/IDX
; al            : DestByte
; ah            : Scratch Register
;==========================================
;

        @ENTER_PAT_TO_STK   <VGA256>                ; _BP=Pat location

;============================================================================
; Since we are in byte boundary, we should never have an invalid density to
; start with
;
; The VGA256's color table is constructed as BGR and 6 steps for each primary
; color.
;============================================================================

        cld                                         ; clear direction

IFE ExtRegSet
        mov     _BX, _SP                            ; the table on the stack
ELSE
        mov     _BX, _AX                            ; _AX point to xlate table
ENDIF
        or      _AX, _AX
        jnz     SHORT V256_XlateStart
        jmp     V256_NoXlate


        ;======== THIS PORTION is for xlate table

V256_XlateByteLoop:
        pop     _SI                                 ; restore SI

V256_XlateStart:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        push    _SI                                 ; save again

        mov     cx, WPTR [_SI+2]                    ; cl:ch=Prim 1/2  B/G
        cmp     cl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_XlateInvDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4  R/I
        mov     si, WPTR [_SI]                      ; count
        inc     si

V256_XlateCountLoop:

        dec     si
        jz      short V256_XlateByteLoop

        dec     _BP
        mov     ah, BPTR [_BP]                      ; ah=Pattern
        dec     ah                                  ; make cmp ah, bl works

        cmp     ah, cl
        sbb     al, al
        and     al, VGA256_B_CUBE_INC               ; AL=0 or 36  Prim1

        cmp     ah, dl                              ; Do Prim 3 first
        adc     al, dh                              ; al=InitValue+Prim1+Prim3

        cmp     ah, ch                              ; do Prim 2 now
        sbb     ah, ah
        and     ah, VGA256_G_CUBE_INC
        add     al, ah

        ;
        ; for extended register set _BX point to the translation table
        ; otherwise ss:bx point to the translation table
        ;

IFE ExtRegSet
        xlat    _SS:VGA256_SSSP_XLAT_TABLE
ELSE
        xlatb
ENDIF

        stosb

V256_XlateReadyNextByte:

        WRAP_BP_PAT?? <V256_XlateCountLoop>


V256_XlateInvDensity:
        cmp     cl, ch                          ; all done?
        jz      SHORT V256_XlateAllDone
        dec     _BP
        inc     _DI

        MOVZX_W _CX, <WPTR [_SI]>
        mov     _SI, _CX                        ; we expect count in si
        cmp     _CX, 1
        jbe     short V256_XlateReadyNextByte

        ;=========

        dec     _CX
        mov     _AX, _CX
        add     _DI, _CX                        ; 1 pel per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short V256_XlateDoneSkipPels    ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
V256_XlateSkipLoop:
        add     _CX, _AX
        jle     short V256_XlateSkipLoop        ; do until > 0
V256_XlateDoneSkipPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     V256_XlateByteLoop              ; repeat the process

V256_XlateAllDone:
        pop     _SI                             ; restore last _SI

IFE ExtRegSet
        add     _SP, VGA256_XLATE_TABLE_SIZE
ENDIF

;======================================================================

AllDone:
        @EXIT_PAT_STK_RESTORE

;======================================================================


V256_NoXlate:

V256_ByteLoop:
        add     _SI, SIZE_PCC                       ; sizeof(PRIMCOLOR_COUNT)
        mov     cx, WPTR [_SI]                      ; cx=count
        mov     bx, WPTR [_SI+2]                    ; bl:bh=Prim 1/2  B/G
        cmp     bl, PRIM_INVALID_DENSITY            ; invalid?
        jz      short V256_InvDensity

        mov     dx, WPTR [_SI+4]                    ; dl:dh=Prim 3/4  R/I

        inc     cx

V256_CountLoop:

        dec     cx
        jz      short V256_ByteLoop

        dec     _BP
        mov     ah, BPTR [_BP]                      ; ah=Pattern
        dec     ah                                  ; make cmp ah, bl works

        cmp     ah, bl
        sbb     al, al
        and     al, VGA256_B_CUBE_INC               ; AL=0 or 36  Prim1

        cmp     ah, dl                              ; Do Prim 3 first
        adc     al, dh                              ; al=InitValue+Prim1+Prim3

        cmp     ah, bh                              ; do Prim 2 now
        sbb     ah, ah
        and     ah, VGA256_G_CUBE_INC
        add     al, ah
        stosb

ReadyNextByte:

        WRAP_BP_PAT?? <V256_CountLoop>


V256_InvDensity:
        cmp     bl, bh                          ; all done?
        jz      short AllDone
        dec     _BP
        inc     _DI
        cmp     cx, 1
        jbe     short ReadyNextByte

SkipDestPels:
        dec     cx
        WZXE    cx                              ; zero extended
        mov     _AX, _CX
        add     _DI, _CX                        ; 1 pel per byte
        mov     _CX, _BP                        ; align pattern now
        and     _CX, HTPAT_STK_MASK             ; how many pat avai.?
        xor     _BP, _CX                        ; clear _BP mask=pPattern
        sub     _CX, _AX                        ; see if > 0? (_AX=Count)
        jg      short DoneSkipDestPels          ; still not used up yet!
        mov     _AX, [_BP - HTPAT_BP_SIZE]      ; get pattern size
SkipDestPelsLoop:
        add     _CX, _AX
        jle     short SkipDestPelsLoop          ; do until > 0
DoneSkipDestPels:
        add     _BP, _CX                        ; _BP=pCurPat
        jmp     V256_ByteLoop                   ; repeat the process



@END_PROC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\i386\htutils.asm ===
PAGE 60, 132
    TITLE   miscellaneous utilities sub-functions

COMMENT `


Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    htutils.asm


Abstract:

    This module provided a set of sub-functions for math speed up
    subfunctions.

    This function is the equivelant codes in the htmath.c

Author:

    24-Sep-1991 Tue 18:33:44 updated  -by-  Daniel Chou (danielc)

[Environment:]

    Printer Driver.


[Notes:]


Revision History:

`


        .XLIST
        INCLUDE i386\i80x86.inc
        .LIST


IF  HT_ASM_80x86


;------------------------------------------------------------------------------
        .XLIST
        INCLUDE i386\htp.inc
        .LIST
;------------------------------------------------------------------------------

        .CODE


FD6NUM_1_DW     equ     0f4240h
FD6NUM_1_HW     equ     0fh
FD6NUM_1_LW     equ     4240h




SUBTTL  ComputeChecksum
PAGE

COMMENT `

Routine Description:

    This function compute 32-bit checksum of the passed data

Arguments:

    pData       - Pointer to a byte array to be computed for the checksum

    DataSize    - Size of the data in bytes

Return Value:

    32-bit checksum in dx:ax or EAX

Author:

    18-Mar-1991 Mon 13:48:51 created  -by-  Daniel Chou (danielc)


Revision History:

`


@BEG_PROC   ComputeChecksum <pData:DWORD,           \
                             InitialChecksum:DWORD, \
                             DataSize:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

;==================================
; ds:si = data
; bx:cx = size
; ax    = Checksum Octet S
; dx    = Checksun Octet R
;============================================================================
;We have two 16-bit checksum octet R,S , inital are zero
;
;   S(n) = S(n-1) + Data
;   R(n) = R(n-1) + S(n)
;============================================================================

        @ENTER  _DS _SI                     ; Save environment registers

        LDS_SI  pData
        cld

        mov     cx, WPTR DataSize
        mov     bx, WPTR DataSize+2

        mov     ax, WPTR InitialChecksum    ; assume no odd byte
        mov     dx, WPTR InitialChecksum+2

        shr     bx, 1
        rcr     cx, 1
        jnc     short CheckSum1

CheckSum0:
        xor     ax, ax
        lodsb
        add     ax, WPTR InitialChecksum

CheckSum1:
        inc     cx
        inc     bx
        jmp     short CheckSumStart

CheckSumLoop:
        add     ax, WPTR [_SI]              ; S(n) = one's complement arithmic
        adc     dx, ax,
        add     _SI, 2

CheckSumStart:
        dec     cx
        jnz     CheckSumLoop
        dec     bx
        jnz     short CheckSumLoop

        @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

;==================================
; _BX   = data
; _CX   = size
; ax    = Checksum Octet S
; dx    = Checksun Octet R
;============================================================================
;We have two 16-bit checksum octet R,S , inital are zero
;
;   S(n) = S(n-1) + Data
;   R(n) = R(n-1) + S(n)
;============================================================================


        @ENTER

        mov     _BX, DPTR pData
        mov     _CX, DPTR DataSize

        movzx   _AX, WPTR InitialChecksum   ; assume no odd byte
        movzx   _DX, WPTR InitialChecksum+2 ; assume no odd byte

        shr     _CX, 1
        jnc     short CheckSum1

CheckSum0:
        xor     ax, ax
        mov     al, BPTR [_BX]
        add     ax, WPTR InitialChecksum
        inc     _BX

CheckSum1:
        inc     _CX
        jmp     short CheckSumStart

CheckSumLoop:
        add     ax, WPTR [_BX]              ; S(n) = one's complement arithmic
        add     dx, ax                      ; R(n) = one's complement arithmic
        add     _BX, 2

CheckSumStart:
        dec     _CX
        jnz     CheckSumLoop

Done:   shl     _DX, 16                     ; R:S = dx:ax = _AX = 32-bits
        or      _AX, _DX                    ; return at EAX

        @EXIT

ENDIF

@END_PROC




SUBTTL  MulFD6
PAGE

COMMENT `

Routine Description:

    This function multiply two FD6 numbers (FIX decimal point decimal long
    number, the LONG DECIMAL POINT SIX (FD6) is a number with lowest 6 digits
    as fraction to the right of the decimal point), so like 1234567 = 1.234567,
    the range for this data type is -2147.483647 to 2147.483647.

Arguments:

    Multiplicand    - a 32-bit FD6 multiplicand dividend number.

    Multiplier      - a 32-bit FD6 multiplier number.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero the return value will be 0, if
    overflow happened, then maximum FD6 number will be returned (ie.
    2147.483647)

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   MulFD6  <Multiplicand:DWORD,    \
                     Multiplier:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _SI _DI _BP                 ; save these registers

    mov     ax, WPTR Multiplier
    mov     dx, WPTR Multiplier + 2
    mov     cx, ax
    or      cx, dx
    jz      short MulFD6_Zero

    mov     bx, WPTR Multiplicand
    mov     bp, WPTR Multiplicand + 2
    mov     cx, bx
    or      cx, bp
    jz      short MulFD6_Zero           ; if any one of them is zero then
                                        ; result must be zero
MulFD6_1:

    xor     cx, cx
    or      bp, bp
    jns     short MulFD6_2

    NEG32_FROMR16HL bp, bx
    not     cx                          ; cx=0 if positive, cx=0xffff negative

MulFD6_2:

    or      dx, dx
    jns     short MulFD6_3

    NEG32_FROMR16HL dx, ax
    not     cx                          ; flip the final sign indicator

MulFD6_3:

    cmp     bp, FD6NUM_1_HW             ; check if bp:bx == 1000000 (1.0)
    jnz     short MulFD6_31
    cmp     bx, FD6NUM_1_LW
    jz      short MulFD6_4              ; bp:bx = 1.0 return dx:ax

MulFD6_31:

    cmp     dx, FD6NUM_1_HW
    jnz     short MulFD6_32             ;
    cmp     ax, FD6NUM_1_LW             ; check if dx:ax == 1000000 (1.0)
    jnz     short MulFD6_32
    mov     ax, bx
    mov     dx, bp                      ; dx:ax = 1.0 return bp:bx
    jmp     short MulFD6_4

MulFD6_32:

    push    cx                          ; save it
    call    U32MulU32_U64               ; dx:ax * bp:bx = dx:ax:bp:bx
    call    U64Div1000000               ; dx:ax:bp:bx / 1000000 = dx:ax
    pop     cx                          ; restore sign indicator

MulFD6_4:

    S32_FROMR16HL_SR16  dx, ax, cx      ; flip sign if sign

    @EXIT

MulFD6_Zero:

    xor     ax, ax                      ; return 0
    xor     dx, dx
    jmp     short MulFD6_4

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Multiplier        ; see if this guy is zero
    cdq                                 ; save dx sign
    xor     _AX, _DX                    ; take absolute Multiplier in _AX
    sub     _AX, _DX                    ; zero ?
    jz      short MulFD6_Done           ; return zero

    mov     _BX, _DX                    ; _BX = sign
    mov     _CX, _AX                    ; save absolute Multiplier in _CX
    mov     _AX, DPTR Multiplicand      ; edx:eax now
    cdq                                 ; sign extended, saved the sign at here
    xor     _AX, _DX
    sub     _AX, _DX                    ; eax=absolute dividend now
    jz      short MulFD6_Done           ; dividend = 0, return 0

    xor     _BX, _DX                    ; _BX=final sign only if _BX != _DX

    ;
    ; _AX=Multiplicand, _CX=Multiplier, _BX = final sign indicator
    ;

    mov     _DX, _CX
    mov     _CX, FD6NUM_1_DW            ; multiply dividend by 1.0 (decimal)

    ;
    ; _AX=Multiplicand, _DX=Multiplier, _BX=sign, _CX=1.0
    ;

    cmp     _DX, _CX                    ; if Multiplier=1.0 or -1.0 then exit
    jz      short MulFD6_Sign           ; return Multiplicand

    xchg    _DX, _AX                    ; _AX=Multiplier, _DX=Multiplicand

    ;
    ; _AX=Multiplier, _DX=Multiplicand, _BX=sign, _CX=1.0
    ;

    cmp     _DX, _CX                    ; if Multiplicand=1.0 or -1.0 then exit
    jz      short MulFD6_Sign           ; return Multiplier

    mul     _DX                         ; _DX x _AX = _DX:_AX
    add     _AX, (FD6NUM_1_DW / 2)      ; try to round up
    adc     _DX, 0

    cmp     _DX, _CX                    ; will divison overflow?
    jae     short MulFD6_Overflow

    div     _CX                         ; _DX=remainder, _AX=quotient

MulFD6_Sign:

    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX

MulFD6_Done:

    cdq                                 ; make it 64-bits
    @EXIT                               ; exiting function

MulFD6_Overflow:

    mov     _AX, 07fffffffh             ; return maximum number
    jmp     short MulFD6_Sign

ENDIF                                   ; i8086 or i286


@END_PROC



SUBTTL  Cube
PAGE

COMMENT `

Routine Description:

    This function compute the cube of the Number (ie. Number ^ 3)
    the range for this data type is -2147.483647 to 2147.483647.

Arguments:

    Number  - a 32-bit FD6 multiplicand dividend number.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   Cube    <Number:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _SI _DI _BP                 ; save these registers

    mov     ax, WPTR Number
    mov     dx, WPTR Number + 2
    mov     cx, ax
    or      cx, dx
    jz      short Cube_Done             ; return 0
                                        ; result must be zero
Cube_1:

    xor     cx, cx
    or      dx, dx
    jns     short Cube_2

    NEG32_FROMR16HL dx, ax
    not     cx                          ; flip the final sign indicator

Cube_2:

    cmp     dx, FD6NUM_1_HW
    jnz     short Cube_3                ;
    cmp     ax, FD6NUM_1_LW             ; check if dx:ax == 1000000 (1.0)
    jz      Cube_Sign                   ; done

Cube_3:

    push    cx                          ; save it (sign)
    push    dx
    push    ax
    mov     bp, dx
    mov     bx, ax
    call    U32MulU32_U64               ; dx:ax * bp:bx = dx:ax:bp:bx
    call    U64Div1000000               ; dx:ax:bp:bx / 1000000 = dx:ax
    pop     bx                          ; now multiply the original again
    pop     bp
    call    U32MulU32_U64               ; dx:ax * bp:bx = dx:ax:bp:bx
    call    U64Div1000000               ; dx:ax:bp:bx / 1000000 = dx:ax
    pop     cx                          ; restore sign indicator

Cube_Sign:

    S32_FROMR16HL_SR16  dx, ax, cx      ; flip sign if sign

Cube_Done:

    @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Number            ; see if this guy is zero
    cdq                                 ; save dx sign
    xor     _AX, _DX                    ; take absolute Multiplier in _AX
    sub     _AX, _DX                    ; zero ?
    jz      short Cube_Done             ; return zero
    push    _DX                         ; save sign
    mov     _CX, _AX                    ; save absolute Multiplier in _CX
    mov     _BX, FD6NUM_1_DW

    ;
    ; _AX=_CX=ABS(Number), esp= final sign indicator, _BX=1.0
    ;

    cmp     _AX, _BX
    jz      Cube_Sign                   ; return 1.0 or -1.0

    mul     _CX                         ; _DX:_AX=result
    add     _AX, (FD6NUM_1_DW / 2)      ; try to round up
    adc     _DX, 0
    cmp     _DX, FD6NUM_1_DW            ; will divison overflow?
    jae     short Cube_Overflow
    div     _BX                         ; _DX=remainder, _AX=quotient

    mul     _CX
    add     _AX, (FD6NUM_1_DW / 2)      ; try to round up
    adc     _DX, 0
    cmp     _DX, FD6NUM_1_DW            ; will divison overflow?
    jae     short Cube_Overflow
    div     _BX                         ; _DX=remainder, _AX=quotient

Cube_Sign:

    pop     _BX
    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX

Cube_Done:

    cdq                                 ; make it 64-bits
    @EXIT                               ; exiting function

Cube_Overflow:

    mov     _AX, 07fffffffh             ; return maximum number
    jmp     short Cube_Sign

ENDIF                                   ; i8086 or i286


@END_PROC




SUBTTL  MulDivFD6Pairs
PAGE

COMMENT `

Routine Description:

    This function multiply each pair of FD6 numbers and add the each pair
    of the result together. (FIX decimal point decimal long number, the LONG
    DECIMAL POINT SIX (FD6) is a number with lowest 6 digits as fraction to
    the right of the decimal point), so like 1234567 = 1.234567, the range
    for this data type is -2147.483647 to 2147.483647.

Arguments:

    pMulDivPair - Pointer to array of MULDIVPAIR data structure, the first
                  structure in the array tell the count of the FD6 pairs,
                  a Divisor present flag and a Divisor, the FD6 pairs start
                  from second element in the array.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero then it assume no divisor is present,
    if Count of FD6 pairs is zero then it return FD6_0

Author:

    27-Aug-1992 Thu 18:13:55 updated  -by-  Daniel Chou (danielc)
        Re-write to remove variable argument conflict, and make it only passed
        a pointer to the MULDIVPAIR structure array

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`



@BEG_PROC   MulDivFD6Pairs  <pMulDivPair:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _DS _SI _DI _BP

    lds     si, pMulDivPair
    lodsw                               ; get count
    xor     dx, dx                      ; clear dx for quick exit
    or      ax, ax
    jnz     short MulDivFD6PairCount

    jmp     MulDivFD6Pair9              ; exit with 0

MulDivFD6PairCount:

    mov     cx, ax                      ; cx=count
    lodsw                               ; get divisor present flag
    or      ax, ax                      ; has divisor ?
    jz      short MulDivFD6PairsStart

    mov     ax, WPTR [si]               ; get divisor = dx:ax
    mov     dx, WPTR [si + 2]           ;

MulDivFD6PairStart:

    push    dx                          ; save divisor dx:ax on stack
    push    ax
    add     si, 4                       ; jump to first pair

MulDivFD6PairsStart:

    xor     dx, dx                      ; sum = 0 to start with
    xor     ax, ax
    xor     bp, bp
    xor     bx, bx

MulDivFD6PairsLoop:

    push    cx                          ; save count
    push    dx                          ; save sum dx:ax:bp:bx
    push    ax
    push    bp
    push    bx

    lodsw
    mov     cx, ax
    lodsw
    mov     dx, ax
    lodsw
    mov     bx, ax
    lodsw

    ;
    ; now dx:cx is multipler, ax:bx=multiplicand
    ;

    mov     bp, ax                      ; bp:bx=multiplicand
    mov     ax, cx                      ; dx:ax=multiplier

MulDivFD6Pairs0:

    or      cx, dx
    jz      short MulDivFD6PairsZero   ; zero content

    mov     cx, bx
    or      cx, bp
    jz      short MulDivFD6PairsZero   ; zero content

MulDivFD6Pairs1:

    xor     cx, cx                      ; initialize sign to zero
    or      bp, bp
    jns     short MulDivFD6Pairs2

    NEG32_FROMR16HL bp, bx
    not     cx                          ; flip the sign

MulDivFD6Pairs2:

    or      dx, dx
    jns     short MulDivFD6Pairs3

    NEG32_FROMR16HL dx, ax
    not     cx

MulDivFD6Pairs3:

    push    si                          ; save pFD6Pairs
    push    cx                          ; save it
    call    U32MulU32_U64               ; dx:ax * bp:bx = dx:ax:bp:bx
    pop     cx                          ; restore sign indicator
    pop     si
    jcxz    short MulDivFD6PairsPos

MulDivFD6PairsNeg:

    pop     cx
    sub     cx, bx
    mov     bx, cx
    pop     cx
    sbb     cx, bp
    mov     bp, cx
    pop     cx
    sbb     cx, ax
    mov     ax, cx
    pop     cx
    sbb     cx, dx
    mov     dx, cx
    jmp     short MulDivFD6PairsLoop2

MulDivFD6PairsZero:

    pop     bx
    pop     bp
    pop     ax
    pop     dx
    jmp     short MulDivFD6PairsLoop2

MulDivFD6PairsPos:

    pop     cx
    add     bx, cx
    pop     cx
    adc     bp, cx
    pop     cx
    adc     ax, cx
    pop     cx
    adc     dx, cx

MulDivFD6PairsLoop2:

    pop     cx
    dec     cx
    jz      short MulDivFD6Pairs4
    jmp     MulDivFD6PairsLoop

MulDivFD6Pairs4:                           ; dx:ax:bp:bx=number

    xor     cx, cx
    or      dx, dx
    jns     short MulDivFD6Pairs5

    not     bx
    not     bp
    not     ax
    not     dx
    add     bx, 1
    adc     bp, cx
    adc     ax, cx
    adc     dx, cx
    not     cx                          ; flip sign

MulDivFD6Pairs5:

    pop     di                          ; get divisor si:di
    pop     si

    or      si, si                      ; a negative number ?
    jns     short MulDivFD6Pair6
    not     cx

MulDivFD6Pair6:

    push    cx                          ; save sign indicator
    mov     cx, si
    or      cx, si                      ; if divisor = 0, then divide by 1.0
    jz      short MulDivFD6Pair7

    call    U64DivU32_U32               ; dx:ax:bp:bx / si:di = dx:ax/bx:cx

    ;
    ; need to round up (if remainder (bx:cx * 2) >= si:di
    ;

    add     cx, cx
    adc     bx, bx
    sub     cx, di
    sbb     bx, si
    cmc
    adc     ax, 0
    adc     dx, 0
    jmp     short MulDivFD6Pairs8

MulDivFD6Pairs7:

    call    U64Div1000000               ; dx:ax:bp:bx / 1000000 = dx:ax

MulDivFD6Pairs8:

    pop     cx                          ; restore sign indicator

    S32_FROMR16HL_SR16  dx, ax, cx

MulDivFD6Pairs9:

    @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER  _SI _DI

    mov     _SI, DPTR pMulDivPair
    xor     _AX, _AX                    ; clear return
    lodsw                               ; get count
    or      ax, ax                      ; if count=0, then return 0.0
    jz      short MulDivFD6PairsNone

    mov     _CX, _AX                    ; _CX=count

    lodsw                               ; get divisor present flag
    or      ax, ax                      ; if none then divisor=0
    jz      short MulDivFD6PairStart

    mov     _AX, DPTR [_SI]

MulDivFD6PairStart:

    push    _AX                         ; save divisor
    add     _SI, 4                      ; jump to first pair

    xor     _BX, _BX
    xor     _DI, _DI                    ; _BX:_DI is the sum = initialize to 0

MulDivFD6PairsLoop:

    lodsd                               ; get multiplicand
    mov     _DX, _AX
    lodsd
    or      _AX, _AX                    ; see if zero, if zero do nothing
    jz      short MulDivFD6PairsLoop2
    or      _DX, _DX
    jz      short MulDivFD6PairsLoop2
    imul    _DX                         ; _DX:_AX = result

MulDivFD6Pairs1:

    add     _DI, _AX
    adc     _BX, _DX

MulDivFD6PairsLoop2:

    loop    MulDivFD6PairsLoop

MulDivFD6Pairs2:

    mov     _AX, _DI
    mov     _DX, _BX

    shl     _BX, 1
    sbb     _BX, _BX                    ; _BX=sign indicator

    S64_FROMR32HL_SR32  _DX, _AX, _BX   ; flip the _DX, _AX according the sign

    mov     _DI, FD6NUM_1_DW            ; now _DX:_AX / _DI 1.0 (decimal)

    pop     _CX                         ; get divisor
    jecxz   short MulDivFD6Pairs3       ; divide by 1.0 if divisor=0.0
    cmp     _CX, _DI                    ; divisor=1.0?
    jz      short MulDivFD6Pairs3

    mov     _DI, _CX                    ; using new divisor
    shl     _CX, 1
    sbb     _CX, _CX                    ; _CX=sign indicator
    xor     _DI, _CX
    sub     _DI, _CX                    ; _DI=absolute divisor
    xor     _BX, _CX                    ; flip the final sign if any

MulDivFD6Pairs3:

    cmp     _DX, _DI                    ; will divison overflow?
    jae     short MulDivFD6PairsOverflow

    div     _DI                         ; edx=remainder, eax=quotient

    shr     _DI, 1                      ; if remainder >= (divisor / 2) then
    sub     _DX, _DI                    ; round it up
    cmc
    adc     _AX, 0                      ; round it up

MulDivFD6PairsSign:

    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX

MulDivFD6Pairs4:

    cdq                                 ; convert to 64-bit

    @EXIT

MulDivFD6PairsNone:

    xor     _AX, _AX
    jmp     short MulDivFD6Pairs4

MulDivFD6PairsOverflow:

    mov     _AX, 07fffffffh             ; return maximum number
    jmp     short MulDivFD6PairsSign

ENDIF                                   ; i8086 or i286


@END_PROC




SUBTTL  DivFD6
PAGE

COMMENT `

Routine Description:

    This function divide two FD6 numbers (FIX decimal point decimal long
    number, the LONG DECIMAL POINT SIX (FD6) is a number with lowest 6 digits
    as fraction to the right of the decimal point), so like 1234567 = 1.234567,
    the range for this data type is -2147.483647 to 2147.483647.

Arguments:

    Dividend    - a 32-bit FD6 dividend number.

    Divisor     - a 32-bit FD6 divisor number.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero the return value will be dividend, if
    overflow happened, then maximum FD6 number will be returned (ie.
    2147.483647)

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`

@BEG_PROC   DivFD6  <Dividend:DWORD, Divisor:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _SI _DI _BP                 ; save used registers

    mov     di, WPTR Divisor
    mov     si, WPTR Divisor + 2
    mov     ax, WPTR Dividend
    mov     dx, WPTR Dividend + 2

    mov     cx, si
    or      cx, di
    jz      short DivFD6_Divisor0

DivFD6_Chk1:

    mov     cx, dx
    or      cx, ax
    jz      short DivFD6_Done

DivFD6_Chk1:                            ; dx:ax=dividend, si:di=divisor

    xor     cx, cx
    or      si, si
    jns     short DivFD6_1

    NEG32_FROMR16HL si, di
    not     cx

DivFD6_1:                               ; check if divided by 1.0 or -1.0

    cmp     si, FD6NUM_1_HW
    jnz     short DivFD6_1a
    cmp     di, FD6NUM_1_LW
    jz      short DivFD6_Sign           ; exit with dx:ax and sign in cx

DivFD6_1a:

    or      dx, dx
    jns     short DivFD6_2

    NEG32_FROMR16HL dx, ax
    not     cx

DivFD6_2:

    cmp     dx, si
    jnz     short DivFD6_3
    cmp     ax, di
    jnz     short DivFD6_3

    mov     dx, FD6NUM_1_HW
    mov     ax, FD6NUM_1_LW
    jmp     short DivFD6_Sign           ; dx:ax=si:di, return 1.0 or -1.0

DivFD6_3:

    push    cx                          ; save sign
    call    u32Mul1000000               ; dx:ax * 0xf4240 = dx:ax:bp:bx
    call    U64DivU32_U32               ; dx:ax:bp:bx / si:di = dx:ax/bx:cx

    ;
    ; Check if we have 0.0000005 to round up, Divisor - (reminder * 2) >= 0
    ; that is.
    ;

    sub     di, cx                      ; Divisor - Remainder = X (si:di)
    sbb     si, bx
    sub     cx, di
    sbb     bx, si                      ; Remainder - X = U (bx:cx)
    cmc
    adc     ax, 0                       ; if (U >= 0) then round up
    adc     dx, 0

    pop     cx                          ; cx=sign

DivFD6_Sign:

    S32_FROMR16HL_SR16  dx, ax cx

DivFD6_Done:

    @EXIT

DivFD6_Divisor0:

    inc     ax
    jmp     short DivFD6_Chk0


ELSE                                    ; assume i386 or up at here

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Divisor           ; see if this guy is zero
    cdq                                 ; save dx sign
    mov     _BX, _DX                    ; _BX = sign
    xor     _AX, _DX                    ; take divisor as absolute number _AX
    sub     _AX, _DX                    ; zero ? DO NOT DESTROY ZERO FLAG
    jz      short DivFD6_Divisor0

DivFD6_1:

    mov     _CX, _AX                    ; save absolute divisor in _CX
    mov     _AX, DPTR Dividend          ; _AX=Dividend, _CX=Divisor, _BX=Sign
    cdq                                 ; sign extended, saved the sign at here
    xor     _AX, _DX
    sub     _AX, _DX                    ; eax=absolute dividend now
    jz      short DivFD6_Done           ; dividend = 0, return 0
    xor     _BX, _DX                    ; _BX=final sign only if _BX != _DX

    ;
    ; _AX=Dividend, _CX=Divisor, _BX = final sign indicator
    ;

    mov     _DX, FD6NUM_1_DW            ; multiply dividend by 1.0 (decimal)
    cmp     _CX, _DX                    ; if divisor == 1.0 or -1.0 then exit
    jz      short DivFD6_Sign

    xchg    _AX, _DX                    ; _AX = 1.0, _DX=Dividend
    cmp     _DX, _CX
    jz      short DivFD6_Sign           ; Divisor=Dividend, return 1.0 or -1.0

    mul     _DX                         ; edx:eax = 64-bit product

    cmp     _DX, _CX                    ; will division overflow ?
    jae     short DivFD6_Overflow

    div     _CX                         ; edx=remainder, eax=quotient

    ;
    ; Check if we have 0.0000005 to round up, Divisor - (reminder * 2) >= 0
    ; that is.
    ;

    sub     _CX, _DX                    ; divisor - remainder = X
    sub     _DX, _CX                    ; Remainder - X = U
    cmc                                 ; if U >= 0 then round up
    adc     _AX, 0

DivFD6_Sign:

    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX
    cdq                                 ; make it 64-bits

DivFD6_Done:

    @EXIT                               ; exiting function

DivFD6_Overflow:

    mov     _AX, 07fffffffh             ; return maximum number
    jmp     short DivFD6_Sign

DivFD6_Divisor0:

    inc     _AX
    jmp     short DivFD6_1


ENDIF                                   ; i8086 or i286


@END_PROC



SUBTTL  FD6DivL
PAGE

COMMENT `

Routine Description:

    This function divide a FD6 number by a LONG integer.

Arguments:

    Dividend    - a 32-bit FD6 dividend number.

    Divisor     - a 32-bit signed number.

Return Value:

    The return value is the 32-bit FD6 number which is round up from 7th
    decimal points, there is no remainder returned.

    NO ERROR returned, if divisor is zero the return value will be dividend, if
    overflow happened, then maximum FD6 number will be returned (ie.
    2147.483647)

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   FD6DivL <Dividend:DWORD, Divisor:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU

    @ENTER  _SI _DI _BP                 ; save used registers

    mov     di, WPTR Divisor
    mov     si, WPTR Divisor + 2
    mov     ax, WPTR Dividend
    mov     dx, WPTR Dividend + 2

    mov     cx, si
    or      cx, di
    jz      short FD6DivL_Done
    mov     cx, dx
    or      cx, ax
    jz      short FD6DivL_Done

FD6DivL_Chk1:                            ; dx:ax=dividend, si:di=divisor

    xor     cx, cx
    or      si, si
    jns     short FD6DivL_1

    NEG32_FROMR16HL si, di
    not     cx

FD6DivL_1:                               ; check if divided by 1.0 or -1.0

    or      dx, dx
    jns     short FD6DivL_2

    NEG32_FROMR16HL dx, ax
    not     cx

FD6DivL_2:

    push    cx                          ; save sign
    call    U32DivU32_U32               ; dx:ax / si:di = dx:ax / bx:cx
    jz      short FD6DivL_3             ; zero flag set if no remainder

    ;
    ; Check if we have 0.0000005 to round up, Divisor - (reminder * 2) >= 0
    ; that is.
    ;

    sub     di, cx                      ; Divisor - Remainder = X (si:di)
    sbb     si, bx
    sub     cx, di
    sbb     bx, si                      ; Remainder - X = U (bx:cx)
    cmc
    adc     ax, 0                       ; if (U >= 0) then round up
    adc     dx, 0

FD6DivL_3:

    pop     cx                          ; cx=sign

FD6DivL_Sign:

    S32_FROMR16HL_SR16  dx, ax cx

FD6DivL_Done:

    @EXIT

ELSE                                    ; assume i386 or up at here

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Divisor           ; see if this guy is zero
    cdq                                 ; save dx sign
    mov     _BX, _DX                    ; _BX = sign
    xor     _AX, _DX                    ; take divisor as absolute number _AX
    sub     _AX, _DX                    ; zero ? DO NOT DESTROY ZERO FLAG
    mov     _CX, _AX                    ; save absolute divisor in _CX
    mov     _AX, DPTR Dividend          ; _AX=Dividend, _CX=Divisor, _BX=Sign
    jz      short FD6DivL_Done          ; If Divisor=0, return Dividend

    cdq                                 ; sign extended, saved the sign at here
    xor     _AX, _DX
    sub     _AX, _DX                    ; eax=absolute dividend now
    jz      short FD6DivL_Done          ; dividend = 0, return 0
    xor     _BX, _DX                    ; _BX=final sign only if _BX != _DX

    ;
    ; _AX=Dividend, _CX=Divisor, _BX = final sign indicator
    ;

    xor     _DX, _DX                    ; 0:_AX / _CX
    div     _CX                         ; _DX=remainder, _AX=quotient

    ;
    ; Check if we have 0.0000005 to round up, Divisor - (reminder * 2) >= 0
    ; that is.
    ;

    sub     _CX, _DX                    ; divisor - remainder = X
    sub     _DX, _CX                    ; Remainder - X = U
    cmc                                 ; if U >= 0 then round up
    adc     _AX, 0

FD6DivL_Sign:

    xor     _AX, _BX                    ; do any sign if necessary
    sub     _AX, _BX
    cdq                                 ; make it 64-bits

FD6DivL_Done:

    @EXIT                               ; exiting function

ENDIF                                   ; i8086 or i286


@END_PROC



;=============================================================================

IF 0

SUBTTL  FD6IntFrac
PAGE

COMMENT `

Routine Description:

    This function is used to extract integer/fraction portion of the FIX
    decimal point decimal long number, the LONG DECIMAL POINT SIX (FD6)
    is a number with lowest 6 digits as fraction to the right of the decimal
    point), so like 1234567 = 1.234567, the range for this data type is
    -2147.483647 - 2147.483647.

Arguments:

    Number      - the FD6 number which will be break down as integer portion
                  and fraction portion.  if -1.123456 is passed then return
                  will be INTEGER = -1 (16-bit extended to 32-bit), and
                  FRACTION = -123456 (ie. -0.123456)

    pFrac       - pointer to the DWORD (32-bit) to store the fraction portion
                  of the FD6 (Num) number.

Return Value:

    The return value is the sign 16-bit integer of the number passed in, it
    will be extented to 32-bit for caller's convinent.

    Since the integer portion for the FD6 only -2147 to 2147 it only need
    16-bit number to retreat.

    The fraction portion is stored at pointer points by the pFrac parameter.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`



@BEG_PROC   FD6IntFrac  <Number:DWORD, pFrac:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU


    @ENTER                              ; enter function

    mov     ax, WPTR Number
    mov     dx, WPTR Number + 2

    mov     bx, dx
    shl     bx, 1
    sbb     bx, bx                      ; bx=0xffff if dx:ax is negative

    S32_FROMR16HL_SR16  dx, ax, bx

    mov     bl, al                      ;
    and     bl, 0fh                     ; save lowest 4 bits of dividend in BL

    shr     dx, 1
    rcr     ax, 1
    shr     dx, 1
    rcr     ax, 1
    shr     dx, 1
    rcr     ax, 1
    shr     dx, 1
    rcr     ax, 1

    mov     cx, 0f424h
    div     cx                          ; dx:bl=remainder, ax=quotient

    rol     dx, 1                       ; rotate the dx left 4 times to put
    rol     dx, 1                       ; saved lowest 4 remainder bits back
    rol     dx, 1
    rol     dx, 1
    mov     cx, 0fh
    and     cx, dx                      ; cx=high portion of remainder
    xor     dx, cx                      ; clear dx low 4 bits
    or      dl, bl                      ; move low 4 bits in, cx:dx=remainder
    ;
    mov     bl, bh
    xor     ax, bx
    sub     ax, bx

    S32_FROMR16HL_SR16  dx, cx, bx

    les     bx, pFrac
    mov     WPTR es:[bx], dx            ; save fraction
    mov     WPTR es:[bx+2], cx
    cwd                                 ; dx:ax=quotient

    @EXIT

ELSE                                    ; assume i386 or up at here

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER                              ; entering function

    mov     _AX, DPTR Number            ; load the 32-bit number
    cdq                                 ; extended to 64-bits
    mov     _CX, 1000000                ; divisor = 1000000 decimal
    idiv    _CX                         ; edx=r, eax=q
    mov     _BX, DPTR pFrac
    mov     DPTR [_BX], _DX             ; save remainder
    cdq                                 ; _AX=quotient, now sign extended

    @EXIT                               ; exiting function

ENDIF                                   ; i8086 or i286


@END_PROC


ENDIF

;=============================================================================



SUBTTL  FractionToMantissa
PAGE

COMMENT `

Routine Description:

    This function convert a fraction FD6 number to the logarithm mantissa
    with correction data.

Arguments:

    Fraction        - the fraction number after decimal place, because
                      we have mantissa table up to two decimal places, the
                      correction is necessary because logarithm numbers are
                      no linear.  The number is range from 0.000000-0.999999

    CorrectData     - The correction data which from MantissaCorrectData[]


Return Value:

    No error returned, the return value is the Mantissa value for the fraction
    passed in.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   FractionToMantissa  <Fraction:DWORD, CorrectData:DWORD>



IF i8086 OR i286                        ; lots of works for this kind of CPU


    @ENTER  _SI _DI _BP                 ; save used registers

    mov     ax, WPTR Fraction
    mov     dx, WPTR Fraction + 2       ; 0-999999 decimal
    mov     si, ax
    and     si, 1                           ; 1 bit remainder
    shr     dx, 1                           ; divide by (100000/2) so dividend
    rcr     ax, 1                           ; must shift right by 1
    mov     cx, 0c350h                      ; 100000 / 2
    div     cx                              ; dx=remainder, ax=quotient
    mov     cx, ax                          ; cx=0-9, quotient
    inc     cx                              ; make it 1-10
    mov     di, dx                          ; remainder = (remainder*2) + save
    shr     si, 1                           ; check the lowest remainder bit
    adc     di, di                          ; put it into final remainder
    adc     si, si                          ; si = 0/1

    ;
    ; starting correction
    ;
    ;       <---High Word---> <----Low Word--->
    ;  Bit#  3          2          1          0
    ;       10987654 32109876 54321098 76543210
    ;       | | | |  | |  |   ||  |  |
    ;       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    ;       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    ;       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    ;       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    ;       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    ;       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    ;       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    ;       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    ;       | | +----------------------- x.005-x.006 (0-3) Correct 7
    ;       | +------------------------- x.004-x.005 (0-3) Correct 8
    ;       +--------------------------- x.003-x.004 (0-3) Correct 9
    ;

    mov     ax, WPTR CorrectData
    mov     dx, WPTR CorrectData + 2    ; dx:ax=correct data

    mov     bp, ax                          ; first get the DifMin = 9 bits
    and     bp, 01ffh                       ; bp=base
    xor     bx, bx                          ; different accumulator=base

Frac2Mant1:

    mov     ch, ah
    mov     ax, 7
    shr     ch, 1
    and     al, ch
    dec     cl
    jz      short Frac2MantGetFrac          ; bx=total, next dif=ax
    add     bx, ax
    add     bx, bp

Frac2Mant2:

    shr     ch, 1                           ; shift away correction 1
    shr     ch, 1
    shr     ch, 1                           ; ch bit 3 is the correction 10
    mov     al, 7
    and     al, ch
    dec     cl
    jz      short Frac2MantGetFrac          ;
    add     bx, ax                          ; correct 2
    add     bx, bp

Frac2Mant3:

    mov     ax, 7
    and     ax, dx
    dec     cl                              ; correct 3
    jz      short Frac2MantGetFrac
    add     bx, ax
    add     bx, bp

Frac2Mant4:

    mov     ax, 7
    cmp     al, ch                          ; if bit 3 of ch is on then carry
    rcr     dx, 1                           ; we actually move that bit into
    shr     dx, 1                           ; bit 15 of dx
    shr     dx, 1                           ; shift away correction 3
    and     ax, dx
    dec     cl
    jz      short Frac2MantGetFrac

    shr     dx, 1                           ; shift away correction 4
    mov     ch, 3                           ; this is the mask, all 2 bits now

Frac2Mant5_10:

    add     bx, ax
    add     bx, bp
    shr     dx, 1
    shr     dx, 1
    mov     al, ch
    and     ax, dx
    dec     cl
    jnz     short Frac2Mant5_10

Frac2MantGetFrac:

    add     bp, ax                          ; add minimum diff. to next table

    ;
    ; Now,    bx=Minimum x.00x,
    ;         bp=different to the next mantissa x.000x + 0.0001
    ;      si:di=fraction ratio (0.000000 - 0.099999)
    ;
    ; Total Dif = bx + ((bp * si:di) / 100000)
    ;
    ; si:di * ax will never greater than 32-bit because (si:di < 100000) and
    ; BP < (2^9 = 512)
    ;

    mov     ax, si
    or      ax, di
    jz      short Frac2MantDoneFrac
    mov     ax, si                          ; if si=0, then no 'mul si'
    or      ax, ax
    jz      short Frac2MantDoneHF
    mov     ax, bp                          ;        si:di
    mul     si                              ;  *        ax

Frac2MantDoneHF:

    xchg    bp, ax                          ; ---------------
    mul     di                              ;        dx:ax
    add     dx, bp                          ;        bp
    mov     cx, 0c350h                      ; ----------------
    add     ax, cx                          ;        dx:ax
    adc     dx, 0                           ; now round up
    shr     dx, 1                           ; divide by (100000/2) so dividend
    rcr     ax, 1                           ; must also right shift by 1
    div     cx                              ; ax=qotient, ignored the remainder

Frac2MantDoneFrac:

    xor     dx, dx                          ; using dx:ax=final number
    add     ax, bx
    adc     dx, dx                          ; dx:ax=fraction mantissa number

    @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER  _SI _DI _BP                     ; entering function

    mov     _AX, DPTR Fraction
    cdq
    mov     _CX, 100000
    div     _CX                             ; _DX=r, _AX=q
    mov     _CX, _AX                        ; _CX=q+1
    inc     _CX                             ; _CX= 1-10

    ;
    ; starting correction
    ;
    ;       <---High Word---> <----Low Word--->
    ;  Bit#  3          2          1          0
    ;       10987654 32109876 54321098 76543210
    ;       | | | |  | |  |   ||  |  |
    ;       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    ;       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    ;       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    ;       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    ;       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    ;       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    ;       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    ;       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    ;       | | +----------------------- x.005-x.006 (0-3) Correct 7
    ;       | +------------------------- x.004-x.005 (0-3) Correct 8
    ;       +--------------------------- x.003-x.004 (0-3) Correct 9
    ;

    mov     _DI, DPTR CorrectData      ; _AX=correct data
    mov     _BP, _DI
    and     _BP, 01ffh                      ; _SI = 9 bit of the DifMin
    mov     _SI, 7
    mov     bx, di
    shl     bx, 1                           ; get the correction 10
    rcr     _DI, 1                          ; put into bit 31
    shr     _DI, 8
    xor     _BX, _BX

Frac2Mant1:

    mov     _AX, _SI
    and     _AX, _DI
    dec     cl
    jz      short Frac2MantGetFrac
    add     _BX, _AX
    add     _BX, _BP

Frac2Mant2:

    shr     _DI, 3
    mov     _AX, _SI
    and     _AX, _DI
    dec     cl
    jz      short Frac2MantGetFrac          ;
    add     _BX, _AX                        ; correct 2
    add     _BX, _BP

Frac2Mant3:

    shr     _DI, 4                          ; shift away correction 2/10
    mov     _AX, _SI
    and     _AX, _DI
    dec     cl                              ; correct 3
    jz      short Frac2MantGetFrac          ;
    add     _BX, _AX                        ;
    add     _BX, _BP

Frac2Mant4:

    shr     _DI, 3
    mov     _AX, _SI
    and     _AX, _DI
    dec     cl                              ; correct 4
    jz      short Frac2MantGetFrac          ;
    shr     _DI, 1                          ; pre-shift, remainding all 2 bits
    mov     _SI, 3

Frac2Mant5_10:

    add     _BX, _AX
    add     _BX, _BP
    shr     _DI, 2
    mov     _AX, _SI
    and     _AX, _DI
    dec     cl
    jnz     short Frac2Mant5_10

Frac2MantGetFrac:

    add     _BP, _AX

    ;
    ; Now,    _BX=Minimum x.00x,
    ;         _BP=different to the next mantissa x.000x + 0.0001
    ;         _DX=fraction ratio (0.000000 - 0.099999)
    ;
    ; Total Dif = _BX + ((_BP * _DX) / 100000)
    ;
    ; _BP * _DX will never greater than 32-bit because (_DX < 100000) and
    ; _BP < (2^9 = 512)
    ;

    mov     _AX, _BX
    or      _DX, _DX                        ; zero fraction?
    jz      short Frac2MantDoneFrac
    mov     _AX, _BP
    mul     _DX                             ; _DX:_AX=products
    add     _AX, 50000                      ; round up
    adc     _DX, 0
    mov     _CX, 100000
    div     _CX                             ; _AX=quotient
    add     _AX, _BX

Frac2MantDoneFrac:

    cdq                                     ; _DX:_AX=final number

    @EXIT                                   ; exiting function

ENDIF                                       ; i8086 or i286


@END_PROC



FD6P1ToP9   dd   100000
            dd   200000
            dd   300000
            dd   400000
            dd   500000
            dd   600000
            dd   700000
            dd   800000
            dd   900000
            dd  1000000



SUBTTL  MantissaToFraction
PAGE

COMMENT `

Routine Description:

    This function take mantissa number and convert it to the decimal fraction
    in FD6 format.

Arguments:

    Mantissa        - the mantissa values which will converted to the the
                      fraction number.

    CorrectData     - The correction data which from MantissaCorrectData[]

Return Value:

    No error returned, the return value is the fraction value for the mantissa
    passed in, it range from 0.000000 - 1.000000

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

Revision History:

`


@BEG_PROC   MantissaToFraction  <Mantissa:DWORD, CorrectData:DWORD>




IF i8086 OR i286                        ; lots of works for this kind of CPU


    @ENTER  _SI _DI _BP                 ; saved used registers

    ;
    ; starting correction
    ;
    ;       <---High Word---> <----Low Word--->
    ;  Bit#  3          2          1          0
    ;       10987654 32109876 54321098 76543210
    ;       | | | |  | |  |   ||  |  |
    ;       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    ;       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    ;       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    ;       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    ;       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    ;       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    ;       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    ;       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    ;       | | +----------------------- x.005-x.006 (0-3) Correct 7
    ;       | +------------------------- x.004-x.005 (0-3) Correct 8
    ;       +--------------------------- x.003-x.004 (0-3) Correct 9
    ;

    mov     ax, WPTR Mantissa           ; only 16-bit needed
    mov     cx, WPTR CorrectData
    mov     dx, WPTR CorrectData + 2    ; dx:cx=correct data

    mov     bp, cx                          ; first get the DifMin = 9 bits
    and     bp, 01ffh                       ; bp=base
    xor     si, si                          ; si=fraction index
    mov     di, 7

Mant2Frac1:

    mov     bh, ch
    shr     bh, 1
    mov     cx, di
    and     cl, bh
    inc     si                              ; increase the fraction index
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jle     short Mant2FracGetFrac

Mant2Frac2:

    shr     bh, 1                           ; shift away correction 1
    shr     bh, 1
    shr     bh, 1                           ; bh bit 3 is the correction 10
    mov     cx, di
    and     cl, bh
    inc     si                              ; increase the fraction index
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jle     short Mant2FracGetFrac

Mant2Frac3:

    mov     cx, di
    and     cx, dx
    inc     si                              ; increase the fraction index
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jle     short Mant2FracGetFrac

Mant2Frac4:

    mov     cx, di
    cmp     cl, bh                          ; if bit 3 of bh is on then carry
    rcr     dx, 1                           ; we actually move that bit into
    shr     dx, 1                           ; bit 15 of dx
    shr     dx, 1                           ; shift away correction 3
    and     cx, dx
    inc     si                              ; increase the fraction index
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jle     short Mant2FracGetFrac

    shr     dx, 1                           ; shift away correction 4
    mov     di, 3                           ; this is the mask, all 2 bits now

Mant2Frac5_10:

    shr     dx, 1
    shr     dx, 1
    mov     cx, di
    and     cx, dx
    inc     si
    add     cx, bp                          ; cx=range
    sub     ax, cx                          ; ax=mantissa
    jg      short Mant2Frac5_10

Mant2FracGetFrac:

    ;
    ; si = fraction index of 000000 - 900000 (0-9)
    ; cx = range,
    ; ax = mantissa, if (ax=0) then si=frac else if (ax<0) then add range back
    ;
    ; Final Frac = (si * 1000000) + (((ax * 100000) + cx / 2) / cx)
    ;

    mov     dx, 0
    jz      short Mant2FracGetFracH         ; si=fraction index

    add     ax, cx                          ; move it back since negative
    dec     si                              ; move the index back by one
    mov     dx, 0c350h                      ; 100000 = (50000 * 2)
    mul     dx                              ; dx:ax= ax * 50000 of the mantissa
    add     ax, ax
    adc     dx, dx                          ; dx:ax = ax * 100000

    xor     di, di
    cmp     dx, cx
    jb      short Mant2FracDiv2

    mov     di, ax                          ; save dividend L
    mov     ax, dx
    xor     dx, dx
    div     cx                              ; 0:ax / bx, dx=r, ax=q
    xchg    di, ax                          ; dx:ax=remainder, di=q

Mant2FracDiv2:

    div     cx                              ; dx=remainder, di:ax=q

    add     dx, dx                          ; to round up, check if
    sub     dx, cx                          ; (remainder * 2) > divisor, if yes
    mov     dx, 0
    cmc                                     ; then increase the qoutient by 1
    adc     ax, dx
    adc     dx, di                          ; dx:ax=((ax*100000) + cx/2) / cx)

Mant2FracGetFracH:

    dec     si
    js      short Mant2FracDone
    add     si, si                          ; 4 bytes alignment
    add     si, si
    add     ax, WORD PTR cs:FD6P1ToP9[si]
    adc     dx, WORD PTR cs:FD6P1ToP9[si+2]

Mant2FracDone:

    @EXIT

ELSE

    ;*************************************************************************
    ; for i386 or upward compatble
    ;*************************************************************************

    @ENTER  _SI _DI                          ; entering function

    ;
    ; starting correction
    ;
    ;       <---High Word---> <----Low Word--->
    ;  Bit#  3          2          1          0
    ;       10987654 32109876 54321098 76543210
    ;       | | | |  | |  |   ||  |  |
    ;       | | | |  | |  |   ||  |  +-- x.000 Minimum Difference
    ;       | | | |  | |  |   ||  +----- x.001-x.002 (0-7) Correct 1
    ;       | | | |  | |  |   |+-------- x.000-x.001 (0-7) Correct 2
    ;       | | | |  | |  |   +--------- x.009-y.000 (0-1) Correct 10
    ;       | | | |  | |  +------------- x.009-y.000 (0-7) Correct 3
    ;       | | | |  | +---------------- x.008-x.009 (0-7) Correct 4
    ;       | | | |  +------------------ x.007-x.008 (0-3) Correct 5
    ;       | | | +--------------------- x.006-x.007 (0-3) Correct 6
    ;       | | +----------------------- x.005-x.006 (0-3) Correct 7
    ;       | +------------------------- x.004-x.005 (0-3) Correct 8
    ;       +--------------------------- x.003-x.004 (0-3) Correct 9
    ;

    movzx   _AX, WPTR Mantissa          ; only 16-bit needed
    mov     _DX, DPTR CorrectData      ; _DX=correct data
    mov     _CX, _DX                        ; first get the DifMin = 9 bits
    and     _CX, 01ffh                      ; _CX=base
    mov     bx, dx                          ; move correction 10 (1 bit) to
    shl     bx, 1                           ; _DX bit 31
    rcr     _DX, 1
    shr     _DX, 8                          ; shift out rest of the bits
    xor     _BX, _BX                        ; _BX=fraction count
    mov     _SI, 7                          ; si=mask

Mant2Frac1:

    mov     _DI, _SI                        ; get mask
    and     _DI, _DX                        ; _DI=current correction 1
    inc     _BX                             ; increase the fraction index
    add     _DI, _CX                        ; _DI=range to next
    sub     _AX, _DI                        ; substract the mantissa from it
    jle     short Mant2FracGetFrac

Mant2Frac2:

    shr     _DX, 3                          ; shift away correction 1
    mov     _DI, _SI
    and     _DI, _DX
    inc     _BX                             ; increase the fraction index
    add     _DI, _CX                        ; _DI=range to next
    sub     _AX, _DI                        ; substract the mantissa from it
    jle     short Mant2FracGetFrac

Mant2Frac3:

    shr     _DX, 4                          ; shift away correction 2/10
    mov     _DI, _SI
    and     _DI, _DX
    inc     _BX                             ; increase the fraction index
    add     _DI, _CX                        ; _DI=range to next
    sub     _AX, _DI                        ; substract the mantissa from it
    jle     short Mant2FracGetFrac

Mant2Frac4:

    shr     _DX, 3                          ; shift away correction 3
    mov     _DI, _SI
    and     _DI, _DX
    inc     _BX                             ; increase the fraction index
    add     _DI, _CX                        ; _DI=range to next
    sub     _AX, _DI                        ; substract the mantissa from it
    jle     short Mant2FracGetFrac

    mov     _SI, 3                          ; all the rest are 2 bits
    shr     _DX, 1                          ; pre-shift 1 bit for correction 4

Mant2Frac5_10:

    shr     _DX, 2
    mov     _DI, _SI
    and     _DI, _DX
    inc     _BX
    add     _DI, _CX
    sub     _AX, _DI
    jg      short Mant2Frac5_10

Mant2FracGetFrac:

    ;
    ; _BX = fraction index of 000000 - 900000 (0-9)
    ; _DI = range,
    ; _AX = mantissa, if (_AX=0) then _BX=frac
    ;                 else if (_AX<0) then add range back
    ;
    ; Final Frac = (_BX * 1000000) + (((_AX * 100000) + _DI / 2) / _DI)
    ;

    or      _AX, _AX
    jz      short Mant2FracGetFracH         ; BX=fraction index
    add     _AX, _DI                        ; _AX is negative, move it back
    dec     _BX                             ; by 1 step
    mov     _CX, 100000
    mul     _CX                             ; _DX:_AX=products
    mov     _CX, _DI
    shr     _CX, 1                          ; round up
    add     _AX, _CX
    adc     _DX, 0
    div     _DI                             ; _DX=r, _AX=q

Mant2FracGetFracH:

    dec     _BX                             ; see if alrady 0
    js      short Mant2FracDone
    add     _AX, DPTR cs:FD6P1ToP9[_BX * 4]     ; 4 bytes alignment

Mant2FracDone:

    cdq                                     ; _AX --> _DX:_AX

    @EXIT                                   ; exiting function

ENDIF                                       ; i8086 or i286


@END_PROC



;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@ Following codes only for 8086/80286, and all functions are used for       @
;@ internally                                                                @
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


IF i8086 OR i286                    ; lots of works for this kind of CPU


SUBTTL  U64Div1000000
PAGE

COMMENT `

Routine Description:

    This function divide a 64-bit number by 1000000 (decimal), this function
    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    dx:ax:bp:bx - dividend

Return Value:

    dx:ax = round up quotient (dx:ax:bp:bx / 1000000 decimal)
            if dx:ax = 0x7fff:ffff then an overflow has been occurred.

    bp:bx registers are destroyed.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)


Revision History:

`


    PUBLIC  U64Div1000000

U64Div1000000   label   near

    ;
    ; dx:ax:bp:bx / FD6NUM_1_DW (0f4240h) --> dx:ax=round up quotient
    ; registers bp/bx are destroyed
    ;
    ; dx:ax:bp:bx / FD6NUM_1_DW (0f4240h) = (dx:ax:bp:bx >> 4)/f424h)
    ;                                     = remainder << 4
    ;

    add     bx, 0a120h                  ; 0f4240h / 2 = 7a120h
    adc     bp, 7
    adc     ax, 0
    adc     dx, 0                       ; round up

    ; shift the dividend right by 4 (64 bits shifts)

    shr     dx, 1
    rcr     ax, 1
    rcr     bp, 1
    rcr     bx, 1

    shr     dx, 1
    rcr     ax, 1
    rcr     bp, 1
    rcr     bx, 1

    shr     dx, 1
    rcr     ax, 1
    rcr     bp, 1
    rcr     bx, 1

    shr     dx, 1
    rcr     ax, 1
    rcr     bp, 1
    rcr     bx, 1

u64Div1000000_0:

    or      dx, dx                      ; dx must be zero (lower 48 bits only)
    jnz     short u64Div1000000_OF      ; 0:ax:bp:bx / divisor
    mov     dx, ax                      ; aligned the dividend in dx:ax:bx
    mov     ax, bp                      ; dx:ax:bx / bp
    mov     bp, 0f424h                  ; divisor = f424h
    cmp     dx, bp
    jae     short u64Div1000000_OF      ; dx:ax:bx / bp
    div     bp                          ; dx=r, ax=q
    xchg    ax, bx                      ; bx=q, dx:ax=remainder
    div     bp                          ; bx:ax=q
    mov     dx, bx                      ; dx:ax=q
    ret

u64Div1000000_OF:

    mov     ax, 0ffffh
    mov     dx, 07fffh
    ret



SUBTTL  U32Mul1000000
PAGE

COMMENT `

Routine Description:

    This function multiply a 32-bit number by 1000000 (decimal), this function
    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    dx:ax   - multiplicand

Return Value:

    dx:ax:bp:bx - final 64-bit number which is dx:ax * 1000000 decimal

    CX register destroyed

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)


Revision History:

`


    PUBLIC  u32Mul1000000

u32Mul1000000   label   near

    ;
    ; at return dx:ax:bp:bx is the (dx:ax * 1000000 (decimal))
    ; cx is destroyed
    ;
    ; dx:ax * FD6NUM_1_DW0 (0f4240h) = (dx:ax * f424h) << 4
    ;
    ;            dx:ax
    ;       x       bp
    ;    -----------------
    ;            ax:bp    x0 =    bp:bx
    ;         dx:bp       x1 = dx:ax
    ;---------------------
    ;

    mov     cx, 0f424h
    xor     bp, bp                      ; assuem x0=0
    xor     bx, bx
    or      ax, ax
    jz      short u32Mul1000000_1       ; jmp if ax=0
    mov     bx, dx                      ; save it
    mul     cx                          ; dx:ax=result = x0
    xchg    dx, bp
    xchg    ax, bx                      ; bp:bx=x0, ax=high 16-bit, dx=0
    xchg    dx, ax                      ; dx=high 16-bit, ax=0 to fall through

u32Mul1000000_1:

    xchg    dx, ax                      ; dx=0, ax=next 16-bit
    or      ax, ax
    jz      short u32Mul1000000_2       ; nothing to do
    mul     cx                          ; dx:ax=x1
    add     bp, ax                      ;         bp:bx = x0
    mov     ax, dx                      ;  +   dx:ax    = x1
    mov     dx, 0                       ;-----------------------
    adc     ax, dx                      ;   dx:ax:bp:bx = products
    adc     dx, dx

u32Mul1000000_2:

    add     bx, bx
    adc     bp, bp
    adc     ax, ax
    adc     dx, dx

    add     bx, bx
    adc     bp, bp
    adc     ax, ax
    adc     dx, dx

    add     bx, bx
    adc     bp, bp
    adc     ax, ax
    adc     dx, dx

    add     bx, bx
    adc     bp, bp
    adc     ax, ax
    adc     dx, dx
    ret




SUBTTL  U64DivU32_U32
PAGE

COMMENT `

Routine Description:

    This function divide a 64-bit number by 32-bit number.
    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    dx:ax:bp:bx - dividend
    si:di       - divisor

Return Value:

    bx:cx       - 32-bit unsigned quotient, if dx:ax = 7fff:ffff then overflow.
    dx:ax       - 32-bit unsigned remainder
    si:di       = divisor (unchanged)

    all other registers are destroyed

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

        Total re-construct, re-write, it make it calculate the 6 decimal
        points precision easier for not using slow floating emulation, the
        speed is faster then the reqular (long/long) routine in the
        standard library while it provide me all the necessary color calcuation
        with good precisions.

Revision History:

`

;==========================================================================
; Defined several useful data at here
;==========================================================================


RShiftTable equ this word
    dw      RShift_0
    dw      RShift_1
    dw      RShift_2
    dw      RShift_3
    dw      RShift_4
    dw      RShift_5
    dw      RShift_6
    dw      RShift_7

ShiftTable1     equ     this word
    dw      1000h       ; 00010000 00000000
    dw      0010h       ; 00000000 00010000

ShiftTable2     equ     this word
    dw      4000h       ; 01000000 00000000
    dw      0400h       ; 00000100 00000000
    dw      0040h       ; 00000000 01000000
    dw      0004h       ; 00000000 00000100

ShiftTable3     equ     this word
    dw      8000h       ; 10000000 00000000
    dw      2000h       ; 00100000 00000000
    dw      0800h       ; 00001000 00000000
    dw      0200h       ; 00000010 00000000
    dw      0080h       ; 00000000 10000000
    dw      0020h       ; 00000000 00100000
    dw      0008h       ; 00000000 00001000
    dw      0002h       ; 00000000 00000010

;***************************************************************************
; END OF LOCAL DATA
;***************************************************************************


uDiv6432_L16:

    ;
    ; dx:ax:bp:bx / si:di (si=0) = dx:ax/bx:cx
    ;

    or      di, di
    jz      short uDiv6432_Overflow
    or      dx, dx
    jnz     short uDiv6432_Overflow     ; dx=0 otherwise overflow
    cmp     ax, di
    jae     short uDiv6432_Overflow
    mov     dx, ax
    mov     ax, bp                      ; move up
    div     di                          ; dx:bx=remainder, ax=quotient
    xchg    bx, ax                      ; dx:ax=remainder, bx=quotient
    div     di                          ; dx=remainder, bx:ax=quotient

    mov     cx, dx                      ; cx=remainder, bx:ax=quotient
    mov     dx, bx                      ; cx=remainder, dx:ax=quotient
    xor     bx, bx                      ; bx:cx=remainder, dx:ax=quotient
    ret

uDiv6432_H16:

    ;
    ; dx:ax:bp:bx / si:di (di=0) = dx:ax/bx:cx
    ;

    cmp     dx, si
    jae     short uDiv6432_Overflow     ; the dividend too big
    div     si                          ; dx:bp:bx=remainder, ax=quotient
    xchg    bp, ax                      ; dx:ax:bx=remainder, bp=quotient
    div     si                          ; dx:bx=remainder, bp:ax=quotient
    mov     cx, bx                      ; dx:cx=remainder, bp:ax=quotient
    mov     bx, dx                      ; bx:cx=remainder, bp:ax=quotient
    mov     dx, bp                      ; bx:cx=remainder, dx:ax=quotient
    ret

uDiv6432_Overflow:

    mov     dx, 07fffh                  ; return quotient (dx:ax) = max. number
    mov     ax, 0ffffh
    xor     bx, bx
    xor     cx, cx
    ret


    PUBLIC  U64DivU32_U32

U64DivU32_U32   label   near

    ;
    ; dx:ax:bp:bx / si:di = dx:ax/bx:cx
    ;

    or      si, si
    jz      short uDiv6432_L16
    or      di, di
    jz      short uDiv6432_H16
    cmp     dx, si                      ; have to make sure dx/si != 0
    jae     short uDiv6432_Overflow     ; the dividend too big

uDiv6432_M1a:

    ;
    ; dx:ax:bp:bx / si:di
    ; dx:ax=remainder, bx:cx=quotient
    ;

    push    bx                          ; save lowest 16-bit of dividend
    div     si                          ; dx=r, ax=q
    mov     cx, dx                      ; cx:bp:sp=r, bx=q
    mov     bx, ax
    mul     di                          ; dx:ax=overrun, cx:bp=remainder
                                        ; bx=quotient
    xchg    ax, bp                      ; cx:bp=overrun, dx:ax=last remainder
    xchg    dx, cx
    sub     ax, bp                      ; remainder - overrun
    sbb     dx, cx

    mov     bp, 0                       ; no shift count
    jnc     short uDiv6432_M1c          ; remainder >= overrun

    ;
    ; now we have -(dx:ax) of overrun, we need to add the divisor back until
    ; dx:ax is not negative, for every divisor (si:di) we add the quotient (bx)
    ; must decrement by one.
    ;
uDiv6432_M1b:

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1c          ; carry on...

    call    uDiv6432_QR                 ; at return BP=shift count
                                        ; bx=adjusted quot, dx:ax=remainder
uDiv6432_M1c:

    mov     cx, bp                      ; save shift count in CX
    pop     bp                          ; bp=lowest 16-bit of dividend
    push    bx                          ; save high 16-bit of quotient

    cmp     dx, si
    jae     short uDiv6432_NegDiv       ; using negative division algorithm

    push    cx                          ; save shift count

uDiv6432_M1d:

    div     si                          ; dx=r, ax=q
    mov     cx, dx                      ; cx=r, sp:bx=q
    mov     bx, ax                      ; cx:bp=r, sp:bx=q
    mul     di                          ; dx:ax=remainder 2

    xchg    ax, bp                      ; cx:bp=overrun, dx:ax=last remainder
    xchg    dx, cx
    sub     ax, bp                      ; remainder - overrun
    sbb     dx, cx

    pop     bp                          ; get shift count

    jnc     short uDiv6432_M1e          ; remainder >= overrun

    ;
    ; now we have -(dx:ax) of overrun, we need to add the divisor back until
    ; dx:ax is not negative, for every divisor (si:di) we add the quotient (bx)
    ; must decrement by one.
    ;

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    dec     bx
    add     ax, di
    adc     dx, si
    jc      short uDiv6432_M1e          ; do until positive number

    call    uDiv6432_QR                 ; too many call-up the division
                                        ; bx=adjusted quot, dx:ax=remainder
uDiv6432_M1e:                           ; sp:bx=quotient, dx:ax=remainder

    mov     cx, ax                      ; sp:bx=quotient, dx:cx=remainder
    mov     ax, bx                      ; sp:ax=quotient, dx:cx=remainder
    mov     bx, dx                      ; sp:ax=quotient, bx:cx=remainder
    pop     dx                          ; dx:ax=quotient, bx:cx=remainder
    ret

;
;
;============================================================================
; interal subfunctions to the uDiv6432
;============================================================================
;
;
; uDiv6432_NegDiv --- Negate and divide algorithm
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;
; dx:ax:bp / si:di, *sp=high qoutient
;
; (dx == si) and (ax < di) at here
;
; now we use maximum difference (di:0 - ax:bp) as estimate 32-bit
; dividend number then divide it by divisor, the (0xffff - resulting
; quotient) is the original quotient, and remainder is equal to
; (divisor - resulting remainder), the only exception is that if remainder
; is zero then the quotient need to increment by 1.
;

uDiv6432_NegDiv:

    mov     dx, di
    neg     bp
    sbb     dx, ax
    mov     ax, bp                          ; dx:ax=inverted 32-bit dividend
    call    uDiv3232_32Divisor              ; dx:ax=quot (0:ax) bx:cx=remainder
    jz      short uDiv6432_NegDiv1          ; remainder = 0, just negate quot
    inc     ax                              ; compensate for non-zero remainder
    neg     bx                              ; remainder = divosr - remainder
    neg     cx                              ; bx=0 at here
    sbb     bx, dx
    add     cx, di
    adc     bx, si                          ; bx:cx=final remainder

uDiv6432_NegDiv1:

    neg     ax                              ; negate the quotient
    pop     dx                              ; dx:ax=quot, bx:cx=remainder
    ret

;
; uDiv6432_QR - 32-bit/32-bit with previos quotient adjustment
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;
; Entry:
;       bp      = shift count
;       bx      = Previous quotient to be adjusted
;       dx:ax   = Negative overrun factor
;       si:di   = Divisor
;
; Exit:
;       bx      = Adjusted quotient
;       dx:ax   = positive/0 remainder after overun adjustment
;       si:di   = divisor (unchanged)
;
; cx, bp destroyed
;

uDiv6432_QR:


    NEG32_FROMR16HL dx, ax

    ;
    ; dx:ax / si:di (bx:di)
    ; remainder = dx:ax
    ;

uDiv6432_QR_0:

    xchg    bx, bp                      ; bp=quotient, bx=shift count

    ; dx:ax / cx:di


uDiv6432_QR_1:


    or      bx, bx
    jnz     short HasShiftCount

    ;
    ; shift dx:ax/cx:di right by bp shift count
    ;

    cmp     si, 0100h                   ; right side set the carry
    adc     bl, bl                      ; 0 <= bx <= 1

    add     bx, bx                      ; bx = 0, 2, pre-shift for word table
    cmp     si, cs:ShiftTable1[bx]      ; split again
    adc     bl, bh                      ; 0 <= bx <= 3

    add     bx, bx                      ; bx = 0,2,4,6, shift for word table
    cmp     si, cs:ShiftTable2[bx]
    adc     bl, bh                      ; 0 <= bx <= 7

    add     bx, bx                      ; bx = 0,2,4,6,8,10,12,14
    cmp     si, cs:ShiftTable3[bx]
    adc     bl, bh                      ; 0 <= bx <= 15
    neg     bx
    add     bx, 16

HasShiftCount:

    push    bx                          ; save shift count back

    push    dx                          ; save dividend high
    push    di                          ; save divisor low
    push    bp                          ; save quotient
    mov     bp, ax                      ; save dividend low
    mov     cx, si

    ;
    ; dx:ax / cx:di,  sp=shift count, sp+2=dx, sp+4=di, sp+6=quotient

    cmp     bx, 8
    jb      short Shift1

    mov     al, ah
    mov     ah, dl
    mov     dl, dh
    xor     dh, dh

    xchg    ax, di
    mov     al, ah
    mov     ah, cl
    mov     cl, ch
    xor     ch, ch
    xchg    ax, di

    and     bx, 7

Shift1:

    add     bx, bx
    jmp     cs:RShiftTable[bx]

RShift_7:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_6:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_5:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_4:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_3:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_2:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1
RShift_1:
    shr     dx, 1
    rcr     ax, 1
    shr     cx, 1
    rcr     di, 1

RShift_0:

    pop     bx                      ; restore quotient

    div     di                      ; get estimate quotient = ax
    sub     bx, ax                  ; decrement the quotient
    mov     cx, ax                  ; ax=bx=estimate quotient
    pop     di                      ; si:di=original divisor

    ;
    ;    estimation of Quotient = eQ
    ;
    ;               vH:vL
    ;                  eQ
    ;    -------------------
    ;               vL:eQ          -- x0    dx:ax
    ;            vH:eQ             -- x1 ..:cx
    ;   -----------------------------------------------
    ;                                    ..:dx:ax
    ;
    ;
    ;   dx += cx;
    ;
    ;   if (carry)              return (eQ - 1);
    ;   if (dx:ax > original dividend) return(eQ - 1) else return(eQ)
    ;
    ; now multiply the eQ (bx) with original divisor (si:di)
    ; now cx:bp=original dividend
    ;

    mul     si                      ; dx:ax, using only ax
    xchg    ax, cx                  ; ax=eQ, cx=H(eQ * Divisor)
    mul     di                      ; dx:ax=L(eQ * Divisor)
    add     dx, cx
    pop     cx                      ; restore cx (original High dividend)

    jc      short uDiv6432_QR_s1

    cmp     dx, cx
    ja      short uDiv6432_QR_s1
    jb      short uDiv6432_QR_s2
    cmp     ax, bp
    jbe     short uDiv6432_QR_s2

uDiv6432_QR_s1:

    inc     bx                      ; add 1 back to the quotient
    sub     ax, di                  ; substract divisor
    sbb     dx, si

uDiv6432_QR_s2:
                                    ; substract original dividend
    sub     ax, bp                  ; at here, we either carry or zero
    sbb     dx, cx
    jnc     short uDiv6432_QR_Done

    ;
    ; still has overrun, that is we have remainder,
    ;

    dec     bx                      ; substract one from the qoutient
    add     ax, di
    adc     dx, si

uDiv6432_QR_Done:

    pop     bp                      ; return BP=shift count
    ret





SUBTTL  U32MulU32_U64
PAGE

COMMENT `

Routine Description:

    This function multiply a 32-bit multipicand with a 32-bit multiplier
    and return a 64-bit product.

    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    bp:bx = multiplicand
    dx:ax = multiplier

Return Value:

    dx:ax:bp:bx - 64-bit products (dx:ax * bp:bx)

    all other registers are destroyed.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

        Total re-construct, re-write, it make it calculate the 6 decimal
        points precision easier for not using slow floating emulation, the
        speed is faster then the reqular (long/long) routine in the
        standard library while it provide me all the necessary color calcuation
        with good precisions.

Revision History:

`


    PUBLIC  U32MulU32_U64

U32MulU32_U64   label   near


    ;           bp:bx                        bp:bx
    ;         x dx:ax                      x si:di
    ; ----------------             ----------------
    ;           bx*ax    x0                  bx*di    x0
    ;        bp*ax       x1               bp*di       x1
    ;        bx*dx       x2               bx*si       x2
    ;   + bp*dx          x3          + bp*si          x3
    ; =====================        =====================
    ;     dx:ax:bp:bx    products      dx:ax:bp:bx    products

uMul3232_Low:

    mov     di, ax                      ; save multiplier in si:di
    mov     si, dx

    xor     cx, cx
    xor     dx, dx
    xor     ax, ax

    or      di, di                      ; see if zero (no business here)
    jz      short uMul3232_High

uMul3232_x0:

    or      bx, bx                      ; zero ?
    jz      short uMul3232_x1
    mov     ax, di
    mul     bx                          ; dx:ax = x0

uMul3232_x1:

    or      bp, bp
    jz      short uMul3232_x1a          ; zeroing the DI

    xchg    di, ax                      ; cx:di = x0, ax=di
    mov     cx, dx
    mul     bp                          ; dx:ax = x1

    xchg    di, ax                      ;         dx:ax = x0
    xchg    cx, dx                      ;      cx:di    = x1
                                        ; --------------------
    add     dx, di                      ;   di:cx:dx:ax

uMul3232_x1a:

    mov     di, 0
    adc     cx, di
    adc     di, di

uMul3232_High:

    or      si, si                      ; now di:cx:dx:ax = x0+x1
    jz      short uMul3232_Done

uMul3232_x2:

    or      bx, bx
    jz      short uMul3232_x3           ; di:cx:dx:ax

    push    ax
    xchg    bx, dx                      ; di:cx:dx:ax ===> di:cx:bx:push
    mov     ax, si                      ;                     dx:ax     = x3
    mul     dx                          ;

    add     bx, ax
    mov     ax, 0
    adc     cx, dx
    adc     di, ax                      ; di:cx:bx:ax
    pop     ax
    mov     dx, bx                      ; di:cx:bx:ax -> di:cx:dx:ax

uMul3232_x3:

    or      bp, bp
    jz      short uMul3232_Done         ;

    mov     bx, dx
    xchg    si, ax                      ; di:cx:dx:ax --> di:cx:bx:si
    mul     bp                          ; dx:ax        = x3

    add     cx, ax
    adc     di, dx                      ; di:cx:bx:si => dx:ax:bp:bx

    mov     dx, di
    mov     ax, cx
    mov     bp, bx
    mov     bx, si
    ret

uMul3232_Done:                          ; di:cx:dx:ax -> dx:ax:bp:bx

    mov     bp, dx
    mov     bx, ax
    mov     dx, di
    mov     ax, cx
    ret




SUBTTL  U32DivU32_U32
PAGE

COMMENT `

Routine Description:

    This function divide a 32-bit number by 32-bit number and return both
    32-bit quotient and 32-bit remainder.

    only assembly under 8086/80286 cpu, for 80386 and up it will use in line
    code to do divison

Arguments:

    dx:ax       - 32-bit unsigned Dividend
    si:di       - 32-bit unsigned Divisor

Return Value:

    dx:ax       - 32-bit unsigned quotient,
    bx:cx       - 32-bit unsigned remainder
    si:di       - Divisor, unchanged.
    zero flag   - set if remainder is zero, clear otherwise
    cx/bp       - destroyed.

Author:

    26-Sep-1991 Thu 17:05:21 created    -by-  Daniel Chou (danielc)

        Total re-construct, re-write, it make it calculate the 6 decimal
        points precision easier for not using slow floating emulation, the
        speed is faster then the reqular (long/long) routine in the
        standard library while it provide me all the necessary color calcuation
        with good precisions.

Revision History:

`

    PUBLIC  U32DivU32_U32

U32DivU32_U32   label   near

;
; dx:ax / si:di ====> dx:ax=quotient, bx:cx=remainder
;

    or      si, si
    jnz     short uDiv3232_32Divisor

    or      di, di                      ; if di=0, then error
    jz      short uDiv3232_Err

    xor     bx, bx                      ; assume quotient H = 0
    cmp     dx, di                      ; see if will overflow ?
    jb      short uDiv3232_1

    mov     bx, ax                      ; save dividend L in bx
    mov     ax, dx
    xor     dx, dx
    div     di                          ; 0:ax/di, dx=r, ax=q
    xchg    bx, ax                      ; dx:ax=remainder, bx=quotient H

uDiv3232_1:

    div     di                          ; bx:ax=quotient, dx=remainder
    mov     cx, dx                      ; bx:ax=quotient, cx=remainder
    mov     dx, bx                      ; dx:ax=quotient, cx=remainder
    xor     bx, bx                      ; dx:ax=quotient, bx:cx(0:cx)=remainder
    or      cx, cx                      ; return zero flag for remainder
    ret

uDiv3232_Err:

    sub     bx, bx
    sub     cx, cx                      ; remainder = 0
    ret


uDiv3232_Zero:

    mov     cx, ax
    mov     bx, dx                      ; return remainder = dividend
    or      ax, dx                      ; return (BOOL)(remainder == 0)
    mov     ax, 0
    mov     dx, 0                       ; dx:ax=quotient, bx:cx=remainder
    ret

uDiv3232_One:

    mov     ax, 1                       ; return quotient = 1 and no remainder
    sub     dx, dx                      ; return dx:ax=1 (quotient) bx:cx=0
    sub     bx, bx                      ; (remainder) and zero flag set to
    sub     cx, cx                      ; indicate that remainder is zero
    ret                                 ; indicate that remainder is zero


    PUBLIC  uDiv3232_32Divisor

uDiv3232_32Divisor  label  near         ; full 32-bit divisor

    ;
    ; dx:ax / si:di = dx:ax/bx:cx
    ;

    mov     bx, dx
    mov     cx, ax
    sub     cx, di
    sbb     bx, si
    jc      short uDiv3232_Zero         ; if carry then dx:ax < si:di
    or      cx, bx                      ; if bx:cx=0 then dx:ax=si:di
    jz      short uDiv3232_One

    ;
    ; dx:ax / si:di     (bx:cx / bp:ss:sp)
    ;

    mov     bx, dx
    mov     cx, ax
    mov     bp, si
    push    di

    ; dx:ax / bp:di

    shl     di, 1                   ; prepare to fall through

uDiv3232_3:

    rcr     di, 1                   ; first pass, so that we do not
    ;===============                ; need to do a seperate check to
    shr     dx, 1                   ; see if 'bp' alreay zero
    rcr     ax, 1
    shr     bp, 1
    jnz     short uDiv3232_3
    rcr     di, 1                   ; do the last one

    ;
    ; ready to divide a 32-bit number by 16-bit number

    div     di                      ; get estimate quotient = ax
    mov     bp, ax                  ; ax=bp=estimate quotient
    pop     di                      ; si:di=original divisor

    ;
    ;    estimation of Quotient = eQ
    ;
    ;               vH:vL
    ;                  eQ
    ;    -------------------
    ;               vL:eQ          -- x0    dx:ax
    ;            vH:eQ             -- x1 ..:cx
    ;   -----------------------------------------------
    ;                                    ..:dx:ax
    ;
    ;
    ;   dx += cx;
    ;
    ;   if (carry)              return (eQ - 1);
    ;   if (dx:ax > original dividend) return(eQ - 1) else return(eQ)
    ;
    ; now multiply the eQ (bp) with original divisor (si:di)
    ; now bx:cx=original dividend
    ;

    mul     si                      ; dx:ax, using only ax
    push    bp                      ; save eQ
    xchg    ax, bp                  ; ax=eQ, bp=H(eQ * Divisor)
    mul     di                      ; dx:ax=L(eQ * Divisor)
    add     dx, bp
    pop     bp                      ; get the eQ back
    jc      short uDiv3232_EQm1     ; the eQ*Divisor is one divisor higher
    cmp     dx, bx                  ; if the eQ*Divisor > original dividend
    jc      short uDiv3232_EQ       ; then the quotient need decrement by 1
    ja      short uDiv3232_EQm1     ; if less or equal then is ok
    cmp     ax, cx
    jbe     short uDiv3232_EQ

uDiv3232_EQm1:                      ; eQ-1: bp=eQ, dx:ax=eQ*Divisor, bx:cx=dvnd

    dec     bp                      ; decrement the eQ by 1
    sub     ax, di                  ; and also substract the divisor one more
    sbb     dx, si                  ; time to compensate for the eQ-1

uDiv3232_EQ:                        ; eQ: bp=q, dx:ax=eQ * Divisor, bx:cx=dvnd

    sub     cx, ax                  ; remainder of the number is
    sbb     bx, dx                  ; original dividend - (eQ * Divisor)
    mov     ax, bp                  ; 0:ax (dx:ax)=quotient, bx:cx=remainder
    mov     dx, cx
    or      dx, bx                  ; return zero flag for (remainder == 0)
    mov     dx, 0                   ; quotient high always zero at here
    ret

;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;@ End of only for 8086/80286 only, and all functions are used internally    @
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

ENDIF                               ; i8086/i286
ENDIF                               ; HT_ASM_80x86




END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\htui\htuigif.h ===
HANDLE
DIBFromGIFFile(
    HFILE   hFileGIF
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\htui\htuiapi.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation


Module Name:

    htuiapi.c


Abstract:

    This module contains the API entry point for the halftone user interface


Author:

    21-Apr-1992 Tue 11:44:06 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    02-Feb-1994 Wed 18:09:28 updated  -by-  Daniel Chou (danielc)
        DLL Entry points is always WINAPI not FAR


--*/

#define _HTUI_APIS_


#include <stddef.h>

#include <windows.h>

#include <ht.h>
#include "htuidlg.h"
#include "htuimain.h"


HMODULE hHTUIModule = (HMODULE)NULL;
WCHAR   BmpExt[16];
WCHAR   FileOpenExtFilter[128];
WCHAR   FileSaveExtFilter[128];



DWORD
APIENTRY
DllMain(
    HMODULE hModule,
    ULONG   Reason,
    LPVOID  Reserved
    )

/*++

Routine Description:

    This function is DLL main entry point, at here we will save the module
    handle, in the future we will need to do other initialization stuff.

Arguments:

    hModule     - Handle to this moudle when get loaded.

    Reason      - may be DLL_PROCESS_ATTACH

    Reserved    - reserved

Return Value:

    Always return 1L


Author:

    20-Feb-1991 Wed 18:42:11 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{

    UNREFERENCED_PARAMETER(Reserved);

    if (Reason == DLL_PROCESS_ATTACH) {

        hHTUIModule = hModule;

        LoadString(hHTUIModule, IDS_BMPEXT, BmpExt, COUNT_ARRAY(BmpExt));

        LoadString(hHTUIModule,
                   IDS_FILEOPENEXTFILTER,
                   FileOpenExtFilter,
                   COUNT_ARRAY(FileOpenExtFilter));

        LoadString(hHTUIModule,
                   IDS_FILESAVEEXTFILTER,
                   FileSaveExtFilter,
                   COUNT_ARRAY(FileSaveExtFilter));
    }

    return(1L);

}




LONG
APIENTRY
HTUI_ColorAdjustmentW(
    LPWSTR              pCallerTitle,
    HANDLE              hDefDIB,
    LPWSTR              pDefDIBTitle,
    PCOLORADJUSTMENT    pColorAdjustment,
    BOOL                ShowMonochromeOnly,
    BOOL                UpdatePermission
    )

/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    pCallerTitle        - Pointer to the caller's title, it can be application
                          name, device name... which will be display in the
                          dialog box 'modify for:' line, if this field is NULL
                          then no title name is displayed on that line.

    hDefDIB             - If it is not NULL then this function will try to use
                          this DIB as default picture to adjustment testing.

    pDefDIBTitle        - Pointer to a string which indified the test DIB
                          content.

    pColorAdjusment     - Pointer to the COLORADJUSMENT data strcuture, this
                          data structure will updated upon exit.

    ShowMonochromeOnly  - Only display mono version of the bitmap

    UpdatePermission    - TRUE if ok for user to change the COLORADJUSTMENT
                          setting


Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment.

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)

    26-Apr-1994 Tue 18:08:30 updated  -by-  Daniel Chou (danielc)
        Updated for the UNICODE version

    03-Jun-1994 Fri 20:52:05 updated  -by-  Daniel Chou (danielc)
        Get decimal character from current user

Revision History:


--*/

{
    HWND            hWndActive = GetActiveWindow();
    //FARPROC         pfnDlgCallBack;
    PHTCLRADJPARAM  pHTClrAdjParam;
    LONG            Result;


    if (!pColorAdjustment)  {

        return(-1);
    }

    Result = GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, NULL, 0) *
             sizeof(WCHAR);

    if (!(pHTClrAdjParam = (PHTCLRADJPARAM)
                LocalAlloc(LPTR, (UINT)(sizeof(HTCLRADJPARAM) + Result)))) {

        return(-2);
    }

    GetLocaleInfoW(LOCALE_USER_DEFAULT,
                   LOCALE_SDECIMAL,
                   pHTClrAdjParam->pwDecimal = (LPWSTR)(pHTClrAdjParam + 1),
                   Result);

    pHTClrAdjParam->hWndApp          = hWndActive;
    pHTClrAdjParam->pCallerTitle     = pCallerTitle;
    pHTClrAdjParam->hDefDIB          = hDefDIB;
    pHTClrAdjParam->pDefDIBTitle     = pDefDIBTitle;
    pHTClrAdjParam->pCallerHTClrAdj  = pColorAdjustment;
    pHTClrAdjParam->ViewMode         = VIEW_MODE_REFCOLORS;
    pHTClrAdjParam->BmpNeedUpdate    = 1;

    if (ShowMonochromeOnly) {

        pHTClrAdjParam->Flags |= HTCAPF_SHOW_MONO;
    }

    if (UpdatePermission) {

        pHTClrAdjParam->Flags |= HTCAPF_CAN_UPDATE;
    }

#ifdef HTUI_STATIC_HALFTONE
    pHTClrAdjParam->RedGamma        =
    pHTClrAdjParam->GreenGamma      =
    pHTClrAdjParam->BlueGamma       = 20000;
#endif

    //pfnDlgCallBack = (FARPROC)MakeProcInstance(HTClrAdjDlgProc,
    //                                           hHTUIModule);

    pHTClrAdjParam->HelpID = (DWORD)HLP_HT_CLR_ADJ_DLG;

    //Result = (LONG)DialogBoxParam(hHTUIModule,
    //                              MAKEINTRESOURCE(HTCLRADJDLG),
    //                              hWndActive,
    //                              (DLGPROC)pfnDlgCallBack,
    //                              (LPARAM)pHTClrAdjParam);


    //FreeProcInstance(pfnDlgCallBack);
    Result = (LONG)DialogBoxParam(hHTUIModule,
                                  MAKEINTRESOURCE(HTCLRADJDLG),
                                  hWndActive,
                                  HTClrAdjDlgProc,
                                  (LPARAM)pHTClrAdjParam);
    LocalFree(pHTClrAdjParam);

#if DBG
#if 0
    DbgPrint("\nHTUI_ColorAdjustment()=%ld", Result);
#endif
#endif

    return(Result);
}




LONG
APIENTRY
HTUI_ColorAdjustmentA(
    LPSTR               pCallerTitle,
    HANDLE              hDefDIB,
    LPSTR               pDefDIBTitle,
    PCOLORADJUSTMENT    pColorAdjustment,
    BOOL                ShowMonochromeOnly,
    BOOL                UpdatePermission
    )

/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    hWndCaller          - a HWND to the parent of color adjustment dialog box.

    pCallerTitle        - Pointer to the caller's title, it can be application
                          name, device name... which will be display in the
                          dialog box 'modify for:' line, if this field is NULL
                          then no title name is displayed on that line.

    hDefDIB             - If it is not NULL then this function will try to use
                          this DIB as default picture to adjustment testing.

    pDefDIBTitle        - Pointer to a string which indified the test DIB
                          content.

    pColorAdjusment     - Pointer to the COLORADJUSMENT data strcuture, this
                          data structure will updated upon exit.

    ShowMonochromeOnly  - Only display mono version of the bitmap

    UpdatePermission    - TRUE if ok for user to change the COLORADJUSTMENT
                          setting


Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment.

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)

    26-Apr-1994 Tue 18:08:30 updated  -by-  Daniel Chou (danielc)
        Updated for the UNICODE version

Revision History:


--*/

{
    LPWSTR  pwAlloc;
    LONG    cTitle;
    LONG    cDIB;
    LONG    Result;


    cTitle = (LONG)((pCallerTitle) ? strlen(pCallerTitle) + 1 : 0);
    cDIB   = (LONG)((pDefDIBTitle) ? strlen(pDefDIBTitle) + 1 : 0);

    if ((cTitle) || (cDIB)) {

        if (!(pwAlloc = (LPWSTR)LocalAlloc(LPTR,
                                           (cTitle + cDIB) * sizeof(WCHAR)))) {

            return(-2);
        }

        if (pCallerTitle) {

            MultiByteToWideChar(CP_ACP,
                                0,
                                pCallerTitle,
                                cTitle,
                                pwAlloc,
                                cTitle);

            pCallerTitle = (LPSTR)pwAlloc;
        }

        if (pDefDIBTitle) {

            MultiByteToWideChar(CP_ACP,
                                0,
                                pDefDIBTitle,
                                cDIB,
                                pwAlloc + cTitle,
                                cDIB);

            pDefDIBTitle = (LPSTR)(pwAlloc + cTitle);
        }

    } else {

        pwAlloc = (LPWSTR)NULL;
    }

    Result = HTUI_ColorAdjustmentW((LPWSTR)pCallerTitle,
                                   hDefDIB,
                                   (LPWSTR)pDefDIBTitle,
                                   pColorAdjustment,
                                   ShowMonochromeOnly,
                                   UpdatePermission);

    if (pwAlloc) {

        LocalFree(pwAlloc);
    }

    return(Result);
}





LONG
APIENTRY
HTUI_ColorAdjustment(
    LPSTR               pCallerTitle,
    HANDLE              hDefDIB,
    LPSTR               pDefDIBTitle,
    PCOLORADJUSTMENT    pColorAdjustment,
    BOOL                ShowMonochromeOnly,
    BOOL                UpdatePermission
    )

/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    hWndCaller          - a HWND to the parent of color adjustment dialog box.

    pCallerTitle        - Pointer to the caller's title, it can be application
                          name, device name... which will be display in the
                          dialog box 'modify for:' line, if this field is NULL
                          then no title name is displayed on that line.

    hDefDIB             - If it is not NULL then this function will try to use
                          this DIB as default picture to adjustment testing.

    pDefDIBTitle        - Pointer to a string which indified the test DIB
                          content.

    pColorAdjusment     - Pointer to the COLORADJUSMENT data strcuture, this
                          data structure will updated upon exit.

    ShowMonochromeOnly  - Only display mono version of the bitmap

    UpdatePermission    - TRUE if ok for user to change the COLORADJUSTMENT
                          setting

Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment.

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)

    26-Apr-1994 Tue 18:08:30 updated  -by-  Daniel Chou (danielc)
        Updated for the UNICODE version

Revision History:


--*/

{

    //
    // Compatible for ealier version of HTUI.DLL
    //

    return(HTUI_ColorAdjustmentA(pCallerTitle,
                                 hDefDIB,
                                 pDefDIBTitle,
                                 pColorAdjustment,
                                 ShowMonochromeOnly,
                                 UpdatePermission));

}





LONG
APIENTRY
HTUI_DeviceColorAdjustmentW(
    LPWSTR          pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    )

/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    pDeviceName     - Pointer to the device name to be displayed

    pDevHTAdjData   - Pointer to the DEVHTADJDATA

Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment if it is not NULL, and update content of
              pDevHTAdjData if it is not NULL

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)

    03-Jun-1994 Fri 20:52:05 updated  -by-  Daniel Chou (danielc)
        Get decimal character from current user


Revision History:


--*/

{
    HWND            hWndActive = GetActiveWindow();
    //FARPROC         pfnDlgCallBack;
    PHTDEVADJPARAM  pHTDevAdjParam;
    UINT            IntRes;
    LONG            Result;


    if ((!pDevHTAdjData) ||
        (!pDevHTAdjData->pDefHTInfo)) {

        return(-1);
    }

    Result = GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, NULL, 0) *
             sizeof(WCHAR);

    if (!(pHTDevAdjParam = (PHTDEVADJPARAM)
                LocalAlloc(LPTR, (UINT)(sizeof(HTDEVADJPARAM) + Result)))) {

        return(-2);
    }

    GetLocaleInfoW(LOCALE_USER_DEFAULT,
                   LOCALE_SDECIMAL,
                   pHTDevAdjParam->pwDecimal= (LPWSTR)(pHTDevAdjParam + 1),
                   Result);

    pHTDevAdjParam->pDeviceName  = pDeviceName;
    pHTDevAdjParam->DevHTAdjData = *pDevHTAdjData;

    if ((pDevHTAdjData->pAdjHTInfo == NULL) ||
        (pDevHTAdjData->pAdjHTInfo == pDevHTAdjData->pDefHTInfo)) {

        pHTDevAdjParam->DevHTAdjData.pAdjHTInfo = pDevHTAdjData->pDefHTInfo;
        pHTDevAdjParam->UpdatePermission        = 0;

    } else {

        pHTDevAdjParam->UpdatePermission = 1;
    }

    //pfnDlgCallBack = (FARPROC)MakeProcInstance(HTDevAdjDlgProc,
    //                                           hHTUIModule);

    if (pDevHTAdjData->DeviceFlags & DEVHTADJF_ADDITIVE_DEVICE) {

        if (pDevHTAdjData->DeviceFlags & DEVHTADJF_COLOR_DEVICE) {

            IntRes = HTDEV_DLG_ADD;
            Result = HLP_HTDEV_DLG_ADD;

        } else {

            IntRes = HTDEV_DLG_ADD_MONO;
            Result = HLP_HTDEV_DLG_ADD_MONO;
        }


        IntRes = (pDevHTAdjData->DeviceFlags & DEVHTADJF_COLOR_DEVICE) ?
                                    HTDEV_DLG_ADD : HTDEV_DLG_ADD_MONO;

    } else {

        if (pDevHTAdjData->DeviceFlags & DEVHTADJF_COLOR_DEVICE) {

            IntRes = HTDEV_DLG_SUB;
            Result = HLP_HTDEV_DLG_SUB;

        } else {

            IntRes = HTDEV_DLG_SUB_MONO;
            Result = HLP_HTDEV_DLG_SUB_MONO;
        }
    }

    pHTDevAdjParam->HelpID = (DWORD)Result;

    //Result = (LONG)DialogBoxParam(hHTUIModule,
    //                              MAKEINTRESOURCE(IntRes),
    //                              hWndActive,
    //                              (DLGPROC)pfnDlgCallBack,
    //                              (LPARAM)pHTDevAdjParam);

    //FreeProcInstance(pfnDlgCallBack);
    Result = (LONG)DialogBoxParam(hHTUIModule,
                                  MAKEINTRESOURCE(IntRes),
                                  hWndActive,
                                  HTDevAdjDlgProc,
                                  (LPARAM)pHTDevAdjParam);
    LocalFree(pHTDevAdjParam);

    return(Result);
}



LONG
APIENTRY
HTUI_DeviceColorAdjustmentA(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    )
/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    pDeviceName     - Pointer to the device name to be displayed

    pDevHTAdjData   - Pointer to the DEVHTADJDATA

Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment if it is not NULL, and update content of
              pDevHTAdjData if it is not NULL

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWSTR  pwAlloc;
    LONG    Result;


    if (pDeviceName) {

        Result = strlen(pDeviceName) + 1;

        if (!(pwAlloc = (LPWSTR)LocalAlloc(LPTR, Result * sizeof(WCHAR)))) {

            return(-2);
        }

        MultiByteToWideChar(CP_ACP, 0, pDeviceName, Result, pwAlloc, Result);
        pDeviceName = (LPSTR)pwAlloc;

    } else {

        pwAlloc = (LPWSTR)NULL;
    }

    Result = HTUI_DeviceColorAdjustmentW((LPWSTR)pDeviceName, pDevHTAdjData);

    if (pwAlloc) {

        LocalFree(pwAlloc);
    }

    return(Result);
}



LONG
APIENTRY
HTUI_DeviceColorAdjustment(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    )
/*++

Routine Description:

    This is the API entry for the halftone color adjustment, this function
    only allowed adjust the input colors

Arguments:

    pDeviceName     - Pointer to the device name to be displayed

    pDevHTAdjData   - Pointer to the DEVHTADJDATA

Return Value:

    LONG value

    > 0     - If user choose 'OK' which the new data are updated into
              pColorAdjustment if it is not NULL, and update content of
              pDevHTAdjData if it is not NULL

    = 0     - If user choose 'CANCEL' which the operation is canceled

    < 0     - An error occurred, it identified a predefined error code


Author:

    24-Apr-1992 Fri 07:45:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    //
    // Compatible for ealier version of HTUI.DLL
    //

    return(HTUI_DeviceColorAdjustmentA(pDeviceName, pDevHTAdjData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\halftone\ht\i386\i80x86.inc ===
COMMENT `

Copyright (c) 1990-1991  Microsoft Corporation


Module Name:

    i80x86.inc

Abstract:

    This module header provide set of defined/macros to be includes in all
    assembly files assembled under halftone directory, it provide a generalized
    convensions to make the single codes fragment to be complied under
    8086, 80186, 80286, 80386, 80486, 80586 family.

Author:

    03-Apr-1991 Wed 10:28:50 created  -by-  Daniel Chou (danielc)


[Environment:]

    Printer Driver.


[Notes:]


Revision History:
    28-Mar-1992 Sat 21:10:26 updated  -by-  Daniel Chou (danielc)
        Add in macros for debugging support



    18-Oct-1991 Fri 11:38:51 updated  -by-  Daniel Chou (danielc)

        Add in following new macros

            NEG32_FROMR16HL
            NEG64_FROMR32HL
            S32_FROMR16HL_SR16
            S64_FROMR32HL_SR32

        Add in comment for each macro

`

IF1

AllNoCaseRegs   equ <al,ah,ax,bl,bh,bx,cl,ch,cx,dl,dh,dx,si,di,bp>
AllCaseRegs     equ <_AX,_BX,_CX,_DX,_SI,_DI,_BP>


;
; __@@VALID_PARAM:    INTERNAL MACRO
;
;   This macro provide a early validation of input registers for other macros
;   It will generate an error message and exiting from assembler if invalid
;   registers are found.
;

__@@VALID_PARAM? macro CallerName, NameIdx, Name, NoCaseNameList

    OkName = 0

    IFB <Name>
        IF1
            %OUT Error: (&CallerName) parameter NameIdx not specified.
            %OUT Valid= NoCaseNameList
        ENDIF
        .ERR
        EXITM
        EXITM
    ENDIF

    IRP OneName,<NoCaseNameList>
        IFIDNI <OneName>,<Name>
            OkName = 1
            EXITM
        ENDIF
    ENDM

    IFE OkName
        IF1
            %OUT Error: (&CallerName) Invalid Parameter NameIdx specified '&Name'.
            %OUT Valid= NoCaseNameList
        ENDIF
        .ERR
        EXITM
        EXITM
    ENDIF
ENDM


;
; __@@VALID_REG:    INTERNAL MACRO
;
;   This macro provide a early validation of input registers for other macros
;   It will generate an error message and exiting from assembler if invalid
;   registers are found.
;

__@@VALID_REG? macro CallerName, Reg, NoCaseRegsList, CaseRegsList
    OkReg = 0

    IFB <Reg>
        IF1
            %OUT Error: (&CallerName) no register name '&Reg' specified.
            %OUT Valid= NoCaseRegsList, CaseRegsList
        ENDIF
        .ERR
        EXITM
        EXITM
    ENDIF

    IFNB <NoCaseRegsList>
        IRP RegName,<NoCaseRegsList>
            IFIDNI <RegName>,<Reg>
                OkReg = 1
                EXITM
            ENDIF
        ENDM
    ENDIF

    IFNB <CaseRegsList>
        IRP RegName,<CaseRegsList>
            IFIDN <RegName>,<Reg>
                OkReg = 1
                EXITM
            ENDIF
        ENDM
    ENDIF

    IFE OkReg
        IF1
            %OUT Error: (&CallerName) Invalid register name '&Reg'.
            %OUT Valid= NoCaseRegsList, CaseRegsList
        ENDIF
        .ERR
        EXITM
        EXITM
    ENDIF
ENDM

;
; __@@EMIT: INTERNAL MACRO
;
;   This macro generate a single line of assembly code with left alignment so
;   the output can be easily referenced.
;


__@@EMIT macro OpCode, Operand1, Operand2
IFNB <Operand2>
    OpCode Operand1, Operand2
ELSE
IFNB <Operand1>
    OpCode Operand1
ELSE
    OpCode
ENDIF
ENDIF
ENDM


IFNDEF HT_STDCALL
    DoStdCall   EQU     <0>
ELSE
    DoStdCall   EQU     <HT_STDCALL>
ENDIF


IFNDEF DBG
    DBG             EQU <0>
ENDIF


IFDEF I8086
    i8086           EQU <I8086>
ENDIF

IFDEF I286
    i286            EQU <I286>
ENDIF

IFDEF I386
    i386            EQU <I386>
ENDIF

IFNDEF i8086
    i8086           EQU <0>
ENDIF

IFNDEF i286
    i286            EQU <0>
ENDIF

IFNDEF i386
    i386            EQU <0>
ENDIF


;
; If we can compile 80x86 assembly code, the HT_ASM_80x86 will be defined
;

IFDEF  _DOS_
    i8086           EQU <1>
    i286            EQU <0>
    i386            EQU <0>
ENDIF  ; _DIS_

IFDEF  _OS2_
    i8086           EQU <0>
    i286            EQU <1>
    i386            EQU <0>
ENDIF  ; _OS2_

IFDEF  _OS_20_
    i8086           EQU <0>
    i286            EQU <0>
    i386            EQU <1>
ENDIF  ; _OS_20_

IFDEF NO_ASM
    i8086           EQU <0>
    i286            EQU <0>
    i386            EQU <0>
ENDIF

HT_ASM_80x86    =   0                   ;; assume no assembly codes

ENDIF                                   ;; pass 1

;*****************************************************************************
IF i8086 OR i286 OR i386
;*****************************************************************************

HT_ASM_80x86    =   1

;
; To make the assembly code can run under 8088/8086/80286 and 80386 mode
; with single code to maintained, following guide lines should be obeied.
;
;  1. To load ds:si/esi from memory only using LDS_SI(mem) macro.
;
;  2. To load es:di/edi from memory only using LES_DI(mem) macro.
;
;  3. never using movzx, movsx 80386 instructions, using MOVZX_W and MOVSX_W
;     macros only, these macros must use to move only the 16-bit (word)
;     source operand.
;
;  4. To extend a 80386 16-bit registers to signed/unsigned 32-bit registers
;     only using WSXE(r) and WZXE(r) macros.
;
;  5. Memory access to seg:[si] or seg:[di] only using following macrors
;
;          BPTR_DS(RegIndex),          WPTR_DS(RegIndex)
;          BPTR_ES(RegIndex),          WPTR_ES(RegIndex)
;          BPTR_SS(Var, RegIndex),     WPTR_SS(Var, RegIndex)
;
;      Note:   A. When i80386 is enabled then BPTR_ES() and WPTR_ES are same
;                 as BPTR_DS() and WPTR_DS()
;
;  6. using _AX, _BX, _CX, _DX, _BP, _SI, _DI macro when there are used for
;     computing memory address.
;
;  7. when using loop instruction, remember ECX must has zero extend, when
;     loading cx for looping instruction later, it should using the macro
;     as MOVZX_W ECX, xxx.  where xxx is the register or memory locaiton
;
;  8. using BSXEAX <Byte> BZXEAX <Byte> macros to convert a signed 8-bit
;     register or memory value to either signed 16-bit AX or signed 32-bit EAX.
;
;  9. When using XLATE_BYTE(seg), the bx (ebx in i80386) must points to the
;     table starting address, and (seg) is the segment which the table resides
;     (only needed for i8088/i8086/i80286), the content in AL will be used as
;     an index to mapped the content in the bx+al and the result in move into
;     the AL register.
;
; 10. When using DSSI_RGB_TO_AX_INDEX macro, the ds:si/esi must points to the
;     current RGB (one byte for each color in that order) bytes array, after
;     the conversion the ds:si/esi will automatically advance 3 bytes, and
;     ax/eax contains the converted index number (0-4095) from 24-bit RGB
;     value.
;
; 11. Use LPTR_BX(Mem, Reg) to load 32-bit pointer to Reg:bx in
;     i8088/i8086/i80286 and and load 32-bit to ebx in i80386.
;


;*****************************************************************************
IF i386
;*****************************************************************************

ExtRegSet   = 1


;
; Because this is the 32-bit segment, for a 32-bit pointer type, a word is
; 32-bit long
;



        .386


        .MODEL SMALL, C                         ;; All 32-bit operation

;        assume cs:flat,ds:flat,es:flat,ss:flat
;        assume fs:nothing,gs:nothing


        IF1
        %OUT    *** Compiling 80386 Assembly Codes ***
        %OUT
        ENDIF

;
; Macros definition for the in-line assembly when the processor is i80386 or
; later (ie. i80486/i80586)
;

_AX             equ         <eax>
_BX             equ         <ebx>
_CX             equ         <ecx>
_DX             equ         <edx>
_BP             equ         <ebp>
_SI             equ         <esi>
_DI             equ         <edi>
_SP             equ         <esp>

REG_MAX_SIZE    equ         4

;
; ZXMUL3:   80386 or later CPUs.
;
;   It take SrcReg and multiply by 3 then put the result into DestReg
;

ZXMUL3 macro DestReg, SrcReg
%   __@@VALID_REG? <ZXMUL3>, <SrcReg>, <>, <AllCaseRegs>
%   __@@VALID_REG? <AXMUL3>, <DestReg>,<>, <AllCaseRegs>

    __@@EMIT <lea  > DestReg, <[SrcReg + (SrcReg*2)]>
ENDM

;
; MOVS_CB:  80386 or later CPUs.
;
;   Move the data from ds:si (esi) to es:di edi) by 'Count' of bytes, the
;   'Count' can be either constant value or in _CX register. If 'ByteReg' is
;   not blank it will be used rather than do a 'push _CX',
;
;   This macro will generate fastest code for the constant count value.
;

MOVS_CB macro Count, ByteReg

    .ERRB <Count>

    IF ((.TYPE Count) AND 00004h)                   ;; if constant value
        IF (Count AND (NOT 3h))
            IF ((Count SHR 2) LE 3)
                REPT (Count SHR 2)
                    __@@EMIT movsD
                ENDM
            ELSE
                __@@EMIT <mov  > ecx, <(Count SHR 2)> ;; if dwrod count > 3
                __@@EMIT <rep  > movsD
            ENDIF                               ;; endif dword count <= 3
        ENDIF                                   ;; endif has any dword

        IF (Count AND 2h)
            __@@EMIT <movsW>
        ENDIF

        IF (Count AND 1h)
            __@@EMIT <movsB>
        ENDIF
    ELSE

        .ERRDIF <_CX>,<Count>

        IFB <ByteReg>
            __@@EMIT <push > cx
        ELSE

            .ERRIDNI <cl>, <ByteReg>
            .ERRIDNI <ch>, <ByteReg>

            __@@EMIT <mov  > ByteReg, cl
        ENDIF

            __@@EMIT <shr  > ecx, 2
            __@@EMIT <repz > movsD

        IFB <ByteReg>
            __@@EMIT <pop  > cx
        ELSE
            __@@EMIT <mov  > cl, ByteReg
        ENDIF

        __@@EMIT <and  > cx, 3
        __@@EMIT <repz > movsB
    ENDIF
ENDM

;
; MOV_SEG:  80386 or later CPUs.
;
;   Since flat mode will not do any segment registers modification
;


MOV_SEG macro DestSeg, SrcSeg, TempReg
ENDM


BPTR_DS     equ     <BYTE PTR >
WPTR_DS     equ     <WORD PTR >
BPTR_ES     equ     <BYTE PTR >
WPTR_ES     equ     <WORD PTR >
DPTR        equ     <DWORD PTR>
FULL_PTR    equ     <DWORD PTR>

;*****************************************************************************
ELSE    ; if i386 = 0
;*****************************************************************************

ExtRegSet   = 0

;
; Because this is the 16-bit segment, for a 32-bit pointer type, a word is
; 16-bit long
;


IF i286
        .286

        IF1
        %OUT    *** Compiling 80286 Assembly Codes ***
        %OUT
        ENDIF
ELSE
        .8086

        IF1
        %OUT    *** Compiling 8086 Assembly Codes ***
        %OUT
        ENDIF
ENDIF


        .MODEL SMALL, C                         ;; All 32-bit operation


; Macros definition for the in-line assembly when the processor is i80286 or
; earlier (ie. i8088/i8086)
;

_AX             equ         <ax>
_BX             equ         <bx>
_CX             equ         <cx>
_DX             equ         <dx>
_BP             equ         <bp>
_SI             equ         <si>
_DI             equ         <di>
_SP             equ         <sp>

REG_MAX_SIZE    equ         2

;
; ZXMUL3:   8086, 80286 or ealier CPUs.
;
;   It take SrcReg and multiply by 3 then put the result into DestReg
;

ZXMUL3 macro DestReg, SrcReg

%   __@@VALID_REG? <ZXMUL3>, <SrcReg>, <>, <AllCaseRegs>
%   __@@VALID_REG? <ZXMUL3>, <DestReg>, <>, <AllCaseRegs>

    SourceReg   CATSTR <SrcReg>
    NeedPush    = 0

    IFIDN <DestReg>, <SrcReg>
        NeedPush = 1

        IFDIF <DestReg>, <_AX>
            SourceReg CATSTR <_AX>
        ELSE
            SourceReg CATSTR <_BX>
        ENDIF
    ENDIF

    IF NeedPush
        __@@EMIT <push > % SourceReg                    ;; 3
        __@@EMIT <mov  > % SourceReg, DestReg           ;; 2
    ELSE
        __@@EMIT <mov  > DestReg, SrcReg                ;; 2
    ENDIF

    __@@EMIT <shl  > DestReg, 1                         ;; 2
    __@@EMIT <add  > DestReg, % SourceReg               ;; 2 = 6

    IF NeedPush
        __@@EMIT <pop  > % SourceReg                    ;; 5 = 14
    ENDIF
ENDM


;
; MOVS_CB:  8086, 80286 or ealier CPUs.
;
;   Move the data from ds:si (esi) to es:di edi) by 'Count' of bytes, the
;   'Count' can be either constant value or in _CX register. If 'ByteReg' is
;   not blank it will be used rather than do a 'push _CX',
;
;   This macro will generate fastest code for the constant count value.
;

MOVS_CB macro Count, ByteReg

    .ERRB <Count>

    IF ((.TYPE Count) AND 00004h)                       ;; if constant value
        IF (Count AND (NOT 1h))
            IF ((Count SHR 1) LE 3)
                REPT (Count SHR 1)
                    __@@EMIT <movsW>
                ENDM
            ELSE
                __@@EMIT <mov  > cx, <(Count SHR 1)>
                __@@EMIT <rep  > movsW
            ENDIF
        ENDIF

        IF (Count AND 1h)
            __@@EMIT <movsB>
        ENDIF
    ELSE
        .ERRDIF <_CX>,<Count>
        __@@EMIT <shr  > cx, 1
        __@@EMIT <repz > movsw
        __@@EMIT <adc  > cx, cx
        __@@EMIT <repz > movsb
    ENDIF
ENDM

;
; MOV_SEG:  8086, 80286 or ealier CPUs.
;
;   Copy between DS/ES/SS segment registers, or move a constant value into the
;   DS/ES/SS.
;
;   DestSeg:    can be DS/ES/SS
;   SrcReg:     can be DS/ES/SS or constant value
;   TempReg:    can be ax/bx/cx/dx/si/di/bp or blank, if blank then a push is
;               is used
;

MOV_SEG macro DestSeg, SrcSeg, TempReg

    IFB <DestSeg>
        IF1
            %OUT Error: MOV_SEG missing destination segment name in parameter 1.
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFB <SrcSeg>
        IF1
            %OUT Error: MOV_SEG missing source segment name in parameter 2.
        ENDIF
        .ERR
        EXITM
    ENDIF

    IsSegName = 0

    IFIDNI <DestSeg>,<SrcSeg>
        IF1
            %OUT Error: MOV_SEG source/destination seg name are same (&DestSeg:&SrcSeg)
        ENDIF
        .ERR
        EXITM
    ENDIF

    IF ((.TYPE SrcSeg) AND 0010h)                   ;; if SrcSeg is a register

        IsSegName = 0

        % IRP RegName, <ds,es,ss>
%           IFIDNI <RegName>,<DestSeg>
                IsSegName = 1
                EXITM
            ENDIF
        ENDM

        IF IsSegName
            IFNB <TempReg>                              ;; if TempReg is not blank
                IF ((.TYPE TempReg) AND 0010h)          ;; if TempSeg is a register
%		    __@@VALID_REG? <MOV_SEG>, <TempReg>, <ax,bx,cx,dx,si,di,bp>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>
                    __@@EMIT <mov  > TempReg, SrcSeg
                    __@@EMIT <mov  > DestSeg, TempReg
                ELSE
                    __@@EMIT <push > SrcSeg             ;; TempReg not a register
                    __@@EMIT <pop  > DestSeg
                ENDIF
            ELSE
                __@@EMIT <push > SrcSeg                 ;; TempReg is not specified
                __@@EMIT <pop  > DestSeg
            ENDIF
        ELSE
            __@@EMIT <mov  > DestSeg, SrcSeg
        ENDIF
    ELSE
        __@@EMIT <mov  > DestSeg, <WORD PTR SrcSeg>     ;; SrcReg is in memory
    ENDIF
ENDM

BPTR_DS     equ     <BYTE PTR >
WPTR_DS     equ     <WORD PTR >
BPTR_ES     equ     <BYTE PTR es:>
WPTR_ES     equ     <WORD PTR es:>
FULL_PTR    equ     <WORD PTR>

;*****************************************************************************
ENDIF   ; i386
;*****************************************************************************

;-----------------------------------------------------------------------------
; Common to all 80x86 process
;-----------------------------------------------------------------------------


_DS         equ     <ds>
_ES         equ     <es>
_SS         equ     <ss>


BPTR_SS     equ     <BYTE PTR ss:>
WPTR_SS     equ     <WORD PTR ss:>
BPTR        equ     <BYTE PTR >
WPTR        equ     <WORD PTR >


IF1


;
; INC_LPBYTE:  80x86 famliy
;
;   Increment the IndexReg by 'Increment' and put the result in MemLoc
;

INC_LPBYTE  macro MemLoc, IncReg
    IFNB <IncReg>
        IF ((.TYPE IncReg) AND 0010h)               ;; if IncSeg is a register
%	    __@@VALID_REG? <INC_LPBYTE>, <IncReg>, <>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>
        ENDIF

        IF ExtRegSet
            __@@EMIT <add  > <DWORD PTR MemLoc>, % IncReg
        ELSE                                                ;; for non i386 cpu
            __@@EMIT <add  > <WORD PTR MemLoc>, % IncReg
        ENDIF
    ELSE
        IF ExtRegSet
            __@@EMIT <inc  > <DWORD PTR MemLoc>
        ELSE                                                ;; for non i386 cpu
            __@@EMIT <inc  > <WORD PTR MemLoc>
        ENDIF
    ENDIF
ENDM

;
; LDS_SI:   80x86 famliy
;
;   move a 32 bits address into either DS:SI or ESI register
;

LDS_SI macro Mem
    IF i386
        __@@EMIT <mov  > esi, <DWORD PTR Mem>
    ELSE
        __@@EMIT <lds  > si, <DWORD PTR Mem>
    ENDIF
ENDM

;
; LES_DI:   80x86 famliy
;
;   move a 32 bits address into either ES:DI or EDI register
;


LES_DI macro Mem
    IF i386
        __@@EMIT <mov  > edi, <DWORD PTR Mem>
    ELSE
        __@@EMIT <les  > di, <DWORD PTR Mem>
    ENDIF
ENDM

;
; LPTR_BX:   80x86 famliy
;
;   16 bit  bx: load 16 bit offset into BX register
;   32 bit ebx: load 32 bit offset into EBX register
;

LPTR_BX macro Mem
    IF i386
        __@@EMIT <mov  > ebx, <DWORD PTR Mem>
    ELSE
        __@@EMIT <mov  > bx, <WORD PTR Mem>
    ENDIF
ENDM

;
; PUSHSEG:  80x86 family
;
;   Push 'SegName' register onto stack, for 80386 or later CPUs in flat model
;   it generate no code
;

PUSHSEG macro   SegName
    IFE i386
        __@@EMIT <push > SegName                    ;; only at non i386 mode
    ENDIF
ENDM

;
; POPSEG:  80x86 family
;
;   Pop 'SegName' register from stack, for 80386 or later CPUs in flat model
;   it generate no code
;

POPSEG  macro   SegName
    IFE i386
        __@@EMIT <pop  > SegName                    ;; only at non i386 mode
    ENDIF
ENDM

;
; NEG32_FROMR16HL:   80x86 fmaily
;
;   take two 16-bit registers (RegH:RegL) as 32-bit sign number and negate that
;   number.  RegH:RegL = -(RegH:RegL)
;

NEG32_FROMR16HL  macro   RegH, RegL
%   __@@VALID_REG? <NEG32_FROMR16HL>, <RegH>, <ax,bx,cx,dx,si,di,bp>, <>
%   __@@VALID_REG? <NEG32_FROMR16HL>, <RegL>, <ax,bx,cx,dx,si,di,bp>, <>

    IFIDNI <RegH>, <RegL>
        IF1
            %OUT Error: (NEG32_FROMR16HL) RegH (&RegH) = RegL (&RegL)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <neg  > RegH
    __@@EMIT <neg  > RegL
    __@@EMIT <sbb  > RegH, 0
ENDM

;
; NEG64_FROMR32HL:   80386 or later CPUs
;
;   take two 32-bit registers (RegH:RegL) as 64-bit sign number and negate that
;   number.  RegH:RegL = -(RegH:RegL)
;


NEG64_FROMR32HL  macro   RegH, RegL

    IFE ExtRegSet
        IF1
            %OUT Error: (NEG64_FROMR32HL) this macro only for 80386 or later CPUs'
        ENDIF
        .ERR
        EXITM
    ENDIF

%   __@@VALID_REG? <NEG64_FROMR32HL>, <RegL>, <>, <_AX,_BX,_CX,_DX,_SI,DI_BP>
%   __@@VALID_REG? <NEG64_FROMR32HL>, <RegH>, <>, <_AX,_BX,_CX,_DX,_SI,DI_BP>

    IFIDNI <RegH>, <RegL>
        IF1
            %OUT Error: (NEG64_FROMR32HL) RegH (&RegH) = RegL (&RegL)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <neg  > RegH
    __@@EMIT <neg  > RegL
    __@@EMIT <sbb  > RegH, 0
ENDM

;
; S32_FROMR16HL_SR16:    80x86 family
;
;   It take two 16-bit registers (RegH:RegL) as a 32-bit number and SignReg
;   as sign indicator (either 0 or 0xffff) then flip (RegH:RegL) if SignReg
;   is equal to 0xffff
;
;   RegH:       Can be ax/bx/cx/dx/si/di/bp
;   RegL:       Can be ax/bx/cx/dx/si/di/bp
;   SignReg:    Can be ax/bx/cx/dx/si/di/bp
;
;   Note: The RegH/RegL/SignReg must resides in different register
;

S32_FROMR16HL_SR16  macro   RegH, RegL, SignReg
%   __@@VALID_REG? <S32_FROMR16HL_SR16>, <RegL>, <ax,bx,cx,dx,si,di,bp>, <>
%   __@@VALID_REG? <S32_FROMR16HL_SR16>, <RegH>, <ax,bx,cx,dx,si,di,bp>, <>
%   __@@VALID_REG? <S32_FROMR16HL_SR16>, <SignReg>, <ax,bx,cx,dx,si,di,bp>, <>

    IFIDNI <RegH>, <RegL>
        IF1
            %OUT Error: (S32_FROMR16HL_SR16) RegH (&RegH) = RegL (&RegL)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <SignReg>, <RegH>
        IF1
            %OUT Error: (S32_FROMR16HL_SR16) RegH (&RegH) = SignReg (&SignReg)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <SignReg>, <RegL>
        IF1
            %OUT Error: (S32_FROMR16HL_SR16) RegL (&RegL) = SignReg (&SignReg)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <xor  > RegL, SignReg
    __@@EMIT <xor  > RegH, SignReg
    __@@EMIT <sub  > RegL, SignReg
    __@@EMIT <sbb  > RegH, SignReg
ENDM


;
; S64_FROMR32HL_SR32:    80386 or later CPUs
;
;   It take two 32-bit registers (RegH:RegL) as a 64-bit number and SignReg
;   as sign indicator (either 0 or 0xffffffff) then flip (RegH:RegL) if SignReg
;   is equal to 0xffffffff
;
;   RegH:       Can be eax/ebx/ecx/edx/esi/edi/ebp
;   RegL:       Can be eax/ebx/ecx/edx/esi/edi/ebp
;   SignReg:    Can be eax/ebx/ecx/edx/esi/edi/ebp
;
;   Note: The RegH/RegL/SignReg must resides in different register
;

S64_FROMR32HL_SR32  macro   RegH, RegL, SignReg
    IFE ExtRegSet
        IF1
            %OUT Error: (NEG64_FROMR32HL_SR32) this macro only for 80386 or later CPUs'
        ENDIF
        .ERR
        EXITM
    ENDIF

%   __@@VALID_REG? <S64_FROMR32HL_SR32>, <RegL>, <>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>
%   __@@VALID_REG? <S64_FROMR32HL_SR32>, <RegH>, <>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>
%   __@@VALID_REG? <S64_FROMR32HL_SR32>, <SignReg>, <>, <_AX,_BX,_CX,_DX,_SI,_DI,_BP>

    IFIDNI <RegH>, <RegL>
        IF1
            %OUT Error: (S64_FROMR32HL_SR32) RegH (&RegH) = RegL (&RegL)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <SignReg>, <RegH>
        IF1
            %OUT Error: (S64_FROMR32HL_SR32) RegH (&RegH) = SignReg (&SignReg)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    IFIDNI <SignReg>, <RegL>
        IF1
            %OUT Error: (S64_FROMR32HL_SR32) RegL (&RegL) = SignReg (&SignReg)'
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <xor  > RegL, SignReg
    __@@EMIT <xor  > RegH, SignReg
    __@@EMIT <sub  > RegL, SignReg
    __@@EMIT <sbb  > RegH, SignReg
ENDM

;
; BSXEAX:   80x86 family
;
;   Sign extend the 'ByteReg' register and put the result into _AX
;

BSXEAX macro ByteReg
%   __@@VALID_REG? <BSXEAX>, <ByteReg>, <al,ah,bl,bh,cl,ch,dl,dh>, <>

    IF i386
        __@@EMIT <movsx> eax, ByteReg
    ELSE
        IFDIFI <ByteReg>,<al>
            __@@EMIT <mov  > al, ByteReg
        ENDIF
        __@@EMIT <cbw  >
    ENDIF
ENDM

;
; WSXEAX:   80x86 family
;
;   Sign extend the 'WordReg' register and put the result into _AX
;

WSXEAX macro WordReg

    IF i386
%	__@@VALID_REG? <BSXEAX>, <WordReg>, <ax,bx,cx,dx,si,di,bp>, <>
        __@@EMIT <movsx> eax, WordReg
    ENDIF
ENDM

;
; BZXEAX:   80x86 family
;
;   Zero extend the 'ByteReg' register and put the result into _AX
;

BZXEAX  macro ByteReg
%   __@@VALID_REG? <BZXEAX>, <ByteReg>, <al,ah,bl,bh,cl,ch,dl,dh>, <>

    IF i386
        __@@EMIT <movzx> eax, ByteReg
    ELSE
        IFDIFI <ByteReg>,<al>
            __@@EMIT <mov  > al, ByteReg
        ENDIF
        __@@EMIT <xor  > ah, ah
    ENDIF
ENDM

;
; WZXEAX:   80x86 family
;
;   Zero extend the 'WordReg' register and put the result into _AX
;

WZXEAX macro WordReg

    IF i386
%	__@@VALID_REG? <WZXEAX>, <WordReg>, <ax,bx,cx,dx,si,di,bp>, <>
        __@@EMIT <movzx> eax, WordReg
    ENDIF
ENDM


;
; WSXE:   80x86 family
;
;   Sign extend the 'WordReg' 16-bit register and put the result back to the
;   extended register (only sign extended for i386 or later)
;

WSXE macro WordReg
%   __@@VALID_REG? <WSXE>, <WordReg>, <ax,bx,cx,dx,si,di,bp>, <>

    IF i386
        __@@EMIT <movsx> e&WordReg, WordReg
    ENDIF
ENDM

;
; WZXE:   80x86 family
;
;   Zero extend the 'WordReg' 16-bit register and put the result back to the
;   extended register (only sign extended for i386 or later)
;

WZXE macro WordReg
%   __@@VALID_REG? <WZXE>, <WordReg>, <ax,bx,cx,dx,si,di,bp>, <>

    IF i386
        __@@EMIT <movzx> e&WordReg, WordReg
    ENDIF
ENDM

;
; MOVZE_W:  80x86 family
;
;   Move 16-bit operand (Op16) and zero extended to the 'Reg'
;

MOVZX_W macro   Reg, Op16
%   __@@VALID_REG? <MOVZX_W>, Reg, <>, <AllCaseRegs>

    IF i386
        __@@EMIT <movzx> Reg, <Op16>
    ELSE
        __@@EMIT <mov  > Reg, <Op16>
    ENDIF
ENDM

;
; MOVSE_W:  80x86 family
;
;   Move 16-bit operand (Op16) and sign extended to the 'Reg'
;

MOVSX_W macro   Reg, Op16
%   __@@VALID_REG? <MOVSX_W>, <Reg>, <>, <AllCaseRegs>

    IF i386
        __@@EMIT <movsx> Reg, <Op16>
    ELSE
        __@@EMIT <mov  > Reg, <Op16>
    ENDIF
ENDM

;
; MOV_DW:   80x86 family
;
;   Move a 64-bit point by ds:si (esi) to es:di (edi)
;

MOV_DW  macro
    IF i386
        __@@EMIT <movsD>
    ELSE
        __@@EMIT <movsw>
        __@@EMIT <movsw>
    ENDIF
ENDM

;
; BSXE: 80x86 family
;
;   Sign extend the the low 8 bits register (ByteReg) to the full 16-bit
;   same register.
;
;   ByteReg:    can be al/ah/bl/bh/cl/ch/dl/dh
;
;   Example:    BSXE al ->  sign extend al to ax
;               BSXE ah ->  sign extend ah to ax
;

BSXE macro ByteReg

%   __@@VALID_REG? <BSXE>, <ByteReg>, <al,ah,bl,bh,cl,ch,dl,dh>, <>
    HighChar    SUBSTR <ByteReg>,1,1

    IF i386
        DWordReg  CATSTR  <e>,HighChar,<x>
        __@@EMIT <movsx> % DWordReg, ByteReg
    ELSE
        LowChar     SUBSTR <ByteReg>,2,1
        HighRegName CATSTR HighChar,<h>
        LowRegName  CATSTR HighChar,<l>
        WordRegName CATSTR HighChar,<x>

%       IFIDNI <LowChar>,<h>
            __@@EMIT <mov  > % LowRegName, % HighRegName
        ENDIF

%       IFDIFI <HighChar>,<a>
            __@@EMIT <xchg > % WordRegName, ax
            __@@EMIT <cbw  >
            __@@EMIT <xchg > % WordRegName, ax
        ELSE
            __@@EMIT <cbw  >
        ENDIF
    ENDIF
ENDM

;
; BZXE: 80x86 family
;
;   Zero extend the the low 8 bits register (ByteReg) to the full 16-bit
;   same register.
;
;   ByteReg:    can be al/ah/bl/bh/cl/ch/dl/dh
;
;   Example:    BZXE al ->  zero extend al to ax
;               BZXE ah ->  zero extend ah to ax
;


BZXE macro ByteReg

%   __@@VALID_REG? <BZXE>, <ByteReg>, <al,ah,bl,bh,cl,ch,dl,dh>, <>
    HighChar    SUBSTR <ByteReg>,1,1

    IF i386
        DWordReg  CATSTR  <e>,HighChar,<x>
        __@@EMIT <movzx> % DWordReg, ByteReg
    ELSE
        LowChar     SUBSTR <ByteReg>,2,1
        HighRegName CATSTR HighChar,<h>
        LowRegName  CATSTR HighChar,<l>

%       IFIDNI <LowChar>,<h>
            __@@EMIT <mov  > % LowRegName, % HighRegName
        ENDIF

        __@@EMIT <xor  > % HighRegName, % HighRegName
    ENDIF
ENDM

;
; The ROTSFTC causing masm386 to GP, the work around is take out all the
; IF/ELSE for now
;

ROTSFTC macro   OpCode, Reg, Count
    __@@EMIT <OpCode  > <Reg>, <Count>
ENDM

;
; ROTSHTC:  80x86 family
;
;   Rotate/Shift (OpCode=shl/shr/rol/ror/rcl/rcr) the 'Reg' by count of 'Count'
;   This macro will try to generate optimized version of the call.
;
;   NOTE:   Assumtion is that the Count is less then 8
;
;ROTSFTC macro   OpCode, Reg, Count
;
;    IF ((.TYPE Count) AND 0004h)                ;; must be a constant
;        __@@VALID_REG? <ROTSFTC>, <Reg>, % AllNoCaseRegs, % AllCaseRegs
;        IF i8086
;            REPT    Count
;                __@@EMIT <OpCode  > <Reg>, 1
;            ENDM
;        ELSE
;            __@@EMIT <OpCode  > <Reg>, <Count>
;        ENDIF
;    ELSE
;        IF1
;            %OUT Error: (ROTSFTC) rotate/shift count (=&Count) must be constant value
;        ENDIF
;        .ERR
;        EXITM
;    ENDIF
;ENDM
;



REGS_PUSHED     equ     <*>                     ;;
CUR_PROC_NAME   equ     <?>                     ;;
CUR_PARAM_SIZE  =       9999


;
; __@@PUSHREG:  INTERNAL MACRO
;
;   push a set of the registers onto stack
;

__@@PUSHREG macro r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12
    IRP Reg,<r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12>
        IFB <Reg>
            EXITM
        ELSE
            __@@EMIT <push > % Reg
            REGS_PUSHED CATSTR <Reg>,<,>,REGS_PUSHED        ;; make it reverse
        ENDIF
    ENDM
ENDM

;
; __@@POPREG:  INTERNAL MACRO
;
;   pop a set of the pushed registers from stack
;

__@@POPREG macro r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12
    % IRP Reg,<r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12>
        IFB <Reg>
            EXITM
        ELSE
            __@@EMIT <pop  > Reg
        ENDIF
    ENDM
ENDM


;
; __@@EMIT_PROC:    Internal Macro to output proc name
;

__@@EMIT_PROC   Macro Name, Key, ArgList

IFB <ArgList>
Name Key
ELSE
Name Key ArgList
ENDIF

ENDM


;
; @BEG_PROC:    x86 family, this macro will generate function (proc) header
;               to match C call or STD_CALL, the 'Name' is the proc name
;               and ParamsList must in following format
;
;               <ArgName:TYPE, ArgName:TYPE,....>
;
;               The Allowed TYPEs are DWORD, QWORD only
;

@BEG_PROC   Macro   Name, ParamsList

    CUR_PARAM_SIZE  = 0                         ;; assume no parameter

    IRP Arg, <ParamsList>
        ParamIndex  INSTR   <Arg>,<:>
        ParamType   SUBSTR  <Arg>, ParamIndex + 1

%       IFIDNI <ParamType>,<DWORD>
                CUR_PARAM_SIZE = CUR_PARAM_SIZE + 4
        ELSE
%           IFIDNI <ParamType>, <QWORD>
                    CUR_PARAM_SIZE = CUR_PARAM_SIZE + 8
            ELSE
                IF1
                   %OUT Error: Invalid Parameter Type (&ParamType) [DWORD/QWORD only]
                ENDIF
                .ERR
                EXITM
            ENDIF
        ENDIF
    ENDM

    IF DoStdCall
        CUR_PROC_NAME   CATSTR <Name>,<@>, % CUR_PARAM_SIZE
    ELSE
        CUR_PROC_NAME   CATSTR <Name>
    ENDIF

    __@@EMIT_PROC   <ALIGN>, <DWORD>
    __@@EMIT_PROC   <PUBLIC>, % CUR_PROC_NAME
    __@@EMIT_PROC   % CUR_PROC_NAME,<PROC NEAR>,<ParamsList>

ENDM


;
; @END_PROC:    x86 family, this macro used to end the function (proc) body
;


@END_PROC   Macro

%   IFIDNI <CUR_PROC_NAME>,<?>
        IF1
           %OUT Error: @BEG_PROC macro never called
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT_PROC   % CUR_PROC_NAME, < ENDP>

    CUR_PROC_NAME   CATSTR <?>
ENDM


;
; @ENTER:   80x86 family
;
;   This macro should only call once at entry point of each function, it save
;   a set of register used by the function and keep track the saved registers
;   at @EXIT macro call to properly restored the saved registers
;
;   Note:   1) This macro must call for each function even no registers need
;              to be saved, it provide compabilities cross different platform,
;              (for example, it automatically save 'ebx' register for i386
;              flat model even no saved registers are passed)
;           2) pushed registers for 8086/80286 are ds, si, di, bp and for i386
;              or later are esi, edi, ebp.
;           3) This macro automatically push 'ebx' for the i386 or later CPUs
;           4) This macro should only used conjunction with @EXIT macro, it
;              will flag error if @ENTER/@EXIT is not in pair.
;

@ENTER  macro   r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12

%   IFIDNI <CUR_PROC_NAME>,<?>
        IF1
           %OUT Error: @BEG_PROC macro never called
        ENDIF
        .ERR
        EXITM
    ENDIF

    NUM_INDEX   INSTR   REGS_PUSHED,<@>

    IF NUM_INDEX
        IF1
            %OUT Error: a @XCHG_SS_SP_BP called before @ENTER
        ENDIF
        .ERR
        EXITM
    ENDIF

    REGS_PUSHED CATSTR <#>, REGS_PUSHED             ;; use # as seperation

%   IFDIF <REGS_PUSHED>,<#*>
        IF1
            %OUT Error: No @EXIT for previous @ENTER
        ENDIF
        .ERR
        EXITM
    ENDIF

    __@@EMIT <cld  >                                ;; clear the direction

    IF i386                                         ;; for 80386 flat model
        __@@PUSHREG _BX                             ;; save EBX also
    ENDIF

    IRP Reg, <r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12>

        IFB <Reg>
            EXITM
        ENDIF

        RegNameOK = 0

        IRP OkReg, <_DS,_SI,_ES,_DI,_SS,_SP,_AX,_BX,_CX,_DX,_BP>
            IFIDN <Reg>,<OkReg>
                RegNameOK = 1
                EXITM
            ENDIF
        ENDM

        IFE RegNameOK
            IF1
                %OUT Error: Invalid @ENTER register '&Reg': (_DS,_SI,_ES,_DI,_SS,_SP,_AX,_BX,_CX,_DX,_BP)
            ENDIF
            .ERR
            EXITM
        ENDIF

        RegNameOk = 0

        IF i386
            IRP RegToPush, <_SI,_DI,_BP>            ;; allowed to specified
                IFIDN <RegToPush>,<Reg>
                    RegNameOk = 1
                    EXITM
                ENDIF
            ENDM
        ELSE
            IRP RegToPush, <_DS,_SI,_DI,_BP>        ;; allowed to specified
                IFIDN <RegToPush>,<Reg>
                    RegNameOk = 1
                    EXITM
                ENDIF
            ENDM
        ENDIF       ;; i386

        IF RegNameOk
            __@@PUSHREG Reg                         ;; save that register
        ENDIF
    ENDM
ENDM

;
; @EXIT:    80x86 family
;
;   This macro poped previously saved registers by @ENTER macro call, if
;   @EXIT is call without @ENTER then it will generate an error.
;
;   Note:   1) The @ENTER/@EXIT should call as pair within the function.
;           2) The @ENTER should used before any other macro calls in the
;              function.
;           3) The @EXIT should used right before the exit point in the
;              fucction.
;

@EXIT   macro

    NUM_INDEX   INSTR   REGS_PUSHED,<@>             ;; find XCHG_SS_SP

    IF NUM_INDEX
        IF NUM_INDEX NE 1
            IF1
                %OUT Error: __@@RESTORE_SS_SP called before @ENTER.
            ENDIF
            .ERR
            EXITM
        ELSE
            __@@RESTORE_SS_SP                          ;; restore ss:sp
        ENDIF
    ENDIF

    NUM_INDEX   INSTR   REGS_PUSHED,<#>

    IFE NUM_INDEX
        IF1
            %OUT Error: @EXIT without an @ENTER
        ENDIF
        .ERR
        EXITM
    ENDIF

    POP_REGS    SUBSTR  REGS_PUSHED,1,NUM_INDEX-1
    REGS_LEN    SIZESTR REGS_PUSHED

    IF REGS_LEN GT NUM_INDEX
        NUM_INDEX = NUM_INDEX + 1
    ENDIF

    REGS_PUSHED SUBSTR  REGS_PUSHED,NUM_INDEX           ;; remove the pops

    % IRP Reg, <POP_REGS>
        IFNB <Reg>
            __@@POPREG  Reg
        ENDIF
    ENDM

    IF DoStdCall
        IF CUR_PARAM_SI