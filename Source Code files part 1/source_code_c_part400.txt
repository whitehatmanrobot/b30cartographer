escription:

    This function binds the specified transport to the redirector
    and the datagram receiver.

    NOTE: The transport name length pass to the redirector and
          datagram receiver is the number of bytes.

Arguments:

    TransportName - Supplies the name of the transport to bind to.

    QualityOfService - Supplies a value which specifies the search
        order of the transport with respect to other transports.  The
        highest value is searched first.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    DWORD RequestPacketSize;
    DWORD TransportNameSize = wcslen(TransportName) * sizeof(WCHAR);

    PNWR_REQUEST_PACKET Rrp;


    //
    // Size of request packet buffer
    //
    RequestPacketSize = TransportNameSize + sizeof(NWR_REQUEST_PACKET);

    //
    // Allocate memory for redirector/datagram receiver request packet
    //
    if ((Rrp = (PVOID) LocalAlloc(LMEM_ZEROINIT, (UINT) RequestPacketSize)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Get redirector to bind to transport
    //
    Rrp->Version = REQUEST_PACKET_VERSION;
    Rrp->Parameters.Bind.QualityOfService = QualityOfService;

    Rrp->Parameters.Bind.TransportNameLength = TransportNameSize;
    wcscpy((LPWSTR) Rrp->Parameters.Bind.TransportName, TransportName);

    if ((status = NwRedirFsControl(
                      RedirDeviceHandle,
                      FSCTL_NWR_BIND_TO_TRANSPORT,
                      Rrp,
                      RequestPacketSize,
                      NULL,
                      0,
                      NULL
                      )) != NO_ERROR) {

        KdPrint(("NWWORKSTATION: NwBindTransport fsctl to bind to transport %ws failed\n",
                 TransportName));
    }

    (void) LocalFree((HLOCAL) Rrp);
    return status;
}


DWORD
NwGetCallerLuid (
    IN OUT  PLUID pLuid
    )
/*++

Routine Description:

    Retrieves the caller's LUID from the effective access_token
    The effective access_token will be the thread's token if
    impersonating, else the process' token

Arguments:

    pLuid [IN OUT] - pointer to a buffer to hold the LUID

Return Value:

    STATUS_SUCCESS - operations successful, did not encounter any errors

    STATUS_INVALID_PARAMETER - pLuid is NULL

    STATUS_NO_TOKEN - could not find a token for the user

    appropriate NTSTATUS code - an unexpected error encountered

--*/

{
    TOKEN_STATISTICS TokenStats;
    HANDLE   hToken    = NULL;
    DWORD    dwLength  = 0;
    NTSTATUS Status;
    ULONG DosError;

    if( (pLuid == NULL) || (sizeof(*pLuid) != sizeof(LUID)) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // Get the access token
    // Try to get the impersonation token, else the primary token
    //
    Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_READ, TRUE, &hToken );

    if( Status == STATUS_NO_TOKEN ) {

        Status = NtOpenProcessToken( NtCurrentProcess(), TOKEN_READ, &hToken );

    }

    if( NT_SUCCESS(Status) ) {

        //
        // Query the LUID for the user.
        //

        Status = NtQueryInformationToken( hToken,
                                          TokenStatistics,
                                          &TokenStats,
                                          sizeof(TokenStats),
                                          &dwLength );

        if( NT_SUCCESS(Status) ) {
            RtlCopyLuid( pLuid, &(TokenStats.AuthenticationId) );
        }
    }

    if( hToken != NULL ) {
        NtClose( hToken );
    }

    DosError = RtlNtStatusToDosError(Status);

    return( (DWORD)DosError );
}


DWORD
NwCreateTreeConnectName(
    IN  LPWSTR UncName,
    IN  LPWSTR LocalName OPTIONAL,
    OUT PUNICODE_STRING TreeConnectStr
    )
/*++

Routine Description:

    This function replaces \\ with \Device\NwRdr\LocalName:\ in the
    UncName to form the NT-style tree connection name.  LocalName:\ is part
    of the tree connection name only if LocalName is specified.  A buffer
    is allocated by this function and returned as the output string.

Arguments:

    UncName - Supplies the UNC name of the shared resource.

    LocalName - Supplies the local device name for the redirection.

    TreeConnectStr - Returns a string with a newly allocated buffer that
        contains the NT-style tree connection name.

Return Value:

    NO_ERROR - the operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

--*/
{
    WCHAR LUIDBuffer[NW_MAX_LOGON_ID_LEN];
    DWORD UncNameLength = wcslen(UncName);
    LUID CallerLuid;
    BOOLEAN UseLUID;

    //UseLUID = (ARGUMENT_PRESENT(LocalName) && NwLUIDDeviceMapsEnabled);

    //
    // Temporary disable passing the LUID until LUID support is added in
    // the nwrdr.sys for parsing the device name
    //
    UseLUID = FALSE;

    //
    // Initialize tree connect string maximum length to hold
    // If LUID DosDevices enabled && LocalName Specified,
    //       \Device\NwRdr\LocalName:XXXXXXXXxxxxxxxx\Server\Volume\Path
    //       XXXXXXXX - LUID.HighPart
    //       xxxxxxxx - LUID.LowPart
    // else
    //       \Device\NwRdr\LocalName:\Server\Volume\Path
    //
    if( UseLUID ) {
        DWORD DosError;

        DosError = NwGetCallerLuid(&CallerLuid);
        if( DosError != NO_ERROR) {
            return DosError;
        }
    }

    TreeConnectStr->MaximumLength = RedirDeviceName.Length +
        sizeof(WCHAR) +                                // For ending 0
        sizeof(WCHAR) +                                // For '\'
        (ARGUMENT_PRESENT(LocalName) ? (wcslen(LocalName) * sizeof(WCHAR)) : 0) +
        (UseLUID ? NW_MAX_LOGON_ID_LEN * sizeof(WCHAR): 0) +
        (USHORT) (UncNameLength * sizeof(WCHAR));      // Includes '\'


    if ((TreeConnectStr->Buffer = (PWSTR) LocalAlloc(
                                              LMEM_ZEROINIT,
                                              (UINT) TreeConnectStr->MaximumLength
                                              )) == NULL) {
        KdPrint(("NWWORKSTATION: NwCreateTreeConnectName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy \Device\NwRdr
    //
    RtlCopyUnicodeString(TreeConnectStr, &RedirDeviceName);

    //
    // Concatenate \LocalName:
    //
    if (ARGUMENT_PRESENT(LocalName)) {

        wcscat(TreeConnectStr->Buffer, L"\\");
        TreeConnectStr->Length += sizeof(WCHAR);

        wcscat(TreeConnectStr->Buffer, LocalName);

        TreeConnectStr->Length += (USHORT) (wcslen(LocalName) * sizeof(WCHAR));

        //
        // Concatenate the caller's LUID
        //
        if( UseLUID ) {
            _snwprintf( LUIDBuffer,
                        NW_MAX_LOGON_ID_LEN - 1,
                        L"%08x%08x",
                        CallerLuid.HighPart,
                        CallerLuid.LowPart );
            LUIDBuffer[NW_MAX_LOGON_ID_LEN - 1] = 0;

            wcscat(TreeConnectStr->Buffer, LUIDBuffer);

            TreeConnectStr->Length += (USHORT) (wcslen(LUIDBuffer) * sizeof(WCHAR));
        }
    }

    //
    // Concatenate \Server\Volume\Path
    //
    if (UncNameLength > 0) {
        wcscat(TreeConnectStr->Buffer, &UncName[1]);
        TreeConnectStr->Length += (USHORT) ((UncNameLength - 1) * sizeof(WCHAR));
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NwCreateTreeConnectName %ws, maxlength %u, length %u\n",
                 TreeConnectStr->Buffer, TreeConnectStr->MaximumLength,
                 TreeConnectStr->Length));
    }
#endif

    return NO_ERROR;
}



DWORD
NwOpenCreateConnection(
    IN PUNICODE_STRING TreeConnectionName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UncName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    )
/*++

Routine Description:

    This function asks the redirector to either open an existing tree
    connection (CreateDisposition == FILE_OPEN), or create a new tree
    connection if one does not exist (CreateDisposition == FILE_CREATE).

    The password and user name passed to the redirector via the EA buffer
    in the NtCreateFile call.  The EA buffer is NULL if neither password
    or user name is specified.

    The redirector expects the EA descriptor strings to be in ANSI
    but the password and username themselves are in Unicode.

Arguments:

    TreeConnectionName - Supplies the name of the tree connection in NT-style
        file name format: \Device\NwRdr\Server\Volume\Directory

    UserName - Supplies the user name to create the tree connection with.

    Password - Supplies the password to create the tree connection with.

    DesiredAccess - Supplies the access need on the connection handle.

    CreateDisposition - Supplies the create disposition value to either
        open or create the tree connection.

    CreateOptions - Supplies the options used when creating or opening
        the tree connection.

    ConnectionType - Supplies the type of the connection (DISK, PRINT,
        or ANY).

    TreeConnectionHandle - Returns the handle to the tree connection
        created/opened by the redirector.

    Information - Returns the information field of the I/O status block.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NTSTATUS ntstatus;

    OBJECT_ATTRIBUTES UncNameAttributes;
    IO_STATUS_BLOCK IoStatusBlock;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION Ea;
    ULONG EaBufferSize = 0;

    UCHAR EaNamePasswordSize = (UCHAR) (ROUND_UP_COUNT(
                                            strlen(EA_NAME_PASSWORD) + sizeof(CHAR),
                                            ALIGN_WCHAR
                                            ) - sizeof(CHAR));
    UCHAR EaNameUserNameSize = (UCHAR) (ROUND_UP_COUNT(
                                            strlen(EA_NAME_USERNAME) + sizeof(CHAR),
                                            ALIGN_WCHAR
                                            ) - sizeof(CHAR));

    UCHAR EaNameTypeSize = (UCHAR) (ROUND_UP_COUNT(
                                        strlen(EA_NAME_TYPE) + sizeof(CHAR),
                                        ALIGN_DWORD
                                        ) - sizeof(CHAR));

    USHORT PasswordSize = 0;
    USHORT UserNameSize = 0;
    USHORT TypeSize = sizeof(ULONG);



    InitializeObjectAttributes(
        &UncNameAttributes,
        TreeConnectionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Calculate the number of bytes needed for the EA buffer to put the
    // password or user name.
    //
    if (ARGUMENT_PRESENT(Password)) {

#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("NWWORKSTATION: NwOpenCreateConnection password is %ws\n",
                     Password));
        }
#endif

        PasswordSize = (USHORT) (wcslen(Password) * sizeof(WCHAR));

        EaBufferSize = ROUND_UP_COUNT(
                           FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                           EaNamePasswordSize + sizeof(CHAR) +
                           PasswordSize,
                           ALIGN_DWORD
                           );
    }

    if (ARGUMENT_PRESENT(UserName)) {

#if DBG
        IF_DEBUG(CONNECT) {
            KdPrint(("NWWORKSTATION: NwOpenCreateConnection username is %ws\n",
                     UserName));
        }
#endif

        UserNameSize = (USHORT) (wcslen(UserName) * sizeof(WCHAR));

        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameUserNameSize + sizeof(CHAR) +
                            UserNameSize,
                            ALIGN_DWORD
                            );
    }

    EaBufferSize += FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                    EaNameTypeSize + sizeof(CHAR) +
                    TypeSize;

    //
    // Allocate the EA buffer
    //
    if ((EaBuffer = (PFILE_FULL_EA_INFORMATION) LocalAlloc(
                                                    LMEM_ZEROINIT,
                                                    (UINT) EaBufferSize
                                                    )) == NULL) {
        status = GetLastError();
        goto FreeMemory;
    }

    Ea = EaBuffer;

    if (ARGUMENT_PRESENT(Password)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_PASSWORD);
        Ea->EaNameLength = EaNamePasswordSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy(
            (LPWSTR) &(Ea->EaName[EaNamePasswordSize + sizeof(CHAR)]),
            Password
            );

        Ea->EaValueLength = PasswordSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNamePasswordSize + sizeof(CHAR) +
                                  PasswordSize,
                                  ALIGN_DWORD
                                  );

        Ea->Flags = 0;
        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }

    if (ARGUMENT_PRESENT(UserName)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_USERNAME);
        Ea->EaNameLength = EaNameUserNameSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy(
            (LPWSTR) &(Ea->EaName[EaNameUserNameSize + sizeof(CHAR)]),
            UserName
            );

        Ea->EaValueLength = UserNameSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameUserNameSize + sizeof(CHAR) +
                                  UserNameSize,
                                  ALIGN_DWORD
                                  );
        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;

    }

    //
    // Copy the connection type name into EA buffer.  EA name length
    // does not include the zero terminator.
    //
    strcpy((LPSTR) Ea->EaName, EA_NAME_TYPE);
    Ea->EaNameLength = EaNameTypeSize;

    *((PULONG) &(Ea->EaName[EaNameTypeSize + sizeof(CHAR)])) = ConnectionType;

    Ea->EaValueLength = TypeSize;

    //
    // Terminate the EA.
    //
    Ea->NextEntryOffset = 0;
    Ea->Flags = 0;

    //
    // Create or open a tree connection
    //
    ntstatus = NtCreateFile(
                   TreeConnectionHandle,
                   DesiredAccess,
                   &UncNameAttributes,
                   &IoStatusBlock,
                   NULL,
                   FILE_ATTRIBUTE_NORMAL,
                   FILE_SHARE_VALID_FLAGS,
                   CreateDisposition,
                   CreateOptions,
                   (PVOID) EaBuffer,
                   EaBufferSize
                   );

    if (ntstatus == NWRDR_PASSWORD_HAS_EXPIRED) {
        //
        // wait till other thread is not using the popup data struct.
        // if we timeout, then we just lose the popup.
        //
        switch (WaitForSingleObject(NwPopupDoneEvent, 3000))
        {
            case WAIT_OBJECT_0:
            {
                LPWSTR lpServerStart, lpServerEnd ;
                WCHAR UserNameW[NW_MAX_USERNAME_LEN+1] ;
                DWORD dwUserNameWSize = sizeof(UserNameW)/sizeof(UserNameW[0]) ;
                DWORD dwServerLength, dwGraceLogins ;
                DWORD dwMessageId = NW_PASSWORD_HAS_EXPIRED ;

                //
                // get the current username
                //
                if (UserName)
                {
                    wcscpy(UserNameW, UserName) ;
                }
                else
                {
                    if (!GetUserNameW(UserNameW, &dwUserNameWSize))
                    {
                        SetEvent(NwPopupDoneEvent) ;
                        break ;
                    }
                }

                //
                // allocate string and fill in the username
                //
                if (!(PopupData.InsertStrings[0] =
                    (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(WCHAR) * (wcslen(UserNameW)+1))))
                {
                    SetEvent(NwPopupDoneEvent) ;
                    break ;
                }
                wcscpy(PopupData.InsertStrings[0], UserNameW) ;

                //
                // find the server name from unc name
                //
                lpServerStart = (*UncName == L'\\') ? UncName+2 : UncName ;
                lpServerEnd = wcschr(lpServerStart,L'\\') ;
                dwServerLength = lpServerEnd ? (DWORD) (lpServerEnd-lpServerStart) :
                                 wcslen(lpServerStart) ;

                //
                // allocate string and fill in the server insert string
                //
                if (!(PopupData.InsertStrings[1] =
                    (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(WCHAR) * (dwServerLength+1))))
                {
                    (void) LocalFree((HLOCAL) PopupData.InsertStrings[0]);
                    SetEvent(NwPopupDoneEvent) ;
                    break ;
                }
                wcsncpy(PopupData.InsertStrings[1],
                        lpServerStart,
                        dwServerLength) ;

                //
                // now call the NCP. if an error occurs while getting
                // the grace login count, dont use it.
                //
                if (NwGetGraceLoginCount(
                                     PopupData.InsertStrings[1],
                                     UserNameW,
                                     &dwGraceLogins) != NO_ERROR)
                {
                    dwMessageId = NW_PASSWORD_HAS_EXPIRED1 ;
                    dwGraceLogins = 0 ;
                }

                //
                // stick the number of grace logins in second insert string.
                //
                if (!(PopupData.InsertStrings[2] =
                    (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(WCHAR) * 16)))
                {
                    (void) LocalFree((HLOCAL) PopupData.InsertStrings[0]);
                    (void) LocalFree((HLOCAL) PopupData.InsertStrings[1]);
                    SetEvent(NwPopupDoneEvent) ;
                    break ;
                }

                wsprintfW(PopupData.InsertStrings[2], L"%d", dwGraceLogins);
                PopupData.InsertCount = 3 ;
                PopupData.MessageId = dwMessageId ;

        //--Mutl-user change ----
                GetLuid( &PopupData.LogonId );          

                //
                // all done at last, trigger the other thread do the popup
                //
                SetEvent(NwPopupEvent) ;
                break ;

            }

            default:
                break ; // dont bother if we cannot
        }
    }

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ntstatus == NWRDR_PASSWORD_HAS_EXPIRED) {
        ntstatus = STATUS_SUCCESS ;
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = IoStatusBlock.Information;
    }

#if DBG
    IF_DEBUG(CONNECT) {
        KdPrint(("NWWORKSTATION: NtCreateFile returns %lx\n", ntstatus));
    }
#endif

    status = NwMapStatus(ntstatus);

FreeMemory:
    if (EaBuffer != NULL) {
        RtlZeroMemory( EaBuffer, EaBufferSize );  // Clear the password
        (void) LocalFree((HLOCAL) EaBuffer);
    }

    return status;
}


DWORD
NwNukeConnection(
    IN HANDLE TreeConnection,
    IN DWORD UseForce
    )
/*++

Routine Description:

    This function asks the redirector to delete an existing tree
    connection.

Arguments:

    TreeConnection - Supplies the handle to an existing tree connection.

    UseForce - Supplies the force flag to delete the tree connection.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NWR_REQUEST_PACKET Rrp;            // Redirector request packet


    //
    // Tell the redirector to delete the tree connection
    //
    Rrp.Version = REQUEST_PACKET_VERSION;
    Rrp.Parameters.DeleteConn.UseForce = (BOOLEAN) UseForce;

    status = NwRedirFsControl(
                 TreeConnection,
                 FSCTL_NWR_DELETE_CONNECTION,
                 &Rrp,
                 sizeof(NWR_REQUEST_PACKET),
                 NULL,
                 0,
                 NULL
                 );

    return status;
}


DWORD
NwGetServerResource(
    IN LPWSTR LocalName,
    IN DWORD LocalNameLength,
    OUT LPWSTR RemoteName,
    IN DWORD RemoteNameLen,
    OUT LPDWORD CharsRequired
    )
/*++

Routine Description:

    This function

Arguments:


Return Value:


--*/
{
    DWORD status = NO_ERROR;

    BYTE Buffer[sizeof(NWR_REQUEST_PACKET) + 2 * sizeof(WCHAR)];
    PNWR_REQUEST_PACKET Rrp = (PNWR_REQUEST_PACKET) Buffer;


    //
    // local device name should not be longer than 4 characters e.g. LPTx, X:
    //
    if ( LocalNameLength > 4 )
        return ERROR_INVALID_PARAMETER;

    Rrp->Version = REQUEST_PACKET_VERSION;

    wcsncpy(Rrp->Parameters.GetConn.DeviceName, LocalName, LocalNameLength);
    Rrp->Parameters.GetConn.DeviceNameLength = LocalNameLength * sizeof(WCHAR);

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_GET_CONNECTION,
                 Rrp,
                 sizeof(NWR_REQUEST_PACKET) +
                     Rrp->Parameters.GetConn.DeviceNameLength,
                 RemoteName,
                 RemoteNameLen * sizeof(WCHAR),
                 NULL
                 );

    if (status == ERROR_INSUFFICIENT_BUFFER) {
        *CharsRequired = Rrp->Parameters.GetConn.BytesNeeded / sizeof(WCHAR);
    }
    else if (status == ERROR_FILE_NOT_FOUND) {

        //
        // Redirector could not find the specified LocalName
        //
        status = WN_NOT_CONNECTED;
    }

    return status;

}


DWORD
NwEnumerateConnections(
    IN OUT PDWORD_PTR ResumeId,
    IN DWORD_PTR EntriesRequested,
    IN LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead,
    IN DWORD ConnectionType,
    IN PLUID LogonId
    )
/*++

Routine Description:

    This function asks the redirector to enumerate all existing
    connections.

Arguments:

    ResumeId - On input, supplies the resume ID of the next entry
        to begin the enumeration.  This ID is an integer value that
        is either the smaller or the same value as the ID of the
        next entry to return.  On output, this ID indicates the next
        entry to start resuming from for the subsequent call.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff ERROR_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

    ConnectionType - The type of connected resource wanted ( DISK, PRINT, ...)

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NWR_REQUEST_PACKET Rrp;            // Redirector request packet


    //
    // Tell the redirector to enumerate all connections.
    //
    Rrp.Version = REQUEST_PACKET_VERSION;

    Rrp.Parameters.EnumConn.ResumeKey = *ResumeId;
    Rrp.Parameters.EnumConn.EntriesRequested = (ULONG) EntriesRequested;
    Rrp.Parameters.EnumConn.ConnectionType = ConnectionType;


    //Multi-user change
    if (LogonId != NULL ) {
        Rrp.Parameters.EnumConn.Uid = *LogonId;
    }
    //
    // This is good to do, the the fix below is also needed.
    //
    Rrp.Parameters.EnumConn.EntriesReturned = 0;

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_ENUMERATE_CONNECTIONS,
                 &Rrp,
                 sizeof(NWR_REQUEST_PACKET),
                 Buffer,                      // User output buffer
                 BufferSize,
                 NULL
                 );

    *EntriesRead = Rrp.Parameters.EnumConn.EntriesReturned;


    //
    // Strange bug on shutdown
    // WinLogon was clearing connections after the shutdown
    //
    if (status == ERROR_INVALID_HANDLE ) {
        KdPrint(("NWWORKSTATION: NwEnumerateConnections Invalid Handle!\n"));
        *EntriesRead = 0;
    }
    else if (status == WN_MORE_DATA) {
        *BytesNeeded = Rrp.Parameters.EnumConn.BytesNeeded;

        //
        // NP specs expect WN_SUCCESS in this case.
        //
        if (*EntriesRead)
            status = WN_SUCCESS ;
    }

    *ResumeId = Rrp.Parameters.EnumConn.ResumeKey;

    return status;
}


DWORD
NwGetNextServerEntry(
    IN HANDLE PreferredServer,
    IN OUT LPDWORD LastObjectId,
    OUT LPSTR ServerName
    )
/*++

Routine Description:

    This function uses an opened handle to the preferred server to
    scan it bindery for all file server objects.

Arguments:

    PreferredServer - Supplies the handle to the preferred server on
        which to scan the bindery.

    LastObjectId - On input, supplies the object ID to the last file
        server object returned, which is the resume handle to get the
        next file server object.  On output, receives the object ID
        of the file server object returned.

    ServerName - Receives the name of the returned file server object.

Return Value:

    NO_ERROR - Successfully gotten a file server name.

    WN_NO_MORE_ENTRIES - No other file server object past the one
        specified by LastObjectId.

--*/
{
    NTSTATUS ntstatus;
    WORD ObjectType;


#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextServerEntry LastObjectId %lu\n",
                 *LastObjectId));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   PreferredServer,
                   FSCTL_NWR_NCP_E3H,    // Bindery function
                   58,                   // Max request packet size
                   59,                   // Max response packet size
                   "bdwp|dwc",           // Format string
                   0x37,                 // Scan bindery object
                   *LastObjectId,        // Previous ID
                   0x4,                  // File server object
                   "*",                  // Wildcard to match all
                   LastObjectId,         // Current ID
                   &ObjectType,          // Ignore
                   ServerName            // Currently returned server
                   );

#if DBG
    if (ntstatus == STATUS_SUCCESS) {
        IF_DEBUG(ENUM) {
            KdPrint(("NWWORKSTATION: NwGetNextServerEntry NewObjectId %08lx, ServerName %s\n",
                     *LastObjectId, ServerName));
        }
    }
#endif

    return NwMapBinderyCompletionCode(ntstatus);
}


DWORD
GetConnectedBinderyServers(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function is a helper routine for the function
    NwGetNextServerConnection. It allocates a buffer to cache
    bindery server names returned from calls to the redirector. Since the
    redirector may return duplicate bindery server names, this
    function checks to see if the server name already exist in the buffer
    before adding it.

Arguments:

    ContextHandle - Used to track cached bindery information and the
                    current server name pointer in the cache buffer.

Return Value:

    NO_ERROR - Successfully returned a server name and cache buffer.

    WN_NO_MORE_ENTRIES - No other server object past the one
        specified by CH->ResumeId.

    ERROR_NOT_ENOUGH_MEMORY - Function was unable to allocate a buffer.

++*/
{
    DWORD_PTR  ResumeKey = 0;
    LPBYTE pBuffer = NULL;
    DWORD  EntriesRead = 0;
    BYTE   tokenIter;
    LPWSTR tokenPtr;
    BOOL   fAddToList;
    DWORD  status = NwGetConnectionStatus( NULL,
                                           &ResumeKey,
                                           &pBuffer,
                                           &EntriesRead );

    if ( status == NO_ERROR  && EntriesRead > 0 )
    {
        DWORD i;
        PCONN_STATUS pConnStatus = (PCONN_STATUS) pBuffer;

        ContextHandle->ResumeId = 0;
        ContextHandle->NdsRawDataCount = 0;
        ContextHandle->NdsRawDataSize = (NW_MAX_SERVER_LEN + 2) * EntriesRead;
        ContextHandle->NdsRawDataBuffer =
                    (DWORD_PTR) LocalAlloc( LMEM_ZEROINIT,
                                        ContextHandle->NdsRawDataSize );

        if ( ContextHandle->NdsRawDataBuffer == 0 )
        {
            KdPrint(("NWWORKSTATION: GetConnectedBinderyServers LocalAlloc failed %lu\n",
                     GetLastError()));

            ContextHandle->NdsRawDataSize = 0;

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        for ( i = 0; i < EntriesRead ; i++ )
        {
            fAddToList = FALSE;

            if ( pConnStatus->fNds == 0 &&
                 ( pConnStatus->dwConnType == NW_CONN_BINDERY_LOGIN ||
                   pConnStatus->dwConnType == NW_CONN_NDS_AUTHENTICATED_NO_LICENSE ||
                   pConnStatus->dwConnType == NW_CONN_NDS_AUTHENTICATED_LICENSED ||
                   pConnStatus->dwConnType == NW_CONN_DISCONNECTED ) )
            {
                fAddToList = TRUE;
                tokenPtr = (LPWSTR) ContextHandle->NdsRawDataBuffer;
                tokenIter = 0;

                //
                // Walk through buffer to see if the tree name already exists.
                //
                while ( tokenIter < ContextHandle->NdsRawDataCount )
                {
                    if ( !wcscmp( tokenPtr, pConnStatus->pszServerName ) )
                    {
                        fAddToList = FALSE;
                    }

                    tokenPtr = tokenPtr + wcslen( tokenPtr ) + 1;
                    tokenIter++;
                }
            }

            //
            //  Add the new tree name to end of buffer if needed.
            //
            if ( fAddToList )
            {
                wcscpy( tokenPtr, pConnStatus->pszServerName );
                _wcsupr( tokenPtr );
                ContextHandle->NdsRawDataCount += 1;
            }

            pConnStatus = (PCONN_STATUS) ( pConnStatus +
                                           pConnStatus->dwTotalLength );
        }

        if ( pBuffer != NULL )
        {
            LocalFree( pBuffer );
            pBuffer = NULL;
        }

        if ( ContextHandle->NdsRawDataCount > 0 )
        {
            //
            // Set ResumeId to point to the first entry in buffer
            // and have NdsRawDataCount set to the number
            // of tree entries left in buffer (ie. substract 1)
            //
            ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer;
            ContextHandle->NdsRawDataCount -= 1;
        }

        return NO_ERROR;
    }

    return WN_NO_MORE_ENTRIES;
}


DWORD
NwGetNextServerConnection(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function queries the redirector for bindery server connections

Arguments:

    ContextHandle - Receives the name of the returned bindery server.

Return Value:

    NO_ERROR - Successfully returned a server name.

    WN_NO_MORE_ENTRIES - No other server objects past the one
        specified by CH->ResumeId exist.

--*/
{
#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextServerConnection ResumeId %lu\n",
                 ContextHandle->ResumeId));
    }
#endif

    if ( ContextHandle->ResumeId == (DWORD_PTR) -1 &&
         ContextHandle->NdsRawDataBuffer == 0 &&
         ContextHandle->NdsRawDataCount == 0 )
    {
        //
        // Fill the buffer and point ResumeId to the last
        // server entry name in it. NdsRawDataCount will be
        // set to one less than the number of server names in buffer.
        //
        return GetConnectedBinderyServers( ContextHandle );
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount > 0 )
    {
        //
        // Move ResumeId to point to the next entry in the buffer
        // and decrement the NdsRawDataCount by one. Watch for case
        // where we backed up to -1.
        //
        if (ContextHandle->ResumeId == (DWORD_PTR) -1) {

            //
            // Reset to start of buffer.
            //
            ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer;
        }
        else {

            //
            // Treat as pointer and advance as need.
            //
            ContextHandle->ResumeId =
                       ContextHandle->ResumeId +
                       ( ( wcslen( (LPWSTR) ContextHandle->ResumeId ) + 1 ) *
                       sizeof(WCHAR) );
        }
        ContextHandle->NdsRawDataCount -= 1;

        return NO_ERROR;
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount == 0 )
    {
        //
        // We already have a buffer and processed all server names
        // in it, and there is no more data to get.
        // So free the memory used for the buffer and return
        // WN_NO_MORE_ENTRIES to tell WinFile that we are done.
        //
        (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );

        ContextHandle->NdsRawDataBuffer = 0;
        ContextHandle->NdsRawDataSize = 0;

        return WN_NO_MORE_ENTRIES;
    }

    //
    // Were done
    //
    return WN_NO_MORE_ENTRIES;
}


DWORD
GetTreeEntriesFromBindery(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function is a helper routine for the function NwGetNextNdsTreeEntry.
    It allocates a buffer (if needed) to cache NDS tree names returned from
    calls to the bindery. Since the bindery often returns duplicates of a
    NDS tree name, this function checks to see if the tree name already
    exist in the buffer before adding it to it if not present.

Arguments:

    ContextHandle - Used to track cached bindery information and the
                    current tree name pointer in the cache buffer.

Return Value:

    NO_ERROR - Successfully returned a NDS tree name and cache buffer.

    WN_NO_MORE_ENTRIES - No other NDS tree object past the one
        specified by CH->ResumeId.

    ERROR_NOT_ENOUGH_MEMORY - Function was unable to allocate a buffer.

++*/
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    SERVERNAME TreeName;
    LPWSTR UTreeName = NULL; //Unicode tree name
    DWORD tempDataId;
    WORD ObjectType;
    BYTE iter;
    BYTE tokenIter;
    LPWSTR tokenPtr;
    BOOL fAddToList;

    //
    // Check to see if we need to allocate a buffer for use
    //
    if ( ContextHandle->NdsRawDataBuffer == 0x00000000 )
    {
        ContextHandle->NdsRawDataId = (DWORD) ContextHandle->ResumeId;
        ContextHandle->NdsRawDataSize = EIGHT_KB;
        ContextHandle->NdsRawDataBuffer =
                    (DWORD_PTR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                ContextHandle->NdsRawDataSize );

        if ( ContextHandle->NdsRawDataBuffer == 0 )
        {
            KdPrint(("NWWORKSTATION: GetTreeEntriesFromBindery LocalAlloc failed %lu\n",
                     GetLastError()));

            ContextHandle->NdsRawDataSize = 0;
            ContextHandle->NdsRawDataId = (DWORD) -1;

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Repeatedly call bindery to fill buffer with NDS tree names until
    // buffer is full.
    //
    while ( ntstatus == STATUS_SUCCESS )
    {
        RtlZeroMemory( TreeName, sizeof( TreeName ) );

        tempDataId = ContextHandle->NdsRawDataId;

        ntstatus = NwlibMakeNcp(
                   ContextHandle->TreeConnectionHandle,
                   FSCTL_NWR_NCP_E3H,            // Bindery function
                   58,                           // Max request packet size
                   59,                           // Max response packet size
                   "bdwp|dwc",                   // Format string
                   0x37,                         // Scan bindery object
                   ContextHandle->NdsRawDataId,  // Previous ID
                   0x278,                        // Directory server object
                   "*",                          // Wildcard to match all
                   &ContextHandle->NdsRawDataId, // Current ID
                   &ObjectType,                  // Ignore
                   TreeName                      // Currently returned NDS tree
                   );

        //
        // We got a tree name, clean it up (i.e. get rid of underscores ),
        // and add it to buffer if unique.
        //
        if ( ntstatus == STATUS_SUCCESS )
        {
            iter = 31;

            while ( TreeName[iter] == '_' && iter > 0 )
            {
                iter--;
            }

            TreeName[iter + 1] = '\0';

            //
            // Convert tree name to a UNICODE string and proccess it,
            // else just skip it and move on to the next tree name.
            //
            if ( NwConvertToUnicode( &UTreeName, TreeName ) )
            {
               tokenPtr = (LPWSTR) ContextHandle->NdsRawDataBuffer;
               tokenIter = 0;
               fAddToList = TRUE;

               //
               // Walk through buffer to see if the tree name already exists.
               //
               while ( tokenIter < ContextHandle->NdsRawDataCount )
               {
                   if ( !wcscmp( tokenPtr, UTreeName ) )
                   {
                       fAddToList = FALSE;
                   }

                   tokenPtr = tokenPtr + wcslen( tokenPtr ) + 1;
                   tokenIter++;
               }

               //
               //  Add the new tree name to end of buffer if needed.
               //
               if ( fAddToList )
               {
                   DWORD BytesNeededToAddTreeName = (wcslen(UTreeName)+1) * sizeof(WCHAR);
                   DWORD NumberOfBytesAvailable =(DWORD) ( ContextHandle->NdsRawDataBuffer +
                                            ContextHandle->NdsRawDataSize -
                                            (DWORD_PTR) tokenPtr );

                   if ( BytesNeededToAddTreeName < NumberOfBytesAvailable )
                   {
                       wcscpy( tokenPtr, UTreeName );
                       ContextHandle->NdsRawDataCount += 1;
                   }
                   else
                   {
                       ContextHandle->NdsRawDataId = tempDataId;
                       ntstatus = ERROR_NOT_ENOUGH_MEMORY;
                   }
               }

               (void) LocalFree((HLOCAL) UTreeName);
            }
        }
    }

    //
    // We are done filling buffer, and there are no more tree names
    // to request. Set id to indicate last value.
    //
    if ( ntstatus == STATUS_NO_MORE_ENTRIES )
    {
        ContextHandle->NdsRawDataId = (DWORD) -1;
        ntstatus = STATUS_SUCCESS;
    }

    //
    // We are done because the buffer is full. So we return NO_ERROR to
    // indicate completion, and leave ContextHandle->NdsRawDataId as is
    // to indicate where we left off.
    //
    if ( ntstatus == ERROR_NOT_ENOUGH_MEMORY )
    {
        ntstatus = STATUS_SUCCESS;
    }

    if ( ContextHandle->NdsRawDataCount == 0 )
    {
        if ( ContextHandle->NdsRawDataBuffer )
            (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );

        ContextHandle->NdsRawDataBuffer = 0;
        ContextHandle->NdsRawDataSize = 0;
        ContextHandle->NdsRawDataId = (DWORD) -1;

        return WN_NO_MORE_ENTRIES;
    }

    if ( ContextHandle->NdsRawDataCount > 0 )
    {
        //
        // Set ResumeId to point to the first entry in buffer
        // and have NdsRawDataCount set to the number
        // of tree entries left in buffer (ie. substract 1)
        //
        ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer;
        ContextHandle->NdsRawDataCount -= 1;

        return NO_ERROR;
    }

    if ( ContextHandle->NdsRawDataBuffer )
        (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );

    ContextHandle->NdsRawDataBuffer = 0;
    ContextHandle->NdsRawDataSize = 0;
    ContextHandle->NdsRawDataId = (DWORD) -1;

    return NwMapStatus( ntstatus );
}


DWORD
NwGetNextNdsTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function uses an opened handle to the preferred server to
    scan it bindery for all NDS tree objects.

Arguments:

    ContextHandle - Receives the name of the returned NDS tree object
    given the current preferred server connection and CH->ResumeId.

Return Value:

    NO_ERROR - Successfully returned a NDS tree name.

    WN_NO_MORE_ENTRIES - No other NDS tree objects past the one
        specified by CH->ResumeId exist.

--*/
{
#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextNdsTreeEntry ResumeId %lu\n",
                 ContextHandle->ResumeId));
    }
#endif

    if ( ContextHandle->ResumeId == (DWORD_PTR) -1 &&
         ContextHandle->NdsRawDataBuffer == 0 &&
         ContextHandle->NdsRawDataCount == 0 )
    {
        //
        // Fill the buffer and point ResumeId to the last
        // tree entry name in it. NdsRawDataCount will be
        // set to one less than the number of tree names in buffer.
        //
        return GetTreeEntriesFromBindery( ContextHandle );
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount > 0 )
    {
        //
        // Move ResumeId to point to the next entry in the buffer
        // and decrement the NdsRawDataCount by one. Watch for case
        // where we backed up to -1.
        //
        if (ContextHandle->ResumeId == (DWORD_PTR) -1) {

            //
            // Reset to start of buffer.
            //
            ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer;
        }
        else {

            //
            // Move ResumeId to point to the next entry in the buffer
            // and decrement the NdsRawDataCount by one
            //
            ContextHandle->ResumeId =
                       ContextHandle->ResumeId +
                       ( ( wcslen( (LPWSTR) ContextHandle->ResumeId ) + 1 ) *
                       sizeof(WCHAR) );
        }

        ContextHandle->NdsRawDataCount -= 1;

        return NO_ERROR;
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount == 0 &&
         ContextHandle->NdsRawDataId != (DWORD) -1 )
    {
        //
        // We already have a buffer and processed all tree names
        // in it, and there is more data in the bindery to get.
        // So go get it and point ResumeId to the last tree
        // entry name in the buffer and set NdsRawDataCount to
        // one less than the number of tree names in buffer.
        //
        return GetTreeEntriesFromBindery( ContextHandle );
    }

    if ( ContextHandle->NdsRawDataBuffer != 0 &&
         ContextHandle->NdsRawDataCount == 0 &&
         ContextHandle->NdsRawDataId == (DWORD) -1 )
    {
        //
        // We already have a buffer and processed all tree names
        // in it, and there is no more data in the bindery to get.
        // So free the memory used for the buffer and return
        // WN_NO_MORE_ENTRIES to tell WinFile that we are done.
        //
        (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );

        ContextHandle->NdsRawDataBuffer = 0;
        ContextHandle->NdsRawDataSize = 0;

        return WN_NO_MORE_ENTRIES;
    }

    //
    // We should never hit this area!
    //
    return WN_NO_MORE_ENTRIES;
}


DWORD
NwGetNextVolumeEntry(
    IN HANDLE ServerConnection,
    IN DWORD NextVolumeNumber,
    OUT LPSTR VolumeName
    )
/*++

Routine Description:

    This function lists the volumes on the server specified by
    an opened tree connection handle to the server.

Arguments:

    ServerConnection - Supplies the tree connection handle to the
        server to enumerate volumes from.

    NextVolumeNumber - Supplies the volume number which to look
        up the name.

    VolumeName - Receives the name of the volume associated with
        NextVolumeNumber.

Return Value:

    NO_ERROR - Successfully gotten the volume name.

    WN_NO_MORE_ENTRIES - No other volume name associated with the
         specified volume number.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextVolumeEntry volume number %lu\n",
                 NextVolumeNumber));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   ServerConnection,
                   FSCTL_NWR_NCP_E2H,       // Directory function
                   4,                       // Max request packet size
                   19,                      // Max response packet size
                   "bb|p",                  // Format string
                   0x6,                     // Get volume name
                   (BYTE) NextVolumeNumber, // Previous ID
                   VolumeName               // Currently returned server
                   );

    return NwMapStatus(ntstatus);
}


DWORD
NwRdrLogonUser(
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN DWORD UserNameSize,
    IN LPWSTR Password OPTIONAL,
    IN DWORD PasswordSize,
    IN LPWSTR PreferredServer OPTIONAL,
    IN DWORD PreferredServerSize,
    IN LPWSTR NdsPreferredServer OPTIONAL,
    IN DWORD NdsPreferredServerSize,
    IN DWORD PrintOption
    )
/*++

Routine Description:

    This function tells the redirector the user logon credential.

Arguments:

    UserName - Supplies the user name.

    UserNameSize - Supplies the size in bytes of the user name string without
        the NULL terminator.

    Password - Supplies the password.

    PasswordSize - Supplies the size in bytes of the password string without
        the NULL terminator.

    PreferredServer - Supplies the preferred server name.

    PreferredServerSize - Supplies the size in bytes of the preferred server
        string without the NULL terminator.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;

    PNWR_REQUEST_PACKET Rrp;            // Redirector request packet

    DWORD RrpSize = sizeof(NWR_REQUEST_PACKET) +
                        UserNameSize +
                        PasswordSize +
                        PreferredServerSize;
    LPBYTE Dest;
    BYTE   lpReplicaAddress[sizeof(TDI_ADDRESS_IPX)];
    DWORD  ReplicaAddressSize = 0;


#if DBG
    IF_DEBUG(LOGON) {
        BYTE PW[128];


        RtlZeroMemory(PW, sizeof(PW));

        if (PasswordSize > (sizeof(PW) - 1)) {
            memcpy(PW, Password, sizeof(PW) - 1);
        }
        else {
            memcpy(PW, Password, PasswordSize);
        }

        KdPrint(("NWWORKSTATION: NwRdrLogonUser: UserName %ws\n", UserName));
        KdPrint(("                               Password %ws\n", PW));
        if ( PreferredServer )
            KdPrint(("                               Server   %ws\n", PreferredServer ));
    }
#endif

    if ( PreferredServer &&
         PreferredServer[0] == TREECHAR &&
         PreferredServer[1] )
    {
        WCHAR  TreeName[MAX_NDS_NAME_CHARS + 1];
        LPWSTR lpTemp;

        //
        // Find the nearest dir server for the tree that the user wants to
        // connect to.
        //
        // Citrix Terminal Server Merge
        // 12/09/96 cjc  PreferredServer also includes organizational units -
        //               not just the tree name so the size of it can be
        //               > MAX_NDS_TREE_NAME_LEN and when it is, the wcscpy
        //               below overwrites other stack data and causes errors
        //               during NW logins.

        if ( PreferredServerSize > (MAX_NDS_TREE_NAME_LEN*sizeof(WCHAR)) ) {
             memcpy(TreeName, PreferredServer+1, 
                    (MAX_NDS_TREE_NAME_LEN*sizeof(WCHAR)) );
             TreeName[MAX_NDS_TREE_NAME_LEN] = L'\0';
        }
        else {
            wcscpy( TreeName, PreferredServer + 1 );
        }

        lpTemp = wcschr( TreeName, L'\\' );
        if (lpTemp) {
            lpTemp[0] = L'\0';
        }

        if (NdsPreferredServerSize != 0) {

            KdPrint(("NWWORKSTATION: NdsPreferredServer: %ws\n", NdsPreferredServer));

            GetPreferredServerAddress( NdsPreferredServer/*L"red_41b"*/,
                                       &ReplicaAddressSize,
                                       lpReplicaAddress );
        } else {
            GetNearestDirServer( TreeName,
                                 &ReplicaAddressSize,
                                 lpReplicaAddress );
        }

        RrpSize += ReplicaAddressSize;
    }


    if ( PreferredServer &&
         PreferredServer[0] == TREECHAR &&
         !PreferredServer[1] )
    {
        PreferredServerSize = 0;
    }

    //
    // Allocate the request packet
    //
    if ((Rrp = (PVOID) LocalAlloc(
                           LMEM_ZEROINIT,
                           RrpSize
                           )) == NULL) {

        KdPrint(("NWWORKSTATION: NwRdrLogonUser LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Tell the redirector the user logon credential.
    //
    Rrp->Version = REQUEST_PACKET_VERSION;

    RtlCopyLuid(&(Rrp->Parameters.Logon.LogonId), LogonId);

#if DBG
    IF_DEBUG(LOGON) {
        KdPrint(("NWWORKSTATION: NwRdrLogonUser passing to Rdr logon ID %lu %lu\n",
                 *LogonId, *((PULONG) ((DWORD_PTR) LogonId + sizeof(ULONG)))));
    }
#endif

    Rrp->Parameters.Logon.UserNameLength = UserNameSize;
    Rrp->Parameters.Logon.PasswordLength = PasswordSize;
    Rrp->Parameters.Logon.ServerNameLength = PreferredServerSize;
    Rrp->Parameters.Logon.ReplicaAddrLength = ReplicaAddressSize;
    Rrp->Parameters.Logon.PrintOption = PrintOption;

    memcpy(Rrp->Parameters.Logon.UserName, UserName, UserNameSize);
    Dest = (LPBYTE) ((DWORD_PTR) Rrp->Parameters.Logon.UserName + UserNameSize);

    if (PasswordSize > 0)
    {
        memcpy(Dest, Password, PasswordSize);
        Dest = (LPBYTE) ((DWORD_PTR) Dest + PasswordSize);
    }

    if (PreferredServerSize > 0)
    {
        memcpy(Dest, PreferredServer, PreferredServerSize);

        if (ReplicaAddressSize > 0)
        {
            Dest = (LPBYTE) ((DWORD_PTR) Dest + PreferredServerSize);
            memcpy(Dest, lpReplicaAddress, ReplicaAddressSize);
        }
    }

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_LOGON,
                 Rrp,
                 RrpSize,
                 NULL,              // No logon script in this release
                 0,
                 NULL
                 );

    RtlZeroMemory(Rrp, RrpSize);   // Clear the password
    (void) LocalFree((HLOCAL) Rrp);

    return status;
}


VOID
NwRdrChangePassword(
    IN PNWR_REQUEST_PACKET Rrp
    )
/*++

Routine Description:

    This function tells the redirector the new password for a user on
    a particular server.

Arguments:

    Rrp - Supplies the username, new password and servername.

    RrpSize - Supplies the size of the request packet.

Return Value:

    None.

--*/
{

    //
    // Tell the redirector the user new password.
    //
    Rrp->Version = REQUEST_PACKET_VERSION;

    (void) NwRedirFsControl(
               RedirDeviceHandle,
               FSCTL_NWR_CHANGE_PASS,
               Rrp,
               sizeof(NWR_REQUEST_PACKET) +
                   Rrp->Parameters.ChangePass.UserNameLength +
                   Rrp->Parameters.ChangePass.PasswordLength +
                   Rrp->Parameters.ChangePass.ServerNameLength,
               NULL,
               0,
               NULL
               );

}


DWORD
NwRdrSetInfo(
    IN DWORD PrintOption,
    IN DWORD PacketBurstSize,
    IN LPWSTR PreferredServer OPTIONAL,
    IN DWORD PreferredServerSize,
    IN LPWSTR ProviderName OPTIONAL,
    IN DWORD ProviderNameSize
    )
/*++

Routine Description:

    This function passes some workstation configuration and current user's
    preference to the redirector. This includes the network provider name, the
    packet burst size, the user's selected preferred server and print option.

Arguments:

    PrintOption  - The current user's print option

    PacketBurstSize - The packet burst size stored in the registry

    PreferredServer - The preferred server the current user selected
    PreferredServerSize - Supplies the size in bytes of the preferred server
                   string without the NULL terminator.

    ProviderName - Supplies the provider name.
    ProviderNameSize - Supplies the size in bytes of the provider name
                   string without the NULL terminator.


Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;

    PNWR_REQUEST_PACKET Rrp;            // Redirector request packet

    DWORD RrpSize = sizeof(NWR_REQUEST_PACKET) +
                        PreferredServerSize +
                        ProviderNameSize;

    LPBYTE Dest;
    BOOL Impersonate = FALSE;

    //
    // Allocate the request packet
    //
    if ((Rrp = (PVOID) LocalAlloc(
                           LMEM_ZEROINIT,
                           RrpSize
                           )) == NULL) {

        KdPrint(("NWWORKSTATION: NwRdrSetInfo LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Rrp->Version = REQUEST_PACKET_VERSION;

    Rrp->Parameters.SetInfo.PrintOption = PrintOption;
    Rrp->Parameters.SetInfo.MaximumBurstSize = PacketBurstSize;

    Rrp->Parameters.SetInfo.PreferredServerLength = PreferredServerSize;
    Rrp->Parameters.SetInfo.ProviderNameLength  = ProviderNameSize;

    if (ProviderNameSize > 0) {
        memcpy( Rrp->Parameters.SetInfo.PreferredServer,
                PreferredServer, PreferredServerSize);
    }

    Dest = (LPBYTE) ((DWORD_PTR) Rrp->Parameters.SetInfo.PreferredServer
                     + PreferredServerSize);

    if (ProviderNameSize > 0) {
        memcpy(Dest, ProviderName, ProviderNameSize);
    }

    /* --- Multi-user change
     *   For print options
     *   It's OK if it doesn't work
     */
    if ((status = NwImpersonateClient()) == NO_ERROR)
    {
        Impersonate = TRUE;
    }

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_SET_INFO,
                 Rrp,
                 RrpSize,
                 NULL,
                 0,
                 NULL
                 );

    if ( Impersonate ) {
        (void) NwRevertToSelf() ;
    }

    (void) LocalFree((HLOCAL) Rrp);


    if ( status != NO_ERROR )
    {
        KdPrint(("NwRedirFsControl: FSCTL_NWR_SET_INFO failed with %d\n",
                status ));
    }

    return status;
}


DWORD
NwRdrLogoffUser(
    IN PLUID LogonId
    )
/*++

Routine Description:

    This function asks the redirector to log off the interactive user.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    NWR_REQUEST_PACKET Rrp;            // Redirector request packet


    //
    // Tell the redirector to logoff user.
    //
    Rrp.Version = REQUEST_PACKET_VERSION;

    RtlCopyLuid(&Rrp.Parameters.Logoff.LogonId, LogonId);

    status = NwRedirFsControl(
                 RedirDeviceHandle,
                 FSCTL_NWR_LOGOFF,
                 &Rrp,
                 sizeof(NWR_REQUEST_PACKET),
                 NULL,
                 0,
                 NULL
                 );

    return status;
}


DWORD
NwConnectToServer(
    IN LPWSTR ServerName
    )
/*++

Routine Description:

    This function opens a handle to \Device\Nwrdr\ServerName, given
    ServerName, and then closes the handle if the open was successful.
    It is to validate that the current user credential can access
    the server.

Arguments:

    ServerName - Supplies the name of the server to validate the
        user credential.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    UNICODE_STRING ServerStr;
    HANDLE ServerHandle;



    ServerStr.MaximumLength = (wcslen(ServerName) + 2) *
                                  sizeof(WCHAR) +          // \ServerName0
                                  RedirDeviceName.Length;  // \Device\Nwrdr

    if ((ServerStr.Buffer = (PWSTR) LocalAlloc(
                                        LMEM_ZEROINIT,
                                        (UINT) ServerStr.MaximumLength
                                        )) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy \Device\NwRdr
    //
    RtlCopyUnicodeString(&ServerStr, &RedirDeviceName);

    //
    // Concatenate \ServerName
    //
    wcscat(ServerStr.Buffer, L"\\");
    ServerStr.Length += sizeof(WCHAR);

    wcscat(ServerStr.Buffer, ServerName);
    ServerStr.Length += (USHORT) (wcslen(ServerName) * sizeof(WCHAR));


    status = NwOpenCreateConnection(
                 &ServerStr,
                 NULL,
                 NULL,
                 ServerName,
                 SYNCHRONIZE | FILE_WRITE_DATA,
                 FILE_OPEN,
                 FILE_SYNCHRONOUS_IO_NONALERT,
                 RESOURCETYPE_DISK,
                 &ServerHandle,
                 NULL
                 );

    if (status == ERROR_FILE_NOT_FOUND) {
        status = ERROR_BAD_NETPATH;
    }

    (void) LocalFree((HLOCAL) ServerStr.Buffer);

    if (status == NO_ERROR || status == NW_PASSWORD_HAS_EXPIRED) {
        (void) NtClose(ServerHandle);
    }

    return status;
}

DWORD
NWPGetConnectionStatus(
    IN     LPWSTR  pszRemoteName,
    IN OUT PDWORD_PTR  ResumeKey,
    OUT    LPBYTE  Buffer,
    IN     DWORD   BufferSize,
    OUT    PDWORD  BytesNeeded,
    OUT    PDWORD  EntriesRead
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    uRdrName;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";

    PNWR_REQUEST_PACKET RequestPacket = NULL;
    DWORD             RequestPacketSize = 0;
    DWORD             dwRemoteNameLen = 0;

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    dwRemoteNameLen = pszRemoteName? wcslen(pszRemoteName)*sizeof(WCHAR) : 0;

    RequestPacketSize = sizeof( NWR_REQUEST_PACKET ) + dwRemoteNameLen;

    RequestPacket = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT,
                                                      RequestPacketSize );

    if ( RequestPacket == NULL )
    {
        ntstatus = STATUS_NO_MEMORY;
        goto CleanExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_STATUS.
    //

    RequestPacket->Parameters.GetConnStatus.ResumeKey = *ResumeKey;

    RequestPacket->Version = REQUEST_PACKET_VERSION;
    RequestPacket->Parameters.GetConnStatus.ConnectionNameLength = dwRemoteNameLen;

    RtlCopyMemory( &(RequestPacket->Parameters.GetConnStatus.ConnectionName[0]),
                   pszRemoteName,
                   dwRemoteNameLen );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_STATUS,
                                (PVOID) RequestPacket,
                                RequestPacketSize,
                                (PVOID) Buffer,
                                BufferSize );

    if ( NT_SUCCESS( ntstatus ))
        ntstatus = IoStatusBlock.Status;

    *EntriesRead = RequestPacket->Parameters.GetConnStatus.EntriesReturned;
    *ResumeKey   = RequestPacket->Parameters.GetConnStatus.ResumeKey;
    *BytesNeeded = RequestPacket->Parameters.GetConnStatus.BytesNeeded;

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    if ( RequestPacket != NULL )
        LocalFree( RequestPacket );

    return RtlNtStatusToDosError( ntstatus );
}

DWORD
NwGetConnectionStatus(
    IN  LPWSTR  pszRemoteName,
    OUT PDWORD_PTR  ResumeKey,
    OUT LPBYTE  *Buffer,
    OUT PDWORD  EntriesRead
)
{
    DWORD err = NO_ERROR;
    DWORD dwBytesNeeded = 0;
    DWORD dwBufferSize  = TWO_KB;

    *Buffer = NULL;
    *EntriesRead = 0;

    do {

        *Buffer = (LPBYTE) LocalAlloc( LMEM_ZEROINIT, dwBufferSize );

        if ( *Buffer == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        err = NWPGetConnectionStatus( pszRemoteName,
                                      ResumeKey,
                                      *Buffer,
                                      dwBufferSize,
                                      &dwBytesNeeded,
                                      EntriesRead );

        if ( err == ERROR_INSUFFICIENT_BUFFER )
        {
            dwBufferSize = dwBytesNeeded + EXTRA_BYTES;
            LocalFree( *Buffer );
            *Buffer = NULL;
        }

    } while ( err == ERROR_INSUFFICIENT_BUFFER );

    if ( err == ERROR_INVALID_PARAMETER )  // not attached
    {
        err = NO_ERROR;
        *EntriesRead = 0;
    }

    return err;
}

VOID
GetNearestDirServer(
    IN  LPWSTR  TreeName,
    OUT LPDWORD lpdwReplicaAddressSize,
    OUT LPBYTE  lpReplicaAddress
    )
{
    WCHAR Buffer[BUFFSIZE];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE hRnr;
    DWORD dwQuerySize = BUFFSIZE;
    GUID gdService = SVCID_NETWARE(0x278);
    WSADATA wsaData;
    WCHAR  ServiceInstanceName[] = L"*";

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    memset(Query, 0, sizeof(*Query));

    //
    // putting a "*" in the lpszServiceInstanceName causes
    // the query to look for all server instances. Putting a
    // specific name in here will search only for instance of
    // that name. If you have a specific name to look for,
    // put a pointer to the name here.
    //
    Query->lpszServiceInstanceName = ServiceInstanceName;
    Query->dwNameSpace = NS_SAP;
    Query->dwSize = sizeof(*Query);
    Query->lpServiceClassId = &gdService;

    //
    // Find the servers. The flags indicate:
    // LUP_NEAREST: look for nearest servers
    // LUP_DEEP : if none are found on the local segement look
    //            for server using a general query
    // LUP_RETURN_NAME: return the name
    // LUP_RETURN_ADDR: return the server address
    //
    // if only servers on the local segment are acceptable, omit
    // setting LUP_DEEP
    //
    if( WSALookupServiceBegin( Query,
                               LUP_NEAREST |
                               LUP_DEEP |
                               LUP_RETURN_NAME |
                               LUP_RETURN_ADDR,
                               &hRnr ) == SOCKET_ERROR )
    {
        //
        // Something went wrong, return no address. The redirector will
        // have to come up with a dir server on its own.
        //
        *lpdwReplicaAddressSize = 0;
        return ;
    }
    else
    {
        //
        // Ready to look for one of them ...
        //
        Query->dwSize = BUFFSIZE;

        while( WSALookupServiceNext( hRnr,
                                     0,
                                     &dwQuerySize,
                                     Query ) == NO_ERROR )
        {
            //
            // Found a dir server, now see if it is a server for the NDS tree
            // TreeName.
            //
            if ( NwpCompareTreeNames( Query->lpszServiceInstanceName,
                                      TreeName ) )
            {
                *lpdwReplicaAddressSize = sizeof(TDI_ADDRESS_IPX);
                memcpy( lpReplicaAddress,
                        Query->lpcsaBuffer->RemoteAddr.lpSockaddr->sa_data,
                        sizeof(TDI_ADDRESS_IPX) );

                WSALookupServiceEnd(hRnr);
                return ;
            }
        }

        //
        // Could not find a dir server, return no address. The redirector will
        // have to come up with a dir server on its own.
        //
        *lpdwReplicaAddressSize = 0;
        WSALookupServiceEnd(hRnr);
    }
}

BOOL
NwpCompareTreeNames(
    LPWSTR lpServiceInstanceName,
    LPWSTR lpTreeName
    )
{
    DWORD  iter = 31;

    while ( lpServiceInstanceName[iter] == '_' && iter > 0 )
    {
        iter--;
    }

    lpServiceInstanceName[iter + 1] = '\0';

    if ( !_wcsicmp( lpServiceInstanceName, lpTreeName ) )
    {
        return TRUE;
    }

    return FALSE;
}


#define SIZE_OF_STATISTICS_TOKEN_INFORMATION    \
     sizeof( TOKEN_STATISTICS ) 

VOID
GetLuid(
    IN OUT PLUID plogonid
)
/*++

Routine Description:

    Returns an LUID

Arguments:

    none

Return Value:

    LUID

--*/
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_STATISTICS_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    LUID        NullId = { 0, 0 };


    // We can use OpenThreadToken because this server thread
    // is impersonating a client

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_READ,
                           TRUE,  /* Open as self */
                           &TokenHandle ))
    {
#if DBG
        KdPrint(("GetLuid: OpenThreadToken failed: Error %d\n",
                      GetLastError()));
#endif
        *plogonid = NullId;
        return;
    }

    // notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure


    if ( !GetTokenInformation( TokenHandle,
                               TokenStatistics,
                               TokenInformation,
                               sizeof( TokenInformation ),
                               &ReturnLength ))
    {
#if DBG
        KdPrint(("GetLuid: GetTokenInformation failed: Error %d\n",
                      GetLastError()));
#endif
        *plogonid = NullId;
        return;
    }

    CloseHandle( TokenHandle );

    *plogonid = ( ((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId );
    return;
}

DWORD
NwCloseAllConnections(
    VOID
    )
/*++

Routine Description:

    This routine closes all connections.  It is used when stopping the
    redirector.

Arguments:

    None.

Return Value:

    NO_ERROR or error

--*/
{
    NWR_REQUEST_PACKET Rrp;
    DWORD error;


    Rrp.Version = REQUEST_PACKET_VERSION;

    error = NwRedirFsControl(
                RedirDeviceHandle,
                FSCTL_NWR_CLOSEALL,
                &Rrp,
                sizeof(NWR_REQUEST_PACKET),
                NULL,
                0,
                NULL
                );

    return error;
}



VOID
GetPreferredServerAddress(
    IN  LPWSTR  PreferredServerName,
    OUT LPDWORD lpdwReplicaAddressSize,
    OUT LPBYTE  lpReplicaAddress
    )
{
    WCHAR Buffer[1024];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE hRnr;
    DWORD dwQuerySize = 1024;
    GUID gdService = SVCID_NETWARE( 0x4 );
    WSADATA wsaData;
    PWCHAR  ServiceInstanceName = PreferredServerName;

    WSAStartup(MAKEWORD(1, 1), &wsaData);

    memset(Query, 0, sizeof(*Query));

    //
    // putting a "*" in the lpszServiceInstanceName causes
    // the query to look for all server instances. Putting a
    // specific name in here will search only for instance of
    // that name. If you have a specific name to look for,
    // put a pointer to the name here.
    //
    Query->lpszServiceInstanceName = ServiceInstanceName;
    Query->dwNameSpace = NS_SAP;
    Query->dwSize = sizeof(*Query);
    Query->lpServiceClassId = &gdService;

    //
    // Find the servers. The flags indicate:
    // LUP_NEAREST: look for nearest servers
    // LUP_DEEP : if none are found on the local segement look
    //            for server using a general query
    // LUP_RETURN_NAME: return the name
    // LUP_RETURN_ADDR: return the server address
    //
    // if only servers on the local segment are acceptable, omit
    // setting LUP_DEEP
    //
    if( WSALookupServiceBeginW( Query,
                            // LUP_NEAREST |
                               LUP_DEEP |
                               LUP_RETURN_NAME |
                               LUP_RETURN_ADDR,
                               &hRnr ) == SOCKET_ERROR )
    {
        //
        // Something went wrong, return no address. The redirector will
        // have to come up with a dir server on its own.
        //
        *lpdwReplicaAddressSize = 0;
        return ;
    }
    else
    {
        //
        // Ready to look for one of them ...
        //
        Query->dwSize = 1024;

        while( WSALookupServiceNextW( hRnr,
                                     0,
                                     &dwQuerySize,
                                     Query ) == NO_ERROR )
        {
            //
            // Found a dir server, now see if it is a server for the NDS tree
            // TreeName.
            //
        //    if ( NwpCompareTreeNames( Query->lpszServiceInstanceName,
        //    TreeName ) )
            {
                *lpdwReplicaAddressSize = sizeof(TDI_ADDRESS_IPX);
                memcpy( lpReplicaAddress,
                        Query->lpcsaBuffer->RemoteAddr.lpSockaddr->sa_data,
                        sizeof(TDI_ADDRESS_IPX) );

                WSALookupServiceEnd(hRnr);
                return ;
            }
        }

        //
        // Could not find a dir server, return no address. The redirector will
        // have to come up with a dir server on its own.
        //
        *lpdwReplicaAddressSize = 0;
        WSALookupServiceEnd(hRnr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\enum.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module contains server, volume, and directory enumeration
    routines supported by NetWare Workstation service.

Author:

    Rita Wong  (ritaw)   15-Feb-1993

Revision History:

--*/

#include <stdlib.h>
#include <nw.h>
#include <splutil.h>
#include <nwmisc.h>
#include <nwreg.h>
#include <nds.h>
#include <nwapi32.h>


VOID
GetLuid(
    IN OUT PLUID plogonid
);

//-------------------------------------------------------------------//
//                                                                   //
// Definitions                                                       //
//                                                                   //
//-------------------------------------------------------------------//

//
// Other definitions
//
#define   ONE_KB 1024
#define   TWO_KB 2048
#define  FOUR_KB 4096
#define EIGHT_KB 8192

#define TREECHAR             L'*'

#define NW_VOLUME_NAME_LEN   256
#define NW_MAX_VOLUME_NUMBER  64

//
// This structure is orginally defined in nwapi32.c, it is redefined
// here so that the routine NWGetFileServerVersionInfo() can be called
// with it.
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO ;

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwrOpenEnumServersCommon(
    IN  NW_ENUM_TYPE EnumType,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    );

DWORD
NwrOpenEnumCommon(
    IN LPWSTR ContainerName,
    IN NW_ENUM_TYPE EnumType,
    IN DWORD_PTR StartingPoint,
    IN BOOL ValidateUserFlag,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    );

DWORD
NwEnumContextInfo(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumServersAndNdsTrees(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumPrintServers(
    IN  LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN  DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumVolumes(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumNdsSubTrees_Disk(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumNdsSubTrees_Print(
    IN  LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN  DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumNdsSubTrees_Any(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumVolumesQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumDirectories(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwEnumPrintQueues(
    IN  LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN  DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    );

DWORD
NwGetFirstDirectoryEntry(
    IN HANDLE DirHandle,
    OUT LPWSTR *DirEntry
    );

DWORD
NwGetNextDirectoryEntry(
    IN HANDLE DirHandle,
    OUT LPWSTR *DirEntry
    );

DWORD
NwGetFirstNdsSubTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD BufferSize
    );

DWORD
NwGetNextNdsSubTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

BYTE
NwGetSubTreeData(
    IN  DWORD_PTR NdsRawDataPtr,
    OUT LPWSTR *  SubTreeName,
    OUT LPDWORD   ResourceScope,
    OUT LPDWORD   ResourceType,
    OUT LPDWORD   ResourceDisplayType,
    OUT LPDWORD   ResourceUsage,
    OUT LPWSTR  * StrippedObjectName
    );

VOID
NwStripNdsUncName(
    IN  LPWSTR   ObjectName,
    OUT LPWSTR * StrippedObjectName
    );

#define VERIFY_ERROR_NOT_A_NDS_TREE     0x1010FFF0
#define VERIFY_ERROR_PATH_NOT_FOUND     0x1010FFF1

DWORD
NwVerifyNDSObject(
    IN  LPWSTR   lpNDSObjectNamePath,
    OUT LPWSTR * lpFullNDSObjectNamePath,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    );

DWORD
NwVerifyBinderyObject(
    IN  LPWSTR   lpBinderyObjectNamePath,
    OUT LPWSTR * lpFullBinderyObjectNamePath,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    );

DWORD
NwGetNDSPathInfo(
    IN  LPWSTR   lpNDSObjectNamePath,
    OUT LPWSTR * lpSystemObjectNamePath,
    OUT LPWSTR * lpSystemPathPart,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    );

DWORD
NwGetBinderyPathInfo(
    IN  LPWSTR   lpBinderyObjectNamePath,
    OUT LPWSTR * lpSystemObjectNamePath,
    OUT LPWSTR * lpSystemPathPart,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    );

BOOL
NwGetRemoteNameParent(
    IN  LPWSTR   lpRemoteName,
    OUT LPWSTR * lpRemoteNameParent
    );

int __cdecl
SortFunc(
    IN CONST VOID *p1,
    IN CONST VOID *p2
    );

DWORD
NwGetConnectionInformation(
    IN  LPWSTR lpName,
    OUT LPWSTR lpUserName,
    OUT LPWSTR lpHostServer
    );


VOID
NwpGetUncInfo(
    IN LPWSTR lpstrUnc,
    OUT WORD * slashCount,
    OUT BOOL * isNdsUnc,
    OUT LPWSTR * FourthSlash
    );

DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    );

DWORD
NwQueryInfo(
    OUT LPWSTR *ppszPreferredSrv
    );


DWORD
NwrOpenEnumContextInfo(
    IN  LPWSTR Reserved OPTIONAL,
    IN  DWORD  ConnectionType,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating context information (i.e. NDS user context objects
    and/or NetWare bindery server connections).

Arguments:

    Reserved - Unused.

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/
{
    LPWSTR pszCurrentContext = NULL;
    DWORD  dwPrintOptions;
    DWORD  status = NwQueryInfo( &pszCurrentContext );
    WCHAR  Context[MAX_NDS_NAME_CHARS];
    LPNW_ENUM_CONTEXT ContextHandle;

    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(ConnectionType);


#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumContextInfo\n"));
    }
#endif

    if ( pszCurrentContext &&
         status == NO_ERROR )
    {
        if ( pszCurrentContext[0] == TREECHAR )
        {
            wcscpy( Context, L"\\\\" );
            wcscat( Context, pszCurrentContext + 1 );

            LocalFree( pszCurrentContext );
            pszCurrentContext = NULL;

            return NwrOpenEnumCommon(
                       Context,
                       NwsHandleListContextInfo_Tree,
                       (DWORD_PTR) -1,
                       FALSE,
                       NULL,
                       NULL,
                       0,
                       0,
                       NULL,
                       EnumHandle
                       );
        }
        else
        {
            //
            // The user does not have a preferred NDS tree and context. They
            // may have only a preferred server.
            //
            if ( pszCurrentContext[0] != 0 )
            {
                //
                // There is a prefered server.
                //
                LocalFree( pszCurrentContext );
                pszCurrentContext = NULL;

                ContextHandle = (PVOID) LocalAlloc(
                                            LMEM_ZEROINIT,
                                            sizeof(NW_ENUM_CONTEXT)
                                            );

                if (ContextHandle == NULL)
                {
                    KdPrint(("NWWORKSTATION: NwrOpenEnumContextInfo LocalAlloc Failed %lu\n", GetLastError()));
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                //
                // Initialize contents of the context handle structure.
                //
                ContextHandle->Signature = NW_HANDLE_SIGNATURE;
                ContextHandle->HandleType = NwsHandleListContextInfo_Server;
                ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
                ContextHandle->ResumeId = (DWORD_PTR) -1;

                // The following are set to zero due to the LMEM_ZEROINIT.
                // ContextHandle->NdsRawDataBuffer = 0;
                // ContextHandle->NdsRawDataSize = 0;
                // ContextHandle->NdsRawDataId = 0;
                // ContextHandle->NdsRawDataCount = 0;
                // ContextHandle->TreeConnectionHandle = 0;
                // ContextHandle->ConnectionType = 0;

                //
                // Return the newly created context.
                //
                *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

                return NO_ERROR;
            }
        }
    }

    //
    // There is no information in the registry about the current user.
    // We go ahead and make an enumeration handle and return success.
    // Later, during a call to NPEnumResource, we will return zero items.
    // This is done because there is no valid return code to tell the
    // callee that we have no context information to provide.
    //
    ContextHandle = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                        sizeof(NW_ENUM_CONTEXT) );

    if (ContextHandle == NULL)
    {
        KdPrint(("NWWORKSTATION: NwrOpenEnumContextInfo LocalAlloc Failed %lu\n", GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure.
    //
    ContextHandle->Signature = NW_HANDLE_SIGNATURE;
    ContextHandle->HandleType = NwsHandleListContextInfo_Server;
    ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
    ContextHandle->ResumeId = 0; // This will tell NwrEnum to
                                 // give up (i.e. we are done).

    // The following are set to zero due to the LMEM_ZEROINIT.
    // ContextHandle->NdsRawDataBuffer = 0;
    // ContextHandle->NdsRawDataSize = 0;
    // ContextHandle->NdsRawDataId = 0;
    // ContextHandle->NdsRawDataCount = 0;
    // ContextHandle->TreeConnectionHandle = 0;
    // ContextHandle->ConnectionType = 0;

    //
    // Return the newly created context.
    //
    *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

    return NO_ERROR;
}



DWORD
NwrOpenEnumServersAndNdsTrees(
    IN LPWSTR Reserved OPTIONAL,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating the servers and NDS trees on the network.

Arguments:

    Reserved - Unused.

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/ // NwrOpenEnumServersAndNdsTrees
{
    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint( ("\nNWWORKSTATION: NwrOpenEnumServersAndNdsTrees\n") );
    }
#endif

    return NwrOpenEnumServersCommon(
               NwsHandleListServersAndNdsTrees,
               EnumHandle
               );
}



DWORD
NwOpenEnumPrintServers(
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating the print servers on the network.

Arguments:

    Reserved   - Unused.
    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/ // NwOpenEnumPrintServers
{

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint( ("\nNWWORKSTATION: NwOpenEnumPrintServers\n") );
    }
#endif

    return NwrOpenEnumServersCommon(
               NwsHandleListPrintServers,
               EnumHandle
               );
}


DWORD
NwrOpenEnumVolumes(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the volumes on a server.

Arguments:

    Reserved - Unused.

    ServerName - Supplies the name of the server to enumerate volumes.
        This name is prefixed by \\.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumVolumes
{
    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumVolumes %ws\n",
                 ServerName));
    }
#endif

    return NwrOpenEnumCommon(
               ServerName,
               NwsHandleListVolumes,
               0,
               FALSE,
               NULL,
               NULL,
               FILE_OPEN,
               FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );
}


DWORD
NwrOpenEnumNdsSubTrees_Disk(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ParentPathName,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the DISK object types
    and containers of a sub-tree in a NDS tree.

Arguments:

    Reserved - Unused.

    ParentPathName - Supplies the name of the tree and the path to a container
    to enumerate sub-trees.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumNdsSubTrees_Disk
{

    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumNdsSubTrees_Disk %ws\n",
                 ParentPathName));
    }
#endif

    return NwrOpenEnumCommon(
               ParentPathName,
               NwsHandleListNdsSubTrees_Disk,
               0,
               FALSE,
               NULL,
               NULL,
               0,
               0,
               ClassTypeOfNDSLeaf,
               EnumHandle
               );
}


DWORD
NwrOpenEnumNdsSubTrees_Print(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ParentPathName,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the PRINT object types
    and containers of a sub-tree in a NDS tree.

Arguments:

    Reserved - Unused.

    ParentPathName - Supplies the name of the tree and the path to a container
    to enumerate sub-trees.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumNdsSubTrees_Print
{
#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumNdsSubTrees_Print %ws\n",
                 ParentPathName));
    }
#endif

    return NwrOpenEnumCommon(
               ParentPathName,
               NwsHandleListNdsSubTrees_Print,
               0,
               FALSE,
               NULL,
               NULL,
               0,
               0,
               ClassTypeOfNDSLeaf,
               EnumHandle
               );
}


DWORD
NwrOpenEnumNdsSubTrees_Any(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ParentPathName,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the ANY object types
    and containers of a sub-tree in a NDS tree.

Arguments:

    Reserved - Unused.

    ParentPathName - Supplies the name of the tree and the path to a container
    to enumerate sub-trees.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumNdsSubTrees_Any
{

    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumNdsSubTrees_Any %ws\n",
                 ParentPathName));
    }
#endif

    return NwrOpenEnumCommon(
               ParentPathName,
               NwsHandleListNdsSubTrees_Any,
               0,
               FALSE,
               NULL,
               NULL,
               0,
               0,
               ClassTypeOfNDSLeaf,
               EnumHandle
               );
}


DWORD
NwrOpenEnumQueues(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the volumes on a server.

Arguments:

    Reserved - Unused.

    ServerName - Supplies the name of the server to enumerate volumes.
        This name is prefixed by \\.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumQueues
{

    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumQueues %ws\n",
                 ServerName));
    }
#endif

    return NwrOpenEnumCommon(
               ServerName,
               NwsHandleListQueues,
               (DWORD_PTR) -1,
               TRUE,
               NULL,
               NULL,
               FILE_OPEN,
               FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );
}


DWORD
NwrOpenEnumVolumesQueues(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the volumes/queues on a server.

Arguments:

    Reserved - Unused.

    ServerName - Supplies the name of the server to enumerate volumes.
        This name is prefixed by \\.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwrOpenEnumVolumesQueues
{

    DWORD status;
    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumVolumesQueues %ws\n",
                 ServerName));
    }
#endif

    status = NwrOpenEnumCommon(
               ServerName,
               NwsHandleListVolumesQueues,
               0,
               FALSE,
               NULL,
               NULL,
               FILE_OPEN,
               FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );

    if ( status == NO_ERROR )
        ((LPNW_ENUM_CONTEXT) *EnumHandle)->ConnectionType = CONNTYPE_DISK;

    return status;
}


DWORD
NwrOpenEnumDirectories(
    IN LPWSTR Reserved OPTIONAL,
    IN LPWSTR ParentPathName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the volumes on a server.

Arguments:

    Reserved - Unused.

    ParentPathName - Supplies the parent path name in the format of
        \\Server\Volume.

    UserName - Supplies the username to connect with.

    Password - Supplies the password to connect with.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ //NwrOpenEnumDirectories
{
    UNREFERENCED_PARAMETER(Reserved);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwrOpenEnumDirectories %ws\n",
                 ParentPathName));
    }
#endif

    return NwrOpenEnumCommon(
               ParentPathName,
               NwsHandleListDirectories,
               0,
               FALSE,
               UserName,
               Password,
               FILE_CREATE,
               FILE_CREATE_TREE_CONNECTION |
                   FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );
}


DWORD
NwOpenEnumPrintQueues(
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function calls a common routine which creates a new context
    handle and initializes it for enumerating the print queues on a server.

Arguments:

    Reserved - Unused.

    ServerName - Supplies the name of the server to enumerate volumes.
        This name is prefixed by \\.

    EnumHandle - Receives the newly created context handle.

Return Value:

    NO_ERROR or reason for failure.

--*/ // NwOpenEnumPrintQueues
{

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("\nNWWORKSTATION: NwOpenEnumPrintQueues %ws\n",
                 ServerName));
    }
#endif

    return NwrOpenEnumCommon(
               ServerName,
               NwsHandleListPrintQueues,
               (DWORD_PTR) -1,
               TRUE,
               NULL,
               NULL,
               FILE_OPEN,
               FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               EnumHandle
               );
}


DWORD
NwrOpenEnumServersCommon(
    IN  NW_ENUM_TYPE EnumType,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function creates a new context handle and initializes it
    for enumerating the servers on the network.

Arguments:

    EnumType   - Supplies the type of the object we want to enumerate

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

--*/ // NwrOpenEnumServersCommon
{
    DWORD status = NO_ERROR;
    LPNW_ENUM_CONTEXT ContextHandle = NULL;

    //
    // Allocate memory for the context handle structure.
    //
    ContextHandle = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                sizeof(NW_ENUM_CONTEXT)
                                );

    if (ContextHandle == NULL) {
        KdPrint((
            "NWWORKSTATION: NwrOpenEnumServersCommon LocalAlloc Failed %lu\n",
            GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure.
    //
    ContextHandle->Signature = NW_HANDLE_SIGNATURE;
    ContextHandle->HandleType = EnumType;
    ContextHandle->ResumeId = (DWORD_PTR) -1;
    ContextHandle->NdsRawDataBuffer = 0x00000000;
    ContextHandle->NdsRawDataSize = 0x00000000;
    ContextHandle->NdsRawDataId = 0x00000000;
    ContextHandle->NdsRawDataCount = 0x00000000;

    //
    // Set flag to indicate that we are going to enumerate NDS trees first.
    //
    ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NDS;

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto CleanExit;
    }

    //
    // We enum servers and nds trees from the preferred server.
    //
    status = NwOpenPreferredServer(
                 &ContextHandle->TreeConnectionHandle
                 );

    (void) NwRevertToSelf() ;

    if (status == NO_ERROR)
    {
        //
        // Return the newly created context.
        //
        *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

        return status;
    }

CleanExit:
    if ( ContextHandle )
    {
        ContextHandle->Signature = 0x0BADBAD0;

        (void) LocalFree((HLOCAL) ContextHandle);
    }

    return status;
}


DWORD
NwrOpenEnumCommon(
    IN LPWSTR ContainerName,
    IN NW_ENUM_TYPE EnumType,
    IN DWORD_PTR StartingPoint,
    IN BOOL  ValidateUserFlag,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    OUT LPDWORD ClassTypeOfNDSLeaf,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function is common code for creating a new context handle
    and initializing it for enumerating either volumes, directories,
    or NDS subtrees.

Arguments:

    ContainerName - Supplies the full path name to the container object
                    we are enumerating from.

    EnumType - Supplies the type of the object we want to enumerate

    StartingPoint - Supplies the initial resume ID.

    UserName - Supplies the username to connect with.

    Password - Supplies the password to connect with.

    EnumHandle - Receives the newly created context handle.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if the memory for the context could
        not be allocated.

    NO_ERROR - Call was successful.

    Other errors from failure to open a handle to the server.

--*/ // NwrOpenEnumCommon
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    LPNW_ENUM_CONTEXT ContextHandle = NULL;
    LPWSTR StrippedContainerName = NULL;
    BOOL  fImpersonate = FALSE ;

    if ( ClassTypeOfNDSLeaf )
        *ClassTypeOfNDSLeaf = 0;

    //
    // Before we do anything, we need to convert the UNC passed to
    // us. We need to get rid of any CN=XXX.OU=YYY.O=ZZZ references, and
    // convert them to XXX.YYY.ZZZ format. Any NETRESOURCE that we generate
    // will look like \\TREE\XXX.YYY.ZZZ for a NDS Unc. We do this to
    // work around to a bug in WOW.EXE, that prevents 16 bit apps from
    // being launched when the user types NDS paths with the CN= stuff in it.
    // 
    NwStripNdsUncName( ContainerName, &StrippedContainerName );

    if ( StrippedContainerName == NULL )
    {
        KdPrint(("NWWORKSTATION: NwrOpenEnumCommon LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Allocate memory for the context handle structure and space for
    // the ContainerName plus \.  Now need one more for NULL terminator
    // because it's already included in the structure.
    //
    ContextHandle = (PVOID) LocalAlloc(
                                        LMEM_ZEROINIT,
                                        sizeof(NW_ENUM_CONTEXT) +
                                        (wcslen(StrippedContainerName) + 1) * sizeof(WCHAR)
                                      );

    if (ContextHandle == NULL)
    {
        if ( StrippedContainerName )
        {
            (void) LocalFree((HLOCAL) StrippedContainerName);
            StrippedContainerName = NULL;
        }

        KdPrint(("NWWORKSTATION: NwrOpenEnumCommon LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize contents of the context handle structure.
    //
    ContextHandle->Signature = NW_HANDLE_SIGNATURE;
    ContextHandle->HandleType = EnumType;
    ContextHandle->ResumeId = StartingPoint;

    //
    // These are set to zero due to LMEM_ZEROINIT.
    //
    // ContextHandle->NdsRawDataBuffer = 0;
    // ContextHandle->NdsRawDataSize = 0;
    // ContextHandle->NdsRawDataId = 0;
    // ContextHandle->NdsRawDataCount = 0;
    // ContextHandle->TreeConnectionHandle = 0;

    //
    // Impersonate the client
    //
    if ( ( status = NwImpersonateClient() ) != NO_ERROR )
    {
        goto ErrorExit;
    }

    fImpersonate = TRUE;

    if ( EnumType == NwsHandleListNdsSubTrees_Disk ||
         EnumType == NwsHandleListNdsSubTrees_Print ||
         EnumType == NwsHandleListNdsSubTrees_Any ||
         EnumType == NwsHandleListContextInfo_Tree )
    {
        WCHAR          lpServerName[NW_MAX_SERVER_LEN];
        UNICODE_STRING ServerName;
        UNICODE_STRING ObjectName;

        ServerName.Length = 0;
        ServerName.MaximumLength = sizeof( lpServerName );
        ServerName.Buffer = lpServerName;

        ObjectName.Buffer = NULL;

        if ( EnumType == NwsHandleListContextInfo_Tree )
        {
            ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
        }
        else
        {
            ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NDS;
        }

        ObjectName.MaximumLength = ( wcslen( StrippedContainerName ) + 1 ) *
                                   sizeof( WCHAR );

        ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                               StrippedContainerName,
                                               PARSE_NDS_GET_TREE_NAME );

        if ( ObjectName.Length == 0 || ObjectName.Buffer == NULL )
        {
            status = ERROR_PATH_NOT_FOUND;
            goto ErrorExit;
        }

        //
        // Open a NDS tree connection handle to \\treename
        //
        ntstatus = NwNdsOpenTreeHandle( &ObjectName,
                                      &ContextHandle->TreeConnectionHandle );

        if ( ntstatus != STATUS_SUCCESS )
        {
            status = RtlNtStatusToDosError(ntstatus);
            goto ErrorExit;
        }


        //
        // Get the path to the container to open.
        //
        ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                               StrippedContainerName,
                                               PARSE_NDS_GET_PATH_NAME
                                             );

        if ( ObjectName.Length == 0 )
        {
            UNICODE_STRING Root;

            RtlInitUnicodeString(&Root, L"[Root]");

            //
            // Resolve the path to get a NDS object id of [Root].
            //
            ntstatus =  NwNdsResolveName( ContextHandle->TreeConnectionHandle,
                                          &Root,
                                          &ContextHandle->dwOid,
                                          &ServerName,
                                          NULL,
                                          0 );

            if ( ntstatus != STATUS_SUCCESS )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            wcscpy(ContextHandle->ContainerName, StrippedContainerName);
        }
        else
        {
            //
            // Resolve the path to get a NDS object id.
            //
            ntstatus =  NwNdsResolveName( ContextHandle->TreeConnectionHandle,
                                          &ObjectName,
                                          &ContextHandle->dwOid,
                                          &ServerName,
                                          NULL,
                                          0 );

            if ( ntstatus != STATUS_SUCCESS )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            wcscpy(ContextHandle->ContainerName, StrippedContainerName);
        }

        if ( ServerName.Length )
        {
            DWORD    dwHandleType;

            //
            // NwNdsResolveName succeeded, but we were referred to
            // another server, though ContextHandle->dwOid is still valid.

            if ( ContextHandle->TreeConnectionHandle )
                CloseHandle( ContextHandle->TreeConnectionHandle );

            ContextHandle->TreeConnectionHandle = 0;

            //
            // Open a NDS generic connection handle to \\ServerName
            //
            ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                               &dwHandleType,
                                               &ContextHandle->TreeConnectionHandle );

            if ( ntstatus != STATUS_SUCCESS )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            ASSERT( dwHandleType == HANDLE_TYPE_NCP_SERVER );
        }

        //
        // Check to see if object is either a Server, Directory Map, or Volume.
        // If so, the object is a known leaf in terms of NDS, and therefore cannot
        // be enumerated through NwNdsList API calls. We fail the OpenEnum call in these
        // cases and pass back the type of object the leaf node was. This way the code in
        // NWPROVAU!NPOpenEnum can call NwrOpenEnumServer, NwrOpenEnumVolume, or
        // NwrOpenEnumDirectories accordingly.
        //
        {
            BYTE RawResponse[TWO_KB];
            DWORD RawResponseSize = sizeof(RawResponse);
            DWORD dwStrLen;
            PBYTE pbRawGetInfo;

            ntstatus = NwNdsReadObjectInfo( ContextHandle->TreeConnectionHandle,
                                            ContextHandle->dwOid,
                                            RawResponse,
                                            RawResponseSize );

            if ( ntstatus != NO_ERROR )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            (void) NwRevertToSelf() ;
            fImpersonate = FALSE;

            pbRawGetInfo = RawResponse;

            //
            // The structure of a NDS_RESPONSE_GET_OBJECT_INFO consists of 4 DWORDs
            // followed by two standard NDS format UNICODE strings. Below we jump pbRawGetInfo
            // into the buffer, past the 4 DWORDs.
            //
            pbRawGetInfo += sizeof ( NDS_RESPONSE_GET_OBJECT_INFO );

            //
            // Now we get the length of the first string (Base Class).
            //
            dwStrLen = * ( DWORD * ) pbRawGetInfo;

            //
            // Now we point pbRawGetInfo to the first WCHAR of the first string (Base Class).
            //
            pbRawGetInfo += sizeof( DWORD );

            //
            // If the object is either a NCP Server, Volume, or a Directory Map, we fail
            // the OpenEnum call and return the class type of the NDS leaf object. We do
            // this because we cannot enumerate through NwNdsList() calls any subordinates,
            // all browsing below these types are done through system redirector calls. So
            // the client side of the provider will instead call NwOpenEnumVolumes or
            // NwOpenEnumDirectories, respectively.
            //
            if ( !wcscmp( (LPWSTR) pbRawGetInfo, L"NCP Server" ) )
            {
                if ( ClassTypeOfNDSLeaf )
                    *ClassTypeOfNDSLeaf = CLASS_TYPE_NCP_SERVER;
                status = ERROR_NETWORK_ACCESS_DENIED;
                goto ErrorExit;
            }

            if ( !wcscmp( (LPWSTR) pbRawGetInfo, L"Volume" ) )
            {
                if ( ClassTypeOfNDSLeaf )
                    *ClassTypeOfNDSLeaf = CLASS_TYPE_VOLUME;
                status = ERROR_NETWORK_ACCESS_DENIED;
                goto ErrorExit;
            }

            if ( !wcscmp( (LPWSTR) pbRawGetInfo, L"Directory Map" ) )
            {
                if ( ClassTypeOfNDSLeaf )
                    *ClassTypeOfNDSLeaf = CLASS_TYPE_DIRECTORY_MAP;
                status = ERROR_NETWORK_ACCESS_DENIED;
                goto ErrorExit;
            }
        } // End of block
    }
    else // EnumType is something other than a NDS Sub-tree
    {
        UNICODE_STRING TreeConnectStr;

        TreeConnectStr.Buffer = NULL;
        ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;

        wcscpy(ContextHandle->ContainerName, StrippedContainerName);
        wcscat(ContextHandle->ContainerName, L"\\");

        //
        // Open a tree connection handle to \Device\NwRdr\ContainerName
        //
        status = NwCreateTreeConnectName( StrippedContainerName,
                                          NULL,
                                          &TreeConnectStr );

        if ( status != NO_ERROR )
        {
            goto ErrorExit;
        }

        status = NwOpenCreateConnection( &TreeConnectStr,
                                         UserName,
                                         Password,
                                         StrippedContainerName,
                                         FILE_LIST_DIRECTORY | SYNCHRONIZE |
                                          ( ValidateUserFlag? FILE_WRITE_DATA : 0 ),
                                         CreateDisposition,
                                         CreateOptions,
                                         RESOURCETYPE_DISK, // When connecting beyond servername
                                         &ContextHandle->TreeConnectionHandle,
                                         NULL );

        (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);
    }

    if (status == NO_ERROR)
    {
        VERSION_INFO vInfo;

        if ( EnumType == NwsHandleListVolumes ||
             EnumType == NwsHandleListVolumesQueues )
        {
            NWC_SERVER_INFO ServerInfo;

            ServerInfo.hConn = ContextHandle->TreeConnectionHandle;
            ServerInfo.ServerString.Length = 0;
            ServerInfo.ServerString.MaximumLength = 0;
            ServerInfo.ServerString.Buffer = NULL;

            status = NWGetFileServerVersionInfo( (HANDLE) &ServerInfo,
                                                 &vInfo );

            if ( status )
            {
                ContextHandle->dwMaxVolumes = NW_MAX_VOLUME_NUMBER;
                status = NO_ERROR;
            }
            else
            {
                ContextHandle->dwMaxVolumes = (DWORD) vInfo.maxVolumes;

                if ( ContextHandle->dwMaxVolumes == 0 )
                {
                    ContextHandle->dwMaxVolumes = NW_MAX_VOLUME_NUMBER;
                }
            }
        }

        (void) NwRevertToSelf() ;
        fImpersonate = FALSE;

        if ( StrippedContainerName )
        {
            (void) LocalFree((HLOCAL) StrippedContainerName);
            StrippedContainerName = NULL;
        }

        //
        // Return the newly created context.
        //
        *EnumHandle = (LPNWWKSTA_CONTEXT_HANDLE) ContextHandle;

        return status;
    }

ErrorExit:

    if ( fImpersonate )
        (void) NwRevertToSelf() ;

    if ( StrippedContainerName )
    {
        (void) LocalFree((HLOCAL) StrippedContainerName);
    }

    if ( ContextHandle )
    {
        if ( ContextHandle->TreeConnectionHandle )
            CloseHandle( ContextHandle->TreeConnectionHandle );

        ContextHandle->Signature = 0x0BADBAD0;

        (void) LocalFree((HLOCAL) ContextHandle);
    }

    *EnumHandle = NULL;

    if (status == ERROR_NOT_CONNECTED)
    {
        //
        // Object name not found.  We should return path not found.
        //
        status = ERROR_PATH_NOT_FOUND;
    }

    return status;
}


DWORD
NwrEnum(
    IN NWWKSTA_CONTEXT_HANDLE EnumHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function

Arguments:

    EnumHandle - Supplies a pointer to the context handle which identifies
        what type of object we are enumerating and the string of the
        container name to concatenate to the returned object.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

    WN_BAD_HANDLE - The specified enumeration handle is invalid.

--*/ // NwrEnum
{
    DWORD status;
    LPNW_ENUM_CONTEXT ContextHandle = (LPNW_ENUM_CONTEXT) EnumHandle;
    BOOL  fImpersonate = FALSE ;

    if (ContextHandle->Signature != NW_HANDLE_SIGNATURE) {
        return WN_BAD_HANDLE;
    }

    //
    // Impersonate the client
    //
    if ((status = NwImpersonateClient()) != NO_ERROR)
    {
        goto CleanExit;
    }
    fImpersonate = TRUE ;

    *EntriesRead = 0;
    *BytesNeeded = 0;

    RtlZeroMemory(Buffer, BufferSize);

    switch (ContextHandle->HandleType) {
        case NwsHandleListConnections:
            if (!(ContextHandle->ConnectionType & CONNTYPE_SYMBOLIC))
            {
                status = NwEnumerateConnections(
                             &ContextHandle->ResumeId,
                             EntriesRequested,
                             Buffer,
                             BufferSize,
                             BytesNeeded,
                             EntriesRead,
                             ContextHandle->ConnectionType,
                             NULL
                             );
            }
            break;

        case NwsHandleListContextInfo_Tree:
        case NwsHandleListContextInfo_Server:

            status = NwEnumContextInfo(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListServersAndNdsTrees:

            status = NwEnumServersAndNdsTrees(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListVolumes:

            status = NwEnumVolumes(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListNdsSubTrees_Disk:

            status = NwEnumNdsSubTrees_Disk(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );

            break;

        case NwsHandleListNdsSubTrees_Print:

            status = NwEnumNdsSubTrees_Print(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );

            break;

        case NwsHandleListNdsSubTrees_Any:

            status = NwEnumNdsSubTrees_Any(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );

            break;

        case NwsHandleListQueues:

            status = NwEnumQueues(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListVolumesQueues:

            status = NwEnumVolumesQueues(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListDirectories:

            status = NwEnumDirectories(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );

            break;

        case NwsHandleListPrintServers:

            status = NwEnumPrintServers(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        case NwsHandleListPrintQueues:

            status = NwEnumPrintQueues(
                         ContextHandle,
                         EntriesRequested,
                         Buffer,
                         BufferSize,
                         BytesNeeded,
                         EntriesRead
                         );
            break;

        default:
            KdPrint(("NWWORKSTATION: NwrEnum unexpected handle type %lu\n",
                     ContextHandle->HandleType));
            ASSERT(FALSE);
            status = WN_BAD_HANDLE;
            goto CleanExit ;
    }

    if (*EntriesRead > 0) {

        switch ( ContextHandle->HandleType ) {
            case NwsHandleListConnections:
            case NwsHandleListContextInfo_Tree:
            case NwsHandleListContextInfo_Server:
            case NwsHandleListServersAndNdsTrees:
            case NwsHandleListVolumes:
            case NwsHandleListQueues:
            case NwsHandleListVolumesQueues:
            case NwsHandleListDirectories:
            case NwsHandleListNdsSubTrees_Disk:
            case NwsHandleListNdsSubTrees_Any:
            {
                DWORD i;
                LPNETRESOURCEW NetR = (LPNETRESOURCEW) Buffer;

                //
                // Replace pointers to strings with offsets as need
                //

                if ((ContextHandle->HandleType == NwsHandleListConnections)
                   && (ContextHandle->ConnectionType & CONNTYPE_SYMBOLIC))
                {
                    //
                    // NwrEnumGWDevices already return offsets.
                    //
                    break ;
                }

                for (i = 0; i < *EntriesRead; i++, NetR++) {

                    if (NetR->lpLocalName != NULL) {
                        NetR->lpLocalName = (LPWSTR)
                            ((DWORD_PTR) (NetR->lpLocalName) - (DWORD_PTR) Buffer);
                    }

                    NetR->lpRemoteName =
                        (LPWSTR) ((DWORD_PTR) (NetR->lpRemoteName) - (DWORD_PTR)Buffer);

                    if (NetR->lpComment != NULL) {
                        NetR->lpComment = (LPWSTR) ((DWORD_PTR) (NetR->lpComment) -
                                                    (DWORD_PTR) Buffer);
                    }

                    if (NetR->lpProvider != NULL) {
                        NetR->lpProvider =
                            (LPWSTR) ((DWORD_PTR) (NetR->lpProvider) -
                                      (DWORD_PTR) Buffer);
                    }
                }
                break;
            }

            case NwsHandleListPrintServers:
            case NwsHandleListPrintQueues:
            case NwsHandleListNdsSubTrees_Print:
            {
                DWORD i;
                PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) Buffer;

                //
                // Sort the entries in the buffer
                //
                if ( *EntriesRead > 1 )
                    qsort( Buffer, *EntriesRead,
                           sizeof( PRINTER_INFO_1W ), SortFunc );

                //
                // Replace pointers to strings with offsets
                //
                for (i = 0; i < *EntriesRead; i++, pPrinterInfo1++) {

                    MarshallDownStructure( (LPBYTE) pPrinterInfo1,
                                           PrinterInfo1Offsets,
                                           Buffer );
                }
                break;
            }

            default:
                KdPrint(("NWWORKSTATION: NwrEnum (pointer to offset code) unexpected handle type %lu\n", ContextHandle->HandleType));
                ASSERT( FALSE );
                break;
        }
    }

CleanExit:

    if (fImpersonate)
        (void) NwRevertToSelf() ;

    return status;
}


DWORD
NwrEnumConnections(
    IN NWWKSTA_CONTEXT_HANDLE EnumHandle,
    IN DWORD EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead,
    IN DWORD  fImplicitConnections
    )
/*++

Routine Description:

    This function is an alternate to NwrEnum. It only accepts handles
    that are opened with ListConnections. This function takes a flag
    indicating whether we need to show all implicit connections or not.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff ERROR_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

    fImplicitConnections - TRUE if we also want to get implicit connections,
        FALSE otherwise.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    ERROR_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwrEnumConnections
{
    DWORD status;
    LPNW_ENUM_CONTEXT ContextHandle = (LPNW_ENUM_CONTEXT) EnumHandle;

    if (  (ContextHandle->Signature != NW_HANDLE_SIGNATURE)
       || ( ContextHandle->HandleType != NwsHandleListConnections )
       )
    {
        return WN_BAD_HANDLE;
    }

    *EntriesRead = 0;
    *BytesNeeded = 0;

    RtlZeroMemory(Buffer, BufferSize);

    if ( fImplicitConnections )
        ContextHandle->ConnectionType |= CONNTYPE_IMPLICIT;

    if ((status = NwImpersonateClient()) != NO_ERROR)
        goto ErrorExit;

    status = NwEnumerateConnections(
               &ContextHandle->ResumeId,
               EntriesRequested,
               Buffer,
               BufferSize,
               BytesNeeded,
               EntriesRead,
               ContextHandle->ConnectionType,
           NULL
               );

    if (*EntriesRead > 0) {

        //
        // Replace pointers to strings with offsets
        //

        DWORD i;
        LPNETRESOURCEW NetR = (LPNETRESOURCEW) Buffer;

        for (i = 0; i < *EntriesRead; i++, NetR++) {

            if (NetR->lpLocalName != NULL) {
                NetR->lpLocalName = (LPWSTR)
                    ((DWORD_PTR) (NetR->lpLocalName) - (DWORD_PTR) Buffer);
            }

            NetR->lpRemoteName =
                (LPWSTR) ((DWORD_PTR) (NetR->lpRemoteName) - (DWORD_PTR)Buffer);

            if (NetR->lpComment != NULL) {
                NetR->lpComment = (LPWSTR) ((DWORD_PTR) (NetR->lpComment) -
                                            (DWORD_PTR) Buffer);
            }

            if (NetR->lpProvider != NULL) {
                NetR->lpProvider = (LPWSTR) ((DWORD_PTR) (NetR->lpProvider) -
                                             (DWORD_PTR) Buffer);
            }
        }
    }
    (void) NwRevertToSelf();

ErrorExit:    
    return status;
}


DWORD
NwEnumContextInfo(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all of the bindery servers that are currently
    connected, then sets the context handle so that the next NPEnumResource
    call goes to the NDS subtree for the user's NDS context information
    (if using NDS).

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumContextInfo
{
    DWORD status = NO_ERROR;
    DWORD_PTR tempResumeId = 0;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;
    DWORD LastObjectId = (DWORD) ContextHandle->ResumeId;

    while ( ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NON_NDS &&
            FitInBuffer &&
            EntriesRequested > *EntriesRead &&
            status == NO_ERROR )
    {
        tempResumeId = ContextHandle->ResumeId;

        status = NwGetNextServerConnection( ContextHandle );

        if ( status == NO_ERROR && ContextHandle->ResumeId != 0 )
        {
            //
            // Pack bindery server name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         L"\\\\",
                         NULL,
                         (LPWSTR) ContextHandle->ResumeId, // A server name
                         RESOURCE_CONTEXT,
                         RESOURCEDISPLAYTYPE_SERVER,
                         RESOURCEUSAGE_CONTAINER,
                         RESOURCETYPE_ANY,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer,
                // backup ResumeId to previous entry.
                //
                ContextHandle->ResumeId = tempResumeId;
                ContextHandle->NdsRawDataCount += 1;

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Note that we've returned the current entry.
                //
                (*EntriesRead)++;
            }
        }
        else if ( status == WN_NO_MORE_ENTRIES )
        {
            //
            // We processed the last item in list, so
            // start enumerating servers.
            //
            ContextHandle->ResumeId = 0;
            LastObjectId = 0;

            if ( ContextHandle->HandleType == NwsHandleListContextInfo_Tree )
            {
                ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NDS;
            }
        }
    }

    if ( ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NDS )
    {
        ContextHandle->HandleType = NwsHandleListNdsSubTrees_Any;
        status = NO_ERROR;
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumServersAndNdsTrees(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the servers and NDS trees on the local
    network by: 1) scanning the bindery for file server objects on the
    preferred server and 2) scanning the bindery for directory servers
    (NDS trees) on the preferred server. The server and tree entries are
    returned in an array of NETRESOURCE entries; each servername is
    prefixed by \\.

    The ContextHandle->ResumeId field is initially -1 before
    enumeration begins and contains the object ID of the last server
    or NDS tree object returned, depending on the value of
    ContextHandle->dwUsingNds.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumServersAndNdsTrees
{
    DWORD status = NO_ERROR;
    DWORD_PTR tempResumeId = 0;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    SERVERNAME ServerName;          // OEM server name
    LPWSTR UServerName = NULL;      // Unicode server name
    DWORD LastObjectId = (DWORD) ContextHandle->ResumeId;

    while ( ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NDS &&
            FitInBuffer &&
            EntriesRequested > *EntriesRead &&
            status == NO_ERROR )
    {
        tempResumeId = ContextHandle->ResumeId;

        //
        // Call the scan bindery object NCP to scan for all NDS
        // tree objects.
        //
        status = NwGetNextNdsTreeEntry( ContextHandle );

        if ( status == NO_ERROR && ContextHandle->ResumeId != 0 )
        {
            //
            // Pack tree name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         L"\\\\",
                         NULL,
                         (LPWSTR) ContextHandle->ResumeId, // This is a NDS tree name
                         RESOURCE_GLOBALNET,
                         RESOURCEDISPLAYTYPE_TREE,
                         RESOURCEUSAGE_CONTAINER,
                         RESOURCETYPE_ANY,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer, backup ResumeId to
                // previous entry.
                //
                ContextHandle->ResumeId = tempResumeId;
                ContextHandle->NdsRawDataCount += 1;

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Note that we've returned the current entry.
                //
                (*EntriesRead)++;
            }
        }
        else if ( status == WN_NO_MORE_ENTRIES )
        {
            //
            // We processed the last item in list, so
            // start enumerating servers.
            //
            ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
            ContextHandle->ResumeId = (DWORD_PTR) -1;
            LastObjectId = (DWORD) -1;
        }
    }

    if ( status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    while ( ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NON_NDS &&
            FitInBuffer &&
            EntriesRequested > *EntriesRead &&
            status == NO_ERROR )
    {
        RtlZeroMemory(ServerName, sizeof(ServerName));

        //
        // Call the scan bindery object NCP to scan for all file
        // server objects.
        //
        status = NwGetNextServerEntry(
                     ContextHandle->TreeConnectionHandle,
                     &LastObjectId,
                     ServerName
                     );

        if (status == NO_ERROR && NwConvertToUnicode(&UServerName, ServerName))
        {
            //
            // Pack server name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         L"\\\\",
                         NULL,
                         UServerName,
                         RESOURCE_GLOBALNET,
                         RESOURCEDISPLAYTYPE_SERVER,
                         RESOURCEUSAGE_CONTAINER,
                         RESOURCETYPE_ANY,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer.
                //

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Note that we've returned the current entry.
                //
                (*EntriesRead)++;

                ContextHandle->ResumeId = (DWORD_PTR) LastObjectId;
            }

            (void) LocalFree((HLOCAL) UServerName);
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    return status;
}



DWORD
NwEnumVolumes(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the volumes on a server by
    iteratively getting the volume name for each volume number from
    0 - 31 until we run into the first volume number that does not
    map to a volume name (this method assumes that volume numbers
    are used contiguously in ascending order).  The volume entries
    are returned in an array of NETRESOURCE entries; each volume
    name if prefixed by \\Server\.

    The ContextHandle->ResumeId field always indicates the next
    volume entry to return.  It is initially set to 0, which indicates
    the first volume number to get.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumVolumes
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    CHAR VolumeName[NW_VOLUME_NAME_LEN]; // OEM volume name
    LPWSTR UVolumeName = NULL;           // Unicode volume name
    DWORD NextVolumeNumber = (DWORD) ContextHandle->ResumeId;
    DWORD MaxVolumeNumber = ContextHandle->dwMaxVolumes;
    ULONG Failures = 0;

    if (NextVolumeNumber == MaxVolumeNumber) {
        //
        // Reached the end of enumeration
        //
        return WN_NO_MORE_ENTRIES;
    }

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           NextVolumeNumber < MaxVolumeNumber &&
           status == NO_ERROR) {

        RtlZeroMemory(VolumeName, sizeof(VolumeName));

        //
        // Call the scan bindery object NCP to scan for all file
        // volume objects.
        //
        
        status = NwGetNextVolumeEntry(
                     ContextHandle->TreeConnectionHandle,
                     NextVolumeNumber++,
                     VolumeName
                     );

        if (status == NO_ERROR) {

            if (VolumeName[0] == 0) {

                //
                // Got an empty volume name back for the next volume number
                // which indicates there is no volume associated with the
                // volume number but still got error success.
                //
                // Treat this as having reached the end of the enumeration
                // only if we've gotten two three empty volumes in a row
                // or reached the max number of volumes because there are
                // some cases where there are holes in the way that volumes
                // are allocated.
                //

                Failures++;
                    
                if ( Failures <= 3 ) {
                
                    continue;

                } else {
 
                    NextVolumeNumber = MaxVolumeNumber;
                    ContextHandle->ResumeId = MaxVolumeNumber;
   
                    if (*EntriesRead == 0) {
                        status = WN_NO_MORE_ENTRIES;
                    }
                }

            } else if (NwConvertToUnicode(&UVolumeName, VolumeName)) {

                //
                // Pack volume name into output buffer.
                //
                status = NwWriteNetResourceEntry(
                             &FixedPortion,
                             &EndOfVariableData,
                             ContextHandle->ContainerName,
                             NULL,
                             UVolumeName,
                             RESOURCE_GLOBALNET,
                             RESOURCEDISPLAYTYPE_SHARE,
#ifdef NT1057
                             RESOURCEUSAGE_CONNECTABLE |
                             RESOURCEUSAGE_CONTAINER,
#else
                             RESOURCEUSAGE_CONNECTABLE |
                             RESOURCEUSAGE_NOLOCALDEVICE,
#endif
                             RESOURCETYPE_DISK,
                             NULL,
                             NULL,
                             &EntrySize
                             );

                if (status == WN_MORE_DATA) {

                    //
                    // Could not write current entry into output buffer.
                    //

                    if (*EntriesRead) {
                        //
                        // Still return success because we got at least one.
                        //
                        status = NO_ERROR;
                    }
                    else {
                        *BytesNeeded = EntrySize;
                    }

                    FitInBuffer = FALSE;
                }
                else if (status == NO_ERROR) {

                    //
                    // Note that we've returned the current entry.
                    //
                    (*EntriesRead)++;

                    ContextHandle->ResumeId = NextVolumeNumber;
                }

                (void) LocalFree((HLOCAL) UVolumeName);
            }

            //
            // We got an entry, so reset the failure counter.
            //

            Failures = 0;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumNdsSubTrees_Disk(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates the sub-trees of a given NDS tree
    handle. It returns the fully-qualified UNC path of the sub-tree
    entries in an array of NETRESOURCE entries.

    The ContextHandle->ResumeId field is 0 initially, and contains
    a pointer to the subtree name string of the last sub-tree
    returned.  If there are no more sub-trees to return, this
    field is set to -1.

Arguments:

    ContextHandle - Supplies the enum context handle.  It contains
        an opened NDS tree handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumNdsSubTrees_Disk
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL   FitInBuffer = TRUE;
    DWORD  EntrySize = 0;

    LPWSTR SubTreeName = NULL;
    DWORD  ResourceScope = 0;
    DWORD  ResourceType = 0;
    DWORD  ResourceDisplayType = 0;
    DWORD  ResourceUsage = 0;
    LPWSTR StrippedObjectName = NULL;

    if (ContextHandle->ResumeId == (DWORD_PTR) -1)
    {
        //
        // Reached the end of enumeration.
        //
        return WN_NO_MORE_ENTRIES;
    }

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           status == NO_ERROR)
    {
        if ( ContextHandle->ResumeId == 0 )
        {
            //
            // Get the first subtree entry.
            //
            status = NwGetFirstNdsSubTreeEntry( ContextHandle, BufferSize );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // NwGetFirstDirectoryEntry or it contains the next directory
        // entry to return.
        //
        if (status == NO_ERROR && ContextHandle->ResumeId != 0)
        {
            BYTE   ClassType;
            LPWSTR newPathStr = NULL;
            LPWSTR tempStr = NULL;
            WORD   tempStrLen;

            //
            // Get current subtree data from ContextHandle
            //
            ClassType = NwGetSubTreeData( ContextHandle->ResumeId,
                                          &SubTreeName,
                                          &ResourceScope,
                                          &ResourceType,
                                          &ResourceDisplayType,
                                          &ResourceUsage,
                                          &StrippedObjectName );

            if ( StrippedObjectName == NULL )
            {
                KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Disk LocalAlloc Failed %lu\n",
                        GetLastError()));

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            switch( ClassType )
            {
                case CLASS_TYPE_COUNTRY:
                case CLASS_TYPE_DIRECTORY_MAP:
                case CLASS_TYPE_NCP_SERVER:
                case CLASS_TYPE_ORGANIZATION:
                case CLASS_TYPE_ORGANIZATIONAL_UNIT:
                case CLASS_TYPE_VOLUME:

                    //
                    // Need to build a string with the new NDS UNC path for subtree object
                    //
                    newPathStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                       ( wcslen( StrippedObjectName ) +
                                         wcslen( ContextHandle->ContainerName ) +
                                         3 ) * sizeof(WCHAR) );

                    if ( newPathStr == NULL )
                    {
                        KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Disk LocalAlloc Failed %lu\n",
                                GetLastError()));

                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_TREE_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscpy( newPathStr, L"\\\\" );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                        wcscat( newPathStr, L"\\" );
                        wcscat( newPathStr, StrippedObjectName );
                    }

                    (void) LocalFree((HLOCAL) StrippedObjectName );
                    StrippedObjectName = NULL;

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_PATH_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscat( newPathStr, L"." );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                    }

                    //
                    // Pack subtree name into output buffer.
                    //
                    status = NwWriteNetResourceEntry(
                                 &FixedPortion,
                                 &EndOfVariableData,
                                 NULL,
                                 NULL,
                                 newPathStr,
                                 ResourceScope,
                                 ResourceDisplayType,
                                 ResourceUsage,
                                 ResourceType,
                                 NULL,
                                 NULL,
                                 &EntrySize );

                    if ( status == NO_ERROR )
                    {
                        //
                        // Note that we've returned the current entry.
                        //
                        (*EntriesRead)++;
                    }

                    if ( newPathStr )
                        (void) LocalFree( (HLOCAL) newPathStr );

                break;

                case CLASS_TYPE_ALIAS:
                case CLASS_TYPE_AFP_SERVER:
                case CLASS_TYPE_BINDERY_OBJECT:
                case CLASS_TYPE_BINDERY_QUEUE:
                case CLASS_TYPE_COMPUTER:
                case CLASS_TYPE_GROUP:
                case CLASS_TYPE_LOCALITY:
                case CLASS_TYPE_ORGANIZATIONAL_ROLE:
                case CLASS_TYPE_PRINTER:
                case CLASS_TYPE_PRINT_SERVER:
                case CLASS_TYPE_PROFILE:
                case CLASS_TYPE_QUEUE:
                case CLASS_TYPE_TOP:
                case CLASS_TYPE_UNKNOWN:
                case CLASS_TYPE_USER:
                break;

                default:
                    KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Disk - Unhandled switch statement case %lu\n", ClassType ));
                    ASSERT( FALSE );
                break;
            }

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer.
                //

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Get next directory entry.
                //
                status = NwGetNextNdsSubTreeEntry( ContextHandle );
            }
        }

        if (status == WN_NO_MORE_ENTRIES)
        {
            ContextHandle->ResumeId = (DWORD_PTR) -1;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

#if DBG
    IF_DEBUG(ENUM)
    {
        KdPrint(("NwEnumNdsSubTrees_Disk returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwEnumNdsSubTrees_Print(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the NDS subtree objects that are either containers,
    queues, printers, or servers from a given NDS tree or subtree. The entries are
    returned in an array of PRINTER_INFO_1 entries and each name is prefixed
    by the parent path in NDS UNC style (ex. \\tree\CN=foo.OU=bar.O=blah).

    The ContextHandle->ResumeId field is initially (DWORD_PTR) -1 before
    enumeration begins and contains the object ID of the last NDS object returned.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes copied or required to get all
        the requested entries.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.

Return Value:

    NO_ERROR - Buffer contains all the entries requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit the requested entries.

--*/ // NwEnumNdsSubTrees_Print
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    DWORD EntrySize;
    BOOL FitInBuffer = TRUE;

    LPWSTR SubTreeName = NULL;
    DWORD  ResourceScope = 0;
    DWORD  ResourceType = 0;
    DWORD  ResourceDisplayType = 0;
    DWORD  ResourceUsage = 0;
    LPWSTR StrippedObjectName = NULL;
    BYTE   ClassType = 0;
    LPWSTR newPathStr = NULL;
    LPWSTR tempStr = NULL;
    WORD   tempStrLen = 0;

    while ( EntriesRequested > *EntriesRead &&
            ( (status == NO_ERROR) || (status == ERROR_INSUFFICIENT_BUFFER)))
    {
        if (ContextHandle->ResumeId == 0)
        {
            //
            // Get the first subtree entry.
            //
            status = NwGetFirstNdsSubTreeEntry( ContextHandle, BufferSize );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // NwGetFirstDirectoryEntry or it contains the next directory
        // entry to return.
        //
        if (status == NO_ERROR && ContextHandle->ResumeId != 0)
        {

            //
            // Get current subtree data from ContextHandle
            //
            ClassType = NwGetSubTreeData( ContextHandle->ResumeId,
                                          &SubTreeName,
                                          &ResourceScope,
                                          &ResourceType,
                                          &ResourceDisplayType,
                                          &ResourceUsage,
                                          &StrippedObjectName );

            if ( StrippedObjectName == NULL )
            {
                KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Print LocalAlloc Failed %lu\n",
                        GetLastError()));

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            switch( ClassType )
            {

                case CLASS_TYPE_COUNTRY:
                case CLASS_TYPE_ORGANIZATION:
                case CLASS_TYPE_ORGANIZATIONAL_UNIT:
                case CLASS_TYPE_NCP_SERVER:
                case CLASS_TYPE_QUEUE:
                    //
                    // Need to build a string with the new NDS UNC path for subtree object
                    //
                    newPathStr = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                       ( wcslen( StrippedObjectName ) +
                                       wcslen( ContextHandle->ContainerName ) +
                                       2 ) * sizeof(WCHAR) );

                    if ( newPathStr == NULL )
                    {
                        KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Print LocalAlloc Failed %lu\n",
                                GetLastError()));

                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_TREE_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcsncpy( newPathStr, tempStr, tempStrLen );
                        wcscat( newPathStr, L"\\" );
                        wcscat( newPathStr, StrippedObjectName );
                    }

                    (void) LocalFree((HLOCAL) StrippedObjectName );
                    StrippedObjectName = NULL;

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_PATH_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscat( newPathStr, L"." );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                    }

                    switch( ClassType )
                    {
                        case CLASS_TYPE_COUNTRY:
                        case CLASS_TYPE_ORGANIZATION:
                        case CLASS_TYPE_ORGANIZATIONAL_UNIT:
                            //
                            // Pack sub-tree container name into output buffer.
                            //
                            status = NwWritePrinterInfoEntry(
                                         &FixedPortion,
                                         &EndOfVariableData,
                                         NULL,
                                         newPathStr,
                                         PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON1,
                                         &EntrySize );

                        break;

                        case CLASS_TYPE_NCP_SERVER:
                            //
                            // Pack server name into output buffer.
                            //
                            status = NwWritePrinterInfoEntry(
                                         &FixedPortion,
                                         &EndOfVariableData,
                                         NULL,
                                         newPathStr,
                                         PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON3,
                                         &EntrySize );

                        break;

                        case CLASS_TYPE_QUEUE:
                            //
                            // Pack print server queue name into output buffer.
                            //
                            status = NwWritePrinterInfoEntry(
                                         &FixedPortion,
                                         &EndOfVariableData,
                                         L"\\\\",
                                         newPathStr,
                                         PRINTER_ENUM_ICON8,
                                         &EntrySize );
                        break;

                        default:
KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Print - Unhandled switch statement case %lu\n", ClassType ));
                            ASSERT(FALSE);
                        break;
                    }

                    switch ( status )
                    {
                        case ERROR_INSUFFICIENT_BUFFER:
                            FitInBuffer = FALSE;
                            // Falls through

                        case NO_ERROR:
                            *BytesNeeded += EntrySize;
                            (*EntriesRead)++;
                            break;

                        default:
                            break;
                    }

                    if ( newPathStr )
                        (void) LocalFree( (HLOCAL) newPathStr );

                break;

                case CLASS_TYPE_ALIAS:
                case CLASS_TYPE_AFP_SERVER:
                case CLASS_TYPE_BINDERY_OBJECT:
                case CLASS_TYPE_BINDERY_QUEUE:
                case CLASS_TYPE_COMPUTER:
                case CLASS_TYPE_DIRECTORY_MAP:
                case CLASS_TYPE_GROUP:
                case CLASS_TYPE_LOCALITY:
                case CLASS_TYPE_ORGANIZATIONAL_ROLE:
                case CLASS_TYPE_PRINTER:
                case CLASS_TYPE_PRINT_SERVER:
                case CLASS_TYPE_PROFILE:
                case CLASS_TYPE_TOP:
                case CLASS_TYPE_UNKNOWN:
                case CLASS_TYPE_USER:
                case CLASS_TYPE_VOLUME:
                break;

                default:
KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Print - Unhandled switch statement case %lu\n", ClassType ));
                    ASSERT( FALSE );
                break;
            }

            if ( status == NO_ERROR || status == ERROR_INSUFFICIENT_BUFFER )
            {
                //
                // Get next directory entry.
                //
                status = NwGetNextNdsSubTreeEntry( ContextHandle );
            }
        }
    }

    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if ( !FitInBuffer )
    {
        *EntriesRead = 0;
        status = ERROR_INSUFFICIENT_BUFFER;
    }
    else if (*EntriesRead && status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumNdsSubTrees_Any(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates the sub-trees of a given NDS tree
    handle. It returns the fully-qualified UNC path of ANY sub-tree
    entries in an array of NETRESOURCE entries.

    The ContextHandle->ResumeId field is 0 initially, and contains
    a pointer to the subtree name string of the last sub-tree
    returned.  If there are no more sub-trees to return, this
    field is set to (DWORD_PTR) -1.

Arguments:

    ContextHandle - Supplies the enum context handle.  It contains
        an opened NDS tree handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumNdsSubTrees_Any
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL   FitInBuffer = TRUE;
    DWORD  EntrySize = 0;

    LPWSTR SubTreeName = NULL;
    DWORD  ResourceScope = 0;
    DWORD  ResourceType = 0;
    DWORD  ResourceDisplayType = 0;
    DWORD  ResourceUsage = 0;
    LPWSTR StrippedObjectName = NULL;

    if (ContextHandle->ResumeId == (DWORD_PTR) -1)
    {
        //
        // Reached the end of enumeration.
        //
        return WN_NO_MORE_ENTRIES;
    }

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           status == NO_ERROR)
    {
        if ( ContextHandle->ResumeId == 0 )
        {
            //
            // Get the first subtree entry.
            //
            status = NwGetFirstNdsSubTreeEntry( ContextHandle, BufferSize );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // NwGetFirstDirectoryEntry or it contains the next directory
        // entry to return.
        //
        if (status == NO_ERROR && ContextHandle->ResumeId != 0)
        {
            BYTE   ClassType;
            LPWSTR newPathStr = NULL;
            LPWSTR tempStr = NULL;
            WORD   tempStrLen;

            //
            // Get current subtree data from ContextHandle
            //
            ClassType = NwGetSubTreeData( ContextHandle->ResumeId,
                                          &SubTreeName,
                                          &ResourceScope,
                                          &ResourceType,
                                          &ResourceDisplayType,
                                          &ResourceUsage,
                                          &StrippedObjectName );

            if ( StrippedObjectName == NULL )
            {
                KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Any LocalAlloc Failed %lu\n",
                        GetLastError()));

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            switch( ClassType )
            {
                case CLASS_TYPE_COUNTRY:
                case CLASS_TYPE_ORGANIZATION:
                case CLASS_TYPE_ORGANIZATIONAL_UNIT:
                case CLASS_TYPE_VOLUME:
                case CLASS_TYPE_DIRECTORY_MAP:
                case CLASS_TYPE_NCP_SERVER:
                case CLASS_TYPE_QUEUE:

                    //
                    // Need to build a string with the new NDS UNC path for subtree object
                    //
                    newPathStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                       ( wcslen( StrippedObjectName ) +
                                         wcslen( ContextHandle->ContainerName ) +
                                         3 ) * sizeof(WCHAR) );

                    if ( newPathStr == NULL )
                    {
                        KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Any LocalAlloc Failed %lu\n",
                                GetLastError()));

                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_TREE_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscpy( newPathStr, L"\\\\" );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                        wcscat( newPathStr, L"\\" );
                        wcscat( newPathStr, StrippedObjectName );
                    }

                    (void) LocalFree((HLOCAL) StrippedObjectName );
                    StrippedObjectName = NULL;

                    tempStrLen = NwParseNdsUncPath( (LPWSTR *) &tempStr,
                                                    ContextHandle->ContainerName,
                                                    PARSE_NDS_GET_PATH_NAME );

                    tempStrLen /= sizeof( WCHAR );

                    if ( tempStrLen > 0 )
                    {
                        wcscat( newPathStr, L"." );
                        wcsncat( newPathStr, tempStr, tempStrLen );
                    }

                    //
                    // Pack subtree name into output buffer.
                    //
                    status = NwWriteNetResourceEntry(
                                 &FixedPortion,
                                 &EndOfVariableData,
                                 NULL,
                                 NULL,
                                 newPathStr,
                                 ResourceScope,
                                 ResourceDisplayType,
                                 ResourceUsage,
                                 ResourceType,
                                 NULL,
                                 NULL,
                                 &EntrySize );

                    if ( status == NO_ERROR )
                    {
                        //
                        // Note that we've returned the current entry.
                        //
                        (*EntriesRead)++;
                    }

                    if ( newPathStr )
                        (void) LocalFree( (HLOCAL) newPathStr );

                break;

                case CLASS_TYPE_ALIAS:
                case CLASS_TYPE_AFP_SERVER:
                case CLASS_TYPE_BINDERY_OBJECT:
                case CLASS_TYPE_BINDERY_QUEUE:
                case CLASS_TYPE_COMPUTER:
                case CLASS_TYPE_GROUP:
                case CLASS_TYPE_LOCALITY:
                case CLASS_TYPE_ORGANIZATIONAL_ROLE:
                case CLASS_TYPE_PRINTER:
                case CLASS_TYPE_PRINT_SERVER:
                case CLASS_TYPE_PROFILE:
                case CLASS_TYPE_TOP:
                case CLASS_TYPE_UNKNOWN:
                case CLASS_TYPE_USER:
                break;

                default:
                    KdPrint(("NWWORKSTATION: NwEnumNdsSubTrees_Any - Unhandled switch statement case %lu\n", ClassType ));
                    ASSERT( FALSE );
                break;
            }

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer.
                //

                if (*EntriesRead)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else
                {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Get next directory entry.
                //
                status = NwGetNextNdsSubTreeEntry( ContextHandle );
            }
        }

        if (status == WN_NO_MORE_ENTRIES)
        {
            ContextHandle->ResumeId = (DWORD_PTR) -1;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

#if DBG
    IF_DEBUG(ENUM)
    {
        KdPrint(("NwEnumNdsSubTrees_Any returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwEnumVolumesQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the volumes and queues on a server.
    The queue entries are returned in an array of NETRESOURCE entries;
    each queue name is prefixed by \\Server\.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned if WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumVolumesQueues
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    CHAR VolumeName[NW_VOLUME_NAME_LEN]; // OEM volume name
    LPWSTR UVolumeName = NULL;           // Unicode volume name
    DWORD NextObject = (DWORD) ContextHandle->ResumeId;
    DWORD MaxVolumeNumber = ContextHandle->dwMaxVolumes;
    ULONG Failures = 0;

    //
    // tommye - bug 139466
    //
    // removed if (NextObject >= 0) becaue NextObject is a DWORD
    //

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           ContextHandle->ConnectionType == CONNTYPE_DISK &&
           (NextObject < MaxVolumeNumber) &&
           status == NO_ERROR) {


        RtlZeroMemory(VolumeName, sizeof(VolumeName));

        //
        // Call the scan bindery object NCP to scan for all file
        // volume objects.
        //
        status = NwGetNextVolumeEntry(
                     ContextHandle->TreeConnectionHandle,
                     NextObject++,
                     VolumeName
                     );

        if (status == NO_ERROR) {

            if (VolumeName[0] == 0) {

                //
                // Got an empty volume name back for the next volume number
                // which indicates there is no volume associated with the
                // volume number but still got error success.
                //
                // Treat this as having reached the end of the enumeration
                // if we have had three failures in a row.  This will allow
                // us to function when there are small holes in the drive
                // list.
                //

                Failures++;

                if ( Failures <= 3 ) {

                    continue;

                } else {

                    NextObject = (DWORD) -1;
                    ContextHandle->ResumeId = (DWORD_PTR) -1;
                    ContextHandle->ConnectionType = CONNTYPE_PRINT;

                }

            } else if (NwConvertToUnicode(&UVolumeName, VolumeName)) {

                //
                // Pack volume name into output buffer.
                //
                status = NwWriteNetResourceEntry(
                             &FixedPortion,
                             &EndOfVariableData,
                             ContextHandle->ContainerName,
                             NULL,
                             UVolumeName,
                             RESOURCE_GLOBALNET,
                             RESOURCEDISPLAYTYPE_SHARE,
#ifdef NT1057
                             RESOURCEUSAGE_CONNECTABLE |
                             RESOURCEUSAGE_CONTAINER,
#else
                             RESOURCEUSAGE_CONNECTABLE |
                             RESOURCEUSAGE_NOLOCALDEVICE,
#endif
                             RESOURCETYPE_DISK,
                             NULL,
                             NULL,
                             &EntrySize
                             );

                if (status == WN_MORE_DATA) {

                    //
                    // Could not write current entry into output buffer.
                    //

                    if (*EntriesRead) {
                        //
                        // Still return success because we got at least one.
                        //
                        status = NO_ERROR;
                    }
                    else {
                        *BytesNeeded = EntrySize;
                    }

                    FitInBuffer = FALSE;
                }
                else if (status == NO_ERROR) {

                    //
                    // Note that we've returned the current entry.
                    //
                    (*EntriesRead)++;

                    ContextHandle->ResumeId = NextObject;
                }

                (void) LocalFree((HLOCAL) UVolumeName);
            }

            //
            // Reset the failures counter.
            //

            Failures = 0;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES)
    {
        status = NO_ERROR;
    }

    if ( *EntriesRead == 0 &&
         status == NO_ERROR &&
         ContextHandle->ConnectionType == CONNTYPE_DISK )
    {
        ContextHandle->ConnectionType = CONNTYPE_PRINT;
        ContextHandle->ResumeId = (DWORD_PTR) -1;
    }

    //
    // The user needs to be validated on a netware311 server to
    // get the print queues. So, we need to close the handle and
    // open a new one with WRITE access. If any error occurred while
    // we are enumerating the print queues, we will abort and
    // assume there are no print queues on the server.
    //

    if ( FitInBuffer &&
         EntriesRequested > *EntriesRead &&
         ContextHandle->ConnectionType == CONNTYPE_PRINT &&
         status == NO_ERROR )
    {
         UNICODE_STRING TreeConnectStr;
         DWORD QueueEntriesRead = 0;

         (void) NtClose(ContextHandle->TreeConnectionHandle);

         //
         // Open a tree connection handle to \Device\NwRdr\ContainerName
         //
         status = NwCreateTreeConnectName(
                      ContextHandle->ContainerName,
                      NULL,
                      &TreeConnectStr );

         if (status != NO_ERROR)
             return (*EntriesRead? NO_ERROR: WN_NO_MORE_ENTRIES );


         status = NwOpenCreateConnection(
                      &TreeConnectStr,
                      NULL,
                      NULL,
                      ContextHandle->ContainerName,
                      FILE_LIST_DIRECTORY | SYNCHRONIZE |  FILE_WRITE_DATA,
                      FILE_OPEN,
                      FILE_SYNCHRONOUS_IO_NONALERT,
                      RESOURCETYPE_PRINT, // Only matters when connecting beyond servername
                      &ContextHandle->TreeConnectionHandle,
                      NULL );

         (void) LocalFree((HLOCAL) TreeConnectStr.Buffer);

         if (status != NO_ERROR)
             return (*EntriesRead? NO_ERROR: WN_NO_MORE_ENTRIES );

         status = NwEnumQueues(
                      ContextHandle,
                      EntriesRequested == (DWORD_PTR) -1?
                          EntriesRequested : (EntriesRequested - *EntriesRead),
                      FixedPortion,
                      (DWORD) ((LPBYTE) EndOfVariableData - (LPBYTE) FixedPortion),
                      BytesNeeded,
                      &QueueEntriesRead );

         if ( status == NO_ERROR )
         {
             *EntriesRead += QueueEntriesRead;
         }
         else if ( *EntriesRead )
         {
             //
             // As long as we read something into the buffer,
             // we should return success.
             //
             status = NO_ERROR;
             *BytesNeeded = 0;
         }

    }

    if ( status == NO_ERROR &&
         *EntriesRead == 0 &&
         ContextHandle->ConnectionType == CONNTYPE_PRINT )
    {
        return WN_NO_MORE_ENTRIES;
    }

    return status;

}



DWORD
NwEnumQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the queues on a server.
    The queue entries are returned in an array of NETRESOURCE entries;
    each queue name is prefixed by \\Server\.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumQueues
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    DWORD NextObject = (DWORD) ContextHandle->ResumeId;

    SERVERNAME QueueName;          // OEM queue name
    LPWSTR UQueueName = NULL;      // Unicode queue name

    while ( FitInBuffer &&
            EntriesRequested > *EntriesRead &&
            status == NO_ERROR ) {

        RtlZeroMemory(QueueName, sizeof(QueueName));

        //
        // Call the scan bindery object NCP to scan for all file
        // volume objects.
        //
        status = NwGetNextQueueEntry(
                     ContextHandle->TreeConnectionHandle,
                     &NextObject,
                     QueueName
                     );

        if (status == NO_ERROR && NwConvertToUnicode(&UQueueName, QueueName)) {

            //
            // Pack server name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         ContextHandle->ContainerName,
                         NULL,
                         UQueueName,
                         RESOURCE_GLOBALNET,
                         RESOURCEDISPLAYTYPE_SHARE,
                         RESOURCEUSAGE_CONNECTABLE,
                         RESOURCETYPE_PRINT,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA) {

                 //
                 // Could not write current entry into output buffer.
                 //

                 if (*EntriesRead) {
                     //
                     // Still return success because we got at least one.
                     //
                     status = NO_ERROR;
                 }
                 else {
                     *BytesNeeded = EntrySize;
                 }

                 FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR) {

                 //
                 // Note that we've returned the current entry.
                 //
                 (*EntriesRead)++;

                 ContextHandle->ResumeId = (DWORD_PTR) NextObject;
            }

            (void) LocalFree((HLOCAL) UQueueName);
        }
    }

    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumDirectories(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates the directories of a given directory
    handle by calling NtQueryDirectoryFile.  It returns the
    fully-qualified UNC path of the directory entries in an array
    of NETRESOURCE entries.

    The ContextHandle->ResumeId field is 0 initially, and contains
    a pointer to the directory name string of the last directory
    returned.  If there are no more directories to return, this
    field is set to (DWORD_PTR) -1.

Arguments:

    ContextHandle - Supplies the enum context handle.  It contains
        an opened directory handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes required to get the
        first entry.  This value is returned iff WN_MORE_DATA is
        the return code, and Buffer is too small to even fit one
        entry.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.
        NO_ERROR is returned as long as at least one entry was written
        into Buffer but does not necessarily mean that it's the number
        of EntriesRequested.

Return Value:

    NO_ERROR - At least one entry was written to output buffer,
        irregardless of the number requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit a single entry.

--*/ // NwEnumDirectories
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    BOOL FitInBuffer = TRUE;
    DWORD EntrySize;

    if (ContextHandle->ResumeId == (DWORD_PTR) -1) {
        //
        // Reached the end of enumeration.
        //
        return WN_NO_MORE_ENTRIES;
    }

    while (FitInBuffer &&
           EntriesRequested > *EntriesRead &&
           status == NO_ERROR) {

        if (ContextHandle->ResumeId == 0) {

            //
            // Get the first directory entry.
            //
            status = NwGetFirstDirectoryEntry(
                         ContextHandle->TreeConnectionHandle,
                         (LPWSTR *) &ContextHandle->ResumeId
                         );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // NwGetFirstDirectoryEntry or it contains the next directory
        // entry to return.
        //
        if (ContextHandle->ResumeId != 0) {

            //
            // Pack directory name into output buffer.
            //
            status = NwWriteNetResourceEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         ContextHandle->ContainerName,
                         NULL,
                         (LPWSTR) ContextHandle->ResumeId,
                         RESOURCE_GLOBALNET,
                         RESOURCEDISPLAYTYPE_SHARE,
#ifdef NT1057
                         RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_CONTAINER,
#else
                         RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_NOLOCALDEVICE,
#endif
                         RESOURCETYPE_DISK,
                         NULL,
                         NULL,
                         &EntrySize
                         );

            if (status == WN_MORE_DATA) {

                //
                // Could not write current entry into output buffer.
                //

                if (*EntriesRead) {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }
                else {
                    *BytesNeeded = EntrySize;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR) {

                //
                // Note that we've returned the current entry.
                //
                (*EntriesRead)++;

                //
                // Free memory allocated to save resume point, which is
                // a buffer that contains the last directory we returned.
                //
                if (ContextHandle->ResumeId != 0) {
                    (void) LocalFree((HLOCAL) ContextHandle->ResumeId);
                    ContextHandle->ResumeId = 0;
                }

                //
                // Get next directory entry.
                //
                status = NwGetNextDirectoryEntry(
                             (LPWSTR) ContextHandle->TreeConnectionHandle,
                             (LPWSTR *) &ContextHandle->ResumeId
                             );

            }
        }

        if (status == WN_NO_MORE_ENTRIES) {
            ContextHandle->ResumeId = (DWORD_PTR) -1;
        }
    }

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("EnumDirectories returns %lu\n", status));
    }
#endif

    return status;
}


DWORD
NwEnumPrintServers(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the servers and NDS tree on the local network
    by scanning the bindery for file server or directory objects on the
    preferred server.  The server and tree entries are returned in an
    array of PRINTER_INFO_1 entries; each entry name is prefixed by
    \\.

    The ContextHandle->ResumeId field is initially (DWORD_PTR) -1 before
    enumeration begins and contains the object ID of the last server
    object returned.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes copied or required to get all
        the requested entries.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.

Return Value:

    NO_ERROR - Buffer contains all the entries requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit the requested entries.

--*/ // NwEnumPrintServers
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    DWORD EntrySize;
    BOOL FitInBuffer = TRUE;

    SERVERNAME ServerName;          // OEM server name
    LPWSTR UServerName = NULL;      // Unicode server name
    DWORD LastObjectId = (DWORD) ContextHandle->ResumeId;
    WCHAR TempBuffer[500];

    while ( EntriesRequested > *EntriesRead &&
            ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NDS &&
            ((status == NO_ERROR) || (status == ERROR_INSUFFICIENT_BUFFER)))
    {
        //
        // Call the scan bindery object NCP to scan for all NDS
        // tree objects.
        //
        status = NwGetNextNdsTreeEntry( ContextHandle );

        if ( status == NO_ERROR && ContextHandle->ResumeId != 0 )
        {
            //
            // Put tree name into a buffer
            //
            RtlZeroMemory( TempBuffer, 500 );
            wcscat( TempBuffer, (LPWSTR) ContextHandle->ResumeId );

            //
            // Pack server name into output buffer.
            //
            status = NwWritePrinterInfoEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         NULL,
                         TempBuffer, // This is a NDS tree name
                         PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON1,
                         &EntrySize
                         );

            switch ( status )
            {
                case ERROR_INSUFFICIENT_BUFFER:
                    FitInBuffer = FALSE;
                    // Falls through

                case NO_ERROR:
                    *BytesNeeded += EntrySize;
                    (*EntriesRead)++;
                    // ContextHandle->ResumeId = LastObjectId;
                    break;

                default:
                    break;
            }
        }
        else if ( status == WN_NO_MORE_ENTRIES )
        {
            //
            // We processed the last item in list, so
            // start enumerating servers.
            //
            ContextHandle->dwUsingNds = CURRENTLY_ENUMERATING_NON_NDS;
            ContextHandle->ResumeId = (DWORD_PTR) -1;
            LastObjectId = (DWORD) -1;
        }
    }

    status = NO_ERROR;

    while ( EntriesRequested > *EntriesRead &&
            ContextHandle->dwUsingNds == CURRENTLY_ENUMERATING_NON_NDS &&
            ((status == NO_ERROR) || (status == ERROR_INSUFFICIENT_BUFFER))) {

        RtlZeroMemory(ServerName, sizeof(ServerName));

        //
        // Call the scan bindery object NCP to scan for all file
        // server objects.
        //
        status = NwGetNextServerEntry(
                     ContextHandle->TreeConnectionHandle,
                     &LastObjectId,
                     ServerName
                     );

        if (status == NO_ERROR && NwConvertToUnicode(&UServerName,ServerName)) {

            //
            // Pack server name into output buffer.
            //
            status = NwWritePrinterInfoEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         NULL,
                         UServerName,
                         PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON3,
                         &EntrySize
                         );

            switch ( status )
            {
                case ERROR_INSUFFICIENT_BUFFER:
                    FitInBuffer = FALSE;
                    // Falls through

                case NO_ERROR:
                    *BytesNeeded += EntrySize;
                    (*EntriesRead)++;
                    ContextHandle->ResumeId = (DWORD_PTR) LastObjectId;
                    break;

                default:
                    break;
            }

            (void) LocalFree((HLOCAL) UServerName);
        }
    }

    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if ( !FitInBuffer ) {
        *EntriesRead = 0;
        status = ERROR_INSUFFICIENT_BUFFER;
    }
    else if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwEnumPrintQueues(
    IN LPNW_ENUM_CONTEXT ContextHandle,
    IN DWORD_PTR EntriesRequested,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead
    )
/*++

Routine Description:

    This function enumerates all the print queues on a server by scanning
    the bindery on the server for print queues objects.
    The print queues entries are returned in an array of PRINTER_INFO_1 entries
    and each printer name is prefixed by \\Server\.

    The ContextHandle->ResumeId field is initially (DWORD_PTR) -1 before
    enumeration begins and contains the object ID of the last print queue
    object returned.

Arguments:

    ContextHandle - Supplies the enum context handle.

    EntriesRequested - Supplies the number of entries to return.  If
        this value is (DWORD_PTR) -1, return all available entries.

    Buffer - Receives the entries we are listing.

    BufferSize - Supplies the size of the output buffer.

    BytesNeeded - Receives the number of bytes copied or required to get all
        the requested entries.

    EntriesRead - Receives the number of entries returned in Buffer.
        This value is only returned iff NO_ERROR is the return code.

Return Value:

    NO_ERROR - Buffer contains all the entries requested.

    WN_NO_MORE_ENTRIES - No entries left to return.

    WN_MORE_DATA - The buffer was too small to fit the requested entries.

--*/ // NwEnumPrintQueues
{
    DWORD status = NO_ERROR;

    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(BufferSize,ALIGN_DWORD));

    DWORD EntrySize;
    BOOL FitInBuffer = TRUE;

    SERVERNAME QueueName;          // OEM queue name
    LPWSTR UQueueName = NULL;      // Unicode queue name
    DWORD LastObjectId = (DWORD) ContextHandle->ResumeId;

    while ( EntriesRequested > *EntriesRead &&
            ( (status == NO_ERROR) || (status == ERROR_INSUFFICIENT_BUFFER))) {

        RtlZeroMemory(QueueName, sizeof(QueueName));

        //
        // Call the scan bindery object NCP to scan for all file
        // volume objects.
        //
        status = NwGetNextQueueEntry(
                     ContextHandle->TreeConnectionHandle,
                     &LastObjectId,
                     QueueName
                     );

        if (status == NO_ERROR && NwConvertToUnicode(&UQueueName, QueueName)) {

            //
            // Pack server name into output buffer.
            //
            status = NwWritePrinterInfoEntry(
                         &FixedPortion,
                         &EndOfVariableData,
                         ContextHandle->ContainerName,
                         UQueueName,
                         PRINTER_ENUM_ICON8,
                         &EntrySize
                         );

            switch ( status )
            {
                case ERROR_INSUFFICIENT_BUFFER:
                    FitInBuffer = FALSE;
                    // Falls through

                case NO_ERROR:
                    *BytesNeeded += EntrySize;
                    (*EntriesRead)++;
                    ContextHandle->ResumeId = (DWORD_PTR) LastObjectId;
                    break;

                default:
                    break;
            }

            (void) LocalFree((HLOCAL) UQueueName);
        }
    }

    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if ( !FitInBuffer ) {
        *EntriesRead = 0;
        status = ERROR_INSUFFICIENT_BUFFER;
    }
    else if (*EntriesRead && status == WN_NO_MORE_ENTRIES) {
        status = NO_ERROR;
    }

    return status;
}


DWORD
NwrCloseEnum(
    IN OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function closes an enum context handle.

Arguments:

    EnumHandle - Supplies a pointer to the enum context handle.

Return Value:

    WN_BAD_HANDLE - Handle is not recognizable.

    NO_ERROR - Call was successful.

--*/ // NwrCloseEnum
{

    LPNW_ENUM_CONTEXT ContextHandle = (LPNW_ENUM_CONTEXT) *EnumHandle;
    DWORD status = NO_ERROR ;

#if DBG
    IF_DEBUG(ENUM)
    {
       KdPrint(("\nNWWORKSTATION: NwrCloseEnum\n"));
    }
#endif

    if (ContextHandle->Signature != NW_HANDLE_SIGNATURE)
    {
        ASSERT(FALSE);
        return WN_BAD_HANDLE;
    }

    //
    // Resume handle for listing directories is a buffer which contains
    // the last directory returned.
    //
    if (ContextHandle->HandleType == NwsHandleListDirectories &&
        ContextHandle->ResumeId != 0 &&
        ContextHandle->ResumeId != (DWORD_PTR) -1)
    {
        (void) LocalFree((HLOCAL) ContextHandle->ResumeId);
    }

    //
    // NdsRawDataBuffer handle for listing NDS tree subordinates is a buffer which contains
    // the last data chunk returned from redirector.
    //
    if ( ( ContextHandle->HandleType == NwsHandleListNdsSubTrees_Disk ||
           ContextHandle->HandleType == NwsHandleListNdsSubTrees_Print ||
           ContextHandle->HandleType == NwsHandleListNdsSubTrees_Any ||
           ContextHandle->HandleType == NwsHandleListServersAndNdsTrees ) &&
         ContextHandle->NdsRawDataBuffer )
    {
        (void) LocalFree((HLOCAL) ContextHandle->NdsRawDataBuffer);
        ContextHandle->NdsRawDataBuffer = 0;
    }

    if (ContextHandle->TreeConnectionHandle != (HANDLE) NULL)
    {
        if (ContextHandle->HandleType == NwsHandleListDirectories)
        {
            //
            // Delete the UNC connection created so that we can browse
            // directories.
            //
            (void) NwNukeConnection(ContextHandle->TreeConnectionHandle, TRUE);
        }

        if ( ContextHandle->HandleType == NwsHandleListNdsSubTrees_Disk ||
             ContextHandle->HandleType == NwsHandleListNdsSubTrees_Print ||
             ContextHandle->HandleType == NwsHandleListNdsSubTrees_Any )
        {
            //
            // Get rid of the connection to the NDS tree.
            //
            (void) CloseHandle(ContextHandle->TreeConnectionHandle);
            ContextHandle->TreeConnectionHandle = 0;
        }
        else
        {
            (void) NtClose(ContextHandle->TreeConnectionHandle);
            ContextHandle->TreeConnectionHandle = 0;
        }
    }

    ContextHandle->Signature = 0x0BADBAD0;
    (void) LocalFree((HLOCAL) ContextHandle);

    *EnumHandle = NULL;

    return status;
}


DWORD
NwrGetUser(
    IN  LPWSTR Reserved OPTIONAL,
    IN  LPWSTR  lpName,
    OUT LPBYTE  lpUserName,
    IN  DWORD   dwUserNameBufferSize,
    OUT LPDWORD lpdwCharsRequired
    )
/*++

Routine Description:

    This is used to determine either the current default username, or the
    username used to establish a network connection.

Arguments:

    Reserved - Unused.

    lpName - The connection for which user information is requested.

    lpUserName - The buffer to receive the user name associated with the
        connection referred to by lpName.

    dwUserNameLen - The size of the buffer lpUserName.

    lpdwCharsRequired - If return status is WN_MORE_DATA, then this is set to
        the value which indicates the number of characters that the buffer
        lpUserName must hold. Otherwise, this is not set.


Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, an error code is,
        returned, which may include:

    WN_NOT_CONNECTED - lpName not a redirected device nor a connected network
        name.

    WN_MORE_DATA - The buffer is too small.

--*/ // NwrGetUser
{
    DWORD status = NO_ERROR;
    WCHAR lpTempUserName[512];
    WCHAR lpTempHostName[512];

    if (lpName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    status = NwGetConnectionInformation( lpName, lpTempUserName, lpTempHostName );

    if ( status == ERROR_BAD_NETPATH )           
    {
        return WN_NOT_CONNECTED; 
    }
    if ( status != NO_ERROR )
    {
        return status;
    }

    if ( ( ( wcslen( lpTempUserName ) + 1 ) * sizeof(WCHAR) ) > dwUserNameBufferSize )
    {
        *lpdwCharsRequired = wcslen( lpTempUserName ) + 1;
        return WN_MORE_DATA;
    }

    wcscpy( (LPWSTR) lpUserName, lpTempUserName );

    return WN_SUCCESS;
}


DWORD
NwrGetResourceInformation(
    IN  LPWSTR Reserved OPTIONAL,
    IN  LPWSTR  lpRemoteName,
    IN  DWORD   dwType,
    OUT LPBYTE  lpBuffer,
    IN  DWORD   dwBufferSize,
    OUT LPDWORD lpdwBytesNeeded,
    OUT LPDWORD lpdwSystemOffset
    )
/*++

Routine Description:

    This function returns an object which details information
    about a specified network resource.

Arguments:

    Reserved - Unused.
    lpRemoteName - The full path name to be verified.
    dwType - The type of the value, if the calling client knows it.
    lpBuffer - A pointer to a buffer to receive a single NETRESOURCE entry.
    dwBufferSize - The size of the buffer.
    lpdwBytesNeeded - The buffer size needed if WN_MORE_DATA is returned.
    lpdwSystemOffset - A DWORD that is an offset value to the beginning of a
    string that specifies the part of the resource that is accessed through
    resource type specific APIs rather than WNet APIs. The string is stored
    in the same buffer as the returned NETRESOURCE structure, lpBuffer.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination
        of parameters is specified (e.g. lpRemoteName does not correspond
        to dwType).

    WN_BAD_NETNAME - The resource is not recognized by this provider.

--*/ // NwrGetResourceInformation
{
    DWORD    status = NO_ERROR;
    DWORD    EntrySize;

    LPBYTE   FixedPortion = lpBuffer;
    LPWSTR   EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(dwBufferSize,ALIGN_DWORD));
    LPWSTR   lpObjectPathName = NULL;
    LPWSTR   lpSystemPathPart = NULL;
    LPWSTR   lpSystem = NULL;
    DWORD    ClassType;
    DWORD    ResourceScope = RESOURCE_CONTEXT; // prefix issue
    DWORD    ResourceType = 0;
    DWORD    ResourceDisplayType;
    DWORD    ResourceUsage;
    BOOL     fReturnBadNetName = FALSE;

    if (lpRemoteName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwSystemOffset = 0;

    status = NwGetNDSPathInfo( lpRemoteName,
                               &lpObjectPathName,
                               &lpSystemPathPart,
                               &ClassType,
                               &ResourceScope,
                               &ResourceType,
                               &ResourceDisplayType,
                               &ResourceUsage );

    if ( status == VERIFY_ERROR_NOT_A_NDS_TREE )
    {
       //
       // Code to handle \\SERVER\VOL\... here!
       //
       status = NwGetBinderyPathInfo( lpRemoteName,
                                      &lpObjectPathName,
                                      &lpSystemPathPart,
                                      &ClassType,
                                      &ResourceScope,
                                      &ResourceType,
                                      &ResourceDisplayType,
                                      &ResourceUsage );
    }

    if ( status == VERIFY_ERROR_PATH_NOT_FOUND )
    {
        fReturnBadNetName = TRUE;
        status = NO_ERROR;
    }

    if ( status == NO_ERROR &&
         dwType != RESOURCETYPE_ANY &&
         ResourceType != RESOURCETYPE_ANY &&
         dwType != ResourceType )
    {
        status = WN_BAD_VALUE;
    }

    if ( status == NO_ERROR )
    {
        //
        // Pack subtree name into output buffer.
        //
        status = NwWriteNetResourceEntry( &FixedPortion,
                                          &EndOfVariableData,
                                          NULL,
                                          NULL,
                                          lpObjectPathName == NULL ? NwProviderName : lpObjectPathName,
                                          ResourceScope,
                                          ResourceDisplayType,
                                          ResourceUsage,
                                          ResourceType,
                                          lpSystemPathPart,
                                          &lpSystem,
                                          &EntrySize );

        if ( lpObjectPathName )
            (void) LocalFree( (HLOCAL) lpObjectPathName );
    }
    else
    {
        if ( lpSystemPathPart != NULL )
        {
            (void) LocalFree( (HLOCAL) lpSystemPathPart );
            lpSystemPathPart = NULL;
        }

        return status;
    }

    if ( status != NO_ERROR )
    {
        if (status == WN_MORE_DATA)
        {
            //
            // Could not write current entry into output buffer.
            //
            *lpdwBytesNeeded = EntrySize;
        }

        if ( lpSystemPathPart != NULL )
        {
            (void) LocalFree( (HLOCAL) lpSystemPathPart );
            lpSystemPathPart = NULL;
        }

        if ( fReturnBadNetName )
            return WN_BAD_NETNAME;

        return status;
    }
    else
    {
        LPNETRESOURCEW NetR = (LPNETRESOURCEW) lpBuffer;

        //
        // Replace pointers to strings with offsets as need
        //

        if (NetR->lpLocalName != NULL)
        {
            NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) (NetR->lpLocalName) - (DWORD_PTR) lpBuffer);
        }

        NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) (NetR->lpRemoteName) - (DWORD_PTR) lpBuffer);

        if (NetR->lpComment != NULL)
        {
            NetR->lpComment = (LPWSTR) ((DWORD_PTR) (NetR->lpComment) - (DWORD_PTR) lpBuffer);
        }

        if (NetR->lpProvider != NULL)
        {
            NetR->lpProvider = (LPWSTR) ((DWORD_PTR) (NetR->lpProvider) - (DWORD_PTR) lpBuffer);
        }

        if (lpSystem != NULL)
        {
            *lpdwSystemOffset = (DWORD)((DWORD_PTR) lpSystem - (DWORD_PTR) lpBuffer);
        }

        if ( lpSystemPathPart != NULL )
        {
            (void) LocalFree( (HLOCAL) lpSystemPathPart );
            lpSystemPathPart = NULL;
        }

        if ( fReturnBadNetName )
            return WN_BAD_NETNAME;

        return WN_SUCCESS;
    }
}


DWORD
NwrGetResourceParent(
    IN  LPWSTR Reserved OPTIONAL,
    IN  LPWSTR  lpRemoteName,
    IN  DWORD   dwType,
    OUT LPBYTE  lpBuffer,
    IN  DWORD   dwBufferSize,
    OUT LPDWORD lpdwBytesNeeded
    )
/*++

Routine Description:

    This function returns an object which details information
    about the parent of a specified network resource.

Arguments:

    Reserved - Unused.
    lpRemoteName - The full path name of object to find the parent of.
    dwType - The type of the value, if the calling client knows it.
    lpBuffer - A pointer to a buffer to receive a single NETRESOURCE entry.
    dwBufferSize - The size of the buffer.
    lpdwBytesNeeded - The buffer size needed if WN_MORE_DATA is returned.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination
        of parameters is specified (e.g. lpRemoteName does not correspond
        to dwType).

--*/ // NwrGetResourceParent
{
    DWORD    status = NO_ERROR;
    DWORD    EntrySize;

    LPBYTE   FixedPortion = lpBuffer;
    LPWSTR   EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                               ROUND_DOWN_COUNT(dwBufferSize,ALIGN_DWORD));
    LPWSTR   lpRemoteNameParent = NULL;
    LPWSTR   lpFullObjectPathName = NULL;
    DWORD    ClassType;
    DWORD    ResourceScope;
    DWORD    ResourceType;
    DWORD    ResourceDisplayType;
    DWORD    ResourceUsage;
    BOOL     fReturnBadNetName = FALSE;

    if (lpRemoteName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( ! NwGetRemoteNameParent( lpRemoteName, &lpRemoteNameParent ) )
    {
        return WN_BAD_NETNAME;
    }

    status = NwVerifyNDSObject( lpRemoteNameParent,
                                &lpFullObjectPathName,
                                &ClassType,
                                &ResourceScope,
                                &ResourceType,
                                &ResourceDisplayType,
                                &ResourceUsage );

    if ( status == VERIFY_ERROR_NOT_A_NDS_TREE )
    {
       status = NwVerifyBinderyObject( lpRemoteNameParent,
                                       &lpFullObjectPathName,
                                       &ClassType,
                                       &ResourceScope,
                                       &ResourceType,
                                       &ResourceDisplayType,
                                       &ResourceUsage );
    }

    if ( lpRemoteNameParent )
        (void) LocalFree( (HLOCAL) lpRemoteNameParent );

    if ( status == VERIFY_ERROR_PATH_NOT_FOUND )
    {
        fReturnBadNetName = TRUE;
        status = NO_ERROR;
    }

    if ( status == NO_ERROR )
    {
        //
        // Pack subtree name into output buffer.
        //
        status = NwWriteNetResourceEntry( &FixedPortion,
                                          &EndOfVariableData,
                                          NULL,
                                          NULL,
                                          lpFullObjectPathName == NULL ? NwProviderName : lpFullObjectPathName,
                                          ResourceScope,
                                          ResourceDisplayType,
                                          ResourceUsage,
                                          ResourceType,
                                          NULL,
                                          NULL,
                                          &EntrySize );

        if ( lpFullObjectPathName )
            (void) LocalFree( (HLOCAL) lpFullObjectPathName );
    }
    else
    {
        return status;
    }

    if ( status != NO_ERROR )
    {
        if (status == WN_MORE_DATA)
        {
            //
            // Could not write current entry into output buffer.
            //
            *lpdwBytesNeeded = EntrySize;
        }

        if ( fReturnBadNetName )
            return WN_BAD_NETNAME;

        return status;
    }
    else
    {
        LPNETRESOURCEW NetR = (LPNETRESOURCEW) lpBuffer;

        //
        // Replace pointers to strings with offsets as need
        //

        if (NetR->lpLocalName != NULL)
        {
            NetR->lpLocalName = (LPWSTR) ((DWORD_PTR) (NetR->lpLocalName) - (DWORD_PTR) lpBuffer);
        }

        NetR->lpRemoteName = (LPWSTR) ((DWORD_PTR) (NetR->lpRemoteName) - (DWORD_PTR) lpBuffer);

        if (NetR->lpComment != NULL)
        {
            NetR->lpComment = (LPWSTR) ((DWORD_PTR) (NetR->lpComment) - (DWORD_PTR) lpBuffer);
        }

        if (NetR->lpProvider != NULL)
        {
            NetR->lpProvider = (LPWSTR) ((DWORD_PTR) (NetR->lpProvider) - (DWORD_PTR) lpBuffer);
        }

        if ( fReturnBadNetName )
            return WN_BAD_NETNAME;

        return WN_SUCCESS;
    }
}


VOID
NWWKSTA_CONTEXT_HANDLE_rundown(
    IN NWWKSTA_CONTEXT_HANDLE EnumHandle
    )
/*++

Routine Description:

    This function is called by RPC when a client terminates with an
    opened handle.  This allows us to clean up and deallocate any context
    data associated with the handle.

Arguments:

    EnumHandle - Supplies the handle opened for an enumeration.

Return Value:

    None.

--*/
{
    //
    // Call our close handle routine.
    //
    NwrCloseEnum(&EnumHandle);
}


DWORD
NwGetFirstNdsSubTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle,
    IN  DWORD BufferSize
    )
/*++

Routine Description:

    This function is called by NwEnumNdsSubTrees to get the first
    subtree entry given a handle to a NDS tree.  It allocates
    the output buffer to hold the returned subtree name; the
    caller should free this output buffer with LocalFree when done.

Arguments:

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating output
        buffer.

    Other errors from NwNdsList.

--*/ // NwGetFirstNdsSubTreeEntry
{
    NTSTATUS ntstatus;

    ContextHandle->NdsRawDataSize = BufferSize;

    //
    // Determine size of NDS raw data buffer to use.
    //
    if ( ContextHandle->NdsRawDataSize < EIGHT_KB )
        ContextHandle->NdsRawDataSize = EIGHT_KB;

	else	//	dfergus 19 Apr 2001 - 346859
			//	if buffer too big, set to max NDS buffer size
		if (ContextHandle->NdsRawDataSize > 0xFC00) // NW_MAX_BUFFER = 0xFC00
		    ContextHandle->NdsRawDataSize = 0xFC00;


    //
    // Create NDS raw data buffer.
    //
    ContextHandle->NdsRawDataBuffer = (DWORD_PTR)
                           LocalAlloc( LMEM_ZEROINIT, 
                                       ContextHandle->NdsRawDataSize );

    if ( ContextHandle->NdsRawDataBuffer == 0 )
    {
        KdPrint(("NWWORKSTATION: NwGetFirstNdsSubTreeEntry LocalAlloc Failed %lu\n", GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Set up to get initial NDS subordinate list.
    //
    ContextHandle->NdsRawDataId = INITIAL_ITERATION;

    ntstatus = NwNdsList( ContextHandle->TreeConnectionHandle,
                        ContextHandle->dwOid,
                        &ContextHandle->NdsRawDataId,
                        (LPBYTE) ContextHandle->NdsRawDataBuffer,
                        ContextHandle->NdsRawDataSize );

    //
    // If error, clean up the ContextHandle and return.
    //
    if ( ntstatus != STATUS_SUCCESS ||
         ((PNDS_RESPONSE_SUBORDINATE_LIST)
             ContextHandle->NdsRawDataBuffer)->SubordinateEntries == 0 )
    {
        if ( ContextHandle->NdsRawDataBuffer )
            (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );
        ContextHandle->NdsRawDataBuffer = 0;
        ContextHandle->NdsRawDataSize = 0;
        ContextHandle->NdsRawDataId = INITIAL_ITERATION;
        ContextHandle->NdsRawDataCount = 0;
        ContextHandle->ResumeId = 0;

        return WN_NO_MORE_ENTRIES;
    }

    ContextHandle->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                       ContextHandle->NdsRawDataBuffer)->SubordinateEntries - 1;

    ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer +
                              sizeof( NDS_RESPONSE_SUBORDINATE_LIST );

    // Multi-user code merge                  
    // 12/05/96 cjc Fix problem with FileManager not showing all the NDS entries.
    //              Problem occurs when the NDS entries don't fit in 1 NCP packet;
    //              need to keep track of the Iteration # and redo NCP.

    ContextHandle->NdsRawDataId = ((PNDS_RESPONSE_SUBORDINATE_LIST)                           
                                    ContextHandle->NdsRawDataBuffer)->IterationHandle;

    return RtlNtStatusToDosError(ntstatus);
}


DWORD
NwGetNextNdsSubTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    )
/*++

Routine Description:

    This function is called by NwEnumNdsSubTrees to get the next
    NDS subtree entry given a handle to a NDS tree.  It allocates
    the output buffer to hold the returned subtree name; the
    caller should free this output buffer with LocalFree when done.

Arguments:

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating output
        buffer.

    Other errors from NwNdsList.

--*/ // NwGetNextDirectoryEntry
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    PBYTE pbRaw;
    DWORD dwStrLen;


    if ( ContextHandle->NdsRawDataCount == 0 &&
         ContextHandle->NdsRawDataId == INITIAL_ITERATION )
        return WN_NO_MORE_ENTRIES;

    if ( ContextHandle->NdsRawDataCount == 0 &&
         ContextHandle->NdsRawDataId != INITIAL_ITERATION )
    {
        ntstatus = NwNdsList( ContextHandle->TreeConnectionHandle,
                            ContextHandle->dwOid,
                            &ContextHandle->NdsRawDataId,
                            (LPBYTE) ContextHandle->NdsRawDataBuffer,
                            ContextHandle->NdsRawDataSize );

        //
        // If error, clean up the ContextHandle and return.
        //
        if (ntstatus != STATUS_SUCCESS)
        {
            if ( ContextHandle->NdsRawDataBuffer )
                (void) LocalFree( (HLOCAL) ContextHandle->NdsRawDataBuffer );
            ContextHandle->NdsRawDataBuffer = 0;
            ContextHandle->NdsRawDataSize = 0;
            ContextHandle->NdsRawDataId = INITIAL_ITERATION;
            ContextHandle->NdsRawDataCount = 0;

            return WN_NO_MORE_ENTRIES;
        }

        ContextHandle->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                           ContextHandle->NdsRawDataBuffer)->SubordinateEntries - 1;

        ContextHandle->ResumeId = ContextHandle->NdsRawDataBuffer +
                                  sizeof( NDS_RESPONSE_SUBORDINATE_LIST );

        // ---Multi-user change --- 
        // 12/05/96 cjc Fix problem with FileManager not showing all the NDS entries.
        //              Problem occurs when the NDS entries don't fit in 1 NCP packet;
        //              need to keep track of the Iteration # and redo NCP.

        ContextHandle->NdsRawDataId = ((PNDS_RESPONSE_SUBORDINATE_LIST)                           
                                       ContextHandle->NdsRawDataBuffer)->IterationHandle;
        return RtlNtStatusToDosError(ntstatus);
    }

    ContextHandle->NdsRawDataCount--;

    //
    // Move pointer past the fixed header portion of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw = (BYTE *) ContextHandle->ResumeId;
    pbRaw += sizeof( NDS_RESPONSE_SUBORDINATE_ENTRY );

    //
    // Move pointer past the length value of the Class Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof( DWORD );

    //
    // Move pointer past the Class Name string of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw += ROUNDUP4( dwStrLen );

    //
    // Move pointer past the length value of the Object Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof( DWORD );

    ContextHandle->ResumeId = (DWORD_PTR) ( pbRaw + ROUNDUP4( dwStrLen ) );

    return RtlNtStatusToDosError(ntstatus);
}


BYTE
NwGetSubTreeData(
    IN DWORD_PTR NdsRawDataPtr,
    OUT LPWSTR * SubTreeName,
    OUT LPDWORD  ResourceScope,
    OUT LPDWORD  ResourceType,
    OUT LPDWORD  ResourceDisplayType,
    OUT LPDWORD  ResourceUsage,
    OUT LPWSTR * StrippedObjectName
    )
/*++

Routine Description:

    This function is called by NwEnumNdsSubTrees to get the information
    needed to describe a single NETRESOURCE from an entry in the
    NdsRawDataBuffer.

Arguments:

    NdsRawDataPtr - Supplies the pointer to a buffer with the NDS raw data.

    SubTreeName - Receives a pointer to the returned subtree object name
                  found in buffer.

    ResourceScope - Receives the value of the scope for the subtree object
                    found in buffer.

    ResourceType - Receives the value of the type for the subtree object
                   found in buffer.

    ResourceDisplayType - Receives the value of the display type for the
                          subtree object found in buffer.

    ResourceUsage - Receives the value of the usage for the subtree object
                    found in buffer.

    StrippedObjectName - A pointer to receive the address of a buffer which
                         will contain the formatted object name. Callee must
                         free buffer with LocalFree().

Return Value:

    A DWORD with a value that is used to represent NDS object class type..

--*/ // NwGetSubTreeData
{
    PNDS_RESPONSE_SUBORDINATE_ENTRY pSubEntry =
                             (PNDS_RESPONSE_SUBORDINATE_ENTRY) NdsRawDataPtr;
    PBYTE pbRaw;
    DWORD dwStrLen;
    LPWSTR ClassNameStr;

    pbRaw = (BYTE *) pSubEntry;

    //
    // The structure of a NDS_RESPONSE_SUBORDINATE_ENTRY consists of 4 DWORDs
    // followed by two standard NDS format UNICODE strings. Below we jump pbRaw
    // into the buffer, past the 4 DWORDs.
    //
    pbRaw += sizeof( NDS_RESPONSE_SUBORDINATE_ENTRY );

    //
    // Now we get the length of the first string (Base Class).
    //
    dwStrLen = * (DWORD *) pbRaw;

    //
    // Now we point pbRaw to the first WCHAR of the first string (Base Class).
    //
    pbRaw += sizeof( DWORD_PTR );

    ClassNameStr = (LPWSTR) pbRaw;

    //
    // Move pbRaw into the buffer, past the first UNICODE string (WORD aligned)
    //
    pbRaw += ROUNDUP4( dwStrLen );

    //
    // Now we get the length of the second string (Entry Name).
    //
    dwStrLen = * (DWORD *) pbRaw;

    //
    // Now we point pbRaw to the first WCHAR of the second string (Entry Name).
    //
    pbRaw += sizeof( DWORD_PTR );

    *SubTreeName = (LPWSTR) pbRaw;

    //
    // Strip off any CN= stuff from the object name.
    //
    NwStripNdsUncName( *SubTreeName, StrippedObjectName );

    *ResourceScope = RESOURCE_GLOBALNET;

    if ( !wcscmp( ClassNameStr, CLASS_NAME_ALIAS ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_ALIAS;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_AFP_SERVER ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_AFP_SERVER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_BINDERY_OBJECT ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_BINDERY_OBJECT;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_BINDERY_QUEUE ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_BINDERY_QUEUE;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_COMPUTER ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_COMPUTER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_COUNTRY ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_NDSCONTAINER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_COUNTRY;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_DIRECTORY_MAP ) )
    {
        *ResourceType = RESOURCETYPE_DISK;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
#ifdef NT1057
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_CONTAINER;
#else
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_NOLOCALDEVICE;
#endif

        return CLASS_TYPE_DIRECTORY_MAP;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_GROUP ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GROUP;
        *ResourceUsage = 0;

        return CLASS_TYPE_GROUP;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_LOCALITY ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_LOCALITY;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_NCP_SERVER ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_NCP_SERVER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_ORGANIZATION ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_NDSCONTAINER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_ORGANIZATION;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_ORGANIZATIONAL_ROLE ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_ORGANIZATIONAL_ROLE;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_ORGANIZATIONAL_UNIT ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_NDSCONTAINER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_ORGANIZATIONAL_UNIT;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_PRINTER ) )
    {
        *ResourceType = RESOURCETYPE_PRINT;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE;

        return CLASS_TYPE_PRINTER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_PRINT_SERVER ) )
    {
        *ResourceType = RESOURCETYPE_PRINT;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        *ResourceUsage = RESOURCEUSAGE_CONTAINER;

        return CLASS_TYPE_PRINT_SERVER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_PROFILE ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_PROFILE;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_QUEUE ) )
    {
        *ResourceType = RESOURCETYPE_PRINT;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE;

        return CLASS_TYPE_QUEUE;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_TOP ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_TOP;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_USER ) )
    {
        *ResourceType = RESOURCETYPE_ANY;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        *ResourceUsage = 0;

        return CLASS_TYPE_USER;
    }

    if ( !wcscmp( ClassNameStr, CLASS_NAME_VOLUME ) )
    {
        *ResourceType = RESOURCETYPE_DISK;
        *ResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
#ifdef NT1057
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_CONTAINER;
#else
        *ResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                         RESOURCEUSAGE_NOLOCALDEVICE;
#endif

        return CLASS_TYPE_VOLUME;
    }

    //
    // Otherwise if ClassNameStr is something other than Unknown, report it
    //
    if ( wcscmp( ClassNameStr, CLASS_NAME_UNKNOWN ) )
    {
        KdPrint(("NWWORKSTATION: NwGetSubTreeData failed to recognize"));
        KdPrint((" ClassName: %S\n", ClassNameStr));
        KdPrint(("    Setting object attributes to Unknown for now . . .\n"));
    }

    *ResourceType = RESOURCETYPE_ANY;
    *ResourceDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
    *ResourceUsage = 0;

    return CLASS_TYPE_UNKNOWN;
}


VOID
NwStripNdsUncName(
    IN  LPWSTR   ObjectName,
    OUT LPWSTR * StrippedObjectName
    )
{
    WORD slashCount;
    BOOL isNdsUnc;
    LPWSTR FourthSlash;
    LPWSTR TreeName;
    LPWSTR ObjectPath;
    DWORD  TreeNameLen;
    DWORD  ObjectPathLen;
    DWORD  PrefixBytes;
    DWORD  CurrentPathIndex;
    DWORD  StrippedNameLen;
    DWORD  StrippedNameMaxLen = MAX_NDS_NAME_CHARS;
    WCHAR  StrippedName[MAX_NDS_NAME_CHARS];

    *StrippedObjectName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                               (wcslen(ObjectName) + 1) *
                                               sizeof(WCHAR) );

    if ( *StrippedObjectName == NULL )
    {
        return;
    }

    NwpGetUncInfo( ObjectName, &slashCount, &isNdsUnc, &FourthSlash );

    if ( slashCount >= 2 )
    {
        TreeNameLen = NwParseNdsUncPath( &TreeName,
                                         ObjectName, 
                                         PARSE_NDS_GET_TREE_NAME );

        TreeNameLen /= sizeof(WCHAR);

        wcscpy( *StrippedObjectName, L"\\\\" );
        wcsncat( *StrippedObjectName, TreeName, TreeNameLen );

        ObjectPathLen = NwParseNdsUncPath( &ObjectPath,
                                           ObjectName,
                                           PARSE_NDS_GET_PATH_NAME );

        if ( ObjectPathLen == 0 )
        {
            _wcsupr( *StrippedObjectName );

            return;
        }

        wcscat( *StrippedObjectName, L"\\" );
    }
    else
    {
        wcscpy( *StrippedObjectName, L"" );

        ObjectPath = ObjectName;
        ObjectPathLen = wcslen(ObjectName) * sizeof(WCHAR);
    }

    CurrentPathIndex = 0;
    PrefixBytes = 0;
    StrippedNameLen = 0;

    //
    // All of these indexes are in BYTES, not WCHARS!
    //
    while ( ( CurrentPathIndex < ObjectPathLen ) &&
            ( StrippedNameLen < StrippedNameMaxLen ) )
    {
        if ( ObjectPath[CurrentPathIndex / sizeof( WCHAR )] == L'=' )
        {
            CurrentPathIndex += sizeof( WCHAR );
            StrippedNameLen -= PrefixBytes;
            PrefixBytes = 0;

            continue;
        }

        StrippedName[StrippedNameLen / sizeof( WCHAR )] =
            ObjectPath[CurrentPathIndex / sizeof( WCHAR )];

        StrippedNameLen += sizeof( WCHAR );
        CurrentPathIndex += sizeof( WCHAR );

        if ( ObjectPath[CurrentPathIndex / sizeof( WCHAR )] == L'.' )
        {
            PrefixBytes = 0;
            PrefixBytes -= sizeof( WCHAR );
        }
        else
        {
            PrefixBytes += sizeof( WCHAR );
        }
    }

    StrippedName[StrippedNameLen / sizeof( WCHAR )] = L'\0';

    wcscat( *StrippedObjectName, StrippedName );
    _wcsupr( *StrippedObjectName );
}


DWORD
NwVerifyNDSObject(
    IN  LPWSTR   lpNDSObjectNamePath,
    OUT LPWSTR * lpFullNDSObjectNamePath,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    )
{
    DWORD    status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    UNICODE_STRING TreeServerName;
    UNICODE_STRING PathString;
    HANDLE   ConnectionHandle = NULL;
    DWORD    dwHandleType;
    DWORD    dwOid;
    BOOL     fImpersonate = FALSE ;

    if ( lpNDSObjectNamePath == NULL )
    {
        //
        // Handle this as if we are at the root of our provider hierarchy.
        //
        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType = RESOURCETYPE_ANY;
#ifdef NT1057
        *lpResourceDisplayType = 0;
#else
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
#endif
        *lpResourceUsage = RESOURCEUSAGE_CONTAINER;

        *lpFullNDSObjectNamePath = NULL;

        return NO_ERROR;
    }

    TreeServerName.Buffer = NULL;
    PathString.Buffer = NULL;
    TreeServerName.MaximumLength = ( wcslen( lpNDSObjectNamePath ) + 1 ) * sizeof( WCHAR );
    PathString.MaximumLength = ( wcslen( lpNDSObjectNamePath ) + 1 ) * sizeof( WCHAR );

    TreeServerName.Length = NwParseNdsUncPath( (LPWSTR *) &TreeServerName.Buffer,
                                           lpNDSObjectNamePath,
                                           PARSE_NDS_GET_TREE_NAME );

    if ( TreeServerName.Length == 0 || TreeServerName.Buffer == NULL )
    {
        //
        // lpNDSObjectNamePath is not in the form \\name[\blah.blah.blah][\foo][\bar]...
        //
        status = WN_BAD_NETNAME;
        goto ErrorExit;
    }

    //
    // Impersonate the client
    //
    if ( ( status = NwImpersonateClient() ) != NO_ERROR )
    {
        goto ErrorExit;
    }

    fImpersonate = TRUE;

    //
    // Open a connection handle to \\name
    //
    ntstatus = NwNdsOpenGenericHandle( &TreeServerName,
                                       &dwHandleType,
                                       &ConnectionHandle );

    if ( ntstatus != STATUS_SUCCESS )
    {
        //
        // The first part of lpNDSObjectNamePath was neither a NDS tree nor a NCP Server.
        //
        status = WN_BAD_NETNAME;
        goto ErrorExit;
    }

    if ( dwHandleType != HANDLE_TYPE_NDS_TREE )
    {
        //
        // The first part of lpNDSObjectNamePath was not a NDS tree.
        //
        status = VERIFY_ERROR_NOT_A_NDS_TREE;
        goto ErrorExit;
    }

    //
    // Adjust TreeServerName.Length to number of characters.
    //
    TreeServerName.Length /= sizeof(WCHAR);

    //
    // The lpNDSObjectNamePath points to a NDS tree. Now verify that the path is valid.
    //
    PathString.Length = NwParseNdsUncPath( (LPWSTR *) &PathString.Buffer,
                                           lpNDSObjectNamePath,
                                           PARSE_NDS_GET_PATH_NAME );

    if ( PathString.Length == 0 )
    {
        LPWSTR treeNameStr = NULL;

        if ( fImpersonate )
            (void) NwRevertToSelf() ;

        if ( ConnectionHandle )
            CloseHandle( ConnectionHandle );

        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType = RESOURCETYPE_ANY;
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_TREE;
        *lpResourceUsage = RESOURCEUSAGE_CONTAINER;

        //
        // Need to build a string with the new NDS UNC path for subtree object
        //
        treeNameStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                          ( TreeServerName.Length + 3 ) * sizeof(WCHAR) );

        if ( treeNameStr == NULL )
        {
            KdPrint(("NWWORKSTATION: NwVerifyNDSObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy( treeNameStr, L"\\\\" );
        wcsncat( treeNameStr, TreeServerName.Buffer, TreeServerName.Length );
        _wcsupr( treeNameStr );

        *lpFullNDSObjectNamePath = treeNameStr;

        return NO_ERROR;
    }
    else
    {
        WCHAR          lpServerName[NW_MAX_SERVER_LEN];
        UNICODE_STRING ServerName;

        ServerName.Length = 0;
        ServerName.MaximumLength = sizeof( lpServerName );
        ServerName.Buffer = lpServerName;

        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( ConnectionHandle,
                                      &PathString,
                                      &dwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

        if ( ntstatus == STATUS_SUCCESS && ServerName.Length )
        {
            DWORD    dwHandleType;

            //
            // NwNdsResolveName succeeded, but we were referred to
            // another server, though ContextHandle->dwOid is still valid.

            if ( ConnectionHandle )
                CloseHandle( ConnectionHandle );

            ConnectionHandle = NULL;

            //
            // Open a NDS generic connection handle to \\ServerName
            //
            ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                               &dwHandleType,
                                               &ConnectionHandle );

            if ( ntstatus != STATUS_SUCCESS )
            {
                status = RtlNtStatusToDosError(ntstatus);
                goto ErrorExit;
            }

            ASSERT( dwHandleType != HANDLE_TYPE_NCP_SERVER );
        }
    }

    if ( ntstatus != STATUS_SUCCESS )
    {
        LPWSTR treeNameStr = NULL;

        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType = RESOURCETYPE_ANY;
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_TREE;
        *lpResourceUsage = RESOURCEUSAGE_CONTAINER;

        //
        // Need to build a string with the new NDS UNC path for subtree object
        //
        treeNameStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                          ( TreeServerName.Length + 3 ) * sizeof(WCHAR) );

        if ( treeNameStr == NULL )
        {
            KdPrint(("NWWORKSTATION: NwVerifyNDSObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy( treeNameStr, L"\\\\" );
        wcsncat( treeNameStr, TreeServerName.Buffer, TreeServerName.Length );
        _wcsupr( treeNameStr );

        *lpFullNDSObjectNamePath = treeNameStr;

        status = VERIFY_ERROR_PATH_NOT_FOUND;
        goto ErrorExit;
    }

    //
    // Check to see what kind of object is pointed to by lpRemoteName.
    //
    {
        BYTE   RawResponse[TWO_KB];
        PBYTE  pbRawGetInfo;
        DWORD  RawResponseSize = sizeof(RawResponse);
        DWORD  dwStrLen;
        LPWSTR  TreeObjectName;
        LPWSTR StrippedObjectName = NULL;
        LPWSTR newPathStr = NULL;

        ntstatus = NwNdsReadObjectInfo( ConnectionHandle,
                                        dwOid,
                                        RawResponse,
                                        RawResponseSize );

        if ( ntstatus != NO_ERROR )
        {
            status = RtlNtStatusToDosError(ntstatus);
            goto ErrorExit;
        }

        //
        // Get current subtree data from ContextHandle
        //
        *lpClassType = NwGetSubTreeData( (DWORD_PTR) RawResponse,
                                         &TreeObjectName,
                                         lpResourceScope,
                                         lpResourceType,
                                         lpResourceDisplayType,
                                         lpResourceUsage,
                                         &StrippedObjectName );

        if ( StrippedObjectName == NULL )
        {
            KdPrint(("NWWORKSTATION: NwVerifyNDSObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        //
        // Need to build a string with the new NDS UNC path for subtree object
        //
        newPathStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                         ( wcslen( StrippedObjectName ) +
                                           TreeServerName.Length + 4 )
                                         * sizeof(WCHAR) );

        if ( newPathStr == NULL )
        {
            (void) LocalFree((HLOCAL) StrippedObjectName);

            KdPrint(("NWWORKSTATION: NwVerifyNDSObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy( newPathStr, L"\\\\" );
        wcsncat( newPathStr, TreeServerName.Buffer, TreeServerName.Length );
        wcscat( newPathStr, L"\\" );
        wcscat( newPathStr, StrippedObjectName );
        _wcsupr( newPathStr );

        //
        // Don't need the StrippedObjectName string anymore
        //
        (void) LocalFree((HLOCAL) StrippedObjectName);
        StrippedObjectName = NULL;

        *lpFullNDSObjectNamePath = newPathStr;
        status = NO_ERROR;
    } // End of Block

ErrorExit:

    if ( fImpersonate )
        (void) NwRevertToSelf() ;

    if ( ConnectionHandle )
        CloseHandle( ConnectionHandle );

    return status;
}


DWORD
NwVerifyBinderyObject(
    IN  LPWSTR   lpBinderyObjectPathName,
    OUT LPWSTR * lpFullBinderyObjectPathName,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    )
{
    DWORD    status = NO_ERROR;
    HANDLE   ConnectionHandle = NULL;
    BOOL     fImpersonate = FALSE ;
    BOOL     fResourceTypeDisk = FALSE ;
    BOOL     fIsNdsUnc = FALSE ;
    UNICODE_STRING BinderyConnectStr;
    ULONG    CreateDisposition = 0;
    ULONG    CreateOptions = 0;
    WORD     wSlashCount;
    LPWSTR   FourthSlash;

    if ( lpBinderyObjectPathName == NULL )
    {
        //
        // Handle this as if we are at the root of our provider hierarchy.
        //
        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType = RESOURCETYPE_ANY;
#ifdef NT1057
        *lpResourceDisplayType = 0;
#else
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
#endif
        *lpResourceUsage = RESOURCEUSAGE_CONTAINER;

        *lpFullBinderyObjectPathName = NULL;

        return NO_ERROR;
    }

    //
    // Open a connection handle to \\server\vol\...
    //

    BinderyConnectStr.Buffer = NULL;

    //
    // Find out if we are looking at a \\server, \\server\vol, or
    // \\server\vol\dir . . .
    //
    NwpGetUncInfo( lpBinderyObjectPathName,
                   &wSlashCount,
                   &fIsNdsUnc,
                   &FourthSlash );

    if ( wSlashCount > 2 )
        fResourceTypeDisk = TRUE;

    //
    // Impersonate the client
    //
    if ( ( status = NwImpersonateClient() ) != NO_ERROR )
    {
        goto ErrorExit;
    }

    fImpersonate = TRUE;

    //
    // Open a tree connection handle to \Device\NwRdr\ContainerName
    //
    status = NwCreateTreeConnectName( lpBinderyObjectPathName,
                                      NULL,
                                      &BinderyConnectStr );

    if ( status != NO_ERROR )
    {
        status = WN_BAD_NETNAME;
        goto ErrorExit;
    }

    CreateDisposition = FILE_OPEN;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;

    status = NwOpenCreateConnection( &BinderyConnectStr,
                                     NULL,
                                     NULL,
                                     lpBinderyObjectPathName,
                                     FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                     CreateDisposition,
                                     CreateOptions,
                                     RESOURCETYPE_DISK, // When connecting beyond servername
                                     &ConnectionHandle,
                                     NULL );

    if ( status == NO_ERROR )
    {
        LPWSTR BinderyNameStr = NULL;

        //
        // Need to build a string with the new UNC path for bindery object
        //
        BinderyNameStr = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                             ( wcslen( lpBinderyObjectPathName ) + 1 )
                                             * sizeof(WCHAR) );

        if ( BinderyNameStr == NULL )
        {
            KdPrint(("NWWORKSTATION: NwVerifyBinderyObject LocalAlloc Failed %lu\n",
            GetLastError()));
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy( BinderyNameStr, lpBinderyObjectPathName );
        _wcsupr( BinderyNameStr );

        *lpFullBinderyObjectPathName = BinderyNameStr;

        if ( BinderyConnectStr.Buffer )
            (void) LocalFree((HLOCAL) BinderyConnectStr.Buffer);

        if ( fImpersonate )
            (void) NwRevertToSelf() ;

        if ( ConnectionHandle )
        {
            *lpResourceScope = RESOURCE_GLOBALNET;
            *lpResourceType = fResourceTypeDisk ?
                              RESOURCETYPE_DISK :
                              RESOURCETYPE_ANY;
            *lpResourceDisplayType = fResourceTypeDisk ?
                                     RESOURCEDISPLAYTYPE_SHARE :
                                     RESOURCEDISPLAYTYPE_SERVER;
#ifdef NT1057
            *lpResourceUsage = fResourceTypeDisk ?
                               RESOURCEUSAGE_CONNECTABLE |
                               RESOURCEUSAGE_CONTAINER :
                               RESOURCEUSAGE_CONTAINER;
#else
            *lpResourceUsage = fResourceTypeDisk ?
                               RESOURCEUSAGE_CONNECTABLE |
                               RESOURCEUSAGE_NOLOCALDEVICE :
                               RESOURCEUSAGE_CONTAINER;
#endif

            CloseHandle( ConnectionHandle );
        }

        return NO_ERROR;
    }

ErrorExit:

    *lpFullBinderyObjectPathName = NULL;

    if ( BinderyConnectStr.Buffer )
        (void) LocalFree((HLOCAL) BinderyConnectStr.Buffer);

    if ( fImpersonate )
        (void) NwRevertToSelf() ;

    if ( ConnectionHandle )
        CloseHandle( ConnectionHandle );

    return WN_BAD_NETNAME;
}


DWORD
NwGetNDSPathInfo(
    IN  LPWSTR   lpNDSObjectNamePath,
    OUT LPWSTR * lppSystemObjectNamePath,
    OUT LPWSTR * lpSystemPathPart,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    )
{
    DWORD    status = NO_ERROR;
    WORD     slashCount;
    BOOL     isNdsUnc;
    BOOL     fReturnBadNetName = FALSE;
    LPWSTR   FourthSlash;
    LPWSTR   lpSystemPath = NULL;

    *lpSystemPathPart = NULL;

    NwpGetUncInfo( lpNDSObjectNamePath,
                   &slashCount,
                   &isNdsUnc,
                   &FourthSlash );

    if ( slashCount <= 3 )
    {
        //
        // Path is to a possible NDS object, check to see if so and if valid...
        //

        status = NwVerifyNDSObject( lpNDSObjectNamePath,
                                    lppSystemObjectNamePath,
                                    lpClassType,
                                    lpResourceScope,
                                    lpResourceType,
                                    lpResourceDisplayType,
                                    lpResourceUsage );

        *lpSystemPathPart = NULL;

        return status;
    }
    else
    {
        //
        // Path is to a directory, see if directory exists . . .
        //
        status = NwVerifyBinderyObject( lpNDSObjectNamePath,
                                        lppSystemObjectNamePath,
                                        lpClassType,
                                        lpResourceScope,
                                        lpResourceType,
                                        lpResourceDisplayType,
                                        lpResourceUsage );
    }

    if ( status == WN_BAD_NETNAME )
    {
        fReturnBadNetName = TRUE;
        status = NO_ERROR;
    }

    if ( status == NO_ERROR )
    {
        WCHAR TempNDSObjectNamePath[256];

        //
        // Test \\tree\obj.obj... component and
        // return network resource for valid parent and the string,
        // lpSystemPathPart, for the directory part ( \dir1\...).
        //

        if ( *lppSystemObjectNamePath != NULL )
        {
            (void) LocalFree( (HLOCAL) (*lppSystemObjectNamePath) );
            *lppSystemObjectNamePath = NULL;
        }

        lpSystemPath = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                            ( wcslen( FourthSlash ) + 1 ) *
                                              sizeof( WCHAR ) );

        if ( lpSystemPath == NULL )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy( lpSystemPath, FourthSlash );
        *FourthSlash = L'\0';

        wcscpy( TempNDSObjectNamePath, lpNDSObjectNamePath );
        *FourthSlash = L'\\';

        //
        // See if \\tree\obj.obj.... exists . . .
        //
        status = NwVerifyNDSObject( TempNDSObjectNamePath,
                                    lppSystemObjectNamePath,
                                    lpClassType,
                                    lpResourceScope,
                                    lpResourceType,
                                    lpResourceDisplayType,
                                    lpResourceUsage );

        if ( status != NO_ERROR )
        {
            LocalFree( lpSystemPath );
            lpSystemPath = NULL;
        }
    }

    *lpSystemPathPart = lpSystemPath;

    //
    // The provider spec for this function used to tell us to create a 
    // NETRESOURCE, even if the system part of the path was invalid, while
    // returning WN_BAD_NETNAME. Now we return SUCCESS and the NETRESOURCE, 
    // irregardless of whether the lpSystem part is valid.
    // if ( fReturnBadNetName == TRUE )
    // {
    //     return WN_BAD_NETNAME;
    // }

    return status;
}


DWORD
NwGetBinderyPathInfo(
    IN  LPWSTR   lpBinderyObjectNamePath,
    OUT LPWSTR * lppSystemObjectNamePath,
    OUT LPWSTR * lpSystemPathPart,
    OUT LPDWORD  lpClassType,
    OUT LPDWORD  lpResourceScope,
    OUT LPDWORD  lpResourceType,
    OUT LPDWORD  lpResourceDisplayType,
    OUT LPDWORD  lpResourceUsage
    )
{
    DWORD    status = NO_ERROR;
    WORD     slashCount;
    BOOL     isNdsUnc;
    LPWSTR   FourthSlash;
    LPWSTR   lpSystemPath = NULL;

    *lpSystemPathPart = NULL;

    NwpGetUncInfo( lpBinderyObjectNamePath,
                   &slashCount,
                   &isNdsUnc,
                   &FourthSlash );

    if ( slashCount <= 3 )
    {
        //
        // Path is to a server or volume, check to see which and if valid . . .
        //

        status = NwVerifyBinderyObject( lpBinderyObjectNamePath,
                                        lppSystemObjectNamePath,
                                        lpClassType,
                                        lpResourceScope,
                                        lpResourceType,
                                        lpResourceDisplayType,
                                        lpResourceUsage );

        *lpSystemPathPart = NULL;

        return status;
    }
    else
    {
        //
        // Path is to a directory, see if directory exists . . .
        //
        status = NwVerifyBinderyObject( lpBinderyObjectNamePath,
                                        lppSystemObjectNamePath,
                                        lpClassType,
                                        lpResourceScope,
                                        lpResourceType,
                                        lpResourceDisplayType,
                                        lpResourceUsage );
    }

    if ( status == WN_BAD_NETNAME )
    {
        WCHAR TempBinderyObjectNamePath[256];

        //
        // Path is to a invalid directory. Test \\server\volume component and
        // return network resource for valid parent and the string,
        // lpSystemPathPart, for the directory part ( \dir1\...).
        //

        lpSystemPath = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                            ( wcslen( FourthSlash ) + 1 ) *
                                              sizeof( WCHAR ) );

        if ( lpSystemPath == NULL )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy( lpSystemPath, FourthSlash );
        *FourthSlash = L'\0';

        wcscpy( TempBinderyObjectNamePath, lpBinderyObjectNamePath );
        *FourthSlash = L'\\';

        //
        // See if \\server\volume exists . . .
        //
        status = NwVerifyBinderyObject( TempBinderyObjectNamePath,
                                        lppSystemObjectNamePath,
                                        lpClassType,
                                        lpResourceScope,
                                        lpResourceType,
                                        lpResourceDisplayType,
                                        lpResourceUsage );

        if ( status != NO_ERROR )
        {
            LocalFree( lpSystemPath );
            lpSystemPath = NULL;
        }

        //
        // Return SUCCESS, since the NETRESOURCE for \\server\volume that
        // we are describing is at least valid, even though the lpSystem
        // part in not. This is a change in the provider spec (4/25/96).
        //
        // else
        // {
        //     status = WN_BAD_NETNAME;
        // }
    }
    else
    {
        //
        // Path is to a valid directory. Return resource information for the
        // \\server\volume component and the string, lpSystemPathPart, for the
        // directory part ( \dir1\...).
        //
        NwpGetUncInfo( *lppSystemObjectNamePath,
                       &slashCount,
                       &isNdsUnc,
                       &FourthSlash );

        lpSystemPath = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                            ( wcslen( FourthSlash ) + 1 ) *
                                              sizeof( WCHAR ) );

        if ( lpSystemPath == NULL )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy( lpSystemPath, FourthSlash );
        *FourthSlash = L'\0';

        *lpResourceScope = RESOURCE_GLOBALNET;
        *lpResourceType =  RESOURCETYPE_DISK;
        *lpResourceDisplayType = RESOURCEDISPLAYTYPE_SHARE;
#ifdef NT1057
        *lpResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                           RESOURCEUSAGE_CONTAINER;
#else
        *lpResourceUsage = RESOURCEUSAGE_CONNECTABLE |
                           RESOURCEUSAGE_NOLOCALDEVICE;
#endif

        status = NO_ERROR;
    }

    *lpSystemPathPart = lpSystemPath;

    return status;
}


BOOL
NwGetRemoteNameParent(
    IN  LPWSTR   lpRemoteName,
    OUT LPWSTR * lpRemoteNameParent
    )
{
    unsigned short iter = 0;
    unsigned short totalLength = (USHORT) wcslen( lpRemoteName );
    unsigned short slashCount = 0;
    unsigned short dotCount = 0;
    unsigned short thirdSlash = 0;
    unsigned short lastSlash = 0;
    unsigned short parentNDSSubTree = 0;
    LPWSTR         newRemoteNameParent = NULL;

    if ( totalLength < 2 )
        return FALSE;

    //
    // Get thirdSlash to indicate the character in the string that indicates the
    // "\" in between the tree name and the rest of the UNC path. Set parentNDSSubTree
    // if available. And always set lastSlash to the most recent "\" seen as you walk.
    //
    // Example:  \\<tree name>\path.to.object[\|.]<object>
    //                        ^    ^
    //                        |    |
    //                thirdSlash  parentNDSSubTree
    //
    while ( iter < totalLength )
    {
        if ( lpRemoteName[iter] == L'\\' )
        {
            slashCount += 1;
            if ( slashCount == 3 )
                thirdSlash = iter;

            lastSlash = iter;
        }

        if ( lpRemoteName[iter] == L'.' )
        {
            dotCount += 1;
            if ( dotCount == 1 )
                parentNDSSubTree = iter;
        }

        iter++;
    }

    if ( slashCount > 3 )
    {
        newRemoteNameParent = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                                  ( lastSlash + 1 ) *
                                                  sizeof(WCHAR));

        if ( newRemoteNameParent == NULL )
        {
            KdPrint(("NWWORKSTATION: NwGetRemoteNameParent LocalAlloc Failed %lu\n",
            GetLastError()));
            return FALSE;
        }

        wcsncpy( newRemoteNameParent, lpRemoteName, lastSlash );
        _wcsupr( newRemoteNameParent );

        *lpRemoteNameParent = newRemoteNameParent;

        return TRUE;
    }

    if ( slashCount == 3 )
    {
        if ( dotCount == 0 )
        {
            newRemoteNameParent = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                                      ( lastSlash + 1 ) *
                                                      sizeof(WCHAR));

            if ( newRemoteNameParent == NULL )
            {
                KdPrint(("NWWORKSTATION: NwGetRemoteNameParent LocalAlloc Failed %lu\n",
                GetLastError()));
                return FALSE;
            }

            wcsncpy( newRemoteNameParent, lpRemoteName, lastSlash );
            _wcsupr( newRemoteNameParent );

            *lpRemoteNameParent = newRemoteNameParent;

            return TRUE;
        }
        else
        {
            newRemoteNameParent = (PVOID) LocalAlloc( LMEM_ZEROINIT,
                                                      ( totalLength -
                                                        ( parentNDSSubTree - thirdSlash )
                                                        + 1 )
                                                      * sizeof(WCHAR) );

            if ( newRemoteNameParent == NULL )
            {
                KdPrint(("NWWORKSTATION: NwGetRemoteNameParent LocalAlloc Failed %lu\n",
                GetLastError()));
                return FALSE;
            }

            wcsncpy( newRemoteNameParent, lpRemoteName, thirdSlash + 1 );
            wcscat( newRemoteNameParent, &lpRemoteName[parentNDSSubTree+1] );
            _wcsupr( newRemoteNameParent );

            *lpRemoteNameParent = newRemoteNameParent;

            return TRUE;
        }
    }

    // Else we set lpRemoteNameParent to NULL, to indicate that we are at the top and
    // return TRUE.
    *lpRemoteNameParent = NULL;

    return TRUE;
}


DWORD
NwGetFirstDirectoryEntry(
    IN HANDLE DirHandle,
    OUT LPWSTR *DirEntry
    )
/*++

Routine Description:

    This function is called by NwEnumDirectories to get the first
    directory entry given a handle to the directory.  It allocates
    the output buffer to hold the returned directory name; the
    caller should free this output buffer with LocalFree when done.

Arguments:

    DirHandle - Supplies the opened handle to the container
        directory find a directory within it.

    DirEntry - Receives a pointer to the returned directory
        found.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating output
        buffer.

    Other errors from NtQueryDirectoryFile.

--*/ // NwGetFirstDirectoryEntry
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    PFILE_DIRECTORY_INFORMATION DirInfo;

    UNICODE_STRING StartFileName;

#if DBG
    DWORD i = 0;
#endif

    //
    // Allocate a large buffer to get one directory information entry.
    //
    DirInfo = (PVOID) LocalAlloc(
                          LMEM_ZEROINIT,
                          sizeof(FILE_DIRECTORY_INFORMATION) +
                              (MAX_PATH * sizeof(WCHAR))
                          );

    if (DirInfo == NULL) {
        KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlInitUnicodeString(&StartFileName, L"*");

    ntstatus = NtQueryDirectoryFile(
                   DirHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   DirInfo,
                   sizeof(FILE_DIRECTORY_INFORMATION) +
                       (MAX_PATH * sizeof(WCHAR)),
                   FileDirectoryInformation,   // Info class requested
                   TRUE,                       // Return single entry
                   &StartFileName,             // Redirector needs this
                   TRUE                        // Restart scan
                   );

    //
    // For now, if buffer to NtQueryDirectoryFile is too small, just give
    // up.  We may want to try to reallocate a bigger buffer at a later time.
    //

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ntstatus != STATUS_SUCCESS) {

        if (ntstatus == STATUS_NO_MORE_FILES) {
            //
            // We ran out of entries.
            //
            status = WN_NO_MORE_ENTRIES;
        }
        else {
            KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry: NtQueryDirectoryFile returns %08lx\n",
                     ntstatus));
            status = RtlNtStatusToDosError(ntstatus);
        }

        goto CleanExit;
    }

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("GetFirst(%u) got %ws, attributes %08lx\n", ++i,
                 DirInfo->FileName, DirInfo->FileAttributes));
    }
#endif

    //
    // Scan until we find the first directory entry that is not "." or ".."
    //
    while (!(DirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
           memcmp(DirInfo->FileName, L".", DirInfo->FileNameLength) == 0 ||
           memcmp(DirInfo->FileName, L"..", DirInfo->FileNameLength) == 0) {

        ntstatus = NtQueryDirectoryFile(
                       DirHandle,
                       NULL,
                       NULL,
                       NULL,
                       &IoStatusBlock,
                       DirInfo,
                       sizeof(FILE_DIRECTORY_INFORMATION) +
                           (MAX_PATH * sizeof(WCHAR)),
                       FileDirectoryInformation,   // Info class requested
                       TRUE,                       // Return single entry
                       NULL,
                       FALSE                       // Restart scan
                       );

        if (ntstatus == STATUS_SUCCESS) {
            ntstatus = IoStatusBlock.Status;
        }

        if (ntstatus != STATUS_SUCCESS) {

            if (ntstatus == STATUS_NO_MORE_FILES) {
                //
                // We ran out of entries.
                //
                status = WN_NO_MORE_ENTRIES;
            }
            else {
                KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry: NtQueryDirectoryFile returns %08lx\n",
                         ntstatus));
                status = RtlNtStatusToDosError(ntstatus);
            }

            goto CleanExit;
        }

#if DBG
        IF_DEBUG(ENUM) {
            KdPrint(("GetFirst(%u) got %ws, attributes %08lx\n", ++i,
                     DirInfo->FileName, DirInfo->FileAttributes));
        }
#endif
    }

    //
    // Allocate the output buffer for the returned directory name
    //
    *DirEntry = (PVOID) LocalAlloc(
                            LMEM_ZEROINIT,
                            DirInfo->FileNameLength + sizeof(WCHAR)
                            );

    if (*DirEntry == NULL) {
        KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry LocalAlloc Failed %lu\n",
                 GetLastError()));
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    memcpy(*DirEntry, DirInfo->FileName, DirInfo->FileNameLength);

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetFirstDirectoryEntry returns %ws\n",
                 *DirEntry));
    }
#endif

    status = NO_ERROR;

CleanExit:
    (void) LocalFree((HLOCAL) DirInfo);

    //
    // We could not find any directories under the requested
    // so we need to treat this as no entries.
    //
    if ( status == ERROR_FILE_NOT_FOUND )
        status = WN_NO_MORE_ENTRIES;

    return status;
}



DWORD
NwGetNextDirectoryEntry(
    IN HANDLE DirHandle,
    OUT LPWSTR *DirEntry
    )
/*++

Routine Description:

    This function is called by NwEnumDirectories to get the next
    directory entry given a handle to the directory.  It allocates
    the output buffer to hold the returned directory name; the
    caller should free this output buffer with LocalFree when done.

Arguments:

    DirHandle - Supplies the opened handle to the container
        directory find a directory within it.

    DirEntry - Receives a pointer to the returned directory
        found.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Out of memory allocating output
        buffer.

    Other errors from NtQueryDirectoryFile.

--*/ // NwGetNextDirectoryEntry
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    PFILE_DIRECTORY_INFORMATION DirInfo;

    //
    // Allocate a large buffer to get one directory information entry.
    //
    DirInfo = (PVOID) LocalAlloc(
                          LMEM_ZEROINIT,
                          sizeof(FILE_DIRECTORY_INFORMATION) +
                              (MAX_PATH * sizeof(WCHAR))
                          );

    if (DirInfo == NULL) {
        KdPrint(("NWWORKSTATION: NwGetNextDirectoryEntry LocalAlloc Failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do {

        ntstatus = NtQueryDirectoryFile(
                       DirHandle,
                       NULL,
                       NULL,
                       NULL,
                       &IoStatusBlock,
                       DirInfo,
                       sizeof(FILE_DIRECTORY_INFORMATION) +
                           (MAX_PATH * sizeof(WCHAR)),
                       FileDirectoryInformation,   // Info class requested
                       TRUE,                       // Return single entry
                       NULL,
                       FALSE                       // Restart scan
                       );

        if (ntstatus == STATUS_SUCCESS) {
            ntstatus = IoStatusBlock.Status;
        }

    } while (ntstatus == STATUS_SUCCESS &&
             !(DirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY));


    if (ntstatus != STATUS_SUCCESS) {

        if (ntstatus == STATUS_NO_MORE_FILES) {
            //
            // We ran out of entries.
            //
            status = WN_NO_MORE_ENTRIES;
        }
        else {
            KdPrint(("NWWORKSTATION: NwGetNextDirectoryEntry: NtQueryDirectoryFile returns %08lx\n",
                     ntstatus));
            status = RtlNtStatusToDosError(ntstatus);
        }

        goto CleanExit;
    }


    //
    // Allocate the output buffer for the returned directory name
    //
    *DirEntry = (PVOID) LocalAlloc(
                            LMEM_ZEROINIT,
                            DirInfo->FileNameLength + sizeof(WCHAR)
                            );

    if (*DirEntry == NULL) {
        KdPrint(("NWWORKSTATION: NwGetNextDirectoryEntry LocalAlloc Failed %lu\n",
                 GetLastError()));
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    memcpy(*DirEntry, DirInfo->FileName, DirInfo->FileNameLength);

#if DBG
   IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextDirectoryEntry returns %ws\n",
                 *DirEntry));
    }
#endif

    status = NO_ERROR;

CleanExit:
    (void) LocalFree((HLOCAL) DirInfo);

    return status;
}


DWORD
NwWriteNetResourceEntry(
    IN OUT LPBYTE * FixedPortion,
    IN OUT LPWSTR * EndOfVariableData,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD ScopeFlag,
    IN DWORD DisplayFlag,
    IN DWORD UsageFlag,
    IN DWORD ResourceType,
    IN LPWSTR SystemPath OPTIONAL,
    OUT LPWSTR * lppSystem OPTIONAL,
    OUT LPDWORD EntrySize
    )
/*++

Routine Description:

    This function packages a NETRESOURCE entry into the user output buffer.
    It is called by the various enum resource routines.

Arguments:

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated to point to the next fixed portion entry
        after a NETRESOURCE entry is written.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the
        user information is written into the output buffer starting from
        the end.

        This pointer is updated after any variable length information is
        written to the output buffer.

    ContainerName - Supplies the full path qualifier to make RemoteName
        a full UNC name.

    LocalName - Supplies the local device name, if any.

    RemoteName - Supplies the remote resource name.

    ScopeFlag - Supplies the flag which indicates whether this is a
        CONNECTED or GLOBALNET resource.

    DisplayFlag - Supplies the flag which tells the UI how to display
        the resource.

    UsageFlag - Supplies the flag which indicates that the RemoteName
        is either a container or a connectable resource or both.

    SystemPath - Supplies the optional system path data to be stored in the
        NETRESOURCE buffer. This is used by the NPGetResourceInformation
        helper routines.

    lppSystem - If SystemPath is provided, this will point to the location
        in the NETRESOURCE buffer that contains the system path string.

    EntrySize - Receives the size of the NETRESOURCE entry in bytes.

Return Value:

    NO_ERROR - Successfully wrote entry into user buffer.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate work buffer.

    WN_MORE_DATA - Buffer was too small to fit entry.

--*/ // NwWriteNetResourceEntry
{
    BOOL FitInBuffer = TRUE;
    LPNETRESOURCEW NetR = (LPNETRESOURCEW) *FixedPortion;
    LPWSTR RemoteBuffer;
    LPWSTR lpSystem;

    *EntrySize = sizeof(NETRESOURCEW) +
                     (wcslen(RemoteName) + wcslen(NwProviderName) + 2) *
                          sizeof(WCHAR);


    if (ARGUMENT_PRESENT(LocalName)) {
        *EntrySize += (wcslen(LocalName) + 1) * sizeof(WCHAR);
    }

    if (ARGUMENT_PRESENT(ContainerName)) {
        *EntrySize += wcslen(ContainerName) * sizeof(WCHAR);
    }

    if (ARGUMENT_PRESENT(SystemPath)) {
        *EntrySize += wcslen(SystemPath) * sizeof(WCHAR);
    }

    *EntrySize = ROUND_UP_COUNT( *EntrySize, ALIGN_DWORD);

    //
    // See if buffer is large enough to fit the entry.
    //
    if ((LPWSTR) ( *FixedPortion + *EntrySize) > *EndOfVariableData) {

        return WN_MORE_DATA;
    }

    NetR->dwScope = ScopeFlag;
    NetR->dwType = ResourceType;
    NetR->dwDisplayType = DisplayFlag;
    NetR->dwUsage = UsageFlag;
    NetR->lpComment = NULL;

    //
    // Update fixed entry pointer to next entry.
    //
    (*FixedPortion) += sizeof(NETRESOURCEW);

    //
    // RemoteName
    //
    if (ARGUMENT_PRESENT(ContainerName)) {

        //
        // Prefix the RemoteName with its container name making the
        // it a fully-qualified UNC name.
        //
        RemoteBuffer = (PVOID) LocalAlloc(
                                   LMEM_ZEROINIT,
                                   (wcslen(RemoteName) + wcslen(ContainerName) + 1) *
                                        sizeof(WCHAR)
                                   );

        if (RemoteBuffer == NULL) {
            KdPrint(("NWWORKSTATION: NwWriteNetResourceEntry LocalAlloc failed %lu\n",
                     GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(RemoteBuffer, ContainerName);
        wcscat(RemoteBuffer, RemoteName);
    }
    else {
        RemoteBuffer = RemoteName;
    }

    FitInBuffer = NwlibCopyStringToBuffer(
                      RemoteBuffer,
                      wcslen(RemoteBuffer),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &NetR->lpRemoteName
                      );

    if (ARGUMENT_PRESENT(ContainerName)) {
        (void) LocalFree((HLOCAL) RemoteBuffer);
    }

    ASSERT(FitInBuffer);

    //
    // LocalName
    //
    if (ARGUMENT_PRESENT(LocalName)) {
        FitInBuffer = NwlibCopyStringToBuffer(
                          LocalName,
                          wcslen(LocalName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &NetR->lpLocalName
                          );

        ASSERT(FitInBuffer);
    }
    else {
        NetR->lpLocalName = NULL;
    }

    //
    // SystemPath
    //
    if (ARGUMENT_PRESENT(SystemPath)) {
        FitInBuffer = NwlibCopyStringToBuffer(
                          SystemPath,
                          wcslen(SystemPath),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &lpSystem
                          );

        ASSERT(FitInBuffer);
    }
    else {
        lpSystem = NULL;
    }

    if (ARGUMENT_PRESENT(lppSystem)) {
        *lppSystem = lpSystem;
    }

    //
    // ProviderName
    //
    FitInBuffer = NwlibCopyStringToBuffer(
                      NwProviderName,
                      wcslen(NwProviderName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &NetR->lpProvider
                      );

    ASSERT(FitInBuffer);

    if (! FitInBuffer) {
        return WN_MORE_DATA;
    }

    return NO_ERROR;
}


DWORD
NwWritePrinterInfoEntry(
    IN OUT LPBYTE *FixedPortion,
    IN OUT LPWSTR *EndOfVariableData,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD  Flags,
    OUT LPDWORD EntrySize
    )
/*++

Routine Description:

    This function packages a PRINTER_INFO_1 entry into the user output buffer.

Arguments:

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated to point to the next fixed portion entry
        after a PRINT_INFO_1 entry is written.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the
        user information is written into the output buffer starting from
        the end.

        This pointer is updated after any variable length information is
        written to the output buffer.

    ContainerName - Supplies the full path qualifier to make RemoteName
        a full UNC name.

    RemoteName - Supplies the remote resource name.

    Flags - Supplies the flag which indicates that the RemoteName
            is either a container or not and the icon to use.

    EntrySize - Receives the size of the PRINTER_INFO_1 entry in bytes.

Return Value:

    NO_ERROR - Successfully wrote entry into user buffer.

    ERROR_NOT_ENOUGH_MEMORY - Failed to allocate work buffer.

    ERROR_INSUFFICIENT_BUFFER - Buffer was too small to fit entry.

--*/ // NwWritePrinterInfoEntry
{
    BOOL FitInBuffer = TRUE;
    PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) *FixedPortion;
    LPWSTR RemoteBuffer;

    *EntrySize = sizeof(PRINTER_INFO_1W) +
                     ( 2 * wcslen(RemoteName) + 2) * sizeof(WCHAR);

    if (ARGUMENT_PRESENT(ContainerName)) {
        *EntrySize += wcslen(ContainerName) * sizeof(WCHAR);
    }
    else {
        // 3 is for the length of "!\\"
        *EntrySize += (wcslen(NwProviderName) + 3) * sizeof(WCHAR);
    }

    *EntrySize = ROUND_UP_COUNT( *EntrySize, ALIGN_DWORD);

    //
    // See if buffer is large enough to fit the entry.
    //
    if ((LPWSTR) (*FixedPortion + *EntrySize) > *EndOfVariableData) {

        return ERROR_INSUFFICIENT_BUFFER;
    }

    pPrinterInfo1->Flags = Flags;
    pPrinterInfo1->pComment = NULL;

    //
    // Update fixed entry pointer to next entry.
    //
    (*FixedPortion) += sizeof(PRINTER_INFO_1W);

    //
    // Name
    //
    if (ARGUMENT_PRESENT(ContainerName)) {

        //
        // Prefix the RemoteName with its container name making the
        // it a fully-qualified UNC name.
        //
        RemoteBuffer = (PVOID) LocalAlloc(
                                   LMEM_ZEROINIT,
                                   (wcslen(ContainerName) + wcslen(RemoteName)
                                    + 1) * sizeof(WCHAR) );

        if (RemoteBuffer == NULL) {
            KdPrint(("NWWORKSTATION: NwWritePrinterInfoEntry LocalAlloc failed %lu\n", GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(RemoteBuffer, ContainerName);
        wcscat(RemoteBuffer, RemoteName);
    }
    else {
        //
        // Prefix the RemoteName with its provider name
        //
        RemoteBuffer = (PVOID) LocalAlloc(
                                   LMEM_ZEROINIT,
                                   (wcslen(RemoteName) +
                                    wcslen(NwProviderName) + 4)
                                    * sizeof(WCHAR) );

        if (RemoteBuffer == NULL) {
            KdPrint(("NWWORKSTATION: NwWritePrinterInfoEntry LocalAlloc failed %lu\n", GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(RemoteBuffer, NwProviderName );
        wcscat(RemoteBuffer, L"!\\\\" );
        wcscat(RemoteBuffer, RemoteName);
    }

    FitInBuffer = NwlibCopyStringToBuffer(
                      RemoteBuffer,
                      wcslen(RemoteBuffer),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &pPrinterInfo1->pName );

    (void) LocalFree((HLOCAL) RemoteBuffer);

    ASSERT(FitInBuffer);

    //
    // Description
    //
    FitInBuffer = NwlibCopyStringToBuffer(
                      RemoteName,
                      wcslen(RemoteName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &pPrinterInfo1->pDescription );

    ASSERT(FitInBuffer);

    if (! FitInBuffer) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    return NO_ERROR;
}


int __cdecl
SortFunc(
    IN CONST VOID *p1,
    IN CONST VOID *p2
)
/*++

Routine Description:

    This function is used in qsort to compare the descriptions of
    two printer_info_1 structure.

Arguments:

    p1 - Points to a PRINTER_INFO_1 structure
    p2 - Points to a PRINTER_INFO_1 structure to compare with p1

Return Value:

    Same as return value of lstrccmpi.

--*/
{
    PRINTER_INFO_1W *pFirst  = (PRINTER_INFO_1W *) p1;
    PRINTER_INFO_1W *pSecond = (PRINTER_INFO_1W *) p2;

    return lstrcmpiW( pFirst->pDescription, pSecond->pDescription );
}



DWORD
NwGetConnectionInformation(
    IN  LPWSTR lpName,
    OUT LPWSTR lpUserName,
    OUT LPWSTR lpHostServer
    )
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr = NULL;
    BOOL  fImpersonate = FALSE ;

    WCHAR OpenString[] = L"\\Device\\Nwrdr\\*";
    UNICODE_STRING OpenName;

    OEM_STRING OemArg;
    UNICODE_STRING ConnectionName;
    WCHAR ConnectionBuffer[512];

    ULONG BufferSize = 512;
    ULONG RequestSize, ReplyLen;
    PNWR_REQUEST_PACKET Request;
    BYTE *Reply;

    PCONN_INFORMATION pConnInfo;
    UNICODE_STRING Name;

    //
    // Allocate buffer space.
    //

    Request = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, BufferSize );

    if ( !Request )
    {
       status = ERROR_NOT_ENOUGH_MEMORY;

        goto ErrorExit;
    }

    //
    // Impersonate the client
    //
    if ( ( status = NwImpersonateClient() ) != NO_ERROR )
    {
        goto ErrorExit;
    }

    fImpersonate = TRUE;

    //
    // Convert the connect name to unicode.
    //
    ConnectionName.Length = wcslen( lpName )* sizeof(WCHAR);
    ConnectionName.MaximumLength = sizeof( ConnectionBuffer );
    ConnectionName.Buffer = ConnectionBuffer;

    if (ConnectionName.Length > MAX_NDS_NAME_SIZE)
    {
        status = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    wcscpy( ConnectionName.Buffer, lpName );
    _wcsupr( ConnectionName.Buffer );

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &OpenName, OpenString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( ntstatus != STATUS_SUCCESS )
    {
        status = RtlNtStatusToDosError(ntstatus);

        goto ErrorExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_INFO.
    //

    Request->Parameters.GetConnInfo.ConnectionNameLength = ConnectionName.Length;
    RtlCopyMemory( &(Request->Parameters.GetConnInfo.ConnectionName[0]),
                   ConnectionBuffer,
                   ConnectionName.Length );

    RequestSize = sizeof( Request->Parameters.GetConnInfo ) + ConnectionName.Length;
    Reply = ((PBYTE)Request) + RequestSize;
    ReplyLen = BufferSize - RequestSize;

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_INFO,
                                (PVOID) Request,
                                RequestSize,
                                (PVOID) Reply,
                                ReplyLen );

    if ( ntstatus != STATUS_SUCCESS )
    {
        status = RtlNtStatusToDosError(ntstatus);

        goto ErrorExit;
    }

    (void) NwRevertToSelf() ;
    fImpersonate = FALSE;

    NtClose( hRdr );

    pConnInfo = (PCONN_INFORMATION) Reply;
    wcscpy( lpUserName, pConnInfo->UserName );
    wcscpy( lpHostServer, pConnInfo->HostServer );

    LocalFree( Request );

    return NO_ERROR;

ErrorExit:

    if ( fImpersonate )
        (void) NwRevertToSelf() ;

    if ( Request )
        LocalFree( Request );

    if ( hRdr )
        NtClose( hRdr );

   return status;
}


VOID
NwpGetUncInfo(
    IN LPWSTR lpstrUnc,
    OUT WORD * slashCount,
    OUT BOOL * isNdsUnc,
    OUT LPWSTR * FourthSlash
    )
{
    WORD   i;
    WORD   length = (WORD) wcslen( lpstrUnc );

    *isNdsUnc = (BOOL) FALSE;
    *slashCount = 0;
    *FourthSlash = NULL;

    for ( i = 0; i < length; i++ )
    {
        if ( lpstrUnc[i] == L'=' )
        {
            *isNdsUnc = TRUE;
        }

        if ( lpstrUnc[i] == L'\\' )
        {
            *slashCount += 1;

            if ( *slashCount == 4 )
            {
                *FourthSlash = &lpstrUnc[i];
            }
        }
    }
}


DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    )
/*++

Routine Description:

    This routine opens the current user's registry key under
    \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NWCWorkstation\Parameters

Arguments:

    DesiredAccess - The access mask to open the key with

    phKeyCurrentUser - Receives the opened key handle

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD err;
    HKEY hkeyWksta;
    LPWSTR CurrentUser;

    HKEY hInteractiveLogonKey;                       //Multi-user
    HKEY OneLogonKey;                                //Multi-user
    LUID logonid;                                    //Multi-user
    WCHAR LogonIdKeyName[NW_MAX_LOGON_ID_LEN];       //Multi-user

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    err = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &hkeyWksta
                   );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open Parameters key unexpected error %lu!\n", err));
        return err;
    }


    //
    // Impersonate the client
    //
    if ( ( err = NwImpersonateClient() ) != NO_ERROR ) {
        (void) RegCloseKey( hkeyWksta );
        return err;
    }

    //
    // Get the NT logon id
    //
    GetLuid( &logonid );

    //
    // Revert
    //
    (void) NwRevertToSelf() ;

    // Open interactive user section

    err = RegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       NW_INTERACTIVE_LOGON_REGKEY,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ,
                       &hInteractiveLogonKey
                       );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open Interactive logon key unexpected error %lu!\n", err));
        (void) RegCloseKey( hkeyWksta );
        return err;
    }

    // Open the logonid

    NwLuidToWStr(&logonid, LogonIdKeyName);

    err = RegOpenKeyExW(
                       hInteractiveLogonKey,
                       LogonIdKeyName,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ,
                       &OneLogonKey
                       );

    (void) RegCloseKey( hInteractiveLogonKey );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open logon key unexpected error %lu!\n", err));
        (void) RegCloseKey( hkeyWksta );
        return err;
    }

    // Read SID 

    err = NwReadRegValue(
                        OneLogonKey,
                        NW_SID_VALUENAME,
                        &CurrentUser
                        );

    (void) RegCloseKey( OneLogonKey );
    (void) RegCloseKey( hkeyWksta );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey read user Sid unexpected error %lu!\n", err));
        return err;
    }

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    err = RegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       NW_WORKSTATION_OPTION_REGKEY,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ,
                       &hkeyWksta
                       );

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open Parameters\\Option key unexpected error %lu!\n", err));
        return err;
    }

    //
    // Open current user's key
    //
    err = RegOpenKeyExW(
              hkeyWksta,
              CurrentUser,
              REG_OPTION_NON_VOLATILE,
              DesiredAccess,
              phKeyCurrentUser
              );

    if ( err == ERROR_FILE_NOT_FOUND)
    {
        DWORD Disposition;

        //
        // Create <NewUser> key under NWCWorkstation\Parameters\Option
        //
        err = RegCreateKeyExW(
                  hkeyWksta,
                  CurrentUser,
                  0,
                  WIN31_CLASS,
                  REG_OPTION_NON_VOLATILE,
                  DesiredAccess,
                  NULL,                      // security attr
                  phKeyCurrentUser,
                  &Disposition
                  );

    }

    if ( err ) {
        KdPrint(("NWPROVAU: NwGetCurrentUserRegKey open or create of Parameters\\Option\\%ws key failed %lu\n", CurrentUser, err));
    }

    (void) RegCloseKey( hkeyWksta );
    (void) LocalFree((HLOCAL)CurrentUser) ;
    return err;
}


DWORD
NwQueryInfo(
    OUT LPWSTR *ppszPreferredSrv
    )
/*++

Routine Description:
    This routine gets the user's preferred server and print options from
    the registry.

Arguments:

    ppszPreferredSrv - Receives the user's preferred server


Return Value:

    Returns the appropriate Win32 error.

--*/
{

    HKEY hKeyCurrentUser = NULL;
    DWORD BufferSize;
    DWORD BytesNeeded;
    DWORD ValueType;
    LPWSTR PreferredServer ;
    DWORD err ;

    //
    // get to right place in registry and allocate dthe buffer
    //
    if (err = NwpGetCurrentUserRegKey( KEY_READ, &hKeyCurrentUser))
    {
        //
        // If somebody mess around with the registry and we can't find
        // the registry, just use the defaults.
        //
        *ppszPreferredSrv = NULL;
        return NO_ERROR;
    }

    BufferSize = sizeof(WCHAR) * (MAX_PATH + 2) ;
    PreferredServer = (LPWSTR) LocalAlloc(LPTR, BufferSize) ;
    if (!PreferredServer)
        return (GetLastError()) ;

    //
    // Read PreferredServer value into Buffer.
    //
    BytesNeeded = BufferSize ;

    err = RegQueryValueExW( hKeyCurrentUser,
                            NW_SERVER_VALUENAME,
                            NULL,
                            &ValueType,
                            (LPBYTE) PreferredServer,
                            &BytesNeeded );

    if (err != NO_ERROR)
    {
        //
        // set to empty and carry on
        //
        PreferredServer[0] = 0;
    }

    if (hKeyCurrentUser != NULL)
        (void) RegCloseKey(hKeyCurrentUser) ;
    *ppszPreferredSrv = PreferredServer ;
    return NO_ERROR ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\handle.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    handle.h

Abstract:

    Header which defines the context handle structure.

Author:

    Rita Wong      (ritaw)      18-Feb-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NW_HANDLE_INLUDED_
#define _NW_HANDLE_INLUDED_

//
// Signature value in handle
//
#define NW_HANDLE_SIGNATURE        0x77442323

//
// Flags used to indicate whether Context Handles are using NDS or not
//
#define CURRENTLY_ENUMERATING_NON_NDS 0
#define CURRENTLY_ENUMERATING_NDS     1

//
// Context handle type
//
typedef enum _NW_ENUM_TYPE {

    NwsHandleListConnections = 10,
    NwsHandleListContextInfo_Tree,
    NwsHandleListContextInfo_Server,
    NwsHandleListServersAndNdsTrees,
    NwsHandleListVolumes,
    NwsHandleListQueues,
    NwsHandleListVolumesQueues,
    NwsHandleListDirectories,
    NwsHandleListPrintServers,
    NwsHandleListPrintQueues,
    NwsHandleListNdsSubTrees_Disk,
    NwsHandleListNdsSubTrees_Print,
    NwsHandleListNdsSubTrees_Any

} NW_ENUM_TYPE, *PNW_ENUM_TYPE;

//
// Data associated with each opened context handle
//
typedef struct _NW_ENUM_CONTEXT {

    //
    // For block identification
    //
    DWORD Signature;

    //
    // Handle type
    //
    NW_ENUM_TYPE HandleType;

    //
    // Resume ID.  This may be the identifier for the next entry
    // to list or may be the last entry listed for the connection handle
    // indicated by the flag dwUsingNds.
    //
    DWORD_PTR ResumeId;

    //
    // Type of object requested. Valid only when the handle type 
    // is NwsHandleListConnections.
    // 
    DWORD ConnectionType;

    //
    // Internal handle to the object we have opened to perform
    // the enumeration.  This value exists only if the handle
    // type is NwsHandleListVolumes, NwsHandleListDirectories,
    // or NwsHandleListNdsSubTrees.
    //
    HANDLE TreeConnectionHandle;

    //
    // Value used to indicate the maximum number of volumes supported on
    // a server. This is used for connection handles that enumerate volumes
    // or volumes and queues (NwsHandleListVolumes or
    // NwsHandleListVolumesQueues).
    //
    DWORD dwMaxVolumes;

    //
    // Flag used to indicate whether enumeration ResumeId is for
    // NDS trees or servers.
    //
    DWORD dwUsingNds;

    //
    // Object identifier for NDS tree enumeration. The Oid of the
    // container/oject in the path of ContainerName.
    //
    DWORD dwOid;

    //
    // The size of the buffer used for caching rdr data under enumeration.
    //
    DWORD NdsRawDataSize;

    //
    // The object identifier of the last object read from the rdr that was
    // put into the local cache buffer NdsRawDataBuffer.
    //
    DWORD NdsRawDataId;

    //
    // The number of objects currently in the local cache buffer NdsRawDataBuffer.
    //
    DWORD NdsRawDataCount;

    //
    // The local cache buffer used for rdr data enumeration.
    //
    DWORD_PTR NdsRawDataBuffer;

    //
    // Full path name of the container object we are enumerating
    // from.
    //
    //    For NwsHandleListVolumes handle type this string points to:
    //         "\\ServerName"
    //
    //    For NwsHandleListDirectories handle type this string points to:
    //         "\\ServerName\Volume\"
    //                 or
    //         "\\ServerName\Volume\Directory\"
    //
    WCHAR ContainerName[1];

} NW_ENUM_CONTEXT, *LPNW_ENUM_CONTEXT;


#endif // _NW_HANDLE_INLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\inswks.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    tacc.c

Abstract:

    Test for accounts.

Author:

    Rita Wong (ritaw) 02-May-1992

Environment:

    User Mode - Win32

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>

#include <nwsnames.h>



DWORD
TestOpenSCManager(
    OUT LPSC_HANDLE hScManager,
    IN  LPWSTR DatabaseName,
    IN  DWORD DesiredAccess,
    IN  DWORD ExpectedError
    );

DWORD
TestCreateService(
    IN SC_HANDLE hScManager,
    IN LPWSTR ServiceName,
    IN DWORD ServiceType,
    IN LPWSTR BinaryPath,
    IN LPWSTR Dependencies
    );


void __cdecl
main(
    void
    )
{
    DWORD status;
    SC_HANDLE hScManager;
    SC_HANDLE hService;
    LONG RegError;
    HKEY ServiceKey;
    HKEY LinkageKey;
    DWORD Disposition;
    DWORD Type = 0x00000007;

    PWCHAR Dependencies = L"MSIPX\0Streams\0Mup\0";


    //
    // Valid desired access
    //
    if (TestOpenSCManager(
               &hScManager,
               NULL,
               SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE,
               NO_ERROR
               ) == NO_ERROR) {

        //
        // Install NwRdr file system driver
        //
        status = TestCreateService(
                     hScManager,
                     L"NwRdr",
                     SERVICE_FILE_SYSTEM_DRIVER,
                     L"\\SystemRoot\\System32\\Drivers\\nwrdr.sys",
                     NULL
                     );

        if (status != NO_ERROR) {
            (void) CloseServiceHandle(hScManager);
            return;
        }

        //
        // Install NWCWorkstation service own process
        //
        status = TestCreateService(
                     hScManager,
                     NW_SERVICE_WORKSTATION,
                     SERVICE_WIN32_SHARE_PROCESS,
                     L"%SystemRoot%\\System32\\nwsvc.exe",
                     Dependencies
                     );

        (void) CloseServiceHandle(hScManager);

        if (status != NO_ERROR) {
            return;
        }

        //
        // Write the linkage key under the NWCWorkstation key
        //
        RegError = RegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\NWCWorkstation",
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_CREATE_SUB_KEY,
                       &ServiceKey
                       );

        if (RegError != ERROR_SUCCESS) {
            printf("RegOpenKeyExW failed %ld\n", RegError);
            return;
        }

        RegError = RegCreateKeyExW(
                       ServiceKey,
                       L"Linkage",
                       0,
                       WIN31_CLASS,
                       REG_OPTION_NON_VOLATILE, // options
                       KEY_WRITE,
                       NULL,
                       &LinkageKey,
                       &Disposition
                       );

        RegCloseKey(ServiceKey);

        if (RegError != ERROR_SUCCESS) {
            printf("RegCreateKeyExW failed %ld\n", RegError);
            return;
        }

        RegError = RegSetValueExW(
                       LinkageKey,
                       L"Bind",
                       0,
                       REG_MULTI_SZ,
                       L"\\Device\\Streams\\IPX\0",
                       (wcslen(L"\\Device\\Streams\\IPX\0") + 1)
                            * sizeof(WCHAR)
                       );

        RegCloseKey(LinkageKey);

        if (RegError != ERROR_SUCCESS) {
            printf("RegSetValueEx failed %ld\n", RegError);
            return;
        }

        //
        // Add a system event entry for the NetWare workstation
        //
        RegError = RegCreateKeyExW(
                       HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\Eventlog\\System\\NWCWorkstation",
                       0,
                       WIN31_CLASS,
                       REG_OPTION_NON_VOLATILE,
                       KEY_WRITE,
                       NULL,
                       &ServiceKey,
                       &Disposition
                       );

        if (RegError != ERROR_SUCCESS) {
            printf("RegCreateKeyExW of eventlog entry failed %ld\n", RegError);
            return;
        }

        RegError = RegSetValueExW(
                       ServiceKey,
                       L"EventMessageFile",
                       0,
                       REG_EXPAND_SZ,
                       L"%SystemRoot%\\System32\\nwevent.dll",
                       wcslen(L"%SystemRoot%\\System32\\nwevent.dll")
                            * sizeof(WCHAR)
                       );

        if (RegError != ERROR_SUCCESS) {
            printf("RegSetValueExW of EventMessageFile value failed %ld\n", RegError);
            RegCloseKey(ServiceKey);
            return;
        }

        RegError = RegSetValueExW(
                       ServiceKey,
                       L"TypesSupported",
                       0,
                       REG_DWORD,
                       &Type,
                       sizeof(DWORD)
                       );

        RegCloseKey(ServiceKey);

        if (RegError != ERROR_SUCCESS) {
            printf("RegSetValueExW of TypesSupported value failed %ld\n", RegError);
            return;
        }

        printf("Successfully installed transport for NWCWorkstation\n");
    }

}


DWORD
TestOpenSCManager(
    OUT LPSC_HANDLE hScManager,
    IN  LPWSTR DatabaseName,
    IN  DWORD DesiredAccess,
    IN  DWORD ExpectedError
    )
{
    DWORD status = NO_ERROR;


    if (DatabaseName != NULL) {
        printf("OpenSCManager: DatabaseName=%ws, DesiredAccess=%08lx\n",
               DatabaseName, DesiredAccess);
    }
    else {
        printf("OpenSCManager: DatabaseName=(null), DesiredAccess=%08lx\n",
               DesiredAccess);
    }

    *hScManager = OpenSCManager(
                      NULL,
                      DatabaseName,
                      DesiredAccess
                      );

    if (*hScManager == (SC_HANDLE) NULL) {

        status = GetLastError();

        if (ExpectedError != status) {
            printf("    FAILED.  Expected %lu, got %lu\n",
                   ExpectedError, status);
            return status;
        }
    }
    else {
        if (ExpectedError != NO_ERROR) {
            printf("    FAILED.  Expected %lu, got NO_ERROR\n",
                   ExpectedError);
            return NO_ERROR;
        }
    }

    printf("    Got %lu as expected\n", status);

    return status;

}

DWORD
TestCreateService(
    IN SC_HANDLE hScManager,
    IN LPWSTR ServiceName,
    IN DWORD ServiceType,
    IN LPWSTR BinaryPath,
    IN LPWSTR Dependencies
    )
{
    DWORD status = NO_ERROR;
    SC_HANDLE hService;


    hService = CreateService(
                   hScManager,
                   ServiceName,
                   NULL,
                   0,
                   ServiceType,
                   SERVICE_DEMAND_START,
                   SERVICE_ERROR_NORMAL,
                   BinaryPath,
                   NULL,
                   NULL,
                   Dependencies,
                   NULL,
                   NULL
                   );

    if (hService == (SC_HANDLE) NULL) {
        status = GetLastError();
        printf("CreateService: %ws failed %lu\n", ServiceName, status);
        return status;
    }

    printf("CreateService: Successfully created %ws\n", ServiceName);

    (void) CloseServiceHandle(hService);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\nw.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nw.h

Abstract:

    Main header of the NetWare Workstation service included by all
    modules.

Author:

    Rita Wong      (ritaw)      11-Dec-1992

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef _NW_INCLUDED_
#define _NW_INCLUDED_

//
// Includes
//
#include <stdlib.h>
#include <string.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <winbase.h>
#include <winerror.h>
#include <winsvc.h>
#include <winreg.h>
#include <winspool.h>

#include <svcs.h>       // intrinsic service definitions

#include <align.h>
#include <nwcanon.h>
#include <nwpkstr.h>

#include <rpc.h>
#include <nwwks.h>

#include <nwevent.h>
#include <ntddnwfs.h>
#include <nwsnames.h>
#include <handle.h>
#include <ndsapi32.h>
#include <ntddnwfs.h>

#define NW_DRIVER_NAME       DD_NWFS_FILESYS_NAME_U


//
// Debug trace level bits for turning on/off trace statements in the
// Workstation service
//

//
// Initialization and reading info from registry
//
#define NW_DEBUG_INIT         0x00000001

//
// Connection APIs
//
#define NW_DEBUG_CONNECT      0x00000002

//
// Enumeration APIs
//
#define NW_DEBUG_ENUM         0x00000004

//
// Credential management APIs
//
#define NW_DEBUG_LOGON        0x00000008

//
// Queue management APIs
//
#define NW_DEBUG_QUEUE        0x00000010

//
// Print Provider APIs
//
#define NW_DEBUG_PRINT        0x00000020

//
// Calls to redirector
//
#define NW_DEBUG_DEVICE       0x00000040

//
// Message APIs
//
#define NW_DEBUG_MESSAGE      0x00000080

#if DBG

extern DWORD WorkstationTrace;

#define IF_DEBUG(DebugCode) if (WorkstationTrace & NW_DEBUG_ ## DebugCode)

#define STATIC

#else

#define IF_DEBUG(DebugCode) if (FALSE)

#define STATIC static

#endif // DBG

//
// Initialization states
//
#define NW_EVENTS_CREATED         0x00000001
#define NW_RDR_INITIALIZED        0x00000002
#define NW_BOUND_TO_TRANSPORTS    0x00000004
#define NW_RPC_SERVER_STARTED     0x00000008
#define NW_INITIALIZED_MESSAGE    0x00000010

//
// Key path to redirector driver entry
//
#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
// now all SKUs have TerminalServer flag.  If App Server is enabled, SingleUserTS flag is cleared
#define IsTerminalServer() (BOOLEAN)(!(USER_SHARED_DATA->SuiteMask & (1 << SingleUserTS))) //user mode

//
// Event that will be signaled when the service is stopping
//
extern HANDLE NwDoneEvent;

//
// Events for controlling popups, and the global popup data.
//
extern HANDLE NwPopupEvent;
extern HANDLE NwPopupDoneEvent;

typedef struct _NWWKS_POPUP_DATA {
    DWORD  MessageId ;
    LUID   LogonId;
    DWORD  InsertCount ;
    LPWSTR InsertStrings[10] ;
} NWWKS_POPUP_DATA, *LPNWWKS_POPUP_DATA ;

extern NWWKS_POPUP_DATA PopupData ;

//
// Flag to control DBCS translations
//

extern LONG Japan;

//
// Name of the network provider and print provider
//
extern WCHAR NwProviderName[];
extern DWORD NwPacketBurstSize;
extern DWORD NwPrintOption;

//
// critical sections used 
//
extern CRITICAL_SECTION NwLoggedOnCritSec;
extern CRITICAL_SECTION NwServiceListCriticalSection; 
extern CRITICAL_SECTION NwPrintCritSec;  
//
// Functions from device.c
//
DWORD
NwInitializeRedirector(
    VOID
    );

DWORD
NwOpenRedirector(
    VOID
    );

DWORD
NwShutdownRedirector(
    VOID
    );

DWORD
NwLoadOrUnloadDriver(
    BOOL Load
    );

DWORD
NwBindToTransports(
    VOID
    );

DWORD
NwOpenPreferredServer(
    PHANDLE ServerHandle
    );

VOID
NwInitializePrintProvider(
    VOID
    );

VOID
NwTerminatePrintProvider(
    VOID
    );

DWORD
NwRedirFsControl(
    IN  HANDLE FileHandle,
    IN  ULONG RedirControlCode,
    IN  PNWR_REQUEST_PACKET Rrp,
    IN  ULONG RrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );

DWORD
NwCreateTreeConnectName(
    IN  LPWSTR UncName,
    IN  LPWSTR LocalName OPTIONAL,
    OUT PUNICODE_STRING TreeConnectStr
    );

DWORD
NwOpenCreateConnection(
    IN PUNICODE_STRING TreeConnectionName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UncName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    );

DWORD
NwNukeConnection(
    IN HANDLE TreeConnection,
    IN DWORD UseForce
    );

DWORD
NwGetServerResource(
    IN LPWSTR LocalName,
    IN DWORD LocalNameLength,
    OUT LPWSTR RemoteName,
    IN DWORD RemoteNameLen,
    OUT LPDWORD CharsRequired
    );

DWORD
NwEnumerateConnections(
    IN OUT PDWORD_PTR ResumeId,
    IN DWORD_PTR EntriesRequested,
    IN LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD EntriesRead,
    IN DWORD ConnectionType,
    IN PLUID LogonId
    );

DWORD
NwGetNextServerEntry(
    IN HANDLE PreferredServer,
    IN OUT LPDWORD LastObjectId,
    OUT LPSTR ServerName
    );

DWORD
NwGetNextServerConnection(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

DWORD
NwGetNextNdsTreeEntry(
    OUT LPNW_ENUM_CONTEXT ContextHandle
    );

DWORD
NwGetNextVolumeEntry(
    IN HANDLE ServerConnection,
    IN DWORD LastObjectId,
    OUT LPSTR VolumeName
    );

DWORD
NwRdrLogonUser(
    IN PLUID LogonId,
    IN LPWSTR UserName,
    IN DWORD UserNameSize,
    IN LPWSTR Password OPTIONAL,
    IN DWORD PasswordSize,
    IN LPWSTR PreferredServer OPTIONAL,
    IN DWORD PreferredServerSize,
    IN LPWSTR NdsPreferredServer OPTIONAL,
    IN DWORD NdsPreferredServerSize,
    IN DWORD PrintOption
    );

VOID
NwRdrChangePassword(
    IN PNWR_REQUEST_PACKET Rrp
    );

DWORD
NwRdrSetInfo(
    IN DWORD  PrintOption,
    IN DWORD  PacketBurstSize,
    IN LPWSTR PreferredServer,
    IN DWORD  PreferredServerSize,
    IN LPWSTR ProviderName,
    IN DWORD  ProviderNameSize
    );

DWORD
NwRdrLogoffUser(
    IN PLUID LogonId
    );

DWORD
NwConnectToServer(
    IN LPWSTR ServerName
    );

NTSTATUS
NwOpenHandle(
    IN PUNICODE_STRING ObjectName,
    IN BOOL ValidateFlag,
    OUT PHANDLE ObjectHandle
    );

NTSTATUS
NwCallNtOpenFile(
    OUT PHANDLE ObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING ObjectName,
    IN ULONG OpenOptions
    );

//
// Functions from queue.c
//
DWORD
NwGetNextQueueEntry(
    IN HANDLE PreferredServer,
    IN OUT LPDWORD LastObjectId,
    OUT LPSTR QueueName
    );

DWORD
NwAttachToNetwareServer(
    IN  LPWSTR  ServerName,
    OUT LPHANDLE phandleServer
    );

//
// Functions from enum.c
//
DWORD
NwOpenEnumPrintServers(
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    );

DWORD
NwOpenEnumPrintQueues(
    IN LPWSTR ServerName,
    OUT LPNWWKSTA_CONTEXT_HANDLE EnumHandle
    );

DWORD
NwWriteNetResourceEntry(
    IN OUT LPBYTE * FixedPortion,
    IN OUT LPWSTR * EndOfVariableData,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD ScopeFlags,
    IN DWORD DisplayFlags,
    IN DWORD UsageFlags,
    IN DWORD ResourceType,
    IN LPWSTR SystemPath OPTIONAL,
    OUT LPWSTR * lppSystem OPTIONAL,
    OUT LPDWORD BytesNeeded
    );

DWORD
NwCloseAllConnections(
    VOID
    );

DWORD
NwWritePrinterInfoEntry(
    IN OUT LPBYTE *FixedPortion,
    IN OUT LPWSTR *EndOfVariableData,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD  Flags,
    OUT LPDWORD BytesNeeded
    );

//
// Functions from credentl.c
//
VOID
NwInitializeLogon(
    VOID
    );

VOID
NwGetLogonCredential(
    VOID
    );

//
// Functions from util.c
//
DWORD
NwMapStatus(
    IN  NTSTATUS NtStatus
    );

DWORD
NwMapBinderyCompletionCode(
    IN  NTSTATUS NtStatus
    );

DWORD
NwImpersonateClient(
    VOID
    );

DWORD
NwRevertToSelf(
    VOID
    );

VOID
NwLogEvent(
    DWORD MessageId,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings,
    DWORD ErrorCode
    );

BOOL
NwConvertToUnicode(
    OUT LPWSTR *UnicodeOut,
    IN LPSTR  OemIn
    );

VOID
DeleteAllConnections(
    VOID
    );

//
// Functions from connect.c
//
DWORD
NwCreateSymbolicLink(
    IN  LPWSTR Local,
    IN  LPWSTR TreeConnectStr,
    IN  BOOL ImpersonatingClient
    );

VOID
NwDeleteSymbolicLink(
    IN  LPWSTR LocalDeviceName,
    IN  LPWSTR TreeConnectStr,
    IN  LPWSTR SessionDeviceName,    //Terminal Server Addition
    IN  BOOL ImpersonatingClient
    );

DWORD
NwOpenHandleToDeleteConn(
    IN  LPWSTR UncName,
    IN  LPWSTR LocalName OPTIONAL,
    IN  DWORD UseForce,
    IN  BOOL IsStopWksta,
    IN  BOOL ImpersonatingClient
    );

DWORD
NwCreateConnection(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD Type,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UserName OPTIONAL
    );

//
// (Functions from citrix.c)
// Terminal Server Addition
//
BOOL
SendMessageToLogonIdW(
    IN LUID    LogonId,
    IN LPWSTR  pMessage,
    IN LPWSTR  pTitle
    );


NTSTATUS
NwGetSessionId(
    OUT PULONG pSessionId
    );


#endif // _NW_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\nwmain.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwmain.c

Abstract:

    Main module of the NetWare workstation service.

Author:

    Rita Wong      (ritaw)      11-Dec-1992

Environment:

    User Mode - Win32

Revision History:

--*/


#include <nw.h>
#include <nwreg.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <nwmisc.h>
#include <winsta.h>


//
//
// GetProcAddr Prototype for winsta.dll function WinStationSetInformationW
//

typedef BOOLEAN (*PWINSTATION_SET_INFORMATION) (
                    HANDLE hServer,
                    ULONG SessionId,
                    WINSTATIONINFOCLASS WinStationInformationClass,
                    PVOID pWinStationInformation,
                    ULONG WinStationInformationLength
                    );

//
//
// GetProcAddr Prototype for winsta.dll function WinStationSendMessageW
//

typedef BOOLEAN
(*PWINSTATION_SEND_MESSAGE) (
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR  pTitle,
    ULONG TitleLength,
    LPWSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOLEAN DoNotWait
    );
//------------------------------------------------------------------
//
// Local Definitions
//
//------------------------------------------------------------------

#define NW_EVENT_MESSAGE_FILE         L"nwevent.dll"
#define NW_MAX_POPUP_MESSAGE_LENGTH   512

#define REG_WORKSTATION_PROVIDER_PATH L"System\\CurrentControlSet\\Services\\NWCWorkstation\\networkprovider"
#define REG_PROVIDER_VALUE_NAME       L"Name"

#define REG_WORKSTATION_PARAMETERS_PATH L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters"
#define REG_BURST_VALUE_NAME          L"MaxBurstSize"
#define REG_DISABLEPOPUP_VALUE_NAME   L"DisablePopup"

#define REG_SETUP_PATH                L"System\\Setup"
#define REG_SETUP_VALUE_NAME          L"SystemSetupInProgress"

//
// QFE release does not have this. so for QFE, we make it a no-op bit.
//
#ifdef QFE_BUILD
#define MB_SERVICE_NOTIFICATION       0
#endif

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwInitialize(
    OUT LPDWORD NwInitState
    );

DWORD
NwInitializeCritSects(
    VOID
    );

VOID
NwInitializeWkstaInfo(
    VOID
    );

DWORD
NwInitializeMessage(
    VOID
    );

BOOL NwShutdownNotify(
    DWORD dwCtrlType
    );

VOID
NwShutdown(
    IN DWORD ErrorCode,
    IN DWORD NwInitState
    );

VOID
NwShutdownMessage(
    VOID
    );

VOID
NwControlHandler(
    IN DWORD Opcode
    );

DWORD
NwUpdateStatus(
    VOID
    );

VOID
NwMessageThread(
    IN HANDLE RdrHandle
    );

VOID
NwDisplayMessage(
    IN LUID LogonId,
    IN LPWSTR Server,
    IN LPWSTR Message
    );

VOID
NwDisplayPopup(
    IN LPNWWKS_POPUP_DATA lpPopupData
    );

BOOL
SendMessageIfUserW(
    LUID   LogonId,
    LPWSTR pMessage,
    LPWSTR pTitle
    );

BOOL
NwSetupInProgress(
    VOID
    );

BOOL
NwGetLUIDDeviceMapsEnabled(
    VOID
    );

RPC_STATUS NwRpcSecurityCallback(
    IN RPC_IF_HANDLE *Interface,
    IN void *Context
	);

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// For service control
//
STATIC SERVICE_STATUS NwStatus;
STATIC SERVICE_STATUS_HANDLE NwStatusHandle = 0;
HANDLE NwDoneEvent = NULL ;

//
// For popping up errors.
//
HANDLE NwPopupEvent = NULL ;
HANDLE NwPopupDoneEvent = NULL ;
NWWKS_POPUP_DATA  PopupData ;

//
// Flag to control DBCS translations
//

extern LONG Japan = 0;

//
// Data global to nwsvc.exe
//
PSVCHOST_GLOBAL_DATA NwsvcGlobalData;

//
// Handle for receiving server messages
//
STATIC HANDLE NwRdrMessageHandle;

//
// Stores the network and print provider name
//
WCHAR NwProviderName[MAX_PATH] = L"";

// Stores the packet burst size
DWORD NwPacketBurstSize = 32 * 1024;

//
// critical sections used
//
CRITICAL_SECTION NwLoggedOnCritSec;
CRITICAL_SECTION NwPrintCritSec;  // protect the linked list of printers

BOOL NwLUIDDeviceMapsEnabled;

//-------------------------------------------------------------------//

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA  pGlobals
    )
{
    NwsvcGlobalData = pGlobals;
}


VOID
ServiceMain(
    DWORD NumArgs,
    LPTSTR *ArgsArray
    )
/*++

Routine Description:

    This is the main entry point of the NetWare workstation service.  After
    the service has been initialized, this thread will wait on NwDoneEvent
    for a signal to terminate the service.

Arguments:

    NumArgs - Supplies the number of strings specified in ArgsArray.

    ArgsArray -  Supplies string arguments that are specified in the
        StartService API call.  This parameter is ignored.

Return Value:

    None.

--*/
{

    DWORD NwInitState = 0;


    UNREFERENCED_PARAMETER(NumArgs);
    UNREFERENCED_PARAMETER(ArgsArray);

    //
    // Make sure svchost.exe gave us the global data
    //

    ASSERT(NwsvcGlobalData != NULL);

    if (NwInitialize(&NwInitState) != NO_ERROR) {
        return;
    }

    //
    // Wait until we are told to stop.
    //
    (void) WaitForSingleObject(
               NwDoneEvent,
               INFINITE
               );

    NwShutdown(
        NO_ERROR,          // Normal termination
        NwInitState
        );
}


DWORD
NwInitialize(
    OUT LPDWORD NwInitState
    )
/*++

Routine Description:

    This function initializes the NetWare workstation service.

Arguments:

    NwInitState - Returns a flag to indicate how far we got with initializing
        the service before an error occurred.

Return Value:

    NO_ERROR or reason for failure.

Notes:

    See IMPORTANT NOTE below.

--*/
{
    DWORD status;
    LCID lcid;
	RPC_STATUS rpcStatus;

    //
    // initialize all our critical sections as soon as we can
    //
    status = NwInitializeCritSects();

    if (status != NO_ERROR)
    {
        KdPrint(("NWWORKSTATION: NwInitializeCritSects error %lu\n", status));
        return status;
    }

    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //
    NwStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    NwStatus.dwCurrentState = SERVICE_START_PENDING;
    NwStatus.dwControlsAccepted = 0;
    NwStatus.dwCheckPoint = 1;
    NwStatus.dwWaitHint = 5000;
    NwStatus.dwWin32ExitCode = NO_ERROR;
    NwStatus.dwServiceSpecificExitCode = 0;

    //
    // Initialize workstation to receive service requests by registering the
    // control handler.
    //
    if ((NwStatusHandle = RegisterServiceCtrlHandlerW(
                              NW_WORKSTATION_SERVICE,
                              NwControlHandler
                              )) == 0) {

        status = GetLastError();
        KdPrint(("NWWORKSTATION: RegisterServiceCtrlHandlerW error %lu\n", status));
        return status;
    }

    //
    // Tell Service Controller that we are start pending.
    //
    (void) NwUpdateStatus();

    //
    // Don't run during GUI-mode setup (doing so can cause migration of
    // registry keys the service opens to fail, deleting share names)
    //
    if (NwSetupInProgress())
    {
        //
        // Fail silently so there's no Eventlog message to panic the user
        //
        NwShutdown(NO_ERROR, *NwInitState);

        //
        // Bit of a hack since ServiceMain will wait on the NwDoneEvent
        // (which hasn't yet been created) if NwInitialize returns anything
        // other than NO_ERROR.  This error code isn't used for anything
        // other than telling ServiceMain to return without waiting.
        //
        return ERROR_SERVICE_DISABLED;
    }

    //
    // Create events to synchronize message popups
    //
    if (((NwPopupEvent = CreateEvent(
                          NULL,      // no security descriptor
                          FALSE,     // use automatic reset
                          FALSE,     // initial state: not signalled
                          NULL       // no name
                          )) == NULL)
       || ((NwPopupDoneEvent = CreateEvent(
                          NULL,      // no security descriptor
                          FALSE,     // use automatic reset
                          TRUE,      // initial state: signalled
                          NULL       // no name
                          )) == NULL))
    {
        status = GetLastError();
        NwShutdown(status, *NwInitState);
        return status;
    }

    //
    // Create event to synchronize termination
    //
    if ((NwDoneEvent = CreateEvent(
                          NULL,      // no security descriptor
                          TRUE,      // do not use automatic reset
                          FALSE,     // initial state: not signalled
                          NULL       // no name
                          )) == NULL) {

        status = GetLastError();
        NwShutdown(status, *NwInitState);
        return status;
    }
    (*NwInitState) |= NW_EVENTS_CREATED;


    //
    // Load the redirector.
    //
    if ((status = NwInitializeRedirector()) != NO_ERROR) {
        NwShutdown(status, *NwInitState);
        return status;
    }
    (*NwInitState) |= NW_RDR_INITIALIZED;

    //
    // Service still start pending.  Update checkpoint to reflect that
    // we are making progress.
    //
    NwStatus.dwCheckPoint++;
    (void) NwUpdateStatus();

    //
    // Bind to transports
    //
    status = NwBindToTransports();

    //
    // tommye MS 24187 / MCS 255
    //
    
    //
    // G/CSNW has been unbound in the connection manager and so, we haven't
    // found the linkage key to bind to.
    //
    
    if (status == ERROR_INVALID_PARAMETER) {
    
        //
        // Fail silently so there's no Eventlog message to panic the user
        //
    
        NwShutdown(NO_ERROR, *NwInitState);
    
        //
        // Bit of a hack since SvcEntry_NWCS will wait on the NwDoneEvent
        // (which hasn't yet been created) if NwInitialize returns anything
        // other than NO_ERROR.  This error code isn't used for anything
        // other than telling SvcEntry_NWCS to return without waiting.
        //
    
        return ERROR_SERVICE_DISABLED;
    
    } else if (status != NO_ERROR) {

        NwShutdown(status, *NwInitState);
        return status;
    }
    (*NwInitState) |= NW_BOUND_TO_TRANSPORTS;

    //
    // Service still start pending.  Update checkpoint to reflect that
    // we are making progress.
    //
    NwStatus.dwCheckPoint++;
    (void) NwUpdateStatus();

    //
    // Initialize credential management.
    //
    NwInitializeLogon();

    //
    // Setup thread to receive server messages.  Even if not successful,
    // just press on as the workstation is mostly functional.
    //
    if ((status = NwInitializeMessage()) == NO_ERROR) {
        (*NwInitState) |= NW_INITIALIZED_MESSAGE;
    }

    //
    // Service still start pending.  Update checkpoint to reflect that
    // we are making progress.
    //
    NwStatus.dwCheckPoint++;
    (void) NwUpdateStatus();

    //
    // Read some workstation information stored in the registry
    // and passes some info to the redirector. This has to be
    // done before opening up the RPC interface.
    //
    NwInitializeWkstaInfo();

    //
    // Initialize the server side print provider.
    //
    NwInitializePrintProvider();

    //
    // Initialize the service provider.
    //
    NwInitializeServiceProvider();

    //
    // Service still start pending.  Update checkpoint to reflect that
    // we are making progress.
    //
    NwStatus.dwCheckPoint++;
    (void) NwUpdateStatus();

    //
    // Open up the RPC interface
    //
    /*
	status = NwsvcGlobalData->StartRpcServer(
                 NWWKS_INTERFACE_NAME,
                 nwwks_ServerIfHandle
                 );
	*/
	rpcStatus = RpcServerUseProtseqEpW(
			L"ncalrpc",
			RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
			L"nwwkslpc",
			NULL
			);

	//  duplicate endpoint is ok
    if ( rpcStatus == RPC_S_DUPLICATE_ENDPOINT ) {
        rpcStatus = RPC_S_OK;
	}
	if (rpcStatus == RPC_S_OK) {
		rpcStatus = RpcServerRegisterIfEx(
					nwwks_ServerIfHandle,
					NULL,
					NULL,
					RPC_IF_AUTOLISTEN,
					RPC_C_LISTEN_MAX_CALLS_DEFAULT,
					NwRpcSecurityCallback
					);
	}
	status = (rpcStatus == RPC_S_OK) ? NO_ERROR : rpcStatus;

    if (status != NO_ERROR) {
        NwShutdown(status, *NwInitState);
        return status;
    }
    (*NwInitState) |= NW_RPC_SERVER_STARTED;

    //
    // Set up the hook to handle computer shut down.
    //
    // IMPORTANT NOTE: this is the last step after everything else
    // has suceeded. When shutdown handler is called, it assumes that
    // the redir is fully initialized.
    //
    if ( !SetConsoleCtrlHandler( NwShutdownNotify, TRUE ))
    {
        KdPrint(("SetConsoleCtrlHandler failed with %d\n", GetLastError()));
        NwShutdown( status, *NwInitState );
        return GetLastError();
    }

    //
    // We are done with workstation startup.
    //
    NwStatus.dwCurrentState = SERVICE_RUNNING;
    NwStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | 
                                  SERVICE_ACCEPT_SHUTDOWN;
    NwStatus.dwCheckPoint = 0;
    NwStatus.dwWaitHint = 0;
    NwStatus.dwWin32ExitCode = NO_ERROR;

    if ((status = NwUpdateStatus()) != NO_ERROR) {
        NwShutdown(status, *NwInitState);
        return status;
    }

    //
    // Read user and service logon credentias from the registry, in
    // case user logged on before workstation was started.
    // Eg. restart workstation.
    //
    NwGetLogonCredential();


#if 0
    //
    // check that the NWLINK has the right sockopts
    //
    // see comment on the actual function
    //
    if (!NwIsNWLinkVersionOK())
    {
        //
        // log the error in the event log
        //

        LPWSTR InsertStrings[1] ;

        NwLogEvent(EVENT_NWWKSTA_WRONG_NWLINK_VERSION,
                   0,
                   InsertStrings,
                   0) ;
    }
#endif

    //
    // Check to see if we're in a DBCS environment.
    //
    NtQueryDefaultLocale( TRUE, &lcid );
    Japan = 0;
    if (PRIMARYLANGID(lcid) == LANG_JAPANESE ||
        PRIMARYLANGID(lcid) == LANG_KOREAN ||
        PRIMARYLANGID(lcid) == LANG_CHINESE) {

        Japan = 1;
    }

    NwLUIDDeviceMapsEnabled = NwGetLUIDDeviceMapsEnabled();
    //
    // Successful initialization
    //
    return NO_ERROR;
}

RPC_STATUS NwRpcSecurityCallback(
    IN RPC_IF_HANDLE *Interface,
    IN void *Context
	)
{
    RPC_STATUS          Status;
    RPC_BINDING_HANDLE  ServerIfHandle;
    LPWSTR              binding = NULL;
    LPWSTR              protseq = NULL;

    Status = RpcBindingServerFromClient((RPC_IF_HANDLE)Context, &ServerIfHandle);
    if (Status != RPC_S_OK) 
    {
        return (RPC_S_ACCESS_DENIED);
    }
    Status = RpcBindingToStringBinding(ServerIfHandle, &binding);
    if (Status != RPC_S_OK) 
    {
        Status = RPC_S_ACCESS_DENIED;
        goto CleanUp;
    }
    Status = RpcStringBindingParse(binding, NULL, &protseq, NULL, NULL, NULL);
    if (Status != RPC_S_OK) 
    {
        Status = RPC_S_ACCESS_DENIED;
    }
    else
    {
        if (lstrcmp(protseq, L"ncalrpc") != 0)
            Status = RPC_S_ACCESS_DENIED;
    }
CleanUp:
    RpcBindingFree(&ServerIfHandle);
    if ( binding )
    {
        RpcStringFreeW( &binding );
    }
    if ( protseq )
    {
        RpcStringFreeW( &protseq );
    }

    return Status;
}


BOOL NwShutdownNotify(
    IN DWORD dwCtrlType
    )
/*++

Routine Description:

    This function is a control handler used in SetConsoleCtrlHandler.
    We are only interested in CTRL_SHUTDOWN_EVENT. On shutdown, we
    need to notify redirector to shut down and then delete the
    CurrentUser key in the registry.

Arguments:

    dwCtrlType - The control type that occurred. We will only
                 process CTRL_SHUTDOWN_EVENT.

Return Value:

    TRUE if we don't want the default or other handlers to be called.
    FALSE otherwise.

Note:

    This Handler is registered after all the Init steps have completed.
    As such, it does not check for what state the service is in as it
    cleans up.

--*/
{
    DWORD err;

#if DBG
    IF_DEBUG(INIT)
        KdPrint(("NwShutdownNotify\n"));
#endif

    if ( dwCtrlType != CTRL_SHUTDOWN_EVENT )
    {
        return FALSE;
    }

    //
    // stop the RPC server
    //
    (void) NwsvcGlobalData->StopRpcServer(nwwks_ServerIfHandle);

    //
    // get rid of all connections
    //
    (void) DeleteAllConnections();

    err = NwShutdownRedirector();

    if ( err != NO_ERROR )
        KdPrint(("Shut down redirector failed with %d\n", err ));
#if DBG
    else
    {
        IF_DEBUG(INIT)
        KdPrint(("NwShutdownRedirector success!\n"));
    }
#endif

    //
    // Delete all logon session information in the registry.
    //
     NwDeleteInteractiveLogon(NULL);

    (void) NwDeleteServiceLogon(NULL);

    return FALSE;  // The default handler will terminate the process.
}


VOID
NwShutdown(
    IN DWORD ErrorCode,
    IN DWORD NwInitState
    )
/*++

Routine Description:

    This function shuts down the Workstation service.

Arguments:

    ErrorCode - Supplies the error code of the failure

    NwInitState - Supplies a flag to indicate how far we got with initializing
        the service before an error occurred, thus the amount of clean up
        needed.

Return Value:

    None.

--*/
{
    DWORD status = NO_ERROR;

    //
    // Service stop still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (NwStatus.dwCheckPoint)++;
    (void) NwUpdateStatus();

    if (NwInitState & NW_RPC_SERVER_STARTED) {
        // NwsvcGlobalData->StopRpcServer(nwwks_ServerIfHandle);
		status = RpcServerUnregisterIf(
					nwwks_ServerIfHandle,
					NULL,
					1
					);
    }

    if (NwInitState & NW_INITIALIZED_MESSAGE) {
        NwShutdownMessage();
    }

    //
    // Service stop still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (NwStatus.dwCheckPoint)++;
    (void) NwUpdateStatus();

    if (NwInitState & NW_BOUND_TO_TRANSPORTS) {
        DeleteAllConnections();
    }

    //
    // Clean up the service provider.
    //
    // NwTerminateServiceProvider(); NOT CALLED! This is done at DLL unload time already.

    //
    // Clean up the server side print provider
    //
    NwTerminatePrintProvider();

    //
    // Service stop still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (NwStatus.dwCheckPoint)++;
    (void) NwUpdateStatus();

    if (NwInitState & NW_RDR_INITIALIZED) {
        //
        // Unload the redirector
        //
        status = NwShutdownRedirector();
    }

    if (NwInitState & NW_EVENTS_CREATED) {
        //
        // Close handle to termination event and popup event
        //
        if (NwDoneEvent) CloseHandle(NwDoneEvent);
        if (NwPopupEvent) CloseHandle(NwPopupEvent);
        if (NwPopupDoneEvent) CloseHandle(NwPopupDoneEvent);
    }

    //
    // We are done with cleaning up.  Tell Service Controller that we are
    // stopped.
    //
    NwStatus.dwCurrentState = SERVICE_STOPPED;
    NwStatus.dwControlsAccepted = 0;

    if ((ErrorCode == NO_ERROR) &&
        (status == ERROR_REDIRECTOR_HAS_OPEN_HANDLES)) {
        ErrorCode = status;
    }

    //
    // Deregister the control handler
    //
    (void) SetConsoleCtrlHandler( NwShutdownNotify, FALSE ) ;

    NwStatus.dwWin32ExitCode = ErrorCode;
    NwStatus.dwServiceSpecificExitCode = 0;

    NwStatus.dwCheckPoint = 0;
    NwStatus.dwWaitHint = 0;

    (void) NwUpdateStatus();
}


VOID
NwControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the Workstation service.

Arguments:

    Opcode - Supplies a value which specifies the action for the
        service to perform.

Return Value:

    None.

--*/
{
    switch (Opcode) {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:

            if ((NwStatus.dwCurrentState != SERVICE_STOP_PENDING) && 
                (NwStatus.dwCurrentState != SERVICE_STOPPED)){

                NwStatus.dwCurrentState = SERVICE_STOP_PENDING;
                NwStatus.dwCheckPoint = 1;
                NwStatus.dwWaitHint = 60000;

                //
                // Send the status response.
                //
                (void) NwUpdateStatus();

                if (! SetEvent(NwDoneEvent)) {

                    //
                    // Problem with setting event to terminate Workstation
                    // service.
                    //
                    KdPrint(("NWWORKSTATION: Error setting NwDoneEvent %lu\n",
                             GetLastError()));

                    ASSERT(FALSE);
                }
                return;
            }
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

    }

    //
    // Send the status response.
    //
    (void) NwUpdateStatus();
}


DWORD
NwUpdateStatus(
    VOID
    )
/*++

Routine Description:

    This function updates the workstation service status with the Service
    Controller.

Arguments:

    None.

Return Value:

    Return code from SetServiceStatus.

--*/
{
    DWORD status = NO_ERROR;


    if (NwStatusHandle == 0) {
        KdPrint(("NWWORKSTATION: Cannot call SetServiceStatus, no status handle.\n"));
        return ERROR_INVALID_HANDLE;
    }

    if (! SetServiceStatus(NwStatusHandle, &NwStatus)) {

        status = GetLastError();

        KdPrint(("NWWORKSTATION: SetServiceStatus error %lu\n", status));
    }

    return status;
}



VOID
NwInitializeWkstaInfo(
    VOID
    )
/*++

Routine Description:

    This function reads some workstation info, including the packet burst
    size and the provider name. We will ignore all errors that occurred when
    reading from the registry and use the default values instead.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD err;
    HKEY  hkey;
    DWORD dwTemp;
    DWORD dwSize = sizeof( dwTemp );
    LPWSTR pszProviderName = NULL;

    //
    // Read the Network and Print Provider Name.
    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\networkprovider
    //
    err = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              REG_WORKSTATION_PROVIDER_PATH,
              REG_OPTION_NON_VOLATILE,   // options
              KEY_READ,                  // desired access
              &hkey
              );

    if ( !err )
    {
        //
        // Read the network provider name
        //
        err = NwReadRegValue(
                  hkey,
                  REG_PROVIDER_VALUE_NAME,
                  &pszProviderName
                  );

        if ( !err )
        {
            wcscpy( NwProviderName, pszProviderName );
            (void) LocalFree( (HLOCAL) pszProviderName );

#if DBG
            IF_DEBUG(INIT)
            {
                KdPrint(("\nNWWORKSTATION: Provider Name = %ws\n",
                        NwProviderName ));
            }
#endif
        }

        RegCloseKey( hkey );
    }

    if ( err )
    {
        KdPrint(("Error %d when reading provider name.\n", err ));
    }


    //
    // Read the Packet Burst Size
    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    err = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              REG_WORKSTATION_PARAMETERS_PATH,
              REG_OPTION_NON_VOLATILE,   // options
              KEY_READ,                  // desired access
              &hkey
              );

    if ( !err )
    {
        err = RegQueryValueExW( hkey,
                                REG_BURST_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) &dwTemp,
                                &dwSize );

        if ( !err )
        {
            NwPacketBurstSize = dwTemp;

#if DBG
            IF_DEBUG(INIT)
            {
                KdPrint(("\nNWWORKSTATION: Packet Burst Size = %d\n",
                        NwPacketBurstSize ));
            }
#endif
        }
        RegCloseKey( hkey );
    }

    //
    // Passes the information to the redirector
    //
    (void) NwRdrSetInfo(
               NW_PRINT_OPTION_DEFAULT,
               NwPacketBurstSize,
               NULL,
               0,
               NwProviderName,
               ((NwProviderName != NULL) ?
                  wcslen( NwProviderName) * sizeof( WCHAR ) : 0 )
               );

}



DWORD
NwInitializeMessage(
    VOID
    )
/*++

Routine Description:

    This routine opens a handle to the redirector device to receive
    server messages and creates a thread to wait for the incoming
    messages.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;
    UNICODE_STRING RdrName;

    HKEY  hkey;
    DWORD dwTemp;
    DWORD dwSize = sizeof( dwTemp );
    BOOL  fDisablePopup = FALSE ;

    HANDLE ThreadHandle;
    DWORD ThreadId;

    //
    // Read the Disable Popup Flag. By default it is cleared.
    // We only set to TRUE if we find the value.
    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    status = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,
              REG_WORKSTATION_PARAMETERS_PATH,
              REG_OPTION_NON_VOLATILE,   // options
              KEY_READ,                  // desired access
              &hkey
              );

    if ( status == NO_ERROR )
    {
        status = RegQueryValueExW( hkey,
                                REG_DISABLEPOPUP_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) &dwTemp,
                                &dwSize );

        if ( status == NO_ERROR )
        {
            fDisablePopup = (dwTemp == 1);
        }

        RegCloseKey( hkey );
    }

    if (fDisablePopup)
    {
        return NO_ERROR ;
    }

    RtlInitUnicodeString(&RdrName, DD_NWFS_DEVICE_NAME_U);

    status = NwMapStatus(
                 NwCallNtOpenFile(
                     &NwRdrMessageHandle,
                     FILE_GENERIC_READ | SYNCHRONIZE,
                     &RdrName,
                     0  // Handle for async call
                     )
                 );

    if (status != NO_ERROR) {
        return status;
    }

    //
    // Create the thread to wait for incoming messages
    //
    ThreadHandle = CreateThread(
                       NULL,
                       0,
                       (LPTHREAD_START_ROUTINE) NwMessageThread,
                       (LPVOID) NwRdrMessageHandle,
                       0,
                       &ThreadId
                       );

    if (ThreadHandle == NULL) {
        (void) NtClose(NwRdrMessageHandle);
        return GetLastError();
    }

    return NO_ERROR;
}


VOID
NwShutdownMessage(
    VOID
    )
{
    (void) NtClose(NwRdrMessageHandle);
}


VOID
NwMessageThread(
    IN HANDLE RdrHandle
    )
{
    NTSTATUS getmsg_ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    DWORD ReturnVal, NumEventsToWaitOn ;
    HANDLE EventsToWaitOn[3];

    //BYTE OutputBuffer[48 * sizeof(WCHAR) + 256 * sizeof(WCHAR)];  //Need more space for terminal server
    BYTE OutputBuffer[ 2 * sizeof(ULONG) + 48 * sizeof(WCHAR) + 256 * sizeof(WCHAR)]; // Need space for UID to redirect message to correct user

    PNWR_SERVER_MESSAGE ServerMessage = (PNWR_SERVER_MESSAGE) OutputBuffer;
    BOOL DoFsctl = TRUE ;
    NWWKS_POPUP_DATA LocalPopupData ;


    EventsToWaitOn[0] = NwDoneEvent;
    EventsToWaitOn[1] = NwPopupEvent;
    EventsToWaitOn[2] = RdrHandle;

    while (TRUE) {
        if (DoFsctl)
        {
            getmsg_ntstatus = NtFsControlFile(
                                  RdrHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_NWR_GET_MESSAGE,
                                  NULL,
                                  0,
                                  OutputBuffer,
                                  sizeof(OutputBuffer)
                                  );

            DoFsctl = FALSE ;
        }

        if (NT_SUCCESS(getmsg_ntstatus))
        {
            NumEventsToWaitOn = 3 ;
        }
        else
        {
            NumEventsToWaitOn = 2 ;
        }

        ReturnVal = WaitForMultipleObjects(
                        NumEventsToWaitOn,
                        EventsToWaitOn,
                        FALSE,           // Wait for any one
                        INFINITE
                        );

        switch (ReturnVal) {

            case WAIT_OBJECT_0 :
                //
                // Workstation is terminating.  Just die.
                //
                ExitThread(0);
                break;

            case WAIT_OBJECT_0 + 1:
                //
                // We have a popup to do. Grab the data and Set the
                // event so that the structure can be used once more.
                //
                LocalPopupData = PopupData ;
                RtlZeroMemory(&PopupData, sizeof(PopupData)) ;
                if (! SetEvent(NwPopupDoneEvent)) {
                    //
                    // should not happen
                    //
                    KdPrint(("NWWORKSTATION: Error setting NwPopupDoneEvent %lu\n",
                             GetLastError()));

                    ASSERT(FALSE);
                }

                NwDisplayPopup(&LocalPopupData) ;
                break;

            case WAIT_OBJECT_0 + 2:
            {
                NTSTATUS ntstatus ;

                //
                // GET_MESSAGE fsctl completed.
                //
                ntstatus = IoStatusBlock.Status;
                DoFsctl = TRUE ;

                if (ntstatus == STATUS_SUCCESS) {
                    NwDisplayMessage(
                                    ServerMessage->LogonId,
                                    ServerMessage->Server,
                                    (LPWSTR) ((UINT_PTR) ServerMessage +
                                              ServerMessage->MessageOffset)
                                    );
                }
                else {
                    KdPrint(("NWWORKSTATION: GET_MESSAGE fsctl failed %08lx\n", ntstatus));
                }

                break;
            }

            case WAIT_FAILED:
            default:
                //
                // Don't care.
                //
                break;
        }

    }
}


VOID
NwDisplayMessage(
    IN LUID LogonId,   /* Need to send to a user station - for terminal server */
    IN LPWSTR Server,
    IN LPWSTR Message
    )
/*++

Routine Description:

    This routine puts up a popup message with the text received from
    a server.

Arguments:

    Server - Supplies the name of the server which the message was
        received from.

    Message - Supplies the message to put up received from the server.

Return Value:

    None.

--*/
{
    HMODULE MessageDll;

    WCHAR Title[128];
    WCHAR Buffer[NW_MAX_POPUP_MESSAGE_LENGTH];

    DWORD MessageLength;
    DWORD CharsToCopy;

#if DBG
    IF_DEBUG(MESSAGE)
    {
        KdPrint(("Server: (%ws), Message: (%ws)\n", Server, Message));
    }
#endif

    //
    // Load the netware message file DLL
    //
    MessageDll = LoadLibraryW(NW_EVENT_MESSAGE_FILE);

    if (MessageDll == NULL) {
        return;
    }

    RtlZeroMemory(Buffer, sizeof(Buffer)) ;
    MessageLength = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        (LPVOID) MessageDll,
                        NW_MESSAGE_TITLE,
                        0,
                        Title,
                        sizeof(Title) / sizeof(WCHAR),
                        NULL
                        );

    if (MessageLength == 0) {
        KdPrint(("NWWORKSTATION: FormatMessageW of title failed\n"));
        return;
    }


    //
    // Get string from message file to display where the message come
    // from.
    //
    MessageLength = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        (LPVOID) MessageDll,
                        NW_MESSAGE_FROM_SERVER,
                        0,
                        Buffer,
                        sizeof(Buffer) / sizeof(WCHAR),
                        (va_list *) &Server
                        );


    if (MessageLength != 0) {

        CharsToCopy = wcslen(Message);

        if (MessageLength + 1 + CharsToCopy > NW_MAX_POPUP_MESSAGE_LENGTH) {

            //
            // Message is too big.  Truncate the message.
            //
            CharsToCopy = NW_MAX_POPUP_MESSAGE_LENGTH - (MessageLength + 1);

        }

        wcsncpy(&Buffer[MessageLength], Message, CharsToCopy);

        if (IsTerminalServer()) {
            (void) SendMessageToLogonIdW( LogonId, Buffer, Title );
        } else {
            (void) MessageBeep(MB_ICONEXCLAMATION);
            (void) MessageBoxW(
                              NULL,
                              Buffer,
                              Title,
                              MB_OK | MB_SETFOREGROUND |
                              MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION
                              );
        }


    }
    else {
        KdPrint(("NWWORKSTATION: FormatMessageW failed %lu\n", GetLastError()));
    }

    (void) FreeLibrary(MessageDll);
}

VOID
NwDisplayPopup(
    IN LPNWWKS_POPUP_DATA lpPopupData
    )
/*++

Routine Description:

    This routine puts up a popup message for the given Id.

Arguments:

    MessageId - Supplies the message to put up.

Return Value:

    None.

--*/
{
    HMODULE MessageDll;

    WCHAR Title[128];
    WCHAR Buffer[NW_MAX_POPUP_MESSAGE_LENGTH];

    DWORD MessageLength;
    DWORD i ;

    //
    // Load the netware message file DLL
    //
    MessageDll = LoadLibraryW(NW_EVENT_MESSAGE_FILE);

    if (MessageDll == NULL) {
        return;
    }

    MessageLength = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE,
                        (LPVOID) MessageDll,
                        NW_MESSAGE_TITLE,
                        0,
                        Title,
                        sizeof(Title) / sizeof(WCHAR),
                        NULL
                        );

    if (MessageLength == 0) {
        KdPrint(("NWWORKSTATION: FormatMessageW of title failed\n"));
        return;
    }


    //
    // Get string from message file to display where the message come
    // from.
    //
    MessageLength = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        (LPVOID) MessageDll,
                        lpPopupData->MessageId,
                        0,
                        Buffer,
                        sizeof(Buffer) / sizeof(WCHAR),
                        (va_list *) &(lpPopupData->InsertStrings)
                        );

    for (i = 0; i < lpPopupData->InsertCount; i++)
        (void) LocalFree((HLOCAL)lpPopupData->InsertStrings[i]) ;


    if (MessageLength != 0) {
        if (IsTerminalServer()) {
            //--- Multiuser change -----
            (void) SendMessageToLogonIdW( lpPopupData->LogonId, Buffer, Title );
        } else {
            (void) MessageBeep(MB_ICONEXCLAMATION);

            (void) MessageBoxW(
                              NULL,
                              Buffer,
                              Title,
                              MB_OK | MB_SETFOREGROUND |
                              MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION
                              );
        }

    }
    else {
        KdPrint(("NWWORKSTATION: FormatMessageW failed %lu\n", GetLastError()));
    }

    (void) FreeLibrary(MessageDll);
}

#if 0

//
// This code was needed when we used to have a version of NwLink from MCS
// that didnt do the sockopts we needed. It used to be called by NwInitialize()
// and if the check failed, we logged an event
//

BOOL
NwIsNWLinkVersionOK(
    void
    )
/*++

Routine Description:

    This routine puts checks if the NWLINK version supports the
    sockopts added for IPX/SPX. if not, barf.

    Arguments:

    None.

    Return Value:

    TRUE is the version is OK, FALSE otherwise.

--*/
{
    int err ;
    SOCKET s ;
    WORD VersionRequested ;
    WSADATA wsaData ;
    IPX_NETNUM_DATA buf;
    int buflen = sizeof(buf);

    BOOL NeedCleanup = FALSE ;
    BOOL NeedClose = FALSE ;
    BOOL result = TRUE ;

    VersionRequested = MAKEWORD(1,1) ;

    if (err = WSAStartup(VersionRequested,
                         &wsaData))
    {
        //
        // cant even get winsock initialized. this is not a question
        // of wrong version. we will fail later. return TRUE
        //
        result = TRUE ;
        goto ErrorExit ;
    }
    NeedCleanup = TRUE ;

    s = socket(AF_IPX,
               SOCK_DGRAM,
               NSPROTO_IPX
              );

    if (s == INVALID_SOCKET)
    {
        //
        // cant even open socket. this is not a question
        // of wrong version. we will fail later. return TRUE
        //
        result = TRUE ;
        goto ErrorExit ;
    }
    NeedClose = TRUE ;

    if (err = getsockopt(s,
                         NSPROTO_IPX,
                         IPX_GETNETINFO,
                         (char FAR*)&buf,
                         &buflen
                         ))
    {
        err = WSAGetLastError() ;
        if (err == WSAENOPROTOOPT)
        {
             //
             // we got a no supported call. we know this is OLD
             // return FALSE
             //
             result = FALSE ;
             goto ErrorExit ;
        }
    }

    //
    // everything dandy. return TRUE
    //
    result = TRUE ;

ErrorExit:

    if (NeedClose)
        closesocket(s) ;
    if (NeedCleanup)
        WSACleanup() ;

    return result ;
}

#endif


DWORD
NwInitializeCritSects(
    VOID
    )
{
    static BOOL s_fBeenInitialized;

    DWORD dwError = NO_ERROR;
    BOOL  fFirst  = FALSE;

    if (!s_fBeenInitialized)
    {
        s_fBeenInitialized = TRUE;

        __try
        {
            //
            // Initialize the critical section to serialize access to
            // NwLogonNotifiedRdr flag. This is also used to serialize
            // access to GetewayLoggedOnFlag
            //
            InitializeCriticalSection( &NwLoggedOnCritSec );
            fFirst = TRUE;

            //
            // Initialize the critical section used by the print provider
            //
            InitializeCriticalSection( &NwPrintCritSec );
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // InitializeCriticalSection() can throw an out of memory exception
            //
            KdPrint(("NwInitializeCritSects: Caught exception %d\n",
                     GetExceptionCode()));

            if (fFirst)
            {
                DeleteCriticalSection( &NwLoggedOnCritSec );
            }

            dwError = ERROR_NOT_ENOUGH_MEMORY;

            s_fBeenInitialized = FALSE;
        }
    }

    return dwError;
}


BOOL
NwSetupInProgress(
    VOID
    )
{
    HKEY   hKey;
    DWORD  dwErr;
    DWORD  dwValue;
    DWORD  cbValue = sizeof(DWORD);

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REG_SETUP_PATH,
                         0,
                         KEY_QUERY_VALUE,
                         &hKey);

    if (dwErr != ERROR_SUCCESS)
    {
        return FALSE;
    }

    dwErr = RegQueryValueEx(hKey,
                            REG_SETUP_VALUE_NAME,
                            NULL,
                            NULL,
                            (LPBYTE) &dwValue,
                            &cbValue);

    RegCloseKey(hKey);

    if (dwErr != ERROR_SUCCESS)
    {
        return FALSE;
    }

    return dwValue;
}


//
// Multi-User Addition
//
/*****************************************************************************
 *
 *  SendMessageToLogonIdW
 *
 *   Send the supplied Message to the WinStation of LogonId
 *
 * ENTRY:
 *   LogonId (input)
 *     LogonId of WinStation to attempt to deliver the message to
 *
 *   pMessage (input)
 *     Pointer to message
 *
 *   pTitle (input)
 *     Pointer to title to use for the message box.
 *
 * EXIT:
 *   TRUE - Delivered the message
 *   FALSE - Could not deliver the message
 *
 ****************************************************************************/

BOOL
SendMessageToLogonIdW(
    LUID    LogonId,
    LPWSTR  pMessage,
    LPWSTR  pTitle
    )
{
    WCHAR LogonIdKeyName[NW_MAX_LOGON_ID_LEN];
    LONG  RegError;
    HKEY  InteractiveLogonKey;
    HKEY  OneLogonKey;
    ULONG TitleLength;
    ULONG MessageLength, Response;
    DWORD status;
    ULONG WinStationId;
    PULONG pWinId = NULL;
    BEEPINPUT BeepStruct;
    HMODULE hwinsta = NULL;
    PWINSTATION_SET_INFORMATION pfnWinStationSetInformation;
    PWINSTATION_SEND_MESSAGE    pfnWinStationSendMessage;
    BOOL bStatus = TRUE;

    RegError = RegOpenKeyExW(
                            HKEY_LOCAL_MACHINE,
                            NW_INTERACTIVE_LOGON_REGKEY,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            &InteractiveLogonKey
                            );

    if (RegError != ERROR_SUCCESS) {
        KdPrint(("SendMessageToLogonId: RegOpenKeyExW failed: Error %d\n",
                 GetLastError()));
        bStatus = FALSE;
        goto Exit;
    }

    NwLuidToWStr(&LogonId, LogonIdKeyName);

    //
    // Open the <LogonIdKeyName> key under Logon
    //
    RegError = RegOpenKeyExW(
                            InteractiveLogonKey,
                            LogonIdKeyName,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            &OneLogonKey
                            );

    if ( RegError != ERROR_SUCCESS ) {
#if DBG
        IF_DEBUG(PRINT)
        KdPrint(("SendMessageToLogonId: RegOpenKeyExW failed, Not interactive Logon: Error %d\n",
                 GetLastError()));
#endif
        (void) RegCloseKey(InteractiveLogonKey);
        bStatus = FALSE;
        goto Exit;
    }

    //
    // Read the WinStation ID value.
    //
    status = NwReadRegValue(
                           OneLogonKey,
                           NW_WINSTATION_VALUENAME,
                           (LPWSTR *) &pWinId
                           );

    (void) RegCloseKey(OneLogonKey);
    (void) RegCloseKey(InteractiveLogonKey);

    if (status != NO_ERROR) {
        KdPrint(("NWWORKSTATION: SendMessageToLogonId: Could not read WinStation ID ID from reg %lu\n", status));
        bStatus = FALSE;
        goto Exit;
    } else if (pWinId != NULL) {
        WinStationId = *pWinId;
        (void) LocalFree((HLOCAL) pWinId);
    } else {
        bStatus = FALSE;
        goto Exit;
    }

    if ( WinStationId == 0L ) {
        (void) MessageBeep(MB_ICONEXCLAMATION);

        (void) MessageBoxW(
                          NULL,
                          pMessage,
                          pTitle,
                          MB_OK | MB_SETFOREGROUND |
                          MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION
                          );
        bStatus = TRUE;
        goto Exit;
    }

    /*
     *  Beep the WinStation
     */
    BeepStruct.uType = MB_ICONEXCLAMATION;

    /* Nevermind any errors it's just a Beep */

    /*
    *  Get handle to winsta.dll
    */
    if ( (hwinsta = LoadLibraryW( L"WINSTA" )) != NULL ) {

        pfnWinStationSetInformation  = (PWINSTATION_SET_INFORMATION)
                                       GetProcAddress( hwinsta, "WinStationSetInformationW" );

        pfnWinStationSendMessage = (PWINSTATION_SEND_MESSAGE)
                                   GetProcAddress( hwinsta, "WinStationSendMessageW" );

        if (pfnWinStationSetInformation) {
            (void) pfnWinStationSetInformation( SERVERNAME_CURRENT,
                                                WinStationId,
                                                WinStationBeep,
                                                &BeepStruct,
                                                sizeof( BeepStruct ) );
        }

        if (pfnWinStationSendMessage) {

            // Now attempt to send the message

            TitleLength = (wcslen( pTitle ) + 1) * sizeof(WCHAR);
            MessageLength = (wcslen( pMessage ) + 1) * sizeof(WCHAR);

            if ( !pfnWinStationSendMessage( SERVERNAME_CURRENT,
                                            WinStationId,
                                            pTitle,
                                            TitleLength,
                                            pMessage,
                                            MessageLength,
                                            MB_OK | MB_SETFOREGROUND |
                                            MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION,
                                            (ULONG)-1,
                                            &Response,
                                            TRUE ) ) {

                bStatus = FALSE;
                goto Exit;
            }
        } else {
            bStatus = FALSE;
            goto Exit;
        }
    }
Exit:

    if (hwinsta) {
        FreeLibrary(hwinsta);
    }
    return(bStatus);
}

BOOL
NwGetLUIDDeviceMapsEnabled(
    VOID
    )

/*++

Routine Description:

    This function calls NtQueryInformationProcess() to determine if
    LUID device maps are enabled


Arguments:

    none

Return Value:

    TRUE - LUID device maps are enabled

    FALSE - LUID device maps are disabled

--*/

{

    NTSTATUS   Status;
    ULONG      LUIDDeviceMapsEnabled;
    BOOL       Result;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
#if DBG
        IF_DEBUG(PRINT)
        KdPrint(("NwGetLUIDDeviceMapsEnabled: Fail to check LUID DosDevices Enabled: Status 0x%lx\n",
                 Status));
#endif

        Result = FALSE;
    }
    else {
        Result = (LUIDDeviceMapsEnabled != 0);
    }

    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\nwwks_s_stub.c ===
#include "nwwks_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\queue.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    This module contains the support routines for the queue APIs that call
    into the NetWare redirector

Author:

    Yi-Hsin Sung    (yihsins)   24-Apr-1993

Revision History:

--*/

#include <nw.h>
#include <nwxchg.h>
#include <nwapi.h>
#include <nwreg.h>
#include <queue.h>
#include <splutil.h>
//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

DWORD
NwWriteJobInfoEntry(
    IN OUT LPBYTE *FixedPortion,
    IN OUT LPWSTR *EndOfVariableData,
    IN DWORD   Level,
    IN WORD    JobId,
    IN LPWSTR  PrinterName,
    IN LPWSTR  JobDescription,
    IN LPWSTR  UserName,
    IN BYTE    JobControlFlags,
    IN BYTE    JobPosition,
    IN LPBYTE  JobEntryTime,
    IN JOBTIME TargetExecutionTime,
    IN DWORD   FileSize
    );

DWORD 
ConvertToSystemTime( 
    IN  JOBTIME      JobTime, 
    OUT LPSYSTEMTIME pSystemTime
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

#define NW_RDR_SERVER_PREFIX L"\\Device\\Nwrdr\\"

#define QF_USER_HOLD      0x40
#define QF_OPERATOR_HOLD  0x80

//
// Stores the current user's print control options
//
//DWORD NwPrintOption = NW_PRINT_OPTION_DEFAULT;  - Commented out for multi-user code merge. We don't use global flag anymore
//                                                  The print option is passed from the client for each user
                               // Default Print Control Flags: Suppress form 
                               // feed, banner on, notify on



DWORD
NwAttachToNetwareServer(
    IN  LPWSTR  ServerName,
    OUT LPHANDLE phandleServer
    )
/*++

Routine Description:

    This routine opens a handle to the given server.

Arguments:

    ServerName    - The server name to attach to.
    phandleServer - Receives an opened handle to the preferred or
                    nearest server.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    NTSTATUS            ntstatus;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    LPWSTR FullName;
    UNICODE_STRING UServerName;

    FullName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                    (UINT) ( wcslen( NW_RDR_SERVER_PREFIX) +
                                             wcslen( ServerName ) - 1) *
                                             sizeof(WCHAR)
                                  );

    if ( FullName == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy( FullName, NW_RDR_SERVER_PREFIX );
    wcscat( FullName, ServerName + 2 );    // Skip past the prefix "\\"

    RtlInitUnicodeString( &UServerName, FullName );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open a handle to the preferred server.
    //
    ntstatus = NtOpenFile(
                   phandleServer,
                   SYNCHRONIZE | GENERIC_WRITE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        *phandleServer = NULL;
    }

    LocalFree( FullName );
    return RtlNtStatusToDosError(ntstatus);
}



DWORD
NwGetNextQueueEntry(
    IN HANDLE PreferredServer,
    IN OUT LPDWORD LastObjectId,
    OUT LPSTR QueueName
    )
/*++

Routine Description:

    This function uses an opened handle to the preferred server to
    scan it bindery for all print queue objects.

Arguments:

    PreferredServer - Supplies the handle to the preferred server on
        which to scan the bindery.

    LastObjectId - On input, supplies the object ID to the last print
        queue object returned, which is the resume handle to get the
        next print queue object.  On output, receives the object ID
        of the print queue object returned.

    QueueName - Receives the name of the returned print queue object.

Return Value:

    NO_ERROR - Successfully gotten a print name.

    WN_NO_MORE_ENTRIES - No other print queue object past the one
        specified by LastObjectId.

--*/
{
    NTSTATUS ntstatus;
    WORD ObjectType;

#if DBG
    IF_DEBUG(ENUM) {
        KdPrint(("NWWORKSTATION: NwGetNextQueueEntry LastObjectId %lu\n",
                 *LastObjectId));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   PreferredServer,
                   FSCTL_NWR_NCP_E3H,    // Bindery function
                   58,                   // Max request packet size
                   59,                   // Max response packet size
                   "bdwp|dwc",           // Format string
                   0x37,                 // Scan bindery object
                   *LastObjectId,        // Previous ID
                   0x3,                  // Print Queue object
                   "*",                  // Wildcard to match all
                   LastObjectId,         // Current ID
                   &ObjectType,          // Ignore
                   QueueName             // Currently returned print queue
                   );

    //
    // Unmap Japanese special chars
    //
    UnmapSpecialJapaneseChars(QueueName,(WORD)lstrlenA(QueueName));

#if DBG
    if ( NT_SUCCESS(ntstatus)) {
        IF_DEBUG(ENUM) {
            KdPrint(("NWWORKSTATION: NwGetNextQueueEntry NewObjectId %08lx, QueueName %s\n", *LastObjectId, QueueName));
        }
    }
#endif

    return NwMapBinderyCompletionCode(ntstatus);
}



DWORD
NwGetQueueId(
    IN  HANDLE  handleServer,
    IN  LPWSTR  QueueName,
    OUT LPDWORD QueueId
    )
/*++

Routine Description:

    This function opens a handle to the server and  scan its bindery
    for the given queue object id.

Arguments:
    handleServer - Supplies the handle of the server on which to
                   scan the bindery.

    QueueName - Supplies the name of the print queue.

    QueueId - On output, supplies the object ID of the given queue.


Return Value:

    NO_ERROR - Successfully gotten a file server name.

--*/
{

    NTSTATUS ntstatus;

    UNICODE_STRING UQueueName;
    OEM_STRING     OemQueueName;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwGetQueueId %ws\n",
                 QueueName ));
    }
#endif

    RtlInitUnicodeString( &UQueueName, QueueName);
    ntstatus = RtlUnicodeStringToOemString( &OemQueueName, &UQueueName, TRUE);

    //
    // Map Japanese special characters
    //
    MapSpecialJapaneseChars(OemQueueName.Buffer,OemQueueName.Length);

    if ( NT_SUCCESS(ntstatus))
    {
        ntstatus = NwlibMakeNcp(
                       handleServer,
                       FSCTL_NWR_NCP_E3H,    // Bindery function
                       58,                   // Max request packet size
                       59,                   // Max response packet size
                       "bdwp|d",             // Format string
                       0x37,                 // Scan bindery object
                       0xFFFFFFFF,           // Previous ID
                       0x3,                  // Print Queue object
                       OemQueueName.Buffer,  // Queue Name
                       QueueId               // Queue ID
                       );
    }

#if DBG
    if ( NT_SUCCESS(ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwGetQueueId QueueId %08lx\n",
                     *QueueId ));
        }
   }
#endif

    RtlFreeOemString( &OemQueueName );
    return NwMapBinderyCompletionCode(ntstatus);

}



DWORD
NwCreateQueueJobAndFile(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  LPWSTR  DocumentName,
    IN  LPWSTR  UserName,
    IN  DWORD   PrintOption,               //Multi-user change
    IN  LPWSTR  QueueName,
    OUT LPWORD  JobId
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    enter a new job into the queue with the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                which add the job.

    QueueId   - Supplies the id of the queue in which to add the job.
    DocumentName  - Supplies the name of the document to be printed
    UserName   - Supplies the banner name to be printed
    QueueName  - Supplies the header name to be printed
    JobId  - Receives the job id of the newly added job.

Return Value:

    NO_ERROR - Successfully added the job to the queue.

--*/
{
    NTSTATUS ntstatus = STATUS_SUCCESS;

    UNICODE_STRING UDocumentName;
    OEM_STRING     OemDocumentName;
    UNICODE_STRING UUserName;
    OEM_STRING     OemUserName;
    UNICODE_STRING UQueueName;
    OEM_STRING     OemQueueName;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwCreateQueueJobAndFile QueueId %08lx\n",
                 QueueId ));
    }
#endif

    if ( UserName )
    {
        RtlInitUnicodeString( &UUserName, UserName);
        ntstatus = RtlUnicodeStringToOemString( &OemUserName,
                                                &UUserName,
                                                TRUE );
    }

    if ( NT_SUCCESS(ntstatus) && DocumentName )
    {
        RtlInitUnicodeString( &UDocumentName, DocumentName);
        ntstatus = RtlUnicodeStringToOemString( &OemDocumentName,
                                                &UDocumentName,
                                                TRUE );
    }

    if ( NT_SUCCESS(ntstatus) && QueueName )
    {
        RtlInitUnicodeString( &UQueueName, QueueName);
        ntstatus = RtlUnicodeStringToOemString( &OemQueueName,
                                                &UQueueName,
                                                TRUE );
    }

    if ( NT_SUCCESS( ntstatus)) {

        LPSTR pszDocument, pszUser, pszQueue;

        pszDocument = DocumentName? OemDocumentName.Buffer : "";
        pszUser = UserName? OemUserName.Buffer : "";
        pszQueue = QueueName? OemQueueName.Buffer : "";

        //Multi-user uses passed print flag
        //
        ntstatus = NwlibMakeNcp(
                               handleServer,
                               FSCTL_NWR_NCP_E3H,        // Bindery function
                               263,                      // Max request packet size
                               56,                       // Max response packet size
                               "bd_ddw_b_Cbbwwww_C-C-_|_w", // Format string
                               0x68,                     // Create Queue Job and File object
                               QueueId,                  // Queue ID
                               6,                        // Skip bytes
                               0xffffffff,               // Target Server ID number
                               0xffffffff, 0xffff,       // Target Execution time
                               11,                       // Skip bytes
                               0x00,                     // Job Control Flags
                               26,                       // Skip bytes
                               pszDocument,              // TextJobDescription
                               50,                       // Skip bytes
                               0,                         // Version number (clientarea)
                               8,                        // Tab Size
                               1,                        // Number of copies
                               PrintOption,              // Print Control Flags
                               0x3C,                     // Maximum lines
                               0x84,                     // Maximum characters
                               22,                       // Skip bytes
                               pszUser,                  // Banner Name
                               12,                       // Max Length of pszUser
                               pszQueue,                 // Header Name
                               12,                       // Max Length of pszQueue
                               14 + 80,                  // Skip remainder of client area
                               22,                       // Skip bytes
                               JobId                     // Job ID 
                               );


    }

#if DBG
    if ( NT_SUCCESS( ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwCreateQueueJobAndFile JobId %d\n", 
                    *JobId ));
        }
    }
#endif

    if ( DocumentName )
        RtlFreeOemString( &OemDocumentName );
    if ( UserName )
        RtlFreeOemString( &OemUserName );
    if ( QueueName )
        RtlFreeOemString( &OemQueueName );
    return NwMapStatus(ntstatus);
}



DWORD
NwCloseFileAndStartQueueJob(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    close a job file and mark the job file ready for service.

Arguments:

    handleServer - Supplies the handle to the server on
                which add the job.

    QueueId   - Supplies the id of the queue in which to add the job.
    JobId     - Supplies the job id.

Return Value:

    NO_ERROR - Successfully added the job to the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwCloseFileAndStartQueueJob QueueId %08lx JobId %d\n", QueueId, JobId ));
    }
#endif

    // Two versions of CloseFileAndStartQueueJobNCP

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   9,                        // Max request packet size
                   2,                        // Max response packet size
                   "bdw|",                   // Format string
                   0x69,                     // Close File And Start Queue Job
                   QueueId,                  // Queue ID
                   JobId );                  // Job ID 

    return NwMapStatus(ntstatus);
}



DWORD
NwRemoveJobFromQueue(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId
    )
/*++

Routine Description:

    This function removes a job from a queue and closes the associate file.

Arguments:

    handleServer - Supplies the handle to the server on
                   which to remove the job.

    QueueId - Supplies the id of the queue in which to remove the job.
    JobId   - Supplies the job id to be removed.

Return Value:

    NO_ERROR - Successfully removed the job from the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwRemoveJobFromQueue QueueId %08lx JobId %d\n",
                  QueueId, JobId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   9,                        // Max request packet size
                   2,                        // Max response packet size
                   "bdw|",                   // Format string
                   0x6A,                     // Remove Job From Queue
                   QueueId,                  // Queue ID
                   JobId );                  // Job ID 

    return NwMapStatus(ntstatus);
}


DWORD
NwRemoveAllJobsFromQueue(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId
    )
/*++

Routine Description:

    This function removes all jobs from a queue.

Arguments:

    handleServer - Supplies the handle to the server on
                   which to remove all jobs.

    QueueId - Supplies the id of the queue in which to remove all jobs.

Return Value:

    NO_ERROR - Successfully removed all jobs from the queue.

--*/
{
    DWORD err;
    WORD  JobCount = 0;
    WORD  pwJobList[250];
    WORD  i;

#if DBG
    IF_DEBUG(QUEUE) 
    {
        KdPrint(("NWWORKSTATION: NwRemoveAllJobsFromQueue QueueId %08lx\n", 
                QueueId ));
    }
#endif

    pwJobList[0] = 0;
    err = NwGetQueueJobList( handleServer,
                             QueueId,
                             &JobCount,
                             pwJobList );

    for ( i = 0; !err && i < JobCount; i++ )
    {
        err = NwRemoveJobFromQueue( handleServer,
                                    QueueId,
                                    pwJobList[i] );

    }

    return err;
}


DWORD
NwReadQueueCurrentStatus(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    OUT LPBYTE  QueueStatus,
    OUT LPBYTE  NumberOfJobs
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    query the status of the queue with the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    QueueStatus  - Receives the status of the queue
    NumberOfJobs - Receives the number of jobs in the queue.

Return Value:

    NO_ERROR - Successfully retrieved the status of the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwReadQueueCurrentStatus QueueId %08lx\n",
                 QueueId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   7,                        // Max request packet size
                   135,                      // Max response packet size
                   "bd|==bb",                // Format string
                   0x66,                     // ReadQueueCurrentStatus
                   QueueId,                  // Queue ID
                   QueueStatus,              // Queue status
                   NumberOfJobs              // Number of jobs in the queue
                   );

#if DBG
    if ( NT_SUCCESS( ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwReadQueueCurrentStatus QueueStatus %d Number of Jobs %d\n", *QueueStatus, *NumberOfJobs ));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}


DWORD
NwSetQueueCurrentStatus(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  BYTE    QueueStatus
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    set the status (pause/ready...) of the queue with the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    QueueStatus  - Supplies the status of the queue

Return Value:

    NO_ERROR - Successfully set the status of the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwSetQueueCurrentStatus QueueId %08lx\n",
                 QueueId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   8,                        // Max request packet size
                   2,                        // Max response packet size
                   "bdb|",                   // Format string
                   0x67,                     // ReadQueueCurrentStatus
                   QueueId,                  // Queue ID
                   QueueStatus               // Queue status
                   );

    return NwMapStatus(ntstatus);
}


DWORD
NwGetQueueJobList(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    OUT LPWORD  NumberOfJobs,
    OUT LPWORD  JobIdList
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the job list of the queue with the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    NumberOfJobs - Receives the number of jobs in the queue.
    JobIdList    - Receives the array of job ids  in the queue

Return Value:

    NO_ERROR - Successfully added the job to the queue.

--*/
{
    NTSTATUS ntstatus;
#if DBG
    WORD i;

    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwGetQueueJobList QueueId %08lx\n",
                 QueueId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   7,                        // Max request packet size
                   506,                      // Max response packet size
                   "bd|W",                   // Format string
                   0x6B,                     // Get Queue Job List
                   QueueId,                  // Queue ID
                   NumberOfJobs,             // Number of jobs in the queue
                   JobIdList                 // Array of job ids
                   );

#if DBG
    if ( NT_SUCCESS(ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwGetQueueJobList Number of Jobs %d\nJob List = ", *NumberOfJobs ));
            for ( i = 0; i < *NumberOfJobs; i++ )
                KdPrint(("%d ", JobIdList[i] ));
            KdPrint(("\n"));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}



DWORD
NwReadQueueJobEntry(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    OUT JOBTIME TargetExecutionTime,
    OUT JOBTIME JobEntryTime,
    OUT LPBYTE  JobPosition,
    OUT LPBYTE  JobControlFlags,
    OUT LPSTR   TextJobDescription,
    OUT LPSTR   UserName
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the information about the job with the given JobId
    in the given QueueId.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    JobId        - Supplies the job we are interested in

    TargetExecutionTime -
    JobEntryTime -
    JobPosition  -
    JobControlsFlags -
    TextJobDescription -

Return Value:

    NO_ERROR - Successfully added the job to the queue.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwReadQueueJobEntry QueueId %08lx JobId %d\n",
                  QueueId, JobId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   9,                        // Max request packet size
                   258,                      // Max response packet size
                   "bdw|_rr==bb_C_c",        // Format string
                   0x6C,                     // Read Queue Job Entry
                   QueueId,                  // Queue ID
                   JobId,                    // Job ID 
                   10,                       // Skip bytes
                   TargetExecutionTime,      // Array storing execution time
                   6,                        // Size of TargetExecutionTime
                   JobEntryTime,             // Array storing job entry time
                   6,                        // Size of JobEntryTime
                   JobPosition,              // Job Position
                   JobControlFlags,          // Job Control Flag
                   26,                       // Skip bytes
                   TextJobDescription,       // Array storing the description
                   50,                       // Maximum size in the above array
                   32,                       // Skip bytes
                   UserName                  // Banner Name
                   );

#if DBG
    if ( NT_SUCCESS( ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwReadQueueJobEntry JobPosition %d Status %d Description %s\n", *JobPosition, *JobControlFlags, TextJobDescription ));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}



DWORD
NwGetQueueJobsFileSize(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    OUT LPDWORD FileSize
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the file size of the given job.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    JobId        - Identifying the job we are interested in
    FileSize     - Receives the file size of the given job

Return Value:

    NO_ERROR - Successfully retrieved the file size.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwGetQueueJobsFileSize QueueId %08lx JobId %d\n", QueueId, JobId ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   9,                        // Max request packet size
                   12,                       // Max response packet size
                   "bdw|===d",               // Format string
                   0x78,                     // Get Queue Job's File Size
                   QueueId,                  // Queue ID
                   JobId,                    // Job ID 
                   FileSize                  // File Size
                   );

#if DBG
    if ( NT_SUCCESS( ntstatus)) {
        IF_DEBUG(QUEUE) {
            KdPrint(("NWWORKSTATION: NwGetQueueJobsFileSize File Size %d\n",
                    *FileSize ));
        }
    }
#endif

    return NwMapStatus(ntstatus);
}



DWORD
NwChangeQueueJobPosition(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  BYTE    NewPosition
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the change a job's position in a queue.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    JobId        - Identifying the job we are interested in
    NewPosition  - Supplies the new position of the job 

Return Value:

    NO_ERROR - Successfully retrieved the file size.

--*/
{
    NTSTATUS ntstatus;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwChangeQueueJobPosition QueueId %08lx JobId %d NewPosition %d\n", QueueId, JobId, NewPosition ));
    }
#endif

    ntstatus = NwlibMakeNcp(
                   handleServer,
                   FSCTL_NWR_NCP_E3H,        // Bindery function
                   10,                       // Max request packet size
                   2,                        // Max response packet size
                   "bdwb|",                  // Format string
                   0x6E,                     // Change Queue Job Position
                   QueueId,                  // Queue ID
                   JobId,                    // Job ID 
                   NewPosition               // New position of the job
                   );

    return NwMapStatus(ntstatus);
}



DWORD
NwChangeQueueJobEntry(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  DWORD   dwCommand,
    IN  PNW_JOB_INFO pNwJobInfo
    )
/*++

Routine Description:

    This function uses an opened handle to a server to
    get the change a job's position in a queue.

Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue
    JobId        - Identifying the job we are interested in
    JobControlFlags - Supplies the new job control flags
    pNwJobInfo   - 

Return Value:

    NO_ERROR - Successfully retrieved the file size.

--*/
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    DWORD TargetServerId;
    JOBTIME TargetExecutionTime;
    WORD JobType;
    BYTE JobControlFlags;
    BYTE TextJobDescription[50];
    BYTE ClientRecordArea[152];

    UNICODE_STRING UDocumentName;
    UNICODE_STRING UUserName;
    OEM_STRING     OemDocumentName, *pOemDocumentName = NULL;
    OEM_STRING     OemUserName, *pOemUserName = NULL;
    LPSTR          pszDocument, pszUser;

#if DBG
    IF_DEBUG(QUEUE) {
        KdPrint(("NWWORKSTATION: NwChangeQueueJobEntry QueueId %08lx JobId %d dwCommand %d\n", QueueId, JobId, dwCommand ));
    }
#endif

    TextJobDescription[0] = 0;
    if ( pNwJobInfo )
    {
        if ( pNwJobInfo->pUserName )
        {
            RtlInitUnicodeString( &UUserName, pNwJobInfo->pUserName);
            ntstatus = RtlUnicodeStringToOemString( &OemUserName,
                                                    &UUserName,
                                                    TRUE );
            if ( NT_SUCCESS(ntstatus) )
                pOemUserName = &OemUserName ;  // record to free later
        }

        if ( NT_SUCCESS(ntstatus) && pNwJobInfo->pDocument )
        {
            RtlInitUnicodeString( &UDocumentName, pNwJobInfo->pDocument);
            ntstatus = RtlUnicodeStringToOemString( &OemDocumentName,
                                                    &UDocumentName,
                                                    TRUE );
            if ( NT_SUCCESS(ntstatus) )
                pOemDocumentName = &OemDocumentName ;  // record to free later
        }

        if ( NT_SUCCESS( ntstatus)) 
        {
            pszDocument = pNwJobInfo->pDocument? OemDocumentName.Buffer : "";
            pszUser = pNwJobInfo->pUserName? OemUserName.Buffer: "";
        }
    }

    if ( NT_SUCCESS( ntstatus))
    {
        ntstatus = NwlibMakeNcp(
                       handleServer,
                       FSCTL_NWR_NCP_E3H,        // Bindery function
                       9,                        // Max request packet size
                       258,                      // Max response packet size
                       "bdw|_dr_w-b_rr",         // Format string
                       0x6C,                     // Read Queue Job Entry
                       QueueId,                  // Queue ID
                       JobId,                    // Job ID 
                       6,                        // Skip bytes
                       &TargetServerId,          // Target Server ID Number
                       TargetExecutionTime,      // Target Execution Time
                       6,                        // sizeof TargetExecutionTime
                       8,                        // Skip bytes 
                       &JobType,                 // Job Type
                       &JobControlFlags,         // Job Control flags
                       26,                       // Skip bytes
                       TextJobDescription,       // TextJobDescription
                       50,                       // sizeof TextJobDescription
                       ClientRecordArea,         // Client record area
                       152                       // sizeof ClientRecordArea
                       );
    }

    if ( NT_SUCCESS( ntstatus))
    {
        switch ( dwCommand )
        {
            case JOB_CONTROL_PAUSE:
                JobControlFlags |=  QF_USER_HOLD;
                break;

            case JOB_CONTROL_RESUME:
                JobControlFlags &= ~( QF_USER_HOLD | QF_OPERATOR_HOLD );
                break;
   
            default:
                break;
                
        }

        ntstatus = NwlibMakeNcp(
                       handleServer,
                       FSCTL_NWR_NCP_E3H,        // Bindery function
                       263,                      // Max request packet size
                       2,                        // Max response packet size
                       "bd_dr_ww-b_CrCr|",       // Format string
                       0x6D,                     // Change Queue Job Entry
                       QueueId,                  // Queue ID
                       6,                        // Skip bytes
                       TargetServerId,           // Target Server ID Number
                       TargetExecutionTime,      // Target Execution Time
                       6,                        // sizeof TargetExecutionTime
                       6,                        // Skip bytes
                       JobId,                    // Job ID 
                       JobType,                  // Job Type
                       JobControlFlags,          // Job Control Flags
                       26,                       // Skip bytes
                       pNwJobInfo? pszDocument
                                 : TextJobDescription,    // Description
                       50,                       // Skip bytes of Description
                       ClientRecordArea,         // Client Record Area
                       32,                       // First 32 bytes of the above
                       pNwJobInfo? pszUser
                                 : (LPSTR) &ClientRecordArea[32], // Banner Name
                       13,                       // sizeof BannerName
                       &ClientRecordArea[45],    // Rest of the Client Area
                       107                       // sizeof the above
                       );
    }

    if ( pOemDocumentName )
        RtlFreeOemString( pOemDocumentName );

    if ( pOemUserName )
        RtlFreeOemString( pOemUserName );

    return NwMapStatus(ntstatus);
}



DWORD
NwGetQueueJobs(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  LPWSTR  PrinterName,
    IN  DWORD   FirstJobRequested,
    IN  DWORD   EntriesRequested,
    IN  DWORD   Level,
    OUT LPBYTE  Buffer,
    IN  DWORD   cbBuf,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD Entries
    )
/*++

Routine Description:


Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue

Return Value:


--*/
{
    DWORD err = NO_ERROR;

    DWORD i;
    WORD  JobCount = 0;
    WORD  pwJobList[250];

    DWORD EntrySize = 0;
    LPBYTE FixedPortion = Buffer;
    LPWSTR EndOfVariableData = ( LPWSTR ) ( Buffer + cbBuf );

#if DBG
    IF_DEBUG(QUEUE)
        KdPrint(("NWWORKSTATION: NwGetQueueJobs QueueId %08lx\n", QueueId));
#endif

    *BytesNeeded = 0;
    *Entries = 0;

    err = NwGetQueueJobList( handleServer,
                             QueueId,
                             &JobCount,
                             pwJobList );


    if ( err )
    {
        KdPrint(("NWWORKSTATION: NwGetQueueJobList Error %d\n", err ));
        return err;
    }

    for ( i = 0; (i < EntriesRequested) && ( i+FirstJobRequested+1 <= JobCount);
          i++ )
    {
        err = NwGetQueueJobInfo( handleServer,
                                 QueueId,
                                 pwJobList[i+FirstJobRequested],
                                 PrinterName,
                                 Level,
                                 &FixedPortion,
                                 &EndOfVariableData,
                                 &EntrySize );
                             
        if ( err != NO_ERROR && err != ERROR_INSUFFICIENT_BUFFER )
             break;

        *BytesNeeded += EntrySize;
    }


    if ( err == ERROR_INSUFFICIENT_BUFFER ) 
    {
        *Entries = 0;
    }
    else if ( err == NO_ERROR )
    {
        *Entries = i;
    }

    return err;
}



DWORD
NwGetQueueJobInfo(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  LPWSTR  PrinterName,
    IN  DWORD   Level,
    IN OUT LPBYTE  *FixedPortion,
    IN OUT LPWSTR  *EndOfVariableData,
    OUT LPDWORD EntrySize
    )
/*++

Routine Description:


Arguments:

    handleServer - Supplies the handle to the server on
                   which add the job.
    QueueId      - Supplies the id of the queue

Return Value:


--*/
{
    DWORD err;
    LPWSTR UTextJobDescription = NULL;
    LPWSTR UUserName = NULL;

    JOBTIME TargetExecutionTime;
    JOBTIME JobEntryTime;
    BYTE  JobPosition;
    BYTE  JobControlFlags;
    CHAR  UserName[14];
    CHAR  TextJobDescription[50];
    DWORD FileSize = 0;

    TextJobDescription[0] = 0;

    err = NwReadQueueJobEntry( handleServer,
                               QueueId,
                               JobId,
                               TargetExecutionTime,
                               JobEntryTime,
                               &JobPosition,
                               &JobControlFlags,
                               TextJobDescription,
                               UserName );

    if ( err )
    {
        KdPrint(("NWWORKSTATION: NwReadQueueJobEntry JobId %d Error %d\n",
                  JobId, err ));
        return err;
    }

    if (!NwConvertToUnicode( &UTextJobDescription, TextJobDescription ))
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
        goto ErrorExit ;
    }

    if (!NwConvertToUnicode( &UUserName, UserName ))
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
        goto ErrorExit ;
    }

    *EntrySize = ( Level == 1? sizeof( JOB_INFO_1W ) : sizeof( JOB_INFO_2W ))
                 + ( wcslen( UTextJobDescription ) + wcslen( UUserName) + 
                     wcslen( PrinterName ) + 3 ) * sizeof( WCHAR );
    //
    // See if the buffer is large enough to fit the entry
    //
    if ( (LPWSTR)( *FixedPortion + *EntrySize ) > *EndOfVariableData )
    {
        err = ERROR_INSUFFICIENT_BUFFER; 
        goto ErrorExit ;
    }

    if ( Level == 2 )
    {
        err = NwGetQueueJobsFileSize( handleServer,
                                      QueueId,
                                      JobId,
                                      &FileSize );

        if ( err )
        {
            KdPrint(("NWWORKSTATION: NwGetQueueJobsFileSize JobId %d Error %d\n", JobId, err ));
            goto ErrorExit ;
        }
    }

    err = NwWriteJobInfoEntry( FixedPortion,
                               EndOfVariableData,
                               Level,
                               JobId,
                               PrinterName,
                               UTextJobDescription,
                               UUserName,
                               JobControlFlags,
                               JobPosition,
                               JobEntryTime,
                               TargetExecutionTime,
                               FileSize );

ErrorExit: 

    if (UTextJobDescription)
        (void) LocalFree((HLOCAL) UTextJobDescription) ;
    if (UUserName)
        (void) LocalFree((HLOCAL) UUserName) ;

    return err;
}



DWORD
NwWriteJobInfoEntry(
    IN OUT LPBYTE *FixedPortion,
    IN OUT LPWSTR *EndOfVariableData,
    IN DWORD Level,
    IN WORD  JobId,
    IN LPWSTR PrinterName,
    IN LPWSTR JobDescription,
    IN LPWSTR UserName,
    IN BYTE  JobControlFlags,
    IN BYTE  JobPosition,
    IN JOBTIME JobEntryTime,
    IN JOBTIME TargetExecutionTime,
    IN DWORD  FileSize
    )
/*++

Routine Description:

    This function packages a JOB_INFO_1 or JOB_INFO_2 entry into the
    user output buffer.

Arguments:

    FixedPortion - Supplies a pointer to the output buffer where the next
        entry of the fixed portion of the use information will be written.
        This pointer is updated to point to the next fixed portion entry
        after a PRINT_INFO_1 entry is written.

    EndOfVariableData - Supplies a pointer just off the last available byte
        in the output buffer.  This is because the variable portion of the
        user information is written into the output buffer starting from
        the end.

        This pointer is updated after any variable length information is
        written to the output buffer.

Return Value:

    NO_ERROR - Successfully wrote entry into user buffer.

    ERROR_INSUFFICIENT_BUFFER - Buffer was too small to fit entry.

--*/
{
    DWORD err = NO_ERROR;
    BOOL FitInBuffer = TRUE;
    DWORD JobStatus = 0;

    JOB_INFO_1W *pJobInfo1 = (JOB_INFO_1W *) *FixedPortion;
    JOB_INFO_2W *pJobInfo2 = (JOB_INFO_2W *) *FixedPortion;


    if (  ( JobControlFlags & QF_USER_HOLD )
       || ( JobControlFlags & QF_OPERATOR_HOLD )
       )
    {
        JobStatus = JOB_STATUS_PAUSED;
    }

    //
    // See if buffer is large enough to fit the entry.
    //

    if ( Level == 1 )
    {
        pJobInfo1->JobId = JobId;
        pJobInfo1->Position = JobPosition;
        pJobInfo1->Status = JobStatus;
        if ( err = ConvertToSystemTime( JobEntryTime, &pJobInfo1->Submitted ))
            return err;

        pJobInfo1->pMachineName = NULL;
        pJobInfo1->pDatatype = NULL;
        pJobInfo1->pStatus = NULL;
        pJobInfo1->Priority = 0;
        pJobInfo1->TotalPages = 0;
        pJobInfo1->PagesPrinted = 0;

        //
        // Update fixed entry pointer to next entry.
        //
        (*FixedPortion) += sizeof(JOB_INFO_1W);

        //
        // PrinterName
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          PrinterName,
                          wcslen(PrinterName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo1->pPrinterName
                          );

        ASSERT(FitInBuffer);

        //
        // UserName
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          UserName,
                          wcslen(UserName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo1->pUserName
                          );

        ASSERT(FitInBuffer);

        //
        // Description
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          JobDescription,
                          wcslen(JobDescription),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo1->pDocument
                          );

        ASSERT(FitInBuffer);
    }
    else  // Level == 2
    {
        pJobInfo2->JobId = JobId;
        pJobInfo2->Position = JobPosition;
        pJobInfo2->Status = JobStatus;
        if ( err = ConvertToSystemTime( JobEntryTime, &pJobInfo2->Submitted ))
            return err;

        pJobInfo2->StartTime = 0;
        pJobInfo2->Size = FileSize;

        pJobInfo2->pMachineName = NULL;
        pJobInfo2->pNotifyName = NULL;
        pJobInfo2->pDatatype = NULL;
        pJobInfo2->pPrintProcessor = NULL;
        pJobInfo2->pParameters = NULL;
        pJobInfo2->pDriverName = NULL;
        pJobInfo2->pDevMode = NULL;
        pJobInfo2->pStatus = NULL;
        pJobInfo2->pSecurityDescriptor = NULL;
        pJobInfo2->Priority = 0;
        pJobInfo2->TotalPages = 0;
        pJobInfo2->UntilTime = 0;
        pJobInfo2->Time = 0;
        pJobInfo2->PagesPrinted = 0;

        //
        // Update fixed entry pointer to next entry.
        //
        (*FixedPortion) += sizeof(JOB_INFO_2W);

        //
        // PrinterName
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          PrinterName,
                          wcslen(PrinterName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo2->pPrinterName
                          );

        ASSERT(FitInBuffer);

        //
        // UserName
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          UserName,
                          wcslen(UserName),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo2->pUserName
                          );

        ASSERT(FitInBuffer);

        //
        // Description
        //
        FitInBuffer = NwlibCopyStringToBuffer(
                          JobDescription,
                          wcslen(JobDescription),
                          (LPCWSTR) *FixedPortion,
                          EndOfVariableData,
                          &pJobInfo2->pDocument
                          );

        ASSERT(FitInBuffer);
    }

    if (!FitInBuffer)
        return ERROR_INSUFFICIENT_BUFFER;

    return NO_ERROR;
}



DWORD 
ConvertToSystemTime( 
    IN  JOBTIME      JobTime,
    OUT LPSYSTEMTIME pSystemTime 
)
/*++

Routine Description:

Arguments:
    JobTime -
    pSystemTime -

Return Value:

--*/
{
    FILETIME fileTimeLocal, fileTimeUTC;
    
    pSystemTime->wYear   = JobTime[0] + 1900;
    pSystemTime->wMonth  = JobTime[1];
    pSystemTime->wDay    = JobTime[2];
    pSystemTime->wDayOfWeek = 0;
    pSystemTime->wHour   = JobTime[3];
    pSystemTime->wMinute = JobTime[4];
    pSystemTime->wSecond = JobTime[5];
    pSystemTime->wMilliseconds = 0;

    if (  ( !SystemTimeToFileTime( pSystemTime, &fileTimeLocal ) )
       || ( !LocalFileTimeToFileTime( &fileTimeLocal, &fileTimeUTC ) )
       || ( !FileTimeToSystemTime( &fileTimeUTC, pSystemTime ) )
       )
    {
        KdPrint(("NWWORKSTATION: Time Conversion Error = %d\n",GetLastError()));
        return GetLastError();
    }

    return NO_ERROR;
}

#ifndef NOT_USED

DWORD

 NwCreateQueue ( IN  HANDLE hServer, 
                 IN  LPWSTR pszQueue,
                 OUT LPDWORD  pQueueId 
               )

/*+++
Routine Description:
  
   Uses the handle opened to a server to create a queue on the server.
   Return the Queue Id if successful.
   
Arguments:

        hServer   : Handle to the file Server
        pszQueue : Name of the queue that you are creating on the server
        pQueueId : Address of QueueId

        
Return Value:

    An error condition as it arises.
    NO_ERROR: Successful in adding printer name
    ERROR   : otherwise 
--*/

{
   NTSTATUS ntstatus;
   WORD ObjectType;
   UNICODE_STRING UQueueName;
   OEM_STRING OemQueueName;

   *pQueueId = 0;
#if DBG
    IF_DEBUG(PRINT) {
        KdPrint(("NWWORKSTATION: NwCreateQueue : %ws\n",
                 pszQueue));
    }
#endif

    RtlInitUnicodeString( &UQueueName, pszQueue);
    ntstatus = RtlUnicodeStringToOemString( &OemQueueName, &UQueueName, TRUE);

    if ( NT_SUCCESS(ntstatus))
       {
       
          ntstatus = NwlibMakeNcp(
                           hServer,
                           FSCTL_NWR_NCP_E3H,
                           174,
                           6,
                           "bwpbp|d",
                           0x64,                          //Create Queue
                           0x0003,                       // Queue Type = Print Queue
                           OemQueueName.Buffer,          //Queue Name
                           0x00,                         // Directory Handle
                           "SYS:SYSTEM",                //queue created in SYS:SYSTEM directory
                           pQueueId
                           );


       }
    else 
       {
          goto Exit;
       }

    if ( NT_SUCCESS(ntstatus)) {
#if DBG
        IF_DEBUG(ENUM) {
            KdPrint(("NWWORKSTATION: NwCreateQueue successful\n" ));
        }
#endif

    }
    else
       goto FreeExit;
      
   // Change Property Security on Q_OPERATORS

    ntstatus = NwlibMakeNcp (
                    hServer,
                    FSCTL_NWR_NCP_E3H,
                    70,
                    2,
                    "bwpbp|",         
                    0x3B,
                    0x0003,
                    OemQueueName.Buffer,
                    0x1,                             //New Property security
                    "Q_OPERATORS"
                    );
                            


    if ( NT_SUCCESS(ntstatus)) {
#if DBG
        IF_DEBUG(PRINT) {
            KdPrint(("NWWORKSTATION: Change Property Security  successful\n" ));
        }
#endif

    }
    else
       //unable to add new property security, so destroy queue and go to end
 {
    (void) NwDestroyQueue( hServer, 
                           *pQueueId );

    goto FreeExit;
 }
       

   // Add Bindery Object of Type Queue to Set

   ntstatus = NwlibMakeNcp (
                       hServer,
                       FSCTL_NWR_NCP_E3H,    // Bindery function
                       122,
                         2,
                       "bwppwp|",
                       0x41,
                       0x0003,
                       OemQueueName.Buffer,
                       "Q_OPERATORS",
                       0x0001,
                       "SUPERVISOR"
                       );
 


    if ( NT_SUCCESS(ntstatus)) {

#if DBG
        IF_DEBUG(PRINT) {
            KdPrint(("NWWORKSTATION: Add Bindery Object:Q_OPERATORS\n" ));
        }
#endif

    }
    else
 {
       (void)NwDestroyQueue(hServer,*pQueueId);
       goto FreeExit;

 }
   // Add Bindery Object to Set of Q_USERS 

   ntstatus = NwlibMakeNcp (
                       hServer,
                       FSCTL_NWR_NCP_E3H,    // Bindery function
                       122,
                         2,
                       "bwppwp|",
                       0x41,
                       0x0003,
                       OemQueueName.Buffer,
                       "Q_USERS",
                       0x0002,
                       "EVERYONE"
                       );
 
      // bunch of parameters to Add Bindery Object to Set Q_USERS 

 
    if ( NT_SUCCESS(ntstatus)) {
#if DBG
        IF_DEBUG(PRINT) {
            KdPrint(("NWWORKSTATION: AddBinderyObjecttoSet Q_USERS\n" ));
        }
#endif


    }


FreeExit: RtlFreeOemString( &OemQueueName);
Exit:
    return NwMapBinderyCompletionCode(ntstatus);
}

 
DWORD 
NwAssocPServers ( IN HANDLE hServer,
                  IN LPWSTR  pszQueue,
                  IN LPWSTR pszPServer
                )

/*+++
Routine Description:
  
   Associates a list of Q Servers with a queue id. This list is supplied
   to this routine as pszPServer with entries separated by semicolons   
   
Arguments:

        hServer   : Handle to the file Server
        pszQueue :  Name of the queue to which to associate the Q servers
        pszPServer  : List of Q Servers.

        
Return Value:

    An error condition as it arises.
    0x0 is returned if there is no error

--*/

{
  LPWSTR pszPServerlist = NULL;
  LPWSTR pszNextPServer = NULL;
  DWORD  err = 0x00000000 ;
  NTSTATUS ntstatus ;
  UNICODE_STRING UQueueName, UNextPServer;
  OEM_STRING    OemQueueName,OemNextPServer;


   if (pszPServer == NULL)
      return  NO_ERROR;
      
   if((pszPServerlist = AllocNwSplStr(pszPServer)) == NULL)
      {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
      }

    RtlInitUnicodeString( &UQueueName, pszQueue);
    ntstatus = RtlUnicodeStringToOemString( &OemQueueName, &UQueueName, TRUE);
  
    if (! NT_SUCCESS(ntstatus))
    {
      goto Exit;
    }

   while( (pszNextPServer = GetNextElement(&pszPServerlist, L';')) != NULL )
      {      
         RtlInitUnicodeString( &UNextPServer, pszNextPServer);
         ntstatus = RtlUnicodeStringToOemString( &OemNextPServer, &UNextPServer, TRUE);
         
          
         if ( !NT_SUCCESS(ntstatus))
            {
               RtlFreeOemString(&OemNextPServer);
               goto Exit;
            }
       //NwlibMakeNcp should associate a print server with a printer

       // Add Bindery Object to Set
       
       ntstatus = NwlibMakeNcp (
                        hServer,
                        FSCTL_NWR_NCP_E3H,    // Bindery function
                        122,
                        2,
                        "bwppwp|",
                         0x41,
                         0x0003,
                        OemQueueName.Buffer,
                        "Q_SERVERS",
                        0x0007,       // Object of type Print Server      
                        OemNextPServer.Buffer
                        );

         RtlFreeOemString(&OemNextPServer);
         if (!( NT_SUCCESS(ntstatus)))
            { 
               RtlFreeOemString(&OemNextPServer);
               goto Exit;
          
            }
      }
  RtlFreeOemString(&OemQueueName);

Exit:  

        return NwMapBinderyCompletionCode(ntstatus);

}

 
DWORD 
 NwDestroyQueue (HANDLE hServer,
                  DWORD dwQueueId)

/*+++
Routine Description:
  
   Makes the Ncp call to destroy the queue given by dwQueueId

   
Arguments:

        dwQueueId : Id of the queue you are creating.
        
Return Value:

    An error condition as it arises.
    0x0 is returned if there is no error

---*/

{
   
   NTSTATUS ntstatus;

   ntstatus = NwlibMakeNcp( 
                   hServer,
                   FSCTL_NWR_NCP_E3H,
                   7,
                   2,
                   "bd|",
                   0x65,
                   dwQueueId
                 );

#if DBG
    if ( NT_SUCCESS(ntstatus)) {
        IF_DEBUG(PRINT) {
            KdPrint(("NWWORKSTATION: Queue successfully destroyed\n"));
        }
    }
#endif

    return NwMapBinderyCompletionCode(ntstatus);

}

#endif // #ifndef NOT_USED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\queue.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    queue.h

Abstract:

    Header file included by the print provider

Author:

    Yi-Hsin Sung (yihsins)   15-May-1993

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef _NW_QUEUE_INCLUDED_
#define _NW_QUEUE_INCLUDED_


//
// Functions from queue.c
//

typedef BYTE JOBTIME[6];

DWORD
NwGetQueueId(
    IN  HANDLE  handleServer,
    IN  LPWSTR  QueueName,
    OUT LPDWORD QueueId
    );

DWORD
NwCreateQueueJobAndFile(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  LPWSTR  DocumentName,
    IN  LPWSTR  UserName,
    IN  DWORD   PrintOption,                //Multi-User addition
    IN  LPWSTR  QueueName,
    OUT LPWORD  JobId
    );

DWORD
NwCloseFileAndStartQueueJob(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId
    );

DWORD
NwRemoveJobFromQueue(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId
    );

DWORD
NwRemoveAllJobsFromQueue(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId
    );

DWORD
NwReadQueueCurrentStatus(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    OUT LPBYTE  QueueStatus,
    OUT LPBYTE  NumberOfJobs
    );

DWORD
NwSetQueueCurrentStatus(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  BYTE    QueueStatus
    );

DWORD
NwGetQueueJobList(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    OUT LPWORD  NumberOfJobs,
    OUT LPWORD  JobIdList
    );

DWORD
NwReadQueueJobEntry(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    OUT JOBTIME TargetExecutionTime,
    OUT JOBTIME JobEntryTime,
    OUT LPBYTE  JobPosition,
    OUT LPBYTE  JobControlFlags,
    OUT LPSTR   TextJobDescription,
    OUT LPSTR   UserName
    );

DWORD
NwGetQueueJobsFileSize(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    OUT LPDWORD FileSize
    );

DWORD
NwChangeQueueJobPosition(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  BYTE    NewPosition
    );

DWORD
NwChangeQueueJobEntry(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  DWORD   dwCommand,
    IN  PNW_JOB_INFO  pNwJobInfo 
    );

DWORD
NwGetQueueJobs(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  LPWSTR  PrinterName,
    IN  DWORD   FirstJobRequested,
    IN  DWORD   EntriesRequested,
    IN  DWORD   Level,
    OUT LPBYTE  Buffer,
    IN  DWORD   cbBuf,
    OUT LPDWORD BytesNeeded,
    OUT LPDWORD Entries
    );

DWORD
NwGetQueueJobInfo(
    IN  HANDLE  handleServer,
    IN  DWORD   QueueId,
    IN  WORD    JobId,
    IN  LPWSTR  PrinterName,
    IN  DWORD   Level,
    IN OUT LPBYTE  *FixedPortion,
    IN OUT LPWSTR  *EndOfVariableData,
    OUT LPDWORD EntrySize
    );

#ifndef NOT_USED
 
DWORD 
NwDestroyQueue (
    IN  HANDLE hServer,
    IN  DWORD dwQueueId
);  

DWORD 
NwAssocPServers ( 
                  IN HANDLE hServer,
                  IN LPWSTR pswQueue,
                  IN LPWSTR pszPServer
                );


DWORD
NwCreateQueue ( 
                 IN HANDLE hServer, 
                 IN LPWSTR pszQueue,
                 OUT  LPDWORD  pQueueId 
               );

#endif // #ifndef NOT_USED

#endif // _NW_QUEUE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\service.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    getaddr.c

Abstract:

    This module contains the code to support NPGetAddressByName.

Author:

    Yi-Hsin Sung (yihsins)    18-Apr-94
    Glenn A. Curtis (glennc)  18-Jul-95

Revision History:

    yihsins      Created
    glennc       Modified     18-Jul-95

--*/

#ifndef QFE_BUILD

#include <nw.h>
#include <winsock.h>
#include <wsipx.h>
#include <nspapi.h>
#include <nspapip.h>
#include <wsnwlink.h>
#include <svcguid.h>
#include <nwsap.h>
#include <align.h>
#include <nwmisc.h>

#define WSOCK_VER_REQD        0x0101

DWORD
NwrGetService(
    IN LPWSTR Reserved,
    IN WORD   nSapType,
    IN LPWSTR lpServiceName,
    IN DWORD  dwProperties,
    OUT LPBYTE lpServiceInfo,
    IN DWORD  dwBufferLength,
    OUT LPDWORD lpdwBytesNeeded
    )
/*++

Routine Description:

    This routine calls NwGetService to, in turn, get the service info.

Arguments:

    Reserved - unused

    nSapType - SAP type

    lpServiceName - service name

    dwProperties -  specifys the properties of the service info needed

    lpServiceInfo - on output, contains the SERVICE_INFO

    dwBufferLength - size of buffer pointed by lpServiceInfo

    lpdwBytesNeeded - if the buffer pointed by lpServiceInfo is not large
                      enough, this will contain the bytes needed on output

Return Value:

    Win32 error.

--*/
{
    return NwGetService( Reserved,
                         nSapType,
                         lpServiceName,
                         dwProperties,
                         lpServiceInfo,
                         dwBufferLength,
                         lpdwBytesNeeded );
}

DWORD
NwrSetService(
    IN LPWSTR Reserved,
    IN DWORD  dwOperation,
    IN LPSERVICE_INFO lpServiceInfo,
    IN WORD   nSapType
    )
/*++

Routine Description:

    This routine registers or deregisters the service info.

Arguments:

    Reserved - unused

    dwOperation - SERVICE_REGISTER or SERVICE_DEREGISTER

    lpServiceInfo - contains the service information

    nSapType - SAP type

Return Value:

    Win32 error.

--*/
{
    DWORD err = NO_ERROR;

    UNREFERENCED_PARAMETER( Reserved );

    //
    // Check if all parameters passed in are valid
    //

    if ( (lpServiceInfo->lpServiceName == NULL) || (wcslen( lpServiceInfo->lpServiceName ) > SAP_OBJECT_NAME_MAX_LENGTH-1) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch ( dwOperation )
    {
        case SERVICE_REGISTER:
            err = NwRegisterService( lpServiceInfo, nSapType, NwDoneEvent );
            break;

        case SERVICE_DEREGISTER:
            err = NwDeregisterService( lpServiceInfo, nSapType );
            break;

        default:
            err = ERROR_INVALID_PARAMETER;
            break;
    }

    return err;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\util.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains miscellaneous utility routines used by the
    NetWare Workstation service.

Author:

    Rita Wong  (ritaw)   08-Feb-1993

Revision History:

--*/

#include <nw.h>
#include <nwstatus.h>

//
// Debug trace flag for selecting which trace statements to output
//
#if DBG

DWORD WorkstationTrace = 0;

#endif // DBG



// Terminal Server Addition - 
DWORD
NwImpersonateClient(
    VOID
    )
/*++

Routine Description:

    This function calls RpcImpersonateClient to impersonate the current caller
    of an API.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;


    if ((status = RpcImpersonateClient(NULL)) != NO_ERROR) {
        KdPrint(("NWWORKSTATION: Fail to impersonate client %ld\n", status));
    }

    return status;
}


// Terminal Server Addition - 
DWORD
NwRevertToSelf(
    VOID
    )
/*++

Routine Description:

    This function calls RpcRevertToSelf to undo an impersonation.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD status;


    if ((status = RpcRevertToSelf()) != NO_ERROR) {
        KdPrint(("NWWORKSTATION: Fail to revert to self %ld\n", status));
        ASSERT(FALSE);
    }

    return status;
}


VOID
NwLogEvent(
    DWORD MessageId,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings,
    DWORD ErrorCode
    )
{

    HANDLE LogHandle;


    LogHandle = RegisterEventSourceW (
                    NULL,
                    NW_WORKSTATION_SERVICE
                    );

    if (LogHandle == NULL) {
        KdPrint(("NWWORKSTATION: RegisterEventSourceW failed %lu\n",
                 GetLastError()));
        return;
    }

    if (ErrorCode == NO_ERROR) {

        //
        // No error codes were specified
        //
        (void) ReportEventW(
                   LogHandle,
                   EVENTLOG_ERROR_TYPE,
                   0,            // event category
                   MessageId,
                   (PSID) NULL,
                   (WORD) NumberOfSubStrings,
                   0,
                   SubStrings,
                   (PVOID) NULL
                   );

    }
    else {

        //
        // Log the error code specified as binary data
        //
        (void) ReportEventW(
                   LogHandle,
                   EVENTLOG_ERROR_TYPE,
                   0,            // event category
                   MessageId,
                   (PSID) NULL,
                   (WORD) NumberOfSubStrings,
                   sizeof(DWORD),
                   SubStrings,
                   (PVOID) &ErrorCode
                   );
    }

    DeregisterEventSource(LogHandle);
}



//---------------------------------------------------------------------------------//
// NwGetSessionId - This routine assumed that the thread is already executed in    //
// the client context. It just get the session ID without impersonating.           //
//---------------------------------------------------------------------------------// 

NTSTATUS
NwGetSessionId(
    OUT PULONG pSessionId
    )
/*++

Routine Description:

    This function gets the session id of the current thread.

    Arguments:

    pSessionId - Returns the session id of the current process.

Return Value:

    DWORD - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    HANDLE CurrentThreadToken;
    ULONG SessionId;
    ULONG ReturnLength;


    ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,              // Use workstation service's security
                                      // context to open thread token
                   &CurrentThreadToken
                   );


    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("[Wksta] Cannot open the current thread token %08lx\n",
                     ntstatus));
        goto Exit;
    }

    //
    // Get the session id of the current thread
    //


    ntstatus = NtQueryInformationToken(
                  CurrentThreadToken,
                  TokenSessionId,
                  &SessionId,
                  sizeof(ULONG),
                  &ReturnLength
                  );


    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("[Wksta] Cannot query current thread's token %08lx\n",
                     ntstatus));
        NtClose(CurrentThreadToken);
        goto Exit;
    }


    NtClose(CurrentThreadToken);

    *pSessionId = SessionId;

Exit:

    return ntstatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\socket.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    socket.h

Abstract:

    Contains macros, prototypes and structures for socket.c

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

#define ARBITRARY_CONNECTION_NUMBER 0x6c8e

//
// forward declarations
//

typedef struct _FIFO *LPFIFO;
typedef struct _XECB *LPXECB;
typedef struct _XECB_QUEUE *LPXECB_QUEUE;
typedef struct _SOCKET_INFO* LPSOCKET_INFO;
typedef struct _CONNECTION_INFO *LPCONNECTION_INFO;

//
// FIFO - standard single-linked FIFO queue structure
//

typedef struct _FIFO {
    LPVOID Head;
    LPVOID Tail;
} FIFO;

//
// function type for cancelling XECB/ECB
//

typedef BYTE (*ECB_CANCEL_ROUTINE)(LPXECB);

//
// QUEUE_ID - indicator of which queue an ECB is on
//

typedef enum {
    NO_QUEUE = 0x10cadd1e,
    ASYNC_COMPLETION_QUEUE = 0xCC5055C0,    // arbitrary numbers make life interesting
    TIMER_QUEUE,
    SOCKET_LISTEN_QUEUE,
    SOCKET_SEND_QUEUE,
    SOCKET_HEADER_QUEUE,  // special queue for small ECBs that cannot hold data
    CONNECTION_CONNECT_QUEUE,
    CONNECTION_ACCEPT_QUEUE,
    CONNECTION_SEND_QUEUE,
    CONNECTION_LISTEN_QUEUE
} QUEUE_ID;

//
// XECB - our copy of the ECB (IPX or AES)
//

typedef struct _XECB {
    LPXECB Next;
    LPECB Ecb;                          // points to ECB in DOS memory
    ECB_ADDRESS EcbAddress;             // segmented address of ECB in DOS memory
    ESR_ADDRESS EsrAddress;             // Event Service Routine in DOS memory
    LPBYTE Buffer;                      // address of 32-bit buffer
    LPBYTE Data;                        // moveable data pointer
    WORD FrameLength;                   // actual size of frame (from IPX/SPX header)
    WORD ActualLength;                  // same as FrameLength. Not decremented
    WORD Length;                        // length of 32-bit buffer
    WORD Ticks;                         // for AES
    WORD SocketNumber;                  // number of owning socket
    WORD Owner;                         // owning DOS Task ID
    DWORD TaskId;                       // owning Windows Task ID
    DWORD Flags;                        // see below
    QUEUE_ID QueueId;                   // identifies the queue for quick location
    LPVOID OwningObject;                // which SOCKET_INFO or CONNECTION_INFO the queue is on
    DWORD RefCount;                     // the dreaded reference count
} XECB;

//
// XECB flags
//

#define XECB_FLAG_AES               0x00000000
#define XECB_FLAG_IPX               0x00000001
#define XECB_FLAG_TEMPORARY_SOCKET  0x00000002
#define XECB_FLAG_BUFFER_ALLOCATED  0x00000004
#define XECB_FLAG_LISTEN            0x00000008
#define XECB_FLAG_SEND              0x00000010
#define XECB_FLAG_TIMER             0x00000020
#define XECB_FLAG_ASYNC             0x00000040
#define XECB_FLAG_FIRST_RECEIVE     0x00000080
#define XECB_FLAG_SPX               0x00000100
#define XECB_FLAG_PROTMODE          0x00000200

#define IS_PROT_MODE(p) (((p)->Flags & XECB_FLAG_PROTMODE) ? TRUE : FALSE)

//
// XECB_QUEUE - queue of XECBs
//

typedef struct _XECB_QUEUE {
    LPXECB Head;
    LPXECB Tail;
} XECB_QUEUE;

//
// SOCKET_INFO - maintains info about IPX sockets
//

typedef struct _SOCKET_INFO {
    LPSOCKET_INFO Next;
    WORD SocketNumber;                  // big-endian socket (bound port)
    WORD Owner;                         // DOS PDB
    DWORD TaskId;                       // Windows owner
    SOCKET Socket;                      // the WinSock socket handle
    DWORD Flags;

    BOOL LongLived;                     // TRUE if keep-alive when app dies
    BOOL SpxSocket;                     // TRUE if socket opened for SPX

    DWORD PendingSends;                 // used by cancel
    DWORD PendingListens;               // used by cancel

    //
    // ListenQueue is used for IPXListenForPacket and SPXListenForSequencedPacket
    //

    XECB_QUEUE ListenQueue;             // pool of listening ECBs against this socket

    //
    // SendQueue is used by IPX for IPXSendPacket
    //

    XECB_QUEUE SendQueue;               // queue of pending send ECBs against this socket

    //
    // HeaderQueue is used to hold small ECBs that can only take header info.
    // We have this separate queue to make sure that we do not put ECBs that
    // really cant accept any data into the Listen Queue.
    //

    XECB_QUEUE HeaderQueue;             // pool of header ECBs against this socket

    LPCONNECTION_INFO Connections;
} SOCKET_INFO;

#define SOCKET_FLAG_LISTENING       0x00000001
#define SOCKET_FLAG_SENDING         0x00000002
#define SOCKET_FLAG_TEMPORARY       0x80000000

//
// CONNECTION_INFO - maintains info about SPX sockets
//

typedef struct _CONNECTION_INFO {
    LPCONNECTION_INFO Next;             // next CONNECTION_INFO by OwningSocket
    LPCONNECTION_INFO List;             // all CONNECTION_INFO are linked together
    LPSOCKET_INFO OwningSocket;         // back-pointer to SOCKET_INFO
    SOCKET Socket;                      // handle to socket
    DWORD TaskId;                       // identifies windows task/owner
    WORD ConnectionId;                  // analogous to SocketNumber
    BYTE Flags;
    BYTE State;
    XECB_QUEUE ConnectQueue;            // outgoing connections being made
    XECB_QUEUE AcceptQueue;             // waiting for incoming connections
    XECB_QUEUE SendQueue;               // packet sends on this connection
    XECB_QUEUE ListenQueue;             // partially complete receive
    BYTE RemoteNode[6];
    WORD RemoteConnectionId;
} CONNECTION_INFO;

//
// CONNECTION_INFO Flag field values
//

#define CF_1ST_RECEIVE  0x80            // hack-o-rama till NWLink timing problem fixed

//
// CONNECTION_INFO State field values
//

#define CI_WAITING      0x01
#define CI_STARTING     0x02
#define CI_ESTABLISHED  0x03
#define CI_TERMINATING  0x04

//
// one-line function macros
//

#define AllocateSocket()    (LPSOCKET_INFO)LocalAlloc(LPTR, sizeof(SOCKET_INFO))
#define DeallocateSocket(p) FREE_OBJECT(p)

//
// SocketType parameter for CreateSocket
//

typedef enum {
    SOCKET_TYPE_IPX,
    SOCKET_TYPE_SPX
} SOCKET_TYPE;

//
// function prototypes
//

int
CreateSocket(
    IN SOCKET_TYPE SocketType,
    IN OUT ULPWORD pSocketNumber,
    OUT SOCKET* pSocket
    );

LPSOCKET_INFO
AllocateTemporarySocket(
    VOID
    );

VOID
QueueSocket(
    IN LPSOCKET_INFO pSocketInfo
    );

LPSOCKET_INFO
DequeueSocket(
    IN LPSOCKET_INFO pSocketInfo
    );

LPSOCKET_INFO
FindSocket(
    IN WORD SocketNumber
    );

LPSOCKET_INFO
FindActiveSocket(
    IN LPSOCKET_INFO pSocketInfo
    );

int
ReopenSocket(
    LPSOCKET_INFO pSocketInfo
    );

VOID
KillSocket(
    IN LPSOCKET_INFO pSocketInfo
    );

VOID
KillShortLivedSockets(
    IN WORD Owner
    );

LPCONNECTION_INFO
AllocateConnection(
    LPSOCKET_INFO pSocketInfo
    );

VOID
DeallocateConnection(
    IN LPCONNECTION_INFO pConnectionInfo
    );

LPCONNECTION_INFO
FindConnection(
    IN WORD ConnectionId
    );

VOID
QueueConnection(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

LPCONNECTION_INFO
DequeueConnection(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

VOID
KillConnection(
    IN LPCONNECTION_INFO pConnectionInfo
    );

VOID
AbortOrTerminateConnection(
    IN LPCONNECTION_INFO pConnectionInfo,
    IN BYTE CompletionCode
    );

VOID
CheckPendingSpxRequests(
    BOOL *pfOperationPerformed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\socket.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    socket.c

Abstract:

    Contains functions to create, delete and manipulate IPX sockets and SPX
    connections

    Contents:
        CreateSocket
        AllocateTemporarySocket
        QueueSocket
        DequeueSocket
        FindSocket
        FindActiveSocket
        ReopenSocket
        KillSocket
        KillShortLivedSockets
        AllocateConnection
        DeallocateConnection
        FindConnection
        QueueConnection
        DequeueConnection
        KillConnection
        AbortOrTerminateConnection
        CheckPendingSpxRequests
        (CheckSocketState)
        (CheckSelectRead)
        (CheckSelectWrite)
        (AsyncReadAction)
        (AsyncWriteAction)
        (CompleteAccept)
        (CompleteReceive)
        (CompleteConnect)
        (CompleteSend)

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Environment:

    User-mode Win32

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// miscellaneous manifests
//

#define ARBITRARY_CONNECTION_INCREMENT  2

//
// macros
//

#define ALLOCATE_CONNECTION_NUMBER()    (ConnectionNumber += ARBITRARY_CONNECTION_INCREMENT)

//
// private data
//

PRIVATE LPSOCKET_INFO SocketList = NULL;
PRIVATE LPCONNECTION_INFO ConnectionList = NULL;
PRIVATE WORD ConnectionNumber = ARBITRARY_CONNECTION_NUMBER;

//
// private functions
//

PRIVATE
BOOL
CheckSocketState(
    IN SOCKET Socket,
    OUT LPBOOL Readable,
    OUT LPBOOL Writeable,
    OUT LPBOOL Error
    );


PRIVATE
VOID
CheckSelectRead(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *CheckRead
    );

PRIVATE
VOID
CheckSelectWrite(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *CheckWrite
    );

PRIVATE
VOID
AsyncReadAction(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *ReadPerformed
    );

PRIVATE
VOID
AsyncWriteAction(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *WritePerformed
    );

PRIVATE
VOID
CompleteAccept(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

PRIVATE
VOID
CompleteReceive(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

PRIVATE
VOID
CompleteConnect(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

PRIVATE
VOID
CompleteSend(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    );

#if SPX_HACK
PRIVATE VOID ModifyFirstReceive(LPBYTE, LPDWORD, WORD, SOCKET);
#endif

//
// public functions
//


int
CreateSocket(
    IN SOCKET_TYPE SocketType,
    IN OUT ULPWORD pSocketNumber,
    OUT SOCKET* pSocket
    )

/*++

Routine Description:

    Creates a socket for IPX or SPX (a connection). Once the socket is created
    we have to bind it to the IPX/SPX 'socket' - i.e. port. We also need to
    change a few things about the standard socket:

        * if this is an SPX request then we must set the REUSEADDR socket option
          since there may typically be several connect requests over the same
          WinSock socket: we need to be able to bind multiple connections to the
          same socket number

        * all sockets opened by this function are put into non-blocking mode
        * all sockets opened by this function will return the packet header in
          any received data (IPX_RECVHDR)

    The requested socket number can be 0 in which case we bind to a dynamic
    socket number. We always return the number of the socket bound to: if not 0
    on input, this should always be the same value as that requested in
    pSocketNumber

    If any WinSock call fails (and the socket was created) then we close the
    socket before returning

Arguments:

    SocketType      - SOCKET_TYPE_IPX or SOCKET_TYPE_SPX
    pSocketNumber   - input: socket number to bind (can be 0)
                      output: socket number bound
    pSocket         - pointer to address of socket identifier to return

Return Value:

    int
        Success - IPX_SUCCESS/SPX_SUCCESS (0)

        Failure - IPX_SOCKET_TABLE_FULL
                    WinSock cannot create the socket

                  IPX_SOCKET_ALREADY_OPEN
                    Assume the request was for an IPX socket: we do not allow
                    multiple IPX sockets to be bound to the same socket number,
                    only SPX


--*/

{
    SOCKET s;
    SOCKADDR_IPX socketAddress;
    BOOL true = TRUE;
    int rc;
    int status = IPX_SOCKET_TABLE_FULL; // default error

    s = socket(AF_IPX,
               (SocketType == SOCKET_TYPE_SPX) ? SOCK_SEQPACKET : SOCK_DGRAM,
               (SocketType == SOCKET_TYPE_SPX) ? NSPROTO_SPX : NSPROTO_IPX
                );

    if (s != INVALID_SOCKET) {

        //
        // for stream (SPX) sockets, we need multiple sockets bound to the
        // same socket number if we are to have multiple connections on the
        // same SPX socket
        //

        if (SocketType == SOCKET_TYPE_SPX) {
            rc = setsockopt(s,
                            SOL_SOCKET,
                            SO_REUSEADDR,
                            (char FAR*)&true,
                            sizeof(true)
                            );
            if (rc == SOCKET_ERROR) {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_ERROR,
                            "CreateSocket: setsockopt(SO_REUSEADDR) returns %d\n",
                            WSAGetLastError()
                            ));

            } else {
                rc = setsockopt(s,
                                SOL_SOCKET,
                                SO_OOBINLINE,
                                (char FAR*)&true,
                                sizeof(true)
                                );

                if (rc == SOCKET_ERROR) {

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_ERROR,
                                "CreateSocket: setsockopt(SO_OOBINLINE) returns %d\n",
                                WSAGetLastError()
                                ));

                }
            }
        } else {

            //
            // allow broadcasts to be transmitted on IPX sockets
            //

            rc = setsockopt(s,
                            SOL_SOCKET,
                            SO_BROADCAST,
                            (char FAR*)&true,
                            sizeof(true)
                            );
        }
        if (!rc) {

            //
            // bind the socket to the local socket number (port)
            //

            ZeroMemory(&socketAddress, sizeof(socketAddress));
            socketAddress.sa_family = AF_IPX;
            socketAddress.sa_socket = *pSocketNumber;
            rc = bind(s, (LPSOCKADDR)&socketAddress, sizeof(socketAddress));
            if (rc != SOCKET_ERROR) {

                int length = sizeof(socketAddress);

                ZeroMemory(&socketAddress, sizeof(socketAddress));
                socketAddress.sa_family = AF_IPX;

                //
                // use getsockname() to find the (big-endian) socket value that
                // was actually assigned: should only be different from
                // *pSocketNumber if the latter was 0 on input
                //

                rc = getsockname(s, (LPSOCKADDR)&socketAddress, &length);
                if (rc != SOCKET_ERROR) {

                    u_long arg = !0;

                    //
                    // put the socket into non-blocking mode. Neither IPX nor
                    // SPX sockets are blocking: the app starts an I/O request
                    // and if it doesn't complete immediately, will be completed
                    // by AES which periodically polls the outstanding I/O
                    // requests
                    //

                    rc = ioctlsocket(s, FIONBIO, &arg);
                    if (rc != SOCKET_ERROR) {

                        //
                        // return protocol header on receive frames
                        //

                        rc = setsockopt(s,
                                        NSPROTO_IPX,
                                        IPX_RECVHDR,
                                        (char FAR*)&true,
                                        sizeof(true)
                                        );
                        if (rc != SOCKET_ERROR) {
                            *pSocketNumber = socketAddress.sa_socket;
                            *pSocket = s;
                            status = IPX_SUCCESS;
                        } else {

                            IPXDBGPRINT((__FILE__, __LINE__,
                                        FUNCTION_ANY,
                                        IPXDBG_LEVEL_ERROR,
                                        "CreateSocket: setsockopt(RECVHDR) returns %d\n",
                                        WSAGetLastError()
                                        ));

                        }
                    } else {

                        IPXDBGPRINT((__FILE__, __LINE__,
                                    FUNCTION_ANY,
                                    IPXDBG_LEVEL_ERROR,
                                    "CreateSocket: ioctlsocket(FIONBIO) returns %d\n",
                                    WSAGetLastError()
                                    ));

                    }
                } else {

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_ERROR,
                                "CreateSocket: getsockname() returns %d\n",
                                WSAGetLastError()
                                ));

                }
            } else {

                //
                // bind() failed - either an expected error (the requested socket
                // is already in use), or (horror) an unexpected error, in which
                // case report table full (?)
                //

                switch (WSAGetLastError()) {
                case WSAEADDRINUSE:

                    ASSERT(*pSocketNumber != 0);
                    ASSERT(SocketType == SOCKET_TYPE_IPX);

                    status = IPX_SOCKET_ALREADY_OPEN;
                    break;

                default:

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_ERROR,
                                "CreateSocket: bind() on socket %#x returns %d\n",
                                s,
                                WSAGetLastError()
                                ));

                }
            }
        }
    } else {

        //
        // the socket() call failed - treat as table full
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "CreateSocket: socket() returns %d\n",
                    WSAGetLastError()
                    ));

    }
    if (status != IPX_SUCCESS) {
        if (s != INVALID_SOCKET) {
            closesocket(s);
        }
    }
    return status;
}


LPSOCKET_INFO
AllocateTemporarySocket(
    VOID
    )

/*++

Routine Description:

    Allocates a temporary socket. Creates an IPX socket having a dynamically
    allocated socket number

Arguments:

    None.

Return Value:

    LPSOCKET_INFO
        Success - pointer to SOCKET_INFO structure
        Failure - NULL

--*/

{
    LPSOCKET_INFO pSocketInfo;
    int rc;

    pSocketInfo = AllocateSocket();
    if (pSocketInfo) {

        //
        // assumption: the SOCKET_INFO structure was zeroed by LocalAlloc(LPTR,..
        // hence the SocketNumber fields is 0. This causes CreateSocket to
        // generate a dynamic socket number
        //

        rc = CreateSocket(SOCKET_TYPE_IPX,
                          &pSocketInfo->SocketNumber,
                          &pSocketInfo->Socket
                          );
        if (rc == IPX_SUCCESS) {
            pSocketInfo->Flags |= SOCKET_FLAG_TEMPORARY;
        } else {
            DeallocateSocket(pSocketInfo);
            pSocketInfo = NULL;
        }
    }
    return pSocketInfo;
}


VOID
QueueSocket(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Add a SOCKET_INFO structure to the list (LIFO) of (opened) sockets

Arguments:

    pSocketInfo - pointer to filled-in SOCKET_INFO structure

Return Value:

    None.

--*/

{
    RequestMutex();
    pSocketInfo->Next = SocketList;
    SocketList = pSocketInfo;
    ReleaseMutex();
}


LPSOCKET_INFO
DequeueSocket(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Remove a SOCKET_INFO structure from the list

Arguments:

    pSocketInfo - pointer to SOCKET_INFO structure to remove

Return Value:

    LPSOCKET_INFO
        pSocketInfo - should be this value
        NULL - couldn't find pSocketInfo (should not get this!)

--*/

{
    LPSOCKET_INFO prev, p;

    ASSERT(SocketList);

    RequestMutex();
    prev = (LPSOCKET_INFO)&SocketList;
    p = SocketList;
    while (p) {
        if (p == pSocketInfo) {
            prev->Next = p->Next;
            p->Next = NULL;
            break;
        } else {
            prev = p;
            p = p->Next;
        }
    }

    if (!p) {

        //
        // should never reach here
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_FATAL,
                    "DequeueSocket: can't find socket structure %08x on queue\n",
                    pSocketInfo
                    ));

    }

    ReleaseMutex();
    return p;
}


LPSOCKET_INFO
FindSocket(
    IN WORD SocketNumber
    )

/*++

Routine Description:

    Locate a SOCKET_INFO structure in the list, by (big-endian) socket number

    Assumes:    1. There is 1 and only 1 SOCKET_INFO structure that contains
                   SocketNumber

Arguments:

    SocketNumber    - big-endian socket number to find

Return Value:

    LPSOCKET_INFO
        NULL - couldn't find requested socket
        !NULL - pointer to discovered SOCKET_INFO structure

--*/

{
    LPSOCKET_INFO p;

    RequestMutex();
    p = SocketList;
    while (p) {
        if (p->SocketNumber == SocketNumber) {
            break;
        } else {
            p = p->Next;
        }
    }
    ReleaseMutex();
    return p;
}


LPSOCKET_INFO
FindActiveSocket(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Find a SOCKET_INFO structure with pending send or receive. Called as FindFirst,
    FindNext - first call made with pSocketInfo == NULL: enters critical section
    if an active socket is found, returns pointer

    Subsequent calls are made with pSocketInfo pointing to last returned
    SOCKET_INFO. This continues the search. When search exhausted, critical
    section is released

Arguments:

    pSocketInfo - pointer to SOCKET_INFO structure: first time must be NULL

Return Value:

    LPSOCKET_INFO - next active SOCKET_INFO structure or NULL

--*/

{
    if (!pSocketInfo) {
        RequestMutex();
        pSocketInfo = SocketList;
    } else {
        pSocketInfo = pSocketInfo->Next;
    }
    for (; pSocketInfo; pSocketInfo = pSocketInfo->Next) {
        if (pSocketInfo->Flags & (SOCKET_FLAG_SENDING | SOCKET_FLAG_LISTENING)) {
            return pSocketInfo;
        }
    }
    ReleaseMutex();
    return NULL;
}


int
ReopenSocket(
    LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Called expressly to close an IPX socket and reassign the descriptor to SPX.
    Note that after this function completes, IPXSendPacket and IPXListenForPacket
    cannot be made agains the IPX socket

Arguments:

    pSocketInfo - pointer to SOCKET_INFO which currently describes an IPX socket

Return Value:

    int - return code from CreateSocket

--*/

{
    int rc;

    rc = closesocket(pSocketInfo->Socket);
    if (rc == SOCKET_ERROR) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "ReopenSocket: closesocket() returns %d\n",
                    WSAGetLastError()
                    ));

    }

    //
    // mark this socket as connection-based (SPX) socket
    //

    pSocketInfo->SpxSocket = TRUE;

    //
    // re-open the socket for SPX use
    //

    return CreateSocket(SOCKET_TYPE_SPX,
                        &pSocketInfo->SocketNumber,
                        &pSocketInfo->Socket
                        );
}


VOID
KillSocket(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    closes a socket, removes the SOCKET_INFO structure from the list and cancels
    any pending send, listen or timed events associated with the socket

Arguments:

    pSocketInfo - identifying socket to kill

Return Value:

    None.

--*/

{

    int rc;

    //
    // remove the SOCKET_INFO structure from the list of sockets. Cancel
    // any pending ECB requests and any IPX timed events that have the
    // same socket number
    //

    DequeueSocket(pSocketInfo);
    rc = closesocket(pSocketInfo->Socket);
    if (rc == SOCKET_ERROR) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "KillSocket: closesocket() returns %d\n",
                    WSAGetLastError()
                    ));

    }

    //
    // the socket has been removed from SocketList: no need to grab mutex to
    // perform the following
    //

    CancelTimedEvents(pSocketInfo->SocketNumber, 0, 0);
    CancelSocketQueue(&pSocketInfo->ListenQueue);
    CancelSocketQueue(&pSocketInfo->HeaderQueue);
    CancelSocketQueue(&pSocketInfo->SendQueue);
    if (pSocketInfo->SpxSocket) {

        LPCONNECTION_INFO pConnectionInfo;

        while (pConnectionInfo = pSocketInfo->Connections) {
            DequeueConnection(pSocketInfo, pConnectionInfo);
            KillConnection(pConnectionInfo);
        }
    }
    DeallocateSocket(pSocketInfo);
}


VOID
KillShortLivedSockets(
    IN WORD Owner
    )

/*++

Routine Description:

    For all those sockets created by a DOS process as SHORT_LIVED, terminate
    the sockets, cancelling any outstanding ECBs

Arguments:

    Owner   - DOS PDB which opened sockets

Return Value:

    None.

--*/

{
    LPSOCKET_INFO pSocketInfo;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "KillShortLivedSockets(%04x)\n",
                Owner
                ));

    RequestMutex();

    //
    // kill any non-socket (AES) timed events owned by this DOS process
    //

    CancelTimedEvents(0, Owner, 0);

    //
    // kill all sockets owned by this PDB
    //

    pSocketInfo = SocketList;
    while (pSocketInfo) {

        LPSOCKET_INFO next;

        next = pSocketInfo->Next;
        if (!pSocketInfo->LongLived && (pSocketInfo->Owner == Owner)) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "KillShortLivedSockets: Socket %04x owned by %04x\n",
                        B2LW(pSocketInfo->SocketNumber),
                        pSocketInfo->Owner
                        ));

            KillSocket(pSocketInfo);
        }
        pSocketInfo = next;
    }
    ReleaseMutex();
}


LPCONNECTION_INFO
AllocateConnection(
    LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Allocates a CONNECTION_INFO structure. If successful, links it at the head
    of ConnectionList

Arguments:

    pSocketInfo - pointer to owner SOCKET_INFO

Return Value:

    LPCONNECTION_INFO
        Success - !NULL
        Failure - NULL

--*/

{
    LPCONNECTION_INFO pConnectionInfo;

    pConnectionInfo = (LPCONNECTION_INFO)LocalAlloc(LPTR, sizeof(*pConnectionInfo));
    if (pConnectionInfo) {
        RequestMutex();
        pConnectionInfo->ConnectionId = ALLOCATE_CONNECTION_NUMBER();
        pConnectionInfo->List = ConnectionList;
        ConnectionList = pConnectionInfo;
        ReleaseMutex();

#if SPX_HACK
        pConnectionInfo->Flags = CF_1ST_RECEIVE;
#endif
    }

    return pConnectionInfo;
}


VOID
DeallocateConnection(
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Undoes the work of AllocateConnection - removes pConnectionInfo from
    ConnectionList and deallocates the structure

Arguments:

    pConnectionInfo - pointer to CONNECTION_INFO to deallocate

Return Value:

    None.

--*/

{
    LPCONNECTION_INFO p;
    LPCONNECTION_INFO prev = (LPCONNECTION_INFO)&ConnectionList;

    RequestMutex();
    for (p = ConnectionList; p != pConnectionInfo; ) {
        prev = p;
        p = p->List;
    }

    //
    // if p is NULL or differs from pConnectionInfo then there's a problem
    //

    ASSERT(p);

    //
    // special case if pConnectionInfo is first on list: can't say
    // &ConnectionList->List - accesses one pointer beyond ConnectionList
    // which is WRONG
    //

    if (prev == (LPCONNECTION_INFO)&ConnectionList) {
        ConnectionList = p->List;
    } else {
        prev->List = p->List;
    }
    FREE_OBJECT(pConnectionInfo);
    ReleaseMutex();
}


LPCONNECTION_INFO
FindConnection(
    IN WORD ConnectionId
    )

/*++

Routine Description:

    Returns a pointer to CONNECTION_INFO given a unique connection ID

Arguments:

    ConnectionId    - value to find

Return Value:

    LPCONNECTION_INFO
        Success - !NULL
        Failure - NULL

--*/

{
    LPCONNECTION_INFO pConnectionInfo;

    RequestMutex();
    for (pConnectionInfo = ConnectionList; pConnectionInfo; ) {
        if (pConnectionInfo->ConnectionId == ConnectionId) {
            break;
        } else {
            pConnectionInfo = pConnectionInfo->List;
        }
    }
    ReleaseMutex();
    return pConnectionInfo;
}


VOID
QueueConnection(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Adds a CONNECTION_INFO to the list of connections owned by a SOCKET_INFO.
    Points the CONNECTION_INFO back to the SOCKET_INFO

Arguments:

    pSocketInfo     - owning SOCKET_INFO
    pConnectionInfo - CONNECTION_INFO to add

Return Value:

    None.

--*/

{
    pConnectionInfo->Next = pSocketInfo->Connections;
    pSocketInfo->Connections = pConnectionInfo;
    pConnectionInfo->OwningSocket = pSocketInfo;
}


LPCONNECTION_INFO
DequeueConnection(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Removes a CONNECTION_INFO from the list of connections owned by a SOCKET_INFO

Arguments:

    pSocketInfo     - owning SOCKET_INFO
    pConnectionInfo - CONNECTION_INFO to remove

Return Value:

    LPCONNECTION_INFO
        Success - pointer to removed CONNECTION_INFO (should be same as
                  pConnectionInfo)
        Failure - NULL (not expected)

--*/

{
    LPCONNECTION_INFO prev = (LPCONNECTION_INFO)&pSocketInfo->Connections;
    LPCONNECTION_INFO p = prev->Next;

    while (p && p != pConnectionInfo) {
        prev = p;
        p = p->Next;
    }

    ASSERT(p == pConnectionInfo);

    prev->Next = p->Next;
    p->OwningSocket = NULL;
    return p;
}


VOID
KillConnection(
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Closes a socket belonging to a connection and cancels all outstanding
    requests. The CONNECTION_INFO is deallocated

Arguments:

    pConnectionInfo - pointer to CONNECTION_INFO to kill

Return Value:

    None.

--*/

{
    if (pConnectionInfo->Socket) {
        closesocket(pConnectionInfo->Socket);
    }
    CancelConnectionQueue(&pConnectionInfo->ConnectQueue);
    CancelConnectionQueue(&pConnectionInfo->AcceptQueue);
    CancelConnectionQueue(&pConnectionInfo->ListenQueue);
    CancelConnectionQueue(&pConnectionInfo->SendQueue);
    DeallocateConnection(pConnectionInfo);
}


VOID
AbortOrTerminateConnection(
    IN LPCONNECTION_INFO pConnectionInfo,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Aborts or terminates a connection: closes the socket, dequeues and completes
    all outstanding ECBs with relevant code and deallocates the CONNECTION_INFO
    structure

    The CONNECTION_INFO must NOT be queued on a SOCKET_INFO when this routine
    is called

Arguments:

    pConnectionInfo - pointer to CONNECTION_INFO to kill
    CompletionCode  - completion code to put in pending ECBs

Return Value:

    None.

--*/

{
    if (pConnectionInfo->Socket) {
        closesocket(pConnectionInfo->Socket);
    }
    AbortQueue(&pConnectionInfo->ConnectQueue, CompletionCode);
    AbortQueue(&pConnectionInfo->AcceptQueue, CompletionCode);
    AbortQueue(&pConnectionInfo->ListenQueue, CompletionCode);
    AbortQueue(&pConnectionInfo->SendQueue, CompletionCode);
    DeallocateConnection(pConnectionInfo);
}


VOID
CheckPendingSpxRequests(
    BOOL *pfOperationPerformed
    )

/*++

Routine Description:

    Checks the open non-blocking SPX sockets for:

        errors
        outgoing established connections (connect)
        incoming established connections (listen/accept)
        data to receive (recv)
        send completions (send)

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPSOCKET_INFO pSocketInfo;
    
    *pfOperationPerformed = FALSE ;

    RequestMutex();
    pSocketInfo = SocketList;
    while (pSocketInfo) {
        if (pSocketInfo->SpxSocket) {

            LPCONNECTION_INFO pConnectionInfo;

            pConnectionInfo = pSocketInfo->Connections;
            while (pConnectionInfo) {

                LPCONNECTION_INFO next;

                //
                // pluck out the Next field now, in case this CONNECTION_INFO
                // is destroyed as the result of an error
                //

                next = pConnectionInfo->Next;

                //
                // if this connection has an active socket or we have issued
                // SPXListenForConnection against the socket then check the
                // state
                //

                if (pConnectionInfo->Socket
                    || (pConnectionInfo->State == CI_WAITING)) {

                    SOCKET sock;
                    BOOL readable;
                    BOOL writeable;
                    BOOL sockError;

                    CheckSelectRead(pSocketInfo, 
                                    pConnectionInfo,
                                    &readable);

                    CheckSelectWrite(pSocketInfo, 
                                     pConnectionInfo,
                                     &writeable);

                    sock = pConnectionInfo->Socket
                         ? pConnectionInfo->Socket
                         : pSocketInfo->Socket
                         ;

                    if (CheckSocketState(sock, &readable, &writeable, &sockError)) {
                        if (!sockError) {
                            if (readable) {
                                AsyncReadAction(pSocketInfo, 
                                                pConnectionInfo,
                                                pfOperationPerformed);
                            }
                            if (writeable) {
                                AsyncWriteAction(pSocketInfo, 
                                                 pConnectionInfo,
                                                 pfOperationPerformed);
                            }
                        } else {

                            IPXDBGPRINT((__FILE__, __LINE__,
                                        FUNCTION_ANY,
                                        IPXDBG_LEVEL_ERROR,
                                        "CheckPendingSpxRequests: socket %x has error. Connection %08x state %d\n",
                                        sock,
                                        pConnectionInfo,
                                        pConnectionInfo->State
                                        ));

                            //
                            // irrespective of the error, we just abort any
                            // connection that gets an error
                            //

                            DequeueConnection(pConnectionInfo->OwningSocket,
                                              pConnectionInfo
                                              );
                            AbortOrTerminateConnection(pConnectionInfo,
                                                       ECB_CC_CONNECTION_ABORTED
                                                       );
                        }
                    } else {

                        IPXDBGPRINT((__FILE__, __LINE__,
                                    FUNCTION_ANY,
                                    IPXDBG_LEVEL_ERROR,
                                    "CheckPendingSpxRequests: CheckSocketState returns %d\n",
                                    WSAGetLastError()
                                    ));

                    }
                } else {

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_ERROR,
                                "CheckPendingSpxRequests: connection %04x (%08x) in weird state?\n",
                                pConnectionInfo->ConnectionId,
                                pConnectionInfo
                                ));

                }
                pConnectionInfo = next;
            }
        }
        pSocketInfo = pSocketInfo->Next;
    }
    ReleaseMutex();
}


PRIVATE
BOOL
CheckSocketState(
    IN SOCKET Socket,
    OUT LPBOOL Readable,
    OUT LPBOOL Writeable,
    OUT LPBOOL Error
    )

/*++

Routine Description:

    Given a socket descriptor, checks to see if it is in one of the following
    states:

        readable    - if waiting for a connection, connection has been made
                      else if established, data is ready to be received

        writeable   - if waiting to make a connection, connection has been
                      made, else if established, we can send data on this
                      socket

        error       - some error has occurred on the socket

Arguments:

    Socket      - socket descriptor to check
    Readable    - returned TRUE if readable
    Writeable   - returned TRUE if writeable
    Error       - returned TRUE if error on socket

Return Value:

    BOOL
        TRUE    - contents of Readable, Writeable and Error are valid
        FALSE   - an error occurred performing the select

--*/

{
    fd_set errors;
    fd_set reads;
    fd_set writes;
    int n;
    static struct timeval timeout = {0, 0};

    FD_ZERO(&errors);
    FD_ZERO(&reads);
    FD_ZERO(&writes);

    if (*Readable)
        FD_SET(Socket, &reads);
    if (*Writeable)
        FD_SET(Socket, &writes);
    FD_SET(Socket, &errors);

    n = select(0, &reads, &writes, &errors, &timeout);

    if (n != SOCKET_ERROR) {
        *Readable = (BOOL)(reads.fd_count == 1);
        *Writeable = (BOOL)(writes.fd_count == 1);
        *Error = (BOOL)(errors.fd_count == 1);
        return TRUE;
    } else if (n) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "CheckSocketState: select returns %d\n",
                    WSAGetLastError()
                    ));

    }
    return FALSE;
}


PRIVATE
VOID
AsyncReadAction(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *ReadPerformed
    )

/*++

Routine Description:

    A connection has some read action to complete - complete a pending
    SPXListenForConnection or SPXListenForSequencedPacket

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    *ReadPerformed = FALSE ;

    switch (pConnectionInfo->State) {
    case CI_STARTING:

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AsyncReadAction: STARTING connection %04x (%08x) readable\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo
                    ));

        break;

    case CI_WAITING:
        if (pConnectionInfo->AcceptQueue.Head) {
            CompleteAccept(pSocketInfo, pConnectionInfo);
            *ReadPerformed = TRUE ;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "AsyncReadAction: connection %04x (%08x): no AcceptQueue\n",
                        pConnectionInfo->ConnectionId,
                        pConnectionInfo
                        ));

        }
        break;

    case CI_ESTABLISHED:
        if (pSocketInfo->ListenQueue.Head) {
            CompleteReceive(pSocketInfo, pConnectionInfo);
            *ReadPerformed = TRUE ;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_WARNING,
                        "AsyncReadAction: connection %04x (%08x): no ListenQueue\n",
                        pConnectionInfo->ConnectionId,
                        pConnectionInfo
                        ));

        }
        break;

    case CI_TERMINATING:

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AsyncReadAction: TERMINATING connection %04x (%08x) readable\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo
                    ));

        break;
    }
}


PRIVATE
VOID
AsyncWriteAction(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *WritePerformed
    )

/*++

Routine Description:

    A connection has some write action to complete - complete a pending
    SPXEstablishConnection or SPXSendSequencedPacket

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    *WritePerformed = FALSE ;

    switch (pConnectionInfo->State) {
    case CI_STARTING:
        if (pConnectionInfo->ConnectQueue.Head) {
            CompleteConnect(pSocketInfo, pConnectionInfo);
            *WritePerformed = TRUE ;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "AsyncWriteAction: connection %04x (%08x): no ConnectQueue\n",
                        pConnectionInfo->ConnectionId,
                        pConnectionInfo
                        ));

        }
        break;

    case CI_WAITING:

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AsyncWriteAction: WAITING connection %04x (%08x) is writeable\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo
                    ));

        break;

    case CI_ESTABLISHED:
        if (pConnectionInfo->SendQueue.Head) {
            CompleteSend(pSocketInfo, pConnectionInfo);
            *WritePerformed = TRUE ;
        } else {
/*
            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_WARNING,
                        "AsyncWriteAction: connection %04x (%08x): no SendQueue\n",
                        pConnectionInfo->ConnectionId,
                        pConnectionInfo
                        ));
*/
        }
        break;

    case CI_TERMINATING:

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AsyncWriteAction: TERMINATING connection %04x (%08x) writeable\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo
                    ));

        break;
    }
}

PRIVATE
VOID
CheckSelectRead(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *CheckRead
    )

/*++

Routine Description:

    See if want to check for Read readiness in select statement.

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    *CheckRead = FALSE ;

    switch (pConnectionInfo->State) 
    {
    case CI_WAITING:

        if (pConnectionInfo->AcceptQueue.Head) 
            *CheckRead = TRUE ;
        break;

    case CI_ESTABLISHED:

        if (pSocketInfo->ListenQueue.Head) 
            *CheckRead = TRUE ;
        break;

    default:

        break;
    }
}


PRIVATE
VOID
CheckSelectWrite(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo,
    OUT BOOL *CheckWrite
    )

/*++

Routine Description:

    See if want to check for Write readiness in select statement.

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    *CheckWrite = FALSE ;

    switch (pConnectionInfo->State) 
    {
    
    case CI_STARTING:

        if (pConnectionInfo->ConnectQueue.Head) 
            *CheckWrite = TRUE ;
        break;

    case CI_ESTABLISHED:

        if (pConnectionInfo->SendQueue.Head) 
            *CheckWrite = TRUE ;
        break;

    default:

        break;
    }
}



PRIVATE
VOID
CompleteAccept(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Complete a SPXListenForConnection

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    SOCKET conn;
    SOCKADDR_IPX remoteAddress;
    int addressLength = sizeof(remoteAddress);
    LPXECB pXecb = pConnectionInfo->AcceptQueue.Head;
    BOOL true = TRUE;
    int rc;

    conn = accept(pSocketInfo->Socket, (LPSOCKADDR)&remoteAddress, &addressLength);
    if (conn != SOCKET_ERROR) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "CompleteAccept: connection %04x (%08x) socket=%x\n",
                    pConnectionInfo->ConnectionId,
                    pConnectionInfo,
                    conn
                    ));

        //
        // we want to receive the frame headers from this socket
        //

        rc = setsockopt(conn,
                        NSPROTO_IPX,
                        IPX_RECVHDR,
                        (char FAR*)&true,
                        sizeof(true)
                        );
        rc = !SOCKET_ERROR;
        if (rc != SOCKET_ERROR) {

            //
            // update the CONNECTION_INFO structure with the actual socket
            // identifier and set the connection state to established
            //

            pConnectionInfo->Socket = conn;
            pConnectionInfo->State = CI_ESTABLISHED;

            //
            // update the app's ECB with the connection ID
            //

            SPX_ECB_CONNECTION_ID(pXecb->Ecb) = pConnectionInfo->ConnectionId;

            //
            // and with the partner address info
            //

            CopyMemory(&pXecb->Ecb->DriverWorkspace,
                       &remoteAddress.sa_netnum,
                       sizeof(pXecb->Ecb->DriverWorkspace)
                       );

            //
            // fill in the immediate address field
            //

            CopyMemory(&pXecb->Ecb->ImmediateAddress,
                       &remoteAddress.sa_nodenum,
                       sizeof(pXecb->Ecb->ImmediateAddress)
                       );

            //
            // remove the XECB from AcceptQueue and complete the SPXListenForConnection ECB
            //

            DequeueEcb(pXecb, &pConnectionInfo->AcceptQueue);

            IPXDUMPECB((pXecb->Ecb,
                        HIWORD(pXecb->EcbAddress),
                        LOWORD(pXecb->EcbAddress),
                        ECB_TYPE_SPX,
                        FALSE,
                        FALSE,
                        IS_PROT_MODE(pXecb)
                        ));

            CompleteOrQueueEcb(pXecb, ECB_CC_SUCCESS);
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "CompleteAccept: setsockopt(IPX_RECVHDR) returns %d\n",
                        WSAGetLastError()
                        ));

            closesocket(conn);
            DequeueEcb(pXecb, &pConnectionInfo->AcceptQueue);
            DequeueConnection(pSocketInfo, pConnectionInfo);
            DeallocateConnection(pConnectionInfo);
            CompleteOrQueueEcb(pXecb, ECB_CC_CONNECTION_ABORTED);
        }
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "CompleteAccept: accept() returns %d\n",
                    WSAGetLastError()
                    ));

    }
}


PRIVATE
VOID
CompleteReceive(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Complete a SPXListenForSequencedPacket

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    LPXECB pXecb;
    int rc;
    BOOL conn_q;
    LPXECB_QUEUE pQueue;
    int len;
    BOOL completeRequest;
    BYTE status;

    //
    // receive packets while there are listen ECBs and data waiting
    //

    while (1) {
        if (pConnectionInfo->ListenQueue.Head) {
            pQueue = &pConnectionInfo->ListenQueue;
            pXecb = pConnectionInfo->ListenQueue.Head;
            conn_q = TRUE;

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "CompleteReceive: XECB %08x from CONNECTION_INFO %08x\n",
                        pXecb,
                        pConnectionInfo
                        ));


        } else if (pSocketInfo->ListenQueue.Head) {
            pQueue = &pSocketInfo->ListenQueue;
            pXecb = pSocketInfo->ListenQueue.Head;
            conn_q = FALSE;

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "CompleteReceive: XECB %08x from SOCKET_INFO %08x\n",
                        pXecb,
                        pSocketInfo
                        ));

        } else {
            break;
        }

        rc = recv(pConnectionInfo->Socket, pXecb->Data, pXecb->Length, 0);

        if (rc != SOCKET_ERROR) {
            len = rc;
            status = ECB_CC_SUCCESS;
            completeRequest = TRUE;
        } else {
            rc = WSAGetLastError();
            if (rc == WSAEMSGSIZE) {
                len = pXecb->Length;
                status = ECB_CC_PACKET_OVERFLOW;
                completeRequest = TRUE;
            } else {
                completeRequest = FALSE;

                //
                // if no data to receive, quit the loop (don't go down error path)
                //

                if (rc == WSAEWOULDBLOCK) {
                    break;
                }
            }

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "CompleteReceive: error %d on socket %08x (CID %04x)\n",
                        rc,
                        pConnectionInfo->Socket,
                        pConnectionInfo->ConnectionId
                        ));

            DUMPXECB(pXecb);

        }
        if( rc == WSAEDISCON ) {

            //
            // handle the disconnect case - we still need to complete the
            // ECB.
            //

            LPSPX_PACKET pPacket = (LPSPX_PACKET)pXecb->Buffer;

            status = ECB_CC_SUCCESS;


            pPacket->DestinationConnectId = pConnectionInfo->ConnectionId;
            pPacket->SourceConnectId = pConnectionInfo->RemoteConnectionId;
            pPacket->DataStreamType = SPX_DS_TERMINATE ;
            pPacket->Checksum = 0xffff;
            pPacket->Length = L2BW(SPX_HEADER_LENGTH);
            pPacket->TransportControl = 0;
            pPacket->PacketType = 5;

            pXecb->Length = SPX_HEADER_LENGTH ;
            ScatterData(pXecb);

            DequeueEcb(pXecb, pQueue);

            //
            // Put the remote node address in the ECB's immediate address
            // field
            //

            CopyMemory(pXecb->Ecb->ImmediateAddress,
                       pConnectionInfo->RemoteNode,
                       sizeof(pXecb->Ecb->ImmediateAddress)
                       );

            CompleteOrQueueIo(pXecb, status);

            DequeueConnection(pConnectionInfo->OwningSocket, pConnectionInfo);
            AbortOrTerminateConnection(pConnectionInfo, ECB_CC_CONNECTION_ABORTED);
            break ;

        }
        else if (completeRequest) {

#if SPX_HACK
            if (pConnectionInfo->Flags & CF_1ST_RECEIVE) {
                pConnectionInfo->Flags &= ~CF_1ST_RECEIVE;
                ModifyFirstReceive(pXecb->Data, &len, pSocketInfo->SocketNumber, pConnectionInfo->Socket);
            }
#endif

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "CompleteReceive: recv() on socket %#x returns %d bytes (Addr=%08x)\n",
                        pConnectionInfo->Socket,
                        len,
                        pXecb->Data
                        ));

            IPXDUMPDATA((pXecb->Data, 0, 0, FALSE, (WORD)len));

            pXecb->Length -= (USHORT) len;
            pXecb->ActualLength += (USHORT)len;
            pXecb->Data += len;
            if (pXecb->ActualLength >= SPX_HEADER_LENGTH) {
                if (pXecb->Flags & XECB_FLAG_FIRST_RECEIVE) {

                    LPSPX_PACKET pPacket = (LPSPX_PACKET)pXecb->Buffer;

                    //
                    // record in the SPX header the local connection id we invented
                    //

                    pPacket->DestinationConnectId = pConnectionInfo->ConnectionId;

                    //
                    // record the actual frame length from the header
                    //

                    pXecb->FrameLength = B2LW(((LPSPX_PACKET)pXecb->Buffer)->Length);
                    pXecb->Flags &=  ~XECB_FLAG_FIRST_RECEIVE;

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_ANY,
                                IPXDBG_LEVEL_INFO,
                                "CompleteReceive: FrameLength=%x (%d)\n",
                                pXecb->FrameLength,
                                pXecb->FrameLength
                                ));

                }

                //
                // if we received all the data in the packet (according to length
                // field in the SPX header) OR we ran out of buffer space, remove
                // the ECB from its queue and complete it
                //

                if (!pXecb->Length || (pXecb->ActualLength == pXecb->FrameLength)) {
                    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {

                        //
                        // update the XECB.Length field to reflect the amount of
                        // data received and copy it to the fragmented buffers 
                        // in VDM. do not overflow buffer if FrameLength turns
                        // out to be larger than we expect.
                        //

                        pXecb->Length = min(pXecb->FrameLength,
                                            pXecb->ActualLength);
                        ScatterData(pXecb);
                    }
                    DequeueEcb(pXecb, pQueue);

                    // DUMPXECB(pXecb);


                    IPXDUMPECB((pXecb->Ecb,
                                HIWORD(pXecb->EcbAddress),
                                LOWORD(pXecb->EcbAddress),
                                ECB_TYPE_SPX,
                                TRUE,
                                TRUE,
                                IS_PROT_MODE(pXecb)
                                ));

                    //
                    // Put the remote node address in the ECB's immediate address
                    // field
                    //

                    CopyMemory(pXecb->Ecb->ImmediateAddress,
                               pConnectionInfo->RemoteNode,
                               sizeof(pXecb->Ecb->ImmediateAddress)
                               );
                    CompleteOrQueueIo(pXecb, status);
                } else {

                    //
                    // partial receive. If the listen ECB came off the socket
                    // queue then put it on the connection queue: this is the
                    // ECB that will be used for this connection until all data
                    // received or we get an error
                    //

                    if (!conn_q) {
                        DequeueEcb(pXecb, &pSocketInfo->ListenQueue);
                        QueueEcb(pXecb,
                                 &pConnectionInfo->ListenQueue,
                                 CONNECTION_LISTEN_QUEUE
                                 );
                    }

                    //
                    // not enough data to satisfy read: don't continue yet
                    //

                    break;
                }
            }
        } else {

            //
            // error occurred - abort the connection
            //

            if (!conn_q) {
                DequeueEcb(pXecb, &pSocketInfo->ListenQueue);
                QueueEcb(pXecb,
                         &pConnectionInfo->ListenQueue,
                         CONNECTION_LISTEN_QUEUE
                         );
            }
            DequeueConnection(pConnectionInfo->OwningSocket, pConnectionInfo);
            AbortOrTerminateConnection(pConnectionInfo, ECB_CC_CONNECTION_ABORTED);

            //
            // don't continue in this case
            //

            break;
        }
    }
}


PRIVATE
VOID
CompleteConnect(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Complete a SPXEstablishConnection

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    LPXECB pXecb = pConnectionInfo->ConnectQueue.Head;
/*
    LPSPX_PACKET pPacket;

    //
    // the connection ID also appears in the first segment of the establish
    // ECB
    //

    pPacket = (LPSPX_PACKET)GET_FAR_POINTER(&ECB_FRAGMENT(pXecb->Ecb, 0)->Address,
                                                          IS_PROT_MODE(pXecb)
                                                          );
    pPacket->Checksum = 0xffff;
    pPacket->Length = L2BW(SPX_HEADER_LENGTH);
    pPacket->TransportControl = 0;
    pPacket->PacketType = 5;
    pPacket->Source.Socket = pSocketInfo->SocketNumber;
    pPacket->ConnectionControl = 0xc0;
    pPacket->DataStreamType = 0;
    pPacket->SourceConnectId = pConnectionInfo->ConnectionId;
    pPacket->DestinationConnectId = 0xffff;
    pPacket->SequenceNumber = 0;
    pPacket->AckNumber = 0;
    pPacket->AllocationNumber = 0;
*/

    pConnectionInfo->State = CI_ESTABLISHED;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "CompleteConnect: connection %04x (%08x) completed\n",
                pConnectionInfo->ConnectionId,
                pConnectionInfo
                ));

    DUMPCONN(pConnectionInfo);

    DequeueEcb(pXecb, &pConnectionInfo->ConnectQueue);

    IPXDUMPECB((pXecb->Ecb,
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                ECB_TYPE_SPX,
                TRUE,
                TRUE,
                IS_PROT_MODE(pXecb)
                ));

    CompleteOrQueueEcb(pXecb, ECB_CC_SUCCESS);
}


PRIVATE
VOID
CompleteSend(
    IN LPSOCKET_INFO pSocketInfo,
    IN LPCONNECTION_INFO pConnectionInfo
    )

/*++

Routine Description:

    Complete a SPXSendSequencedPacket

Arguments:

    pSocketInfo     - pointer to SOCKET_INFO
    pConnectionInfo - pointer to CONNECTION_INFO

Return Value:

    None.

--*/

{
    LPXECB pXecb = pConnectionInfo->SendQueue.Head;
    int rc;
    BYTE status;

    LPSPX_PACKET pPacket;  //Multi-User addition
    int flags = 0;             //Multi-User addition

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "CompleteSend: sending %d (0x%x) bytes from %08x\n",
                pXecb->Length,
                pXecb->Length,
                pXecb->Data
                ));

    IPXDUMPECB((pXecb->Ecb,
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                ECB_TYPE_SPX,
                TRUE,
                TRUE,
                IS_PROT_MODE(pXecb)
                ));

    //======Multi-User code merge ==============================
    // 2/18/97 cjc Code copied from _VwSPXSendSequencedPacket (vwspx.c) to fix
    //             problem where EndOfMessage bit was being set prematurely and
    //             caused BSPXCOM8 error messages with Btrieve.

    //
    // if the app set the END_OF_MESSAGE bit in the ConnectionControl
    // field then set the flags to 0: NWLink will automatically set the
    // end-of-message bit in the packet; otherwise set flags to MSG_PARTIAL
    // to indicate to NWLink that it *shouldn't* set the bit in the packet
    //
    pPacket = (LPSPX_PACKET)GET_FAR_POINTER(
                                    &(ECB_FRAGMENT(pXecb->Ecb, 0)->Address),
                                    IS_PROT_MODE(pXecb)
                                    );
    if (pPacket) {
        flags = (pPacket->ConnectionControl & SPX_END_OF_MESSAGE)
              ? 0
              : MSG_PARTIAL
              ;
    }

    rc = send(pConnectionInfo->Socket, pXecb->Data, pXecb->Length, flags);

    //rc = send(pConnectionInfo->Socket, pXecb->Data, pXecb->Length, 0); //Original
    //======Multi-User code merge End ==============================
    if (rc == pXecb->Length) {

        //
        // all data sent
        //

        status = ECB_CC_SUCCESS;
    } else if (rc == SOCKET_ERROR) {
        rc = WSAGetLastError();
        if (rc == WSAEWOULDBLOCK) {

            //
            // huh???
            //

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "CompleteSend: send() returns WSAEWOODBLOCK??\n"
                        ));

            //
            // leave ECB on queue
            //

            return;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "CompleteSend: send() returns %d\n",
                        rc
                        ));

            status = ECB_CC_CONNECTION_ABORTED;
        }
    } else {

        //
        // partial data sent. Update the buffer pointer and length fields
        // and leave this ECB at the head of the send queue
        //

        pXecb->Data += rc;
        pXecb->Length -= (WORD)rc;
        return;
    }
    DequeueEcb(pXecb, &pConnectionInfo->SendQueue);
    CompleteOrQueueIo(pXecb, status);
}

#if SPX_HACK

PRIVATE
VOID
ModifyFirstReceive(
    LPBYTE Buffer,
    LPDWORD pLength,
    WORD SocketNumber,
    SOCKET Socket
    )
{
    WORD len = *(LPWORD)pLength;

    if ((*(ULPWORD)Buffer != 0xffff) && (*(ULPWORD)(Buffer+2) != L2BW(len))) {

        LPSPX_PACKET packet;
        SOCKADDR_IPX remote;
        int rc;
        int remlen;

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "ModifyFirstReceive: Modifying: Buffer=%08x Length=%04x SocketNumber=%04x Socket=%08x\n",
                    Buffer,
                    len,
                    B2LW(SocketNumber),
                    Socket
                    ));

        MoveMemory(Buffer+42, Buffer, len);
        packet = (LPSPX_PACKET)Buffer;
        packet->Checksum = 0xffff;
        packet->Length = L2BW(42+len);
        packet->TransportControl = 0;
        packet->PacketType = 5;
        CopyMemory((LPVOID)&packet->Destination,
                   (LPVOID)&MyInternetAddress.sa_netnum,
                   sizeof(INTERNET_ADDRESS)
                   );
        packet->Destination.Socket = SocketNumber;
        rc = getpeername(Socket, (LPSOCKADDR)&remote, &remlen);
        if (rc != SOCKET_ERROR) {
            CopyMemory((LPVOID)&packet->Source,
                       (LPVOID)&remote.sa_netnum,
                       sizeof(NETWARE_ADDRESS)
                       );
        } else {
            ZeroMemory((LPVOID)&packet->Source, sizeof(NETWARE_ADDRESS));
        }
        packet->ConnectionControl = 0x40;
        packet->DataStreamType = 0;
        packet->SourceConnectId = 0;
        packet->DestinationConnectId = 0;
        packet->SequenceNumber = 0;
        packet->AckNumber = 0;
        packet->AllocationNumber = 0;
        *pLength += 42;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\util.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    util.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains various utility routines

    Contents:
        GetInternetAddress
        GetMaxPacketSize
        RetrieveEcb
        RetrieveXEcb
        (AllocateXecb)
        (DeallocateXecb)
        ScheduleEvent
        ScanTimerList
        CancelTimerEvent
        CancelTimedEvents
        CancelAsyncEvent
        CancelSocketEvent
        CancelConnectionEvent
        QueueEcb
        DequeueEcb
        CancelSocketQueue
        CancelConnectionQueue
        AbortQueue
        AbortConnectionEvent
        StartIpxSend
        GetIoBuffer
        (ReleaseIoBuffer)
        GatherData
        ScatterData
        IpxReceiveFirst
        IpxReceiveNext
        (IpxSendFirst)
        IpxSendNext
        (QueueReceiveRequest)
        (DequeueReceiveRequest)
        (QueueSendRequest)
        (DequeueSendRequest)
        CompleteOrQueueIo
        CompleteIo
        CompleteOrQueueEcb
        CompleteEcb
        (QueueAsyncCompletion)
        EsrCallback
        VWinEsrCallback
        FifoAddHead
        FifoAdd
        FifoRemove
        FifoNext

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// private routine prototypes
//

PRIVATE
LPXECB
AllocateXecb(
    VOID
    );

PRIVATE
VOID
DeallocateXecb(
    IN LPXECB pXecb
    );

PRIVATE
VOID
ReleaseIoBuffer(
    IN LPXECB pXecb
    );

PRIVATE
VOID
IpxSendFirst(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
VOID
QueueReceiveRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
LPXECB
DequeueReceiveRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
VOID
QueueSendRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
LPXECB
DequeueSendRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

PRIVATE
VOID
QueueAsyncCompletion(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

//
// private data
//

//
// TimerList - singly-linked list of timed events, in order of duration
//

PRIVATE LPXECB TimerList = NULL;

//
// AsyncCompletionQueue - keeps list of completed ECBs awaiting removal via
// ESR callback
//

PRIVATE FIFO AsyncCompletionQueue = {NULL, NULL};

//
// sort-of-private data (matches not-really-global data in other modules)
//

//
// SerializationCritSec - grab this when manipulating SOCKET_INFO list
//

CRITICAL_SECTION SerializationCritSec;

//
// AsyncCritSec - grab this when manipulating AsyncCompletionQueue
//

CRITICAL_SECTION AsyncCritSec;

//
// functions
//


int
GetInternetAddress(
    IN OUT LPSOCKADDR_IPX InternetAddress
    )

/*++

Routine Description:

    Gets the node and net numbers for this station

Arguments:

    InternetAddress - pointer to SOCKADDR_IPX structure to fill with internetwork
                      address for this station

Return Value:

    int
        Success - 0
        Failure - SOCKET_ERROR

--*/

{
    SOCKET s;
    int rc;
    int structureLength = sizeof(*InternetAddress);

    s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
    if (s != INVALID_SOCKET) {

        //
        // make dynamic binding (socket number = 0)
        //

        ZeroMemory(InternetAddress, structureLength);
        InternetAddress->sa_family = AF_IPX;
        rc = bind(s, (LPSOCKADDR)InternetAddress, structureLength);
        if (rc != SOCKET_ERROR) {
            rc = getsockname(s, (LPSOCKADDR)InternetAddress, &structureLength);
            if (rc) {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_ERROR,
                            "GetInternetAddress: getsockname() returns %d\n",
                            WSAGetLastError()
                            ));

            }
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "GetInternetAddress: bind() returns %d\n",
                        WSAGetLastError()
                        ));

        }
        closesocket(s);
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "GetInternetAddress: socket() returns %d\n",
                    WSAGetLastError()
                    ));

        rc = SOCKET_ERROR;
    }
    return rc;
}


int
GetMaxPacketSize(
    OUT LPWORD MaxPacketSize
    )

/*++

Routine Description:

    Returns the maximum packet allowed by the underlying transport

Arguments:

    MaxPacketSize   - pointer to returned maximum packet size

Return Value:

    int
        Success - 0
        Failure - SOCKET_ERROR

--*/

{
    SOCKET s;
    int maxLen, maxLenSize = sizeof(maxLen);
    int rc;
    SOCKADDR_IPX ipxAddr;

    s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
    if (s != SOCKET_ERROR) {

        //
        // set socket to 0 - causes any applicable address to be bound
        //

        ZeroMemory(&ipxAddr, sizeof(ipxAddr));
        ipxAddr.sa_family = AF_IPX;
        rc = bind(s, (LPSOCKADDR)&ipxAddr, sizeof(ipxAddr));
        if (rc != SOCKET_ERROR) {

            rc = getsockopt(s,
                            NSPROTO_IPX,
                            IPX_MAXSIZE,
                            (char FAR*)&maxLen,
                            &maxLenSize
                            );
            if (rc != SOCKET_ERROR) {

                //
                // IPX_MAXSIZE always returns the amount of data that can be
                // transmitted in a single frame. 16-bit IPX/SPX requires that
                // the IPX header length be included in the data size
                //

                maxLen += IPX_HEADER_LENGTH;
            } else {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_ERROR,
                            "GetMaxPacketSize: getsockopt() returns %d\n",
                            WSAGetLastError()
                            ));

            }
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "GetMaxPacketSize: bind() returns %d\n",
                        WSAGetLastError()
                        ));

        }
        closesocket(s);
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "GetMaxPacketSize: socket() returns %d\n",
                    WSAGetLastError()
                    ));

        rc = SOCKET_ERROR;
    }

    *MaxPacketSize = (rc != SOCKET_ERROR) ? maxLen : MAXIMUM_IPX_PACKET_LENGTH;

    return rc;
}


LPXECB
RetrieveEcb(
    IN BYTE EcbType
    )

/*++

Routine Description:

    Returns pointer to 32-bit extended ECB structure which contains flat pointer
    to IPX or AES ECB in VDM memory

    We allocate the extended ECB for 3 reasons:

        1. Avoids 16-bit app scribbling over our control fields
        2. Don't have to make unaligned references to all fields (still need some)
        3. Don't have enough space in AES ECB to remember all the stuff we need

    However, we do update the 16-bit ECB's LinkAddress field. We use this as a
    pointer to the 32-bit XECB we allocate in this routine. This just saves us
    having to traverse all the lists looking for the address of the 16-bit ECB
    (which we could still do as a fall-back)

Arguments:

    EcbType - type of ECB - AES, IPX or SPX

Return Value:

    LPXECB  - 32-bit pointer to extended ECB structure

--*/

{
    WORD segment;
    WORD offset;
    LPECB pEcb;

    segment = IPX_GET_ECB_SEGMENT();
    offset = IPX_GET_ECB_OFFSET();
    pEcb = (LPIPX_ECB)POINTER_FROM_WORDS(segment, offset, sizeof(IPX_ECB));

    return RetrieveXEcb(EcbType, pEcb, (ECB_ADDRESS)MAKELONG(offset,segment));
}


LPXECB
RetrieveXEcb(
    IN BYTE EcbType,
    LPECB pEcb,
    ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    worker for RetrieveEcb, callable from windows functions (ex DOS parms)

Arguments:

    EcbType     - type of ECB - AES, IPX or SPX
    pEcb        - pointer to the 16-bit ECB
    EcbAddress  - address (seg:off in DWORD) of 16-bit ECB

Return Value:

    LPXECB

--*/

{
    LPXECB pXecb;

    if (pEcb) {

        // 
        // tommye - MS 30525
        // Make sure the pEcb is valid - we'll go ahead
        // and do this before we alloc the XEcb.
        //

        try {
            BYTE x;

            // Just deref the ptr to make sure it is okay

            x = pEcb->InUse;

        } except(1) {

            //
            // bad pointer: bogus ECB
            //

            return NULL;
        }

        //
        // allocate and fill-in 32-bit extended ECB structure. If can't allocate
        // then return NULL
        //

        pXecb = AllocateXecb();
        if (pXecb) {
            pXecb->Ecb = pEcb;
            pXecb->EcbAddress = EcbAddress;
            pXecb->EsrAddress = pEcb->EsrAddress;

            //
            // set flags - IPX/AES, SPX, protect-mode
            //

            pXecb->Flags |= (((EcbType == ECB_TYPE_IPX) || (EcbType == ECB_TYPE_SPX))
                            ? XECB_FLAG_IPX
                            : XECB_FLAG_AES)
                         | ((EcbType == ECB_TYPE_SPX) ? XECB_FLAG_SPX : 0)
                         | ((getMSW() & MSW_PE) ? XECB_FLAG_PROTMODE : 0);

            //
            // this XECB is not yet on a queue
            //

            pXecb->QueueId = NO_QUEUE;

            //
            // mark the 16-bit ECB as being used. We use an undefined value to
            // make sure it gets set/reset in the right places
            //

            pEcb->InUse = ECB_IU_TEMPORARY;

            //
            // use the LinkAddress field in the 16-bit ECB to point to the XECB.
            // We use this when cancelling the ECB
            //

            pEcb->LinkAddress = pXecb;

            //
            // AES and IPX ECBs have different sizes and different layouts
            //

            if ((EcbType == ECB_TYPE_IPX) || (EcbType == ECB_TYPE_SPX)) {
                pXecb->SocketNumber = pEcb->SocketNumber;
            }
        }
    } else {
        pXecb = NULL;
    }
    return pXecb;
}


PRIVATE
LPXECB
AllocateXecb(
    VOID
    )

/*++

Routine Description:

    Allocate an XECB; zero it; set the reference count to 1

Arguments:

    None.

Return Value:

    LPXECB

--*/

{
    LPXECB pXecb;

    pXecb = (LPXECB)LocalAlloc(LPTR, sizeof(*pXecb));
    if (pXecb) {
        pXecb->RefCount = 1;
    }
    return pXecb;
}


PRIVATE
VOID
DeallocateXecb(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    decrement the XECB reference count (while holding SerializationCritSec). If
    goes to 0 then free the structure (else other thread is also holding pointer
    to XECB)

Arguments:

    pXecb   - XECB to deallocate

Return Value:

    None.

--*/

{
    RequestMutex();
    --pXecb->RefCount;
    if (!pXecb->RefCount) {

#if DBG
        FillMemory(pXecb, sizeof(*pXecb), 0xFF);
#endif

        FREE_OBJECT(pXecb);
    }
    ReleaseMutex();
}


VOID
ScheduleEvent(
    IN LPXECB pXecb,
    IN WORD Ticks
    )

/*++

Routine Description:

    Adds an ECB to the TimerList, ordered by Ticks. The value of Ticks cannot
    be zero

    Assumes 1. Ticks != 0
            2. pXecb->Next is already NULL (as result of LocalAlloc(LPTR,...)

Arguments:

    pXecb   - pointer to XECB describing IPX or AES ECB to queue
    Ticks   - number of ticks to elapse before ECB is cooked

Return Value:

    None.

--*/

{
    ASSERT(Ticks);
    ASSERT(pXecb->Next == NULL);

    RequestMutex();
    if (!TimerList) {
        TimerList = pXecb;
    } else {
        if (TimerList->Ticks > Ticks) {
            TimerList->Ticks -= Ticks;
            pXecb->Next = TimerList;
            TimerList = pXecb;
        } else {

            LPXECB previous = (LPXECB)TimerList;
            LPXECB this = previous->Next;

            Ticks -= TimerList->Ticks;
            while (this && Ticks > this->Ticks) {
                Ticks -= this->Ticks;
                previous = this;
                this = this->Next;
            }
            previous->Next = pXecb;
            pXecb->Next = this;
        }
    }
    pXecb->Ticks = Ticks;
    pXecb->QueueId = TIMER_QUEUE;
    ReleaseMutex();
}


VOID
ScanTimerList(
    VOID
    )

/*++

Routine Description:

    Called once per tick. Decrements the tick count of the ECB at the head of
    the list. If it goes to zero, completes the ECB and any subsequent ECBs
    which whose tick count would go to zero

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPXECB pXecb;

    RequestMutex();
    pXecb = TimerList;
    if (pXecb) {

        //
        // Decrement if not already zero. Can be zero because the ECB at the
        // front of the list could have been Cancelled. This makes sure we
        // do not wrap around to 0xFFFF !!!
        //

        if (pXecb->Ticks != 0)
            --pXecb->Ticks;

        if (!pXecb->Ticks) {

            //
            // complete all ECBs that would go to 0 on this tick
            //

            while (pXecb->Ticks <= 1) {
                TimerList = pXecb->Next;

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_INFO,
                            "ScanTimerList: ECB %04x:%04x is done\n",
                            HIWORD(pXecb->EcbAddress),
                            LOWORD(pXecb->EcbAddress)
                            ));

                CompleteOrQueueEcb(pXecb, ECB_CC_SUCCESS);
                pXecb = TimerList;
                if (!pXecb) {
                    break;
                }
            }
        }
    }

    ReleaseMutex();
}


BYTE
CancelTimerEvent(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Cancels a pending event on the timer list

Arguments:

    pXecb   - pointer to XECB to cancel

Return Value:

    BYTE
        Success - IPX_SUCCESS
        Failure - IPX_ECB_NOT_IN_USE

--*/

{
    LPXECB listptr;
    LPXECB previous = (LPXECB)&TimerList;
    BYTE status;

    RequestMutex();
    listptr = TimerList;
    while (listptr && listptr != pXecb) {
        previous = listptr;
        listptr = listptr->Next;
    }
    if (listptr) {

        //
        // take the XECB out of the list and complete the ECB (in VDM memory).
        // Does not generate a call-back to the ESR. When CompleteEcb returns,
        // the XECB has been deallocated
        //

        previous->Next = listptr->Next;

        ASSERT(pXecb->RefCount == 2);

        --pXecb->RefCount;
        CompleteEcb(pXecb, ECB_CC_CANCELLED);
        status = IPX_SUCCESS;
    } else {
        status = IPX_ECB_NOT_IN_USE;
    }
    ReleaseMutex();
    return status;
}


VOID
CancelTimedEvents(
    IN WORD SocketNumber,
    IN WORD Owner,
    IN DWORD TaskId
    )

/*++

Routine Description:

    traverses the TimerList cancelling any IPX or AES events owned by any of
    SocketNumber, Owner or TaskId

    Assumes valid SocketNumber, Owner or TaskId cannot be 0

Arguments:

    SocketNumber    - owning socket of IPX events to cancel
    Owner           - owning DOS PDB
    TaskID          - owning Windows Task ID

Return Value:

    None.

--*/

{
    LPXECB pXecb;
    LPXECB prev = (LPXECB)&TimerList;
    LPXECB next;

    RequestMutex();
    pXecb = TimerList;
    while (pXecb) {

        next = pXecb->Next;

        if ((SocketNumber && (pXecb->SocketNumber == SocketNumber))
        || (Owner && !(pXecb->Flags & XECB_FLAG_IPX) && (pXecb->Owner == Owner))
        || (TaskId && (pXecb->TaskId == TaskId))) {

            prev->Next = next;

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "CancelTimedEvents: cancelling ECB %08x (%04x:%04x)\n",
                        pXecb,
                        HIWORD(pXecb->EcbAddress),
                        LOWORD(pXecb->EcbAddress)
                        ));

            CompleteEcb(pXecb, ECB_CC_CANCELLED);
        }
        else
        {
            prev = pXecb ;
        }
        pXecb = next;
    }
    ReleaseMutex();
}


BYTE
CancelAsyncEvent(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Called to cancel an event currently on the async completion list. We don't
    cancel these events - just return 0xF9 (ECB cannot be cancelled). It is a
    race to see who gets there first - us with the cancel, or the ESR callback.
    In this case it is fairly immaterial

Arguments:

    pXecb   - pointer to XECB to cancel (ignored)

Return Value:

    BYTE    - IPX_CANNOT_CANCEL

--*/

{
    //
    // we call DeallocateXecb to reduce the reference count. If the other thread
    // really tried to deallocate it in the short time we've been looking at it
    // on the cancel path, the call will finish up what the other thread started
    //

    DeallocateXecb(pXecb);
    return IPX_CANNOT_CANCEL;
}


BYTE
CancelSocketEvent(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Called to cancel a pending send or listen from a socket queue. Request can
    be IPX or SPX. If IPX event, then the ECB is on either the SendQueue or
    ListenQueue. If SPX, it may be on a CONNECTION_INFO ConnectQueue,
    AcceptQueue, SendQueue or ListenQueue, or if it is an
    SPXListenForSequencedPacket request that is still in the pool then it may
    be on the owning SOCKET_INFO ListenQueue

Arguments:

    pXecb   - pointer to XECB describing ECB to cancel

Return Value:

    BYTE    - IPX_SUCCESS

--*/

{
    LPXECB ptr;
    LPVOID pObject;

    RequestMutex();
    pObject = pXecb->OwningObject;
    switch (pXecb->QueueId) {
    case SOCKET_LISTEN_QUEUE:
        if (pXecb->Flags & XECB_FLAG_SPX) {
            ptr = DequeueEcb(pXecb, &((LPSOCKET_INFO)pObject)->ListenQueue);
        } else {
            ptr = DequeueReceiveRequest(pXecb, (LPSOCKET_INFO)pObject);
        }
        break;

    case SOCKET_SEND_QUEUE:
        if (pXecb->Flags & XECB_FLAG_SPX) {
            ptr = DequeueEcb(pXecb, &((LPSOCKET_INFO)pObject)->SendQueue);
        } else {
            ptr = DequeueSendRequest(pXecb, (LPSOCKET_INFO)pObject);
        }
        break;

    case SOCKET_HEADER_QUEUE:                  // SPX only
        if (pXecb->Flags & XECB_FLAG_SPX) {
            ptr = DequeueEcb(pXecb, &((LPSOCKET_INFO)pObject)->HeaderQueue);
        } else {
            ASSERT(FALSE);
        }
        break;
    }
    ReleaseMutex();
    if (ptr) {
        CompleteIo(ptr, ECB_CC_CANCELLED);
    }
    return IPX_SUCCESS;
}


BYTE
CancelConnectionEvent(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Cancels a pending SPXListenForConnection or SPXListenForSequencedPacket, the
    only cancellable SPX requests

Arguments:

    pXecb   - pointer to SPX XECB to cancel

Return Value:

    BYTE    - IPX_SUCCESS

--*/

{
    LPXECB ptr;
    LPVOID pObject;
    LPXECB_QUEUE pQueue;

    RequestMutex();
    pObject = pXecb->OwningObject;
    switch (pXecb->QueueId) {
    case CONNECTION_ACCEPT_QUEUE:
        pQueue = &((LPCONNECTION_INFO)pObject)->AcceptQueue;
        break;

    case CONNECTION_LISTEN_QUEUE:
        pQueue = &((LPCONNECTION_INFO)pObject)->ListenQueue;
        break;
    }
    ptr = DequeueEcb(pXecb, pQueue);
    ReleaseMutex();
    if (ptr) {
        CompleteIo(ptr, ECB_CC_CANCELLED);
    }
    return IPX_SUCCESS;
}


VOID
QueueEcb(
    IN LPXECB pXecb,
    IN LPXECB_QUEUE Queue,
    IN QUEUE_ID QueueId
    )

/*++

Routine Description:

    Adds an XECB to a queue and sets the queue identifier in the XECB.

Arguments:

    pXecb   - pointer to XECB to queue
    Queue   - pointer to queue to add XECB to (at tail)
    QueueId - identifies Queue

Return Value:

    None.

--*/

{
    LPVOID owningObject = NULL;

#define CONTAINER_STRUCTURE(p, t, f) (LPVOID)(((LPBYTE)(p)) - (UINT_PTR)(&((t)0)->f))

    pXecb->QueueId = QueueId;
    switch (QueueId) {
    case SOCKET_LISTEN_QUEUE:
        if (Queue->Tail && (Queue->Tail->Length < pXecb->Length)) {
            FifoAddHead((LPFIFO)Queue, (LPFIFO)pXecb);
        } else {
            FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        }
        owningObject = CONTAINER_STRUCTURE(Queue, LPSOCKET_INFO, ListenQueue);
        break;

    case SOCKET_SEND_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPSOCKET_INFO, SendQueue);
        break;

    case SOCKET_HEADER_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPSOCKET_INFO, HeaderQueue);
        break;

    case CONNECTION_CONNECT_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPCONNECTION_INFO, ConnectQueue);
        break;

    case CONNECTION_ACCEPT_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPCONNECTION_INFO, AcceptQueue);
        break;

    case CONNECTION_SEND_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPCONNECTION_INFO, SendQueue);
        break;

    case CONNECTION_LISTEN_QUEUE:
        FifoAdd((LPFIFO)Queue, (LPFIFO)pXecb);
        owningObject = CONTAINER_STRUCTURE(Queue, LPCONNECTION_INFO, ListenQueue);
        break;
    }
    pXecb->OwningObject = owningObject;
}


LPXECB
DequeueEcb(
    IN LPXECB pXecb,
    IN LPXECB_QUEUE Queue
    )

/*++

Routine Description:

    Removes pXecb from Queue and resets the XECB queue identifier (to NO_QUEUE)

Arguments:

    pXecb   - pointer to XECB to remove
    Queue   - queue from which to remove pXecb

Return Value:

    LPXECB
        pointer to removed XECB

--*/

{
    LPXECB p;

    p = (LPXECB)FifoRemove((LPFIFO)Queue, (LPFIFO)pXecb);
    pXecb->QueueId = NO_QUEUE;
    pXecb->OwningObject = NULL;
    return pXecb;
}


VOID
CancelSocketQueue(
    IN LPXECB_QUEUE pXecbQueue
    )

/*++

Routine Description:

    Cancels all pending ECBs on a SOCKET_INFO queue

Arguments:

    pXecbQueue  - pointer to (socket/connection) queue

Return Value:

    None.

--*/

{
    LPXECB ptr;

    while (ptr = pXecbQueue->Head) {
        CancelSocketEvent(ptr);
    }
}


VOID
CancelConnectionQueue(
    IN LPXECB_QUEUE pXecbQueue
    )

/*++

Routine Description:

    Cancels all pending ECBs on a CONNECTION_INFO queue

Arguments:

    pXecbQueue  - pointer to XECB queue on CONNECTION_INFO

Return Value:

    None.

--*/

{
    LPXECB ptr;

    while (ptr = pXecbQueue->Head) {
        CancelConnectionEvent(ptr);
    }
}


VOID
AbortQueue(
    IN LPXECB_QUEUE pXecbQueue,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Aborts or terminates an ECB queue from a CONNECTION_INFO structure

Arguments:

    pXecbQueue      - pointer to queue
    CompletionCode  - to put in aborted/terminated ECBs

Return Value:

    None.

--*/

{
    LPXECB ptr;

    while (ptr = pXecbQueue->Head) {
        AbortConnectionEvent(ptr, CompletionCode);
    }
}


VOID
AbortConnectionEvent(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Aborts a connection ECB

Arguments:

    pXecb           - pointer to SPX XECB to cancel
    CompletionCode  - value to put in ECB

Return Value:

    None.

--*/

{
    LPXECB ptr;
    LPCONNECTION_INFO pConnectionInfo;
    LPXECB_QUEUE pQueue;

    pConnectionInfo = (LPCONNECTION_INFO)pXecb->OwningObject;
    switch (pXecb->QueueId) {
    case CONNECTION_CONNECT_QUEUE:
        pQueue = &pConnectionInfo->ConnectQueue;
        break;

    case CONNECTION_ACCEPT_QUEUE:
        pQueue = &pConnectionInfo->AcceptQueue;
        break;

    case CONNECTION_SEND_QUEUE:
        pQueue = &pConnectionInfo->SendQueue;
        break;

    case CONNECTION_LISTEN_QUEUE:
        pQueue = &pConnectionInfo->ListenQueue;
        break;
    }
    ptr = DequeueEcb(pXecb, pQueue);
    if (ptr) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "AbortConnectionEvent: Aborting ECB %04x:%04x\n",
                    HIWORD(pXecb->EcbAddress),
                    LOWORD(pXecb->EcbAddress)
                    ));

        SPX_ECB_CONNECTION_ID(ptr->Ecb) = pConnectionInfo->ConnectionId;
        CompleteOrQueueIo(ptr, CompletionCode);
    }
}


VOID
StartIpxSend(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Starts a send operation for IPXSendPacket(). Allocates a send buffer if
    the ECB has >1 fragment else uses a pointer to the single fragment buffer
    in 16-bit address space

    Fills in various fields in the ECB and IPX header

    Assumes:    1. By the time this function is called, we already know we have
                   a valid non-zero fragment count and the first fragment is
                   big enough to hold an IPX packet header

    When this function terminates, the ECB is either completed or queued

Arguments:

    pXecb       - pointer to XECB describing ECB to use for sending
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    None.

--*/

{
    BOOL success;
    int packetLength = 0;
    LPFRAGMENT pFragment;
    int fragmentCount;
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "StartIpxSend: %d frag(s), 1: address=%x (%04x:%04x), len=%04x\n",
                READ_WORD(&pEcb->FragmentCount),
                GET_FAR_POINTER(&(ECB_FRAGMENT(pEcb, 0)->Address), IS_PROT_MODE(pXecb)),
                GET_SELECTOR(&(ECB_FRAGMENT(pEcb, 0)->Address)),
                GET_OFFSET(&(ECB_FRAGMENT(pEcb, 0)->Address)),
                READ_WORD(&(ECB_FRAGMENT(pEcb, 0)->Length))
                ));

    //
    // mark the ECB as being used by IPX (for send)
    //

    pEcb->InUse = ECB_IU_SENDING;

    //
    // the total send buffer size cannot exceed the maximum packet size
    //

    fragmentCount = (int)pEcb->FragmentCount;

    ASSERT(fragmentCount);

    pFragment = (LPFRAGMENT)&(ECB_FRAGMENT(pEcb, 0)->Address);
    while (fragmentCount--) {
        packetLength += pFragment->Length;
        ++pFragment;
    }
    if (packetLength <= MyMaxPacketSize) {
        success = GetIoBuffer(pXecb, TRUE, IPX_HEADER_LENGTH);
        if (success) {

            LPIPX_PACKET pPacket = (LPIPX_PACKET)GET_FAR_POINTER(
                                            &(ECB_FRAGMENT(pEcb, 0)->Address),
                                            IS_PROT_MODE(pXecb)
                                            );

            //
            // fill in the following fields in the IPX header:
            //
            //  Checksum
            //  Length
            //  TransportControl
            //  Source (network, node, socket)
            //
            //  Does real IPX modify these fields in app memory?
            //  If so, does the app expect modified fields?
            //  If not, we need to always copy then modify memory,
            //  even if only 1 fragment
            //

            pPacket->Checksum = 0xFFFF;
            pPacket->Length = L2BW((WORD)packetLength);
            pPacket->TransportControl = 0;
            CopyMemory((LPBYTE)&pPacket->Source,
                       &MyInternetAddress.sa_netnum,
                       sizeof(MyInternetAddress.sa_netnum)
                       + sizeof(MyInternetAddress.sa_nodenum)
                       );
            pPacket->Source.Socket = pSocketInfo->SocketNumber;

            //
            // if we allocated a buffer then there is >1 fragment. Collect them
            //

            if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
                GatherData(pXecb, IPX_HEADER_LENGTH);
            }

            //
            // initiate the send. IPX_ECB_BUFFER32(pEcb) points to the data to send,
            // IPX_ECB_LENGTH32(pEcb) is the size of data to send
            //

            IpxSendFirst(pXecb, pSocketInfo);
        } else {

            //
            // couldn't allocate a buffer? Comes under the heading of
            // hardware error?
            //

            CompleteEcb(pXecb, ECB_CC_HARDWARE_ERROR);
            if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
                KillSocket(pSocketInfo);
            }
        }
    } else {

        //
        // packet larger than MyMaxPacketSize
        //

        CompleteOrQueueEcb(pXecb, ECB_CC_BAD_REQUEST);
        if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
            KillSocket(pSocketInfo);
        }
    }
}


BOOL
GetIoBuffer(
    IN OUT LPXECB pXecb,
    IN BOOL Send,
    IN WORD HeaderLength
    )

/*++

Routine Description:

    Allocate a buffer based on the ECB fragment list. If there is only 1 fragment
    we use the address of the buffer in the VDM. If >1 fragment, we allocate a
    32-bit buffer large enough to hold all the 16-bit fragments

    We trim the buffer requirement for a send buffer: we do not send the IPX/SPX
    header with the data: it will be provided by the transport

    Assumes:    1. If called for a send buffer, the first fragment has already
                   been verified as >= HeaderLength

Arguments:

    pXecb           - pointer to XECB which points to IPX_ECB containing fragment
                      list to allocate buffer for
    Send            - TRUE if this request is to get a send buffer
    HeaderLength    - length of the (untransmitted) header portion

Return Value:

    BOOL
        TRUE    - Buffer allocated, XECB updated with address, length and flags
        FALSE   - either ECB contains bad fragment descriptor list or we
                  couldn't allocate a buffer

--*/

{
    WORD fragmentCount;
    WORD bufferLength = 0;
    LPBYTE bufferPointer = NULL;
    WORD flags = 0;
    int i;
    int fragIndex = 0;  // index of fragment address to use if no allocation required
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    fragmentCount = READ_WORD(&pEcb->FragmentCount);

    for (i = 0; i < (int)fragmentCount; ++i) {
        bufferLength += ECB_FRAGMENT(pEcb, i)->Length;
    }
    if (bufferLength) {

        //
        // exclude the IPX header from send buffer. If the first send fragment
        // contains only the IPX header, reduce the fragment count by 1
        //

        if (Send) {
            bufferLength -= HeaderLength;
            if (ECB_FRAGMENT(pEcb, 0)->Length == HeaderLength) {
                --fragmentCount;
                fragIndex = 1;
            }
        }
        if (bufferLength) {
            if (fragmentCount > 1) {
                bufferPointer = AllocateBuffer(bufferLength);
                if (bufferPointer) {
                    flags = XECB_FLAG_BUFFER_ALLOCATED;
                } else {

                    //
                    // need a buffer; failed to allocate it
                    //

                    return FALSE;
                }
            } else {

                //
                // fragmentCount must be 1 (else bufferLength would be 0)
                //

                bufferPointer = GET_FAR_POINTER(
                                    &ECB_FRAGMENT(pEcb, fragIndex)->Address,
                                    IS_PROT_MODE(pXecb)
                                    );
                if (Send && !fragIndex) {

                    //
                    // if we are allocating a send buffer AND there is only 1
                    // fragment AND it is the first fragment then the one and
                    // only fragment must contain the IPX header and the data.
                    // Advance the data pointer past the IPX header
                    //

                    bufferPointer += HeaderLength;
                }
            }
        } else {

            //
            // sending 0 bytes!!!
            //

        }
    } else {

        //
        // fragments but no buffer length? Sounds like a malformed packet
        //

        return FALSE;
    }

    //
    // bufferPointer is either the address of a buffer in 32-bit memory which
    // must be gather/scattered when the I/O operation completes, or it is the
    // address of a single fragment buffer in 16-bit memory. In the former case
    // flags is ECB_ALLOCATE_32 and the latter 0
    //

    pXecb->Buffer = pXecb->Data = bufferPointer;
    pXecb->Length = bufferLength;
    pXecb->Flags |= flags;
    return TRUE;
}


PRIVATE
VOID
ReleaseIoBuffer(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Deallocates I/O buffer attached to XECB and zaps associated XECB fields

Arguments:

    pXecb   - pointer to XECB owning buffer to be released

Return Value:

    None.

--*/

{
    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
        DeallocateBuffer(pXecb->Buffer);
        pXecb->Buffer = pXecb->Data = NULL;
        pXecb->Flags &= ~XECB_FLAG_BUFFER_ALLOCATED;
    }
}


VOID
GatherData(
    IN LPXECB pXecb,
    IN WORD HeaderLength
    )

/*++

Routine Description:

    Copies data from fragmented 16-bit memory into single 32-bit memory buffer.
    Used to send data. We exclude the IPX header: this information is supplied
    by the transport

    Assumes:    1. The fragment descriptor list has been verified: we know that
                   the first fragment contains at least the IPX header

Arguments:

    pXecb           - pointer to XECB structure. The following IPX_ECB and XECB
                      fields must contain coherent values:

                        IPX_ECB.FragmentCount
                        XECB.Buffer

    HeaderLength    - length of the (untransmitted) header portion

Return Value:

    None.

--*/

{
    int fragmentCount;
    WORD length;
    ULPBYTE pData16;
    ULPBYTE pData32;
    LPFRAGMENT pFragment;
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    fragmentCount = (int)pEcb->FragmentCount;
    pFragment = (LPFRAGMENT)&(ECB_FRAGMENT(pEcb, 0)->Address);
    pData32 = pXecb->Buffer;

    //
    // if the 1st fragment contains more than the IPX/SPX header, copy the data
    // after the header
    //

    if (pFragment->Length > HeaderLength) {

        LPBYTE fragAddr = GET_FAR_POINTER(&pFragment->Address,
                                          IS_PROT_MODE(pXecb)
                                          );

        length = pFragment->Length - HeaderLength;
        CopyMemory((LPVOID)pData32,
                   fragAddr + HeaderLength,
                   length
                   );
        pData32 += length;
    }

    //
    // copy subsequent fragments
    //

    ++pFragment;
    while (--fragmentCount) {
        pData16 = GET_FAR_POINTER(&pFragment->Address, IS_PROT_MODE(pXecb));
        if (pData16 == NULL) {
            break;
        }
        length = pFragment->Length;
        CopyMemory((PVOID)pData32, (CONST VOID*)pData16, (ULONG)length);
        pData32 += length;
        ++pFragment;
    }
}


VOID
ScatterData(
    IN LPXECB pXecb
    )

/*++

Routine Description:

    Copies data from 32-bit memory to 16-bit. The data must be fragmented if
    this function has been called (i.e. we determined there were >1 fragments
    and allocated a single 32-bit buffer to cover them)

Arguments:

    pXecb   - pointer to XECB containing 32-bit buffer info

Return Value:

    None.

--*/

{
    int fragmentCount;
    int length;
    WORD length16;
    WORD length32;
    ULPBYTE pData16;
    ULPBYTE pData32;
    LPFRAGMENT pFragment;
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    fragmentCount = (int)pEcb->FragmentCount;
    pFragment = (LPFRAGMENT)&(ECB_FRAGMENT(pEcb, 0)->Address);
    pData32 = pXecb->Buffer;
    length32 = pXecb->Length;
    while (length32) {
        pData16 = GET_FAR_POINTER(&pFragment->Address, IS_PROT_MODE(pXecb));
        if (pData16 == NULL) {
            break;
        }

        length16 = pFragment->Length;
        length = min(length16, length32);
        CopyMemory((PVOID)pData16, (CONST VOID*)pData32, (ULONG)length);
        pData32 += length;
        length32 -= (WORD) length;
        ++pFragment;
        --fragmentCount;

        ASSERT(fragmentCount >= 0);

    }
}


VOID
IpxReceiveFirst(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Performs a receive against a non-blocking socket. This is the first
    receive call for this ECB. If the receive completes immediately with data
    or an error that isn't WSAEWOULDBLOCK then the ECB is completed. If the
    receives completes with a WSAEWOULDBLOCK error then the request is queued
    for deferred processing by the AES thread

    Unlike send, receives are not serialized. If there are already receives
    pending against the socket there could be a clash between this function
    and IpxReceiveNext(), called from the AES thread. In this case, we expect
    Winsock to do the right thing and serialize the callers

Arguments:

    pXecb           - pointer to XECB describing receive ECB
    pSocketInfo     - pointer to socket structure

Return Value:

    None.

--*/

{
    SOCKADDR_IPX from;
    int fromLen = sizeof(from);
    int rc;
    BYTE status;
    BOOL error;

    rc = recvfrom(pSocketInfo->Socket,
                  (char FAR*)pXecb->Buffer,
                  (int)pXecb->Length,
                  0,    // flags
                  (LPSOCKADDR)&from,
                  &fromLen
                  );
    if (rc != SOCKET_ERROR) {
        error = FALSE;
        status = ECB_CC_SUCCESS;
    } else {
        error = TRUE;
        rc = WSAGetLastError();
        if (rc == WSAEWOULDBLOCK) {
            RequestMutex();
            QueueReceiveRequest(pXecb, pSocketInfo);
            ReleaseMutex();
        } else if (rc == WSAEMSGSIZE) {
            error = FALSE;
            status = ECB_CC_BAD_REQUEST;
            rc = pXecb->Length;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "IpxReceiveFirst: recvfrom() returns %d (buflen=%d)\n",
                        rc,
                        pXecb->Length
                        ));

            CompleteOrQueueIo(pXecb, ECB_CC_BAD_REQUEST);
        }
    }
    if (!error) {

        //
        // rc = bytes received, or 0 = connection terminated (even for DGRAM?)
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "IpxReceiveFirst: bytes received = %d (%x)\n",
                    rc,
                    rc
                    ));
/*
        VwDumpEcb(pXecb->Ecb,
                  HIWORD(pXecb->EcbAddress),
                  LOWORD(pXecb->EcbAddress),
                  FALSE,
                  TRUE,
                  TRUE,
                  IS_PROT_MODE(pXecb)
                  );
*/

        IPXDUMPDATA((pXecb->Buffer, 0, 0, FALSE, (WORD)rc));

        //
        // if the receive buffers are fragmented, copy the data to 16-bit memory
        // (else single buffer: its already there (dude))
        //

        if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {

            //
            // update the ECB_LENGTH32 field to reflect the amount of data received
            //

            pXecb->Length = (WORD)rc;
            ScatterData(pXecb);

            //
            // we have finished with the 32-bit buffer: deallocate it
            //

            ReleaseIoBuffer(pXecb);
        }

        //
        // update the ImmediateAddress field in the ECB with the node address
        // of the sender
        //

        CopyMemory(pXecb->Ecb->ImmediateAddress, from.sa_nodenum, sizeof(from.sa_nodenum));

        //
        // if this ECB has a non-NULL ESR then queue for asynchronous completion
        // else complete immediately (app must poll InUse field)
        //

        CompleteOrQueueEcb(pXecb, status);
    }
}


VOID
IpxReceiveNext(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Attempts to complete an IPXListenForPacket request that has been deferred due
    to the fact the socket was blocked.

    The ECB containing all the receive information is at the head of the
    ListenQueue on pSocketInfo

    We can use any queued listen ECB, but it just so happens we use the one at
    the head of the FIFO

    Note: SerializationCritSec is held when this function is called.

Arguments:

    pSocketInfo - pointer to SOCKET_INFO structure with pending IPX send request

Return Value:

    None.

--*/

{
    LPXECB pXecb;
    SOCKADDR_IPX from;
    int fromLen = sizeof(from);
    int rc;
    BYTE status;
    BOOL error;

    ASSERT(pSocketInfo);

    pXecb = (LPXECB)pSocketInfo->ListenQueue.Head;

    ASSERT(pXecb);

    rc = recvfrom(pSocketInfo->Socket,
                  (char FAR*)pXecb->Buffer,
                  (int)pXecb->Length,
                  0,    // flags
                  (LPSOCKADDR)&from,
                  &fromLen
                  );
    if (rc != SOCKET_ERROR) {
        error = FALSE;
        status = ECB_CC_SUCCESS;
    } else {
        error = TRUE;
        rc = WSAGetLastError();
        if (rc == WSAEMSGSIZE) {
            error = FALSE;
            status = ECB_CC_BAD_REQUEST;
            rc = pXecb->Length;
        } else if (rc != WSAEWOULDBLOCK) {
            DequeueReceiveRequest(pXecb, pSocketInfo);

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "IpxReceiveNext: recvfrom() returns %d\n",
                        rc
                        ));

            CompleteOrQueueIo(pXecb, ECB_CC_CANCELLED);
        }
    }
    if (!error) {
/*
        VwDumpEcb(pXecb->Ecb,
                  HIWORD(pXecb->EcbAddress),
                  LOWORD(pXecb->EcbAddress),
                  FALSE,
                  TRUE,
                  TRUE,
                  IS_PROT_MODE(pXecb)
                  );
*/
        //
        // data received. Remove ECB from queue
        //

        DequeueReceiveRequest(pXecb, pSocketInfo);

        //
        // rc = bytes received, or 0 = connection terminated (even for DGRAM?)
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "IpxReceiveNext: ECB %04x:%04x bytes received = %d (%x)\n",
                    HIWORD(pXecb->EcbAddress),
                    LOWORD(pXecb->EcbAddress),
                    rc,
                    rc
                    ));

        IPXDUMPDATA((pXecb->Buffer, 0, 0, FALSE, (WORD)rc));

        //
        // if the receive buffers are fragmented, copy the data to 16-bit memory
        // (else single buffer: its already there (dude))
        //

        if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {

            //
            // update the IPX_ECB_LENGTH32 field to reflect the amount of data received
            //

            pXecb->Length = (WORD)rc;
            ScatterData(pXecb);
            ReleaseIoBuffer(pXecb);
        }

        //
        // update the ImmediateAddress field in the ECB with the node address
        // of the sender
        //

        CopyMemory(pXecb->Ecb->ImmediateAddress,
                   from.sa_nodenum,
                   sizeof(from.sa_nodenum)
                   );

        //
        // if this ECB has a non-NULL ESR then queue for asynchronous completion
        // else complete immediately (app must poll InUse field)
        //

        CompleteOrQueueEcb(pXecb, ECB_CC_SUCCESS);
    }
}


PRIVATE
VOID
IpxSendFirst(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Tries to send an IPX packet. This is the first attempt to send the packet
    described in the ECB. If the send succeeds or fails with an error other
    than WSAEWOULDBLOCK we complete the ECB. If the send attempt fails because
    the transport can't accept the request at this time, we queue it for later
    when the AES thread will attempt to send it.

    If there is already a send being attempted then we just queue this request
    and let AES handle it in IpxSendNext()

Arguments:

    pXecb       - pointer to XECB
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    None.

--*/

{
    RequestMutex();
    if (pSocketInfo->Flags & SOCKET_FLAG_SENDING) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "IpxSendFirst: queueing ECB %04x:%04x\n",
                    HIWORD(pXecb->EcbAddress),
                    LOWORD(pXecb->EcbAddress)
                    ));

        QueueSendRequest(pXecb, pSocketInfo);
    } else {

        SOCKADDR_IPX to;
        LPIPX_PACKET pPacket;
        int length;
        int rc;
        LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;
        int type;
/*
        VwDumpEcb(pXecb->Ecb,
                  HIWORD(pXecb->EcbAddress),
                  LOWORD(pXecb->EcbAddress),
                  FALSE,
                  TRUE,
                  TRUE,
                  IS_PROT_MODE(pXecb)
                  );
*/
        length = (int)pXecb->Length;

        //
        // the first fragment holds the destination address info
        //

        pPacket = (LPIPX_PACKET)GET_FAR_POINTER(&ECB_FRAGMENT(pEcb, 0)->Address,
                                                IS_PROT_MODE(pXecb)
                                                );
        to.sa_family = AF_IPX;

        //
        // copy the destination net number as a DWORD (4 bytes) from the
        // destination network address structure in the IPX packet header
        //

        *(ULPDWORD)&to.sa_netnum[0] = *(ULPDWORD)&pPacket->Destination.Net[0];
        //
        // copy the immediate (destination) node number as a DWORD (4 bytes) and
        // a WORD (2 bytes) from the Destination network address structure in
        // the IPX packet header. pPacket is an unaligned pointer, so we are
        // safe
        //

        *(ULPDWORD)&to.sa_nodenum[0] = *(ULPDWORD)&pPacket->Destination.Node[0];

        *(LPWORD)&to.sa_nodenum[4] = *(ULPWORD)&pPacket->Destination.Node[4];

        //
        // copy the destination socket number from the IPX packet header as a
        // WORD (2 bytes). Again, the aligned pointer will save us
        //

        to.sa_socket = pPacket->Destination.Socket;

        type = (int)pPacket->PacketType;
        rc = setsockopt(pSocketInfo->Socket,
                        NSPROTO_IPX,
                        IPX_PTYPE,
                        (char FAR*)&type,
                        sizeof(type)
                        );
        if (rc) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "IpxSendFirst: setsockopt(IPX_PTYPE) returns %d\n",
                        WSAGetLastError()
                        ));

        }
        rc = sendto(pSocketInfo->Socket,
                    (char FAR*)pXecb->Buffer,
                    length,
                    0,  // flags
                    (LPSOCKADDR)&to,
                    sizeof(to)
                    );
        if (rc == length) {

            //
            // all data sent
            //

            IPXDUMPDATA((pXecb->Buffer, 0, 0, FALSE, (WORD)rc));

            CompleteOrQueueIo(pXecb, ECB_CC_SUCCESS);
            if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
                KillSocket(pSocketInfo);
            }
        } else if (rc == SOCKET_ERROR) {
            rc = WSAGetLastError();
            if (rc == WSAEWOULDBLOCK) {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_INFO,
                            "IpxSendFirst: queueing ECB %04x:%04x (after sendto)\n",
                            HIWORD(pXecb->EcbAddress),
                            LOWORD(pXecb->EcbAddress)
                            ));

                QueueSendRequest(pXecb, pSocketInfo);
            } else {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_ANY,
                            IPXDBG_LEVEL_ERROR,
                            "IpxSendFirst: sendto() returns %d\n",
                            rc
                            ));

                CompleteIo(pXecb, ECB_CC_UNDELIVERABLE);
                if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
                    KillSocket(pSocketInfo);
                }
            }
        } else {

            //
            // send should send all the data or return an error
            //

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "IpxSendFirst: sendto() returns unexpected %d (length = %d)\n",
                        rc,
                        length
                        ));
        }
    }
    ReleaseMutex();
}


VOID
IpxSendNext(
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Attempts to complete an IPXSendPacket request that has been deferred due
    to the fact the socket was blocked.

    The ECB containing all the send information is at the head of the SendQueue
    on pSocketInfo

    The SendQueue is serialized in FIFO order

    Note: SerializationCritSec is held when this function is called.

Arguments:

    pSocketInfo - pointer to SOCKET_INFO structure with pending IPX send request

Return Value:

    None.

--*/

{
    SOCKADDR_IPX to;
    LPIPX_PACKET pPacket;
    int length;
    int rc;
    LPXECB pXecb;
    LPIPX_ECB pEcb;
    int type;

    pXecb = (LPXECB)pSocketInfo->SendQueue.Head;
    pEcb = (LPIPX_ECB)pXecb->Ecb;

    ASSERT(pXecb);
    ASSERT(pEcb);
/*
    VwDumpEcb(pXecb->Ecb,
              HIWORD(pXecb->EcbAddress),
              LOWORD(pXecb->EcbAddress),
              FALSE,
              TRUE,
              TRUE,
              IS_PROT_MODE(pXecb)
              );
*/
    length = (int)pXecb->Length;

    //
    // even though we have a 32-bit pointer to the IPX packet buffer which
    // may be in 16- or 32-bit memory, we still need unaligned access
    //

    pPacket = (LPIPX_PACKET)pXecb->Buffer;
    to.sa_family = AF_IPX;

    //
    // copy the destination net number as a DWORD (4 bytes) from the
    // destination network address structure in the IPX packet header
    //

    *(ULPDWORD)&to.sa_netnum[0] = *(ULPDWORD)&pPacket->Destination.Net[0];
    //
    // copy the immediate (destination) node number as a DWORD (4 bytes) and
    // a WORD (2 bytes) from the Destination network address structure in
    // the IPX packet header. pPacket is an unaligned pointer, so we are
    // safe
    //

    *(ULPDWORD)&to.sa_nodenum[0] = *(ULPDWORD)&pPacket->Destination.Node[0];
    *(LPWORD)&to.sa_nodenum[4] = *(ULPWORD)&pPacket->Destination.Node[4];

    //
    // copy the destination socket number from the IPX packet header as a
    // WORD (2 bytes). Again, the aligned pointer will save us
    //

    to.sa_socket = pPacket->Destination.Socket;

    type = (int)pPacket->PacketType;
    rc = setsockopt(pSocketInfo->Socket,
                    NSPROTO_IPX,
                    IPX_PTYPE,
                    (char FAR*)&type,
                    sizeof(type)
                    );
    if (rc) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "IpxSendNext: setsockopt(IPX_PTYPE) returns %d\n",
                    WSAGetLastError()
                    ));

    }
    rc = sendto(pSocketInfo->Socket,
                (char FAR*)pPacket,
                length,
                0,  // flags
                (LPSOCKADDR)&to,
                sizeof(to)
                );
    if (rc == length) {

        //
        // all data sent - dequeue it
        //


        IPXDUMPDATA((pXecb->Buffer, 0, 0, FALSE, (WORD)rc));

        DequeueEcb(pXecb, &pSocketInfo->SendQueue);
        if (pXecb->EsrAddress) {
            if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
                ReleaseIoBuffer(pXecb);
            }
            QueueAsyncCompletion(pXecb, ECB_CC_SUCCESS);
        } else {
            CompleteIo(pXecb, ECB_CC_SUCCESS);
        }
        if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
            KillSocket(pSocketInfo);
        }
    } else if (rc == SOCKET_ERROR) {

        //
        // if the socket is still blocked, there's nothing to do - just leave
        // the request hanging around till next time
        //

        rc = WSAGetLastError();
        if (rc != WSAEWOULDBLOCK) {
            DequeueSendRequest(pXecb, pSocketInfo);

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "IpxSendNext: sendto() returns %d\n",
                        rc
                        ));

            CompleteIo(pXecb, ECB_CC_UNDELIVERABLE);
            if (pSocketInfo->Flags & SOCKET_FLAG_TEMPORARY) {
                KillSocket(pSocketInfo);
            }
        }
    } else {

        //
        // send should send all the data or return an error
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_FATAL,
                    "IpxSendNext: sendto() returns unexpected %d (length = %d)\n",
                    rc,
                    length
                    ));
    }
}


PRIVATE
VOID
QueueReceiveRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Add a listen XECB to queue of listen XECBs on a SOCKET_INFO structure

Arguments:

    pXecb       - pointer to listen XECB to queue
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    None.

--*/

{
    QueueEcb(pXecb, &pSocketInfo->ListenQueue, SOCKET_LISTEN_QUEUE);
    ++pSocketInfo->PendingListens;
    pSocketInfo->Flags |= SOCKET_FLAG_LISTENING;
}


PRIVATE
LPXECB
DequeueReceiveRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Remove a listen XECB from queue of listen XECBs on a SOCKET_INFO structure

Arguments:

    pXecb       - pointer to listen XECB to dequeue
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    LPXECB

--*/

{
    LPXECB ptr;

    ptr = (LPXECB)DequeueEcb(pXecb, &pSocketInfo->ListenQueue);
    if (ptr) {

        ASSERT(ptr == pXecb);

        --pSocketInfo->PendingListens;
        if (!pSocketInfo->PendingListens) {
            pSocketInfo->Flags &= ~SOCKET_FLAG_LISTENING;
        }

        pXecb->Ecb->InUse = ECB_IU_AWAITING_PROCESSING;
    }
    return ptr;
}


PRIVATE
VOID
QueueSendRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Add a send XECB to queue of send XECBs on a SOCKET_INFO structure

Arguments:

    pXecb       - pointer to send XECB to queue
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    None.

--*/

{
    QueueEcb(pXecb, &pSocketInfo->SendQueue, SOCKET_SEND_QUEUE);
    ++pSocketInfo->PendingSends;
    pSocketInfo->Flags |= SOCKET_FLAG_SENDING;
    pXecb->Ecb->InUse = ECB_IU_SEND_QUEUED;
}


PRIVATE
LPXECB
DequeueSendRequest(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    )

/*++

Routine Description:

    Remove a send XECB from queue of send XECBs on a SOCKET_INFO structure

Arguments:

    pXecb       - pointer to send XECB to dequeue
    pSocketInfo - pointer to SOCKET_INFO structure

Return Value:

    LPXECB

--*/

{
    LPXECB ptr;

    ptr = (LPXECB)DequeueEcb(pXecb, &pSocketInfo->SendQueue);
    if (ptr) {

        ASSERT(ptr == pXecb);

        --pSocketInfo->PendingSends;
        if (!pSocketInfo->PendingSends) {
            pSocketInfo->Flags &= ~SOCKET_FLAG_SENDING;
        }
        pXecb->Ecb->InUse = ECB_IU_AWAITING_PROCESSING;
    }
    return ptr;
}


VOID
CompleteOrQueueIo(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Returns any allocated buffer resource then completes or queues the ECB

Arguments:

    pXecb           - pointer to XECB structure
    CompletionCode  - value to put in CompletionCode field

Return Value:

    None.

--*/

{
    //
    // if we allocated a buffer, free it
    //

    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
        ReleaseIoBuffer(pXecb);
    }
    CompleteOrQueueEcb(pXecb, CompletionCode);
}


VOID
CompleteIo(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Completes a send/receive request by returning any allocated buffer resource
    and setting the ECB InUse and CompletionCode fields

Arguments:

    pXecb           - pointer to XECB structure
    CompletionCode  - value to put in CompletionCode field

Return Value:

    None.

--*/

{
    //
    // if we allocated a buffer, free it
    //

    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
        ReleaseIoBuffer(pXecb);
    }
    CompleteEcb(pXecb, CompletionCode);
}


VOID
CompleteOrQueueEcb(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Queues an XECB for completion by ESR or completes it now

Arguments:

    pXecb           - pointer to XECB describing ECB to complete
    CompletionCode  - value to put in ECB CompletionCode field

Return Value:

    None.

--*/

{
    if (pXecb->EsrAddress) {
        QueueAsyncCompletion(pXecb, CompletionCode);
    } else {
        CompleteIo(pXecb, CompletionCode);
    }
}


VOID
CompleteEcb(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Sets the CompletionCode field in the ECB and sets the InUse field to 0.
    Deallocates the XECB structure

Arguments:

    pXecb           - pointer to XECB describing ECB in 16-bit memory to update
    CompletionCode  - value to put in CompletionCode field

Return Value:

    None.

--*/

{
    LPIPX_ECB pEcb = (LPIPX_ECB)pXecb->Ecb;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "CompleteEcb: completing ECB @%04x:%04x w/ %02x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                CompletionCode
                ));

    //
    // if this is really an AES ECB then CompletionCode is actually the first
    // byte of the AES workspace. It shouldn't matter that we write into this
    // field - we are supposed to own it
    //

    pEcb->CompletionCode = CompletionCode;
    pEcb->InUse = ECB_IU_NOT_IN_USE;

    //
    // reset the LinkAddress field. This means we have completed the ECB
    //

    pEcb->LinkAddress = NULL;

    //
    // finally, deallocate the XECB. This mustn't have any allocated resources
    // (like a buffer)
    //

    DeallocateXecb(pXecb);
}


PRIVATE
VOID
QueueAsyncCompletion(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    )

/*++

Routine Description:

    Add an XECB to the (serialized) async completion queue and raise a simulated
    hardware interrupt in the VDM.

    The interrupt will cause the VDM to start executing at the ISR in the TSR
    which will call-back to find the address for the ESR, then execute it

Arguments:

    pXecb           - pointer to XECB describing IPX or AES ECB to add to async
                      completion list
    CompletionCode  - the ECB in VDM memory will be updated with this completion
                      code

Return Value:

    None.

--*/

{

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "QueueAsyncCompletion: completing ECB @%04x:%04x w/ %02x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                CompletionCode
                ));

    pXecb->Ecb->CompletionCode = CompletionCode;
    pXecb->QueueId = ASYNC_COMPLETION_QUEUE;
    EnterCriticalSection(&AsyncCritSec);
    FifoAdd(&AsyncCompletionQueue, (LPFIFO)pXecb);
    LeaveCriticalSection(&AsyncCritSec);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "QueueAsyncCompletion: ECB @ %04x:%04x ESR @ %04x:%04x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                HIWORD(pXecb->EsrAddress),
                LOWORD(pXecb->EsrAddress)
                ));

    VDDSimulateInterrupt(Ica, IcaLine, 1);
}


VOID
EsrCallback(
    VOID
    )

/*++

Routine Description:

    Callback function from within 16-bit TSR ESR function. Returns the address
    of the next completed ECB in ES:SI

    Any allocated resources (e.g. 32-bit buffer) must have been freed by the
    time the ESR callback happens

Arguments:

    None.

Return Value:

    None.

--*/

{
    WORD segment = 0;
    WORD offset = 0;
    BYTE flags = 0;

    VWinEsrCallback( &segment, &offset, &flags );

    setES(segment);
    setSI(offset);
    setAL(flags);
}


VOID
VWinEsrCallback(
    WORD *pSegment,
    WORD *pOffset,
    BYTE *pFlags
    )

/*++

Routine Description:

    Callback function from within 16-bit function. Returns the address
    of the next completed ECB

    Any allocated resources (e.g. 32-bit buffer) must have been freed by the
    time the ESR callback happens

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPXECB pXecb;

    EnterCriticalSection(&AsyncCritSec);
    pXecb = AsyncCompletionQueue.Head;
    if (pXecb) {

        WORD msw = getMSW();

        if ((msw & MSW_PE) ^ IS_PROT_MODE(pXecb)) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "EsrCallback: ECB @ %04x:%04x NOT for this proc mode (%d)\n",
                        HIWORD(pXecb->EcbAddress),
                        LOWORD(pXecb->EcbAddress),
                        msw & MSW_PE
                        ));

            pXecb = NULL;
        } else {
            pXecb = (LPXECB)FifoNext(&AsyncCompletionQueue);
        }
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_FATAL,
                    "EsrCallback: no ECBs on AsyncCompletionQueue!\n"
                    ));

    }
    LeaveCriticalSection(&AsyncCritSec);

    if (pXecb) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_INFO,
                    "EsrCallback: ECB @ %04x:%04x ESR @ %04x:%04x\n",
                    HIWORD(pXecb->EcbAddress),
                    LOWORD(pXecb->EcbAddress),
                    HIWORD(pXecb->EsrAddress),
                    LOWORD(pXecb->EsrAddress)
                    ));

        *pSegment = HIWORD(pXecb->EcbAddress);
        *pOffset  = LOWORD(pXecb->EcbAddress);
        pXecb->Ecb->LinkAddress = NULL;
        pXecb->Ecb->InUse = ECB_IU_NOT_IN_USE;
        *pFlags = (BYTE)((pXecb->Flags & XECB_FLAG_IPX) ? ECB_TYPE_IPX : ECB_TYPE_AES);
        DeallocateXecb(pXecb);
        setCF(0);
    } else {
        setCF(1);
    }
}


VOID
FifoAddHead(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    )

/*++

Routine Description:

    Adds an element to the head of a (single-linked) FIFO list

Arguments:

    pFifo       - pointer to FIFO structure
    pElement    - pointer to (FIFO) element to add to list

Return Value:

    None.

--*/

{
    if (!pFifo->Head) {
        pFifo->Head = pFifo->Tail = pElement;
        pElement->Head = NULL;
    } else {
        pElement->Head = pFifo->Head;
        pFifo->Head = pElement;
    }
}

VOID
FifoAdd(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    )

/*++

Routine Description:

    Adds an element to the tail of a (single-linked) FIFO list

Arguments:

    pFifo       - pointer to FIFO structure
    pElement    - pointer to (FIFO) element to add to list

Return Value:

    None.

--*/

{
    if (!pFifo->Head) {
        pFifo->Head = pFifo->Tail = pElement;
    } else {
        ((LPFIFO)pFifo->Tail)->Head = pElement;
    }
    pFifo->Tail = pElement;
    pElement->Head = NULL;
}


LPFIFO
FifoRemove(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    )

/*++

Routine Description:

    Removes an element from a (single-linked) FIFO list

Arguments:

    pFifo       - pointer to FIFO structure
    pElement    - pointer to (FIFO) element to remove (single-linked)

Return Value:

    PFIFO
        NULL - pElement not on list
        !NULL - pElement removed from list

--*/

{
    LPFIFO p;
    LPFIFO prev = (LPFIFO)pFifo;

    p = (LPFIFO)pFifo->Head;
    while (p && (p != pElement)) {
        prev = p;
        p = p->Head;
    }
    if (p) {
        prev->Head = p->Head;
        if (pFifo->Head == NULL) {
            pFifo->Tail = NULL;
        } else if (pFifo->Tail == p) {
            pFifo->Tail = prev;
        }
    }
    return p;
}


LPFIFO
FifoNext(
    IN LPFIFO pFifo
    )

/*++

Routine Description:

    Remove element at head of FIFO queue

Arguments:

    pFifo   - pointer to FIFO

Return Value:

    LPFIFO
        NULL - nothing on queue
        !NULL - removed element

--*/

{
    LPFIFO p;
    LPFIFO prev = (LPFIFO)pFifo;

    p = (LPFIFO)pFifo->Head;
    if (p) {
        pFifo->Head = p->Head;
        if (!pFifo->Head) {
            pFifo->Tail = NULL;
        }
    }
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\util.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Contains macros, prototypes and structures for util.c

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

//
// external data
//

extern CRITICAL_SECTION SerializationCritSec;

//
// one-line function macros
//

#define RequestMutex()  EnterCriticalSection(&SerializationCritSec)
#define ReleaseMutex()  LeaveCriticalSection(&SerializationCritSec)

//
// function prototypes
//

int
GetInternetAddress(
    IN OUT LPSOCKADDR_IPX InternetAddress
    );

int
GetMaxPacketSize(
    OUT LPWORD MaxPacketSize
    );

LPXECB
RetrieveEcb(
    IN BYTE Type
    );

LPXECB
RetrieveXEcb(
    IN BYTE  Type,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
ScheduleEvent(
    IN LPXECB pXecb,
    IN WORD Ticks
    );

VOID
ScanTimerList(
    VOID
    );

BYTE
CancelTimerEvent(
    IN LPXECB pXecb
    );

VOID
CancelTimedEvents(
    IN WORD SocketNumber,
    IN WORD Owner,
    IN DWORD TaskId
    );

BYTE
CancelAsyncEvent(
    IN LPXECB pXecb
    );

BYTE
CancelSocketEvent(
    IN LPXECB pXecb
    );

BYTE
CancelConnectionEvent(
    IN LPXECB pXecb
    );

VOID
QueueEcb(
    IN LPXECB pXecb,
    IN LPXECB_QUEUE Queue,
    IN QUEUE_ID QueueId
    );

LPXECB
DequeueEcb(
    IN LPXECB pXecb,
    IN LPXECB_QUEUE Queue
    );

VOID
CancelSocketQueue(
    IN LPXECB_QUEUE pXecbQueue
    );

VOID
CancelConnectionQueue(
    IN LPXECB_QUEUE pXecbQueue
    );

VOID
AbortQueue(
    IN LPXECB_QUEUE pXecbQueue,
    IN BYTE CompletionCode
    );

VOID
AbortConnectionEvent(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

VOID
StartIpxSend(
    IN LPXECB pEcb,
    IN LPSOCKET_INFO pSocketInfo
    );

BOOL
GetIoBuffer(
    IN OUT LPXECB pXecb,
    IN BOOL Send,
    IN WORD HeaderLength
    );

VOID
GatherData(
    IN LPXECB pXecb,
    IN WORD HeaderLength
    );

VOID
ScatterData(
    IN LPXECB pXecb
    );

VOID
IpxReceiveFirst(
    IN LPXECB pXecb,
    IN LPSOCKET_INFO pSocketInfo
    );

VOID
IpxReceiveNext(
    IN LPSOCKET_INFO pSocketInfo
    );

VOID
IpxSendNext(
    IN LPSOCKET_INFO pSocketInfo
    );

VOID
CompleteOrQueueIo(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

VOID
CompleteIo(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

VOID
CompleteOrQueueEcb(
    IN LPXECB pXecb,
    IN BYTE CompletionCode
    );

VOID
CompleteEcb(
    IN LPXECB pEcb,
    IN BYTE CompletionCode
    );

VOID
EsrCallback(
    VOID
    );

VOID
VWinEsrCallback(
    WORD *pSegment,
    WORD *pOffset,
    BYTE *pFlags
    );

VOID
FifoAddHead(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    );

VOID
FifoAdd(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    );

LPFIFO
FifoRemove(
    IN LPFIFO pFifo,
    IN LPFIFO pElement
    );

LPFIFO
FifoNext(
    IN LPFIFO pFifo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\svcdlls\nwwks\server\spool.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    spool.c

Abstract:

    This module contains the Netware print provider.

Author:

    Yi-Hsin Sung    (yihsins)   15-May-1993

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <nw.h>
#include <nwreg.h>
#include <nwpkstr.h>
#include <splutil.h>
#include <queue.h>
#include <nwmisc.h>
#include <Accctrl.h>
#include <Aclapi.h>

//------------------------------------------------------------------
//
// Local Definitions
//
//------------------------------------------------------------------

#define NW_SIGNATURE           0x574E       /* "NW" is the signature */

#define SPOOL_STATUS_STARTDOC  0x00000001
#define SPOOL_STATUS_ADDJOB    0x00000002
#define SPOOL_STATUS_ABORT     0x00000003

#define PRINTER_CHANGE_VALID   0x55770F07
#define PRINTER_CHANGE_DEFAULT_TIMEOUT_VALUE  10000
#define PRINTER_CHANGE_MINIMUM_TIMEOUT_VALUE  1000
#define REG_TIMEOUT_PATH       L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters"
#define REG_TIMEOUT_VALUE_NAME L"PrintNotifyTimeout"

#define NDS_MAX_NAME_CHARS 256
#define NDS_MAX_NAME_SIZE  ( NDS_MAX_NAME_CHARS * 2 )

//
// Printer structure
//
typedef struct _NWPRINTER {
    LPWSTR  pszServer;                 // Server Name
    LPWSTR  pszQueue;                  // Queue Name
    LPWSTR  pszUncConnection;          // UNC Connection Name
                                       // (only present if NDS print queue
    DWORD   nQueueId;                  // Queue Id
    struct _NWPRINTER *pNextPrinter;   // Points to the next printer
    struct _NWSPOOL   *pSpoolList;     // Points to the list of open handles
} NWPRINTER, *PNWPRINTER;

//
//  Handle structure
//
typedef struct _NWSPOOL {
    DWORD      nSignature;             // Signature
    DWORD      errOpenPrinter;         // OpenPrinter API will always return
                                       // success on known printers. This will
                                       // contain the error that we get
                                       // if something went wrong in the API.
    PNWPRINTER pPrinter;               // Points to the corresponding printer
    HANDLE     hServer;                // Opened handle to the server
    struct _NWSPOOL  *pNextSpool;      // Points to the next handle
    DWORD      nStatus;                // Status
    DWORD      nJobNumber;             // StartDocPrinter/AddJob: Job Number
    HANDLE     hChangeEvent;           // WaitForPrinterChange: event to wait on
    DWORD      nWaitFlags;             // WaitForPrinterChange: flags to wait on
    DWORD      nChangeFlags;           // Changes that occurred to the printer
} NWSPOOL, *PNWSPOOL;

//------------------------------------------------------------------
//
// Global Variables
//
//------------------------------------------------------------------


// Stores the timeout value used in WaitForPrinterChange ( in milliseconds )
STATIC DWORD NwTimeOutValue = PRINTER_CHANGE_DEFAULT_TIMEOUT_VALUE;

// Points to the link list of printers
STATIC PNWPRINTER NwPrinterList = NULL;

//------------------------------------------------------------------
//
// Local Function Prototypes
//
//------------------------------------------------------------------

VOID
NwSetPrinterChange(
    IN PNWSPOOL pSpool,
    IN DWORD nFlags
);

PNWPRINTER
NwFindPrinterEntry(
    IN LPWSTR pszServer,
    IN LPWSTR pszQueue
);

DWORD
NwCreatePrinterEntry(
    IN LPWSTR pszServer,
    IN LPWSTR pszQueue,
    OUT PNWPRINTER *ppPrinter,
    OUT PHANDLE phServer
);

VOID
NwRemovePrinterEntry(
    IN PNWPRINTER pPrinter
);

LPWSTR
NwGetUncObjectName(
    IN LPWSTR ContainerName
);



VOID
NwInitializePrintProvider(
    VOID
)
/*++

Routine Description:

    This routine initializes the server side print provider when
    the workstation service starts up.

Arguments:

    None.

Return Value:

--*/
{
    DWORD err;
    HKEY  hkey;
    DWORD dwTemp;
    DWORD dwSize = sizeof( dwTemp );

    //
    // Read the time out value from the registry.
    // We will ignore all errors since we can always have a default time out.
    // The default will be used if the key does not exist.
    //
    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                         REG_TIMEOUT_PATH,
                         0,
                         KEY_READ,
                         &hkey );

    if ( !err )
    {
        err = RegQueryValueExW( hkey,
                                REG_TIMEOUT_VALUE_NAME,
                                NULL,
                                NULL,
                                (LPBYTE) &dwTemp,
                                &dwSize );

        if ( !err )
        {
            NwTimeOutValue = dwTemp;

            //
            // tommye - bug 139469 - removed 
            //  if (NwTimeOutValue >= 0) because NwtimeOutValue is a DWORD
            //
            // Use the minimum timeout value if the
            // value set in the registry is too small.
            //

            if (NwTimeOutValue <= PRINTER_CHANGE_MINIMUM_TIMEOUT_VALUE)
            {
                NwTimeOutValue = PRINTER_CHANGE_MINIMUM_TIMEOUT_VALUE;
            }
        }

        RegCloseKey( hkey );
    }

}



VOID
NwTerminatePrintProvider(
    VOID
)
/*++

Routine Description:

    This routine cleans up the server side print provider when
    the workstation service shut downs.

Arguments:

    None.

Return Value:

--*/
{
    PNWPRINTER pPrinter, pNext;
    PNWSPOOL pSpool, pNextSpool;

    for ( pPrinter = NwPrinterList; pPrinter; pPrinter = pNext )
    {
         pNext = pPrinter->pNextPrinter;

         pPrinter->pNextPrinter = NULL;

         for ( pSpool = pPrinter->pSpoolList; pSpool; pSpool = pNextSpool )
         {
              pNextSpool = pSpool->pNextSpool;
              if ( pSpool->hChangeEvent )
                  CloseHandle( pSpool->hChangeEvent );
              (VOID) NtClose( pSpool->hServer );

              //
              // Free all memory associated with the context handle
              //
              FreeNwSplMem( pSpool, sizeof( NWSPOOL) );
         }

         pPrinter->pSpoolList = NULL;
         FreeNwSplStr( pPrinter->pszServer );
         FreeNwSplStr( pPrinter->pszQueue );
         if ( pPrinter->pszUncConnection )
         {
             (void) NwrDeleteConnection( NULL,
                                         pPrinter->pszUncConnection,
                                         FALSE );
             FreeNwSplStr( pPrinter->pszUncConnection );
         }
         FreeNwSplMem( pPrinter, sizeof( NWPRINTER));
    }

    NwPrinterList = NULL;
    NwTimeOutValue = PRINTER_CHANGE_DEFAULT_TIMEOUT_VALUE;
}



DWORD
NwrOpenPrinter(
    IN LPWSTR Reserved,
    IN LPWSTR pszPrinterName,
    IN DWORD  fKnownPrinter,
    OUT LPNWWKSTA_PRINTER_CONTEXT phPrinter
)
/*++

Routine Description:

    This routine retrieves a handle identifying the specified printer.

Arguments:

    Reserved       -  Unused
    pszPrinterName -  Name of the printer
    fKnownPrinter  -  TRUE if we have successfully opened the printer before,
                      FALSE otherwise.
    phPrinter      -  Receives the handle that identifies the given printer

Return Value:


--*/
{
    DWORD      err;
    PNWSPOOL   pSpool = NULL;
    LPWSTR     pszServer = NULL;
    LPWSTR     pszQueue  = NULL;
    PNWPRINTER pPrinter = NULL;
    BOOL       fImpersonate = FALSE ;
    HANDLE     hServer;
    BOOL       isPrinterNameValid;

    UNREFERENCED_PARAMETER( Reserved );

    if ( pszPrinterName[0] == L' ' &&
         pszPrinterName[1] == L'\\' &&
         pszPrinterName[2] == L'\\' )
    {
        if ( (pszServer = AllocNwSplStr( pszPrinterName + 1 )) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;
        isPrinterNameValid = ValidateUNCName( pszPrinterName + 1 );
    }
    else
    {
        if ( (pszServer = AllocNwSplStr( pszPrinterName )) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;
        isPrinterNameValid = ValidateUNCName( pszPrinterName );
    }

    CharUpperW( pszServer );   // convert in place

    //
    // ValidatePrinterName
    //
    if (  ( !isPrinterNameValid )
       || ( (pszQueue = wcschr( pszServer + 2, L'\\')) == NULL )
       || ( pszQueue == (pszServer + 2) )
       || ( *(pszQueue + 1) == L'\0' )
       )
    {
        FreeNwSplStr( pszServer );
        return ERROR_INVALID_NAME;
    }

    *pszQueue = L'\0';   // put a '\0' in place of '\\'
    pszQueue++;          // Get past the '\0'

    if ( !(pSpool = AllocNwSplMem( LMEM_ZEROINIT, sizeof( NWSPOOL))))
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    //
    // Impersonate the client
    //
    if ((err = NwImpersonateClient()) != NO_ERROR)
    {
        goto ErrorExit;
    }
    fImpersonate = TRUE ;

    EnterCriticalSection( &NwPrintCritSec );

    if ((err = NwCreatePrinterEntry( pszServer, pszQueue, &pPrinter, &hServer)))
    {
        if ( !fKnownPrinter )
        {
            LeaveCriticalSection( &NwPrintCritSec );
            goto ErrorExit;
        }
    }

    //
    // Construct the print queue context handle to give back to the caller
    //
    pSpool->nSignature  = NW_SIGNATURE;
    pSpool->errOpenPrinter = err;

    pSpool->hServer = hServer;
    pSpool->nStatus     = 0;
    pSpool->nJobNumber  = 0;
    pSpool->hChangeEvent= NULL;
    pSpool->nWaitFlags  = 0;
    pSpool->nChangeFlags= 0;

    if ( !err )
    {
        pSpool->pPrinter    = pPrinter;
        pSpool->pNextSpool  = pPrinter->pSpoolList;
        pPrinter->pSpoolList= pSpool;
    }
    else
    {
        pSpool->pPrinter    = NULL;
        pSpool->pNextSpool  = NULL;
    }

    // We know about this printer before but failed to retrieve
    // it this time. Clean up the error and return successfully.
    // The error code is stored in the handle above which
    // will be returned on subsequent calls using this
    // dummy handle.
    err = NO_ERROR;

    LeaveCriticalSection( &NwPrintCritSec );

ErrorExit:

    if (fImpersonate)
        (void) NwRevertToSelf() ;

    if ( err )
    {
        if ( pSpool )
            FreeNwSplMem( pSpool, sizeof( NWSPOOL) );
    }
    else
    {
        *phPrinter = (NWWKSTA_PRINTER_CONTEXT) pSpool;
    }

    //
    // Free up all allocated memories
    //
    *(pszServer + wcslen( pszServer)) = L'\\';
    FreeNwSplStr( pszServer );

    return err;

}



DWORD
NwrClosePrinter(
    IN OUT LPNWWKSTA_PRINTER_CONTEXT phPrinter
)
/*++

Routine Description:

    This routine closes the given printer object.

Arguments:

    phPrinter -  Handle of the printer object

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) *phPrinter;
    PNWPRINTER pPrinter;
    PNWSPOOL pCur, pPrev = NULL;


    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE ))
        return ERROR_INVALID_HANDLE;

    //
    // If OpenPrinter failed, then this is a dummy handle.
    // We just need to free up the memory.
    //
    if ( pSpool->errOpenPrinter )
    {
        //
        // invalidate the signature, but leave a recognizable value
        //
        pSpool->nSignature += 1 ;
        FreeNwSplMem( pSpool, sizeof( NWSPOOL) );
        *phPrinter = NULL;
        return NO_ERROR;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    //
    // Call EndDocPrinter if the user has not already done so
    //
    if ( pSpool->nStatus == SPOOL_STATUS_STARTDOC )
    {
        (void) NwrEndDocPrinter( *phPrinter );
    }
    else if ( pSpool->nStatus == SPOOL_STATUS_ADDJOB )
    {
        (void) NwrScheduleJob( *phPrinter, pSpool->nJobNumber );
    }

    if ( pSpool->hChangeEvent )
        CloseHandle( pSpool->hChangeEvent );

    pSpool->hChangeEvent = NULL;
    pSpool->nChangeFlags = 0;
    (VOID) NtClose( pSpool->hServer );


    EnterCriticalSection( &NwPrintCritSec );

    for ( pCur = pPrinter->pSpoolList; pCur;
          pPrev = pCur, pCur = pCur->pNextSpool )
    {
        if ( pCur == pSpool )
        {
            if ( pPrev )
                pPrev->pNextSpool = pCur->pNextSpool;
            else
                pPrinter->pSpoolList = pCur->pNextSpool;
            break;
        }

    }

    ASSERT( pCur );

    if ( pPrinter->pSpoolList == NULL )
    {
#if DBG
        IF_DEBUG(PRINT)
        {
            KdPrint(("*************DELETED PRINTER ENTRY: %ws\\%ws\n\n",
                    pPrinter->pszServer, pPrinter->pszQueue ));
        }
#endif

        NwRemovePrinterEntry( pPrinter );
    }

    LeaveCriticalSection( &NwPrintCritSec );

    //
    // invalidate the signature, but leave a recognizable value
    //
    pSpool->nSignature += 1 ;

    pSpool->pNextSpool = NULL;
    pSpool->pPrinter = NULL;

    //
    // Free all memory associated with the context handle
    //
    FreeNwSplMem( pSpool, sizeof( NWSPOOL) );

    //
    // indicate to RPC we are done
    //
    *phPrinter = NULL;

    return NO_ERROR;
}



DWORD
NwrGetPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD dwLevel,
    IN OUT LPBYTE pbPrinter,
    IN DWORD cbBuf,
    OUT LPDWORD pcbNeeded
)
/*++

Routine Description:

    The routine retrieves information about the given printer.

Arguments:

    hPrinter  -  Handle of the printer
    dwLevel   -  Specifies the level of the structure to which pbPrinter points.
    pbPrinter -  Points to a buffer that receives the PRINTER_INFO object.
    cbBuf     -  Size, in bytes of the array pbPrinter points to.
    pcbNeeded -  Points to a value which specifies the number of bytes copied
                 if the function succeeds or the number of bytes required if
                 cbBuf was too small.

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    PNWPRINTER pPrinter;

    LPBYTE pbEnd = pbPrinter + cbBuf;
    BOOL   fFitInBuffer;
    DWORD_PTR  *pOffsets;

    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        return ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        return pSpool->errOpenPrinter;
    }
    else if ( ( dwLevel != 1 ) && ( dwLevel != 2 ) && ( dwLevel != 3 ))
    {
        return ERROR_INVALID_LEVEL;
    }

    if ( !pbPrinter )
    {
        if ( cbBuf == 0 )
        {
            //
            // Calculate size needed
            //
            pPrinter = pSpool->pPrinter;
            ASSERT( pPrinter );

            if ( dwLevel == 1 )
            {
                *pcbNeeded = sizeof( PRINTER_INFO_1W ) +
                             (   wcslen( pPrinter->pszServer )
                               + wcslen( pPrinter->pszQueue ) + 2 ) * sizeof( WCHAR );
            }
            else if ( dwLevel == 2 )
            {
                *pcbNeeded = sizeof( PRINTER_INFO_2W ) +
                             ( 2*wcslen( pPrinter->pszServer ) +
                               2*wcslen( pPrinter->pszQueue ) + 4 ) * sizeof( WCHAR );
            }
            else  // Level == 3
            {
                PRINTER_INFO_3 *pPrinterInfo3 = (PRINTER_INFO_3 *) pbPrinter;

                *pcbNeeded = sizeof( PRINTER_INFO_3 );
            }
            return ERROR_INSUFFICIENT_BUFFER;
        }
        else
            return ERROR_INVALID_PARAMETER;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    if ( dwLevel == 1 )
    {
        PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) pbPrinter;
        LPBYTE pbFixedEnd = pbPrinter + sizeof( PRINTER_INFO_1W );

        //
        // Calculate size needed
        //
        *pcbNeeded = sizeof( PRINTER_INFO_1W ) +
                     (   wcslen( pPrinter->pszServer )
                       + wcslen( pPrinter->pszQueue ) + 2 ) * sizeof( WCHAR );

        if ( cbBuf < *pcbNeeded )
            return ERROR_INSUFFICIENT_BUFFER;

        pOffsets = PrinterInfo1Offsets;

        //
        // Fill in the structure
        //
        pPrinterInfo1->Flags    = PRINTER_ENUM_REMOTE | PRINTER_ENUM_NAME;
        pPrinterInfo1->pComment = NULL;

        fFitInBuffer = NwlibCopyStringToBuffer(
                           pPrinter->pszServer,
                           wcslen( pPrinter->pszServer ),
                           (LPWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo1->pDescription );

        ASSERT( fFitInBuffer );

        fFitInBuffer = NwlibCopyStringToBuffer(
                           pPrinter->pszQueue,
                           wcslen( pPrinter->pszQueue ),
                           (LPWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo1->pName );

        ASSERT( fFitInBuffer );

    }
    else if ( dwLevel == 2 )
    {
        DWORD  err;
        BYTE   nQueueStatus;
        BYTE   nNumJobs;
        PRINTER_INFO_2W *pPrinterInfo2 = (PRINTER_INFO_2W *) pbPrinter;
        LPBYTE pbFixedEnd = pbPrinter + sizeof( PRINTER_INFO_2W );

        //
        // Check if the buffer is big enough to hold all the data
        //

        *pcbNeeded = sizeof( PRINTER_INFO_2W ) +
                     ( 2*wcslen( pPrinter->pszServer ) +
                       2*wcslen( pPrinter->pszQueue ) + 4 ) * sizeof( WCHAR );

        if ( cbBuf < *pcbNeeded )
            return ERROR_INSUFFICIENT_BUFFER;

        pOffsets = PrinterInfo2Offsets;

        err = NwReadQueueCurrentStatus( pSpool->hServer,
                                        pPrinter->nQueueId,
                                        &nQueueStatus,
                                        &nNumJobs );

        if ( err )
            return err;

        pPrinterInfo2->Status = (nQueueStatus & 0x05)? PRINTER_STATUS_PAUSED
                                                     : 0;
        pPrinterInfo2->cJobs  = nNumJobs;

        fFitInBuffer = NwlibCopyStringToBuffer(
                           pPrinter->pszServer,
                           wcslen( pPrinter->pszServer ),
                           (LPCWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo2->pServerName );

        ASSERT( fFitInBuffer );

        pbEnd -= ( wcslen( pPrinter->pszQueue) + 1 ) * sizeof( WCHAR );
        wcscpy( (LPWSTR) pbEnd, pPrinter->pszQueue );
        pbEnd -= ( wcslen( pPrinter->pszServer) + 1 ) * sizeof( WCHAR );
        wcscpy( (LPWSTR) pbEnd, pPrinter->pszServer );
        *(pbEnd + wcslen( pPrinter->pszServer )*sizeof(WCHAR))= L'\\';
        pPrinterInfo2->pPrinterName = (LPWSTR) pbEnd;

        fFitInBuffer = NwlibCopyStringToBuffer(
                           pPrinter->pszQueue,
                           wcslen( pPrinter->pszQueue ),
                           (LPCWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo2->pShareName );

        ASSERT( fFitInBuffer );

        pPrinterInfo2->pPortName = NULL;
        pPrinterInfo2->pDriverName = NULL;
        pPrinterInfo2->pComment = NULL;
        pPrinterInfo2->pLocation = NULL;
        pPrinterInfo2->pDevMode = NULL;
        pPrinterInfo2->pSepFile = NULL;
        pPrinterInfo2->pPrintProcessor = NULL;
        pPrinterInfo2->pDatatype = NULL;
        pPrinterInfo2->pParameters = NULL;
        pPrinterInfo2->pSecurityDescriptor = NULL;
        pPrinterInfo2->Attributes = PRINTER_ATTRIBUTE_QUEUED;
        pPrinterInfo2->Priority = 0;
        pPrinterInfo2->DefaultPriority = 0;
        pPrinterInfo2->StartTime = 0;
        pPrinterInfo2->UntilTime = 0;
        pPrinterInfo2->AveragePPM = 0;
    }
    else  // Level == 3
    {
        PRINTER_INFO_3 *pPrinterInfo3 = (PRINTER_INFO_3 *) pbPrinter;

        *pcbNeeded = sizeof( PRINTER_INFO_3 );

        if ( cbBuf < *pcbNeeded )
            return ERROR_INSUFFICIENT_BUFFER;

        pOffsets = PrinterInfo3Offsets;
        pPrinterInfo3->pSecurityDescriptor = NULL;
    }

    MarshallDownStructure( pbPrinter, pOffsets, pbPrinter );
    return NO_ERROR;
}



DWORD
NwrSetPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD  dwCommand
)
/*++

Routine Description:

    The routine sets information about the given printer.

Arguments:

    hPrinter  -  Handle of the printer
    dwCommand -  Specifies the new printer state

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    DWORD err = NO_ERROR;
    PNWPRINTER pPrinter;

    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        return ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        return pSpool->errOpenPrinter;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    switch ( dwCommand )
    {
        case PRINTER_CONTROL_PAUSE:
        case PRINTER_CONTROL_RESUME:
        {
            BYTE nQueueStatus = 0;
            BYTE nNumJobs;

            //
            // Get the original queue status so that we don't overwrite
            // some of the bits.
            //
            err = NwReadQueueCurrentStatus( pSpool->hServer,
                                            pPrinter->nQueueId,
                                            &nQueueStatus,
                                            &nNumJobs );

            if ( !err )
            {
                //
                // Clear the pause bits, and leave the rest alone.
                //
                nQueueStatus &= ~0x05;
            }

            if ( dwCommand == PRINTER_CONTROL_PAUSE )
            {
                nQueueStatus |= 0x04;
            }

            err = NwSetQueueCurrentStatus( pSpool->hServer,
                                           pPrinter->nQueueId,
                                           nQueueStatus );
            if ( !err )
                NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_PRINTER );
            break;
        }

        case PRINTER_CONTROL_PURGE:

            err = NwRemoveAllJobsFromQueue( pSpool->hServer,
                                            pPrinter->nQueueId );
            if ( !err )
                NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_PRINTER |
                                            PRINTER_CHANGE_DELETE_JOB );
            break;

        default:
            //
            // dwCommand is 0 so that means
            // some properties of the printer has changed.
            // We will ignore the properties that
            // are being modified since most properties
            // are stored in the registry by spooler.
            // All we need to do is to signal WaitForPrinterChange to
            // return so that print manager will refresh its data.
            //

            ASSERT( dwCommand == 0 );
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_PRINTER );
            break;
    }

    return err;
}



DWORD
NwrEnumPrinters(
    IN LPWSTR Reserved,
    IN LPWSTR pszName,
    IN OUT LPBYTE pbPrinter,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
)
/*++

Routine Description:

    This routine enumerates the available providers, servers, printers
    depending on the given pszName.

Arguments:

    Reserved   -  Unused
    pszName    -  The name of the container object
    pbPrinter  -  Points to the array to receive the PRINTER_INFO objects
    cbBuf      -  Size, in bytes of pbPrinter
    pcbNeeded  -  Count of bytes needed
    pcReturned -  Count of PRINTER_INFO objects

Return Value:

--*/
{
    PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) pbPrinter;

    *pcbNeeded = 0;
    *pcReturned = 0;

    if ( ( cbBuf != 0 ) && !pbPrinter )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( !pszName )   // Enumerate the provider name
    {
        BOOL   fFitInBuffer;
        LPBYTE pbFixedEnd = pbPrinter + sizeof( PRINTER_INFO_1W );
        LPBYTE pbEnd = pbPrinter + cbBuf;

        *pcbNeeded = sizeof( PRINTER_INFO_1W ) +
                     ( 2 * wcslen( NwProviderName ) +
                       + 2) * sizeof(WCHAR);

        if ( *pcbNeeded > cbBuf )
            return ERROR_INSUFFICIENT_BUFFER;

        pPrinterInfo1->Flags = PRINTER_ENUM_ICON1 |
                               PRINTER_ENUM_CONTAINER |
                               PRINTER_ENUM_EXPAND;
        pPrinterInfo1->pComment = NULL;

        fFitInBuffer = NwlibCopyStringToBuffer(
                           NwProviderName,
                           wcslen( NwProviderName ),
                           (LPWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo1->pDescription );

        ASSERT( fFitInBuffer );

        fFitInBuffer = NwlibCopyStringToBuffer(
                           NwProviderName,
                           wcslen( NwProviderName ),
                           (LPWSTR) pbFixedEnd,
                           (LPWSTR *) &pbEnd,
                           &pPrinterInfo1->pName );

        ASSERT( fFitInBuffer );

        MarshallDownStructure( pbPrinter, PrinterInfo1Offsets, pbPrinter );
        *pcReturned = 1;
    }

    else if ( pszName && *pszName )
    {
        DWORD  err;
        LPWSTR pszFullName;
        LPWSTR pszServer;
        NWWKSTA_CONTEXT_HANDLE handle;
        BYTE bTemp = 0;
        LPBYTE pbTempBuf = pbPrinter ? pbPrinter : &bTemp;

        if ( (pszFullName = LocalAlloc( 0, (wcslen( pszName ) + 1) *
                                           sizeof(WCHAR) ) ) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy( pszFullName, pszName );
        pszServer = wcschr( pszFullName, L'!');

        if ( pszServer )
            *pszServer++ = 0;

        if ( lstrcmpiW( pszFullName, NwProviderName ) )
        {
            LocalFree( pszFullName );
            return ERROR_INVALID_NAME;
        }

        if ( !pszServer )  // Enumerate servers
        {
            LocalFree( pszFullName );

            err = NwOpenEnumPrintServers( &handle );

            if ( err != NO_ERROR )
            {
                return err;
            }

            err = NwrEnum( handle,
                           (DWORD_PTR) -1,
                           pbTempBuf,
                           cbBuf,
                           pcbNeeded,
                           pcReturned );

            if ( err != NO_ERROR )
            {
                NwrCloseEnum( &handle );
                return err;
            }

            err = NwrCloseEnum( &handle );

            if ( err != NO_ERROR )
            {
                return err;
            }
        }
        else  // Enumerate NDS sub-trees or print queues
        {
            LPWSTR tempStrPtr = pszServer;
            DWORD  dwClassType = 0;

            if ( tempStrPtr[0] == L'\\' &&
                 tempStrPtr[1] == L'\\' &&
                 tempStrPtr[2] == L' ' )
                 tempStrPtr = &tempStrPtr[1];

            err = NwrOpenEnumNdsSubTrees_Print( NULL, tempStrPtr, &dwClassType, &handle );

            if ( err == ERROR_NETWORK_ACCESS_DENIED && dwClassType == CLASS_TYPE_NCP_SERVER )
            {
                // An error code from the above NwOpenEnumNdsSubTrees could have
                // failed because the object was a server, which cannot be enumerated
                // with the NDS tree APIs. If so we try to get the print queues with the
                // regular NW APIs.

                tempStrPtr = NwGetUncObjectName( tempStrPtr );

                err = NwOpenEnumPrintQueues( tempStrPtr, &handle );

                if ( err != NO_ERROR )
                {
                    LocalFree( pszFullName );
                    return err;
                }
            }

            if ( err != NO_ERROR )
            {
                // An error code from the above NwOpenEnumNdsSubTrees could have
                // failed because the object was not a part of an NDS tree.
                // So we try to get the print queues with the regular NW APIs.

                err = NwOpenEnumPrintQueues( tempStrPtr, &handle );

                if ( err != NO_ERROR )
                {
                    LocalFree( pszFullName );
                    return err;
                }
            }

            //
            // Get rid of the allocated temp buffer that we've been using
            // indirectly through tempStrPtr and pszServer.
            //
            LocalFree( pszFullName );

            err = NwrEnum( handle,
                           0xFFFFFFFF,
                           pbTempBuf,
                           cbBuf,
                           pcbNeeded,
                           pcReturned );

            if ( err != NO_ERROR )
            {
                NwrCloseEnum( &handle );
                return err;
            }

            err = NwrCloseEnum( &handle );

            if ( err != NO_ERROR )
            {
                return err;
            }
        }
    }

    return NO_ERROR;
}


DWORD
NwrStartDocPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN LPWSTR pszDocument,
    IN LPWSTR pszUser,
    IN DWORD  PrintOptions                 //Multi-User Addition
)
/*++

Routine Description:

    This routine informs the print spooler that a document is to be spooled
    for printing.

Arguments:

    hPrinter    -  Handle of the printer
    pszDocument -  Name of the document to be printed
    pszUser     -  Name of the user submitting the print job

Return Value:

--*/
{
    DWORD err;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || (pSpool->nSignature != NW_SIGNATURE) )
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( pSpool->nStatus != 0 )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Get pSpool->nJobNumber from CreateQueueJobAndFile
        //

        PNWPRINTER pPrinter = pSpool->pPrinter;
        WORD  nJobNumber = 0;

        ASSERT( pPrinter );
        err = NwCreateQueueJobAndFile( pSpool->hServer,
                                       pPrinter->nQueueId,
                                       pszDocument,
                                       pszUser,
                                       PrintOptions,           //Multi-User addition
                                       pPrinter->pszQueue,
                                       &nJobNumber );

        if ( !err )
        {
            pSpool->nJobNumber = nJobNumber;
            pSpool->nStatus = SPOOL_STATUS_STARTDOC;
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_ADD_JOB |
                                        PRINTER_CHANGE_SET_PRINTER );
        }
    }

    return err;
}



DWORD
NwrWritePrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN LPBYTE pBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pcbWritten
)
/*++

Routine Description:

    This routine informs the print spooler that the specified data should be
    written to the given printer.

Arguments:

    hPrinter   -  Handle of the printer object
    pBuf       -  Address of array that contains printer data
    cbBuf      -  Size, in bytes of pBuf
    pcbWritten -  Receives the number of bytes actually written to the printer

Return Value:

--*/
{
    DWORD err = NO_ERROR;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE))
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( pSpool->nStatus != SPOOL_STATUS_STARTDOC )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else
    {
        NTSTATUS ntstatus;
        IO_STATUS_BLOCK IoStatusBlock;
        PNWPRINTER pPrinter = pSpool->pPrinter;

        ASSERT( pPrinter );
        ntstatus = NtWriteFile( pSpool->hServer,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                pBuf,
                                cbBuf,
                                NULL,
                                NULL );

        if ( NT_SUCCESS(ntstatus))
            ntstatus = IoStatusBlock.Status;

        if ( NT_SUCCESS(ntstatus) )
        {
            *pcbWritten = (DWORD) IoStatusBlock.Information;
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_WRITE_JOB );
        }
        else
        {
            KdPrint(("NWWORKSTATION: NtWriteFile failed 0x%08lx\n", ntstatus));
            *pcbWritten = 0;
            err = RtlNtStatusToDosError( ntstatus );
        }
    }

    return err;
}



DWORD
NwrAbortPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter
)
/*++

Routine Description:

    This routine deletes a printer's spool file if the printer is configured
    for spooling.

Arguments:

    hPrinter - Handle of the printer object

Return Value:

--*/
{
    DWORD err;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE ))
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( pSpool->nStatus != SPOOL_STATUS_STARTDOC )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PNWPRINTER pPrinter = pSpool->pPrinter;

        ASSERT( pPrinter );
        err = NwRemoveJobFromQueue( pSpool->hServer,
                                    pPrinter->nQueueId,
                                    (WORD) pSpool->nJobNumber );

        if ( !err )
        {
            pSpool->nJobNumber = 0;
            pSpool->nStatus = SPOOL_STATUS_ABORT;
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_JOB );
        }
    }

    return err;
}



DWORD
NwrEndDocPrinter(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter
)
/*++

Routine Description:

    This routine ends the print job for the given printer.

Arguments:

    hPrinter -  Handle of the printer object

Return Value:

--*/
{
    DWORD err = NO_ERROR;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE ))
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if (  ( pSpool->nStatus != SPOOL_STATUS_STARTDOC )
            && ( pSpool->nStatus != SPOOL_STATUS_ABORT )
            )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PNWPRINTER pPrinter = pSpool->pPrinter;

        ASSERT( pPrinter );

        if ( pSpool->nStatus == SPOOL_STATUS_STARTDOC )
        {
             err = NwCloseFileAndStartQueueJob( pSpool->hServer,
                                                pPrinter->nQueueId,
                                                (WORD) pSpool->nJobNumber );

             if ( !err )
                 NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_JOB );
        }

        if ( !err )
        {
            pSpool->nJobNumber = 0;
            pSpool->nStatus = 0;
        }
    }

    return err;
}



DWORD
NwrGetJob(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD dwJobId,
    IN DWORD dwLevel,
    IN OUT LPBYTE pbJob,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
)
/*++

Routine Description:


Arguments:

    hPrinter  -  Handle of the printer
    dwJobId   -
    dwLevel   -
    pbJob     -
    cbBuf     -
    pcbNeeded -

Return Value:

--*/
{
    DWORD err;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;

    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        err = ERROR_INVALID_HANDLE;
    }
    // allow NULL for bpJob if cbBuf is 0.
    // Relies on NwGetQueueJobInfo to properly handle NULL pointer in request to fill pcbNeeded
    else if ( (cbBuf != 0) && ( !pbJob ) )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if (( dwLevel != 1 ) && ( dwLevel != 2 ))
    {
        err = ERROR_INVALID_LEVEL;
    }
    else
    {
        DWORD  nPrinterLen;
        LPWSTR pszPrinter;
        LPBYTE FixedPortion = pbJob;
        LPWSTR EndOfVariableData = (LPWSTR) (pbJob + cbBuf);
        PNWPRINTER pPrinter = pSpool->pPrinter;

        ASSERT( pPrinter );

        pszPrinter = AllocNwSplMem( LMEM_ZEROINIT,
                         nPrinterLen = ( wcslen( pPrinter->pszServer) +
                         wcslen( pPrinter->pszQueue) + 2) * sizeof(WCHAR));

        if ( pszPrinter == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy( pszPrinter, pPrinter->pszServer );
        wcscat( pszPrinter, L"\\" );
        wcscat( pszPrinter, pPrinter->pszQueue );

        *pcbNeeded = 0;
        err = NwGetQueueJobInfo( pSpool->hServer,
                                 pPrinter->nQueueId,
                                 (WORD) dwJobId,
                                 pszPrinter,
                                 dwLevel,
                                 &FixedPortion,
                                 &EndOfVariableData,
                                 pcbNeeded );

        FreeNwSplMem( pszPrinter, nPrinterLen );

        if ( !err )
        {
            switch( dwLevel )
            {
                case 1:
                    MarshallDownStructure( pbJob, JobInfo1Offsets, pbJob );
                    break;

                case 2:
                    MarshallDownStructure( pbJob, JobInfo2Offsets, pbJob );
                    break;

                default:
                    ASSERT( FALSE );
                    break;
            }
        }

    }

    return err;
}



DWORD
NwrEnumJobs(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD dwFirstJob,
    IN DWORD dwNoJobs,
    IN DWORD dwLevel,
    IN OUT LPBYTE pbJob,
    IN DWORD cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
)
/*++

Routine Description:


Arguments:

    hPrinter    -  Handle of the printer
    dwFirstJob  -
    dwNoJobs    -
    dwLevel     -
    pbJob       -
    cbBuf       -
    pcbNeeded   -
    pcReturned  -

Return Value:

--*/
{
    DWORD err;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;


    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        err = ERROR_INVALID_HANDLE;
    }
    // allow NULL for bpJob if cbBuf is 0.
    // Relies on NwGetQueueJobInfo to properly handle NULL pointer in request to fill pcbNeeded
    else if ( (cbBuf != 0) && ( !pbJob ) )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( ( dwLevel != 1 ) && ( dwLevel != 2 ) )
    {
        err = ERROR_INVALID_LEVEL;
    }
    else
    {
        PNWPRINTER pPrinter = pSpool->pPrinter;
        LPWSTR pszPrinter;
        DWORD nPrinterLen;

        ASSERT( pPrinter );
        pszPrinter = AllocNwSplMem( LMEM_ZEROINIT,
                         nPrinterLen = ( wcslen( pPrinter->pszServer ) +
                         wcslen( pPrinter->pszQueue) + 2) * sizeof(WCHAR));

        if ( pszPrinter == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy( pszPrinter, pPrinter->pszServer );
        wcscat( pszPrinter, L"\\" );
        wcscat( pszPrinter, pPrinter->pszQueue );

        err = NwGetQueueJobs( pSpool->hServer,
                              pPrinter->nQueueId,
                              pszPrinter,
                              dwFirstJob,
                              dwNoJobs,
                              dwLevel,
                              pbJob,
                              cbBuf,
                              pcbNeeded,
                              pcReturned );

        FreeNwSplMem( pszPrinter, nPrinterLen );

        if ( !err )
        {
            DWORD_PTR *pOffsets;
            DWORD cbStruct;
            DWORD cReturned = *pcReturned;
            LPBYTE pbBuffer = pbJob;

            switch( dwLevel )
            {
                case 1:
                    pOffsets = JobInfo1Offsets;
                    cbStruct = sizeof( JOB_INFO_1W );
                    break;

                case 2:
                    pOffsets = JobInfo2Offsets;
                    cbStruct = sizeof( JOB_INFO_2W );
                    break;

                default:
                    ASSERT( FALSE );
                    break;
            }

            while ( cReturned-- )
            {
                MarshallDownStructure( pbBuffer, pOffsets, pbJob );
                pbBuffer += cbStruct;
            }
        }
    }

    return err;
}



DWORD
NwrSetJob(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD  dwJobId,
    IN DWORD  dwLevel,
    IN PNW_JOB_INFO  pNwJobInfo,
    IN DWORD  dwCommand
)
/*++

Routine Description:


Arguments:

    hPrinter  -  Handle of the printer
    dwJobId   -
    dwLevel   -
    pNwJobInfo-
    dwCommand -

Return Value:

--*/
{
    DWORD err = NO_ERROR;
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    PNWPRINTER pPrinter;

    if ( !pSpool || pSpool->nSignature != NW_SIGNATURE )
    {
        err = ERROR_INVALID_HANDLE;
    }
    else if ( ( dwLevel != 0 ) && ( !pNwJobInfo ) )
    {
        err = ERROR_INVALID_PARAMETER;
    }
    else if ( pSpool->errOpenPrinter )
    {
        err = pSpool->errOpenPrinter;
    }
    else if ( ( dwLevel != 0 ) && ( dwLevel != 1 ) && ( dwLevel != 2 ) )
    {
        err = ERROR_INVALID_LEVEL;
    }

    if ( err )
        return err;

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    if ( ( dwCommand == JOB_CONTROL_CANCEL ) ||
         ( dwCommand == JOB_CONTROL_DELETE ) )
    {
        err = NwRemoveJobFromQueue( pSpool->hServer,
                                    pPrinter->nQueueId,
                                    (WORD) dwJobId );

        if ( !err )
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_DELETE_JOB |
                                        PRINTER_CHANGE_SET_PRINTER );

        // Since the job is removed, we don't need to change other
        // information about it.
    }
    else
    {
        if ( dwLevel != 0 )
        {
            if ( pNwJobInfo->nPosition != JOB_POSITION_UNSPECIFIED )
            {
                err = NwChangeQueueJobPosition( pSpool->hServer,
                                                pPrinter->nQueueId,
                                                (WORD) dwJobId,
                                                (BYTE) pNwJobInfo->nPosition );
            }
        }

        if ( ( !err ) && ( dwCommand == JOB_CONTROL_RESTART ))
        {
            err = ERROR_NOT_SUPPORTED;
        }
        else if ( !err )
        {
            err = NwChangeQueueJobEntry( pSpool->hServer,
                                         pPrinter->nQueueId,
                                         (WORD) dwJobId,
                                         dwCommand,
                                         pNwJobInfo );
        }

        if ( !err )
            NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_JOB );
    }

    return err;
}



DWORD
NwrAddJob(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    OUT LPADDJOB_INFO_1W pAddInfo1,
    IN DWORD cbBuf,
    OUT LPDWORD pcbNeeded
    )
/*++

Routine Description:


Arguments:

    hPrinter  - Handle of the printer.
    pAddInfo1 - Output buffer to hold ADDJOB_INFO_1W structure.
    cbBuf     - Output buffer size in bytes.
    pcbNeeded - Required output buffer size in bytes.

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    PNWPRINTER pPrinter;


    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE )) {
        return ERROR_INVALID_HANDLE;
    }

    if ( pSpool->errOpenPrinter ) {
        return pSpool->errOpenPrinter;
    }

    if ( pSpool->nStatus != 0 )  {
        return ERROR_INVALID_PARAMETER;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    *pcbNeeded = sizeof(ADDJOB_INFO_1W) +
                 (wcslen(pPrinter->pszServer) +
                  wcslen(pPrinter->pszQueue) + 2) * sizeof(WCHAR);

    if (cbBuf < *pcbNeeded) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Write UNC path name into the output buffer.
    //
    //	dfergus 19 Apr 2001 - 348006
    //	DWORD cast
    pAddInfo1->Path = (LPWSTR) ((DWORD) pAddInfo1 + sizeof(ADDJOB_INFO_1W));
    //
    wcscpy(pAddInfo1->Path, pPrinter->pszServer);
    wcscat(pAddInfo1->Path, L"\\" );
    wcscat(pAddInfo1->Path, pPrinter->pszQueue);

    //
    // Return special job id value which the client (winspool.drv) looks
    // for and does an FSCTL call to our redirector to get the real
    // job id.  We cannot return a real job id at this point because
    // the CreateQueueJobAndFile NCP is not issue until the client opens
    // the UNC name we return in this API.
    //
    pAddInfo1->JobId = (DWORD) -1;

    //
    // Save context information
    //
    pSpool->nJobNumber = pAddInfo1->JobId;
    pSpool->nStatus = SPOOL_STATUS_ADDJOB;

#if DBG
    IF_DEBUG(PRINT) {
        KdPrint(("NWWORKSTATION: NwrAddJob Path=%ws, JobId=%lu, BytesNeeded=%lu\n",
                 pAddInfo1->Path, pAddInfo1->JobId, *pcbNeeded));
    }
#endif

    NwSetPrinterChange( pSpool, PRINTER_CHANGE_ADD_JOB |
                                PRINTER_CHANGE_SET_PRINTER );

    return NO_ERROR;
}



DWORD
NwrScheduleJob(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN DWORD dwJobId
    )
/*++

Routine Description:


Arguments:

    hPrinter -  Handle of the printer
    dwJobId  -  Job identification number

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    PNWPRINTER pPrinter;


    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE )) {
        return ERROR_INVALID_HANDLE;
    }

    if ( pSpool->errOpenPrinter ) {
        return pSpool->errOpenPrinter;
    }

    if (pSpool->nStatus != SPOOL_STATUS_ADDJOB) {
        return ERROR_INVALID_PARAMETER;
    }

    pPrinter = pSpool->pPrinter;
    ASSERT( pPrinter );

    pSpool->nJobNumber = 0;
    pSpool->nStatus = 0;

    NwSetPrinterChange( pSpool, PRINTER_CHANGE_SET_JOB );

    return NO_ERROR;
}



DWORD
NwrWaitForPrinterChange(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter,
    IN OUT LPDWORD pdwFlags
)
/*++

Routine Description:


Arguments:

    hPrinter -  Handle of the printer
    pdwFlags -

Return Value:

--*/
{
    PNWSPOOL pSpool = (PNWSPOOL) hPrinter;
    HANDLE hChangeEvent = NULL;
    DWORD  nRetVal;
    HANDLE ahWaitEvents[2];
    DWORD err = NO_ERROR;

    if ( !pSpool || ( pSpool->nSignature != NW_SIGNATURE ))
    {
        return ERROR_INVALID_HANDLE;
    }
    else if ( pSpool->errOpenPrinter )
    {
        return pSpool->errOpenPrinter;
    }
    else if ( pSpool->hChangeEvent )
    {
        return ERROR_ALREADY_WAITING;
    }
    else if ( !(*pdwFlags & PRINTER_CHANGE_VALID ))
    {
        return ERROR_INVALID_PARAMETER;
    }


    if ( pSpool->nChangeFlags & *pdwFlags )
    {
        //
        // There is a change since we last called
        //

        *pdwFlags &= pSpool->nChangeFlags;

        EnterCriticalSection( &NwPrintCritSec );
        pSpool->nChangeFlags = 0;
        LeaveCriticalSection( &NwPrintCritSec );

        return NO_ERROR;
    }

    hChangeEvent = CreateEvent( NULL,
                                FALSE,   // automatic reset
                                FALSE,   // initial state not signalled
                                NULL );

    if ( !hChangeEvent )
    {
        KdPrint(("WaitForPrinterChange: CreateEvent failed with error %d\n",
                 GetLastError() ));
        return GetLastError();
    }


    pSpool->nWaitFlags = *pdwFlags;

    EnterCriticalSection( &NwPrintCritSec );
    pSpool->hChangeEvent = hChangeEvent;
    pSpool->nChangeFlags = 0;
    LeaveCriticalSection( &NwPrintCritSec );

    ahWaitEvents[0] = pSpool->hChangeEvent;
    ahWaitEvents[1] = NwDoneEvent;

    nRetVal = WaitForMultipleObjects( 2,        // Two events to wait for
                                      ahWaitEvents,
                                      FALSE,    // Wait for one to signal
                                      NwTimeOutValue );

    switch ( nRetVal )
    {
        case WAIT_FAILED:
            err = GetLastError();
            break;

        case WAIT_TIMEOUT:
        case WAIT_OBJECT_0 + 1:    // treats service stopping as timeout
            *pdwFlags |= PRINTER_CHANGE_TIMEOUT;
            break;

        case WAIT_OBJECT_0:
            *pdwFlags &= pSpool->nChangeFlags;
            break;

        default:
            KdPrint(("WaitForPrinterChange: WaitForMultipleObjects returned with %d\n", nRetVal ));
            *pdwFlags |= PRINTER_CHANGE_TIMEOUT;
            break;
    }

    if ( ( !err ) && ( nRetVal != WAIT_OBJECT_0 + 1 ) )
    {
        pSpool->nWaitFlags = 0;

        EnterCriticalSection( &NwPrintCritSec );
        pSpool->nChangeFlags = 0;
        pSpool->hChangeEvent = NULL;
        LeaveCriticalSection( &NwPrintCritSec );
    }

    if ( !CloseHandle( hChangeEvent ) )
    {
        KdPrint(("WaitForPrinterChange: CloseHandle failed with error %d\n",
                  GetLastError()));
    }

    return err;
}

typedef DWORD (*PRINTPROC)(HWND, HINSTANCE, LPCTSTR, UINT);

DWORD
NwrAddPrinterConnection(
    IN LPWSTR Reserved,
    IN LPWSTR pszPrinterName,
    IN LPWSTR pszDriverName
    )
/*++

Routine Description: Implements workaround to allow CSNW to support Point and Print
    If PnP is enabled in registry, NwrAddPrinterConnection is called with driver
    name read from NDS Queue object Description attribute in format:
    "PnP Driver:Driver Friendly Name[@\\server\share\driver.inf]".
    If driver inf file is specified it must be a Logo'd PnP driver, and must not
    invoke UI.  If not specified, driver name must be from %windir%\inf\ntprint.inf.

    Thie routine purposely runs in the system context, not impersonating the user
    in order to load the printer driver.  To maintain administrative control
    the feature requires a registry setting to enable PnP configuration, and 
    another key can be set to restrict PnP configuration to using only drivers
    listed in ntprint.inf.

    \\HKLM\System\CurrentControlSet\Control\Print\Providers\NetWare or Conpatible Network
            DWORD Value: EnableUserAddPrinter = 1 enables PnP loading of printer drivers
                                                ( Default: 0 )
            DWORD Value: RestrictToInboxDrivers = 1 forces loading from ntprint.inf only
                                                ( Default: 0 )

Arguments:

    Reserved - RPC Handle not used
    pszPrinterName - NDS Queue object
    pszDriverName - Friendly name of printer driver, with optional driver location

Return Value:

--*/
{
    DWORD err = 0;
    PRINTER_INFO_2W * pPrinterInfo = NULL;
    HANDLE hPrinter = NULL;

    PSECURITY_DESCRIPTOR pSecDesc = NULL;
    PACL pDacl = NULL;

    LPTSTR pszProcessor = L"winprint";
    NWWKSTA_PRINTER_CONTEXT phPrinter = NULL;
    LPBYTE pDest = NULL;
    DWORD dwBytesNeeded = 0;
    BOOL bRet = FALSE;
    LPWSTR pszInfPath = NULL;

    PSID pEveryoneSID = NULL;
    EXPLICIT_ACCESS ea[1];
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    WCHAR szPrintInf[MAX_PATH];

    if (!pszPrinterName || (*pszPrinterName == 0))
        return ERROR_INVALID_PARAMETER;
    if (!pszDriverName || (*pszDriverName == 0))
        return ERROR_INVALID_PARAMETER;

    pszInfPath = wcschr(pszDriverName, L'@');
    if (pszInfPath)
    {
        *pszInfPath = 0;
        pszInfPath++;
    }
    else
    {
        szPrintInf[0] = 0;
        err = GetSystemWindowsDirectory(szPrintInf, MAX_PATH);
        lstrcat(szPrintInf, L"\\inf\\ntprint.inf");
        pszInfPath = szPrintInf;
    }

#if DBG
    IF_DEBUG(PRINT)
    {
        KdPrint(("NWWKS:AddPrinterConnection - Printer=%ws, driver=%ws from %ws\n", pszPrinterName, pszDriverName, szPrintInf));
    }
#endif
    // Create a well-known SID for the Everyone group.

    if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                     SECURITY_WORLD_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pEveryoneSID) ) 
    {
        goto Cleanup;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea[0].grfAccessPermissions = PRINTER_ALL_ACCESS;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= OBJECT_INHERIT_ACE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

    // Create a new ACL that contains the new ACE.
    err = SetEntriesInAcl(1, ea, NULL, &pDacl);
    if (ERROR_SUCCESS != err) {
       goto Cleanup;
    }

    // Initialize a security descriptor.  
 
    pSecDesc = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                             SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSecDesc == NULL) { 
        goto Cleanup; 
    } 

    if (!InitializeSecurityDescriptor(pSecDesc, SECURITY_DESCRIPTOR_REVISION)) {  
        goto Cleanup; 
    }

    // Add the ACL to the security descriptor. 
 
    if (!SetSecurityDescriptorDacl(pSecDesc, 
            TRUE,     // fDaclPresent flag   
            pDacl, 
            FALSE))   // not a default DACL 
    {  
        goto Cleanup; 
    } 

    dwBytesNeeded = sizeof(PRINTER_INFO_2);
    pPrinterInfo = (PRINTER_INFO_2 *) LocalAlloc(LPTR, dwBytesNeeded);
    if (pPrinterInfo)
    {
        pPrinterInfo->pPrinterName = pszPrinterName;
        pPrinterInfo->pPortName = pPrinterInfo->pPrinterName;
        pPrinterInfo->pDriverName = pszDriverName;
        pPrinterInfo->pPrintProcessor = pszProcessor;
        pPrinterInfo->Attributes = PRINTER_ATTRIBUTE_NETWORK | PRINTER_ATTRIBUTE_LOCAL;
        pPrinterInfo->pServerName = NULL;
        pPrinterInfo->pShareName = NULL;
        pPrinterInfo->Status = 0;
        pPrinterInfo->cJobs = 0;

        if (IsValidSecurityDescriptor(pSecDesc))
        {
            pPrinterInfo->pSecurityDescriptor = pSecDesc;
        }

        hPrinter = AddPrinter(NULL, 2, (LPBYTE) pPrinterInfo);

        if (hPrinter == NULL)
        {
            if ( GetLastError() == ERROR_UNKNOWN_PRINTER_DRIVER )
            {
                WCHAR szCmdLine[1024];

                _snwprintf(szCmdLine, sizeof(szCmdLine) / sizeof(WCHAR),
                    L"/ia /q /m \"%.200ws\" /h \"Intel\" /v \"Windows 2000 or XP\" /f \"%.768ws\"",
                    pPrinterInfo->pDriverName, pszInfPath);
#if DBG
                IF_DEBUG(PRINT)
                {
                    KdPrint(("AddPrinterConnection - attempting to load driver from cab with command\n   %ws\n", szCmdLine));
                }
#endif
                {
                    HINSTANCE hPrintDll = LoadLibrary(L"printui.dll");
                    PRINTPROC pPrintFunc = NULL;
                    if (hPrintDll)
                    {
                        pPrintFunc = (PRINTPROC) GetProcAddress((HMODULE)hPrintDll, "PrintUIEntryW");
                        if (pPrintFunc)
                        {
                            HINSTANCE hInst = (HINSTANCE) GetModuleHandle(NULL);
                            HWND hParentWnd = GetDesktopWindow();
                            DWORD nRet = 0;

                            nRet = (pPrintFunc) (hParentWnd, hInst, szCmdLine, TRUE);

                            hPrinter = AddPrinter(NULL, 2, (LPBYTE) pPrinterInfo);
                        }
                        FreeLibrary(hPrintDll);
                    }
                }
            }
        }
#if DBG
        IF_DEBUG(PRINT)
        {
            KdPrint(("AddPrinter returned 0x%8.8X\n", hPrinter ));
        }
#endif
    }

Cleanup:
    if (pEveryoneSID)
        FreeSid(pEveryoneSID);
    if (pDacl)
        LocalFree(pDacl);
    if (pSecDesc)
        LocalFree(pSecDesc);
    if (hPrinter)
        ClosePrinter(hPrinter);
    if (phPrinter)
        ClosePrinter(phPrinter);
    if (pPrinterInfo)
        LocalFree(pPrinterInfo);
    return (hPrinter) ? ERROR_SUCCESS : ERROR_ACCESS_DENIED;
}


VOID
NwSetPrinterChange(
    PNWSPOOL pSpool,
    DWORD nFlags
)
{
    PNWPRINTER pPrinter = pSpool->pPrinter;
    PNWSPOOL pCurSpool = pSpool;

    EnterCriticalSection( &NwPrintCritSec );

    do {

        if ( pCurSpool->nWaitFlags & nFlags )
        {
            pCurSpool->nChangeFlags |= nFlags;

            if ( pCurSpool->hChangeEvent )
            {
                SetEvent( pCurSpool->hChangeEvent );
                pCurSpool->hChangeEvent = NULL;
            }
        }

        pCurSpool = pCurSpool->pNextSpool;
        if ( pCurSpool == NULL )
            pCurSpool = pPrinter->pSpoolList;

    } while ( pCurSpool && (pCurSpool != pSpool) );

    LeaveCriticalSection( &NwPrintCritSec );
}



PNWPRINTER
NwFindPrinterEntry(
    IN LPWSTR pszServer,
    IN LPWSTR pszQueue
)
{
    PNWPRINTER pPrinter = NULL;

    //
    // Check to see if we already have the given printer in our printer
    // link list. If yes, return the printer.
    //

    for ( pPrinter = NwPrinterList; pPrinter; pPrinter = pPrinter->pNextPrinter)
    {
        if (  ( lstrcmpiW( pPrinter->pszServer, pszServer ) == 0 )
           && ( lstrcmpiW( pPrinter->pszQueue, pszQueue ) == 0 )
           )
        {
            return pPrinter;
        }
    }

    return NULL;
}



DWORD
NwCreatePrinterEntry(
    IN LPWSTR pszServer,
    IN LPWSTR pszQueue,
    OUT PNWPRINTER *ppPrinter,
    OUT PHANDLE phServer
)
{
    DWORD          err = NO_ERROR;
    DWORD          nQueueId = 0;
    HANDLE         TreeHandle = NULL;
    UNICODE_STRING TreeName;
    PNWPRINTER     pNwPrinter = NULL;
    BOOL           fCreatedNWConnection = FALSE;

    LPWSTR lpRemoteName = NULL;
    DWORD  dwBufSize = ( wcslen(pszServer) + wcslen(pszQueue) + 2 )
                       * sizeof(WCHAR);

    lpRemoteName = (LPWSTR) AllocNwSplMem( LMEM_ZEROINIT, dwBufSize );

    if ( lpRemoteName == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    wcscpy( lpRemoteName, pszServer );
    wcscat( lpRemoteName, L"\\" );
    wcscat( lpRemoteName, pszQueue );

    *ppPrinter = NULL;
    *phServer = NULL;

    //
    // See if we already know about this print queue.
    //
    pNwPrinter = NwFindPrinterEntry( pszServer, pszQueue );

    /* Changing to get queue status to verify access to queue instead
    if ( pNwPrinter == NULL )
    {
        // We don't know about this NetWare print queue. We need to see if
        // we are authorized to use this queue. If so, then go ahead
        // and continue to open printer. Otherwise, fail with not
        // authorized error code.

        err = NwCreateConnection( NULL,
                                  lpRemoteName,
                                  RESOURCETYPE_PRINT,
                                  NULL,
                                  NULL );

        if ( err != NO_ERROR )
        {
            if ( ( err == ERROR_INVALID_PASSWORD ) ||
                 ( err == ERROR_ACCESS_DENIED ) ||
                 ( err == ERROR_NO_SUCH_USER ) )
            {
                err = ERROR_ACCESS_DENIED;
            }

            FreeNwSplMem( lpRemoteName, dwBufSize );

            return err;
        }

        fCreatedNWConnection = TRUE;
    }
    */

    //
    // See if pszServer is really a NDS tree name, if so call
    // NwNdsGetQueueInformation to get the QueueId and possible referred
    // server for which we open handle.
    //

    RtlInitUnicodeString( &TreeName, pszServer + 2 );

    err = NwNdsOpenTreeHandle( &TreeName, &TreeHandle );

    if ( err == NO_ERROR )
    {
        NTSTATUS ntstatus;
        WCHAR    szRefServer[NDS_MAX_NAME_CHARS];
        UNICODE_STRING ObjectName;
        UNICODE_STRING QueuePath;

        ObjectName.Buffer = szRefServer;
        ObjectName.MaximumLength = NDS_MAX_NAME_CHARS;
        ObjectName.Length = 0;

        RtlInitUnicodeString( &QueuePath, pszQueue );

        ntstatus = NwNdsGetQueueInformation( TreeHandle,
                                             &QueuePath,
                                             &ObjectName,
                                             &nQueueId );

        if ( TreeHandle )
        {
            CloseHandle( TreeHandle );
            TreeHandle = NULL;
        }

        if ( ntstatus )
        {
            err = RtlNtStatusToDosError( ntstatus );
            goto ErrorExit;
        }

        //
        // If we got a referred server, it's name would look like:
        // "CN=SERVER.OU=DEV.O=MICROSOFT" . . . Convert it to "C\\SERVER"
        //
        if ( ObjectName.Length > 0 )
        {
            WORD i;
            LPWSTR EndOfServerName = NULL;

            //
            // First convert the referred server name to
            // "C\\SERVER.OU=DEV.O=MICROSOFT"
            //
            szRefServer[1] = L'\\';
            szRefServer[2] = L'\\';

            //
            // Put a NULL terminator at the first '.'
            //
            EndOfServerName = wcschr( szRefServer + 3, L'.' );
            if (EndOfServerName)
                *EndOfServerName = L'\0';

            //
            // pszServer now equals the referred server "C\\SERVER"
            //

            //
            // Get the handle of the referred server skipping the 'C' character.
            //
            err = NwAttachToNetwareServer( szRefServer + 1, phServer);
        }
    }
    else // Not an NDS tree, so get handle of server.
    {

        err = NwAttachToNetwareServer( pszServer, phServer);

        if ( err == NO_ERROR )
        {
            if ( err = NwGetQueueId( *phServer, pszQueue, &nQueueId))
                err = ERROR_INVALID_NAME;
        }
    }

    if ( ( err == ERROR_INVALID_PASSWORD ) ||
         ( err == ERROR_ACCESS_DENIED ) ||
         ( err == ERROR_NO_SUCH_USER ) )
    {
        err = ERROR_ACCESS_DENIED;
        goto ErrorExit;
    }
    else if ( err != NO_ERROR )
    {
        err = ERROR_INVALID_NAME;
        goto ErrorExit;
    }

    //
    // Test to see if there already was a entry for this print queue. If so,
    // we can now return with NO_ERROR since pNwPrinter and phServer are
    // now set.
    //
    if ( pNwPrinter )
    {
        if ( lpRemoteName )
        {
            FreeNwSplMem( lpRemoteName, dwBufSize );
        }

        *ppPrinter = pNwPrinter;

        return NO_ERROR;
    }

    //
    // The printer entry was not found in our list of printers in the
    // call to NwFindPrinterEntry. So, we must create one.
    //
    // First, verify access rights
    else
    {
        BYTE nQueueStatus;
        BYTE nJobCount;

        err = NwReadQueueCurrentStatus(*phServer, nQueueId, &nQueueStatus, &nJobCount);
        if(err != NO_ERROR)
        {
            err = NwCreateConnection( NULL,
                                      lpRemoteName,
                                      RESOURCETYPE_PRINT,
                                      NULL,
                                      NULL );
        }

        if ( ( err == ERROR_INVALID_PASSWORD ) ||
            ( err == ERROR_ACCESS_DENIED ) ||
            ( err == ERROR_NO_SUCH_USER ) )
        {
            err = ERROR_ACCESS_DENIED;
            goto ErrorExit;
        }
        else if ( err != NO_ERROR )
        {
            err = ERROR_INVALID_NAME;
            goto ErrorExit;
        }

    }

    if ( *ppPrinter = AllocNwSplMem( LMEM_ZEROINIT, sizeof(NWPRINTER) ))
    {
        if ( !( (*ppPrinter)->pszServer = AllocNwSplStr( pszServer )) )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        else if ( !( (*ppPrinter)->pszQueue = AllocNwSplStr( pszQueue )))
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if ( fCreatedNWConnection )
        {
             if ( !( (*ppPrinter)->pszUncConnection =
                                   AllocNwSplStr( lpRemoteName )) )
             {
                 err = ERROR_NOT_ENOUGH_MEMORY;
                 goto ErrorExit;
             }

             FreeNwSplMem( lpRemoteName, dwBufSize );
             lpRemoteName = NULL;
        }
        else
        {
            (*ppPrinter)->pszUncConnection = NULL;
        }

#if DBG
        IF_DEBUG(PRINT)
        {
            KdPrint(("*************CREATED PRINTER ENTRY: %ws\\%ws\n\n",
                    (*ppPrinter)->pszServer, (*ppPrinter)->pszQueue ));
        }
#endif

        (*ppPrinter)->nQueueId = nQueueId;
        (*ppPrinter)->pSpoolList = NULL;
        (*ppPrinter)->pNextPrinter = NwPrinterList;
        NwPrinterList = *ppPrinter;

        err = NO_ERROR;
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    if ( err == NO_ERROR )
        return err;

ErrorExit:

    if ( *phServer )
    {
        (VOID) NtClose( *phServer );
        *phServer = NULL;
    }

    if ( *ppPrinter )
    {
        if ( (*ppPrinter)->pszServer )
        {
            FreeNwSplStr( (*ppPrinter)->pszServer );
        }

        if ( (*ppPrinter)->pszQueue )
        {
            FreeNwSplStr( (*ppPrinter)->pszQueue );
        }

        if ( (*ppPrinter)->pszUncConnection )
        {
            (void) NwrDeleteConnection( NULL,
                                        (*ppPrinter)->pszUncConnection,
                                        FALSE );
            FreeNwSplStr( (*ppPrinter)->pszUncConnection );
        }

        FreeNwSplMem( *ppPrinter, sizeof( NWPRINTER));
        *ppPrinter = NULL;
    }

    if ( lpRemoteName )
    {
        FreeNwSplMem( lpRemoteName, dwBufSize );
    }

    return err;
}



VOID
NwRemovePrinterEntry(
    IN PNWPRINTER pPrinter
)
{
    PNWPRINTER pCur, pPrev = NULL;

    ASSERT( pPrinter->pSpoolList == NULL );
    pPrinter->pSpoolList = NULL;

    for ( pCur = NwPrinterList; pCur; pPrev = pCur, pCur = pCur->pNextPrinter )
    {
        if ( pCur == pPrinter )
        {
            if ( pPrev )
                pPrev->pNextPrinter = pCur->pNextPrinter;
            else
                NwPrinterList = pCur->pNextPrinter;
            break;
        }
    }

    ASSERT( pCur );

    pPrinter->pNextPrinter = NULL;
    FreeNwSplStr( pPrinter->pszServer );
    FreeNwSplStr( pPrinter->pszQueue );
    if ( pPrinter->pszUncConnection )
    {
        (void) NwrDeleteConnection( NULL,
                                    pPrinter->pszUncConnection,
                                    FALSE );
        FreeNwSplStr( pPrinter->pszUncConnection );
    }
    FreeNwSplMem( pPrinter, sizeof( NWPRINTER));
}



VOID
NWWKSTA_PRINTER_CONTEXT_rundown(
    IN NWWKSTA_PRINTER_CONTEXT hPrinter
    )
/*++

Routine Description:

    This function is called by RPC when a client terminates with an
    opened handle.  This allows us to clean up and deallocate any context
    data associated with the handle.

Arguments:

    hPrinter - Supplies the opened handle

Return Value:

    None.

--*/
{
    (void) NwrClosePrinter(&hPrinter);
}



LPWSTR
NwGetUncObjectName(
    IN LPWSTR ContainerName
)
{
    WORD length = 2;
    WORD totalLength = (WORD) wcslen( ContainerName );

    if ( totalLength < 2 )
        return 0;

    while ( length < totalLength )
    {
        if ( ContainerName[length] == L'.' )
            ContainerName[length] = L'\0';

        length++;
    }

    length = 2;

    while ( length < totalLength && ContainerName[length] != L'\\' )
    {
        length++;
    }

    ContainerName[length + 2] = L'\\';
    ContainerName[length + 3] = L'\\';

    return (ContainerName + length + 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwasync.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwipx.h

Abstract:

    Contains function prototypes for VWASYNC.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

DWORD
VwAesThread(
    IN LPVOID Parameters
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwasync.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwasync.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains Asyncrhonous Event Scheduler (thread)

    Contents:
        VwAesThread
        (CheckPendingIpxRequests)

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// private routine prototypes
//

PRIVATE
VOID
CheckPendingIpxRequests(
    VOID
    );

//
// global data
//

WORD AesTickCount;

//
// functions
//


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
DWORD
VwAesThread(
    IN LPVOID Parameters
    )

/*++

Routine Description:

    Provides the functionality of the Asynchronous Event Scheduler (AES) in the
    Netware world:

        - updates the tick count
        - completes any matured timer events
        - checks any pending requests and schedules the next action

    This thread wakes up every PC tick (1/18 second)

Arguments:

    Parameters  - unused

Return Value:

    DWORD
        0

--*/

{
    BOOL fOperationPerformed = FALSE ;
    static int n = 1 ;

    UNREFERENCED_PARAMETER(Parameters);

    while (TRUE)
    {
        //
        // we will always yield in this loop to be friendly to others,
        // but occasionally we will forcefully do a non zero sleep for
        // lower priority threads to run.
        //
        if ((n % 100) == 0)
        {
            Sleep(ONE_TICK) ;
            n = 1 ;
        }
        if (!fOperationPerformed && ((n % 4) == 0))
        {
            Sleep(10) ;
            n++ ;
        }
        else
        {
            Sleep(0) ;
            n++ ;
        }

        ++AesTickCount;
        ScanTimerList();
        CheckPendingIpxRequests();
        CheckPendingSpxRequests(&fOperationPerformed);
    }

    return 0;   // compiler-pacifier
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif



PRIVATE
VOID
CheckPendingIpxRequests(
    VOID
    )

/*++

Routine Description:

    Polls the opened, active non-blocking IPX sockets to see if there is anything
    to do (data to receive, availability to send, timeouts)

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPSOCKET_INFO pActiveSocket = NULL;

    //
    // search SOCKET_INFO structures for something to do. Could do select()
    // but we have most of the info anyway. We use the BFI filter mechanism
    //

    while (pActiveSocket = FindActiveSocket(pActiveSocket)) {
        if (pActiveSocket->Flags & SOCKET_FLAG_SENDING) {
            IpxSendNext(pActiveSocket);
        }
        if (pActiveSocket->Flags & SOCKET_FLAG_LISTENING) {
            IpxReceiveNext(pActiveSocket);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vw.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vw.h

Abstract:

    Top-level include file for VWIPXSPX DLL. Pulls in all other required header
    files

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

//
// all include files required by VWIPXSPX.DLL
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define FD_SETSIZE MAX_OPEN_SOCKETS
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <vddsvc.h> // GetVDMAddress, GetVDMPointer
#undef getMSW

extern  WORD getMSW(VOID);

#include "vwvdm.h"
#include "vwdll.h"
#include "vwipxspx.h"
#include "vwasync.h"
#include "vwmisc.h"
#include "vwipx.h"
#include "vwspx.h"
#include "socket.h"
#include "util.h"
#include "vwdebug.h"
#include "vwinapi.h"
#include "vwint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwdebug.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwdebug.c

Abstract:

    Contains debug routines for VWIPXSPX.DLL

    Contents:
        VwDebugStart
        VwDebugEnd
        VwDebugPrint
        VwDumpData
        VwDumpEcb
        VwDumpFragment
        VwDumpPacketHeader
        VwDumpXecb
        VwDumpSocketInfo
        VwDumpConnectionInfo
        VwDumpConnectionStats
        VwLog
        CheckInterrupts

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    User-mode Win32

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

#if DBG

//
// private prototypes
//

int PokeLevelString(LPSTR, DWORD, DWORD, LPSTR);
LPSTR StripNameFromPath(LPSTR);

//
// private data
//

DWORD VwDebugFlags = 0;
DWORD VwDebugFunctions = 0;
DWORD VwShow = SHOW_ECBS | SHOW_HEADERS;
DWORD VwDebugLevel = IPXDBG_MIN_LEVEL;
DWORD VwDebugDump = 0;
BOOL VwDebugInitialized = FALSE;
FILE* hVwDebugLog = NULL;
DWORD DebugFlagsEx = 0 ;

//
// functions
//

VOID VwDebugStart() {

    //
    // a little run-time diagnostication, madam?
    //

    LPSTR ptr;

    if (VwDebugInitialized) {
        return;
    }

    //
    // override VwDebugFlags from VWFLAGS environment variable
    //

    if (ptr = getenv("VWFLAGS")) {
        VwDebugFlags = (DWORD)strtoul(ptr, NULL, 0);
    }
    if (ptr = getenv("VWFUNCS")) {
        VwDebugFunctions = (DWORD)strtoul(ptr, NULL, 0);
    }
    if (ptr = getenv("VWSHOW")) {
        VwShow = (DWORD)strtoul(ptr, NULL, 0);
    }
    if (ptr = getenv("VWLEVEL")) {
        VwDebugLevel = strtoul(ptr, NULL, 0);
        if (VwDebugLevel > IPXDBG_MAX_LEVEL) {
            VwDebugLevel = IPXDBG_MAX_LEVEL;
        }
    }
    if (ptr = getenv("VWDUMP")) {
        VwDebugDump = strtoul(ptr, NULL, 0);
    }
    IF_DEBUG(TO_FILE) {
        if ((hVwDebugLog = fopen(VWDEBUG_FILE, "w+")) == NULL) {
            VwDebugFlags &= ~DEBUG_TO_FILE;
        } else {

#if 0

            char currentDirectory[256];
            int n;

            currentDirectory[0] = 0;
            if (n = GetCurrentDirectory(sizeof(currentDirectory), currentDirectory)) {
                if (currentDirectory[n-1] == '\\') {
                    currentDirectory[n-1] = 0;
                }
            }

            DbgPrint("VWIPXSPX: Writing debug output to %s\\" VWDEBUG_FILE "\n", currentDirectory);
#endif

        }
    }
    VwDebugInitialized = TRUE;
}

VOID VwDebugEnd() {
    IF_DEBUG(TO_FILE) {
        fflush(hVwDebugLog);
        fclose(hVwDebugLog);
    }
}

VOID VwDebugPrint(LPSTR Module, DWORD Line, DWORD Function, DWORD Level, LPSTR Format, ...) {

    char buf[1024];
    va_list p;

    IF_DEBUG(NOTHING) {
        return;
    }

    //
    // only log something if we are tracking this Function and Level is above
    // (or equal to) the filter cut-off or Level >= minimum alert level (error)
    //

    if (((Function & VwDebugFunctions) && (Level >= VwDebugLevel)) || (Level >= IPXDBG_LEVEL_ERROR)) {
        va_start(p, Format);
        vsprintf(buf+PokeLevelString(Module, Line, Level, buf), Format, p);
        VwLog(buf);
        va_end(p);
    }
}

int PokeLevelString(LPSTR Module, DWORD Line, DWORD Level, LPSTR Buffer) {

    int length;
    static char levelString[4] = " : ";
    char level;

    switch (Level) {
    case IPXDBG_LEVEL_INFO:
        level = 'I';
        break;

    case IPXDBG_LEVEL_WARNING:
        level = 'W';
        break;

    case IPXDBG_LEVEL_ERROR:
        level = 'E';
        break;

    case IPXDBG_LEVEL_FATAL:
        level = 'F';
        break;
    }

    levelString[0] = level;
    strcpy(Buffer, levelString);
    length = strlen(levelString);

    if (Level >= IPXDBG_LEVEL_ERROR) {
        length += sprintf(Buffer + length, "%s [% 5d]: ", StripNameFromPath(Module), Line);
    }

    return length;
}

LPSTR StripNameFromPath(LPSTR Path) {

    LPSTR p;

    p = strrchr(Path, '\\');
    return p ? p+1 : Path;
}

VOID VwDumpData(ULPBYTE Address, WORD Seg, WORD Off, BOOL InVdm, WORD Size) {

    char buf[128];
    int i, len;

    IF_NOT_DEBUG(DATA) {
        return;
    }

    while (Size) {
        len = min(Size, 16);
        if (InVdm) {
            sprintf(buf, "%04x:%04x ", Seg, Off);
        } else {
            sprintf(buf, "%p  ", Address);
        }
        for (i = 0; i < len; ++i) {
            sprintf(&buf[10+i*3], "%02.2x ", Address[i] & 0xff);
        }
        for (i = len; i < 17; ++i) {
            strcat(buf, "   ");
        }
        for (i = 0; i < len; ++i) {

            char ch;

            ch = Address[i];
            buf[61+i] =  ((ch < 32) || (ch > 127)) ? '.' : ch;
        }
        buf[61+i++] = '\n';
        buf[61+i] = 0;
        VwLog(buf);
        Address += len;
        Size -= (WORD)len;
        Off += (WORD)len;
    }
    VwLog("\n");
}

VOID VwDumpEcb(LPECB pEcb, WORD Seg, WORD Off, BYTE Type, BOOL Frags, BOOL Data, BOOL Mode) {

    char buf[512];
    int n;
    char* bufptr;

    IF_NOT_DEBUG(ECB) {
        return;
    }

    IF_NOT_SHOW(ECBS) {
        VwDumpData((ULPBYTE)pEcb,
                   Seg,
                   Off,
                   TRUE,
                   (WORD)((Type == ECB_TYPE_AES)
                        ? sizeof(AES_ECB)
                        : (sizeof(IPX_ECB) + sizeof(FRAGMENT) * (pEcb->FragmentCount - 1)))
                   );
        return;
    }

    n = sprintf(buf,
                "\n"
                "%s ECB @ %04x:%04x:\n"
                "LinkAddress      %04x:%04x\n"
                "EsrAddress       %04x:%04x\n"
                "InUse            %02x\n",
                (Type == ECB_TYPE_AES)
                    ? "AES"
                    : (Type == ECB_TYPE_IPX)
                        ? "IPX"
                        : "SPX",
                Seg,
                Off,
                GET_SEGMENT(&pEcb->LinkAddress),
                GET_OFFSET(&pEcb->LinkAddress),
                GET_SEGMENT(&pEcb->EsrAddress),
                GET_OFFSET(&pEcb->EsrAddress),
                pEcb->InUse
                );
    bufptr = buf + n;
    if (Type == ECB_TYPE_AES) {
        sprintf(bufptr,
                "AesWorkspace     %02x-%02x-%02x-%02x-%02x\n",
                ((LPAES_ECB)pEcb)->AesWorkspace[0] & 0xff,
                ((LPAES_ECB)pEcb)->AesWorkspace[1] & 0xff,
                ((LPAES_ECB)pEcb)->AesWorkspace[2] & 0xff,
                ((LPAES_ECB)pEcb)->AesWorkspace[3] & 0xff,
                ((LPAES_ECB)pEcb)->AesWorkspace[4] & 0xff
                );
    } else {
        sprintf(bufptr,
                "CompletionCode   %02x\n"
                "SocketNumber     %04x\n"
                "IpxWorkspace     %08x\n"
                "DriverWorkspace  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"
                "ImmediateAddress %02x-%02x-%02x-%02x-%02x-%02x\n"
                "FragmentCount    %04x\n",
                pEcb->CompletionCode,
                B2LW(pEcb->SocketNumber),
                pEcb->IpxWorkspace,
                pEcb->DriverWorkspace[0] & 0xff,
                pEcb->DriverWorkspace[1] & 0xff,
                pEcb->DriverWorkspace[2] & 0xff,
                pEcb->DriverWorkspace[3] & 0xff,
                pEcb->DriverWorkspace[4] & 0xff,
                pEcb->DriverWorkspace[5] & 0xff,
                pEcb->DriverWorkspace[6] & 0xff,
                pEcb->DriverWorkspace[7] & 0xff,
                pEcb->DriverWorkspace[8] & 0xff,
                pEcb->DriverWorkspace[9] & 0xff,
                pEcb->DriverWorkspace[10] & 0xff,
                pEcb->DriverWorkspace[11] & 0xff,
                pEcb->ImmediateAddress[0] & 0xff,
                pEcb->ImmediateAddress[1] & 0xff,
                pEcb->ImmediateAddress[2] & 0xff,
                pEcb->ImmediateAddress[3] & 0xff,
                pEcb->ImmediateAddress[4] & 0xff,
                pEcb->ImmediateAddress[5] & 0xff,
                pEcb->FragmentCount
                );
    }

    VwLog(buf);

    if ((Type != ECB_TYPE_AES) && Frags) {

        ASSERT(pEcb->FragmentCount < 10);

        VwDumpFragment(pEcb->FragmentCount,
                       (LPFRAGMENT)(pEcb + 1),
                       Type,
                       Data,
                       Mode
                       );
    }
}

VOID VwDumpFragment(WORD Count, LPFRAGMENT pFrag, BYTE Type, BOOL Data, BOOL Mode) {

    char buf[256];
    int i;

    IF_NOT_DEBUG(FRAGMENTS) {
        return;
    }

    for (i = 0; i < Count; ++i) {
        sprintf(buf,
                "Fragment %d:\n"
                "    Address      %04x:%04x\n"
                "    Length       %04x\n",
                i + 1,
                GET_SEGMENT(&pFrag->Address),
                GET_OFFSET(&pFrag->Address),
                pFrag->Length
                );
        VwLog(buf);
        if (Data) {

            ULPBYTE ptr;
            WORD size;
            WORD offset;

            ptr = GET_FAR_POINTER(&pFrag->Address, Mode);
            size = pFrag->Length;
            offset = GET_OFFSET(&pFrag->Address);

            //
            // this allows us to show headers vs. raw data
            //

            IF_SHOW(HEADERS) {
                if (i == 0) {
                    VwDumpPacketHeader(ptr, Type);

                    if (Type == ECB_TYPE_IPX) {
                        ptr += IPX_HEADER_LENGTH;
                        size -= IPX_HEADER_LENGTH;
                        offset += IPX_HEADER_LENGTH;
                    } else {
                        ptr += SPX_HEADER_LENGTH;
                        size -= SPX_HEADER_LENGTH;
                        offset += SPX_HEADER_LENGTH;
                    }
                }
            }

            VwDumpData(ptr,
                       GET_SEGMENT(&pFrag->Address),
                       offset,
                       TRUE,
                       size
                       );
        }
        ++pFrag;
    }
}

VOID VwDumpPacketHeader(ULPBYTE pPacket, BYTE Type) {

    char buf[512];

    IF_NOT_DEBUG(HEADERS) {
        return;
    }

    sprintf(buf,
            "Checksum         %04x\n"
            "Length           %04x\n"
            "TransportControl %02x\n"
            "PacketType       %02x\n"
            "Destination      %02x-%02x-%02x-%02x : %02x-%02x-%02x-%02x-%02x-%02x : %04x\n"
            "Source           %02x-%02x-%02x-%02x : %02x-%02x-%02x-%02x-%02x-%02x : %04x\n",
            ((LPIPX_PACKET)pPacket)->Checksum,
            B2LW(((LPIPX_PACKET)pPacket)->Length),
            ((LPIPX_PACKET)pPacket)->TransportControl,
            ((LPIPX_PACKET)pPacket)->PacketType,
            ((LPIPX_PACKET)pPacket)->Destination.Net[0] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Net[1] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Net[2] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Net[3] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[0] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[1] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[2] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[3] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[4] & 0xff,
            ((LPIPX_PACKET)pPacket)->Destination.Node[5] & 0xff,
            B2LW(((LPIPX_PACKET)pPacket)->Destination.Socket),
            ((LPIPX_PACKET)pPacket)->Source.Net[0] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Net[1] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Net[2] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Net[3] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[0] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[1] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[2] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[3] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[4] & 0xff,
            ((LPIPX_PACKET)pPacket)->Source.Node[5] & 0xff,
            B2LW(((LPIPX_PACKET)pPacket)->Source.Socket)
            );
    VwLog(buf);
    if (Type == ECB_TYPE_SPX) {
        sprintf(buf,
                "ConnectControl   %02x\n"
                "DataStreamType   %02x\n"
                "SourceConnectId  %04x\n"
                "DestConnectId    %04x\n"
                "SequenceNumber   %04x\n"
                "AckNumber        %04x\n"
                "AllocationNumber %04x\n",
                ((LPSPX_PACKET)pPacket)->ConnectionControl,
                ((LPSPX_PACKET)pPacket)->DataStreamType,
                B2LW(((LPSPX_PACKET)pPacket)->SourceConnectId),
                B2LW(((LPSPX_PACKET)pPacket)->DestinationConnectId),
                B2LW(((LPSPX_PACKET)pPacket)->SequenceNumber),
                B2LW(((LPSPX_PACKET)pPacket)->AckNumber),
                B2LW(((LPSPX_PACKET)pPacket)->AllocationNumber)
                );
        VwLog(buf);
    }
    VwLog("\n");
}

VOID VwDumpXecb(LPXECB pXecb) {

    char buf[512];

    IF_NOT_DEBUG(XECB) {
        return;
    }

    sprintf(buf,
            "XECB @ %p:\n"
            "Next           %p\n"
            "Ecb            %p\n"
            "EcbAddress     %08x\n"
            "EsrAddress     %08x\n"
            "Buffer         %p\n"
            "Data           %p\n"
            "FrameLength    %04x\n"
            "ActualLength   %04x\n"
            "Length         %04x\n"
            "Ticks          %04x\n"
            "SocketNumber   %04x\n"
            "Owner          %04x\n"
            "TaskId         %08x\n"
            "Flags          %08x\n"
            "QueueId        %08x\n"
            "OwningObject   %p\n"
            "RefCount       %08x\n",
            pXecb,
            pXecb->Next,
            pXecb->Ecb,
            pXecb->EcbAddress,
            pXecb->EsrAddress,
            pXecb->Buffer,
            pXecb->Data,
            pXecb->FrameLength,
            pXecb->ActualLength,
            pXecb->Length,
            pXecb->Ticks,
            B2LW(pXecb->SocketNumber),
            pXecb->Owner,
            pXecb->TaskId,
            pXecb->Flags,
            pXecb->QueueId,
            pXecb->OwningObject,
            pXecb->RefCount
            );
    VwLog(buf);
}

VOID VwDumpSocketInfo(LPSOCKET_INFO pSocketInfo) {

    char buf[512];

    IF_NOT_DEBUG(SOCKINFO) {
        return;
    }

    sprintf(buf,
            "SOCKET_INFO @ %p:\n"
            "Next           %p\n"
            "SocketNumber   %04x\n"
            "Owner          %04x\n"
            "TaskId         %08x\n"
            "Socket         %08x\n"
            "Flags          %08x\n"
            "LongLived      %d\n"
            "SpxSocket      %d\n"
            "PendingSends   %08x\n"
            "PendingListens %08x\n"
            "ListenQueue    %p, %p\n"
            "SendQueue      %p, %p\n"
            "HeaderQueue    %p, %p\n"
            "Connections    %p\n",
            pSocketInfo,
            pSocketInfo->Next,
            B2LW(pSocketInfo->SocketNumber),
            pSocketInfo->Owner,
            pSocketInfo->TaskId,
            pSocketInfo->Socket,
            pSocketInfo->Flags,
            pSocketInfo->LongLived,
            pSocketInfo->SpxSocket,
            pSocketInfo->PendingSends,
            pSocketInfo->PendingListens,
            pSocketInfo->ListenQueue.Head,
            pSocketInfo->ListenQueue.Tail,
            pSocketInfo->SendQueue.Head,
            pSocketInfo->SendQueue.Tail,
            pSocketInfo->HeaderQueue.Head,
            pSocketInfo->HeaderQueue.Tail,
            pSocketInfo->Connections
            );
    VwLog(buf);
}

VOID VwDumpConnectionInfo(LPCONNECTION_INFO pConnectionInfo) {

    char buf[512];

    IF_NOT_DEBUG(CONNINFO) {
        return;
    }

    sprintf(buf,
            "CONNECTION_INFO @ %p:\n"
            "Next           %p\n"
            "List           %p\n"
            "OwningSocket   %p\n"
            "Socket         %08x\n"
            "TaskId         %08x\n"
            "ConnectionId   %04x\n"
            "Flags          %02x\n"
            "State          %02x\n"
            "ConnectQueue   %p, %p\n"
            "AcceptQueue    %p, %p\n"
            "SendQueue      %p, %p\n"
            "ListenQueue    %p, %p\n",
            pConnectionInfo,
            pConnectionInfo->Next,
            pConnectionInfo->List,
            pConnectionInfo->OwningSocket,
            pConnectionInfo->Socket,
            pConnectionInfo->TaskId,
            pConnectionInfo->ConnectionId,
            pConnectionInfo->Flags,
            pConnectionInfo->State,
            pConnectionInfo->ConnectQueue.Head,
            pConnectionInfo->ConnectQueue.Tail,
            pConnectionInfo->AcceptQueue.Head,
            pConnectionInfo->AcceptQueue.Tail,
            pConnectionInfo->SendQueue.Head,
            pConnectionInfo->SendQueue.Tail,
            pConnectionInfo->ListenQueue.Head,
            pConnectionInfo->ListenQueue.Tail
            );
    VwLog(buf);
}

VOID VwDumpConnectionStats(LPSPX_CONNECTION_STATS pStats) {

    char buf[1024];

    IF_NOT_DEBUG(STATS) {
        return;
    }

    sprintf(buf,
            "State                      %02x\n"
            "WatchDog                   %02x\n"
            "LocalConnectionId          %04x\n"
            "RemoteConnectionId         %04x\n"
            "LocalSequenceNumber        %04x\n"
            "LocalAckNumber             %04x\n"
            "LocalAllocNumber           %04x\n"
            "RemoteAckNumber            %04x\n"
            "RemoteAllocNumber          %04x\n"
            "LocalSocket                %04x\n"
            "ImmediateAddress           %02x-%02x-%02x-%02x-%02x-%02x\n"
            "RemoteNetwork              %02x-%02x-%02x-%02x\n"
            "RemoteNode                 %02x-%02x-%02x-%02x-%02x-%02x\n"
            "RemoteSocket               %04x\n"
            "RetransmissionCount        %04x\n"
            "EstimatedRoundTripDelay    %04x\n"
            "RetransmittedPackets       %04x\n",
            pStats->State,
            pStats->WatchDog,
            B2LW(pStats->LocalConnectionId),
            B2LW(pStats->RemoteConnectionId),
            B2LW(pStats->LocalSequenceNumber),
            B2LW(pStats->LocalAckNumber),
            B2LW(pStats->LocalAllocNumber),
            B2LW(pStats->RemoteAckNumber),
            B2LW(pStats->RemoteAllocNumber),
            B2LW(pStats->LocalSocket),
            pStats->ImmediateAddress[0] & 0xff,
            pStats->ImmediateAddress[1] & 0xff,
            pStats->ImmediateAddress[2] & 0xff,
            pStats->ImmediateAddress[3] & 0xff,
            pStats->ImmediateAddress[4] & 0xff,
            pStats->ImmediateAddress[5] & 0xff,
            pStats->RemoteNetwork[0] & 0xff,
            pStats->RemoteNetwork[1] & 0xff,
            pStats->RemoteNetwork[2] & 0xff,
            pStats->RemoteNetwork[3] & 0xff,
            pStats->RemoteNode[0] & 0xff,
            pStats->RemoteNode[1] & 0xff,
            pStats->RemoteNode[2] & 0xff,
            pStats->RemoteNode[3] & 0xff,
            pStats->RemoteNode[4] & 0xff,
            pStats->RemoteNode[5] & 0xff,
            B2LW(pStats->RemoteSocket),
            B2LW(pStats->RetransmissionCount),
            B2LW(pStats->EstimatedRoundTripDelay),
            B2LW(pStats->RetransmittedPackets)
            );

    VwLog(buf);
}

VOID VwLog(LPSTR buf) {

    IF_DEBUG(NOTHING) {
        return;
    }

    IF_DEBUG(TO_FILE) {
        fputs(buf, hVwDebugLog);
        IF_DEBUG(FLUSH) {
            fflush(hVwDebugLog);
        }
    } else IF_DEBUG(TO_DBG) {
        OutputDebugString(buf);
    }
}

VOID CheckInterrupts(LPSTR name) {

    IF_DEBUG(CHECK_INT) {

        LPWORD pDosIntFlag = (LPWORD)GET_POINTER(0x40, 0x314, 2, FALSE);

        if ((getIF() == 0) || !(*pDosIntFlag & 0x200)) {
            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_ERROR,
                        "*** CheckInterrupts: ints off in %s (IF=%d, 40:314=%04x)\n",
                        name,
                        getIF(),
                        *pDosIntFlag
                        ));
        }
    }
}

extern LPCONNECTION_INFO ConnectionList ;
extern LPSOCKET_INFO SocketList ;

VOID VwDumpAll(VOID)
{
    char buf[512];
    LPCONNECTION_INFO pConnectionInfo;
    LPSOCKET_INFO pSocketInfo;

    if (DebugFlagsEx == 0)
        return ;

    DebugFlagsEx = 0 ;

    RequestMutex();


    pSocketInfo = SocketList;
    while (pSocketInfo) {

        LPXECB pXecb ;

        if (!(pSocketInfo->SpxSocket)) {
            pSocketInfo = pSocketInfo->Next;
            continue ;
        }

        sprintf(buf,
            "%sSOCKET_INFO @ %p:\n"
            "    SocketNumber   %04x\n"
            "    Owner          %04x\n"
            "    TaskId         %08x\n"
            "    Socket         %08x\n"
            "    Flags          %08x\n"
            "    LongLived      %d\n"
            "    PendingSends   %08x\n"
            "    PendingListens %08x\n"
            "    ListenQueue    %p, %p\n"
            "    SendQueue      %p, %p\n"
            "    HeaderQueue    %p, %p\n"
            "    Connections    %p\n\n",
            (pSocketInfo->SpxSocket)?"SPX ":"",
            pSocketInfo,
            B2LW(pSocketInfo->SocketNumber),
            pSocketInfo->Owner,
            pSocketInfo->TaskId,
            pSocketInfo->Socket,
            pSocketInfo->Flags,
            pSocketInfo->LongLived,
            pSocketInfo->PendingSends,
            pSocketInfo->PendingListens,
            pSocketInfo->ListenQueue.Head,
            pSocketInfo->ListenQueue.Tail,
            pSocketInfo->SendQueue.Head,
            pSocketInfo->SendQueue.Tail,
            pSocketInfo->HeaderQueue.Head,
            pSocketInfo->HeaderQueue.Tail,
            pSocketInfo->Connections
            );
        OutputDebugString(buf);

        pConnectionInfo = pSocketInfo->Connections ;

        while(pConnectionInfo) {
            sprintf(buf,
                "CONNECTION_INFO @ %p:\n"
                "    List           %p\n"
                "    OwningSocket   %p\n"
                "    Socket         %08x\n"
                "    TaskId         %08x\n"
                "    ConnectionId   %04x\n"
                "    Flags          %02x\n"
                "    State          %02x\n"
                "    ConnectQueue   %p, %p\n"
                "    AcceptQueue    %p, %p\n"
                "    SendQueue      %p, %p\n"
                "    ListenQueue    %p, %p\n\n",
                pConnectionInfo,
                pConnectionInfo->List,
                pConnectionInfo->OwningSocket,
                pConnectionInfo->Socket,
                pConnectionInfo->TaskId,
                pConnectionInfo->ConnectionId,
                pConnectionInfo->Flags,
                pConnectionInfo->State,
                pConnectionInfo->ConnectQueue.Head,
                pConnectionInfo->ConnectQueue.Tail,
                pConnectionInfo->AcceptQueue.Head,
                pConnectionInfo->AcceptQueue.Tail,
                pConnectionInfo->SendQueue.Head,
                pConnectionInfo->SendQueue.Tail,
                pConnectionInfo->ListenQueue.Head,
                pConnectionInfo->ListenQueue.Tail
                );
            OutputDebugString(buf);
            pConnectionInfo = pConnectionInfo->Next ;
        }

        pXecb = pSocketInfo->ListenQueue.Head ;
        while(pXecb) {
            sprintf(buf,
                    "    XECB @ %p: (Ecb %p)\n"
                    "        EcbAddress/EsrAddress  %08x  %08x\n"
                    "        Flags/RefCount         %08x  %08x\n"
                    "        Buffer/QueueId         %p  %08x\n"
                    "        OwningObject           %p\n",
                    pXecb,
                    pXecb->Ecb,
                    pXecb->EcbAddress,
                    pXecb->EsrAddress,
                    pXecb->Flags,
                    pXecb->RefCount,
                    pXecb->Buffer,
                    pXecb->QueueId,
                    pXecb->OwningObject
                    );
            OutputDebugString(buf);
            pXecb =  pXecb->Next ;
        }
        pSocketInfo = pSocketInfo->Next;
    }
    ReleaseMutex();
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwdll.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwdll.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    VDD functions for DOS/WOW IPX/SPX support

    Contents:
        VwDllEntryPoint
        VwInitialize
        VWinInitialize
        VwDispatcher
        VwInvalidFunction

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

#include <overflow.h>


//
// private prototypes
//

PRIVATE
VOID
VwInvalidFunction(
    VOID
    );

//
// private data
//

PRIVATE
VOID
(*VwDispatchTable[])(VOID) = {
    VwIPXOpenSocket,                // 0x00
    VwIPXCloseSocket,               // 0x01
    VwIPXGetLocalTarget,            // 0x02
    VwIPXSendPacket,                // 0x03
    VwIPXListenForPacket,           // 0x04
    VwIPXScheduleIPXEvent,          // 0x05
    VwIPXCancelEvent,               // 0x06
    VwIPXScheduleAESEvent,          // 0x07
    VwIPXGetIntervalMarker,         // 0x08
    VwIPXGetInternetworkAddress,    // 0x09
    VwIPXRelinquishControl,         // 0x0A
    VwIPXDisconnectFromTarget,      // 0x0B
    VwInvalidFunction,              // 0x0C
    VwInvalidFunction,              // 0x0D     old-style GetMaxPacketSize
    VwInvalidFunction,              // 0x0E
    VwInvalidFunction,              // 0x0F     internal send packet function
    VwSPXInitialize,                // 0x10
    VwSPXEstablishConnection,       // 0x11
    VwSPXListenForConnection,       // 0x12
    VwSPXTerminateConnection,       // 0x13
    VwSPXAbortConnection,           // 0x14
    VwSPXGetConnectionStatus,       // 0x15
    VwSPXSendSequencedPacket,       // 0x16
    VwSPXListenForSequencedPacket,  // 0x17
    VwInvalidFunction,              // 0x18
    VwInvalidFunction,              // 0x19
    VwIPXGetMaxPacketSize,          // 0x1A
    VwInvalidFunction,              // 0x1B
    VwInvalidFunction,              // 0x1C
    VwInvalidFunction,              // 0x1D
    VwInvalidFunction,              // 0x1E
    VwIPXGetInformation,            // 0x1F
    VwIPXSendWithChecksum,          // 0x20
    VwIPXGenerateChecksum,          // 0x21
    VwIPXVerifyChecksum             // 0x22
};

#define MAX_IPXSPX_FUNCTION LAST_ELEMENT(VwDispatchTable)

WSADATA WsaData = {0};
HANDLE hAesThread = NULL;

//
// global data
//

SOCKADDR_IPX MyInternetAddress;
WORD MyMaxPacketSize;
int Ica;
BYTE IcaLine;

//
// not-really-global data
//

extern CRITICAL_SECTION SerializationCritSec;
extern CRITICAL_SECTION AsyncCritSec;

//
// functions
//


BOOL
WINAPI
VwDllEntryPoint(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    Called when the process attaches (LoadLibrary/init) and detaches (FreeLibrary/
    process termination) from this DLL

    Attach:
        initialize Winsock DLL
        get internet address for this station
        get maximum packet size supported by transport (IPX)
        create AES thread

    Detach:
        terminate Winsock DLL

Arguments:

    DllHandle   - unused
    Reason      - checked for process attach/detach
    Context     - unused

Return Value:

    BOOLEAN

--*/

{
    DWORD aesThreadId;  // unused outside of this function

    static BOOL CriticalSectionsAreInitialized = FALSE;

    UNREFERENCED_PARAMETER(DllHandle);
    UNREFERENCED_PARAMETER(Context);

    IPXDBGSTART();

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwDllEntryPoint: %s\n",
                Reason == DLL_PROCESS_ATTACH ? "DLL_PROCESS_ATTACH"
                : Reason == DLL_PROCESS_DETACH ? "DLL_PROCESS_DETACH"
                : Reason == DLL_THREAD_ATTACH ? "DLL_THREAD_ATTACH"
                : Reason == DLL_THREAD_DETACH ? "DLL_THREAD_DETACH"
                : "?"
                ));

    if (Reason == DLL_PROCESS_ATTACH) {

        int err;

        //
        // TRACKING: get ICA values from new VDD service. Right now we grab
        // line 4 on the slave (base = 0x70, modifier = 0x03)
        //

        Ica = ICA_SLAVE;
        IcaLine = 3;

        err = WSAStartup(MAKEWORD(1, 1), &WsaData);
        if (err) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "VwDllEntryPoint: WSAStartup() returns %d\n",
                        err
                        ));

            return FALSE;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "VwDllEntryPoint: WsaData:\n"
                         "\twVersion       : 0x%04x\n"
                         "\twHighVersion   : 0x%04x\n"
                         "\tszDescription  : \"%s\"\n"
                         "\tszSystemStatus : \"%s\"\n"
                         "\tiMaxSockets    : %d\n"
                         "\tiMaxUdpDg      : %d\n"
                         "\tlpVendorInfo   : 0x%08x\n",
                         WsaData.wVersion,
                         WsaData.wHighVersion,
                         WsaData.szDescription,
                         WsaData.szSystemStatus,
                         WsaData.iMaxSockets,
                         WsaData.iMaxUdpDg,
                         WsaData.lpVendorInfo
                         ));

        }

        //
        // retrieve the internet address for this station. Used in
        // IPXGetInternetworkAddress() and IPXSendPacket()
        //

        err = GetInternetAddress(&MyInternetAddress);
        if (err) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "VwDllEntryPoint: GetInternetAddress() returns %d\n",
                        WSAGetLastError()
                        ));

            goto attach_error_exit;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "VwDllEntryPoint: MyInternetAddress:\n"
                        "\tNet  : %02.2x-%02.2x-%02.2x-%02.2x\n"
                        "\tNode : %02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x\n",
                        MyInternetAddress.sa_netnum[0] & 0xff,
                        MyInternetAddress.sa_netnum[1] & 0xff,
                        MyInternetAddress.sa_netnum[2] & 0xff,
                        MyInternetAddress.sa_netnum[3] & 0xff,
                        MyInternetAddress.sa_nodenum[0] & 0xff,
                        MyInternetAddress.sa_nodenum[1] & 0xff,
                        MyInternetAddress.sa_nodenum[2] & 0xff,
                        MyInternetAddress.sa_nodenum[3] & 0xff,
                        MyInternetAddress.sa_nodenum[4] & 0xff,
                        MyInternetAddress.sa_nodenum[5] & 0xff
                        ));

        }

        //
        // get the maximum packet size supported by IPX. Used in
        // IPXGetMaxPacketSize()
        //

        err = GetMaxPacketSize(&MyMaxPacketSize);
        if (err) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "VwDllEntryPoint: GetMaxPacketSize() returns %d\n",
                        WSAGetLastError()
                        ));

            goto attach_error_exit;
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_INFO,
                        "VwDllEntryPoint: GetMaxPacketSize: %04x (%d)\n",
                        MyMaxPacketSize,
                        MyMaxPacketSize
                        ));

        }

        hAesThread = CreateThread(NULL,
                                  0,
                                  (LPTHREAD_START_ROUTINE)VwAesThread,
                                  NULL,
                                  0,
                                  &aesThreadId
                                  );
        if (hAesThread == NULL) {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_ANY,
                        IPXDBG_LEVEL_FATAL,
                        "VwDllEntryPoint: CreateThread() returns %d\n",
                        GetLastError()
                        ));

            goto attach_error_exit;
        }

        //
        // finally initialize any critical sections
        //

        InitializeCriticalSection(&SerializationCritSec);
        InitializeCriticalSection(&AsyncCritSec);
        CriticalSectionsAreInitialized = TRUE;
    } else if (Reason == DLL_PROCESS_DETACH) {
        if (hAesThread != NULL) {
            WaitForSingleObject(hAesThread, ONE_TICK * 2);
            CloseHandle(hAesThread);
        }

        WSACleanup();

        if (CriticalSectionsAreInitialized) {
            DeleteCriticalSection(&SerializationCritSec);
            DeleteCriticalSection(&AsyncCritSec);
        }

        IPXDBGEND();
    }
    return TRUE;

attach_error_exit:

    //
    // here if any fatal errors on process attach after successfully performing
    // WSAStartup
    //

    WSACleanup();
    return FALSE;
}

BYTE
VWinInitialize(
    VOID
    )
/*++

Routine Description:

    Called by interface when nwipxspx.dll is loaded. We
    return the IRQ value.

Arguments:

    None.

Return Value:

    The IRQ value.

--*/

{
    return 0x73;
}



VOID
VwInitialize(
    VOID
    )

/*++

Routine Description:

    Called by VDD interface when DLL loaded via call to RegisterModule. We
    get the IRQ value and return it as an interrupt vector in BX

Arguments:

    None.

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwInitialize\n"
                ));

    //
    // only lines on slave PIC are available. Currently, lines 3, 4 and 7 are
    // not used. We'll grab line 3 here, but in the future we expect a function
    // to return the available IRQ line
    //

    setBX( VWinInitialize() );
}


VOID
VwDispatcher(
    VOID
    )

/*++

Routine Description:

    Branches to relevant IPX/SPX handler for DOS calls, based on contents of
    VDM BX register.

    Control transfered here from 16-bit entry point, either as result of call
    to far address returned from INT 2Fh/AH=7A or INT 7Ah

    Special: we use BX = 0xFFFF to indicate that the app is terminating. The
    TSR hooks INT 0x2F/AX=0x1122 (IFSResetEnvironment)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD dispatchIndex;

    dispatchIndex = (DWORD)getBX() & 0x7fff;

    if (dispatchIndex <= MAX_IPXSPX_FUNCTION) {
        VwDispatchTable[dispatchIndex]();
    } else if (dispatchIndex == 0x7FFE) {
        EsrCallback();
    } else if (dispatchIndex == 0x7FFF) {
        VwTerminateProgram();
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_ANY,
                    IPXDBG_LEVEL_ERROR,
                    "ERROR: VwDispatcher: dispatchIndex = %x\n",
                    dispatchIndex
                    ));

        setAX(ERROR_INVALID_FUNCTION);
        setCF(1);
    }
}


PRIVATE
VOID
VwInvalidFunction(
    VOID
    )

/*++

Routine Description:

    Just alerts us to the fact that an invalid function request was made.
    Useful if any app makes a bad call, or we miss out a required function
    during design/implementation

Arguments:

    None.

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwInvalidFunction: BX=%04x\n",
                getBX()
                ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwdos.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwdos.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains handlers for DOS IPX/SPX calls (netware functions). The IPX APIs
    use WinSock to perform the actual operations

    Contents:
        VwIPXCancelEvent
        VwIPXCloseSocket
        VwIPXDisconnectFromTarget
        VwIPXGenerateChecksum
        VwIPXGetInformation
        VwIPXGetInternetworkAddress
        VwIPXGetIntervalMarker
        VwIPXGetLocalTarget
        VwIPXGetLocalTargetAsync
        VwIPXGetMaxPacketSize
        VwIPXInitialize
        VwIPXListenForPacket
        VwIPXOpenSocket
        VwIPXRelinquishControl
        VwIPXScheduleAESEvent
        VwIPXScheduleIPXEvent
        VwIPXSendPacket
        VwIPXSendWithChecksum
        VwIPXSPXDeinit
        VwIPXVerifyChecksum

        VwSPXAbortConnection
        VwSPXEstablishConnection
        VwSPXGetConnectionStatus
        VwSPXInitialize
        VwSPXListenForConnection
        VwSPXListenForSequencedPacket
        VwSPXSendSequencedPacket
        VwSPXTerminateConnection

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// functions
//


VOID
VwIPXCancelEvent(
    VOID
    )

/*++

Routine Description:

    Cancels event described by an ECB

    This call is Synchronous

Arguments:

    Inputs
        BX      06h
        ES:SI   ECB

    Outputs
        AL      Completion code:
                    00h Success
                    F9h Can't cancel ECB
                    FFh ECB not in use

Return Value:

    None.

--*/

{
    LPECB pEcb;
    WORD status;

    CHECK_INTERRUPTS("VwIPXCancelEvent");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCancelEvent,
                IPXDBG_LEVEL_INFO,
                "VwIPXCancelEvent(%04x:%04x)\n",
                getES(),
                getSI()
                ));

    IPX_GET_IPX_ECB(pEcb);

    status = _VwIPXCancelEvent( pEcb );

    IPX_SET_STATUS(status);
}


VOID
VwIPXCloseSocket(
    VOID
    )

/*++

Routine Description:

    Closes a socket and cancels any outstanding events on the socket.
    Closing an unopened socket does not return an error
    ESRs in cancelled ECBs are not called

    This call is Synchronous

Arguments:

    Inputs
        BX      01h
        DX      Socket Number

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    WORD socketNumber;

    CHECK_INTERRUPTS("VwIPXCloseSocket");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCloseSocket,
                IPXDBG_LEVEL_INFO,
                "VwIPXCloseSocket(%#x)\n",
                B2LW(IPX_SOCKET_PARM())
                ));

    IPX_GET_SOCKET(socketNumber);

    _VwIPXCloseSocket( socketNumber );

}


VOID
VwIPXDisconnectFromTarget(
    VOID
    )

/*++

Routine Description:

    Performs no action for NTVDM IPX

    This call is Synchronous

Arguments:

    Inputs
        BX      0Bh
        ES:SI   Request buffer:
                    Destination Network DB 4 DUP (?)
                    Destination Node    DB 6 DUP (?)
                    Destination Socket  DB 2 DUP (?)

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXDisconnectFromTarget");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXDisconnectFromTarget,
                IPXDBG_LEVEL_INFO,
                "VwIPXDisconnectFromTarget\n"
                ));
}


VOID
VwIPXGenerateChecksum(
    VOID
    )

/*++

Routine Description:

    Generates checksum for a transmit ECB

    This call is Synchronous

Arguments:

    Inputs
        BX      21h
        ES:SI   ECB address

    Outputs
        No registers
        ECB checksum field is updated

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXGenerateChecksum");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGenerateChecksum,
                IPXDBG_LEVEL_INFO,
                "VwIPXGenerateChecksum\n"
                ));
}


VOID
VwIPXGetInformation(
    VOID
    )

/*++

Routine Description:

    Returns a bit-map of supported functions

    This call is Synchronous

Arguments:

    Inputs
        BX      1Fh
        DX      0000h

    Outputs
        DX      Bit map:
                    0001h   Set if IPX is IPXODI.COM, not dedicated IPX
                    0002h   Set if checksum functions (20h, 21h, 22h) supported

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXGetInformation");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetInformation,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetInformation\n"
                ));

    IPX_SET_INFORMATION(IPX_ODI);
}


VOID
VwIPXGetInternetworkAddress(
    VOID
    )

/*++

Routine Description:

    Returns a buffer containing the net number and node number for this
    station.

    This function cannot return an error (!)

    Assumes:    1. GetInternetAddress has been successfully called in the
                   DLL initialization phase

    This call is Synchronous

Arguments:

    Inputs
        BX      09h

    Outputs
        ES:SI   Buffer
                    Network Address DB 4 DUP (?)
                    Node Address    DB 6 DUP (?)

Return Value:

    None.

--*/

{
    LPINTERNET_ADDRESS pAddr;

    CHECK_INTERRUPTS("VwIPXGetInternetworkAddress");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetInternetworkAddress,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetInternetworkAddress(%04x:%04x)\n",
                getES(),
                getSI()
                ));

    pAddr = (LPINTERNET_ADDRESS)IPX_BUFFER_PARM(sizeof(*pAddr));
    if (pAddr) {
        _VwIPXGetInternetworkAddress( pAddr );
    }
}


VOID
VwIPXGetIntervalMarker(
    VOID
    )

/*++

Routine Description:

    Just returns the tick count maintained by Asynchronous Event Scheduler

    This call is Synchronous

Arguments:

    Inputs
        BX      08h

    Outputs
        AX      Interval marker

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXGetIntervalMarker");

    setAX( _VwIPXGetIntervalMarker() );

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetIntervalMarker,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetIntervalMarker: Returning %04x\n",
                getAX()
                ));
}


VOID
VwIPXGetLocalTarget(
    VOID
    )

/*++

Routine Description:

    Given a target address of the form (network address {4}, node address {6}),
    returns the node address of the target if on the same network, or the node
    address of the router which knows how to get to the next hop in reaching the
    eventual target

    This call is Synchronous

Arguments:

    Inputs
        BX      02h
        ES:SI   Request buffer
                    Destination Network DB 4 DUP (?)
                    Destination Node    DB 6 DUP (?)
                    Destination Socket  DB 2 DUP (?)
        ES:DI   Response buffer
                    Local Target DB 6 DUP (?)

    Outputs
        AL      Completion code
                    00h Success
                    FAh No path to destination node found
        AH      Number of hops to destination
        CX      Transport time

Return Value:

    None.

--*/

{
    LPBYTE pImmediateAddress;
    LPBYTE pNetworkAddress;
    WORD   transportTime;
    WORD   status;

    CHECK_INTERRUPTS("VwIPXGetLocalTarget");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetLocalTarget,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetLocalTarget(target buf @ %04x:%04x, local buf @ %04x:%04x)\n",
                getES(),
                getSI(),
                getES(),
                getDI()
                ));


    pImmediateAddress = POINTER_FROM_WORDS(getES(), getDI(), 6);
    pNetworkAddress = POINTER_FROM_WORDS(getES(), getSI(), 12);

    if (pImmediateAddress && pNetworkAddress) {
        status = _VwIPXGetLocalTarget( pNetworkAddress,
                                       pImmediateAddress,
                                       &transportTime );
    }
    else {
        status = IPX_BAD_REQUEST;
    }


    setCX( transportTime );
    setAH(1);

    IPX_SET_STATUS(status);
}


VOID
VwIPXGetLocalTargetAsync(
    VOID
    )

/*++

Routine Description:

    description-of-function.

    This call is Asynchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXGetLocalTargetAsync");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetLocalTargetAsync\n"
                ));
}


VOID
VwIPXGetMaxPacketSize(
    VOID
    )

/*++

Routine Description:

    Returns the maximum packet size the underlying network can handle

    Assumes:    1. A successfull call to GetMaxPacketSize has been made during
                   DLL initialization
                2. Maximum packet size is constant

    This call is Synchronous

Arguments:

    Inputs
        BX      1Ah

    Outputs
        AX      Maximum packet size
        CX      IPX retry count

Return Value:

    None.

--*/

{
    WORD maxPacketSize;
    WORD retryCount;

    CHECK_INTERRUPTS("VwIPXGetMaxPacketSize");

    maxPacketSize = _VwIPXGetMaxPacketSize( &retryCount );

    setAX(maxPacketSize);

    //
    // The DOS Assembly and C manuals differ slightly here: DOS says
    // we return the IPX retry count in CX. There is no corresponding parameter
    // in the C interface?
    //

    setCX(retryCount);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetMaxPacketSize,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetMaxPacketSize: PacketSize=%d, RetryCount=%d\n",
                getAX(),
                getCX()
                ));
}


VOID
VwIPXInitialize(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXInitialize");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwIPXInitialize\n"
                ));
}


VOID
VwIPXListenForPacket(
    VOID
    )

/*++

Routine Description:

    Queue a listen request against a socket. All listen requests will be
    completed asynchronously, unless cancelled by app

    This call is Asynchronous

Arguments:

    Inputs
        BX      04h
        ES:SI   ECB address

    Outputs
        AL      Completion code
                    FFh Socket doesn't exist

Return Value:

    None.

--*/

{
    LPECB pEcb;
    WORD  status;

    CHECK_INTERRUPTS("VwIPXListenForPacket");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXListenForPacket,
                IPXDBG_LEVEL_INFO,
                "VwIPXListenForPacket(%04x:%04x)\n",
                getES(),
                getSI()
                ));

    IPX_GET_IPX_ECB(pEcb);

    status = _VwIPXListenForPacket( pEcb, ECB_PARM_ADDRESS() );

    IPX_SET_STATUS(status);
}


VOID
VwIPXOpenSocket(
    VOID
    )

/*++

Routine Description:

    Opens a socket for use by IPX or SPX. Puts the socket into non-blocking mode.
    The socket will be bound to IPX

    This call is Synchronous

Arguments:

    Inputs
        AL      Socket Longevity flag
                    This parameter is actually in BP - AX has been sequestered
                    by the VDD dispatcher
        BX      00h
        DX      Requested Socket Number

        CX      DOS PDB. This parameter is not part of the IPX API.
                Added because we need to remember which DOS executable created
                the socket: we need to clean-up short-lived sockets when the
                executable terminates

    Outputs
        AL      Completion code:
                    00h Success
                    FFh Socket already open
                    FEh Socket table full
        DX      Assigned socket number

Return Value:

    None.

--*/

{
    BYTE socketLife;
    WORD socketNumber;
    WORD status;

    CHECK_INTERRUPTS("VwIPXOpenSocket");

    IPX_GET_SOCKET_LIFE(socketLife);
    IPX_GET_SOCKET(socketNumber);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXOpenSocket,
                IPXDBG_LEVEL_INFO,
                "VwIPXOpenSocket(Life=%02x, Socket=%04x, Owner=%04x)\n",
                socketLife,
                B2LW(socketNumber),
                IPX_SOCKET_OWNER_PARM()
                ));


    status = _VwIPXOpenSocket( &socketNumber,
                               socketLife,
                               IPX_SOCKET_OWNER_PARM() );

    if ( status == IPX_SUCCESS )
        IPX_SET_SOCKET(socketNumber);

    IPX_SET_STATUS(status);
}


VOID
VwIPXRelinquishControl(
    VOID
    )

/*++

Routine Description:

    Just sleep for a nominal amount. Netware seems to be dependent on the
    default setting of the PC clock, so one timer tick (1/18 second) would
    seem to be a good value

    This call is Synchronous

Arguments:

    Inputs
        BX      0Ah

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXRelinquishControl");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXRelinquishControl,
                IPXDBG_LEVEL_INFO,
                "VwIPXRelinquishControl\n"
                ));

    _VwIPXRelinquishControl();

}


VOID
VwIPXScheduleAESEvent(
    VOID
    )

/*++

Routine Description:

    Schedules a an event to occur in some number of ticks. When the tick count
    reaches 0, the ECB InUse field is cleared and any ESR called

    This call is Asynchronous

Arguments:

    Inputs
        BX      07h
        AX      Delay time - number of 1/18 second ticks
        ES:SI   ECB address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = AES_ECB_PARM();
    WORD ticks = IPX_TICKS_PARM();

    if (pXecb == NULL) {
        return;
    }

    CHECK_INTERRUPTS("VwIPXScheduleAESEvent");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXScheduleAESEvent,
                IPXDBG_LEVEL_INFO,
                "VwIPXScheduleAESEvent(%04x:%04x, %04x)\n",
                getES(),
                getSI(),
                ticks
                ));

    ScheduleEvent(pXecb, ticks);
}


VOID
VwIPXScheduleIPXEvent(
    VOID
    )

/*++

Routine Description:

    Schedules a an event to occur in some number of ticks. When the tick count
    reaches 0, the ECB InUse field is cleared and any ESR called

    This call is Asynchronous

Arguments:

    Inputs
        BX      05h
        AX      Delay time - number of 1/18 second ticks
        ES:SI   ECB address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPECB pEcb;
    WORD ticks = IPX_TICKS_PARM();

    CHECK_INTERRUPTS("VwIPXScheduleIPXEvent");

    IPX_GET_IPX_ECB(pEcb);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXScheduleIPXEvent,
                IPXDBG_LEVEL_INFO,
                "VwIPXScheduleIPXEvent(%04x:%04x, %04x)\n",
                getES(),
                getSI(),
                ticks
                ));

    _VwIPXScheduleIPXEvent( ticks, pEcb, ECB_PARM_ADDRESS() );

}


VOID
VwIPXSendPacket(
    VOID
    )

/*++

Routine Description:

    Sends a packet to the target machine/router. This call can be made on a
    socket that is not open

    The app must have filled in the following IPX_ECB fields:

        EsrAddress
        Socket
        ImmediateAddress
        FragmentCount
        fragment descriptor fields

    and the following IPX_PACKET fields:

        PacketType
        Destination.Net
        Destination.Node
        Destination.Socket

    This call is Asynchronous

Arguments:

    Inputs
        BX      03h
        CX      DOS PDB. This parameter is not part of the IPX API.
                Added because we need to remember which DOS executable owns the
                socket IF WE MUST CREATE A TEMPORTARY SOCKET: we need to clean-up
                short-lived sockets when the executable terminates
        ES:SI   ECB Address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPECB pEcb;
    WORD owner;

    CHECK_INTERRUPTS("VwIPXSendPacket");

    IPX_GET_IPX_ECB(pEcb);

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXSendPacket,
                IPXDBG_LEVEL_INFO,
                "VwIPXSendPacket(%04x:%04x), owner = %04x\n",
                getES(),
                getSI(),
                IPX_SOCKET_OWNER_PARM()
                ));

    _VwIPXSendPacket(pEcb,
                     ECB_PARM_ADDRESS(),
                     IPX_SOCKET_OWNER_PARM()
                     );
}


VOID
VwIPXSendWithChecksum(
    VOID
    )

/*++

Routine Description:

    description-of-function.

    This call is Asynchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXSendWithChecksum");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXSendWithChecksum,
                IPXDBG_LEVEL_INFO,
                "VwIPXSendWithChecksum\n"
                ));
}


VOID
VwIPXSPXDeinit(
    VOID
    )

/*++

Routine Description:

    description-of-function.

    This call is Synchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXSPXDeinit");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwIPXSPXDeinit\n"
                ));
}


VOID
VwIPXVerifyChecksum(
    VOID
    )

/*++

Routine Description:

    description-of-function.

    This call is Synchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_INTERRUPTS("VwIPXVerifyChecksum");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXVerifyChecksum,
                IPXDBG_LEVEL_INFO,
                "VwIPXVerifyChecksum\n"
                ));
}


VOID
VwSPXAbortConnection(
    VOID
    )

/*++

Routine Description:

    Aborts this end of a connection

    This call is Asynchronous

Arguments:

    Inputs
        BX      14h
        DX      Connection ID

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    WORD connectionId = SPX_CONNECTION_PARM();

    CHECK_INTERRUPTS("VwSPXAbortConnection");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXAbortConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXAbortConnection(%04x)\n",
                connectionId
                ));

    _VwSPXAbortConnection(connectionId);
}


VOID
VwSPXEstablishConnection(
    VOID
    )

/*++

Routine Description:

    Creates a connection with a remote SPX socket. The remote end can be on
    this machine (i.e. same app in DOS world)

    This call is Asynchronous

Arguments:

    Inputs
        BX      11h
        AL      Retry count
        AH      WatchDog flag
        ES:SI   ECB Address

    Outputs
        AL      Completion code:
                    00h Attempting to talk to remote
                    EFh Local connection table full
                    FDh Fragment count not 1; buffer size not 42
                    FFh Send socket not open
        DX      Connection ID

Return Value:

    None.

--*/

{
    WORD status;
    BYTE retryCount = SPX_RETRY_COUNT_PARM();
    BYTE watchDogFlag = SPX_WATCHDOG_FLAG_PARM();
    WORD connectionId = 0;
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXEstablishConnection");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXEstablishConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXEstablishConnection(%02x, %02x, %04x:%04x)\n",
                retryCount,
                watchDogFlag,
                ECB_PARM_SEGMENT(),
                ECB_PARM_OFFSET()
                ));

    IPX_GET_IPX_ECB( pEcb );

    IPXDUMPECB((pEcb, getES(), getSI(), ECB_TYPE_SPX, TRUE, TRUE, FALSE));

    status = _VwSPXEstablishConnection( retryCount,
                                        watchDogFlag,
                                        &connectionId,
                                        pEcb,
                                        ECB_PARM_ADDRESS() );


    SPX_SET_CONNECTION_ID( connectionId );
    SPX_SET_STATUS( status );
}


VOID
VwSPXGetConnectionStatus(
    VOID
    )

/*++

Routine Description:

    Returns buffer crammed full of useful statistics or something (hu hu huh)

    This call is Synchronous

Arguments:

    Inputs
        BX      15h
        DX      Connection ID
        ES:SI   Buffer address

    Outputs
        AL      Completion code:
                    00h Connection is active
                    EEh No such connection

        on output, buffer in ES:SI contains:

            BYTE    ConnectionStatus
            BYTE    WatchDogActive
            WORD    LocalConnectionID
            WORD    RemoteConnectionID
            WORD    SequenceNumber
            WORD    LocalAckNumber
            WORD    LocalAllocationNumber
            WORD    RemoteAckNumber
            WORD    RemoteAllocationNumber
            WORD    LocalSocket
            BYTE    ImmediateAddress[6]
            BYTE    RemoteNetwork[4]
            WORD    RetransmissionCount
            WORD    RetransmittedPackets
            WORD    SuppressedPackets

Return Value:

    None.

--*/

{
    WORD status;
    WORD connectionId = SPX_CONNECTION_PARM();
    LPSPX_CONNECTION_STATS pStats = (LPSPX_CONNECTION_STATS)SPX_BUFFER_PARM(sizeof(*pStats));

    CHECK_INTERRUPTS("VwSPXGetConnectionStatus");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXGetConnectionStatus,
                IPXDBG_LEVEL_INFO,
                "VwSPXGetConnectionStatus: connectionId=%04x\n",
                connectionId
                ));

    status = _VwSPXGetConnectionStatus( connectionId,
                                        pStats );


    SPX_SET_STATUS(status);
}


VOID
VwSPXInitialize(
    VOID
    )

/*++

Routine Description:

    Informs the app that SPX is present on this station

    This call is Synchronous

Arguments:

    Inputs
        BX      10h
        AL      00h

    Outputs
        AL      Installation flag:
                    00h Not installed
                    FFh Installed
        BH      SPX Major revision number
        BL      SPX Minor revision number
        CX      Maximum SPX connections supported
                    normally from SHELL.CFG
        DX      Available SPX connections

Return Value:

    None.

--*/

{
    WORD status;
    BYTE majorRevisionNumber;
    BYTE minorRevisionNumber;
    WORD maxConnections;
    WORD availableConnections;

    CHECK_INTERRUPTS("VwSPXInitialize");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXInitialize,
                IPXDBG_LEVEL_INFO,
                "VwSPXInitialize\n"
                ));


    status = _VwSPXInitialize( &majorRevisionNumber,
                               &minorRevisionNumber,
                               &maxConnections,
                               &availableConnections );


    setBH( majorRevisionNumber );
    setBL( minorRevisionNumber );
    setCX( maxConnections );
    setDX( availableConnections );
    SPX_SET_STATUS(status);
}


VOID
VwSPXListenForConnection(
    VOID
    )

/*++

Routine Description:

    Listens for an incoming connection request

    This call is Asynchronous

Arguments:

    Inputs
        BX      12h
        AL      Retry count
        AH      SPX WatchDog flag
        ES:SI   ECB Address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    BYTE retryCount = SPX_RETRY_COUNT_PARM();
    BYTE watchDogFlag = SPX_WATCHDOG_FLAG_PARM();
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXListenForConnection");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXListenForConnection(%02x, %02x, %04x:%04x)\n",
                retryCount,
                watchDogFlag,
                ECB_PARM_SEGMENT(),
                ECB_PARM_OFFSET()
                ));

    IPX_GET_IPX_ECB( pEcb );

    IPXDUMPECB((pEcb, getES(), getSI(), ECB_TYPE_SPX, TRUE, FALSE, FALSE));

    _VwSPXListenForConnection( retryCount,
                               watchDogFlag,
                               pEcb,
                               ECB_PARM_ADDRESS() );
}


VOID
VwSPXListenForSequencedPacket(
    VOID
    )

/*++

Routine Description:

    Attempts to receive an SPX packet. This call is made against the top-level
    socket (the socket in SPX-speak, not the connection). We can receive a
    packet from any connection assigned to this socket. In this function, we
    just queue the ECB (since there is no return status, we expect that the
    app has supplied an ESR) and let AES handle it

    This call is Asynchronous

Arguments:

    Inputs
        BX      17h
        ES:SI   ECB Address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXListenForSequencedPacket");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VwSPXListenForSequencedPacket(%04x:%04x)\n",
                ECB_PARM_SEGMENT(),
                ECB_PARM_OFFSET()
                ));

    IPX_GET_IPX_ECB( pEcb );

    IPXDUMPECB((pEcb, getES(), getSI(), ECB_TYPE_SPX, TRUE, FALSE, FALSE));

    _VwSPXListenForSequencedPacket( pEcb,
                                    ECB_PARM_ADDRESS());

}


VOID
VwSPXSendSequencedPacket(
    VOID
    )

/*++

Routine Description:

    Sends a packet on an SPX connection

    This call is Asynchronous

Arguments:

    Inputs
        BX      16h
        DX      Connection ID
        ES:SI   ECB address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    WORD connectionId = SPX_CONNECTION_PARM();
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXSendSequencedPacket""VwSPXSendSequencedPacket");

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXSendSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VwSPXSendSequencedPacket(%04x, %04x:%04x)\n",
                connectionId,
                getES(),
                getSI()
                ));

    IPX_GET_IPX_ECB( pEcb );

    IPXDUMPECB((pEcb, getES(), getSI(), ECB_TYPE_SPX, TRUE, TRUE, FALSE));

    _VwSPXSendSequencedPacket( connectionId,
                               pEcb,
                               ECB_PARM_ADDRESS() );

}


VOID
VwSPXTerminateConnection(
    VOID
    )

/*++

Routine Description:

    Terminates a connection

    This call is Asynchronous

Arguments:

    Inputs
        BX      13h
        DX      Connection ID
        ES:SI   ECB Address

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    WORD connectionId = SPX_CONNECTION_PARM();
    LPECB pEcb;

    CHECK_INTERRUPTS("VwSPXTerminateConnection");

    IPX_GET_IPX_ECB( pEcb );

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXTerminateConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXTerminateConnection(%04x, %04x:%04x)\n",
                connectionId,
                ECB_PARM_SEGMENT(),
                ECB_PARM_OFFSET()
                ));

    _VwSPXTerminateConnection(connectionId, pEcb, ECB_PARM_ADDRESS());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwdebug.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwdebug.h

Abstract:

    Prototypes, structures, manifests, macros for VWIPXSPX debug routines

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

#ifndef _VWDEBUG_H_
#define _VWDEBUG_H_

//
// debug flags
//

#define DEBUG_ANY       0xFFFFFFFF      // any debug flags set
#define DEBUG_NOTHING   0x00000001      // no debug output
#define DEBUG_CHECK_INT 0x00080000      // check interrupts (DOS)
#define DEBUG_STATS     0x00100000      // dump connection stats
#define DEBUG_DATA      0x00200000      // dump data (send)
#define DEBUG_FRAGMENTS 0x00400000      // dump fragments
#define DEBUG_HEADERS   0x00800000      // dump IPX/SPX headers
#define DEBUG_ECB       0x01000000      // dump 16-bit ECBs
#define DEBUG_XECB      0x02000000      // dump 32-bit XECBs
#define DEBUG_SOCKINFO  0x04000000      // dump SOCKET_INFO structs
#define DEBUG_CONNINFO  0x08000000      // dump CONNECTION_INFO structs
#define DEBUG_DLL       0x10000000      // include DLL attach/detach info
#define DEBUG_FLUSH     0x20000000      // flush every write
#define DEBUG_TO_FILE   0x40000000      // write debug stuff to file
#define DEBUG_TO_DBG    0x80000000      // debug stuff to debugger

#define VWDEBUG_FILE    "VWDEBUG.LOG"

//
// function designators
//

#define FUNCTION_ANY                            0xFFFFFFFF
#define FUNCTION_IPXOpenSocket                  0x00000001  // 0x00
#define FUNCTION_IPXCloseSocket                 0x00000002  // 0x01
#define FUNCTION_IPXGetLocalTarget              0x00000004  // 0x02
#define FUNCTION_IPXSendPacket                  0x00000008  // 0x03
#define FUNCTION_IPXListenForPacket             0x00000010  // 0x04
#define FUNCTION_IPXScheduleIPXEvent            0x00000020  // 0x05
#define FUNCTION_IPXCancelEvent                 0x00000040  // 0x06
#define FUNCTION_IPXScheduleAESEvent            0x00000080  // 0x07
#define FUNCTION_IPXGetIntervalMarker           0x00000100  // 0x08
#define FUNCTION_IPXGetInternetworkAddress      0x00000200  // 0x09
#define FUNCTION_IPXRelinquishControl           0x00000400  // 0x0A
#define FUNCTION_IPXDisconnectFromTarget        0x00000800  // 0x0B
#define FUNCTION_InvalidFunction_0C             0x00001000  // 0x0C
#define FUNCTION_InvalidFunction_0D             0x00002000  // 0x0D
#define FUNCTION_InvalidFunction_0E             0x00004000  // 0x0E
#define FUNCTION_InvalidFunction_0F             0x00008000  // 0x0F
#define FUNCTION_SPXInitialize                  0x00010000  // 0x10
#define FUNCTION_SPXEstablishConnection         0x00020000  // 0x11
#define FUNCTION_SPXListenForConnection         0x00040000  // 0x12
#define FUNCTION_SPXTerminateConnection         0x00080000  // 0x13
#define FUNCTION_SPXAbortConnection             0x00100000  // 0x14
#define FUNCTION_SPXGetConnectionStatus         0x00200000  // 0x15
#define FUNCTION_SPXSendSequencedPacket         0x00400000  // 0x16
#define FUNCTION_SPXListenForSequencedPacket    0x00800000  // 0x17
#define FUNCTION_InvalidFunction_18             0x01000000  // 0x18
#define FUNCTION_InvalidFunction_19             0x02000000  // 0x19
#define FUNCTION_IPXGetMaxPacketSize            0x04000000  // 0x1A
#define FUNCTION_InvalidFunction_1B             0x08000000  // 0x1B
#define FUNCTION_InvalidFunction_1C             0x10000000  // 0x1C
#define FUNCTION_InvalidFunction_1D             0x20000000  // 0x1D
#define FUNCTION_InvalidFunction_1E             0x40000000  // 0x1E
#define FUNCTION_IPXGetInformation              0x80000000  // 0x1F
#define FUNCTION_IPXSendWithChecksum            0xFFFFFFFF  // 0x20
#define FUNCTION_IPXGenerateChecksum            0xFFFFFFFF  // 0x21
#define FUNCTION_IPXVerifyChecksum              0xFFFFFFFF  // 0x22

//
// debug levels
//

#define IPXDBG_LEVEL_ALL        0
#define IPXDBG_LEVEL_INFO       1
#define IPXDBG_LEVEL_WARNING    2
#define IPXDBG_LEVEL_ERROR      3
#define IPXDBG_LEVEL_FATAL      4

#define IPXDBG_MIN_LEVEL        IPXDBG_LEVEL_ALL
#define IPXDBG_MAX_LEVEL        IPXDBG_LEVEL_FATAL

//
// info dump flags (VWDUMP)
//

#define DUMP_ECB_IN         0x00000001
#define DUMP_ECB_OUT        0x00000002
#define DUMP_SEND_DATA      0x00000004
#define DUMP_RECEIVE_DATA   0x00000008

//
// show flags
//

#define SHOW_ECBS           0x00000001  // show ECBs vs. raw data
#define SHOW_HEADERS        0x00000002  // show IPX/SPX headers vs. raw data

#if DBG

extern DWORD VwDebugFlags;
extern DWORD VwDebugFunctions;
extern DWORD VwShow;
extern DWORD DebugFlagsEx;


#define IF_DEBUG(f)     if (VwDebugFlags & DEBUG_ ## f)
#define IF_NOT_DEBUG(f) if (!(VwDebugFlags & DEBUG_ ## f))
#define IF_SHOW(f)      if (VwShow & SHOW_ ## f)
#define IF_NOT_SHOW(f)  if (!(VwShow & SHOW_ ## f))
#define PRIVATE
#define IPXDBGPRINT(x)  VwDebugPrint x
#define IPXDBGSTART()   VwDebugStart()
#define IPXDBGEND()     VwDebugEnd()
#define VWASSERT(a, b)  ASSERT((a) == (b))
#define IPXDUMPDATA(x)  VwDumpData x
#define IPXDUMPECB(x)   VwDumpEcb x
#define DUMPXECB(x)     VwDumpXecb(x)
#define DUMPCONN(x)     VwDumpConnectionInfo(x)
#define DUMPSTATS(x)    VwDumpConnectionStats(x)
#define CHECK_INTERRUPTS(s) CheckInterrupts(s)
#define DUMPALL()       VwDumpAll()

#else

#define IF_DEBUG(f)     if (0)
#define IF_NOT_DEBUG(f) if (0)
#define IF_SHOW(f)      if (0)
#define IF_NOT_SHOW(f)  if (0)
#define PRIVATE         static
#define IPXDBGPRINT(x)
#define IPXDBGSTART()
#define IPXDBGEND()
#define VWASSERT(a, b)  a
#define IPXDUMPDATA(x)
#define IPXDUMPECB(x)
#define DUMPXECB(x)
#define DUMPCONN(x)
#define DUMPSTATS(x)
#define CHECK_INTERRUPTS(s)
#define DUMPALL()

#endif

//
// debug function prototypes
//

extern VOID VwDebugStart(VOID);
extern VOID VwDebugEnd(VOID);
extern VOID VwDebugPrint(LPSTR, DWORD, DWORD, DWORD, LPSTR, ...);
extern VOID VwDumpData(ULPBYTE, WORD, WORD, BOOL, WORD);
extern VOID VwDumpEcb(LPECB, WORD, WORD, BYTE, BOOL, BOOL, BOOL);
extern VOID VwDumpFragment(WORD, LPFRAGMENT, BYTE, BOOL, BOOL);
extern VOID VwDumpPacketHeader(ULPBYTE, BYTE);
extern VOID VwDumpXecb(LPXECB);
extern VOID VwDumpSocketInfo(LPSOCKET_INFO);
extern VOID VwDumpConnectionInfo(LPCONNECTION_INFO);
extern VOID VwDumpConnectionStats(LPSPX_CONNECTION_STATS);
extern VOID VwLog(LPSTR);
extern VOID CheckInterrupts(LPSTR);
extern VOID VwDumpAll(VOID);

#endif  // _VWDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwdll.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwdll.h

Abstract:

    Contains external data declarations for VWDLL.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

extern SOCKADDR_IPX MyInternetAddress;
extern WORD MyMaxPacketSize;
extern int Ica;
extern BYTE IcaLine;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwinapi.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwinapi.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Contains handlers for WOW IPX/SPX calls (netware functions). The IPX/SPX
    APIs use WinSock to perform the actual operations

    Contents:
        VWinIPXCancelEvent
        VWinIPXCloseSocket
        VWinIPXDisconnectFromTarget
        VWinIPXGetInternetworkAddress
        VWinIPXGetIntervalMarker
        VWinIPXGetLocalTarget
        VWinIPXGetLocalTargetAsync
        VWinIPXGetMaxPacketSize
        VWinIPXInitialize
        VWinIPXListenForPacket
        VWinIPXOpenSocket
        VWinIPXRelinquishControl
        VWinIPXScheduleIPXEvent
        VWinIPXSendPacket
        VWinIPXSPXDeinit

        VWinSPXAbortConnection
        VWinSPXEstablishConnection
        VWinSPXGetConnectionStatus
        VWinSPXInitialize
        VWinSPXListenForConnection
        VWinSPXListenForSequencedPacket
        VWinSPXSendSequencedPacket
        VWinSPXTerminateConnection

Author:

    Yi-Hsin Sung ( yihsins ) 28-Oct-1993

Environment:

    User-mode Win32

Revision History:

    28-Oct-1993 yihsins
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// functions
//


WORD
VWinIPXCancelEvent(
    IN DWORD IPXTaskID,
    IN LPECB pEcb
    )

/*++

Routine Description:

    Cancels event described by an ECB

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        pECB

Return Value:

    00h Success
    F9h Can't cancel ECB
    FFh ECB not in use

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCancelEvent,
                IPXDBG_LEVEL_INFO,
                "VWinIPXCancelEvent\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwIPXCancelEvent( pEcb );
}


VOID
VWinIPXCloseSocket(
    IN DWORD IPXTaskID,
    IN WORD socketNumber
    )

/*++

Routine Description:

    Closes a socket and cancels any outstanding events on the socket.
    Closing an unopened socket does not return an error
    ESRs in cancelled ECBs are not called

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        socketNumber

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCloseSocket,
                IPXDBG_LEVEL_INFO,
                "VWinIPXCloseSocket(%#x)\n",
                B2LW(socketNumber)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwIPXCloseSocket( socketNumber );
}


VOID
VWinIPXDisconnectFromTarget(
    IN DWORD IPXTaskID,
    IN LPBYTE pNetworkAddress
    )

/*++

Routine Description:

    Performs no action for NTVDM IPX

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        pNetworkAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXDisconnectFromTarget,
                IPXDBG_LEVEL_INFO,
                "VWinIPXDisconnectFromTarget\n"
                ));
}


VOID
VWinIPXGetInternetworkAddress(
    IN DWORD IPXTaskID,
    OUT LPINTERNET_ADDRESS pNetworkAddress
    )

/*++

Routine Description:

    Returns a buffer containing the net number and node number for this
    station.

    This function cannot return an error (!)

    Assumes:    1. GetInternetAddress has been successfully called in the
                   DLL initialization phase

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID

    Outputs
        pNetworkAddress

Return Value:

    None.

--*/

{

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetInternetworkAddress,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetInternetworkAddress\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwIPXGetInternetworkAddress( pNetworkAddress );

}


WORD
VWinIPXGetIntervalMarker(
    IN DWORD IPXTaskID
    )

/*++

Routine Description:

    Just returns the tick count maintained by Asynchronous Event Scheduler

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID

    Outputs

Return Value:

    The tick count.

--*/

{
    WORD intervalMarker = _VwIPXGetIntervalMarker();

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetIntervalMarker,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetIntervalMarker: Returning %04x\n",
                intervalMarker
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return intervalMarker;
}


WORD
VWinIPXGetLocalTarget(
    IN DWORD IPXTaskID,
    IN LPBYTE pNetworkAddress,
    OUT LPBYTE pImmediateAddress,
    OUT ULPWORD pTransportTime
    )

/*++

Routine Description:

    Given a target address of the form (network address {4}, node address {6}),
    returns the node address of the target if on the same network, or the node
    address of the router which knows how to get to the next hop in reaching the
    eventual target

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        pNetworkAddress

    Outputs
        pImmediateAddress
        pTransportTime


Return Value:

    00h Success
    F1h Ipx/Spx Not Initialized
    FAh No path to destination node found

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetLocalTarget,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetLocalTarget\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwIPXGetLocalTarget( pNetworkAddress,
                                 pImmediateAddress,
                                 pTransportTime );
}


WORD
VWinIPXGetLocalTargetAsync(
    IN LPBYTE pSendAGLT,
    OUT LPBYTE pListenAGLT,
    IN WORD windowsHandle
    )

/*++

Routine Description:

    description-of-function.

    This call is Asynchronous

Arguments:

    pSendAGLT
    pListenAGLT
    windowsHandle

Return Value:

    00h Success
    F1h Ipx/Spx Not Initialized
    FAh No Local Target Identified

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetLocalTargetAsync\n"
                ));

    return IPX_SUCCESS;   // return success for now
}


WORD
VWinIPXGetMaxPacketSize(
    VOID
    )

/*++

Routine Description:

    Returns the maximum packet size the underlying network can handle

    Assumes:    1. A successfull call to GetMaxPacketSize has been made during
                   DLL initialization
                2. Maximum packet size is constant

    This call is Synchronous

Arguments:

    Inputs
        None.

Return Value:

    The max packet size.

--*/

{
    //
    // this is a WORD function in DOS and Windows: always return MaxPacketSize
    // in AX
    //

    WORD maxPacketSize = _VwIPXGetMaxPacketSize( NULL );

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetMaxPacketSize,
                IPXDBG_LEVEL_INFO,
                "VWinIPXGetMaxPacketSize: PacketSize=%d\n",
                maxPacketSize
                ));

    return maxPacketSize;
}


WORD
VWinIPXInitialize(
    IN OUT ULPDWORD pIPXTaskID,
    IN WORD maxECBs,
    IN WORD maxPacketSize
    )

/*++

Routine Description:

    Get the entry address for the IPX Interface.

Arguments:

    Inputs
        maxECBs
        maxPacketSize

    Output
        pIPXTaskID

Return Value:

    00h Success
    F0h Ipx NotInstalled
    F1h Ipx/Spx Not Initialized
    F2h No Dos Memory
    F3h No Free Ecb
    F4h Lock Failed
    F5h Over the maximum limit
    F6h Ipx/Spx Previously Initialized

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VWinIPXInitialize (MaxECBs=%04x, MaxPacketSize=%04x)\n",
                maxECBs,
                maxPacketSize
                ));

    UNREFERENCED_PARAMETER( maxECBs );          // ignore for now
    UNREFERENCED_PARAMETER( maxPacketSize );    // ignore for now

    return IPX_SUCCESS;
}


VOID
VWinIPXListenForPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Queue a listen request against a socket. All listen requests will be
    completed asynchronously, unless cancelled by app

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        pEcb
        EcbAddress

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXListenForPacket,
                IPXDBG_LEVEL_INFO,
                "VWinIPXListenForPacket(%04x:%04x)\n",
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    (VOID) _VwIPXListenForPacket( pEcb, EcbAddress );
}


WORD
VWinIPXOpenSocket(
    IN DWORD IPXTaskID,
    IN OUT ULPWORD pSocketNumber,
    IN BYTE socketType
    )

/*++

Routine Description:

    Opens a socket for use by IPX or SPX.Puts the socket into non-blocking mode.
    The socket will be bound to IPX.

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        *pSocketNumber
        socketType - Socket Longevity flag

    Outputs
        pSocketNumber - Assigned socket number

Return Value:

    00h Success
    F0h Ipx Not Installed
    F1h Ipx/Spx Not Initialized
    FEh Socket table full
    FFh Socket already open

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXOpenSocket,
                IPXDBG_LEVEL_INFO,
                "VwIPXOpenSocket(Life=%02x, Socket=%04x)\n",
                socketType,
                B2LW(*pSocketNumber)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwIPXOpenSocket( pSocketNumber,
                             socketType,
                             0 );

}


VOID
VWinIPXRelinquishControl(
    VOID
    )

/*++

Routine Description:

    Just sleep for a nominal amount. Netware seems to be dependent on the
    default setting of the PC clock, so one timer tick (1/18 second) would
    seem to be a good value

    This call is Synchronous

Arguments:

    None.

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXRelinquishControl,
                IPXDBG_LEVEL_INFO,
                "VWinIPXRelinquishControl\n"
                ));

    _VwIPXRelinquishControl();
}


VOID
VWinIPXScheduleIPXEvent(
    IN DWORD IPXTaskID,
    IN WORD time,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Schedules a an event to occur in some number of ticks. When the tick count
    reaches 0, the ECB InUse field is cleared and any ESR called

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        time
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXScheduleIPXEvent,
                IPXDBG_LEVEL_INFO,
                "VWinIPXScheduleIPXEvent(%04x:%04x, Time:%04x)\n",
                HIWORD( EcbAddress ),
                LOWORD( EcbAddress ),
                time
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwIPXScheduleIPXEvent( time, pEcb, EcbAddress );
}


VOID
VWinIPXSendPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Sends a packet to the target machine/router. This call can be made on a
    socket that is not open

    The app must have filled in the following IPX_ECB fields:

        EsrAddress
        Socket
        ImmediateAddress
        FragmentCount
        fragment descriptor fields

    and the following IPX_PACKET fields:

        PacketType
        Destination.Net
        Destination.Node
        Destination.Socket

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        pEcb
        EcbAddress

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXSendPacket,
                IPXDBG_LEVEL_INFO,
                "VWinIPXSendPacket(%04x:%04x)\n",
                HIWORD( EcbAddress ),
                LOWORD( EcbAddress )
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwIPXSendPacket( pEcb, EcbAddress, 0);
}


WORD
VWinIPXSPXDeinit(
    IN DWORD IPXTaskID
    )

/*++

Routine Description:

    Release any resources allocated to an application by NWIPXSPX.DLL
    for use by other applications.

    This call is Synchronous

Arguments:

    None.

Return Value:

    00h Successful
    F1h IPX/SPX Not Initialized

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwIPXSPXDeinit\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );
    return IPX_SUCCESS;
}


VOID
VWinSPXAbortConnection(
    IN WORD SPXConnectionID
    )

/*++

Routine Description:

    Abort an SPX connection.

    This call is Synchronous

Arguments:

    SPXConnectionID

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXAbortConnection,
                IPXDBG_LEVEL_INFO,
                "VWinSPXAbortConnection(%04x)\n",
                SPXConnectionID
                ));

    _VwSPXAbortConnection(SPXConnectionID);
}


WORD
VWinSPXEstablishConnection(
    IN DWORD IPXTaskID,
    IN BYTE retryCount,
    IN BYTE watchDog,
    OUT ULPWORD pSPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Establish a connection with a listening socket.

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        retryCount
        watchDog
        pEcb
        EcbAddress

    Outputs
        pSPXConnectionID
        pEcb

Return Value:

    00h  Success
    EFh  Connection Table Full
    F1h  IPX/SPX Not Initialized
    FDh  Malformed Packet
    FFh  Socket Not Opened

--*/

{

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXEstablishConnection,
                IPXDBG_LEVEL_INFO,
                "VWinSPXEstablishConnection(%02x, %02x, %04x:%04x)\n",
                retryCount,
                watchDog,
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwSPXEstablishConnection( retryCount,
                                      watchDog,
                                      pSPXConnectionID,
                                      pEcb,
                                      EcbAddress );
}


WORD
VWinSPXGetConnectionStatus(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPSPX_CONNECTION_STATS pConnectionStats
    )

/*++

Routine Description:

    Return the status of an SPX connection.

    This call is Synchronous

Arguments:

    Inputs
        IPXTaskID
        SPXConnectionID

    Outputs
        pConnectionStats

Return Value:

    00h  Success
    EEh  Invalid Connection
    F1h  IPX/SPX Not Initialized

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXGetConnectionStatus,
                IPXDBG_LEVEL_INFO,
                "VWinSPXGetConnectionStatus\n"
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    return _VwSPXGetConnectionStatus( SPXConnectionID,
                                      pConnectionStats );
}


WORD
VWinSPXInitialize(
    IN OUT ULPDWORD pIPXTaskID,
    IN WORD maxECBs,
    IN WORD maxPacketSize,
    OUT LPBYTE pMajorRevisionNumber,
    OUT LPBYTE pMinorRevisionNumber,
    OUT ULPWORD pMaxConnections,
    OUT ULPWORD pAvailableConnections
    )

/*++

Routine Description:

    Informs the app that SPX is present on this station

    This call is Synchronous

Arguments:

    pIPXTaskID              - on input, specifies how resources will be
                              allocated:

                                0x00000000  - directly to calling application
                                0xFFFFFFFE  - directly to calling application,
                                              but multiple initializations are
                                              allowed
                                0xFFFFFFFF  - resources allocated in a pool for
                                              multiple applications
    maxECBs                 - maximum number of outstanding ECBs
    maxPacketSize           - maximum packet size to be sent by the app
    pMajorRevisionNumber    - returned SPX major version #
    pMinorRevisionNumber    - returned SPX minor version #
    pMaxConnections         - maximum connections supported by this SPX version
    pAvailableConnections   - number of connections available to this app

Return Value:

    WORD
        0x0000  SPX not installed
        0x00F1  IPX/SPX not installed
        0x00F2  no DOS memory
        0x00F3  no free ECBs
        0x00F4  lock failed
        0x00F5  exceeded maximum limit
        0x00F6  IPX/SPX already initialized
        0x00FF  SPX installed

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXInitialize,
                IPXDBG_LEVEL_INFO,
                "VWinSPXInitialize\n"
               ));

    UNREFERENCED_PARAMETER( maxECBs );        // ignore for now
    UNREFERENCED_PARAMETER( maxPacketSize );  // ignore for now

    //
    // do the same thing as 16-bit windows and return the task ID unchanged
    //

//    *pIPXTaskID = 0;

    return _VwSPXInitialize( pMajorRevisionNumber,
                             pMinorRevisionNumber,
                             pMaxConnections,
                             pAvailableConnections );
}


VOID
VWinSPXListenForConnection(
    IN DWORD IPXTaskID,
    IN BYTE retryCount,
    IN BYTE watchDog,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Listens for an incoming connection request

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        retryCount
        watchDogFlag
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForConnection,
                IPXDBG_LEVEL_INFO,
                "VWinSPXListenForConnection(%02x, %02x, %04x:%04x)\n",
                retryCount,
                watchDog,
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwSPXListenForConnection( retryCount,
                               watchDog,
                               pEcb,
                               EcbAddress );
}


VOID
VWinSPXListenForSequencedPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Attempts to receive an SPX packet.

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VWinSPXListenForSequencedPacket(%04x:%04x)\n",
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwSPXListenForSequencedPacket( pEcb,
                                    EcbAddress );
}


VOID
VWinSPXSendSequencedPacket(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Sends a packet on an SPX connection

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        SPXConnectionID
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXSendSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VWinSPXSendSequencedPacket(%04x, %04x:%04x)\n",
                SPXConnectionID,
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now
    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwSPXSendSequencedPacket( SPXConnectionID,
                               pEcb,
                               EcbAddress );
}


VOID
VWinSPXTerminateConnection(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Terminate an SPX connection by passing a connection ID and an
    ECB address to SPX. Then return control to the calling application.

    This call is Asynchronous

Arguments:

    Inputs
        IPXTaskID
        SPXConnectionID
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXTerminateConnection,
                IPXDBG_LEVEL_INFO,
                "VWinSPXTerminateConnection(%04x, %04x:%04x)\n",
                SPXConnectionID,
                HIWORD(EcbAddress),
                LOWORD(EcbAddress)
                ));

    // ignore IPXTaskID for now

    UNREFERENCED_PARAMETER( IPXTaskID );

    _VwSPXTerminateConnection(SPXConnectionID, pEcb, EcbAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwipx.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwipx.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Internal worker routines for DOS/WOW IPX calls (netware functions).
    The IPX APIs use WinSock to perform the actual operations

    Contents:
        _VwIPXCancelEvent
        _VwIPXCloseSocket
        _VwIPXGetInternetworkAddress
        _VwIPXGetIntervalMarker
        _VwIPXGetLocalTarget
        _VwIPXGetMaxPacketSize
        _VwIPXListenForPacket
        _VwIPXOpenSocket
        _VwIPXRelinquishControl
        _VwIPXScheduleIPXEvent
        _VwIPXSendPacket

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

extern WORD AesTickCount;

//
// functions
//


WORD
_VwIPXCancelEvent(
    IN LPECB pEcb
    )

/*++

Routine Description:

    Internal routine shared by DOS and WIN that cancels event
    described by an ECB

    This call is Synchronous

Arguments:

    Inputs
        pECB

Return Value:

    00h Success
    F9h Can't cancel ECB
    FFh ECB not in use

--*/

{
    LPXECB pXecb;
    WORD status;

    if (!pEcb) {
        return IPX_ECB_NOT_IN_USE;
    }

    //
    // if the ECB is still in the state we left it then LinkAddress will be the
    // address of the XECB which subsequently points back to the ECB. If both
    // these pan out then we have an ECB which we have at least seen before.
    // Maybe we can cancel it?
    //
    // Note: we grab the serialization semaphore here just in case the AES thread
    // is about to complete the ECB
    //

    status = IPX_CANNOT_CANCEL;
    RequestMutex();
    pXecb = (LPXECB)pEcb->LinkAddress;
    if (pXecb) {
        try {
            if (pXecb->Ecb == pEcb) {
                status = IPX_SUCCESS;

                //
                // pXecb ok: increase reference count in case other thread tries
                // to deallocate it while we're trying to cancel it
                //

                ++pXecb->RefCount;
            }
        } except(1) {

            //
            // bad pointer: bogus ECB
            //

        }
    } else {

        //
        // NULL pointer: event probably completed already
        //

        status = IPX_ECB_NOT_IN_USE;
    }
    ReleaseMutex();
    if (status == IPX_SUCCESS) {

        ECB_CANCEL_ROUTINE cancelRoutine;

        //
        // we have an ECB to cancel. If we still have it, it will be on one of
        // the socket queues, the timer list or the async completion list. If
        // the latter we are in a race. Treat such events as already happened.
        // We will cancel events on the timer list and queued send and receive
        // events only
        //

        switch (pXecb->QueueId) {
        case NO_QUEUE:
            status = ECB_CC_CANCELLED;
            goto cancel_exit;

        case ASYNC_COMPLETION_QUEUE:
            cancelRoutine = CancelAsyncEvent;
            break;

        case TIMER_QUEUE:
            cancelRoutine = CancelTimerEvent;
            break;

        case SOCKET_HEADER_QUEUE:        //Multi-User Addition
        case SOCKET_LISTEN_QUEUE:
        case SOCKET_SEND_QUEUE:
            cancelRoutine = CancelSocketEvent;
            break;

        case CONNECTION_CONNECT_QUEUE:
        case CONNECTION_SEND_QUEUE:

            //
            // SPXEstablishConnection and SPXSendSequencedPacket cannot be
            // cancelled using IPXCancelEvent
            //

            status = ECB_CC_CANNOT_CANCEL;
            goto cancel_exit;

        case CONNECTION_ACCEPT_QUEUE:
        case CONNECTION_LISTEN_QUEUE:
            cancelRoutine = CancelConnectionEvent;
            break;
        }
        return cancelRoutine(pXecb);
    }

    //
    // app tried to sneak us an unknown ECB, -OR- the ECB was stomped on,
    // destroying the LinkAddress and hence the address of the XECB. We
    // could search the various lists looking for an XECB whose Ecb field
    // matches pEcb, but if the app has scribbled over the ECB when we
    // (make that Novell) told it not to, chances are it would fail real
    // well on DOS. Probable worst case is that the app is terminating and
    // the ECB may sometime later call an ESR which won't be there. Crashola
    //

cancel_exit:

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXCancelEvent,
                IPXDBG_LEVEL_ERROR,
                "VwIPXCancelEvent: cannot find/cancel ECB %04x:%04x\n",
                HIWORD(pEcb),
                LOWORD(pEcb)
                ));

    pEcb->CompletionCode = (BYTE)status;
    pEcb->InUse = ECB_IU_NOT_IN_USE;
    return status;
}


VOID
_VwIPXCloseSocket(
    IN WORD socketNumber
    )

/*++

Routine Description:

    Closes a socket and cancels any outstanding events on the socket.
    Closing an unopened socket does not return an error
    ESRs in cancelled ECBs are not called

    This call is Synchronous

Arguments:

    Inputs
        socketNumber

Return Value:

    None.

--*/

{
    LPSOCKET_INFO pSocketInfo;

    pSocketInfo = FindSocket(socketNumber);
    if (pSocketInfo != NULL) {
        KillSocket(pSocketInfo);
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_IPXCloseSocket,
                    IPXDBG_LEVEL_WARNING,
                    "_VwIPXCloseSocket: can't locate socket 0x%04x\n",
                    B2LW(socketNumber)
                    ));

    }
}


VOID
_VwIPXGetInternetworkAddress(
    IN LPINTERNET_ADDRESS pNetworkAddress
    )

/*++

Routine Description:

    Returns a buffer containing the net number and node number for this
    station.

    This function cannot return an error (!)

    Assumes:    1. GetInternetAddress has been successfully called in the
                   DLL initialization phase

    This call is Synchronous

Arguments:

    Inputs
        Nothing.

    Outputs
        pNetworkAddress

Return Value:

    None.

--*/

{
    CopyMemory((LPBYTE)pNetworkAddress,
               (LPBYTE)&MyInternetAddress.sa_netnum,
               sizeof(*pNetworkAddress)
               );

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetInternetworkAddress,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetInternetworkAddress: %02x-%02x-%02x-%02x : %02x-%02x-%02x-%02x-%02x-%02x\n",
                pNetworkAddress->Net[0] & 0xff,
                pNetworkAddress->Net[1] & 0xff,
                pNetworkAddress->Net[2] & 0xff,
                pNetworkAddress->Net[3] & 0xff,
                pNetworkAddress->Node[0] & 0xff,
                pNetworkAddress->Node[1] & 0xff,
                pNetworkAddress->Node[2] & 0xff,
                pNetworkAddress->Node[3] & 0xff,
                pNetworkAddress->Node[4] & 0xff,
                pNetworkAddress->Node[5] & 0xff
                ));

}


WORD
_VwIPXGetIntervalMarker(
    VOID
    )

/*++

Routine Description:

    Just returns the tick count maintained by Asynchronous Event Scheduler

    This call is Synchronous

Arguments:

    None.

Return Value:

    The tick count.

--*/

{
//    Sleep(0);
    Sleep(1);         //Multi-User change
    return AesTickCount;
}


WORD
_VwIPXGetLocalTarget(
    IN LPBYTE pNetworkAddress,
    OUT LPBYTE pImmediateAddress,
    OUT ULPWORD pTransportTime
    )

/*++

Routine Description:

    Given a target address of the form (network address {4}, node address {6}),
    returns the node address of the target if on the same network, or the node
    address of the router which knows how to get to the next hop in reaching the
    eventual target

    This call is Synchronous

Arguments:

    Inputs
        pNetworkAddress

    Outputs
        pImmediateAddress
        pTransportTime

Return Value:

    00h Success
    F1h Ipx/Spx Not Initialized
    FAh No path to destination node found

--*/

{
    //
    // the transport handles real routing, so we always return the immediate
    // address as the target address. The transport will only look at the
    // target when routing
    //

    CopyMemory( pImmediateAddress,
                pNetworkAddress + 4,
                6
              );

    *pTransportTime = 1; // ticks

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXGetLocalTarget,
                IPXDBG_LEVEL_INFO,
                "VwIPXGetLocalTarget: IN: %02x-%02x-%02x-%02x:%02x-%02x-%02x-%02x-%02x-%02x OUT: %02x-%02x-%02x-%02x-%02x-%02x\n",
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Net[0] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Net[1] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Net[2] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Net[3] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[0] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[1] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[2] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[3] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[4] & 0xff,
                ((LPINTERNET_ADDRESS)pNetworkAddress)->Node[5] & 0xff,
                pImmediateAddress[0] & 0xff,
                pImmediateAddress[1] & 0xff,
                pImmediateAddress[2] & 0xff,
                pImmediateAddress[3] & 0xff,
                pImmediateAddress[4] & 0xff,
                pImmediateAddress[5] & 0xff
                ));

    return IPX_SUCCESS;
}



WORD
_VwIPXGetMaxPacketSize(
    OUT ULPWORD pRetryCount
    )

/*++

Routine Description:

    Returns the maximum packet size the underlying network can handle

    Assumes:    1. A successfull call to GetMaxPacketSize has been made during
                   DLL initialization
                2. Maximum packet size is constant

    This call is Synchronous

Arguments:

    Outputs
        pRetryCount


Return Value:

    The maximum packet size.

--*/

{
    if ( pRetryCount ) {
        *pRetryCount = 5;   // arbitrary?
    }
    return MyMaxPacketSize;
}


WORD
_VwIPXListenForPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Queue a listen request against a socket. All listen requests will be
    completed asynchronously, unless cancelled by app

    This call is Asynchronous

Arguments:

    Inputs
        pEcb
        EcbAddress

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_IPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_IPXListenForPacket,
                IPXDBG_LEVEL_INFO,
                "_VwIPXListenForPacket(%04x:%04x) socket=%04x ESR=%04x:%04x\n",
                HIWORD(EcbAddress),
                LOWORD(EcbAddress),
                B2LW(pXecb->SocketNumber),
                HIWORD(pXecb->EsrAddress),
                LOWORD(pXecb->EsrAddress)
                ));

    //
    // don't know what real IPX/SPX does if it gets a NULL pointer
    //

    if (!pXecb) {
        return IPX_BAD_REQUEST;
    }

    //
    // the socket must be open already before we can perform a listen
    //

    pSocketInfo = FindSocket(pXecb->SocketNumber);

    //
    // we also return NON_EXISTENT_SOCKET (0xFF) if the socket is in use for SPX
    //

    //
    // There is nothing in the netware documentation that explains
    // what gets returned if this is the case, only a warning about IPX listens
    // and sends can't be made on a socket open for SPX. Really definitive
    //

    if (!pSocketInfo || pSocketInfo->SpxSocket) {
        CompleteEcb(pXecb, ECB_CC_NON_EXISTENT_SOCKET);
        return IPX_NON_EXISTENT_SOCKET;
    }

    //
    // initiate the receive. It may complete if there is data waiting or an
    // error occurs, otherwise the ECB will be placed in a receive pending queue
    // for this socket
    //

    if (GetIoBuffer(pXecb, FALSE, IPX_HEADER_LENGTH)) {
        pXecb->Ecb->InUse = ECB_IU_LISTENING;
        IpxReceiveFirst(pXecb, pSocketInfo);
    } else {
        CompleteEcb(pXecb, ECB_CC_CANCELLED);
    }

    //
    // return success. Any errors will be communicated asynchronously - either
    // indirectly by relevant values in CompletionCode and InUse fields of the
    // ECB or directly by an ESR callback
    //

    return IPX_SUCCESS;
}


WORD
_VwIPXOpenSocket(
    IN OUT ULPWORD pSocketNumber,
    IN BYTE socketType,
    IN WORD dosPDB
    )

/*++

Routine Description:

    Opens a socket for use by IPX or SPX. Puts the socket into non-blocking mode.
    The socket will be bound to IPX

    This call is Synchronous

Arguments:
    Inputs
        *pSocketNumber - The requested socket number
        socketType -  Socket Longevity flag
        dosPDB - DOS PDB. This parameter is not part of the IPX API.
                 Added because we need to remember which DOS executable created
                 the socket: we need to clean-up short-lived sockets when the
                 executable terminates

    Outputs
        pSocketNumber - Assigned socket number

Return Value:

    00h Success
    F0h Ipx Not Installed
    F1h Ipx/Spx Not Initialized
    FEh Socket table full
    FFh Socket already open

--*/

{
    LPSOCKET_INFO pSocketInfo;
    WORD status;

    if ((pSocketInfo = AllocateSocket()) == NULL) {
        return IPX_SOCKET_TABLE_FULL;
    }
    status = (WORD) CreateSocket(SOCKET_TYPE_IPX, pSocketNumber, &pSocketInfo->Socket);
    if (status == IPX_SUCCESS) {

        //
        // set up the SOCKET_INFO fields and add it to our list of open sockets
        //

        pSocketInfo->Owner = dosPDB;
        pSocketInfo->SocketNumber = *pSocketNumber;

        //
        // treat socketType == 0 as short-lived, anything else as long-lived.
        // There doesn't appear to be an error return if the flag is not 0 or 0xFF
        //

        pSocketInfo->LongLived = (BOOL)(socketType != 0);
        QueueSocket(pSocketInfo);

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_IPXOpenSocket,
                    IPXDBG_LEVEL_INFO,
                    "_VwIPXOpenSocket: created socket %04x\n",
                    B2LW(*pSocketNumber)
                    ));

    } else {
        DeallocateSocket(pSocketInfo);

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_IPXOpenSocket,
                    IPXDBG_LEVEL_ERROR,
                    "_VwIPXOpenSocket: Failure: returning %x\n",
                    status
                    ));

    }
    return status;
}


VOID
_VwIPXRelinquishControl(
    VOID
    )

/*++

Routine Description:

    Just sleep for a nominal amount. 

    This call is Synchronous

Arguments:

    None.

Return Value:

    None.

--*/
{
    Sleep(0);
}



VOID
_VwIPXScheduleIPXEvent(
    IN WORD time,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Schedules a an event to occur in some number of ticks. When the tick count
    reaches 0, the ECB InUse field is cleared and any ESR called

    This call is Asynchronous

Arguments:

    Inputs
        time - the delay time ( number of 1/18 second ticks )
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_IPX, pEcb, EcbAddress);

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        return;
    }

    ScheduleEvent(pXecb, time);
}


VOID
_VwIPXSendPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress,
    IN WORD DosPDB
    )

/*++

Routine Description:

    Sends a packet to the target machine/router. This call can be made on a
    socket that is not open

    The app must have filled in the following IPX_ECB fields:

        EsrAddress
        Socket
        ImmediateAddress
        FragmentCount
        fragment descriptor fields

    and the following IPX_PACKET fields:

        PacketType
        Destination.Net
        Destination.Node
        Destination.Socket

    This call is Asynchronous

Arguments:

    Inputs
        pEcb
        EcbAddress
        DosPDB

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_IPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;

    // tommye - MS 30525
    //
    // Make sure the XEcb alloc didn't fail
    //

    if (pXecb == NULL) {
        return;
    }

    //
    // this function returns no immediate status so we must assume that the
    // ECB pointer is valid
    //

    //
    // check the ECB for correctness
    //

    if ((pXecb->Ecb->FragmentCount == 0)
    || (ECB_FRAGMENT(pXecb->Ecb, 0)->Length < IPX_HEADER_LENGTH)) {
        CompleteEcb(pXecb, ECB_CC_BAD_REQUEST);
        return;
    }

    //
    // IPXSendPacket() can be called on an unopened socket: we must try to
    // temporarily allocate the socket
    //
    //  Q: Is the following scenario possible with real IPX:
    //      IPXSendPacket() on unopened socket X
    //      Send fails & gets queued
    //      app makes IPXOpenSocket() call on X; X gets opened
    //
    //  Currently, we would create the temporary socket and fail IPXOpenSocket()
    //  because it is already open!
    //

    pSocketInfo = FindSocket(pXecb->SocketNumber);
    if (!pSocketInfo) {

        //
        // when is temporary socket deleted? After send completed?
        // when app dies? when? Novell documentation is not specific (used
        // to say something else :-))
        //

        pSocketInfo = AllocateTemporarySocket();
        if (pSocketInfo) {

            //
            // set up the SOCKET_INFO fields and add it to our list of open sockets
            //

            pSocketInfo->Owner = DosPDB;

            //
            // temporary sockets are always short-lived
            //

            pSocketInfo->LongLived = FALSE;
            QueueSocket(pSocketInfo);

        } else {

            CompleteEcb(pXecb, ECB_CC_SOCKET_TABLE_FULL);
            return;
        }
    } else if (pSocketInfo->SpxSocket) {

        //
        // see complaint in IPXListenForPacket
        //
        // can't make IPX requests on socket opened for SPX
        //

        CompleteEcb(pXecb, ECB_CC_NON_EXISTENT_SOCKET);
        return;
    }

    //
    // start the send: tries to send the data in one go. Either succeeds, fails
    // with an error, or queues the ECB for subsequent attempts via AES/IPX
    // deferred processing.
    //
    // In the first 2 cases, the ECB has been completed already
    //

    StartIpxSend(pXecb, pSocketInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwinapi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwinapi.h

Abstract:

    Contains function prototypes for WIN IPX/SPX functions

Author:


Environment:

    User-mode Win32

Revision History:

    28-Oct-1993 yihsins
        Created

--*/

WORD
VWinIPXCancelEvent(
    IN DWORD IPXTaskID,
    IN LPECB pEcb
    );

VOID
VWinIPXCloseSocket(
    IN DWORD IPXTaskID,
    IN WORD socketNumber
    );

VOID
VWinIPXDisconnectFromTarget(
    IN DWORD IPXTaskID,
    OUT LPBYTE pNetworkAddress
    );

VOID
VWinIPXGetInternetworkAddress(
    IN DWORD IPXTaskID,
    OUT LPINTERNET_ADDRESS pNetworkAddress
    );

WORD
VWinIPXGetIntervalMarker(
    IN DWORD IPXTaskID
    );

WORD
VWinIPXGetLocalTarget(
    IN DWORD IPXTaskID,
    IN LPBYTE pNetworkAddress,
    OUT LPBYTE pImmediateAddress,
    OUT ULPWORD pTransportTime
    );

WORD
VWinIPXGetLocalTargetAsync(
    IN LPBYTE pSendAGLT,
    OUT LPBYTE pListenAGLT,
    IN WORD windowsHandle
    );

WORD
VWinIPXGetMaxPacketSize(
    VOID
    );

WORD
VWinIPXInitialize(
    IN OUT ULPDWORD pIPXTaskID,
    IN WORD maxECBs,
    IN WORD maxPacketSize
    );

VOID
VWinIPXListenForPacket(
    DWORD IPXTaskID,
    LPECB pEcb,
    ECB_ADDRESS EcbAddress
    );

WORD
VWinIPXOpenSocket(
    IN DWORD  IPXTaskID,
    IN OUT ULPWORD pSocketNumber,
    IN BYTE socketType
    );

VOID
VWinIPXRelinquishControl(
    VOID
    );

VOID
VWinIPXScheduleIPXEvent(
    IN DWORD IPXTaskID,
    IN WORD time,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
VWinIPXSendPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

WORD
VWinIPXSPXDeinit(
    IN DWORD IPXTaskID
    );

VOID
VWinSPXAbortConnection(
    IN WORD SPXConnectionID
    );

WORD
VWinSPXEstablishConnection(
    IN DWORD IPXTaskID,
    IN BYTE retryCount,
    IN BYTE watchDog,
    OUT ULPWORD pSPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

WORD
VWinSPXGetConnectionStatus(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPSPX_CONNECTION_STATS pConnectionStats
    );

WORD
VWinSPXInitialize(
    IN OUT DWORD UNALIGNED* pIPXTaskID,
    IN WORD maxECBs,
    IN WORD maxPacketSize,
    OUT LPBYTE pMajorRevisionNumber,
    OUT LPBYTE pMinorRevisionNumber,
    OUT WORD UNALIGNED* pMaxConnections,
    OUT WORD UNALIGNED* pAvailableConnections
    );

VOID
VWinSPXListenForConnection(
    IN DWORD IPXTaskID,
    IN BYTE retryCount,
    IN BYTE watchDog,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );


VOID
VWinSPXListenForSequencedPacket(
    IN DWORD IPXTaskID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
VWinSPXSendSequencedPacket(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
VWinSPXTerminateConnection(
    IN DWORD IPXTaskID,
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwint.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwint.h

Abstract:

    Contains internal function prototypes used by DOS/WIN IPX/SPX functions

Author:

    Yi-Hsin Sung (yihsins)   28-Oct-1993

Environment:

    User-mode Win32

Revision History:

    28-Oct-1993 yihsins
        Created

--*/

WORD
_VwIPXCancelEvent(
    IN LPECB pEcb
    );

VOID
_VwIPXCloseSocket(
    IN WORD SocketNumber
    );

VOID
_VwIPXGetInternetworkAddress(
    OUT LPINTERNET_ADDRESS pNetworkAddress
    );

WORD
_VwIPXGetIntervalMarker(
    VOID
    );

WORD
_VwIPXGetLocalTarget(
    IN LPBYTE pNetworkAddress,
    OUT LPBYTE pImmediateAddress,
    OUT ULPWORD pTransportTime
    );

WORD
_VwIPXGetMaxPacketSize(
    OUT ULPWORD pRetryCount
    );

WORD
_VwIPXListenForPacket(
    IN OUT LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

WORD
_VwIPXOpenSocket(
    IN OUT ULPWORD pSocketNumber,
    IN BYTE SocketType,
    IN WORD DosPDB
    );

VOID
_VwIPXRelinquishControl(
    VOID
    );

VOID
_VwIPXScheduleIPXEvent(
    IN WORD Time,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
_VwIPXSendPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress,
    IN WORD DosPDB
    );

VOID
_VwSPXAbortConnection(
    IN WORD SPXConnectionID
    );

WORD
_VwSPXEstablishConnection(
    IN BYTE RetryCount,
    IN BYTE WatchDog,
    OUT ULPWORD pSPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

WORD
_VwSPXGetConnectionStatus(
    IN WORD SPXConnectionID,
    OUT LPSPX_CONNECTION_STATS pStats
    );

WORD
_VwSPXInitialize(
    OUT ULPBYTE pMajorRevisionNumber,
    OUT ULPBYTE pMinorRevisionNumber,
    OUT ULPWORD pMaxConnections,
    OUT ULPWORD pAvailableConnections
    );

VOID
_VwSPXListenForConnection(
    IN BYTE RetryCount,
    IN BYTE WatchDog,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
_VwSPXListenForSequencedPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
_VwSPXSendSequencedPacket(
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );

VOID
_VwSPXTerminateConnection(
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwmisc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwipx.h

Abstract:

    Contains function prototypes for VWMISC.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

VOID
VwTerminateProgram(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwmisc.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwmisc.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains miscellaneous (non-IPX/SPX) functions

    Contents:
        VwTerminateProgram

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// functions
//


VOID
VwTerminateProgram(
    VOID
    )

/*++

Routine Description:

    When a DOS program terminates, we must close any open sockets that were
    specified as SHORT_LIVED

Arguments:

    None.

Return Value:

    None.

--*/

{
    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_ANY,
                IPXDBG_LEVEL_INFO,
                "VwTerminateProgram: PDB=%04x\n",
                getCX()
                ));

    KillShortLivedSockets(getCX());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\asmmacro.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    asmmacro.inc
;
;Abstract:
;
;    Contains macros to extend masm functionality:
;
;       jmpc
;       jmpnc
;       jmpne
;       jmps
;       _mkjmp
;
;
;Author:
;
;    Richard L Firth (rfirth) 24-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;Revision History:
;
;    24-Sep-1991 rfirth
;        Created
;
;--



DEFINED_BIT=020h
;ISDEFINED equ %(.type <thing> and DEFINED_BIT)
LABEL_DEFINED equ <(.type &label and DEFINED_BIT)>

DEBUG_MACROS    = 0
;DEBUG_MACROS    = 1


;***    jmpa
;*
;*      jump to label if above. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpa    macro   label
        _mkjmp  ja,jna,&label
endm

;***    jmpc
;*
;*      jump to label if below. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpb    macro   label
        _mkjmp  jb,jnb,&label
endm

;***    jmpc
;*
;*      jump to label if carry flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpc    macro   label
        _mkjmp  jc,jnc,&label
endm



;***    jmpnc
;*
;*      jump to label if carry flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpnc   macro   label
        _mkjmp  jnc,jc,&label
endm



;***    jmpne
;*
;*      jump to label if zero flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpne   macro   label
        _mkjmp  jne,je,&label
endm



;***    jmpe
;*
;*      jump to label if zero flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpe    macro   label
        _mkjmp  je,jne,&label
endm



;***    jmps
;*
;*      jump to label. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmps    macro   label
        local   l,dist
dist=&label-$
if1
if (.type label and DEFINED_BIT)
if ((dist gt 129) or (dist lt -126))
if DEBUG_MACROS
        %out pass1: &label defined and near
endif
        jmp     &label
else
if DEBUG_MACROS
        %out pass1: &label defined and short
endif
        jmp     short &label
endif
else
if DEBUG_MACROS
        %out pass1: &label not defined
endif
        org     $+3
endif
else
if ((dist gt 129) or (dist lt -126))
if DEBUG_MACROS
        %out pass2: &label defined and near
endif
        jmp     &label
else
if DEBUG_MACROS
        %out pass2: &label defined and short
endif
        jmp     short &label
        org     $+1
endif
endif
l:
endm



;***    _mkjmp
;*
;*      Make a jmp<?> macro. Generate instruction sequence for jump with or
;*      without conditional test. Jump may be short (+127/-128 bytes) or near
;*      (+32767/-32768 bytes)
;*
;*      ENTRY   is      - short jump instruction
;*              in      - near jump instruction
;*              label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

_put macro s,v
if2
if DEBUG_MACROS
%out s = v
endif
endif
endm

_mkjmp  macro   is, in, label
        local   l

;;
;; if pass 1 and label is already known, generate correct instruction
;;

if1
if (.type &label and DEFINED_BIT)

;;
;; if label is too far away for short jump instruction, make jump <condition>
;; into jump <NOT condition> round jump to label followed by a near jump to
;; label
;;

if (((&label - $) gt 129) or ((&label - $) lt -126))
        &in     l       ;; short jump, NOT condition
        jmp     &label  ;; jump to where we want to go
else
        &is     &label  ;; short jump
endif

;;
;; if pass 1 and we don't know about the label yet, adjust the program
;; counter by the max. number of bytes taken up by this macro (5 - 2 for
;; short jump, 3 for near jump)
;;

else
        nop
        nop
        nop
        nop
        nop
endif

;;
;; pass 2 - do same stuff as for pass 1
;;

else
if (((&label - $) gt 129) or ((&label - $) lt -126))
 if ((&label-$) gt 129)
        _put    <label distance>, %(&label-$)
 else
        _put    <label distance>, %($-&label)
 endif
        &in     l
        jmp     &label
else

;;
;; label is within +127/-128 bytes of current instruction - generate short
;; jump instruction and put the program counter forward past the space
;; reserved during pass 1
;;

        _put    <label distance>, %(&label-$)
        &is     &label
        nop
        nop
        nop
endif
endif
l:
endm



oldjmps macro   label
if2
if (((&label - $) gt 127) or (($ - &label) lt -128))
        jmp     short l
        jmp     &label
else
        jmp     short &label
        org     $+3
endif
else
;;
;; if this is pass 1 just take up max amount of space so phases don't get
;; screwed
;;
        org     $+5
endif
l:
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwipxspx.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwipxspx.h

Abstract:

    Contains manifests, typedefs, structures, macros for NTVDM IPX/SPX support

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    Structures are expected to live in segmented VDM address space, but be
    accessible from flat 32-bit protect mode. The VDM can be in real or protect
    mode

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#ifndef _VWIPXSPX_H_
#define _VWIPXSPX_H_

//
// FREE_OBJECT - in free version, just calls LocalFree. For debug version, fills
// memory with some arbitrary value, then frees the pointer and checks that what
// LocalFree thought that the pointer pointed at a valid, freeable object
//

#if DBG

#define FREE_OBJECT(p)      {\
                                FillMemory(p, sizeof(*p), 0xFF);\
                                VWASSERT(LocalFree((HLOCAL)(p)), NULL);\
                            }
#else

#define FREE_OBJECT(p)      VWASSERT(LocalFree((HLOCAL)(p)), NULL)

#endif

//
// simple function macros
//

//#define AllocateXecb()      (LPXECB)LocalAlloc(LPTR, sizeof(XECB))
//#define DeallocateXecb(p)   FREE_OBJECT(p)
#define AllocateBuffer(s)   (LPVOID)LocalAlloc(LMEM_FIXED, (s))
#define DeallocateBuffer(p) FREE_OBJECT(p)

//
// pseudo-types for 16-bit addresses
//

#define ESR_ADDRESS DWORD
#define ECB_ADDRESS DWORD

//
// from Novell documentation, the default maximum open sockets. Max max is 150
//

#ifndef DEFAULT_MAX_OPEN_SOCKETS
#define DEFAULT_MAX_OPEN_SOCKETS    20
#endif

#ifndef MAX_OPEN_SOCKETS
#define MAX_OPEN_SOCKETS        150
#endif

#define SPX_INSTALLED           0xFF

#define MAX_LISTEN_QUEUE_SIZE   5   // ?

//
// misc. macros
//

//
// B2LW, L2Bx - big-endian to little-endian macros
//

#define B2LW(w)                 (WORD)(((WORD)(w) << 8) | ((WORD)(w) >> 8))
#define B2LD(d)                 (DWORD)(B2LW((DWORD)(d) << 16) | B2LW((DWORD)(d) >> 16))
#define L2BW(w)                 B2LW(w)
#define L2BD(d)                 B2LD(d)

//
// miscellaneous manifests
//

#define ONE_TICK    (1000/18)           // 1/18 sec in milliseconds (55.55 mSec)
#define SLEEP_TIME  ONE_TICK            // amount of time we Sleep() during IPXRelinquishControl

//
// options for IPXGetInformation
//

#define IPX_ODI                     0x0001
#define IPX_CHECKSUM_FUNCTIONS      0x0002

//
// IPX/SPX structures. The following structures are in VDM format, and should
// be packed on a byte-boundary
//
// Netware maintains certain structure fields in network (big-endian) format
//

#include <packon.h>

//
// INTERNET_ADDRESS - structure returned by IPXGetInternetworkAddress
//

typedef struct {
    BYTE Net[4];
    BYTE Node[6];
} INTERNET_ADDRESS ;

typedef INTERNET_ADDRESS UNALIGNED *LPINTERNET_ADDRESS;

//
// NETWARE_ADDRESS - address of an application on the network, as defined by
// its network segment, node address and socket number
//

typedef struct {
    BYTE Net[4];                        // hi-lo
    BYTE Node[6];                       // hi-lo
    WORD Socket;                        // hi-lo
} NETWARE_ADDRESS ;

typedef NETWARE_ADDRESS UNALIGNED *LPNETWARE_ADDRESS;

//
// FRAGMENT - ECB/IPX/SPX buffers are split into 'fragments'
//

typedef struct {
    LPVOID Address;                     // offset-segment
    WORD Length;                        // hi-lo
} FRAGMENT ;

typedef FRAGMENT UNALIGNED *LPFRAGMENT;

//
// IPX_PACKET - format of packet submitted to IPX for sending. The maximum
// size of an IPX packet is 576 bytes, 30 bytes header, 546 bytes data
//

typedef struct {
    WORD Checksum;                      // always set to 0xFFFF
    WORD Length;                        // set by IPX - header + data
    BYTE TransportControl;              // set by IPX to 0. Used by routers

    //
    // for IPX, PacketType is 0 (Unknown Packet Type) or 4 (Packet Exchange
    // Packet)
    //

    BYTE PacketType;
    NETWARE_ADDRESS Destination;
    NETWARE_ADDRESS Source;
    BYTE Data[];                        // 546 bytes max.
} IPX_PACKET ;

typedef IPX_PACKET UNALIGNED *LPIPX_PACKET;

#define IPX_HEADER_LENGTH           sizeof(IPX_PACKET)
#define MAXIMUM_IPX_PACKET_LENGTH   576
#define MAXIMUM_IPX_DATA_LENGTH     (MAXIMUM_IPX_PACKET_LENGTH - IPX_HEADER_LENGTH)

#define IPX_PACKET_TYPE             4

//
// SPX_PACKET - format of packet submitted to SPX for sending. The maximum
// size of an SPX packet is 576 bytes, 42 bytes header, 534 bytes data
//

typedef struct {
    WORD Checksum;                      // always set to 0xFFFF
    WORD Length;                        // set by IPX - header + data
    BYTE TransportControl;              // set by IPX to 0. Used by routers

    //
    // for SPX, PacketType is set to 5 (Sequenced Packet Protocol Packet)
    //

    BYTE PacketType;
    NETWARE_ADDRESS Destination;
    NETWARE_ADDRESS Source;

    //
    // ConnectionControl is a bitmap which control bi-directional flow over a
    // link. The bits are defined (by Xerox SPP) as:
    //
    //      0-3 undefined
    //      4   end-of-message
    //          This is the only bit which can be directly manipulated by an
    //          app. The bit is passed through unchanged by SPX
    //      5   attention
    //          Ignored by SPX, but passed through
    //      6   acknowledge
    //          Set by SPX if an ack is required
    //      7   system packet
    //          Set by SPX if the packet is internal control. An app should
    //          never see this bit (i.e. should never see a system packet)
    //

    BYTE ConnectionControl;

    //
    // DataStreamType defines the type of data in the packet:
    //
    //      0x00 - 0xFD client-defined.
    //                      Ignored by SPX
    //      0xFE        end-of-connection.
    //                      When active connection is terminated, SPX
    //                      generates and sends a packet with this bit set.
    //                      This will be the last packet sent on the connection
    //      0xFF        end-of-connection acknowledgement
    //                      SPX generates a system packet to acknowledge an
    //                      end-of-connection packet
    //

    BYTE DataStreamType;
    WORD SourceConnectId;               // assigned by SPX
    WORD DestinationConnectId;
    WORD SequenceNumber;                // managed by SPX
    WORD AckNumber;                     // managed by SPX
    WORD AllocationNumber;              // managed by SPX
    BYTE Data[];                        // 534 bytes max.

} SPX_PACKET ;

typedef SPX_PACKET UNALIGNED *LPSPX_PACKET;

#define SPX_HEADER_LENGTH           sizeof(SPX_PACKET)
#define MAXIMUM_SPX_PACKET_LENGTH   MAXIMUM_IPX_PACKET_LENGTH
#define MAXIMUM_SPX_DATA_LENGTH     (MAXIMUM_SPX_PACKET_LENGTH - SPX_HEADER_LENGTH)

#define SPX_PACKET_TYPE             5

//
// ConnectionControl flags
//

#define SPX_CONNECTION_RESERVED 0x0F
#define SPX_END_OF_MESSAGE      0x10
#define SPX_ATTENTION           0x20
#define SPX_ACK_REQUIRED        0x40
#define SPX_SYSTEM_PACKET       0x80

//
// DataStreamType values
//

#define SPX_DS_ESTABLISH        0x00
#define SPX_DS_TERMINATE        0xfe

//
// IPX_ECB - Event Control Block. This structure is used by most IPX/SPX APIs,
// especially when deferred IPX/AES processing is required. The following
// structure is a socket-based ECB
//

typedef struct {

    //
    // LinkAddress is reserved for use by IPX. We use it to link the ECB onto
    // a queue. We appropriate the space used for an x86 segmented address
    // (real or protect mode) as a flat 32-bit pointer
    //

    ULPVOID LinkAddress;                // offset-segment

    //
    // EsrAddress is non-NULL if an Event Service Routine will be called when
    // the event described by the ECB completes. This will always be an x86
    // segmented address (real or protect mode)
    //

    ESR_ADDRESS EsrAddress;             // offset-segment

    //
    // IPX uses the InUse field to mark the ECB as owned by IPX (!0) or by the
    // app (0):
    //
    //      0xF8    App tried to send a packet while IPX was busy; IPX queued
    //              the ECB
    //      0xFA    IPX is processing the ECB
    //      0xFB    IPX has used the ECB for some event and put it on a queue
    //              for processing
    //      0xFC    the ECB is waiting for an AES event to occur
    //      0xFD    the ECB is waiting for an IPX event to occur
    //      0xFE    IPX is listening on a socket for incoming packets
    //      0xFF    IPX is using the ECB to send a packet
    //

    BYTE InUse;

    //
    // CompletionCode is used to return a status from a deferred request. This
    // field is not valid until InUse has been set to 0
    //
    // NOTE: We have to differentiate between AES and IPX ECBs on callbacks: due
    // to their different sizes, we store the 16-bit segment and offset in
    // different places. In order to differentiate the ECBs, we use CompletionCode
    // field (AesWorkspace[0]) as the owner. The real CompletionCode for IPX ECBs
    // goes in IPX_ECB_COMPLETE (DriverWorkspace[7]). But only for completed ECBs
    // that have an ESR
    //

    BYTE CompletionCode;
    WORD SocketNumber;                  // hi-lo

    //
    // the first word of IpxWorkspace is used to return the connection ID of
    // an SPX connection
    //

    DWORD IpxWorkspace;
    BYTE DriverWorkspace[12];

    //
    // ImmediateAddress is the local network node at the remote end of this
    // connection. It is either the node address of the remote machine if it
    // is on this LAN, or it is the node address of the router if the remote
    // machine is on a different LAN
    //
    // This field must be initialized when talking over IPX, but not SPX
    //

    BYTE ImmediateAddress[6];

    //
    // FragmentCount - number of FRAGMENT structures that comprise the request.
    // Must be at least 1
    //

    WORD FragmentCount;

    //
    // FragmentCount fragments start here
    //

} IPX_ECB ;

typedef IPX_ECB UNALIGNED *LPIPX_ECB;

//
// ECB InUse values
//

#define ECB_IU_NOT_IN_USE               0x00
#define ECB_IU_TEMPORARY                0xCC
#define ECB_IU_LISTENING_SPX            0xF7    // same as win16 (by observation)
#define ECB_IU_SEND_QUEUED              0xF8
#define ECB_IU_AWAITING_CONNECTION      0xF9    // same as win16 (by observation)
#define ECB_IU_BEING_PROCESSED          0xFA
#define ECB_IU_AWAITING_PROCESSING      0xFB
#define ECB_IU_AWAITING_AES_EVENT       0xFC
#define ECB_IU_AWAITING_IPX_EVENT       0xFD
#define ECB_IU_LISTENING                0xFE
#define ECB_IU_SENDING                  0xFF

//
// ECB CompletionCode values
//

#define ECB_CC_SUCCESS                  0x00
#define ECB_CC_CONNECTION_TERMINATED    0xEC
#define ECB_CC_CONNECTION_ABORTED       0xED
#define ECB_CC_INVALID_CONNECTION       0xEE
#define ECB_CC_CONNECTION_TABLE_FULL    0xEF
#define ECB_CC_CANNOT_CANCEL            0xF9
#define ECB_CC_CANCELLED                0xFC
#define ECB_CC_BAD_REQUEST              0xFD
#define ECB_CC_BAD_SEND_REQUEST         0xFD
#define ECB_CC_PACKET_OVERFLOW          0xFD
#define ECB_CC_UNDELIVERABLE            0xFE
#define ECB_CC_SOCKET_TABLE_FULL        0xFE
#define ECB_CC_BAD_LISTEN_REQUEST       0xFF
#define ECB_CC_HARDWARE_ERROR           0xFF
#define ECB_CC_NON_EXISTENT_SOCKET      0xFF

//
// we commandeer certain (reserved) fields for our own internal use:
//
//  LPECB   EcbLink     LinkAddress
//  PVOID   Buffer32    DriverWorkspace[0]
//  WORD    Length32    DriverWorkspace[4]
//  WORD    Flags32     DriverWorkspace[6]
//  WORD    OriginalEs  DriverWorkspace[8]
//  WORD    OriginalSi  DriverWorkspace[10]
//

#define ECB_TYPE(p)         (((LPIPX_ECB)(p))->CompletionCode)
#define IPX_ECB_SEGMENT(p)  (WORD)*((ULPWORD)&(((LPIPX_ECB)(p))->IpxWorkspace)+0)
#define IPX_ECB_OFFSET(p)   (WORD)*((ULPWORD)&(((LPIPX_ECB)(p))->IpxWorkspace)+2)
#define IPX_ECB_BUFFER32(p) (ULPVOID)*(ULPVOID*)&(((LPIPX_ECB)(p))->DriverWorkspace[0])
#define IPX_ECB_LENGTH32(p) (WORD)*(ULPWORD)&(((LPIPX_ECB)(p))->DriverWorkspace[4])
#define IPX_ECB_FLAGS32(p)  (((LPIPX_ECB)(p))->DriverWorkspace[6])
#define IPX_ECB_COMPLETE(p) (((LPIPX_ECB)(p))->DriverWorkspace[7])

#define SPX_ECB_CONNECTION_ID(p)    (WORD)*(ULPWORD)&(((LPIPX_ECB)(p))->IpxWorkspace)

//
// ECB Flags32 flags
//

#define ECB_FLAG_BUFFER_ALLOCATED   0x01

//
// ECB types
//

#define ECB_TYPE_AES    0
#define ECB_TYPE_IPX    1
#define ECB_TYPE_SPX    2

//
// ECB owners
//

#define ECB_OWNER_IPX   0xFF
#define ECB_OWNER_AES   0x00

//
// ECB_FRAGMENT - macro which gives the address of the first fragment structure
// within a socket-based ECB
//

#define ECB_FRAGMENT(p, n)  ((LPFRAGMENT)(((LPIPX_ECB)(p) + 1)) + (n))

//
// AES_ECB - used by AES, these socket-less ECBs are used to schedule events
//

typedef struct {
    ULPVOID LinkAddress;                // offset-segment
    ESR_ADDRESS EsrAddress;             // offset-segment
    BYTE InUse;

    //
    // first 3 bytes overlay CompletionCode (1) and SocketNumber (2) fields of
    // IPX_ECB. Last 2 bytes overlay first 2 bytes of IpxWorkspace (4) field of
    // IPX_ECB. We use the 1st byte of the common unused fields as the ECB type
    // (send/receive/timed-event)
    //

    BYTE AesWorkspace[5];
} AES_ECB ;

typedef AES_ECB UNALIGNED *LPAES_ECB;

//
// as with IPX_ECB, we 'borrow' some of the reserved fields for our own use
//

#define AES_ECB_SEGMENT(p)  (WORD)*(ULPWORD)&(((LPAES_ECB)(p))->AesWorkspace[1])
#define AES_ECB_OFFSET(p)   (WORD)*(ULPWORD)&(((LPAES_ECB)(p))->AesWorkspace[3])

//
// LPECB - points to either IPX_ECB or AES_ECB. Both in VDM workspace
//

#define LPECB LPIPX_ECB

//
// SPX_CONNECTION_STATS - returned by SPXGetConnectionStatus. All WORD fields
// are to be returned HiLo (ie to Hawaii). All fields come back from NT SPX
// transport in HiLo format also (this was changed recently, used to be in
// Intel order).
//

typedef struct {
    BYTE State;
    BYTE WatchDog;
    WORD LocalConnectionId;
    WORD RemoteConnectionId;
    WORD LocalSequenceNumber;
    WORD LocalAckNumber;
    WORD LocalAllocNumber;
    WORD RemoteAckNumber;
    WORD RemoteAllocNumber;
    WORD LocalSocket;
    BYTE ImmediateAddress[6];
    BYTE RemoteNetwork[4];
    BYTE RemoteNode[6];
    WORD RemoteSocket;
    WORD RetransmissionCount;
    WORD EstimatedRoundTripDelay;
    WORD RetransmittedPackets;
    WORD SuppressedPackets;
} SPX_CONNECTION_STATS ;

typedef SPX_CONNECTION_STATS UNALIGNED* LPSPX_CONNECTION_STATS;

#include <packoff.h>

//
// 16-bit parameter get/set macros. These may change depending on requirements
// of real/protect mode parameters (e.g. stack based vs. register based)
//

#define IPX_GET_AES_ECB(p)          (p) = (LPAES_ECB)POINTER_FROM_WORDS(getES(), getSI(), sizeof(AES_ECB))
#define IPX_GET_IPX_ECB(p)          (p) = (LPIPX_ECB)POINTER_FROM_WORDS(getES(), getSI(), sizeof(IPX_ECB))
#define IPX_GET_SOCKET(s)           (s) = (WORD)getDX()
#define IPX_GET_SOCKET_LIFE(l)      (l) = (BYTE)getBP()
#define IPX_GET_SOCKET_OWNER(o)     (o) = (WORD)getCX()
#define IPX_GET_BUFFER(p, s)        (p) = (ULPBYTE)POINTER_FROM_WORDS(getES(), getSI(), (s))
#define IPX_GET_ECB_SEGMENT()       getES()
#define IPX_GET_ECB_OFFSET()        getSI()

#define IPX_SET_STATUS(s)           setAL((BYTE)(s))
#define IPX_SET_SOCKET(s)           setDX((WORD)(s))
#define IPX_SET_INFORMATION(v)      setDX((WORD)(v))

#define SPX_SET_STATUS(s)           setAL((BYTE)(s))
#define SPX_SET_CONNECTION_ID(i)    setDX((WORD)(i))

//
// macros returning 16-bit API parameters - may fetch register contents or values
// from stack/memory
//

#define ECB_PARM_SEGMENT()          getES()
#define ECB_PARM_OFFSET()           getSI()
#define ECB_PARM_ADDRESS()          (ECB_ADDRESS)MAKELONG(getSI(), getES())

#define AES_ECB_PARM()              RetrieveEcb(ECB_TYPE_AES)

#define IPX_ECB_PARM()              RetrieveEcb(ECB_TYPE_IPX)
#define IPX_SOCKET_PARM()           getDX()
#define IPX_SOCKET_LIFE_PARM()      (BYTE)getBP()
#define IPX_SOCKET_OWNER_PARM()     getCX()
#define IPX_BUFFER_PARM(s)          (ULPBYTE)POINTER_FROM_WORDS(getES(), getSI(), (s))
#define IPX_TICKS_PARM()            getBP()

#define SPX_RETRY_COUNT_PARM()      (BYTE)getBP()
#define SPX_WATCHDOG_FLAG_PARM()    ((BYTE)(getBP() >> 8))
#define SPX_ECB_PARM()              RetrieveEcb(ECB_TYPE_IPX)
#define SPX_CONNECTION_PARM()       getDX()
#define SPX_BUFFER_PARM(s)          (ULPBYTE)POINTER_FROM_WORDS(getES(), getSI(), (s))

//
// IPX error codes - same codes used in different circumstances
//

#define IPX_SUCCESS                 0x00
#define IPX_CANNOT_CANCEL           0xF9
#define IPX_NO_PATH_TO_DESTINATION  0xFA
#define IPX_CANCELLED               0xFC
#define IPX_BAD_REQUEST             0xFD
#define IPX_SOCKET_TABLE_FULL       0xFE
#define IPX_UNDELIVERABLE           0xFE
#define IPX_SOCKET_ALREADY_OPEN     0xFF
#define IPX_HARDWARE_ERROR          0xFF
#define IPX_NON_EXISTENT_SOCKET     0xFF
#define IPX_ECB_NOT_IN_USE          0xFF

//
// SPX error codes - same codes used in different circumstances
//

#define SPX_SUCCESS                 0x00
#define SPX_CONNECTION_TERMINATED   0xEC
#define SPX_CONNECTION_ABORTED      0xED
#define SPX_INVALID_CONNECTION      0xEE
#define SPX_CONNECTION_TABLE_FULL   0xEF
#define SPX_SOCKET_CLOSED           0xFC
#define SPX_PACKET_OVERFLOW         0xFD
#define SPX_BAD_SEND_REQUEST        0xFD    // malformed packet
#define SPX_BAD_LISTEN_REQUEST      0xFF
#define SPX_NON_EXISTENT_SOCKET     0xFF

#endif // _VWIPXSPX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwipx.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwipx.h

Abstract:

    Contains function prototypes for VWIPX.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

VOID
VwIPXCancelEvent(
    VOID
    );

VOID
VwIPXCloseSocket(
    VOID
    );

VOID
VwIPXDisconnectFromTarget(
    VOID
    );

VOID
VwIPXGenerateChecksum(
    VOID
    );

VOID
VwIPXGetInformation(
    VOID
    );

VOID
VwIPXGetInternetworkAddress(
    VOID
    );

VOID
VwIPXGetIntervalMarker(
    VOID
    );

VOID
VwIPXGetLocalTarget(
    VOID
    );

VOID
VwIPXGetLocalTargetAsync(
    VOID
    );

VOID
VwIPXGetMaxPacketSize(
    VOID
    );

VOID
VwIPXInitialize(
    VOID
    );

VOID
VwIPXListenForPacket(
    VOID
    );

VOID
VwIPXOpenSocket(
    VOID
    );

VOID
VwIPXRelinquishControl(
    VOID
    );

VOID
VwIPXScheduleAESEvent(
    VOID
    );

VOID
VwIPXScheduleIPXEvent(
    VOID
    );

VOID
VwIPXSendPacket(
    VOID
    );

VOID
VwIPXSendWithChecksum(
    VOID
    );

VOID
VwIPXSPXDeinit(
    VOID
    );

VOID
VwIPXVerifyChecksum(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\debugmac.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    debugmac.inc
;
;Abstract:
;
;    Contains debugging macros:
;
;       DbgBreakPoint
;       DbgUnsupported
;       DbgDEBUG
;       DbgPrint
;       DbgPrintTty
;       DbgPrintString
;       DbgPrintHexDword
;       DbgPrintHexWord
;       DbgPrintHexByte
;       DbgPrintNearPointer
;       DbgPrintFarPointer
;
;Author:
;
;    Richard L Firth (rfirth) 13-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;[Notes:]
;
;    optional-notes
;
;Revision History:
;
;    13-Sep-1991 rfirth
;        Created
;
;--


;***    DbgBreakPoint
;*
;*      Same as NT routine of same name. No-op in non-DEBUG version
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgBreakPoint macro
if DEBUG
        int     3
endif
endm

;***    DbgUnsupported
;*
;*      Causes the 32-bit support code to display a message about an unsupported
;*      service code, and dumps the 16-bit registers. Used to discover when an
;*      unsupported int 2f/11 call or int 21/5f call is being made
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgUnsupported macro
if DEBUG
        SVC     -1
endif
endm

;***    DbgDEBUG
;*
;*      Prints the string "DEBUG: " to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    ax
;*
;*      ASSUMES 286+
;*
;***

DbgDEBUG macro
        mov     ax,(14 shl 8) + 'D'
        int     10h
        mov     al,'E'
        int     10h
        mov     al,'B'
        int     10h
        mov     al,'U'
        int     10h
        mov     al,'G'
        int     10h
        mov     al,':'
        int     10h
        mov     al,' '
        int     10h
endm



;***    DbgCrLf
;*
;*      Prints CR,LF to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgCrLf macro
        push    ax
        mov     ax,(14 shl 8) + 13
        int     10h
        mov     al,10
        int     10h
        pop     ax
endm



;***    DbgPrint
;*
;*      Prints an ASCIZ string to console using Bios Int 10h
;*
;*      ENTRY   string  - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrint macro string
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; save regs used by DbgPrintTty
        push    ax
        push    bx
        push    si
        push    ds
        mov     ax,seg string
        mov     ds,ax
        mov     si,offset string;; ds:si = address of string
        DbgPrintTty             ;; display it on console
        pop     ds
        pop     si
        pop     bx
        pop     ax
        popf
endif
endm



;***    DbgPrintTty
;*
;*      Prints an ASCIZ string in ds:si to console using Bios Int 10h
;*
;*      ENTRY   page    - if present defines which Bios video page to use
;*                        Defaults to 0
;*              ds:si   - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    al, bh, si, flags
;*
;*      ASSUMES 286+
;*
;***

DbgPrintTty macro page
        local   l1,l2

if DEBUG                        ;; no macro if not debug version
        mov     ah,14           ;; Bios Int write character as TTY function
ifb <page>
        sub     bh,bh
else
        mov     bh,page
endif
        cld                     ;; autoincrement lodsb
l1:     lodsb                   ;; al := next character; si := next character addr
        or      al,al           ;; eof string?
        jz      l2              ;; yes
        int     10h             ;; display it to console
        jmp     short l1        ;; go round again
l2:
endif
endm



;***    DbgPrintString
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions. The string "DEBUG: " will be
;*      displayed if the banner parm is not blank
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*              banner  - the "DEBUG: " banner will be printed if not blank
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintString macro string, banner
        local   s1
        local   l1

if DEBUG                        ;; no macro if not debug version
        jmp     short l1
s1      db      &string,0
l1:     pushf                   ;; don't destroy direction flag
        pusha                   ;; save gp regs
ifb <banner>
        DbgDEBUG                ;; Display "DEBUG: "
endif
        push    ds              ;; save user's data seg
        push    cs
        pop     ds              ;; ds == cs
        mov     si,offset cs:s1 ;; si := string offset
        DbgPrintTty             ;; display ds:si to console
        pop     ds              ;; restore user's data seg
        popa                    ;; restore gp regs
        popf                    ;; restore direction flag+
endif
endm



;***    DbgPrintHexDword
;*
;*      Prints a dword to console in hex notation using Bios Int 10h
;*
;*      ENTRY   dword   - dword to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexDword macro dword
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexDword not implemented yet",13,10>
endif
endm



;***    DbgPrintHexWord
;*
;*      Prints a word to console in hex notation using Bios Int 10h
;*
;*      ENTRY   word    - to print. Can be memory or register
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexWord macro word
        local   l1, l2
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; don't use any registers
        push    ax
        push    cx
        push    dx
ifdifi <word>,<ax>
        mov     ax,word
endif
        mov     cx,4
l1:     rol     ax,4
        mov     dx,ax
        and     al,0fh
        cmp     al,9
        jle     l2
        add     al,'a'-('9'+1)
l2:     add     al,'0'
        mov     ah,14
        int     10h
        mov     ax,dx
        loop    l1
        pop     dx
        pop     cx
        pop     ax
        popf
endif
endm



;***    DbgPrintHexByte
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*
;*      EXIT
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexByte macro byte
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexByte not implemented yet",13,10>
endif
endm



DbgPrintNearPointer macro nearptr
endm



DbgPrintFarPointer macro farptr
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\segorder.inc ===
;/*++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    segorder.inc
;
;Abstract:
;
;    This module contains the segment order and segment macros
;
;Author:
;
;    Richard Firth (rfirth) 05-Sep-1991
;
;Environment:
;
;    Dos mode only
;
;Notes:
;
;    When initially loaded, the NT VDM redir has the following order:
;
;       +----------------------+
;       |                      |
;       |    Resident Code     |
;       |                      |
;       +----------------------+
;       |                      |
;       |    Resident Data     |
;       |                      |
;       +----------------------+ ----------------+
;       |                      |                 |
;       | Initialisation Code  | <- entry point  v
;       |                      |
;       +----------------------+
;       |                      |                 all the stuff between these
;       | Initialisation Data  |                 arrows is discarded if we stay
;       |                      |                 resident. Note that the redir
;       +----------------------+                 does not uninstall
;       |                      |
;       | Initialisation Stack |                 ^
;       |                      |                 |
;       +----------------------+ ----------------+
;
;Revision History:
;
;    05-Sep-1991 rfirth
;        Created
;
;--*/



ResidentStart   segment public para 'code'
ResidentStart   ends

ResidentCode    segment public word 'code'
ResidentCode    ends

ResidentData    segment public word 'data'
ResidentData    ends

ResidentEnd     segment public para 'data'
ResidentEnd     ends

ResidentGroup   group   ResidentStart, ResidentCode, ResidentData, ResidentEnd

InitCode        segment public para 'init'
InitCode        ends

InitData        segment public word 'init'
InitData        ends

InitStack       segment stack para 'stack'
InitStack       ends

;
; macros to avoid having to type in/possibly alter segment header guff
;

ResidentCodeStart macro
ResidentCode    segment public word 'code'
endm

ResidentCodeEnd macro
ResidentCode    ends
endm

ResidentDataStart macro
ResidentData    segment public word 'data'
endm

ResidentDataEnd macro
ResidentData    ends
endm

InitCodeStart   macro
InitCode        segment public para 'init'
endm

InitCodeEnd     macro
InitCode        ends
endm

InitDataStart   macro
InitData        segment public word 'init'
endm

InitDataEnd     macro
InitData        ends
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwspx.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwspx.h

Abstract:

    Contains function prototypes for VWSPX.C

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

VOID
VwSPXAbortConnection(
    VOID
    );

VOID
VwSPXEstablishConnection(
    VOID
    );

VOID
VwSPXGetConnectionStatus(
    VOID
    );

VOID
VwSPXInitialize(
    VOID
    );

VOID
VwSPXListenForConnection(
    VOID
    );

VOID
VwSPXListenForSequencedPacket(
    VOID
    );

VOID
VwSPXSendSequencedPacket(
    VOID
    );

VOID
VwSPXTerminateConnection(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwspx.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwspx.c

Abstract:

    ntVdm netWare (Vw) IPX/SPX Functions

    Vw: The peoples' network

    Contains internal routines for DOS/WOW SPX calls (netware functions).
    The SPX APIs use WinSock to perform the actual operations

    Contents:
        _VwSPXAbortConnection
        _VwSPXEstablishConnection
        _VwSPXGetConnectionStatus
        _VwSPXInitialize
        _VwSPXListenForConnection
        _VwSPXListenForSequencedPacket
        _VwSPXSendSequencedPacket
        _VwSPXTerminateConnection

    The SPX functions build on the IPX functions (VWIPX.C). SPX maintains
    connections, IPX maintains sockets. A socket may have a list of connections

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    User-mode Win32

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

#include "vw.h"
#pragma hdrstop

//
// functions
//


VOID
_VwSPXAbortConnection(
    IN WORD SPXConnectionID
    )

/*++

Routine Description:

    Aborts a connection. Because NWLink doesn't differentiate between abrupt
    and graceful closes, this function has the same effect as
    VwSPXTerminateConnection

Arguments:

    SPXConnectionID - connection to abort

Return Value:

    None.

--*/

{
    LPCONNECTION_INFO pConnectionInfo;

    RequestMutex();
    pConnectionInfo = FindConnection(SPXConnectionID);
    if (pConnectionInfo) {
        DequeueConnection(pConnectionInfo->OwningSocket, pConnectionInfo);
        AbortOrTerminateConnection(pConnectionInfo, ECB_CC_CONNECTION_ABORTED);
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXAbortConnection,
                    IPXDBG_LEVEL_ERROR,
                    "VwSPXAbortConnection: cannot find connection %04x\n",
                    SPXConnectionID
                    ));

    }
    ReleaseMutex();
}


WORD
_VwSPXEstablishConnection(
    IN BYTE retryCount,
    IN BYTE watchDogFlag,
    OUT ULPWORD pSPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Creates a connection with a remote SPX socket. The remote end can be on
    this machine (i.e. same app in DOS world)

    This call is Asynchronous

Arguments:

    Inputs
        retryCount
        watchDogFlag
        pEcb
        EcbAddress

    Outputs
        pSPXConnectionID

Return Value:

    00h Attempting to talk to remote
    EFh Local connection table full
    FDh Fragment count not 1; buffer size not 42
    FFh Send socket not open

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;
    LPCONNECTION_INFO pConnectionInfo;
    WORD connectionId;
    LPSPX_PACKET pPacket;
    SOCKADDR_IPX destination;
    int rc;
    SOCKET s;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    // We don't know what the real SPX does if a malloc fails.
    //

    if (pXecb == NULL) {
        return SPX_BAD_SEND_REQUEST;
    }

    pSocketInfo = FindSocket(pXecb->SocketNumber);
    if (!pSocketInfo) {
        CompleteEcb(pXecb, ECB_CC_NON_EXISTENT_SOCKET);
        return SPX_NON_EXISTENT_SOCKET;
    }

    //
    // if no outstanding IPX operations, change socket to SPX
    //

    if (!pSocketInfo->SpxSocket) {
        if (!(pSocketInfo->PendingSends && pSocketInfo->PendingListens)) {
            rc = ReopenSocket(pSocketInfo);
        } else {
            rc = ECB_CC_BAD_SEND_REQUEST;
        }
        if (rc != SPX_SUCCESS) {
            CompleteOrQueueEcb(pXecb, (BYTE)rc);
            return SPX_BAD_SEND_REQUEST;
        }
    }

    //
    // real SPX will use the ECB to send an ESTABLISH CONNECTION packet. This
    // is handled for us within the SPX transport. Nevertheless we must check
    // the fragment and dismiss the request if its not sufficient
    //

    if ((pXecb->Ecb->FragmentCount != 1)
    || (ECB_FRAGMENT(pXecb->Ecb, 0)->Length < SPX_HEADER_LENGTH)) {
        CompleteEcb(pXecb, ECB_CC_BAD_SEND_REQUEST);
        return SPX_BAD_SEND_REQUEST;
    }

    //
    // the socket is open for SPX. Allocate a connection/connection ID
    //

    pConnectionInfo = AllocateConnection(pSocketInfo);
    if (pConnectionInfo) {

        //
        // create new socket, bound to the same local address as the parent
        // socket. This is the 'connection'
        //

#if REUSEADDR

        connectionId = pSocketInfo->SocketNumber;
        rc = CreateSocket(SOCKET_TYPE_SPX, &connectionId, &pConnectionInfo->Socket);
        s = pConnectionInfo->Socket;
//        if (rc == SPX_SUCCESS) {

#else

        s = socket(AF_IPX, SOCK_SEQPACKET, NSPROTO_SPX);
        if (s != INVALID_SOCKET) {

            u_long arg = !0;

            //
            // put the socket in non-blocking I/O mode
            //

            rc = ioctlsocket(s, FIONBIO, &arg);
            if (rc != SOCKET_ERROR) {

                int true = 1;

                rc = setsockopt(s,
                                NSPROTO_IPX,
                                IPX_RECVHDR,
                                (char FAR*)&true,
                                sizeof(true)
                                );
                if (rc != SOCKET_ERROR) {
                    pConnectionInfo->Socket = s;
                } else {

                    IPXDBGPRINT((__FILE__, __LINE__,
                                FUNCTION_SPXEstablishConnection,
                                IPXDBG_LEVEL_ERROR,
                                "VwSPXEstablishConnection: setsockopt(IPX_RECVHDR) returns %d\n",
                                WSAGetLastError()
                                ));

                }
            } else {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_SPXEstablishConnection,
                            IPXDBG_LEVEL_ERROR,
                            "VwSPXEstablishConnection: ioctlsocket(FIONBIO) returns %d\n",
                            WSAGetLastError()
                            ));

            }
        } else {
            rc = WSAGetLastError();

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXEstablishConnection,
                        IPXDBG_LEVEL_ERROR,
                        "VwSPXEstablishConnection: socket() returns %d\n",
                        rc
                        ));

        }

#endif

    } else {
        rc = !SPX_SUCCESS;
    }

    if (rc == SPX_SUCCESS) {
        pConnectionInfo->State = CI_STARTING;
        connectionId = pConnectionInfo->ConnectionId;

        //
        // set the ECB InUse field to 0xF7. Same as snowball by observation (and
        // probably correct anyway since it looks as though 0xF7 means 'waiting
        // to receive SPX packet', which is true in this case - normally SPX
        // creates a connection by sending an establish frame then waits for the
        // ack frame
        //

        pXecb->Ecb->InUse = ECB_IU_LISTENING_SPX;
    } else {

        //
        // if we failed to get CONNECTION_INFO or create the new socket, return
        // immediately with an error (socket table full?)
        //

        if (s != INVALID_SOCKET) {
            closesocket(s);
        }
        if (pConnectionInfo) {
            DeallocateConnection(pConnectionInfo);
        }
        CompleteEcb(pXecb, ECB_CC_CONNECTION_TABLE_FULL);
        return SPX_CONNECTION_TABLE_FULL;
    }

    //
    // get the destination info from the SPX header in VDM memory and set up the
    // connection. If the connect request would wait then we leave AES to
    // periodically check the progress of the request
    //

    pPacket = (LPSPX_PACKET)GET_FAR_POINTER(&ECB_FRAGMENT(pXecb->Ecb, 0)->Address,
                                                          IS_PROT_MODE(pXecb)
                                                          );

    if (pPacket == NULL) {
        CompleteEcb(pXecb, ECB_CC_BAD_SEND_REQUEST);
        return SPX_BAD_SEND_REQUEST;
    }

    //
    // fill in the packet details (app shouldn't look at these until the command
    // completes). In 16-bit SPX, these values are filled in by the transport.
    // Our transport does not return these values, so we have to 'invent' them,
    // but since they are fairly static it should be ok (maybe the transport
    // should return them)
    //

    pPacket->Checksum = 0xffff;
    pPacket->Length = L2BW(SPX_HEADER_LENGTH);
    pPacket->TransportControl = 0;
    pPacket->PacketType = SPX_PACKET_TYPE;
    pPacket->Source.Socket = pSocketInfo->SocketNumber;
    pPacket->ConnectionControl = SPX_SYSTEM_PACKET | SPX_ACK_REQUIRED;
    pPacket->DataStreamType = SPX_DS_ESTABLISH;
    pPacket->SourceConnectId = pConnectionInfo->ConnectionId;
    pPacket->DestinationConnectId = 0xffff;
    pPacket->SequenceNumber = 0;
    pPacket->AckNumber = 0;
    pPacket->AllocationNumber = 0;

    //
    // get the destination address info
    //

    CopyMemory(&destination.sa_netnum,
               (LPBYTE)&pPacket->Destination,
               sizeof(pPacket->Destination)
               );
    destination.sa_family = AF_IPX;

    //
    // initiate the connection
    //

    rc = connect(s, (LPSOCKADDR)&destination, sizeof(destination));
    if (rc != SOCKET_ERROR) {

        //
        // add the CONNECTION_INFO structure to the list of connections owned
        // by this socket and set the connection state to ESTABLISHED
        //

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXEstablishConnection,
                    IPXDBG_LEVEL_INFO,
                    "VwSPXEstablishConnection: socket connected\n"
                    ));

        RequestMutex();
        QueueConnection(pSocketInfo, pConnectionInfo);
        pConnectionInfo->State = CI_ESTABLISHED;
        ReleaseMutex();

        //
        // the connection ID also appears in the first segment of the establish
        // ECB
        //

        pPacket->SourceConnectId = connectionId;

        //
        // the SPXEstablishConnection ECB is done!
        //

        CompleteEcb(pXecb, ECB_CC_SUCCESS);
    } else {
        rc = WSAGetLastError();
        if (rc == WSAEWOULDBLOCK) {

            //
            // the connect request is in progress. Add it to the queue of
            // pending SPXEstablishConnection requests (SHOULD ONLY BE 1 PER
            // CONNECTION!!!) and add the CONNECTION_INFO structure to the
            // owning SOCKET_INFO structure
            //

            RequestMutex();
            QueueEcb(pXecb,
                     &pConnectionInfo->ConnectQueue,
                     CONNECTION_CONNECT_QUEUE
                     );
            QueueConnection(pSocketInfo, pConnectionInfo);
            ReleaseMutex();

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXEstablishConnection,
                        IPXDBG_LEVEL_INFO,
                        "VwSPXEstablishConnection: connect() queued\n"
                        ));

        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXEstablishConnection,
                        IPXDBG_LEVEL_ERROR,
                        "VwSPXEstablishConnection: connect(%x) returns %d\n",
                        s,
                        rc
                        ));

            //
            // the connect request failed. Deallocate all resources (socket,
            // CONNECTION_INFO, XECB) and return failure
            //

            closesocket(pConnectionInfo->Socket);
            DeallocateConnection(pConnectionInfo);
            CompleteEcb(pXecb, ECB_CC_CONNECTION_ABORTED);
            return SPX_CONNECTION_ABORTED;
        }
    }

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXEstablishConnection,
                IPXDBG_LEVEL_INFO,
                "VwSPXEstablishConnection: returning %04x\n",
                connectionId
                ));

    *pSPXConnectionID = connectionId;
    return SPX_SUCCESS;
}


WORD
_VwSPXGetConnectionStatus(
    IN WORD connectionId,
    OUT LPSPX_CONNECTION_STATS pStats
    )

/*++

Routine Description:

    Returns buffer crammed full of useful statistics or something (hu hu huh)

    This call is Synchronous

Arguments:

    Inputs
        connectionId
        pStats

    Outputs
        on output, buffer in pStats contains:

            BYTE    ConnectionStatus
            BYTE    WatchDogActive
            WORD    LocalConnectionID
            WORD    RemoteConnectionID
            WORD    SequenceNumber
            WORD    LocalAckNumber
            WORD    LocalAllocationNumber
            WORD    RemoteAckNumber
            WORD    RemoteAllocationNumber
            WORD    LocalSocket
            BYTE    ImmediateAddress[6]
            BYTE    RemoteNetwork[4]
            WORD    RetransmissionCount
            WORD    RetransmittedPackets
            WORD    SuppressedPackets

Return Value:
    00h Connection is active
    EEh No such connection

--*/

{
    int rc;
    IPX_SPXCONNSTATUS_DATA buf;
    int buflen = sizeof(buf);
    LPCONNECTION_INFO pConnectionInfo;

    pConnectionInfo = FindConnection(connectionId);
    if (!pConnectionInfo) {
        return SPX_INVALID_CONNECTION;
    }

    //
    // get the stats
    //

    rc = getsockopt(pConnectionInfo->Socket,
                    NSPROTO_IPX,
                    IPX_SPXGETCONNECTIONSTATUS,
                    (char FAR*)&buf,
                    &buflen
                    );
    if (rc == SOCKET_ERROR) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXGetConnectionStatus,
                    IPXDBG_LEVEL_ERROR,
                    "VwSPXGetConnectionStatus: getsockopt() returns %d\n",
                    WSAGetLastError()
                    ));

        //
        // the request to get the stats failed - probably because the socket is
        // not yet connected. Fill in those bits we know about
        //

        ZeroMemory((LPBYTE)pStats, sizeof(*pStats));
    } else {

        //
        // copy the returned fields
        //

        pStats->RemoteConnectionId       = buf.RemoteConnectionId;
        pStats->LocalSequenceNumber      = buf.LocalSequenceNumber;
        pStats->LocalAckNumber           = buf.LocalAckNumber;
        pStats->LocalAllocNumber         = buf.LocalAllocNumber;
        pStats->RemoteAckNumber          = buf.RemoteAckNumber;
        pStats->RemoteAllocNumber        = buf.RemoteAllocNumber;
        pStats->LocalSocket              = buf.LocalSocket;
        CopyMemory(&pStats->ImmediateAddress,
                   &buf.ImmediateAddress,
                   sizeof(buf.ImmediateAddress)
                   );

        //
        // copy remote network as a DWORD. Endian format is same for both
        //

        *(ULPDWORD)&pStats->RemoteNetwork = *(LPDWORD)&buf.RemoteNetwork;
        CopyMemory(&pStats->RemoteNode,
                   &buf.RemoteNode,
                   sizeof(buf.RemoteNode)
                   );
        pStats->RemoteSocket             = buf.RemoteSocket;
        pStats->RetransmissionCount      = buf.RetransmissionCount;
        pStats->EstimatedRoundTripDelay  = buf.EstimatedRoundTripDelay;
        pStats->RetransmittedPackets     = buf.RetransmittedPackets;
        pStats->SuppressedPackets        = buf.SuppressedPacket;
    }

    //
    // fill in common, known fields
    //

    pStats->State = pConnectionInfo->State; // not returned by NWIPX
    pStats->WatchDog = 0x02;    // see novell dog-umentation
    pStats->LocalConnectionId = L2BW(pConnectionInfo->ConnectionId);
    pStats->LocalSocket = pConnectionInfo->OwningSocket->SocketNumber;

    DUMPSTATS(pStats);

    //
    // we are returning some kind o stats - therefore success
    //

    return SPX_SUCCESS;
}


WORD
_VwSPXInitialize(
    OUT ULPBYTE pMajorRevisionNumber,
    OUT ULPBYTE pMinorRevisionNumber,
    OUT ULPWORD pMaxConnections,
    OUT ULPWORD pAvailableConnections
    )

/*++

Routine Description:

    Informs the app that SPX is present on this station

    This call is Synchronous

Arguments:

    Inputs

    Outputs
        pMajorRevisionNumber - SPX Major revision number
        pminorRevisionNumber - SPX Minor revision number
        pMaxConnections -  Maximum SPX connections supported
                           normally from SHELL.CFG
        pAvailableConnections - Available SPX connections

Return Value:

    00h Not installed
    FFh Installed

--*/

{

    //
    // The following values are returned same as per Windows For Workgroups
    // v3.10
    //

    *pMajorRevisionNumber = 3;
    *pMinorRevisionNumber = 10;
    *pMaxConnections = 128;
    *pAvailableConnections = *pMaxConnections - 1 ;

    return SPX_INSTALLED;
}


VOID
_VwSPXListenForConnection(
    IN BYTE retryCount,
    IN BYTE watchDogFlag,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Listens for an incoming connection request

    This call is Asynchronous

Arguments:

    Inputs
        retryCount
        watchDogFlag
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;
    LPCONNECTION_INFO pConnectionInfo;
    SOCKET sock;
    SOCKET conn;
    SOCKADDR_IPX remoteAddress;
    int rc;
    BYTE completionCode;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        IPXDBGPRINT((__FILE__, __LINE__, 
                    FUNCTION_SPXListenForConnection,
                    IPXDBG_LEVEL_ERROR,
                    "RetrieveXEcb returned NULL pointer"
                    ));
        return;
    }

    //
    // it turns out that SPXListenForConnection doesn't need a fragment to
    // receive connection info - that is handled by SPXListenForSequencedPacket
    // that the app has dutifully initiated
    //

    pSocketInfo = FindSocket(pXecb->SocketNumber);
    if (!pSocketInfo) {
        completionCode = ECB_CC_NON_EXISTENT_SOCKET;
        goto lc_completion_exit;
    }

    //
    // if no outstanding IPX operations, change socket to SPX
    //

    if (!pSocketInfo->SpxSocket) {
        if (!(pSocketInfo->PendingSends && pSocketInfo->PendingListens)) {
            rc = ReopenSocket(pSocketInfo);
        } else {
            rc = ECB_CC_BAD_LISTEN_REQUEST;
        }
        if (rc != SPX_SUCCESS) {
            completionCode = (BYTE)rc;
            goto lc_completion_exit;
        }
    }

    //
    // the socket is open for SPX. Allocate a connection/connection ID
    //

    pConnectionInfo = AllocateConnection(pSocketInfo);
    if (!pConnectionInfo) {
        completionCode = ECB_CC_CONNECTION_TABLE_FULL;
        goto lc_completion_exit;
    }

    //
    // put the socket into listening state and try to accept a connection
    //

    sock = pSocketInfo->Socket;

    //
    // If the socket is already listening, will probably return an
    // error: just queue
    //

    rc = listen(sock, MAX_LISTEN_QUEUE_SIZE);
    if (rc != SOCKET_ERROR) {

        int addressLength = sizeof(remoteAddress);

        conn = accept(sock, (LPSOCKADDR)&remoteAddress, &addressLength);
        if (conn != SOCKET_ERROR) {

            //
            // we want to receive the frame headers from this socket
            //

            BOOL bval = TRUE;

            rc = setsockopt(conn,
                            NSPROTO_IPX,
                            IPX_RECVHDR,
                            (char FAR*)&bval,
                            sizeof(bval)
                            );
            if (rc != SOCKET_ERROR) {

                //
                // update the CONNECTION_INFO structure with the actual socket
                // identifier and set the connection state to established
                //

                pConnectionInfo->Socket = conn;
                pConnectionInfo->State = CI_ESTABLISHED;

                //
                // add the CONNECTION_INFO structure to the list of connections owned
                // by this socket
                //

                RequestMutex();
                QueueConnection(pSocketInfo, pConnectionInfo);
                ReleaseMutex();

                //
                // update the app's ECB with the connection ID
                //

                SPX_ECB_CONNECTION_ID(pXecb->Ecb) = pConnectionInfo->ConnectionId;

                //
                // and with the partner address info
                //

                CopyMemory(&pXecb->Ecb->DriverWorkspace,
                           &remoteAddress.sa_netnum,
                           sizeof(pXecb->Ecb->DriverWorkspace)
                           );
                completionCode = ECB_CC_SUCCESS;
                goto lc_completion_exit;
            } else {

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_SPXListenForConnection,
                            IPXDBG_LEVEL_ERROR,
                            "VwSPXListenForConnection: setsockopt(RECVHDR) returns %d\n",
                            WSAGetLastError()
                            ));

                closesocket(conn);
                completionCode = ECB_CC_CONNECTION_ABORTED;
                goto lc_deallocate_exit;
            }
        } else {
            rc = WSAGetLastError();
            if (rc == WSAEWOULDBLOCK) {

                //
                // the accept request is in progress. Add it to the queue of
                // pending SPXListenForConnection requests (SHOULD ONLY BE 1 PER
                // CONNECTION!!!) and add the CONNECTION_INFO structure to the
                // owning SOCKET_INFO structure
                //

                pConnectionInfo->State = CI_WAITING; // waiting for incoming connect
                RequestMutex();
                QueueEcb(pXecb,
                         &pConnectionInfo->AcceptQueue,
                         CONNECTION_ACCEPT_QUEUE
                         );
                QueueConnection(pSocketInfo, pConnectionInfo);
                pXecb->Ecb->InUse = ECB_IU_AWAITING_CONNECTION;
                ReleaseMutex();
            } else {

                //
                // the accept request failed. Deallocate all resources
                // (CONNECTION_INFO, XECB) and complete the ECB with a failure
                // indication
                //

                IPXDBGPRINT((__FILE__, __LINE__,
                            FUNCTION_SPXListenForConnection,
                            IPXDBG_LEVEL_ERROR,
                            "VwSPXListenForConnection: accept() returns %d\n",
                            rc
                            ));

                completionCode = ECB_CC_CONNECTION_ABORTED;
                goto lc_deallocate_exit;
            }
        }
    } else {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXListenForConnection,
                    IPXDBG_LEVEL_ERROR,
                    "VwSPXListenForConnection: listen() returns %d\n",
                    WSAGetLastError()
                    ));

        //
        // listen failed? Bogus. Complete the ECB and we're outta here
        //

        completionCode = ECB_CC_CONNECTION_ABORTED;
        goto lc_deallocate_exit;
    }

    //
    // here if we queued the listen request
    //

    return;

lc_deallocate_exit:
    DeallocateConnection(pConnectionInfo);

lc_completion_exit:
    CompleteEcb(pXecb, completionCode);
}


VOID
_VwSPXListenForSequencedPacket(
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Attempts to receive an SPX packet. This call is made against the top-level
    socket (the socket in SPX-speak, not the connection). We can receive a
    packet from any connection assigned to this socket. In this function, we
    just queue the ECB (since there is no return status, we expect that the
    app has supplied an ESR) and let AES handle it

    This call is Asynchronous

Arguments:

    Inputs
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    LPSOCKET_INFO pSocketInfo;
    int rc;
    BOOL dummy ;
    BYTE status;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        IPXDBGPRINT((__FILE__, __LINE__, 
                    FUNCTION_SPXListenForSequencedPacket,
                    IPXDBG_LEVEL_ERROR,
                    "RetrieveXEcb returned NULL pointer"
                    ));
        return;
    }

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXListenForSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VwSPXListenForSequencedPacket(%04x:%04x) socket=%04x ESR=%04x:%04x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                B2LW(pXecb->SocketNumber),
                HIWORD(pXecb->EsrAddress),
                LOWORD(pXecb->EsrAddress)
                ));

    pSocketInfo = FindSocket(pXecb->SocketNumber);
    if (!pSocketInfo) {
        status = ECB_CC_NON_EXISTENT_SOCKET;
        goto lp_exit;
    }

    //
    // if no outstanding IPX operations, change socket to SPX
    //

    if (!pSocketInfo->SpxSocket) {
        if (!(pSocketInfo->PendingSends && pSocketInfo->PendingListens)) {
            rc = ReopenSocket(pSocketInfo);
        } else {
            rc = ECB_CC_BAD_LISTEN_REQUEST;
        }
        if (rc != SPX_SUCCESS) {
            status = (BYTE)rc;
            goto lp_exit;
        }
    }

    //
    // the first fragment must be large enough to hold an SPX packet header
    //

    if ((pXecb->Ecb->FragmentCount == 0)
    || (ECB_FRAGMENT(pXecb->Ecb, 0)->Length < SPX_HEADER_LENGTH)) {
        status = ECB_CC_BAD_LISTEN_REQUEST;
        goto lp_exit;
    }

    //
    // we have a socket and the receive buffer looks good. Get a buffer for recv()
    //

    if (!GetIoBuffer(pXecb, FALSE, SPX_HEADER_LENGTH)) {
        status = ECB_CC_BAD_LISTEN_REQUEST;
        goto lp_exit;
    } else {

        //
        // when recv() is attempted against this request, it will be the first
        // time we tried to receive anything to this buffer. That means (if we
        // get anything) that the buffer will contain the length of the entire
        // frame
        //

        pXecb->Flags |= XECB_FLAG_FIRST_RECEIVE;
    }

    //
    // mark the VDM ECB as in use
    //

    pXecb->Ecb->InUse = ECB_IU_LISTENING_SPX;

    //
    // add this ECB to the queue of listens for the top-level socket and quit
    //

    RequestMutex();

    if ((pXecb->Ecb->FragmentCount == 1) &&
        (ECB_FRAGMENT(pXecb->Ecb, 0)->Length == SPX_HEADER_LENGTH))
    {
        QueueEcb(pXecb, &pSocketInfo->HeaderQueue, SOCKET_HEADER_QUEUE);
    }
    else
    {
        QueueEcb(pXecb, &pSocketInfo->ListenQueue, SOCKET_LISTEN_QUEUE);
    }

    ReleaseMutex();

    //
    // see if we are ready to rock
    //

    CheckPendingSpxRequests(&dummy);
    return;

lp_exit:
    CompleteOrQueueEcb(pXecb, status);
}


VOID
_VwSPXSendSequencedPacket(
    IN WORD connectionId,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Sends a packet on an SPX connection

    This call is Asynchronous

Arguments:

    Inputs
        connectionId
        pEcb
        EcbAddress

    Outputs
        Nothing

Return Value:

    None.

--*/

{
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    LPCONNECTION_INFO pConnectionInfo;
    int rc;
    BOOL addToQueue;
    LPSPX_PACKET pPacket;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        IPXDBGPRINT((__FILE__, __LINE__, 
                    FUNCTION_SPXSendSequencedPacket, 
                    IPXDBG_LEVEL_ERROR,
                    "RetrieveXEcb returned NULL pointer"
                    ));
        return;
    }

    IPXDBGPRINT((__FILE__, __LINE__,
                FUNCTION_SPXSendSequencedPacket,
                IPXDBG_LEVEL_INFO,
                "VwSPXSendSequencedPacket(%04x:%04x) Connection=%04x ESR=%04x:%04x\n",
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                connectionId,
                HIWORD(pXecb->EsrAddress),
                LOWORD(pXecb->EsrAddress)
                ));

    IPXDUMPECB((pXecb->Ecb,
                HIWORD(pXecb->EcbAddress),
                LOWORD(pXecb->EcbAddress),
                ECB_TYPE_SPX,
                TRUE,
                TRUE,
                IS_PROT_MODE(pXecb)
                ));

    //
    // find the connection. No need to check if this is an SPX socket: if we
    // can't find the connection, its a bad connection, else the socket must
    // be open for SPX
    //

    pConnectionInfo = FindConnection(connectionId);
    if (!pConnectionInfo || (pConnectionInfo->State != CI_ESTABLISHED)) {
        CompleteOrQueueEcb(pXecb, ECB_CC_INVALID_CONNECTION);
        return;
    }

    //
    // the first fragment must be large enough to hold an SPX packet header
    //

    if ((pXecb->Ecb->FragmentCount == 0)
    || (ECB_FRAGMENT(pXecb->Ecb, 0)->Length < SPX_HEADER_LENGTH)) {
        CompleteOrQueueEcb(pXecb, ECB_CC_BAD_SEND_REQUEST);
        return;
    }
    if (!GetIoBuffer(pXecb, TRUE, SPX_HEADER_LENGTH)) {
        CompleteOrQueueEcb(pXecb, ECB_CC_BAD_SEND_REQUEST);
        return;
    }

    pPacket = (LPSPX_PACKET)GET_FAR_POINTER(
                                    &(ECB_FRAGMENT(pXecb->Ecb, 0)->Address),
                                    IS_PROT_MODE(pXecb)
                                    );

    //
    // fill in the following fields in the SPX header:
    //
    //  Checksum
    //  Length
    //  TransportControl
    //  Source (network, node, socket)
    //
    // Does real IPX modify these fields in app memory?
    //         If so, does the app expect modified fields?
    //         If not, we need to always copy then modify memory,
    //         even if only 1 fragment
    //

    pPacket->Checksum = 0xFFFF;

    //
    // since the transport adds the SPX header, we subtracted the length of
    // the header from our transmit length; add it back when updating the
    // header in the app's space
    //

    pPacket->Length = L2BW(pXecb->Length + SPX_HEADER_LENGTH);
    pPacket->TransportControl = 0;
    CopyMemory((LPBYTE)&pPacket->Source,
               &MyInternetAddress.sa_netnum,
               sizeof(MyInternetAddress.sa_netnum)
               + sizeof(MyInternetAddress.sa_nodenum)
               );
    pPacket->Source.Socket = pConnectionInfo->OwningSocket->SocketNumber;

    //
    // if we allocated a buffer then there is >1 fragment. Collect them
    //

    if (pXecb->Flags & XECB_FLAG_BUFFER_ALLOCATED) {
        GatherData(pXecb, SPX_HEADER_LENGTH);
    }

    //
    // mark the VDM ECB as in use
    //

    pXecb->Ecb->InUse = ECB_IU_SENDING;

    //
    // if there is a send queued on this connection already, add this request
    // to the back of the queue and let AES do the rest
    //

    RequestMutex();
    if (pConnectionInfo->SendQueue.Head) {
        addToQueue = TRUE;
    } else {

        int dataStreamType;

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXSendSequencedPacket,
                    IPXDBG_LEVEL_INFO,
                    "VwSPXSendSequencedPacket: sending %d (0x%x) bytes from %08x\n",
                    pXecb->Length,
                    pXecb->Length,
                    pXecb->Data
                    ));

        //
        // no outstanding sends queued for this connection. Start sending this
        // packet
        //

        dataStreamType = (int)pPacket->DataStreamType;
        rc = setsockopt(pConnectionInfo->Socket,
                        NSPROTO_IPX,
                        IPX_DSTYPE,
                        (char FAR*)&dataStreamType,
                        sizeof(dataStreamType)
                        );
        if (rc != SOCKET_ERROR) {

            //
            // if the app set the END_OF_MESSAGE bit in the ConnectionControl
            // field then set the flags to 0: NWLink will automatically set the
            // end-of-message bit in the packet; otherwise set flags to MSG_PARTIAL
            // to indicate to NWLink that it *shouldn't* set the bit in the packet
            //

            int flags = (pPacket->ConnectionControl & SPX_END_OF_MESSAGE)
                      ? 0
                      : MSG_PARTIAL
                      ;

            rc = send(pConnectionInfo->Socket, pXecb->Data, pXecb->Length, flags);

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXSendSequencedPacket,
                        IPXDBG_LEVEL_INFO,
                        "VwSPXSendSequencedPacket: send() returns %d\n",
                        rc
                        ));

            if (rc == pXecb->Length) {

                //
                // all data sent
                //

                CompleteOrQueueIo(pXecb, ECB_CC_SUCCESS);
                addToQueue = FALSE;
            } else if (rc == SOCKET_ERROR) {
                rc = WSAGetLastError();
                if (rc == WSAEWOULDBLOCK) {

                    //
                    // can't send right now. Queue it for AES
                    //

                    addToQueue = TRUE;
                }
            } else {

                //
                // partial data sent. Update the buffer pointer and length fields
                // and queue this request
                //

                pXecb->Data += rc;
                pXecb->Length -= (WORD)rc;
                addToQueue = TRUE;
            }
        } else {

            IPXDBGPRINT((__FILE__, __LINE__,
                        FUNCTION_SPXSendSequencedPacket,
                        IPXDBG_LEVEL_ERROR,
                        "VwSPXSendSequencedPacket: setsockopt(IPX_DSTYPE) returns %d\n",
                        WSAGetLastError()
                        ));

            CompleteOrQueueIo(pXecb, ECB_CC_BAD_REQUEST);
        }
    }

    //
    // if addToQueue set then we can't do anything right now - add this
    // request to the send queue
    //

    if (addToQueue) {

        IPXDBGPRINT((__FILE__, __LINE__,
                    FUNCTION_SPXSendSequencedPacket,
                    IPXDBG_LEVEL_WARNING,
                    "VwSPXSendSequencedPacket: adding XECB %08x to send queue\n",
                    pXecb
                    ));

        QueueEcb(pXecb, &pConnectionInfo->SendQueue, CONNECTION_SEND_QUEUE);
    }
    ReleaseMutex();
}


VOID
_VwSPXTerminateConnection(
    IN WORD SPXConnectionID,
    IN LPECB pEcb,
    IN ECB_ADDRESS EcbAddress
    )

/*++

Routine Description:

    Terminates a connection

Arguments:

    SPXConnectionID - connection to terminate
    pEcb            - pointer to 16-bit ECB to use
    EcbAddress      - address of 16-bit ECB in 16:16 format

Return Value:

    None.

--*/

{
    LPCONNECTION_INFO pConnectionInfo;
    LPXECB pXecb = RetrieveXEcb(ECB_TYPE_SPX, pEcb, EcbAddress);
    BYTE status;
    BYTE completionCode;

    // tommye - MS 30525
    //
    // Make sure the xecb alloc didn't fail
    //

    if (pXecb == NULL) {
        return;
    }

    RequestMutex();
    pConnectionInfo = FindConnection(SPXConnectionID);
    if (pConnectionInfo) {

        //
        // once dequeued, pConnectionInfo no longer points to OwningSocket
        //

        WORD socketNumber = pConnectionInfo->OwningSocket->SocketNumber;

        DequeueConnection(pConnectionInfo->OwningSocket, pConnectionInfo);
        if ((pXecb->Ecb->FragmentCount >= 1)
        && (ECB_FRAGMENT(pXecb->Ecb, 0)->Length >= SPX_HEADER_LENGTH)) {

            LPSPX_PACKET pPacket;
            SOCKADDR_IPX remote;
            int remoteLen = sizeof(remote);

            completionCode = ECB_CC_CONNECTION_TERMINATED;
            status = ECB_CC_SUCCESS;

            //
            // fill in the packet header: this would normally contain the
            // acknowledgement packet from the remote partner
            //

            pPacket = (LPSPX_PACKET)GET_FAR_POINTER(
                                        &(ECB_FRAGMENT(pXecb->Ecb, 0)->Address),
                                        IS_PROT_MODE(pXecb)
                                        );
            if (pPacket == NULL) {
                completionCode = ECB_CC_CONNECTION_ABORTED;
                status = ECB_CC_BAD_REQUEST;
            }
            else {
                pPacket->Checksum = 0xffff;
                pPacket->Length = L2BW(SPX_HEADER_LENGTH);
                pPacket->TransportControl = 0;
                pPacket->PacketType = SPX_PACKET_TYPE;
                getpeername(pConnectionInfo->Socket, (LPSOCKADDR)&remote, &remoteLen);
                CopyMemory((LPBYTE)&pPacket->Destination,
                           (LPBYTE)&remote.sa_netnum,
                           sizeof(NETWARE_ADDRESS)
                           );
                CopyMemory((LPBYTE)&pPacket->Source,
                           (LPBYTE)&MyInternetAddress.sa_netnum,
                           sizeof(INTERNET_ADDRESS)
                           );
                pPacket->Source.Socket = socketNumber;
                pPacket->ConnectionControl = SPX_ACK_REQUIRED;
                pPacket->DataStreamType = SPX_DS_TERMINATE;
                pPacket->SourceConnectId = pConnectionInfo->ConnectionId;
                pPacket->DestinationConnectId = 0;
                pPacket->SequenceNumber = 0;
                pPacket->AckNumber = 0;
                pPacket->AllocationNumber = 0;
            }

        } else {
            completionCode = ECB_CC_CONNECTION_ABORTED;
            status = ECB_CC_BAD_REQUEST;
        }
        AbortOrTerminateConnection(pConnectionInfo, completionCode);
    } else {
        status = ECB_CC_INVALID_CONNECTION;
    }
    ReleaseMutex();
    CompleteOrQueueEcb(pXecb, status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\dll\vwvdm.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vwvdm.h

Abstract:

    Contains macros, manifests, includes for dealing with VDM

Author:

    Richard L Firth (rfirth) 25-Oct-1993

Revision History:

    25-Oct-1993 rfirth
        Created

--*/

#ifndef _VWVDM_H_
#define _VWVDM_H_

//
// unaligned pointers - non-Intel platforms must use UNALIGNED to access data
// in VDM which can (and most likely will) be aligned on odd-byte and word
// boundaries
//

#ifndef ULPBYTE
#define ULPBYTE BYTE UNALIGNED FAR*
#endif

#ifndef ULPWORD
#define ULPWORD WORD UNALIGNED FAR*
#endif

#ifndef ULPDWORD
#define ULPDWORD DWORD UNALIGNED FAR*
#endif

#ifndef ULPVOID
#define ULPVOID VOID UNALIGNED FAR*
#endif

//
// VDM macros
//

//
// POINTER_FROM_WORDS - returns 32-bit pointer to address in VDM memory described
// by seg:off. If seg:off = 0:0, returns NULL
//

#define POINTER_FROM_WORDS(seg, off, size) \
    _inlinePointerFromWords((WORD)(seg), (WORD)(off), (WORD)(size))

//
// _inlinePointerFromWords - the POINTER_FROM_WORDS macro is inefficient if the
// arguments are calls to eg. getES(), getBX() - the calls are made twice if
// the pointer turns out to be non-zero. Use an inline function to achieve the
// same results, but only call function arguments once
//

__inline LPVOID _inlinePointerFromWords(WORD seg, WORD off, WORD size) {
    return (seg | off)
        ? (LPVOID)GetVDMPointer((ULONG)(MAKELONG(off, seg)), size, (CHAR)((getMSW() & MSW_PE) ? TRUE : FALSE))
        : NULL;
}

//
// GET_POINTER - does the same thing as POINTER_FROM_WORDS, but we know beforehand
// which processor mode we are in
//

#define GET_POINTER(seg, off, size, mode) \
    _inlineGetPointer((WORD)(seg), (WORD)(off), (WORD)(size), (BOOL)(mode))

__inline LPVOID _inlineGetPointer(WORD seg, WORD off, WORD size, BOOL mode) {
    return (seg | off)
        ? (LPVOID)GetVDMPointer(MAKELONG(off, seg), size, (UCHAR)mode)
        : NULL;
}

//
// GET_FAR_POINTER - same as READ_FAR_POINTER with the same proviso as for
// GET_POINTER
//

#define GET_FAR_POINTER(addr, mode) ((LPBYTE)(GET_POINTER(GET_SELECTOR(addr), GET_OFFSET(addr), sizeof(LPBYTE), mode)))

//
// GET_SELECTOR - retrieves the selector word from the intel 32-bit far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//

#define GET_SELECTOR(pointer)   READ_WORD((LPWORD)(pointer)+1)

//
// GET_SEGMENT - same as GET_SELECTOR
//

#define GET_SEGMENT(pointer)    GET_SELECTOR(pointer)

//
// GET_OFFSET - retrieves the offset word from an intel 32-bit far pointer
// (DWORD) pointed at by <pointer> (remember: stored as offset, segment)
//

#define GET_OFFSET(pointer)     READ_WORD((LPWORD)(pointer))

//
// READ_FAR_POINTER - read the pair of words in VDM memory, currently pointed at
// by a 32-bit flat pointer and convert them to a 32-bit flat pointer
//

#define READ_FAR_POINTER(addr)  ((LPBYTE)(POINTER_FROM_WORDS(GET_SELECTOR(addr), GET_OFFSET(addr), sizeof(LPBYTE))))

//
// READ_WORD - read a single 16-bit little-endian word from VDM memory. On non
// Intel platforms, use unaligned pointer to access data
//

#define READ_WORD(addr)         (*((ULPWORD)(addr)))

//
// READ_DWORD - read a 4-byte little-endian double word from VDM memory. On non
// Intel platforms, use unaligned pointer to access data
//

#define READ_DWORD(addr)        (*((ULPDWORD)(addr)))

//
// ARRAY_ELEMENTS - gives the number of elements of a particular type in an
// array
//

#define ARRAY_ELEMENTS(a)   (sizeof(a)/sizeof((a)[0]))

//
// LAST_ELEMENT - returns the index of the last element in array
//

#define LAST_ELEMENT(a)     (ARRAY_ELEMENTS(a)-1)

#endif // _VWVDM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=vwipxspx

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\makefile.inc ===
!IF 0

Copyright (c) 1991 & 1993  Microsoft Corporation

Module Name:

    makefile

Abstract:

    makefile for Vdm NetWare Redir program

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

!ENDIF

!include $(NTMAKEENV)\makefile.plt

#
# Because we've invoked nmake from within a makefile, macros defined
# in a previous makefile (ie, sources, sources.inc, makefile.def)
# are not defined at this point unless they're defined on the command
# line.  This makefile assumes the LANGUAGE and ALT_PROJECT_TARGET macros
# defined in $(LANGUAGE)\sources.inc are passed to this invokation of nmake
# on the command line.
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
TARGET_DIRECTORY=i386
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
TARGET_DIRECTORY=alpha
!endif

#
# set the LANGUAGE info
#

!IFNDEF LANGUAGE
LANGUAGE=USA
!ENDIF

DEST=$(LANGUAGE)\$(_OBJ_DIR)\$(TARGET_DIRECTORY)

.SUFFIXES:
.SUFFIXES:  .asm .h


PATH=$(PATH_TOOLS16);$(PATH)

ASM         = masm
LINK        = link16

#
# convert NTDEBUG into DEBUG flag. NTDEBUG can be not present or retail, either
# of which mean no debugging; or ntsd, cvp or sym, which means debugging support
# required
#

!IF $(FREEBUILD)
DEBUGGING=0
!ELSE
DEBUGGING=1
!ENDIF

#
# assembler and linker debugging options
#

!IF $(DEBUGGING)
ASMDEBUG    =/DDEBUG=1 /Zi
LINKDEBUG   =/CO
!ELSE
ASMDEBUG    =/DDEBUG=0
LINKDEBUG   =
!ENDIF

ASMINC      =/I. /I..\..\inc /I..\..\inc\$(LANGUAGE) /I$(SDK_INC16_PATH)
ASMFLAGS    =/Mx
LINKFLAGS   =/MAP /CP:1

#
# any other non-debug related options (for assembler) go in USERDEFS
#

USERDEFS    =/DCALL_DOS

#
# Inference rules - asm to obj, h to inc
#

.asm{$(DEST)\}.obj:
    @rem Setting the MASM env var keeps the masm command line below 128 chars
    set MASM=$(ASMDEBUG) $(USERDEFS) $(ASMINC)
    $(ASM) $<,$@;

.h.inc:
    h2inc $< -o $*.inc

.asm.lst:
    $(ASM) $(ASMINC) $(ASMDEBUG) $(USERDEFS) /d /L $<;

#
# what it is we're building
#

TARGET      = $(DEST)\vwipxspx.exe
MAPFILE     = $(TARGET:.exe=.map)
DEFFILE     = ;

OBJS        = $(DEST)\vwipxspx.obj

LIBS        =

#
# how to build it
#

all:    makedir $(TARGET)

$(TARGET):  $(OBJS)
    $(LINK) @<<
$(OBJS)
$(TARGET) $(LINKFLAGS) $(LINKDEBUG)
$(MAPFILE)
$(LIBS)
$(DEFFILE)
<<


#
# where to put it
#

     if not exist $(DEST) md $(DEST)
     binplace -o $(ALT_PROJECT_TARGET) $(TARGET)
     binplace -o $(ALT_PROJECT_TARGET) $(MAPFILE)

#
# clean build - delete all objs
#

#clean:  makedir clean2
clean:  clean2

clean2:
    if exist messages.inc del messages.inc
    if exist $(DEST)\*.obj del $(DEST)\*.obj
    $(MAKE)

#
# makedir - ensure the subdirectory for the object files exists
#

makedir:
    @-if not exist $(DEST) md $(DEST)

#
# file dependencies
#

$(DEST)\vwipxspx.obj:   \
        vwipxspx.asm    \
        debugmac.inc    \
        asmmacro.inc    \
        segorder.inc    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

vwipxspx:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\vwipxspx\tsr\vwipxspx.asm ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vwipxspx.asm

Abstract:

    Contains handlers for 16-bit (DOS) netware IPX/SPX emulation. Creates TSR

    Contents:
        start
        InstallationCheck
        InstallVdd
        InstallInterruptHandlers
        VwIpxEntryPoint
        VwIpxDispatcher
        VwIpx7ADispatcher
        DispatchWithFeeling
        VwIpxEsrFunction

Author:

    Richard L Firth (rfirth) 30-Sep-1993

Environment:

    DOS Real mode only

Revision History:

    30-Sep-1993 rfirth
        Created

--*/

endif

;
; DOS include files
;
        
.xlist
.xcref
include ..\..\..\..\public\sdk\inc\isvbop.inc      ; NTVDM BOP mechanism
include dossym.inc      ; includes MS-DOS version etc
include pdb.inc         ; PSP defines
include syscall.inc     ; AssignOper
include segorder.inc    ; load order of 'redir' segments
include debugmac.inc    ; debug display macros
include asmmacro.inc    ; jumps which may be short or near
include messages.inc    ; internationalisationable (prestidigitation) messages
.cref
.list

InitStack segment stack para 'stack'

        dw      256 dup (?)

InitStack ends

InitDataStart

bad_ver_msg             db      NLS_MSG_001,c_CR,c_LF
BAD_VER_MSG_LEN         equ     $-bad_ver_msg
                        db      '$'     ; for INT 21/09 display string

already_loaded_msg      db      NLS_MSG_002,c_CR,c_LF
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

cannot_load_msg         db      NLS_MSG_003,c_CR, c_LF
CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg

;
; strings used to load/dispatch NWIPXSPX.DLL
;

DllName         db      "VWIPXSPX.DLL",0
InitFunc        db      "VwInitialize",0
DispFunc        db      "VwDispatcher",0

InitDataEnd

InitCodeStart
        assume  cs:InitCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        public  start
start   proc    near

;
; when we start up we could be on any old PC - even an original, so don't
; assume anything other than a model-T processor
;

        .8086

;
; Set the data segment while we're at it - all paths set it sooner
; or later. NOTE: es will point to the PSP until we change it!
;

        mov     dx,InitData
        mov     ds,dx

        assume  ds:InitData

;
; first off, get the DOS version. If we're not running on NT (VDM) then this
; TSR's not going to do much, so exit. Exit using various methods, depending
; on the DOS version (don't you hate compatibility?)
;

        mov     ah,30h
        int     21h
        jc      ancient_version         ; version not even supported

;
; version is 2.0 or higher. Check it out. al = major#, ah = minor#
;

        cmp     al,major_version
        jne     invalid_version

;
; okay, we're at least 5.0. But are we NT?
;

        mov     ax,3306h
        int     21h
        jc      invalid_version         ; ?
        cmp     bl,5
        jne     invalid_version
        cmp     bh,50
        jne     invalid_version

;
; what do you know? We're actually running on NT (unless some evil programmer
; has pinched int 21h/30h and broken it!). Enable minimum instruction set
; for NTVDM (286 on RISC).
;

        .286c

;
; perform an installation check. Bail if we're there dude ((C) Beavis & Butthead)
;

        call    InstallationCheck
        jnz     already_here            ; nope - IPX/SPX support installed already

;
; We should find some way of deferring loading the 32-bit DLL until an
; IPX/SPX function is called, to speed-up loading. However, if we later find we
; cannot load the DLL, it may be too late: there is no way of consistently
; returning an error and we cannot unload the TSR
;

        call    InstallVdd              ; returns IRQ in BX
        jc      initialization_error
        call    InstallInterruptHandlers

        assume  es:nothing

;
; free the environment segment
;

        mov     es,es:[PDB_environ]
        mov     ah,49h
        int     21h                     ; free environment segment

;
; finally terminate and stay resident
;

        mov     dx,ResidentEnd
        sub     dx,ResidentStart        ; number of paragraphs in resident code
        add     dx,10h                  ; additional for PSP (PDB)
        mov     ax,3100h
        int     21h                     ; terminate and stay resident

;
; here if the MS-DOS version check (Ah=30h) call is not supported
;

ancient_version:
        mov     dx,InitData
        mov     ds,dx

        assume  ds:InitData

        mov     dx,offset bad_ver_msg
        mov     ah,9                    ; cp/m-style write to output
        int     21h

;
; safe exit: what we really want to do here is INT 20H, but when you do this,
; CS must be the segment of the PSP of this program. Knowing that CD 20 is
; embedded at the start of the PSP, the most foolproof way of doing this is
; to jump (using far return) to the start of the PSP
;

        push    es
        xor     ax,ax
        push    ax
        retf                            ; terminate

;
; we are running on a version of DOS >= 2.00, but its not NT, so we still can't
; help. Display the familiar message and exit, but using a less programmer-
; hostile mechanism
;

invalid_version:
        mov     dx,offset bad_ver_msg
        mov     cx,BAD_VER_MSG_LEN
        jmp     short print_error_message_and_exit

;
; if we cannot initialize 32-bit support (because we can't find/load the DLL)
; then put back the hooked interrupt vectors as they were when this TSR started,
; display a message and fail to load the redir TSR
;

initialization_error:
        mov     dx,offset cannot_load_msg
        mov     cx,CANNOT_LOAD_MSG_LEN
        jmp     short print_error_message_and_exit

;
; The DOS version's OK, but this TSR is already loaded
;

already_here:
        mov     dx,offset already_loaded_msg
        mov     cx,ALREADY_LOADED_MSG_LEN

print_error_message_and_exit:
        mov     bx,1                    ; bx = stdout handle
        mov     ah,40h                  ; write to handle
        int     21h                     ; write (cx) bytes @ (ds:dx) to stdout
        mov     ax,4c01h                ; terminate program
        int     21h                     ; au revoir, cruel environment

start   endp

; ***   InstallationCheck
; *
; *     Test to see if this module is already loaded
; *
; *     ENTRY   nothing
; *
; *     EXIT    ZF = 0: loaded
; *
; *     USES    AX
; *
; *     ASSUMES nothing
; *
; ***

InstallationCheck proc
        mov     ax,7a00h
        int     2fh
        or      al,al
        ret
InstallationCheck endp

; ***   InstallVdd
; *
; *     Load VWIPXSPX.DLL into the NTVDM process context
; *
; *     ENTRY   nothing
; *
; *     EXIT    CF = 1: error
; *             CF = 0: VWIPXSPX loaded ok
; *                     AX = VDD handle
; *                     BX = IRQ used by call-back functions (ESR)
; *                     ResidentCode:VddHandle updated
; *                     ResidentCode:IrqValue updated
; *
; *     USES    AX, BX, SI, DI
; *
; *     ASSUMES nothing
; *
; ***

InstallVdd proc
        push    ds
        push    es
        mov     ax,InitData
        mov     ds,ax

        assume  ds:InitData

        mov     es,ax
        mov     si,offset DllName       ; ds:si = library name
        mov     di,offset InitFunc      ; es:di = init function name
        mov     bx,offset DispFunc      ; ds:bx = dispatcher function name

        RegisterModule                  ; returns carry if problem

        mov     si,ResidentCode
        mov     ds,si

        assume  ds:ResidentCode

        mov     VddHandle,ax
        mov     IrqValue,bx
        pop     es

        assume  es:nothing

        pop     ds

        assume  ds:nothing

        ret
InstallVdd endp

; ***   InstallInterruptHandlers
; *
; *     Sets the interrupt handlers for all the ints we use - 2F, 7A
; *
; *     ENTRY   BX = IRQ for call-backs
; *             ES = PSP segment
; *
; *     EXIT    Old2FHandler contains the original interrupt 2F vector
; *             Old7AHandler contains the original interrupt 7A vector
; *             OldIrqHandler contains original IRQ vector
; *
; *     USES    AX, BX, CX, DX
; *
; *     ASSUMES nothing
; *
; ***

InstallInterruptHandlers proc
        push    es                      ; PSP segment - destroyed by INT 21/35h
        push    ds
        mov     dx,ResidentCode
        mov     ds,dx

        assume  ds:ResidentCode

;
; get and set call-back IRQ
;

        mov     ah,35h
        mov     al,bl
        mov     cl,bl                   ; cl = IRQ number
        int     21h
        mov     word ptr OldIrqHandler,bx
        mov     word ptr OldIrqHandler+2,es
        mov     al,cl
        mov     ah,25h
        mov     dx,offset ResidentCode:VwIpxEsrFunction
        int     21h

;
; get and set 2F handler
;

        mov     ax,352Fh
        int     21h
        mov     word ptr Old2FHandler,bx
        mov     word ptr Old2FHandler+2,es
        mov     dx,offset ResidentCode:VwIpxEntryPoint
        mov     ax,252Fh
        int     21h

;
; get and set 7A handler
;

        mov     ax,357Ah
        int     21h
        mov     word ptr Old7AHandler,bx
        mov     word ptr Old7AHandler+2,es
        mov     dx,offset ResidentCode:VwIpx7ADispatcher
        mov     ax,257Ah
        int     21h
        pop     ds                      ; restore segment registers

        assume  ds:nothing

        pop     es

        assume  es:nothing

        ret
InstallInterruptHandlers endp

InitCodeEnd

page

;
; code from here on will be left in memory after initialisation
;

ResidentCodeStart

        assume cs:ResidentCode
        assume ds:nothing
        assume es:nothing
        assume ss:nothing

Old2FHandler    dd      ?
Old7AHandler    dd      ?
OldIrqHandler   dd      ?

IrqValue        dw      ?

VddHandle       dw      ?

; ***   VwIpxEntryPoint
; *
; *     The INT 2Fh handler that recognizes the Netware IPX request code (7A).
; *     Also chains INT 2F/AX=1122
; *
; *     ENTRY   AX = 7A00h
; *
; *     EXIT    AL = 0FFh
; *             ES:DI = address of routine to call when submitting IPX/SPX
; *                     requests
; *
; *     USES
; *
; *     ASSUMES nothing
; *
; ***

VwIpxEntryPoint proc
        cmp     ax,7a00h
        jne     @f
        mov     di,cs
        mov     es,di
        mov     di,offset VwIpxDispatcher
        dec     al
        iret

;
; not 7A00h. Check for 1122h (IFSResetEnvironment). If yes, then this is DOS
; calling the IFS chain to notify that the app is terminating. When we have
; notified the DLL, chain the IFS request
;

@@:     cmp     ax,7affh
        jne     try1122
        mov     di,cs
        mov     es,di
        mov     di,offset VwIpxDispatcher
        or      bx,bx
        jz      @f
        mov     cx,8000h
        mov     si,7
        iret
@@:     mov     cx,14h
        mov     si,200h
        iret

try1122:cmp     ax,1122h
        jne     @f

;
; DOS Calls INT 2F/AX=1122 for every terminating app, including this one. We
; can't differentiate between a TSR and a non-TSR. Let the DLL handle it
;

        push    ax
        push    bx
        push    cx
        mov     ah,51h
        int     21h
        mov     cx,bx                   ; cx = PDB of terminating program/TSR
        mov     bx,-1                   ; bx = dispatch code
        mov     ax,VddHandle            ; ax = VDD handle
        DispatchCall
        pop     cx
        pop     bx
        pop     ax
@@:     jmp     Old2FHandler            ; chain int 2F
VwIpxEntryPoint endp

; ***   VwIpxDispatcher
; *
; *     All DOS IPX/SPX calls are routed here by the netware libraries. Just
; *     BOP on through to the other side
; *
; *     This routine just transfers control to 32-bit world, where all work is
; *     done
; *
; *     ENTRY   BX = netware IPX/SPX dispatch code
; *             others - depends on function
; *
; *     EXIT    depends on function
; *
; *     USES    depends on function
; *
; *     ASSUMES nothing
; *
; ***

VwIpxDispatcher proc far
        pushf                           ; apparently we don't modify flags
        call    DispatchWithFeeling
        popf
        ret
VwIpxDispatcher endp

; ***   VwIpx7ADispatcher
; *
; *     Older Netware apps make the call to IPX/SPX via INT 7A. Same function
; *     as VwIpxDispatcher
; *
; *     This routine just transfers control to 32-bit world, where all work is
; *     done
; *
; *     ENTRY   BX = netware IPX/SPX dispatch code
; *             others - depends on function
; *
; *     EXIT    depends on function
; *
; *     USES    depends on function
; *
; *     ASSUMES nothing
; *
; ***

VwIpx7ADispatcher proc
        call    DispatchWithFeeling
        iret
VwIpx7ADispatcher endp

; ***   DispatchWithFeeling
; *
; *     Performs the dispatch for VrIpxDispatcher and VrIpx7ADispatcher. Checks
; *     requested function for return code in AX: either returns value in AX
; *     or restores AX to value on input
; *
; *     This routine just transfers control to 32-bit world, where all work is
; *     done
; *
; *     ENTRY   BX = netware IPX/SPX dispatch code
; *             others - depends on function
; *
; *     EXIT    depends on function
; *
; *     USES    depends on function
; *
; *     ASSUMES 1. Dispatch codes are in range 0..255 (ie 0 in BH)
; *
; ***

DispatchWithFeeling proc
        push    bp
        push    ax                      ; caller value

;
; some APIs (IPXOpenSocket, IPXScheduleIPXEvent, SPXEstablishConnection, and
; others...) pass a parameter in AX. Since AX is being used for the VDD
; handle, we have to commandeer another register to hold our AX value. BP is
; always a good candidate
;

        mov     bp,ax                   ; grumble, mutter, gnash, gnash
        push    cx                      ; required if IPXOpenSocket
        push    bx                      ; dispatch code
        or      bx,bx                   ; IPXOpenSocket?
        jz      @f                      ; yus ma'am
        cmp     bl,3                    ; IPXSendPacket?
        jz      @f                      ; yus ma'am again
        jmp     short carry_on_dispatching      ; ooo-err missus

;
; IPXOpenSocket et IPXSendPacket: We need an extra piece of info - the PDB of
; the process making this request. This is so we can clean-up at program
; termination
;

@@:     push    bx
        mov     ah,51h                  ; get DOS PDB
        int     21h                     ; this call can be made any time
        mov     cx,bx
        pop     bx

carry_on_dispatching:
        mov     ax,VddHandle
        DispatchCall
        mov     bp,sp

;
; BX and [BP] will be the same value except for SPXInitialize which is the only
; function that returns something in BX
;

        xchg    bx,[bp]                 ; bx = dispatch code, [bp] = returned bx

;
; if this call returns something in AX (or AL) don't pop the AX value we pushed.
; If not a call which returns something in AX then restore the caller's AX. You
; can rest assured some assembler programmer has made use of the fact that some
; calls modify AX and the others leave it alone (presumably...?)
;

        or      bl,bl                   ; 0x00 = IPXOpenSocket
        jz      @f
        cmp     bl,2                    ; 0x02 = IPXGetLocalTarget
        jz      @f
        cmp     bl,4                    ; 0x04 = IPXListenForPacket
        jz      @f
        cmp     bl,6                    ; 0x06 = IPXCancelEvent
        jz      @f
        cmp     bl,8                    ; 0x08 = IPXGetIntervalMarker
        jz      @f
        cmp     bl,10h                  ; 0x10 = SPXInitialize
        jz      spx_init
        cmp     bl,11h                  ; 0x11 = SPXEstablishConnection
        jz      @f
        cmp     bl,15h                  ; 0x15 = SPXGetConnectionStatus
        jz      @f
        cmp     bl,1ah                  ; 0x1A = IPXGetMaxPacketSize
        jz      @f
        pop     cx                      ; original dispatch code
        pop     cx                      ; original cx
        pop     ax                      ; original ax
        pop     bp                      ; original bp
        ret

;
; here if this call returns something in AX/AL
;

@@:     pop     cx                      ; original dispatch code
        pop     cx                      ; original cx
        pop     bp                      ; don't restore AX
        pop     bp
        ret

;
; here if the call was SPXInitialize which returns values in AX, BX, CX, DX
;

spx_init:
        pop     bx                      ; bx = major/minor SPX version #
        pop     bp                      ; caller cx - NOT restored
        pop     bp                      ; caller ax - NOT restored
        pop     bp                      ; caller bp - restored
        ret
DispatchWithFeeling endp

; ***   VwIpxEsrFunction
; *
; *     This routine makes the call to the ESR as defined in the ECB. We must
; *     set up our stack, save the registers (except SS & SP), then call the
; *     ESR.
; *
; *     Control will not be transferred here for an ECB which has a NULL ESR
; *     field
; *
; *     ENTRY   AL = 0 for AES or 0FFh for IPX
; *             ES:SI = ECB address
; *
; *     EXIT    depends on function
; *
; *     USES    depends on function
; *
; *     ASSUMES nothing
; *
; ***

VwIpxEsrFunction proc

;
; Novell documentation states all registers except SS and SP are saved before
; calling ESR and that INTERRUPTS ARE DISABLED
;

        pusha
        push    ds
        push    es
        mov     ax,VddHandle
        mov     bx,-2
        DispatchCall                    ; get ECB
        jc      @f
        call    dword ptr es:[si][4]    ; branch to the ESR
        mov     al,20h
        out     0a0h,al                 ; clear slave pic
        out     20h,al                  ;   "   master "
        pop     es
        pop     ds
        popa
        iret
@@:     pop     es
        pop     ds
        popa
        jmp     OldIrqHandler
VwIpxEsrFunction endp

ResidentCodeEnd

end start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\dspch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\certcli.c ===
#include "dspch.h"
#pragma hdrstop

#define _CERTCLI_
#include <certca.h>

#include <winldap.h>


static
HRESULT
WINAPI
CAAccessCheck(
    IN HCAINFO      hCAInfo,
    IN HANDLE       ClientToken
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CACertTypeAccessCheck(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CACloseCA(
          IN HCAINFO hCA
          )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CACloseCertType(
                IN HCERTTYPE hCertType
                )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
DWORD
WINAPI
CACountCAs(
           IN  HCAINFO  hCAInfo
           )
{
    return 0;
}

static
DWORD
WINAPI
CACountCertTypes(
    IN  HCERTTYPE  hCertType
    )
{
    return 0;
}

static
CERTCLIAPI
HRESULT
WINAPI
CACreateLocalAutoEnrollmentObject(
    IN LPCWSTR                              pwszCertType,
    IN OPTIONAL WCHAR **                    awszCAs,
    IN OPTIONAL PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
    IN DWORD                                dwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAEnumCertTypesForCA(
    IN  HCAINFO     hCAInfo,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAEnumCertTypesForCAEx(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
CAEnumFirstCA(
    IN  LPCWSTR          wszScope,
    IN  DWORD            fFlags,
    OUT HCAINFO *        phCAInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAEnumNextCA(
    IN  HCAINFO          hPrevCA,
    OUT HCAINFO *        phCAInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAEnumNextCertType(
    IN  HCERTTYPE          hPrevCertType,
    OUT HCERTTYPE *        phCertType
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
CAFindByIssuerDN(
    IN  CERT_NAME_BLOB const *  pIssuerDN,
    IN  LPCWSTR                 wszScope,
    IN  DWORD                   fFlags,
    OUT HCAINFO *               phCAInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFindByName(
    IN  LPCWSTR     wszCAName,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCAINFO *   phCAInfo
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFindCertTypeByName(
        IN  LPCWSTR     wszCertType,
        IN  HCAINFO     hCAInfo,
        IN  DWORD       dwFlags,
        OUT HCERTTYPE * phCertType
        )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFreeCAProperty(
    IN  HCAINFO     hCAInfo,
    LPWSTR *        awszPropertyValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFreeCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    IN  PCERT_EXTENSIONS    pCertExtensions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAFreeCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPWSTR *    awszPropertyValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCACertificate(
    IN  HCAINFO     hCAInfo,
    OUT PCCERT_CONTEXT *ppCert
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCAProperty(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
CAGetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    OUT OPTIONAL FILETIME * pftExpiration,
    OUT OPTIONAL FILETIME * pftOverlap
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeExtensionsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwFlags,
    IN  LPVOID              pParam,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT
WINAPI
CAGetCertTypeFlags(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeFlagsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwOption,
    OUT DWORD *             pdwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeKeySpec(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwKeySpec
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CAGetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPVOID      pPropertyValue)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
myRobustLdapBind(
    OUT LDAP ** ppldap,
    IN BOOL fGC
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
CertServerSubmitRequest(
    IN DWORD Flags,
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OPTIONAL IN WCHAR const *pwszRequestAttributes,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll) // free via CertServerFreeMemory
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
VOID
WINAPI
CertServerFreeMemory(
    IN VOID *pv)
{
    NOTHING;
}



//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(certcli)
{
	DLPENTRY(CAAccessCheck)
	DLPENTRY(CACertTypeAccessCheck)
	DLPENTRY(CACloseCA)
	DLPENTRY(CACloseCertType)
	DLPENTRY(CACountCAs)
	DLPENTRY(CACountCertTypes)
        DLPENTRY(CACreateLocalAutoEnrollmentObject)
	DLPENTRY(CAEnumCertTypesForCA)
	DLPENTRY(CAEnumCertTypesForCAEx)
	DLPENTRY(CAEnumFirstCA)
	DLPENTRY(CAEnumNextCA)
	DLPENTRY(CAEnumNextCertType)
	DLPENTRY(CAFindByIssuerDN)
	DLPENTRY(CAFindByName)
	DLPENTRY(CAFindCertTypeByName)
	DLPENTRY(CAFreeCAProperty)
	DLPENTRY(CAFreeCertTypeExtensions)
	DLPENTRY(CAFreeCertTypeProperty)
	DLPENTRY(CAGetCACertificate)
	DLPENTRY(CAGetCAProperty)
	DLPENTRY(CAGetCertTypeExpiration)
	DLPENTRY(CAGetCertTypeExtensions)
	DLPENTRY(CAGetCertTypeExtensionsEx)
	DLPENTRY(CAGetCertTypeFlags)
	DLPENTRY(CAGetCertTypeFlagsEx)
	DLPENTRY(CAGetCertTypeKeySpec)
	DLPENTRY(CAGetCertTypeProperty)
	DLPENTRY(CAGetCertTypePropertyEx)
};


DEFINE_PROCNAME_MAP(certcli)

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(certcli)
{
    DLOENTRY(214,myRobustLdapBind)
    DLOENTRY(219,CertServerSubmitRequest)
    DLOENTRY(221,CertServerFreeMemory)
};

DEFINE_ORDINAL_MAP(certcli)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\crypt32.c ===
#include "dspch.h"
#pragma hdrstop

#define _CRYPT32_
#include <wincrypt.h>

static
WINCRYPT32API
BOOL
WINAPI
CertAddCertificateContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertAddEncodedCertificateToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertCloseStore(
    IN HCERTSTORE hCertStore,
    DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertCompareCertificate(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId1,
    IN PCERT_INFO pCertId2
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertCompareCertificateName(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pCertName1,
    IN PCERT_NAME_BLOB pCertName2
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertControlStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertCreateCertificateContext(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertCreateCTLContext(
    DWORD dwMsgAndCertEncodingType,
    const BYTE *pbCtlEncoded,
    DWORD cbCtlEncoded
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
BOOL
WINAPI
CertDeleteCertificateFromStore(
    IN PCCERT_CONTEXT pCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertCreateSelfSignCertificate(
    IN          HCRYPTPROV                  hProv,
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertDuplicateCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertDuplicateCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertEnumCertificatesInStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
BOOL
WINAPI
CertFreeCertificateContext (
    IN PCCERT_CONTEXT pCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertFindCertificateInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
WINCRYPT32API
PCCTL_CONTEXT
WINAPI
CertFindCTLInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCTL_CONTEXT pPrevCtlContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
PCERT_EXTENSION
WINAPI
CertFindExtension(
    IN LPCSTR pszObjId,
    IN DWORD cExtensions,
    IN CERT_EXTENSION rgExtensions[]
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
PCTL_ENTRY 
WINAPI 
CertFindSubjectInCTL(
    DWORD dwEncodingType, 
    DWORD dwSubjectType, 
    void *pvSubject, 
    PCCTL_CONTEXT pCtlContext, 
    DWORD dwFlags 
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
VOID
WINAPI
CertFreeCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    NOTHING;
}

static
WINCRYPT32API
BOOL
WINAPI
CertFreeCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertGetCertificateChain (
    IN OPTIONAL HCERTCHAINENGINE hChainEngine,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPFILETIME pTime,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertGetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI 
CertGetEnhancedKeyUsage (
    IN     PCCERT_CONTEXT     pCertContext,
    IN     DWORD              dwFlags,
    OUT    PCERT_ENHKEY_USAGE pUsage,
    IN OUT DWORD*             pcbUsage
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CertGetIssuerCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN OPTIONAL PCCERT_CONTEXT pPrevIssuerContext,
    IN OUT DWORD *pdwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
WINCRYPT32API
DWORD
WINAPI
CertGetPublicKeyLength(
    DWORD dwCertEncodingType,
    PCERT_PUBLIC_KEY_INFO pPublicKey
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}


static
WINCRYPT32API
DWORD
WINAPI
CertNameToStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPWSTR psz,
    IN DWORD csz
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
HCERTSTORE
WINAPI
CertOpenStore(
    IN LPCSTR lpszStoreProvider,
    IN DWORD dwEncodingType,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwFlags,
    IN const void *pvPara
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINCRYPT32API
HCERTSTORE
WINAPI 
CertOpenSystemStoreW(
    HCRYPTPROV  hProv,
    const WCHAR * wcsSubsystemProtocol
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
WINCRYPT32API
BOOL
WINAPI
CertRegisterPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
DWORD
WINAPI
CertRDNValueToStrW(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPWSTR psz,
    IN DWORD csz
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINCRYPT32API
BOOL
WINAPI
CertSetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertStrToNameW(
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppszError
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertVerifyCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CertVerifySubjectCertificateContext(
    IN PCCERT_CONTEXT pSubject,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
LONG
WINAPI
CertVerifyTimeValidity(
    IN LPFILETIME pTimeToVerify,
    IN PCERT_INFO pCertInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptAcquireCertificatePrivateKey(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTPROV *phCryptProv,
    OUT OPTIONAL DWORD *pdwKeySpec,
    OUT OPTIONAL BOOL *pfCallerFreeProv
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32STRINGAPI
BOOL
WINAPI
CryptBinaryToStringW(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    IN     LPWSTR      pszString,
    IN OUT DWORD       *pcchString
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptDecodeObject(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT void        *pvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptDecodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
BOOL
WINAPI
CryptDecryptMessage(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptEncodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptEncodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT void *pvEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptEncryptMessage(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE *pbEncryptedBlob,
    IN OUT DWORD *pcbEncryptedBlob
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptExportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptFormatObject(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
    IN DWORD dwFormatStrType,
    IN void  *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
DWORD
WINAPI
CertGetNameStringW(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwType,
    IN DWORD dwFlags,
    IN void *pvTypePara,
    OUT OPTIONAL LPWSTR pszNameString,
    IN DWORD cchNameString
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptHashPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptImportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT HCRYPTKEY *phKey
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptImportPublicKeyInfoEx(
    HCRYPTPROV hCryptProv,
    DWORD dwCertEncodingType,
    PCERT_PUBLIC_KEY_INFO pInfo,
    ALG_ID aiKeyAlg,
    DWORD dwFlags,
    void *pvAuxInfo,
    HCRYPTKEY *phKey
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptMsgGetAndVerifySigner(
    HCRYPTMSG hCryptMsg, 
    DWORD cSignerStore,
    HCERTSTORE *rghSignerStore,
    DWORD dwFlags,    
    PCCERT_CONTEXT *ppSigner,
    DWORD *pdwSignerIndex
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptProtectData(
        DATA_BLOB*      pDataIn,
        LPCWSTR         szDataDescr,
        DATA_BLOB*      pOptionalEntropy,
        PVOID           pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
        DWORD           dwFlags,
        DATA_BLOB*      pDataOut)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptProtectMemory(
    LPVOID          pDataIn,
    DWORD           cbDataIn,
    DWORD           dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;    
}

static
WINCRYPT32API
BOOL
WINAPI
CryptSignAndEncodeCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OPTIONAL const void *pvHashAuxInfo,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptSignMessage(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN BOOL fDetachedSignature,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptUnprotectData(
        DATA_BLOB*      pDataIn,             // in encr blob
        LPWSTR*         ppszDataDescr,       // out
        DATA_BLOB*      pOptionalEntropy,
        PVOID           pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
        DWORD           dwFlags,
        DATA_BLOB*      pDataOut)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINCRYPT32API
BOOL
WINAPI
CryptUnprotectMemory(
    LPVOID          pDataIn,
    DWORD           cbDataIn,
    DWORD           dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE; 
}

static
WINCRYPT32API
BOOL
WINAPI
CryptVerifyCertificateSignature(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN const BYTE * pbEncoded,
    IN DWORD        cbEncoded,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINCRYPT32API
BOOL
WINAPI
CryptVerifyMessageSignature(
    PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    DWORD dwSignerIndex,
    const BYTE *pbSignedBlob,
    DWORD cbSignedBlob,
    BYTE *pbDecoded,
    DWORD *pcbDecoded,
    PCCERT_CONTEXT *ppSignerCert
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(crypt32)
{
    DLPENTRY(CertAddCertificateContextToStore)
    DLPENTRY(CertAddEncodedCertificateToStore)
    DLPENTRY(CertCloseStore)
    DLPENTRY(CertCompareCertificate)
    DLPENTRY(CertCompareCertificateName)
    DLPENTRY(CertControlStore)
    DLPENTRY(CertCreateCTLContext)
    DLPENTRY(CertCreateCertificateContext)
    DLPENTRY(CertCreateSelfSignCertificate)
    DLPENTRY(CertDeleteCertificateFromStore)
    DLPENTRY(CertDuplicateCTLContext)
    DLPENTRY(CertDuplicateCertificateContext)
    DLPENTRY(CertEnumCertificatesInStore)
    DLPENTRY(CertFindCTLInStore)
    DLPENTRY(CertFindCertificateInStore)
    DLPENTRY(CertFindExtension)
    DLPENTRY(CertFindSubjectInCTL)
    DLPENTRY(CertFreeCTLContext)
    DLPENTRY(CertFreeCertificateChain)
    DLPENTRY(CertFreeCertificateContext)
    DLPENTRY(CertGetCertificateChain)
    DLPENTRY(CertGetCertificateContextProperty)
    DLPENTRY(CertGetEnhancedKeyUsage)
    DLPENTRY(CertGetIssuerCertificateFromStore)
    DLPENTRY(CertGetNameStringW)
    DLPENTRY(CertGetPublicKeyLength)
    DLPENTRY(CertNameToStrW)
    DLPENTRY(CertOpenStore)
    DLPENTRY(CertOpenSystemStoreW)
    DLPENTRY(CertRDNValueToStrW)
    DLPENTRY(CertRegisterPhysicalStore)
    DLPENTRY(CertSetCertificateContextProperty)
    DLPENTRY(CertStrToNameW)
    DLPENTRY(CertVerifyCertificateChainPolicy)
    DLPENTRY(CertVerifySubjectCertificateContext)
    DLPENTRY(CertVerifyTimeValidity)
    DLPENTRY(CryptAcquireCertificatePrivateKey)
    DLPENTRY(CryptBinaryToStringW)
    DLPENTRY(CryptDecodeObject)
    DLPENTRY(CryptDecodeObjectEx)
    DLPENTRY(CryptDecryptMessage)
    DLPENTRY(CryptEncodeObject)
    DLPENTRY(CryptEncodeObjectEx)
    DLPENTRY(CryptEncryptMessage)
    DLPENTRY(CryptExportPublicKeyInfo)
    DLPENTRY(CryptFormatObject)
    DLPENTRY(CryptHashPublicKeyInfo)
    DLPENTRY(CryptImportPublicKeyInfo)
    DLPENTRY(CryptImportPublicKeyInfoEx)
    DLPENTRY(CryptMsgGetAndVerifySigner)
    DLPENTRY(CryptProtectData)
    DLPENTRY(CryptProtectMemory)
    DLPENTRY(CryptSignAndEncodeCertificate)
    DLPENTRY(CryptSignMessage)
    DLPENTRY(CryptUnprotectData)
    DLPENTRY(CryptUnprotectMemory)
    DLPENTRY(CryptVerifyCertificateSignature)
    DLPENTRY(CryptVerifyMessageSignature)
};

DEFINE_PROCNAME_MAP(crypt32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\activeds.c ===
#include "dspch.h"
#pragma hdrstop

static
HRESULT
WINAPI
ADsOpenObject(
    LPCWSTR lpszPathName,
    LPCWSTR lpszUserName,
    LPCWSTR lpszPassword,
    DWORD  dwReserved,
    REFIID riid,
    void FAR * FAR * ppObject
    )
{
    if (ppObject)
        *ppObject = NULL;
        
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}    

static
HRESULT
WINAPI
ADsGetObject(
    LPCWSTR lpszPathName,
    REFIID riid,
    VOID * * ppObject
    )
{
    if (ppObject)
    {
        *ppObject = NULL;
    }

    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
WINAPI
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(activeds)
{
    DLOENTRY(3,ADsGetObject)
    DLOENTRY(9,ADsOpenObject)
    DLOENTRY(13,ADsGetLastError)
};

DEFINE_ORDINAL_MAP(activeds)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\esent.c ===
#include "dspch.h"
#pragma hdrstop

#include <esent98.h>

static
JET_ERR JET_API JetAddColumn(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        const char              *szColumnName,
        const JET_COLUMNDEF     *pcolumndef,
        const void              *pvDefault,
        unsigned long   cbDefault,
        JET_COLUMNID    *pcolumnid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetAttachDatabase(
        JET_SESID               sesid,
        const char              *szFilename,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetBeginSession(
        JET_INSTANCE    instance,
        JET_SESID               *psesid,
        const char              *szUserName,
        const char              *szPassword )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetBeginTransaction(
        JET_SESID sesid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCloseDatabase(
        JET_SESID               sesid,
        JET_DBID                dbid,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCloseTable(
        JET_SESID sesid, JET_TABLEID tableid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCommitTransaction(
        JET_SESID sesid, JET_GRBIT grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCreateDatabase(
        JET_SESID               sesid,
        const char              *szFilename,
        const char              *szConnect,
        JET_DBID                *pdbid,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetCreateTableColumnIndex(
        JET_SESID               sesid,
        JET_DBID                dbid,
        JET_TABLECREATE *ptablecreate )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetDelete(
        JET_SESID sesid, JET_TABLEID tableid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetDeleteTable(
        JET_SESID               sesid,
        JET_DBID                dbid,
        const char              *szTableName )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetDetachDatabase(
        JET_SESID               sesid,
        const char              *szFilename )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetEndSession(
        JET_SESID sesid, JET_GRBIT grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetGetDatabaseInfo(
        JET_SESID               sesid,
        JET_DBID                dbid,
        void                    *pvResult,
        unsigned long   cbMax,
        unsigned long   InfoLevel )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetGetTableColumnInfo(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        const char              *szColumnName,
        void                    *pvResult,
        unsigned long   cbMax,
        unsigned long   InfoLevel )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetIndexRecordCount(
        JET_SESID sesid,
        JET_TABLEID tableid,
        unsigned long *pcrec,
        unsigned long crecMax )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetInit(
        JET_INSTANCE *pinstance)
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetMakeKey(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        const void              *pvData,
        unsigned long   cbData,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetMove(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        long                    cRow,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetOpenDatabase(
        JET_SESID               sesid,
        const char              *szFilename,
        const char              *szConnect,
        JET_DBID                *pdbid,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetOpenTable(
        JET_SESID               sesid,
        JET_DBID                dbid,
        const char              *szTableName,
        const void              *pvParameters,
        unsigned long   cbParameters,
        JET_GRBIT               grbit,
        JET_TABLEID             *ptableid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetPrepareUpdate(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        unsigned long   prep )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetResetSessionContext(
        JET_SESID               sesid )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetRetrieveColumn(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        JET_COLUMNID    columnid,
        void                    *pvData,
        unsigned long   cbData,
        unsigned long   *pcbActual,
        JET_GRBIT               grbit,
        JET_RETINFO             *pretinfo )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetRollback(
        JET_SESID sesid, JET_GRBIT grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSeek(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        JET_GRBIT               grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetColumn(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        JET_COLUMNID    columnid,
        const void              *pvData,
        unsigned long   cbData,
        JET_GRBIT               grbit,
        JET_SETINFO             *psetinfo )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetCurrentIndex(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        const char              *szIndexName )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetIndexRange(
        JET_SESID sesid,
        JET_TABLEID tableidSrc,
        JET_GRBIT grbit)
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetSessionContext(
        JET_SESID               sesid,
        ULONG_PTR               ulContext )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetSetSystemParameter(
        JET_INSTANCE    *pinstance,
        JET_SESID               sesid,
        unsigned long   paramid,
        ULONG_PTR               lParam,
        const char              *sz )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetTerm(
        JET_INSTANCE instance )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetTerm2(
        JET_INSTANCE instance,
        JET_GRBIT grbit )
{
    return JET_errInternalError;
}


static
JET_ERR JET_API JetUpdate(
        JET_SESID               sesid,
        JET_TABLEID             tableid,
        void                    *pvBookmark,
        unsigned long   cbBookmark,
        unsigned long   *pcbActual)
{
    return JET_errInternalError;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(esent)
{
    DLPENTRY(JetAddColumn)
    DLPENTRY(JetAttachDatabase)
    DLPENTRY(JetBeginSession)
    DLPENTRY(JetBeginTransaction)
    DLPENTRY(JetCloseDatabase)
    DLPENTRY(JetCloseTable)
    DLPENTRY(JetCommitTransaction)
    DLPENTRY(JetCreateDatabase)
    DLPENTRY(JetCreateTableColumnIndex)
    DLPENTRY(JetDelete)
    DLPENTRY(JetDeleteTable)
    DLPENTRY(JetDetachDatabase)
    DLPENTRY(JetEndSession)
    DLPENTRY(JetGetDatabaseInfo)
    DLPENTRY(JetGetTableColumnInfo)
    DLPENTRY(JetIndexRecordCount)
    DLPENTRY(JetInit)
    DLPENTRY(JetMakeKey)
    DLPENTRY(JetMove)
    DLPENTRY(JetOpenDatabase)
    DLPENTRY(JetOpenTable)
    DLPENTRY(JetPrepareUpdate)
    DLPENTRY(JetResetSessionContext)
    DLPENTRY(JetRetrieveColumn)
    DLPENTRY(JetRollback)
    DLPENTRY(JetSeek)
    DLPENTRY(JetSetColumn)
    DLPENTRY(JetSetCurrentIndex)
    DLPENTRY(JetSetIndexRange)
    DLPENTRY(JetSetSessionContext)
    DLPENTRY(JetSetSystemParameter)
    DLPENTRY(JetTerm)
    DLPENTRY(JetTerm2)
    DLPENTRY(JetUpdate)
};

DEFINE_PROCNAME_MAP(esent)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\authz.c ===
#include "dspch.h"
#pragma hdrstop

#define AUTHZAPI
#define AUTHZ_CLIENT_CONTEXT_HANDLE          PVOID
#define PAUTHZ_CLIENT_CONTEXT_HANDLE         PVOID *
#define AUTHZ_RESOURCE_MANAGER_HANDLE        PVOID
#define PAUTHZ_RESOURCE_MANAGER_HANDLE       PVOID *
#define AUTHZ_ACCESS_CHECK_RESULTS_HANDLE    PVOID
#define AUTHZ_CONTEXT_INFORMATION_CLASS      DWORD
#define PFN_AUTHZ_ACCESS_CHECK               PVOID
#define PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS     PVOID
#define PFN_AUTHZ_FREE_DYNAMIC_GROUPS        PVOID
#define PFN_AUTHZ_DYNAMIC_ACCESS_CHECK       PVOID
#define PAUTHZ_ACCESS_REQUEST                PVOID
#define AUTHZ_AUDIT_EVENT_HANDLE             PVOID
#define PAUTHZ_ACCESS_REPLY                  PVOID
#define PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE   PVOID
#define PAUTHZ_AUDIT_EVENT_TYPE_HANDLE       PVOID
#define AUTHZ_AUDIT_EVENT_TYPE_HANDLE        PVOID
#define PAUDIT_PARAMS                        PVOID
#define AUTHZ_AUDIT_QUEUE_HANDLE             PVOID
#define PAUTHZ_AUDIT_EVENT_HANDLE            PVOID


static
AUTHZAPI
BOOL
WINAPI
AuthzAccessCheck(
    IN     DWORD                              Flags,
    IN     AUTHZ_CLIENT_CONTEXT_HANDLE        hAuthzClientContext,
    IN     PAUTHZ_ACCESS_REQUEST              pRequest,
    IN     AUTHZ_AUDIT_EVENT_HANDLE           hAuditEvent                      OPTIONAL,
    IN     PSECURITY_DESCRIPTOR               pSecurityDescriptor,
    IN     PSECURITY_DESCRIPTOR               *OptionalSecurityDescriptorArray OPTIONAL,
    IN     DWORD                              OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY                pReply,
    OUT    PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults             OPTIONAL
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzAddSidsToContext(
    IN  AUTHZ_CLIENT_CONTEXT_HANDLE  hAuthzClientContext,
    IN  PSID_AND_ATTRIBUTES          Sids                    OPTIONAL,
    IN  DWORD                        SidCount,
    IN  PSID_AND_ATTRIBUTES          RestrictedSids          OPTIONAL,
    IN  DWORD                        RestrictedSidCount,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE phNewAuthzClientContext
    )
{
    return FALSE;
}


static
AUTHZAPI
BOOL
WINAPI
AuthzFreeAuditEvent(
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzFreeContext(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzFreeResourceManager(
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzGetInformationFromContext(
    IN  AUTHZ_CLIENT_CONTEXT_HANDLE     hAuthzClientContext,
    IN  AUTHZ_CONTEXT_INFORMATION_CLASS InfoClass,
    IN  DWORD                           BufferSize,
    OUT PDWORD                          pSizeRequired,
    OUT PVOID                           Buffer
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzInitializeContextFromSid(
    IN  DWORD                         Flags,
    IN  PSID                          UserSid,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs       OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzInitializeResourceManager(
    IN  DWORD                            Flags,
    IN  PFN_AUTHZ_DYNAMIC_ACCESS_CHECK   pfnDynamicAccessCheck   OPTIONAL,
    IN  PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups OPTIONAL,
    IN  PFN_AUTHZ_FREE_DYNAMIC_GROUPS    pfnFreeDynamicGroups    OPTIONAL,
    IN  PCWSTR                           szResourceManagerName,
    OUT PAUTHZ_RESOURCE_MANAGER_HANDLE   phAuthzResourceManager
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditEventType(
    IN  DWORD                          Flags,
    IN  USHORT                         CategoryID,
    IN  USHORT                         AuditID,
    IN  USHORT                         ParameterCount,
    OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditParams(
    IN  DWORD         dwFlags,
    OUT PAUDIT_PARAMS pParams,
    OUT PSID*         ppUserSid,
    IN  PCWSTR        SubsystemName,
    IN  USHORT        NumParams,
    ...
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditEvent(
    IN  DWORD                         Flags,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hRM,
    IN  AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType  OPTIONAL,
    IN  PAUDIT_PARAMS                 pAuditParams     OPTIONAL,
    IN  AUTHZ_AUDIT_QUEUE_HANDLE      hAuditQueue      OPTIONAL,
    IN  DWORD                         dwTimeOut,
    IN  PWSTR                         szOperationType,
    IN  PWSTR                         szObjectType,
    IN  PWSTR                         szObjectName,
    IN  PWSTR                         szAdditionalInfo OPTIONAL,
    OUT PAUTHZ_AUDIT_EVENT_HANDLE     phAuditEvent
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthziLogAuditEvent(
    IN DWORD Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hEvent,
    IN PVOID pReserved
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthziFreeAuditEventType(
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthziInitializeContextFromSid(
    IN  DWORD                         Flags,
    IN  PSID                          UserSid,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs       OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext
    )
{
    return FALSE;
}


static
AUTHZAPI
BOOL
WINAPI
AuthziSourceAudit(
    IN DWORD dwFlags,
    IN USHORT CategoryId,
    IN USHORT AuditId,
    IN PWSTR szSource,
    IN PSID pUserSid OPTIONAL,
    IN USHORT Count,
    ...
    )
{
    return FALSE;
}

static
AUTHZAPI
BOOL
WINAPI
AuthzFreeHandle(
    IN OUT AUTHZ_ACCESS_CHECK_RESULTS_HANDLE hAccessCheckResults
    )

{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(authz)
{
    DLPENTRY(AuthzAccessCheck)
    DLPENTRY(AuthzAddSidsToContext)
    DLPENTRY(AuthzFreeAuditEvent)
    DLPENTRY(AuthzFreeContext)
    DLPENTRY(AuthzFreeHandle)
    DLPENTRY(AuthzFreeResourceManager)
    DLPENTRY(AuthzGetInformationFromContext)
    DLPENTRY(AuthzInitializeContextFromSid)
    DLPENTRY(AuthzInitializeResourceManager)
    DLPENTRY(AuthziFreeAuditEventType)
    DLPENTRY(AuthziInitializeAuditEvent)
    DLPENTRY(AuthziInitializeAuditEventType)
    DLPENTRY(AuthziInitializeAuditParams)
    DLPENTRY(AuthziInitializeContextFromSid)
    DLPENTRY(AuthziLogAuditEvent)
    DLPENTRY(AuthziSourceAudit)
};

DEFINE_PROCNAME_MAP(authz)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\cryptui.c ===
#include "dspch.h"
#pragma hdrstop

#include <wincrypt.h>
#include <cryptui.h>
#include <lenroll.h>


static
BOOL
WINAPI
CryptUIDlgViewCRLW(
        IN PCCRYPTUI_VIEWCRL_STRUCTW pcvcrl
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptUIDlgViewCTLW(
        IN PCCRYPTUI_VIEWCTL_STRUCTW pcvctl
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptUIDlgViewCertificateW(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOL
WINAPI
CryptUIWizCertRequest(
        IN             DWORD                           dwFlags,
        IN OPTIONAL    HWND                            hwndParent,
        IN OPTIONAL    LPCWSTR                         pwszWizardTitle,
        IN             PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
        OUT OPTIONAL   PCCERT_CONTEXT                  *ppCertContext,
        OUT OPTIONAL   DWORD                           *pCAdwStatus
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


HRESULT WINAPI LocalEnroll(  DWORD                 dwFlags,         //IN Required
              LPCWSTR               pRequestString,  // Reserved:  must be NULL. 
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
              PCERT_CONTEXT         *ppCertContext   //OUT Optional: The enrolled certificate
                   )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND); 
}
    

HRESULT WINAPI LocalEnrollNoDS(  DWORD                 dwFlags,         //IN Required
              LPCWSTR               pRequestString,  // Reserved:  must be NULL. 
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
              HANDLE                *pResult         //IN OUT Optional: The enrolled certificate
                   )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND); 
}



//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(cryptui)
{
    DLPENTRY(CryptUIDlgViewCRLW)
    DLPENTRY(CryptUIDlgViewCTLW)
    DLPENTRY(CryptUIDlgViewCertificateW)
    DLPENTRY(CryptUIWizCertRequest)
    DLPENTRY(LocalEnroll)
    DLPENTRY(LocalEnrollNoDS)
};

DEFINE_PROCNAME_MAP(cryptui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\credui.c ===
#include "dspch.h"
#pragma hdrstop

#define _CREDUI_
#include <wincrui.h>

static
CREDUIAPI
void
WINAPI
CredUIFlushAllCredentials(
    void
    )
{
}

static
CREDUIAPI
DWORD
WINAPI
CredUIParseUserNameW(
    PCWSTR pszUserName,
    PWSTR pszUser,
    ULONG ulUserMaxChars,
    PWSTR pszDomain,
    ULONG ulDomainMaxChars
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
CREDUIAPI
BOOL
WINAPI
CredUIInitControls()
{
    return FALSE;
}

static
CREDUIAPI
DWORD
WINAPI
CredUICmdLinePromptForCredentialsW(
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR UserName,
    ULONG ulUserMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
CREDUIAPI
DWORD
WINAPI
CredUIConfirmCredentialsW(
    PCWSTR pszTargetName,
    BOOL   bConfirm
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
CREDUIAPI
DWORD
WINAPI
CredUIPromptForCredentialsW(
    PCREDUI_INFOW pUiInfo,
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR pszUserName,
    ULONG ulUserNameMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    BOOL *save,
    DWORD dwFlags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
CREDUIAPI
DWORD
WINAPI
CredUIStoreSSOCredW(
    PCWSTR pszRealm,
    PCWSTR pszUsername,
    PCWSTR pszPassword,
    BOOL   bPersist
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(credui)
{
    DLPENTRY(CredUICmdLinePromptForCredentialsW)
    DLPENTRY(CredUIConfirmCredentialsW)
    DLPENTRY(CredUIFlushAllCredentials)
    DLPENTRY(CredUIInitControls)
    DLPENTRY(CredUIParseUserNameW)
    DLPENTRY(CredUIPromptForCredentialsW)
    DLPENTRY(CredUIStoreSSOCredW)
};

DEFINE_PROCNAME_MAP(credui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\kdcsvc.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntsam.h>

static
NTSTATUS
KdcAccountChangeNotification (
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(kdcsvc)
{
    DLPENTRY(KdcAccountChangeNotification)
};

DEFINE_PROCNAME_MAP(kdcsvc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\keymgr.c ===
#include "dspch.h"
#pragma hdrstop

#define _KEYMGR_
#include <keymgr.h>

static LONG APIENTRY CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2)
{
    return 0;
}
static void WINAPI KRShowKeyMgr(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowRestoreWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowRestoreWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowRestoreFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowSaveWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowSaveWizardExW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}
static void WINAPI PRShowSaveFromMsginaW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    return;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(keymgr)
{
    DLPENTRY(CPlApplet)
    DLPENTRY(KRShowKeyMgr)
    DLPENTRY(PRShowRestoreFromMsginaW)
    DLPENTRY(PRShowRestoreWizardExW)
    DLPENTRY(PRShowRestoreWizardW)
    DLPENTRY(PRShowSaveFromMsginaW)
    DLPENTRY(PRShowSaveWizardExW)
    DLPENTRY(PRShowSaveWizardW)
};

DEFINE_PROCNAME_MAP(keymgr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\mscat32.c ===
#include "dspch.h"
#pragma hdrstop

#include <wincrypt.h>
#include <mscat.h>


static
BOOL
WINAPI
CryptCATAdminAcquireContext (
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
HCATINFO
WINAPI
CryptCATAdminAddCatalog (
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OPTIONAL WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CryptCATAdminCalcHashFromFileHandle (
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
HCATINFO
WINAPI
CryptCATAdminEnumCatalogFromHash (
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CryptCATAdminReleaseCatalogContext (
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminReleaseContext (
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATCatalogInfoFromContext (
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mscat32)
{
    DLPENTRY(CryptCATAdminAcquireContext)
    DLPENTRY(CryptCATAdminAddCatalog)
    DLPENTRY(CryptCATAdminCalcHashFromFileHandle)
    DLPENTRY(CryptCATAdminEnumCatalogFromHash)
    DLPENTRY(CryptCATAdminReleaseCatalogContext)
    DLPENTRY(CryptCATAdminReleaseContext)
    DLPENTRY(CryptCATCatalogInfoFromContext)
};

DEFINE_PROCNAME_MAP(mscat32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\lsasrv.c ===
#include "dspch.h"
#pragma hdrstop

#include <lsarpc.h>
#include <crypt.h>
#include <ntsam.h>
#include <logonmsv.h>

static
NTSTATUS
LsaICallPackagePassthrough(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
VOID
NTAPI
LsaIFreeHeap(
    IN PVOID pvMemory
    )
{
    return;
}

static
VOID
NTAPI
LsaIFreeReturnBuffer(
    IN PVOID Buffer
    )
{
    return;
}

static
VOID
NTAPI
LsaIFree_LSAPR_CR_CIPHER_VALUE (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    )
{
    return;
}

static
VOID
NTAPI
LsaIFree_LSAPR_POLICY_INFORMATION (
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    )
{
    return;
}

static
VOID
NTAPI
LsaIFree_LSAPR_REFERENCED_DOMAIN_LIST (
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    )
{
    return;
}

static
VOID
NTAPI
LsaIFree_LSAPR_TRANSLATED_NAMES (
    IN PLSAPR_TRANSLATED_NAMES TranslatedNames
    )
{
    return;
}

static
VOID
NTAPI
LsaIFree_LSAPR_TRANSLATED_SIDS (
    IN PLSAPR_TRANSLATED_SIDS TranslatedSids
    )
{
    return;
}

static
NTSTATUS
LsaIGetNbAndDnsDomainNames(
    IN PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING DnsDomainName,
    OUT PUNICODE_STRING NetbiosDomainName
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
LsaIGetLogonGuid(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
VOID
LsaINotifyPasswordChanged(
    IN PUNICODE_STRING NetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PUNICODE_STRING Upn OPTIONAL,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    IN BOOLEAN Impersonating
    )
{
    return;
}

static
NTSTATUS
NTAPI
LsaIOpenPolicyTrusted(
    OUT PLSAPR_HANDLE PolicyHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaIQueryInformationPolicyTrusted(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
LsarClose(
    LSAPR_HANDLE *ObjectHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
LsarLookupSids(
    LSAPR_HANDLE PolicyHandle,
    PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    PLSAPR_TRANSLATED_NAMES TranslatedNames,
    LSAP_LOOKUP_LEVEL LookupLevel,
    PULONG MappedCount
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
LsarOpenSecret(
    LSAPR_HANDLE PolicyHandle,
    PLSAPR_UNICODE_STRING SecretName,
    ACCESS_MASK DesiredAccess,
    LSAPR_HANDLE *SecretHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
LsarQuerySecret(
    LSAPR_HANDLE SecretHandle,
    PLSAPR_CR_CIPHER_VALUE *EncryptedCurrentValue,
    PLARGE_INTEGER CurrentValueSetTime,
    PLSAPR_CR_CIPHER_VALUE *EncryptedOldValue,
    PLARGE_INTEGER OldValueSetTime
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
LsaIFilterSids(
    PUNICODE_STRING TrustedDomainName,
    ULONG TrustDirection,
    ULONG TrustType,
    ULONG TrustAttributes,
    PSID Sid,
    NETLOGON_VALIDATION_INFO_CLASS InfoClass,
    PVOID SamInfo,
    PSID ResourceGroupDomainSid,
    PULONG ResourceGroupCount,
    PGROUP_MEMBERSHIP ResourceGroupIds
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
LsaIFilterNamespace(
    IN PUNICODE_STRING TrustedDomainName,
    IN ULONG TrustDirection,
    IN ULONG TrustType,
    IN ULONG TrustAttributes,
    IN PUNICODE_STRING Namespace
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
LsaIIsDomainWithinForest(
    IN UNICODE_STRING * TrustedDomainName,
    OUT BOOL * WithinForest,
    OUT OPTIONAL BOOL * ThisDomain,
    OUT OPTIONAL PSID * TrustedDomainSid,
    OUT OPTIONAL ULONG * TrustDirection,
    OUT OPTIONAL ULONG * TrustType,
    OUT OPTIONAL ULONG * TrustAttributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOLEAN
LsaINoMoreWin2KDomain()
{
    return FALSE;
}

static
NTSTATUS
LsaISetTokenDacl(
    IN HANDLE Token
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(lsasrv)
{
    DLPENTRY(LsaICallPackagePassthrough)
    DLPENTRY(LsaIFilterSids)
    DLPENTRY(LsaIFreeHeap)
    DLPENTRY(LsaIFreeReturnBuffer)
    DLPENTRY(LsaIFree_LSAPR_CR_CIPHER_VALUE)
    DLPENTRY(LsaIFree_LSAPR_POLICY_INFORMATION)
    DLPENTRY(LsaIFree_LSAPR_REFERENCED_DOMAIN_LIST)
    DLPENTRY(LsaIFree_LSAPR_TRANSLATED_NAMES)
    DLPENTRY(LsaIFree_LSAPR_TRANSLATED_SIDS)
    DLPENTRY(LsaIGetLogonGuid)
    DLPENTRY(LsaIGetNbAndDnsDomainNames)
    DLPENTRY(LsaIIsDomainWithinForest)
    DLPENTRY(LsaINoMoreWin2KDomain)
    DLPENTRY(LsaINotifyPasswordChanged)
    DLPENTRY(LsaIOpenPolicyTrusted)
    DLPENTRY(LsaIQueryInformationPolicyTrusted)
    DLPENTRY(LsaISetTokenDacl)
    DLPENTRY(LsarClose)
    DLPENTRY(LsarLookupSids)
    DLPENTRY(LsarOpenSecret)
    DLPENTRY(LsarQuerySecret)
};

DEFINE_PROCNAME_MAP(lsasrv)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\dnsapi.c ===
#include "dspch.h"
#pragma hdrstop

#include <dnsapi.h>

#define PDNS_DEBUG_INFO  PVOID

//
//  Old entry point macro'd away in dnsapi.h
//

#undef DnsRecordListFree


//
//  SDK public
//

static 
BOOL
WINAPI
DnsFlushResolverCache(
    VOID
    )
{
    return FALSE;
}

static
VOID
WINAPI
DnsFree(
    IN OUT  PVOID           pData,
    IN      DNS_FREE_TYPE   FreeType
    )
{
    return;
}

static
DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_W(
    IN      LPCWSTR         pszLeftName,
    IN      LPCWSTR         pszRightName,
    IN      DWORD           dwReserved
    )
{
    return DnsNameCompareInvalid;
}


static
BOOL
WINAPI
DnsNameCompare_A(
    IN      LPSTR       pName1,
    IN      LPSTR       pName2
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DnsNameCompare_UTF8(
    IN      LPSTR       pName1,
    IN      LPSTR       pName2
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DnsNameCompare_W(
    IN      LPWSTR          pName1,
    IN      LPWSTR          pName2
    )
{
    return FALSE;
}

static
DNS_STATUS
WINAPI
DnsQuery_A(
    IN      LPCSTR          pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DNS_STATUS
WINAPI
DnsQuery_UTF8(
    IN      LPCSTR          pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DNS_STATUS
WINAPI
DnsQuery_W(
    IN      LPCWSTR         pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      aipServers            OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResults        OPTIONAL,
    IN OUT  PVOID *         pReserved             OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

BOOL
WINAPI
DnsRecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    )
{
    return  FALSE;
}

BOOL
WINAPI
DnsRecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,
    OUT     PDNS_RECORD *   ppDiff2
    )
{
    return  FALSE;
}

PDNS_RECORD
WINAPI
DnsRecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return  NULL;
}

PDNS_RECORD
WINAPI
DnsRecordSetCopyEx(
    IN      PDNS_RECORD     pRecordSet,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return  NULL;
}


static
VOID
WINAPI
DnsRecordListFree(
    IN OUT  PDNS_RECORD     pRecordList,
    IN      DNS_FREE_TYPE   FreeType
    )
{
    return;
}

PDNS_RECORD
DnsRecordSetDetach(
    IN OUT  PDNS_RECORD     pRecordList
    )
{
    return  NULL;
}


static
DNS_STATUS
DnsValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DNS_STATUS
DnsValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DNS_STATUS
DnsValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return ERROR_PROC_NOT_FOUND;
}


DNS_STATUS
WINAPI
DnsQueryConfig(
    IN      DNS_CONFIG_TYPE     Config,
    IN      DWORD               Flag,
    IN      PWSTR               pwsAdapterName,
    IN      PVOID               pReserved,
    OUT     PVOID               pBuffer,
    IN OUT  PDWORD              pBufferLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
//  Private config
//

PVOID
WINAPI
DnsQueryConfigAllocEx(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName,
    IN      BOOL                fLocalAlloc
    )
{
    return NULL;
}

VOID
WINAPI
DnsFreeConfigStructure(
    IN OUT  PVOID           pData,
    IN      DNS_CONFIG_TYPE ConfigId
    )
{
    return;
}

DWORD
WINAPI
DnsQueryConfigDword(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName
    )
{
    return 0;
}

DNS_STATUS
WINAPI
DnsSetConfigDword(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName,
    IN      DWORD               NewValue
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
//  Private stuff
//

PVOID
DnsApiAlloc(
    IN      INT             iSize
    )
{
    return  NULL;
}

PVOID
DnsApiRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
{
    return  NULL;
}

VOID
DnsApiFree(
    IN OUT  PVOID           pMem
    )
{
    return;
}

PDNS_DEBUG_INFO
DnsApiSetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    )
{
    return  NULL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are
// CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(dnsapi)
{
    DLPENTRY(DnsApiAlloc)
    DLPENTRY(DnsApiFree)
    DLPENTRY(DnsApiRealloc)
    DLPENTRY(DnsApiSetDebugGlobals)
    DLPENTRY(DnsFlushResolverCache)
    DLPENTRY(DnsFree)
    DLPENTRY(DnsFreeConfigStructure)
    DLPENTRY(DnsNameCompareEx_W)
    DLPENTRY(DnsNameCompare_A)
    DLPENTRY(DnsNameCompare_UTF8)
    DLPENTRY(DnsNameCompare_W)
    DLPENTRY(DnsQueryConfig)
    DLPENTRY(DnsQueryConfigAllocEx)
    DLPENTRY(DnsQueryConfigDword)
    DLPENTRY(DnsQuery_A)
    DLPENTRY(DnsQuery_UTF8)
    DLPENTRY(DnsQuery_W)
    DLPENTRY(DnsRecordCompare)
    DLPENTRY(DnsRecordCopyEx)
    DLPENTRY(DnsRecordListFree)
    DLPENTRY(DnsRecordSetCompare)
    DLPENTRY(DnsRecordSetCopyEx)
    DLPENTRY(DnsRecordSetDetach)
    DLPENTRY(DnsSetConfigDword)
    DLPENTRY(DnsValidateName_A)
    DLPENTRY(DnsValidateName_UTF8)
    DLPENTRY(DnsValidateName_W)
};

DEFINE_PROCNAME_MAP(dnsapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\mssign32.c ===
#include "dspch.h"
#pragma hdrstop

#include <wincrypt.h>
#include <signer.h>
#include <mssip.h>
#include <signhlp.h>

static
void WINAPI FreeCryptProvFromCert(BOOL          fAcquired,
                           HCRYPTPROV   hProv,
                           LPWSTR       pwszCapiProvider,
                           DWORD        dwProviderType,
                           LPWSTR       pwszTmpContainer)
{
    NOTHING;
}

static
BOOL WINAPI GetCryptProvFromCert(
    HWND            hwnd,
    PCCERT_CONTEXT  pCert,
    HCRYPTPROV      *phCryptProv,
    DWORD           *pdwKeySpec,
    BOOL            *pfDidCryptAcquire,
    LPWSTR          *ppwszTmpContainer,
    LPWSTR          *ppwszProviderName,
    DWORD           *pdwProviderType
    )
{
    return FALSE;
}


static
void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer)
{
    NOTHING;
}


static
HRESULT WINAPI PvkGetCryptProv( IN HWND hwnd,
                            IN LPCWSTR pwszCaption,
                            IN LPCWSTR pwszCapiProvider,
                            IN DWORD   dwProviderType,
                            IN LPCWSTR pwszPvkFile,
                            IN LPCWSTR pwszKeyContainerName,
                            IN DWORD   *pdwKeySpec,
                            OUT LPWSTR *ppwszTmpContainer,
                            OUT HCRYPTPROV *phCryptProv)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


static
HRESULT WINAPI
SignerFreeSignerContext(
    IN  SIGNER_CONTEXT          *pSignerContext
)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT WINAPI 
SignerSignEx(
    IN  DWORD                   dwFlags,
    IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,
    IN	SIGNER_CERT				*pSignerCert,
    IN	SIGNER_SIGNATURE_INFO	*pSignatureInfo,
    IN	SIGNER_PROVIDER_INFO	*pProviderInfo,
    IN  LPCWSTR					pwszHttpTimeStamp,
    IN  PCRYPT_ATTRIBUTES		psRequest,
    IN	LPVOID					pSipData,
    OUT SIGNER_CONTEXT          **ppSignerContext
)									
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT WINAPI 
SignerTimeStampEx(
    IN  DWORD                   dwFlags,
    IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,
    IN  LPCWSTR					pwszHttpTimeStamp,
    IN  PCRYPT_ATTRIBUTES		psRequest,
    IN	LPVOID					pSipData,
    OUT SIGNER_CONTEXT          **ppSignerContext
)					
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
SpcGetCertFromKey(IN DWORD dwCertEncodingType,
                  IN HCERTSTORE hStore,
                  IN HCRYPTPROV hProv,
                  IN DWORD hKeySpec,
                  OUT PCCERT_CONTEXT* pReturnCert)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mssign32)
{
    DLPENTRY(FreeCryptProvFromCert)
    DLPENTRY(GetCryptProvFromCert)
    DLPENTRY(PvkFreeCryptProv)
    DLPENTRY(PvkGetCryptProv)
    DLPENTRY(SignerFreeSignerContext)
    DLPENTRY(SignerSignEx)
    DLPENTRY(SignerTimeStampEx)
    DLPENTRY(SpcGetCertFromKey)
};

DEFINE_PROCNAME_MAP(mssign32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\msgina.c ===
#include "dspch.h"
#pragma hdrstop

#include <unknwn.h>
#include <winwlx.h>
#undef _MSGinaExports_
#define _MSGINA_
#include <MSGinaExports.h>
#include <shlobj.h>
#include <shlobjp.h>    // for SHTDN_NONE


static MSGINAAPI LONG ShellGetUserList (BOOL fRemoveGuest, DWORD *pdwUserCount, void* *pUserList)
{
    return 0;
}

static MSGINAAPI BOOL ShellIsSingleUserNoPassword (WCHAR *pwszUsername, WCHAR *pwszDomain)
{
    return FALSE;
}

static MSGINAAPI BOOL ShellIsFriendlyUIActive (void)
{
    return FALSE;
}

static MSGINAAPI BOOL ShellIsMultipleUsersEnabled (void)
{
    return FALSE;
}

static MSGINAAPI BOOL ShellIsRemoteConnectionsEnabled (void)
{
    return FALSE;
}

static MSGINAAPI BOOL ShellEnableFriendlyUI (BOOL fEnable)
{
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
}

static MSGINAAPI BOOL ShellEnableMultipleUsers (BOOL fEnable)
{
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
}

static MSGINAAPI BOOL ShellEnableRemoteConnections (BOOL fEnable)
{
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
}

static MSGINAAPI DWORD ShellTurnOffDialog (HWND hwndParent)
{
    return SHTDN_NONE;
}

static MSGINAAPI int ShellACPIPowerButtonPressed (void *pWlxContext, UINT uiEventType, BOOL fLocked)
{
    return -1;
}

static MSGINAAPI BOOL ShellIsSuspendAllowed (void)
{
    return FALSE;
}

static MSGINAAPI void ShellStatusHostBegin (UINT uiStartType)
{
}

static MSGINAAPI void ShellStatusHostEnd (UINT uiEndType)
{
}

static MSGINAAPI void ShellStatusHostShuttingDown (void)
{
}

static MSGINAAPI BOOL ShellSwitchWhenInteractiveReady (SWITCHTYPE eSwitchType, void *pWlxContext)
{
    return FALSE;
}

static MSGINAAPI HRESULT ShellDimScreen (IUnknown* *ppIUnknown, HWND* phwndDimmed)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static MSGINAAPI void ShellInstallAccountFilterData (void)
{
}

static MSGINAAPI DWORD ShellSwitchUser (BOOL fWait)
{
    return ERROR_PROC_NOT_FOUND;
}

static MSGINAAPI int ShellIsUserInteractiveLogonAllowed (const WCHAR *pwszUsername)
{
    return -1;
}

static MSGINAAPI void ShellNotifyThemeUserChange (USERLOGTYPE eUserLogType, HANDLE hToken)
{
}

static MSGINAAPI DWORD ShellReturnToWelcome (BOOL fUnlock)
{
    return WLX_SAS_ACTION_NONE;
}

static MSGINAAPI void ShellStatusHostPowerEvent (void)
{
}

static MSGINAAPI DWORD ShellStartCredentialServer (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword, DWORD dwTimeout)
{
    return ERROR_PROC_NOT_FOUND;
}

static MSGINAAPI void ShellAcquireLogonMutex (void)
{
}

static MSGINAAPI void ShellReleaseLogonMutex (BOOL fSignalEvent)
{
}

static MSGINAAPI void ShellSignalShutdown (void)
{
}

static MSGINAAPI void ShellStatusHostHide (void)
{
}

static MSGINAAPI void ShellStatusHostShow (void)
{
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(msgina)
{
    DLOENTRY(1,ShellGetUserList)
    DLOENTRY(2,ShellIsFriendlyUIActive)
    DLOENTRY(3,ShellACPIPowerButtonPressed)
    DLOENTRY(4,ShellSwitchUser)
    DLOENTRY(5,ShellIsRemoteConnectionsEnabled)
    DLOENTRY(6,ShellEnableFriendlyUI)
    DLOENTRY(7,ShellEnableMultipleUsers)
    DLOENTRY(8,ShellEnableRemoteConnections)
    DLOENTRY(9,ShellTurnOffDialog)
    DLOENTRY(10,ShellNotifyThemeUserChange)
    DLOENTRY(11,ShellStatusHostBegin)
    DLOENTRY(12,ShellStatusHostEnd)
    DLOENTRY(13,ShellIsSuspendAllowed)  
    DLOENTRY(14,ShellIsSingleUserNoPassword)
    DLOENTRY(15,ShellSwitchWhenInteractiveReady)
    DLOENTRY(16,ShellDimScreen)
    DLOENTRY(17,ShellInstallAccountFilterData)
    DLOENTRY(18,ShellStatusHostShuttingDown)
    DLOENTRY(19,ShellIsUserInteractiveLogonAllowed)
    DLOENTRY(20,ShellIsMultipleUsersEnabled)
    DLOENTRY(21,ShellReturnToWelcome)
    DLOENTRY(22,ShellStatusHostPowerEvent)
    DLOENTRY(23,ShellStartCredentialServer)
    DLOENTRY(24,ShellAcquireLogonMutex)
    DLOENTRY(25,ShellReleaseLogonMutex)
    DLOENTRY(26,ShellSignalShutdown)
    DLOENTRY(27,ShellStatusHostHide)
    DLOENTRY(28,ShellStatusHostShow)
};

DEFINE_ORDINAL_MAP(msgina)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\ntdsbsrv.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>

#define	NTDSBSRV_API	_stdcall
typedef DWORD ERR;

static
void
NTDSBSRV_API
SetNTDSOnlineStatus(
    BOOL fBootedOffNTDS
    )
{
    return;
}

static
HRESULT
NTDSBSRV_API
HrBackupRegister(
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
HRESULT
NTDSBSRV_API
HrBackupUnregister(
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ERR
NTDSBSRV_API
ErrRestoreRegister(
	)
{
    return ERROR_PROC_NOT_FOUND;
}

static
ERR
NTDSBSRV_API
ErrRestoreUnregister(
	)
{
    return ERROR_PROC_NOT_FOUND;
}

static
ERR
NTDSBSRV_API
ErrRecoverAfterRestoreA(
	char * szParametersRoot,
	char * szAnnotation,
        BOOL fInSafeMode
	)
{
    return ERROR_PROC_NOT_FOUND;
}

static
ERR
NTDSBSRV_API
ErrRecoverAfterRestoreW(
	WCHAR * szParametersRoot,
	WCHAR * wszAnnotation,
        BOOL fInSafeMode
	)
{
    return ERROR_PROC_NOT_FOUND;
}

static
ERR
NTDSBSRV_API
ErrGetNewInvocationId(
    IN      DWORD   dwFlags,
    OUT     GUID *  NewId
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
ErrGetBackupUsnFromDatabase(
    IN  JET_DBID      dbid,
    IN  JET_SESID     hiddensesid,
    IN  JET_TABLEID   hiddentblid,
    IN  JET_SESID     datasesid,
    IN  JET_TABLEID   datatblid_arg,
    IN  JET_COLUMNID  usncolid,
    IN  JET_TABLEID   linktblid_arg,
    IN  JET_COLUMNID  linkusncolid,
    IN  BOOL          fDelete,
    OUT USN *         pusnAtBackup
    )
{
    return ERROR_PROC_NOT_FOUND;
}

DWORD
ErrGetBackupUsn(
    IN  JET_DBID      dbid,
    IN  JET_SESID     hiddensesid,
    IN  JET_TABLEID   hiddentblid,
    OUT USN *         pusnAtBackup
    ){
    return ERROR_PROC_NOT_FOUND;
}



//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntdsbsrv)
{
    DLPENTRY(ErrGetBackupUsn)
    DLPENTRY(ErrGetBackupUsnFromDatabase)
    DLPENTRY(ErrGetNewInvocationId)
    DLPENTRY(ErrRecoverAfterRestoreA)
    DLPENTRY(ErrRecoverAfterRestoreW)
    DLPENTRY(ErrRestoreRegister)
    DLPENTRY(ErrRestoreUnregister)
    DLPENTRY(HrBackupRegister)
    DLPENTRY(HrBackupUnregister)
    DLPENTRY(SetNTDSOnlineStatus)
};

DEFINE_PROCNAME_MAP(ntdsbsrv)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\ntdsapi.c ===
#include "dspch.h"
#pragma hdrstop
#define _NTDSAPI_
#include <ntdsapi.h>

//needed
//DsBindA
static
NTDSAPI
DWORD
WINAPI
DsBindA(
    LPCSTR          DomainControllerName,      // in, optional
    LPCSTR          DnsDomainName,             // in, optional
    HANDLE          *phDS)
{
    return ERROR_PROC_NOT_FOUND;
}
//DsBindWithCredA
static
NTDSAPI
DWORD
WINAPI
DsBindWithCredA(
    LPCSTR          DomainControllerName,      // in, optional
    LPCSTR          DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS)
{
    return ERROR_PROC_NOT_FOUND;
}
//DsBindWithSpnA
//DsBindWithSpnW
static
NTDSAPI
DWORD
WINAPI
DsBindWithSpnW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    LPCWSTR         ServicePrincipalName,      // in, optional
    HANDLE          *phDS)
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsBindWithSpnA(
    LPCSTR          DomainControllerName,      // in, optional
    LPCSTR          DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    LPCSTR          ServicePrincipalName,      // in, optional
    HANDLE          *phDS)
{
    return ERROR_PROC_NOT_FOUND;
}
//DsBindWithSpnExW
//DsBindWithSpnExA
static
NTDSAPI
DWORD
WINAPI
DsBindWithSpnExW(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  LPCWSTR ServicePrincipalName,
    IN  DWORD   BindFlags,
    OUT HANDLE  *phDS
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsBindWithSpnExA(
    LPCSTR  DomainControllerName,
    LPCSTR  DnsDomainName,
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPCSTR  ServicePrincipalName,
    DWORD   BindFlags,
    HANDLE  *phDS
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//DsUnBindA
static
NTDSAPI
DWORD
WINAPI
DsUnBindA(
    HANDLE          *phDS)             // in
{
    return ERROR_PROC_NOT_FOUND;
}

//DsCrackNamesA
static
NTDSAPI
DWORD
WINAPI
DsCrackNamesA(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCSTR        *rpNames,           // in
    PDS_NAME_RESULTA    *ppResult)         // out
{
    return ERROR_PROC_NOT_FOUND;
}

//DsFreeNameResultA
static
NTDSAPI
void
WINAPI
DsFreeNameResultA(
    DS_NAME_RESULTA *pResult)          // in
{
}

//DsMakeSpnA
//DsMakeSpnW
static
NTDSAPI
DWORD
WINAPI
DsMakeSpnW(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN LPCWSTR InstanceName,
    IN USHORT InstancePort,
    IN LPCWSTR Referrer,
    IN OUT DWORD *pcSpnLength,
    OUT LPWSTR pszSpn
)
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsMakeSpnA(
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN LPCSTR InstanceName,
    IN USHORT InstancePort,
    IN LPCSTR Referrer,
    IN OUT DWORD *pcSpnLength,
    OUT LPSTR pszSpn
)
{
    return ERROR_PROC_NOT_FOUND;
}
//DsFreeSpnArrayA
//DsFreeSpnArrayW
static
NTDSAPI
void
WINAPI
DsFreeSpnArrayA(
    IN DWORD cSpn,
    IN OUT LPSTR *rpszSpn
    )
{
}

static
NTDSAPI
void
WINAPI
DsFreeSpnArrayW(
    IN DWORD cSpn,
    IN OUT LPWSTR *rpszSpn
    )
{
}

//DsCrackSpnA
//DsCrackSpnW
static
NTDSAPI
DWORD
WINAPI
DsCrackSpnA(
    IN LPCSTR pszSpn,
    IN OUT LPDWORD pcServiceClass,
    OUT LPSTR ServiceClass,
    IN OUT LPDWORD pcServiceName,
    OUT LPSTR ServiceName,
    IN OUT LPDWORD pcInstanceName,
    OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsCrackSpnW(
    IN LPCWSTR pszSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//DsCrackSpn2A
//DsCrackSpn2W
//DsCrackSpn3W
static
NTDSAPI
DWORD
WINAPI
DsCrackSpn2A(
    IN LPCSTR pszSpn,
    IN DWORD cSpn,
    IN OUT LPDWORD pcServiceClass,
    OUT LPSTR ServiceClass,
    IN OUT LPDWORD pcServiceName,
    OUT LPSTR ServiceName,
    IN OUT LPDWORD pcInstanceName,
    OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsCrackSpn2W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsCrackSpn3W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcHostName,
    OUT LPWSTR HostName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pPortNumber,
    IN OUT DWORD *pcDomainName,
    OUT LPWSTR DomainName,
    IN OUT DWORD *pcRealmName,
    OUT LPWSTR RealmName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//DsWriteAccountSpnA
static
NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnA(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCSTR pszAccount,
    IN DWORD cSpn,
    IN LPCSTR *rpszSpn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//DsReplicaSyncA
//DsReplicaSyncW
static
NTDSAPI
DWORD
WINAPI
DsReplicaSyncA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsReplicaSyncW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsReplicaSyncAllA
//DsReplicaSyncAllW
static
NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllA (
    HANDLE				hDS,
    LPCSTR				pszNameContext,
    ULONG				ulFlags,
    BOOL (__stdcall *			pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID				pCallbackData,
    PDS_REPSYNCALL_ERRINFOA **		pErrors
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllW (
    HANDLE				hDS,
    LPCWSTR				pszNameContext,
    ULONG				ulFlags,
    BOOL (__stdcall *			pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    LPVOID				pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **		pErrors
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsReplicaAddA
//DsReplicaAddW
static
NTDSAPI
DWORD
WINAPI
DsReplicaAddA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR SourceDsaDn,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsReplicaAddW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR SourceDsaDn,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsReplicaDelA
//DsReplicaDelW
static
NTDSAPI
DWORD
WINAPI
DsReplicaDelA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaSrc,
    IN ULONG Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsReplicaDelW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaSrc,
    IN ULONG Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsReplicaModifyA
//DsReplicaModifyW
static
NTDSAPI
DWORD
WINAPI
DsReplicaModifyA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsReplicaModifyW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsReplicaUpdateRefsA
//DsReplicaUpdateRefsW
static
NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsMakePasswordCredentialsA
static
NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsA(
    LPCSTR User,
    LPCSTR Domain,
    LPCSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsRemoveDsServerA
//DsRemoveDsServerW
static
NTDSAPI
DWORD
WINAPI
DsRemoveDsServerW(
    HANDLE  hDs,             // in
    LPWSTR  ServerDN,        // in
    LPWSTR  DomainDN,        // in,  optional
    BOOL   *fLastDcInDomain, // out, optional
    BOOL    fCommit          // in
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsRemoveDsServerA(
    HANDLE  hDs,              // in
    LPSTR   ServerDN,         // in
    LPSTR   DomainDN,         // in,  optional
    BOOL   *fLastDcInDomain,  // out, optional
    BOOL    fCommit           // in
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsRemoveDsDomainA
//DsRemoveDsDomainW
static
NTDSAPI
DWORD
WINAPI
DsRemoveDsDomainW(
    HANDLE  hDs,               // in
    LPWSTR  DomainDN           // in
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsRemoveDsDomainA(
    HANDLE  hDs,               // in
    LPSTR   DomainDN           // in
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//DsListSitesA
//DsListSitesW
static
NTDSAPI
DWORD
WINAPI
DsListSitesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppSites)      // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsListSitesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppSites)      // out
{
    return ERROR_PROC_NOT_FOUND;
}
//DsListServersInSiteA
//DsListServersInSiteW
static
NTDSAPI
DWORD
WINAPI
DsListServersInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers)    // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsListServersInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers)    // out
{
    return ERROR_PROC_NOT_FOUND;
}
//DsListDomainsInSiteA
//DsListDomainsInSiteW
static
NTDSAPI
DWORD
WINAPI
DsListDomainsInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppDomains)    // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsListDomainsInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppDomains)    // out
{
    return ERROR_PROC_NOT_FOUND;
}
//DsListServersForDomainInSiteA
//DsListServersForDomainInSiteW
static
NTDSAPI
DWORD
WINAPI
DsListServersForDomainInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              domain,         // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers)    // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsListServersForDomainInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             domain,         // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers)    // out
{
    return ERROR_PROC_NOT_FOUND;
}
//DsListInfoForServerA
//DsListInfoForServerW
static
NTDSAPI
DWORD
WINAPI
DsListInfoForServerA(
    HANDLE              hDs,            // in
    LPCSTR              server,         // in
    PDS_NAME_RESULTA    *ppInfo)       // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsListInfoForServerW(
    HANDLE              hDs,            // in
    LPCWSTR             server,         // in
    PDS_NAME_RESULTW    *ppInfo)       // out
{
    return ERROR_PROC_NOT_FOUND;
}
//DsListRolesA
//DsListRolesW
static
NTDSAPI
DWORD
WINAPI
DsListRolesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppRoles)      // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsListRolesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppRoles)      // out
{
    return ERROR_PROC_NOT_FOUND;
}
//DsMapSchemaGuidsA
//DsMapSchemaGuidsW
//DsFreeSchemaGuidMapA
//DsFreeSchemaGuidMapW
static
NTDSAPI
DWORD
WINAPI
DsMapSchemaGuidsA(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPA     **ppGuidMap)   // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
VOID
WINAPI
DsFreeSchemaGuidMapA(
    PDS_SCHEMA_GUID_MAPA    pGuidMap)      // in
{
}

static
NTDSAPI
DWORD
WINAPI
DsMapSchemaGuidsW(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPW     **ppGuidMap)   // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
VOID
WINAPI
DsFreeSchemaGuidMapW(
    PDS_SCHEMA_GUID_MAPW    pGuidMap)      // in
{
}
//DsGetDomainControllerInfoA
//DsGetDomainControllerInfoW
//DsFreeDomainControllerInfoA
//DsFreeDomainControllerInfoW
static
NTDSAPI
DWORD
WINAPI
DsGetDomainControllerInfoA(
    HANDLE                          hDs,            // in
    LPCSTR                          DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo)      // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsGetDomainControllerInfoW(
    HANDLE                          hDs,            // in
    LPCWSTR                         DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo)      // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
VOID
WINAPI
DsFreeDomainControllerInfoA(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo)        // in
{
}

static
NTDSAPI
VOID
WINAPI
DsFreeDomainControllerInfoW(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo)        // in
{
}

//DsClientMakeSpnForTargetServerA
//DsClientMakeSpnForTargetServerW
static
NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerW(
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    OUT LPWSTR pszSpn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerA(
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    OUT LPSTR pszSpn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//DsServerRegisterSpnA
//DsServerRegisterSpnW
static
NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnA(
    IN DS_SPN_WRITE_OP Operation,
    IN LPCSTR ServiceClass,
    IN LPCSTR UserObjectDN
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnW(
    IN DS_SPN_WRITE_OP Operation,
    IN LPCWSTR ServiceClass,
    IN LPCWSTR UserObjectDN
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsReplicaConsistencyCheck
static
NTDSAPI
DWORD
WINAPI
DsReplicaConsistencyCheck(
    HANDLE          hDS,        // in
    DS_KCC_TASKID   TaskID,     // in
    DWORD           dwFlags)   // in
{
    return ERROR_PROC_NOT_FOUND;
}
    
//DsLogEntry
static
BOOL
DsLogEntry(
    IN DWORD    Flags,
    IN LPSTR    Format,
    ...
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsReplicaGetInfoW
//DsReplicaFreeInfo
//DsReplicaGetInfo2W
static
NTDSAPI
DWORD
WINAPI
DsReplicaGetInfoW(
    HANDLE              hDS,                        // in
    DS_REPL_INFO_TYPE   InfoType,                   // in
    LPCWSTR             pszObject,                  // in
    UUID *              puuidForSourceDsaObjGuid,   // in
    VOID **             ppInfo)                    // out
{
    return ERROR_PROC_NOT_FOUND;
}

// This API is not supported by Windows 2000 clients or Windows 2000 DCs.
static
NTDSAPI
DWORD
WINAPI
DsReplicaGetInfo2W(
    HANDLE              hDS,                        // in
    DS_REPL_INFO_TYPE   InfoType,                   // in
    LPCWSTR             pszObject,                  // in
    UUID *              puuidForSourceDsaObjGuid,   // in
    LPCWSTR             pszAttributeName,           // in
    LPCWSTR             pszValue,                   // in
    DWORD               dwFlags,                    // in
    DWORD               dwEnumerationContext,       // in
    VOID **             ppInfo)                    // out
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
void
WINAPI
DsReplicaFreeInfo(
    DS_REPL_INFO_TYPE   InfoType,   // in
    VOID *              pInfo)     // in
{
}


//DsAddSidHistoryA
//DsAddSidHistoryW
static
NTDSAPI
DWORD
WINAPI
DsAddSidHistoryW(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCWSTR                 SrcDomain,              // in - DNS or NetBIOS
    LPCWSTR                 SrcPrincipal,           // in - SAM account name
    LPCWSTR                 SrcDomainController,    // in, optional
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domain
    LPCWSTR                 DstDomain,              // in - DNS or NetBIOS
    LPCWSTR                 DstPrincipal)          // in - SAM account name
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsAddSidHistoryA(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCSTR                  SrcDomain,              // in - DNS or NetBIOS
    LPCSTR                  SrcPrincipal,           // in - SAM account name
    LPCSTR                  SrcDomainController,    // in, optional
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domain
    LPCSTR                  DstDomain,              // in - DNS or NetBIOS
    LPCSTR                  DstPrincipal)          // in - SAM account name
{
    return ERROR_PROC_NOT_FOUND;
}

//DsInheritSecurityIdentityA
//DsInheritSecurityIdentityW
static
NTDSAPI
DWORD
WINAPI
DsInheritSecurityIdentityW(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCWSTR                 SrcPrincipal,           // in - distinguished name
    LPCWSTR                 DstPrincipal)          // in - distinguished name
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsInheritSecurityIdentityA(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCSTR                  SrcPrincipal,           // in - distinguished name
    LPCSTR                  DstPrincipal)          // in - distinguished name
{
    return ERROR_PROC_NOT_FOUND;
}
//DsUnquoteRdnValueA
static
NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValueA(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCCH    psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPCH     psUnquotedRdnValue
)
{
    return ERROR_PROC_NOT_FOUND;
}
//DsCrackUnquotedMangledRdnA
//DsCrackUnquotedMangledRdnW
static
NTDSAPI
BOOL
WINAPI
DsCrackUnquotedMangledRdnW(
     IN LPCWSTR pszRDN,
     IN DWORD cchRDN,
     OUT OPTIONAL GUID *pGuid,
     OUT OPTIONAL DS_MANGLE_FOR *peDsMangleFor
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
BOOL
WINAPI
DsCrackUnquotedMangledRdnA(
     IN LPCSTR pszRDN,
     IN DWORD cchRDN,
     OUT OPTIONAL GUID *pGuid,
     OUT OPTIONAL DS_MANGLE_FOR *peDsMangleFor
     )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsIsMangledRdnValueA
//DsIsMangledRdnValueW
static
NTDSAPI
BOOL
WINAPI
DsIsMangledRdnValueW(
    LPCWSTR pszRdn,
    DWORD cRdn,
    DS_MANGLE_FOR eDsMangleForDesired
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
BOOL
WINAPI
DsIsMangledRdnValueA(
    LPCSTR pszRdn,
    DWORD cRdn,
    DS_MANGLE_FOR eDsMangleForDesired
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsIsMangledDnA
//DsIsMangledDnW
static
NTDSAPI
BOOL
WINAPI
DsIsMangledDnA(
    LPCSTR pszDn,
    DS_MANGLE_FOR eDsMangleFor
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
BOOL
WINAPI
DsIsMangledDnW(
    LPCWSTR pszDn,
    DS_MANGLE_FOR eDsMangleFor
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsaopExecuteScript
//DsaopPrepareScript
//DsaopBind
//DsaopBindWithCred
//DsaopBindWithSpn
//DsaopUnBind
static
DWORD
DsaopExecuteScript (
    IN  PVOID                  phAsync,
    IN  RPC_BINDING_HANDLE     hRpc,
    IN  DWORD                  cbPassword,
    IN  BYTE                  *pbPassword,
    OUT DWORD                 *dwOutVersion,
    OUT PVOID                  reply
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
DsaopPrepareScript ( 
    IN  PVOID                        phAsync,
    IN  RPC_BINDING_HANDLE           hRpc,
    OUT DWORD                        *dwOutVersion,
    OUT PVOID                        reply
    )
{
    return ERROR_PROC_NOT_FOUND;
}
    
static
DWORD
DsaopBind(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
DsaopBindWithCred(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
DsaopBindWithSpn(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    IN  LPCWSTR ServicePrincipalName,
    OUT RPC_BINDING_HANDLE  *phRpc
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
DsaopUnBind(
    RPC_BINDING_HANDLE  *phRpc
    )
{
    return ERROR_PROC_NOT_FOUND;
}
//DsReplicaVerifyObjectsA
//DsReplicaVerifyObjectsW
static
NTDSAPI
DWORD
WINAPI
DsReplicaVerifyObjectsW(
    HANDLE          hDS,        // in
    LPCWSTR         NameContext,// in
    const UUID *    pUuidDsaSrc,// in
    ULONG           ulOptions)   // in
{
    return ERROR_PROC_NOT_FOUND;
}
    
static
NTDSAPI
DWORD
WINAPI
DsReplicaVerifyObjectsA(
    HANDLE          hDS,        // in
    LPCSTR          NameContext,// in
    const UUID *    pUuidDsaSrc,// in
    ULONG           ulOptions)   // in
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsGetSpnA(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    OUT LPSTR **prpszSpn
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsGetSpnW(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCWSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    OUT LPWSTR **prpszSpn
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
NTDSAPI
DWORD
WINAPI
DsQuoteRdnValueW(
    IN     DWORD    cUnquotedRdnValueLength,
    IN     LPCWCH   psUnquotedRdnValue,
    IN OUT DWORD    *pcQuotedRdnValueLength,
    OUT    LPWCH    psQuotedRdnValue
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsQuoteRdnValueA(
    IN     DWORD    cUnquotedRdnValueLength,
    IN     LPCCH    psUnquotedRdnValue,
    IN OUT DWORD    *pcQuotedRdnValueLength,
    OUT    LPCH     psQuotedRdnValue
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsBindW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    HANDLE          *phDS
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsBindWithCredW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsCrackNamesW(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult           // out
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
void
WINAPI
DsFreeNameResultW(
    PDS_NAME_RESULTW      pResult            // in
    )
{
    return;
}

static
NTDSAPI
VOID
WINAPI
DsFreePasswordCredentials(
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity
    )
{
    return;
}

static
NTDSAPI
DWORD
WINAPI
DsGetRdnW(
    IN OUT LPCWCH   *ppDN,
    IN OUT DWORD    *pcDN,
    OUT    LPCWCH   *ppKey,
    OUT    DWORD    *pcKey,
    OUT    LPCWCH   *ppVal,
    OUT    DWORD    *pcVal
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsW(
    LPCWSTR User,
    LPCWSTR Domain,
    LPCWSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsUnBindW(
    HANDLE          *phDS               // in
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValueW(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCWCH   psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPWCH    psUnquotedRdnValue
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnW(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCWSTR pszAccount,
    IN DWORD cSpn,
    IN LPCWSTR *rpszSpn
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntdsapi)
{
    DLPENTRY(DsAddSidHistoryA)
    DLPENTRY(DsAddSidHistoryW)

    DLPENTRY(DsBindA)
    DLPENTRY(DsBindW)
    DLPENTRY(DsBindWithCredA)
    DLPENTRY(DsBindWithCredW)
    DLPENTRY(DsBindWithSpnA)
    DLPENTRY(DsBindWithSpnExA)
    DLPENTRY(DsBindWithSpnExW)
    DLPENTRY(DsBindWithSpnW)
    DLPENTRY(DsClientMakeSpnForTargetServerA)
    DLPENTRY(DsClientMakeSpnForTargetServerW)

    DLPENTRY(DsCrackNamesA)
    DLPENTRY(DsCrackNamesW)
    DLPENTRY(DsCrackSpn2A)
    DLPENTRY(DsCrackSpn2W)
    DLPENTRY(DsCrackSpn3W)
    DLPENTRY(DsCrackSpnA)
    DLPENTRY(DsCrackSpnW)
    DLPENTRY(DsCrackUnquotedMangledRdnA)
    DLPENTRY(DsCrackUnquotedMangledRdnW)

    DLPENTRY(DsFreeDomainControllerInfoA)
    DLPENTRY(DsFreeDomainControllerInfoW)
    DLPENTRY(DsFreeNameResultA)
    DLPENTRY(DsFreeNameResultW)
    DLPENTRY(DsFreePasswordCredentials)
    DLPENTRY(DsFreeSchemaGuidMapA)
    DLPENTRY(DsFreeSchemaGuidMapW)

    DLPENTRY(DsFreeSpnArrayA)
    DLPENTRY(DsFreeSpnArrayW)

    DLPENTRY(DsGetDomainControllerInfoA)
    DLPENTRY(DsGetDomainControllerInfoW)
    DLPENTRY(DsGetRdnW)
    DLPENTRY(DsGetSpnA)
    DLPENTRY(DsGetSpnW)

    DLPENTRY(DsInheritSecurityIdentityA)
    DLPENTRY(DsInheritSecurityIdentityW)

    DLPENTRY(DsIsMangledDnA)
    DLPENTRY(DsIsMangledDnW)
    DLPENTRY(DsIsMangledRdnValueA)
    DLPENTRY(DsIsMangledRdnValueW)

    DLPENTRY(DsListDomainsInSiteA)
    DLPENTRY(DsListDomainsInSiteW)
    DLPENTRY(DsListInfoForServerA)
    DLPENTRY(DsListInfoForServerW)
    DLPENTRY(DsListRolesA)
    DLPENTRY(DsListRolesW)
    DLPENTRY(DsListServersForDomainInSiteA)
    DLPENTRY(DsListServersForDomainInSiteW)
    DLPENTRY(DsListServersInSiteA)
    DLPENTRY(DsListServersInSiteW)
    DLPENTRY(DsListSitesA)
    DLPENTRY(DsListSitesW)

    DLPENTRY(DsLogEntry)

    DLPENTRY(DsMakePasswordCredentialsA)
    DLPENTRY(DsMakePasswordCredentialsW)
    DLPENTRY(DsMakeSpnA)
    DLPENTRY(DsMakeSpnW)

    DLPENTRY(DsMapSchemaGuidsA)
    DLPENTRY(DsMapSchemaGuidsW)

    DLPENTRY(DsQuoteRdnValueA)
    DLPENTRY(DsQuoteRdnValueW)

    DLPENTRY(DsRemoveDsDomainA)
    DLPENTRY(DsRemoveDsDomainW)
    DLPENTRY(DsRemoveDsServerA)
    DLPENTRY(DsRemoveDsServerW)

    DLPENTRY(DsReplicaAddA)
    DLPENTRY(DsReplicaAddW)
    DLPENTRY(DsReplicaConsistencyCheck)
    DLPENTRY(DsReplicaDelA)
    DLPENTRY(DsReplicaDelW)
    DLPENTRY(DsReplicaFreeInfo)
    DLPENTRY(DsReplicaGetInfo2W)
    DLPENTRY(DsReplicaGetInfoW)
    DLPENTRY(DsReplicaModifyA)
    DLPENTRY(DsReplicaModifyW)
    DLPENTRY(DsReplicaSyncA)
    DLPENTRY(DsReplicaSyncAllA)
    DLPENTRY(DsReplicaSyncAllW)
    DLPENTRY(DsReplicaSyncW)
    DLPENTRY(DsReplicaUpdateRefsA)
    DLPENTRY(DsReplicaUpdateRefsW)
    DLPENTRY(DsReplicaVerifyObjectsA)
    DLPENTRY(DsReplicaVerifyObjectsW)

    DLPENTRY(DsServerRegisterSpnA)
    DLPENTRY(DsServerRegisterSpnW)

    DLPENTRY(DsUnBindA)
    DLPENTRY(DsUnBindW)

    DLPENTRY(DsUnquoteRdnValueA)
    DLPENTRY(DsUnquoteRdnValueW)

    DLPENTRY(DsWriteAccountSpnA)
    DLPENTRY(DsWriteAccountSpnW)

    DLPENTRY(DsaopBind)
    DLPENTRY(DsaopBindWithCred)
    DLPENTRY(DsaopBindWithSpn)
    DLPENTRY(DsaopExecuteScript)
    DLPENTRY(DsaopPrepareScript)
    DLPENTRY(DsaopUnBind)
};

DEFINE_PROCNAME_MAP(ntdsapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\netrap.c ===
#include "dspch.h"
#pragma hdrstop


#define LPDESC                 LPVOID
#define NET_API_STATUS         DWORD
#define RAP_TRANSMISSION_MODE  DWORD
#define RAP_CONVERSION_MODE    DWORD


static
DWORD
RapArrayLength(
    IN LPDESC Descriptor,
    IN OUT LPDESC * UpdatedDescriptorPtr,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    )
{
    return 0;
}

static
DWORD
RapAsciiToDecimal(
   IN OUT LPDESC *Number
   )
{
    return 0;
}

static
DWORD
RapAuxDataCount(
    IN LPBYTE Buffer,
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return 0Xffffffff;
}

static
DWORD
RapAuxDataCountOffset(
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return 0xffffffff;
}

static
NET_API_STATUS
RapConvertSingleEntry(
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
RapConvertSingleEntryEx(
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode,
    IN UINT_PTR Bias
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
RapGetFieldSize(
    IN LPDESC TypePointer,
    IN OUT LPDESC * TypePointerAddress,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    )
{
    return 0;
}

static
BOOL
RapIsValidDescriptorSmb(
    IN LPDESC Desc
    )
{
    //
    // Since this function is always used in assertions, just return TRUE
    // so they don't fail when the delayload fails under low memory
    // conditions.  In that case, we merely lose out on a DBG-only validation.
    //

    return TRUE;
}

static
LPDESC
RapParmNumDescriptor(
    IN LPDESC Descriptor,
    IN DWORD ParmNum,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return NULL;
}

static
DWORD
RapStructureAlignment(
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return 0;
}

static
DWORD
RapStructureSize(
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )
{
    return 0;
}

static
DWORD
RapTotalSize(
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    )
{
    return 0;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(netrap)
{
    DLPENTRY(RapArrayLength)
    DLPENTRY(RapAsciiToDecimal)
    DLPENTRY(RapAuxDataCount)
    DLPENTRY(RapAuxDataCountOffset)
    DLPENTRY(RapConvertSingleEntry)
    DLPENTRY(RapConvertSingleEntryEx)
    DLPENTRY(RapGetFieldSize)
    DLPENTRY(RapIsValidDescriptorSmb)
    DLPENTRY(RapParmNumDescriptor)
    DLPENTRY(RapStructureAlignment)
    DLPENTRY(RapStructureSize)
    DLPENTRY(RapTotalSize)
};

DEFINE_PROCNAME_MAP(netrap)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\ntdsetup.c ===
#include "dspch.h"
#pragma hdrstop

#define PPOLICY_ACCOUNT_DOMAIN_INFO  PVOID

static
DWORD
NtdsPrepareForDsUpgrade(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO NewLocalAccountInfo,
    OUT LPWSTR                     *NewAdminPassword
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntdsetup)
{
    DLPENTRY(NtdsPrepareForDsUpgrade)
};

DEFINE_PROCNAME_MAP(ntdsetup)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\ntdsa.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntdsa.h>
#include <wxlpc.h>
#include <drs.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mappings.h>
#include <dsaapi.h>
#include <dsevent.h>

//
// Notes on stub behavior
//

//
// Whenever possible, STATUS_PROCEDURE_NOT_FOUHD, ERROR_PROC_NOT_FOUND, NULL,
// or FALSE is returned.
//

//
// Some of the functions below require the caller to look at an OUT
// parameter to determine whether the results of the function (in addition
// or independent of the return value).  Since these are private functions
// there is no need in shipping code to check for the validity of the OUT
// parameter (typically a pointer).  These values should always be present
// in RTM versions.
//

//
// Some functions don't return a status and were designed to never fail
// (for example, functions that effectively do a table lookup).  For these
// functions there is no reasonable return value.  However, this is not
// a practical issue since these API's would only be called after the DS
// initialized which means that API would have already been "snapped" in via
// GetProcAddress().
//
// Of course, it is possible to rewrite these routines to return errors,
// however, as above, this will have no practical effect.
//

#define NTDSA_STUB_NO_REASONABLE_DEFAULT 0xFFFFFFFF

//
// Most Dir functions return 0 on success and simply a non zero on failure.
// The error space can be from the DB layer or sometimes from the Jet layer.
// To extract the real error, the caller looks at an OUT parameter.  In
// these cases we return a standard failure value.
//

#define NTDSA_STUB_GENERAL_FAILURE      (!0)

static
NTSTATUS
DsWaitUntilDelayedStartupIsDone(void)
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
void
DsInitializeCritSecs(void)
{
}

static
BOOL
DsIsBeingBackSynced()
{
    return FALSE;
}

static
ULONG
DirBind (
    BINDARG               * pBindArg,    /* binding credentials            */
    BINDRES              ** ppBindRes    /* binding results                */
    )
{
    *ppBindRes = NULL;
    return systemError;
}

static
ULONG
DirUnBind (
    void
    )
{
    return systemError;
}

static
ULONG
DirCompare(
    COMPAREARG        * pCompareArg, /* Compare argument                   */
    COMPARERES       ** ppCompareRes
    )
{
    *ppCompareRes = NULL;
    return systemError;
}

static
ULONG
DirList(
    LISTARG FAR   * pListArg,
    LISTRES      ** ppListRes

    )
{
    *ppListRes = NULL;
    return systemError;
}

static
VOID
DirTransactControl(
    DirTransactionOption    option)
{
}

static
BOOL
DirPrepareForImpersonate (
        DWORD hClient,
        DWORD hServer,
        void ** ppImpersonateData
    )
{
    return FALSE;
}

static
VOID
DirStopImpersonating (
        DWORD hClient,
        DWORD hServer,
        void * pImpersonateData
        )
{
}

static
ULONG
DirReplicaAdd(
    IN  DSNAME *    pNC,
    IN  DSNAME *    pSourceDsaDN,               OPTIONAL
    IN  DSNAME *    pTransportDN,               OPTIONAL
    IN  LPWSTR      pszSourceDsaAddress,
    IN  LPWSTR      pszSourceDsaDnsDomainName,  OPTIONAL
    IN  REPLTIMES * preptimesSync,              OPTIONAL
    IN  ULONG       ulOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ULONG
DirReplicaModify(
    DSNAME *    pNC,
    UUID *      puuidSourceDRA,
    UUID *      puuidTransportObj,
    LPWSTR      pszSourceDRA,
    REPLTIMES * prtSchedule,
    ULONG       ulReplicaFlags,
    ULONG       ulModifyFields,
    ULONG       ulOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ULONG
DirReplicaDelete(
        DSNAME *pNC,
        LPWSTR pszSourceDRA,
        ULONG ulOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ULONG
DirReplicaSynchronize(
        DSNAME *pNC,
        LPWSTR pszSourceDRA,
        UUID * puuidSourceDRA,
        ULONG ulOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ULONG
DirReplicaReferenceUpdate(
        DSNAME *pNC,
        LPWSTR pszReferencedDRA,
        UUID * puuidReferencedDRA,
        ULONG ulOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ULONG
DirReplicaGetDemoteTarget(
    IN      DSNAME *                        pNC,
    IN OUT  DRS_DEMOTE_TARGET_SEARCH_INFO * pDTSInfo,
    OUT     LPWSTR *                        ppszDemoteTargetDNSName,
    OUT     DSNAME **                       ppDemoteTargetDSADN
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ULONG
DirReplicaDemote(
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN,
    IN  ULONG       ulOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
DirReplicaSetCredentials(
    IN HANDLE ClientToken,
    IN WCHAR *User,
    IN WCHAR *Domain,
    IN WCHAR *Password,
    IN ULONG  PasswordLength   // number of characters NOT including terminating
                               // NULL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
void *
THReAlloc(
    void *p,
    DWORD size
    )
{
    return NULL;
}

static
BOOL THVerifyCount(
    unsigned count
    )  /* Returns TRUE if thread has exactly   */
{
    return FALSE;
}

static
LPSTR
THGetErrorString()
{
    return NULL;
}

static
VOID
SampSetLsa(
   BOOLEAN DsaFlag
)
{
}

static
ULONG
SampGetSamAttrIdByName(
    SAMP_OBJECT_TYPE ObjectType,
    UNICODE_STRING AttributeIdentifier)
{
    return DS_ATTRIBUTE_UNKNOWN;
}

static
BOOLEAN
SampDoesDomainExist(
    IN PDSNAME pDN
    )
{
    return FALSE;
}

static 
NTSTATUS
SampDsControl(
    IN PSAMP_DS_CTRL_OP RequestedOp,
    OUT PVOID *Result
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOL
DoLogEvent(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
        MessageId midEvent, int iIncludeName,
        char *arg1, char *arg2, char *arg3, char *arg4,
        char *arg5, char *arg6, char *arg7, char *arg8,
        DWORD cbData, VOID * pvData)
{
    return FALSE;
}

static
VOID
DoLogEventAndTrace(PLOG_PARAM_BLOCK LogBlock)
{
}

static
BOOL
DoLogOverride(DWORD file, ULONG sev)
{
    return FALSE;
}

static
void __fastcall
DoLogUnhandledError(unsigned long ulID, int iErr, int iIncludeName)
{
}

static
VOID
DsTraceEvent(
    IN MessageId Event,
    IN DWORD    WmiEventType,
    IN DWORD    TraceGuid,
    IN PEVENT_TRACE_HEADER TraceHeader,
    IN DWORD    ClientID,
    IN PWCHAR    Arg1,
    IN PWCHAR    Arg2,
    IN PWCHAR    Arg3,
    IN PWCHAR    Arg4,
    IN PWCHAR    Arg5,
    IN PWCHAR    Arg6,
    IN PWCHAR    Arg7,
    IN PWCHAR    Arg8
    )
{
}

static
void
DoAssert( char *x,
          DWORD y,
          char *z )
{
}

static
void
DebPrint( USHORT a,
          UCHAR *b,
          CHAR *c,
          unsigned d, ... )
{
}

USHORT
DebugTest( USHORT a,
           CHAR *b )
{
    return 0;
}

static
int
NameMatchedStringNameOnly(const DSNAME *pDN1, const DSNAME *pDN2)
{
    return FALSE;
}

static
unsigned
NamePrefix(const DSNAME *pPrefix,
           const DSNAME *pDN)
{
    return FALSE;
}

static
unsigned
AttrTypeToKey(ATTRTYP attrtyp, WCHAR *pOutBuf)
{
    return 0;
}

static
NTSTATUS
CrackSingleName(
    DWORD       formatOffered,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       dwFlags,                // DS_NAME_FLAG mask
    WCHAR       *pNameIn,               // name to crack
    DWORD       formatDesired,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       *pccDnsDomain,          // char count of following argument
    WCHAR       *pDnsDomain,            // buffer for DNS domain name
    DWORD       *pccNameOut,            // char count of following argument
    WCHAR       *pNameOut,              // buffer for formatted name
    DWORD       *pErr)                 // one of DS_NAME_ERROR in ntdsapi.h
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
unsigned
CountNameParts(
            const DSNAME *pName,
            unsigned *pCount
            )
{
    return 0;
}

static
DWORD
DSNAMEToHashKeyExternal(const DSNAME *pDN)
{
    return 0;
}

static
CHAR*
DSNAMEToMappedStrExternal(const DSNAME *pDN)
{
    return NULL;
}

static
DWORD
DSStrToHashKeyExternal(const WCHAR *pStr, int cchLen)
{
    return 0;
}

static
CHAR *
DSStrToMappedStrExternal(const WCHAR *pStr, int cchMaxStr)
{
    return NULL;
}

static
PDSNAME
GetConfigDsName(
    IN  PWCHAR  wszParam
    )
{
    return NULL;
}

static
BOOL
MtxSame(UNALIGNED MTX_ADDR *pmtx1, UNALIGNED MTX_ADDR *pmtx2)
{
    return FALSE;
}

static
void DbgPrintErrorInfo()
{
    return;
}

static
NTSTATUS
GetConfigurationNamesList(
    DWORD       which,
    DWORD       dwFlags,
    DWORD *     pcbNames,
    DSNAME **   padsNames)
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
GetDnsRootAlias(
    WCHAR * pDnsRootAlias,
    WCHAR * pRootDnsRootAlias)
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
VOID
DsaDisableUpdates(
    VOID
    )
{
}

static VOID
DsaEnableUpdates(
    VOID
    )
{
}

static VOID
DsaSetInstallCallback(
    IN DSA_CALLBACK_STATUS_TYPE        pfnUpdateStatus,
    IN DSA_CALLBACK_ERROR_TYPE         pfnErrorStatus,
    IN DSA_CALLBACK_CANCEL_TYPE        pfnCancelOperation,
    IN HANDLE                          ClientToken
    )
{
}

static LPWSTR
TransportAddrFromMtxAddr(
    IN  MTX_ADDR *  pmtx
    )
{
    return NULL;
}

static
MTX_ADDR *
MtxAddrFromTransportAddr(
    IN  LPWSTR    psz
    )
{
    return NULL;
}

static
LPWSTR
GuidBasedDNSNameFromDSName(
    IN  DSNAME *  pDN
    )
{
    return NULL;
}

LPCWSTR
MapSpnServiceClass(WCHAR *a)
{
    return NULL;
}

static
NTSTATUS
MatchCrossRefBySid(
   IN PSID           SidToMatch,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
MatchCrossRefByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
MatchDomainDnByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
MatchDomainDnByDnsName(
   IN LPWSTR         DnsName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
FindNetbiosDomainName(
   IN DSNAME*        DomainDsName,
   OUT LPWSTR        NetbiosName OPTIONAL,
   IN OUT PULONG     NetbiosNameLen
   )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
DSNAME *
DsGetDefaultObjCategory(
    IN  ATTRTYP objClass
    )
{
    return NULL;
}

static BOOL
IsStringGuid(
    WCHAR       *pwszGuid,
    GUID        *pGuid
    )
{
    return FALSE;
}

static
VOID
DsFreeServersAndSitesForNetLogon(
    SERVERSITEPAIR *         paServerSites
    )
{
}

static
NTSTATUS
DsGetServersAndSitesForNetLogon(
    IN   WCHAR *         pNCDNS,
    OUT  SERVERSITEPAIR ** ppaRes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
int
__cdecl
DsaExeStartRoutine(int argc, char *argv[])
{
    return 0;
}

static
unsigned
AppendRDN(
    DSNAME *pDNBase,
    DSNAME *pDNNew,
    ULONG ulBufSize,
    WCHAR *pRDNVal,
    ULONG RDNlen,
    ATTRTYP AttId
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirAddEntry (
    ADDARG        * pAddArg,
    ADDRES       ** ppAddRes
    )
{
    *ppAddRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
NTSTATUS
DirErrorToNtStatus(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
DWORD
DirErrorToWinError(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
ULONG
DirFindEntry(
    FINDARG    *pFindArg,
    FINDRES    ** ppFindRes
)
{
    *ppFindRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
DWORD
DirGetDomainHandle(
    DSNAME *pDomainDN
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirModifyDN(
    MODIFYDNARG    * pModifyDNArg,
    MODIFYDNRES   ** ppModifyDNRes
    )
{
    *ppModifyDNRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirModifyEntry (
    MODIFYARG  * pModifyArg,
    MODIFYRES ** ppModifyRes
    )
{
    *ppModifyRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirNotifyRegister(
    SEARCHARG *pSearchArg,
    NOTIFYARG *pNotifyArg,
    NOTIFYRES **ppNotifyRes
    )
{
    *ppNotifyRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}


static
ULONG
DirNotifyUnRegister(
    DWORD hServer,
    NOTIFYRES **pNotifyRes
    )
{
    *pNotifyRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirOperationControl(
    OPARG   * pOpArg,
    OPRES  ** ppOpRes
    )
{
    *ppOpRes= NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirProtectEntry(
    IN DSNAME *pObj
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirRead (
    READARG FAR   * pReadArg,
    READRES      ** ppReadRes
    )
{
    *ppReadRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirRemoveEntry (
    REMOVEARG  * pRemoveArg,
    REMOVERES ** ppRemoveRes
    )
{
    *ppRemoveRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
DirSearch (
    SEARCHARG     * pSearchArg,
    SEARCHRES    ** ppSearchRes
    )
{
    *ppSearchRes = NULL;
    return NTDSA_STUB_GENERAL_FAILURE;
}


static
NTSTATUS
DsChangeBootOptions(
    WX_AUTH_TYPE    BootOption,
    ULONG           Flags,
    PVOID           NewKey,
    ULONG           cbNewKey
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOL
DsCheckConstraint(
        IN ATTRTYP  attID,
        IN ATTRVAL *pAttVal,
        IN BOOL     fVerifyAsRDN
        )
{
    return FALSE;
}

static
WX_AUTH_TYPE
DsGetBootOptions(
    VOID
    )
{
    return WxNone;
}

static
NTSTATUS
DsInitialize(
   ULONG Flags,
   IN  PDS_INSTALL_PARAM   InParams  OPTIONAL,
   OUT PDS_INSTALL_RESULT  OutParams OPTIONAL
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
DsPrepareUninitialize(
    VOID
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
DsUninitialize(
    BOOL fExternalOnly
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
ENTINF *
GCVerifyCacheLookup(
    DSNAME *pDSName
    )
{
    return NULL;
}

static
DWORD
GetConfigParam(
    char * parameter,
    void * value,
    DWORD dwSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
GetConfigParamAllocW(
    IN  PWCHAR  parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
GetConfigParamW(
    WCHAR * parameter,
    void * value,
    DWORD dwSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTSTATUS
GetConfigurationInfo(
    DWORD       which,
    DWORD       *pcbSize,
    VOID        *pBuff)
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
GetConfigurationName(
    DWORD       which,
    DWORD       *pcbName,
    DSNAME      *pName
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
unsigned
GetRDNInfoExternal(
    const DSNAME *pDN,
    WCHAR *pRDNVal,
    ULONG *pRDNlen,
    ATTRTYP *pRDNtype
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
DWORD
ImpersonateAnyClient(
    void
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID
InitCommarg(
    COMMARG *pCommArg
    )
{
    return;
}

static
int
NameMatched(
    const DSNAME *pDN1,
    const DSNAME *pDN2
    )
{
    return !0;
}

static
unsigned
QuoteRDNValue(
    const WCHAR * pVal,
    unsigned ccVal,
    WCHAR * pQuote,
    unsigned ccQuoteBufMax
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
BOOLEAN
SampAddLoopbackTask(
    IN PVOID NotifyInfo
    )
{
    return FALSE;
}

static
BOOL
SampAmIGC()
{
    return FALSE;
}


static
NTSTATUS
SampComputeGroupType(
    ULONG  ObjectClass,
    ULONG  GroupType,
    NT4_GROUP_TYPE *pNT4GroupType,
    NT5_GROUP_TYPE *pNT5GroupType,
    BOOLEAN        *pSecurityEnabled
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


static
ULONG
SampDeriveMostBasicDsClass(
    ULONG   DerivedClass
    )
{
    return DerivedClass;
}

static
ULONG
SampDsAttrFromSamAttr(
    SAMP_OBJECT_TYPE    ObjectType,
    ULONG               SamAttr
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}


static
ULONG
SampDsClassFromSamObjectType(
    ULONG SamObjectType
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}


static
BOOL
SampExistsDsLoopback(
    DSNAME  **ppLoopbackName
    )
{
    return FALSE;
}


static
BOOL
SampExistsDsTransaction()
{
    return FALSE;
}

static
NTSTATUS
SampGCLookupNames(
    IN  ULONG           cNames,
    IN  UNICODE_STRING *rNames,
    OUT ENTINF         **rEntInf
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}



static
NTSTATUS
SampGCLookupSids(
    IN  ULONG         cSid,
    IN  PSID         *rpSid,
    OUT PDS_NAME_RESULTW *Results
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetAccountCounts(
        DSNAME * DomainObjectName,
        BOOLEAN  GetApproximateCount,
        int    * UserCount,
        int    * GroupCount,
        int    * AliasCount
        )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetClassAttribute(
     IN     ULONG    ClassId,
     IN     ULONG    Attribute,
     OUT    PULONG   attLen,
     OUT    PVOID    pattVal
     )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetDisplayEnumerationIndex (
      IN    DSNAME      *DomainName,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING Prefix,
      OUT   PULONG      Index,
      OUT   PRESTART    *RestartToReturn
      )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


static
ULONG
SampGetDsAttrIdByName(
    UNICODE_STRING AttributeIdentifier
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}

static
VOID
SampGetEnterpriseSidList(
   IN   PULONG pcSids,
   IN OPTIONAL PSID * rgSids
   )
{
    *pcSids = 0;
    if (rgSids) {
        *rgSids = NULL;
    }
    return;
}


static
NTSTATUS
SampGetGroupsForToken(
    IN  DSNAME * pObjName,
    IN  ULONG    Flags,
    OUT ULONG   *pcSids,
    OUT PSID    **prpSids
   )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
VOID
SampGetLoopbackObjectClassId(
    PULONG  ClassId
    )
{
    *ClassId = NTDSA_STUB_NO_REASONABLE_DEFAULT;
    return;
}

static
NTSTATUS
SampGetMemberships(
    IN  PDSNAME     *rgObjNames,
    IN  ULONG       cObjNames,
    IN  OPTIONAL    DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    OUT ULONG       *pcDsNames,
    OUT PDSNAME     **prpDsNames,
    OUT PULONG      *Attributes OPTIONAL,
    OUT PULONG      pcSidHistory OPTIONAL,
    OUT PSID        **rgSidHistory OPTIONAL
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetQDIRestart(
    IN PDSNAME  DomainName,
    IN DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN ULONG    LastObjectDNT,
    OUT PRESTART *ppRestart
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampGetServerRoleFromFSMO(
   DOMAIN_SERVER_ROLE *ServerRole
   )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOLEAN
SampIsSecureLdapConnection(
    VOID
    )
{
    return FALSE;
}

static
BOOL
SampIsWriteLockHeldByDs()
{
    return FALSE;
}

static
NTSTATUS
SampMaybeBeginDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL ReadOrWrite
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampMaybeEndDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL CommitOrAbort
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SampNetlogonPing(
    IN  ULONG           DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT PBOOLEAN        AccountExists,
    OUT PULONG          UserAccountControl
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
ULONG
SampSamAttrFromDsAttr(
    SAMP_OBJECT_TYPE    ObjectType,
    ULONG DsAttr
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}

static
ULONG
SampSamObjectTypeFromDsClass(
    ULONG DsClass
    )
{
    return NTDSA_STUB_NO_REASONABLE_DEFAULT;
}

static
VOID
SampSetDsa(
   BOOLEAN DsaFlag
   )
{
    return;
}


static
NTSTATUS
SampSetIndexRanges(
    ULONG   IndexTypeToUse,
    ULONG   LowLimitLength1,
    PVOID   LowLimit1,
    ULONG   LowLimitLength2,
    PVOID   LowLimit2,
    ULONG   HighLimitLength1,
    PVOID   HighLimit1,
    ULONG   HighLimitLength2,
    PVOID   HighLimit2,
    BOOL    RootOfSearchIsNcHead
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


static
VOID
SampSetSam(
    IN BOOLEAN fSAM
    )
{
    return;
}


static
VOID
SampSignalStart(
        VOID
        )
{
    return;
}

static
ULONG
SampVerifySids(
    ULONG           cSid,
    PSID            *rpSid,
    DSNAME         ***prpDSName
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
void *
THAlloc(
    DWORD size
    )
{
    return NULL;
}

static
VOID
THClearErrors()
{
    return;
}

static
ULONG
THCreate(
    DWORD x
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
ULONG
THDestroy(
    void
    )
{
    return NTDSA_STUB_GENERAL_FAILURE;
}

static
void
THFree(
    void *buff
    )
{
    return;
}

static
BOOL
THQuery(
    void
    )
{
    return FALSE;
}

static
VOID
THRestore(
    PVOID x
    )
{
    return;
}

static
PVOID
THSave()
{
    return NULL;
}

static
DWORD
TrimDSNameBy(
    DSNAME *pDNSrc,
    ULONG cava,
    DSNAME *pDNDst
    )
{
    return 1;
}

static
VOID
UnImpersonateAnyClient(
    void
    )
{
    return;
}

static
VOID
UpdateDSPerfStats(
    IN DWORD        dwStat,
    IN DWORD        dwOperation,
    IN DWORD        dwChange
    )
{
    return;
}


static
BOOL
IsMangledRDNExternal(
    WCHAR * pszRDN,
    ULONG   cchRDN,
    PULONG  pcchUnMangled OPTIONAL
    )
{
    return FALSE;
}

static
ULONG
DBDsReplBackupPrepare()
{
    return 0;
}

static
DWORD DsUpdateOnPDC(BOOL fRootDomain)
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntdsa)
{
    DLPENTRY(AppendRDN)
    DLPENTRY(AttrTypeToKey)
    DLPENTRY(CountNameParts)
    DLPENTRY(CrackSingleName)

    DLPENTRY(DBDsReplBackupPrepare)
    DLPENTRY(DSNAMEToHashKeyExternal)
    DLPENTRY(DSNAMEToMappedStrExternal)
    DLPENTRY(DSStrToHashKeyExternal)
    DLPENTRY(DSStrToMappedStrExternal)
    
    DLPENTRY(DbgPrintErrorInfo)
    DLPENTRY(DebPrint)
    DLPENTRY(DebugTest)

    DLPENTRY(DirAddEntry)
    DLPENTRY(DirBind)
    DLPENTRY(DirCompare)
    DLPENTRY(DirErrorToNtStatus)
    DLPENTRY(DirErrorToWinError)
    DLPENTRY(DirFindEntry)
    DLPENTRY(DirGetDomainHandle)
    DLPENTRY(DirList)
    DLPENTRY(DirModifyDN)
    DLPENTRY(DirModifyEntry)
    DLPENTRY(DirNotifyRegister)
    DLPENTRY(DirNotifyUnRegister)
    DLPENTRY(DirOperationControl)
    DLPENTRY(DirPrepareForImpersonate)
    DLPENTRY(DirProtectEntry)
    DLPENTRY(DirRead)
    DLPENTRY(DirRemoveEntry)
    DLPENTRY(DirReplicaAdd)
    DLPENTRY(DirReplicaDelete)
    DLPENTRY(DirReplicaDemote)
    DLPENTRY(DirReplicaGetDemoteTarget)
    DLPENTRY(DirReplicaModify)
    DLPENTRY(DirReplicaReferenceUpdate)
    DLPENTRY(DirReplicaSetCredentials)
    DLPENTRY(DirReplicaSynchronize)
    DLPENTRY(DirSearch)
    DLPENTRY(DirStopImpersonating)
    DLPENTRY(DirTransactControl)
    DLPENTRY(DirUnBind)

    DLPENTRY(DoAssert)
    DLPENTRY(DoLogEvent)
    DLPENTRY(DoLogEventAndTrace)
    DLPENTRY(DoLogOverride)
    DLPENTRY(DoLogUnhandledError)

    DLPENTRY(DsChangeBootOptions)
    DLPENTRY(DsCheckConstraint)
    DLPENTRY(DsFreeServersAndSitesForNetLogon)
    DLPENTRY(DsGetBootOptions)
    DLPENTRY(DsGetDefaultObjCategory)
    DLPENTRY(DsGetServersAndSitesForNetLogon)
    DLPENTRY(DsInitialize)
    DLPENTRY(DsInitializeCritSecs)
    DLPENTRY(DsIsBeingBackSynced)
    DLPENTRY(DsPrepareUninitialize)
    DLPENTRY(DsTraceEvent)
    DLPENTRY(DsUninitialize)
    DLPENTRY(DsUpdateOnPDC)
    DLPENTRY(DsWaitUntilDelayedStartupIsDone)

    DLPENTRY(DsaDisableUpdates)
    DLPENTRY(DsaEnableUpdates)
    DLPENTRY(DsaExeStartRoutine)
    DLPENTRY(DsaSetInstallCallback)

    DLPENTRY(FindNetbiosDomainName)
    DLPENTRY(GCVerifyCacheLookup)

    DLPENTRY(GetConfigDsName)
    DLPENTRY(GetConfigParam)
    DLPENTRY(GetConfigParamAllocW)
    DLPENTRY(GetConfigParamW)
    DLPENTRY(GetConfigurationInfo)
    DLPENTRY(GetConfigurationName)
    DLPENTRY(GetConfigurationNamesList)
    DLPENTRY(GetDnsRootAlias)
    DLPENTRY(GetRDNInfoExternal)
    DLPENTRY(GuidBasedDNSNameFromDSName)

    DLPENTRY(ImpersonateAnyClient)
    DLPENTRY(InitCommarg)
    DLPENTRY(IsMangledRDNExternal)
    DLPENTRY(IsStringGuid)

    DLPENTRY(MapSpnServiceClass)
    DLPENTRY(MatchCrossRefByNetbiosName)
    DLPENTRY(MatchCrossRefBySid)
    DLPENTRY(MatchDomainDnByDnsName)
    DLPENTRY(MatchDomainDnByNetbiosName)
    DLPENTRY(MtxAddrFromTransportAddr)
    DLPENTRY(MtxSame)

    DLPENTRY(NameMatched)
    DLPENTRY(NameMatchedStringNameOnly)
    DLPENTRY(NamePrefix)
    DLPENTRY(QuoteRDNValue)

    DLPENTRY(SampAddLoopbackTask)
    DLPENTRY(SampAmIGC)
    DLPENTRY(SampComputeGroupType)
    DLPENTRY(SampDeriveMostBasicDsClass)
    DLPENTRY(SampDoesDomainExist)
    DLPENTRY(SampDsAttrFromSamAttr)
    DLPENTRY(SampDsClassFromSamObjectType)
    DLPENTRY(SampDsControl)
    DLPENTRY(SampExistsDsLoopback)
    DLPENTRY(SampExistsDsTransaction)
    DLPENTRY(SampGCLookupNames)
    DLPENTRY(SampGCLookupSids)
    DLPENTRY(SampGetAccountCounts)
    DLPENTRY(SampGetClassAttribute)
    DLPENTRY(SampGetDisplayEnumerationIndex)
    DLPENTRY(SampGetDsAttrIdByName)
    DLPENTRY(SampGetEnterpriseSidList)
    DLPENTRY(SampGetGroupsForToken)
    DLPENTRY(SampGetLoopbackObjectClassId)
    DLPENTRY(SampGetMemberships)
    DLPENTRY(SampGetQDIRestart)
    DLPENTRY(SampGetSamAttrIdByName)
    DLPENTRY(SampGetServerRoleFromFSMO)
    DLPENTRY(SampIsSecureLdapConnection)
    DLPENTRY(SampIsWriteLockHeldByDs)
    DLPENTRY(SampMaybeBeginDsTransaction)
    DLPENTRY(SampMaybeEndDsTransaction)
    DLPENTRY(SampNetlogonPing)
    DLPENTRY(SampSamAttrFromDsAttr)
    DLPENTRY(SampSamObjectTypeFromDsClass)
    DLPENTRY(SampSetDsa)
    DLPENTRY(SampSetIndexRanges)
    DLPENTRY(SampSetLsa)
    DLPENTRY(SampSetSam)
    DLPENTRY(SampSignalStart)
    DLPENTRY(SampVerifySids)

 
    DLPENTRY(THAlloc)
    DLPENTRY(THClearErrors)
    DLPENTRY(THCreate)
    DLPENTRY(THDestroy)
    DLPENTRY(THFree)
    DLPENTRY(THGetErrorString)
    DLPENTRY(THQuery)
    DLPENTRY(THReAlloc)
    DLPENTRY(THRestore)
    DLPENTRY(THSave)
    DLPENTRY(THVerifyCount)

    DLPENTRY(TransportAddrFromMtxAddr)
    DLPENTRY(TrimDSNameBy)
    DLPENTRY(UnImpersonateAnyClient)
    DLPENTRY(UpdateDSPerfStats)

};

DEFINE_PROCNAME_MAP(ntdsa)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\netapi32.c ===
#include "dspch.h"
#pragma hdrstop

#define _DSGETDCAPI_
#include <dsgetdc.h>
#include <lm.h>
#include <icanon.h>
#include <dsrole.h>
#include <nb30.h>
#include <winsock2.h>
#include <netlibnt.h>

static
DWORD
WINAPI
DsEnumerateDomainTrustsW(
    LPWSTR ServerName,
    ULONG Flags,
    PDS_DOMAIN_TRUSTSW *Domains,
    PULONG DomainCount
    )
{
    *Domains = NULL;
    *DomainCount = 0;
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DsGetDcNameW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DsGetDcNameWithAccountW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID
WINAPI
DsRoleFreeMemory(
    IN PVOID    Buffer
    )
{
    return;
}

static
DWORD
WINAPI
DsRoleGetPrimaryDomainInformation(
    IN LPCWSTR lpServer OPTIONAL,
    IN DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PBYTE *Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DsAddressToSiteNamesW(
    IN LPCWSTR ComputerName,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPWSTR **SiteNames
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DsGetDcSiteCoverageW(
    IN LPCWSTR ServerName,
    OUT PULONG EntryCount,
    OUT LPWSTR **SiteNames
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
I_NetNameCanonicalize(
    IN  LPTSTR  ServerName OPTIONAL,
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
I_NetNameValidate(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetAlertRaiseEx(
    IN LPCWSTR AlertEventName,
    IN LPVOID  VariableInfo,
    IN DWORD   VariableInfoSize,
    IN LPCWSTR ServiceName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetApiBufferAllocate (
    IN  DWORD ByteCount,
    OUT LPVOID *Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetDfsGetClientInfo(
    IN  LPWSTR  DfsEntryPath,
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  ShareName OPTIONAL,
    IN  DWORD   Level,
    OUT LPBYTE*  Buffer)
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetDfsGetInfo(
    IN  LPWSTR  DfsEntryPath,
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  ShareName OPTIONAL,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NTSTATUS
NET_API_FUNCTION
NetEnumerateTrustedDomains (
    IN LPWSTR ServerName OPTIONAL,
    OUT LPWSTR *DomainNames
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetGetDCName (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetGetJoinInformation(
    IN   LPCWSTR                lpServer OPTIONAL,
    OUT  LPWSTR                *lpNameBuffer,
    OUT  PNETSETUP_JOIN_STATUS  BufferType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetJoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDomain,
    IN  LPCWSTR lpAccountOU, OPTIONAL
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fJoinOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetLocalGroupGetMembers(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR LocalGroupName,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetMessageBufferSend (
    IN  LPCWSTR servername OPTIONAL,
    IN  LPCWSTR msgname,
    IN  LPCWSTR fromname,
    IN  LPBYTE  buf,
    IN  DWORD   buflen
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetQueryDisplayInformation(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  DWORD   Level,
    IN  DWORD   Index,
    IN  DWORD   EntriesRequested,
    IN  DWORD   PreferredMaximumLength,
    OUT LPDWORD ReturnedEntryCount,
    OUT PVOID   *SortedBuffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetRemoteComputerSupports(
    IN LPCWSTR UncServerName OPTIONAL,
    IN DWORD OptionsWanted,
    OUT LPDWORD OptionsSupported
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetRenameMachineInDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpNewMachineName OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fRenameOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetServerSetInfo (
    IN  LPWSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD ParmError OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetSessionEnum (
    IN      LPTSTR      servername,
    IN      LPTSTR      clientname,
    IN      LPTSTR      username,
    IN      DWORD       level,
    OUT     LPBYTE      *bufptr,
    IN      DWORD       prefmaxlen,
    OUT     LPDWORD     entriesread,
    OUT     LPDWORD     totalentries,
    IN OUT  LPDWORD     resume_handle
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetShareAdd (
    IN  LMSTR   servername,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetShareDel     (
    IN  LMSTR   servername,
    IN  LMSTR   netname,
    IN  DWORD   reserved
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetShareGetInfo(
    IN  LMSTR   servername,
    IN  LMSTR   netname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetShareSetInfo (
    IN  LMSTR   servername,
    IN  LMSTR   netname,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetUnjoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fUnjoinOptions
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserAdd(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserChangePassword(
    IN LPCWSTR DomainName,
    IN LPCWSTR UserName,
    IN LPCWSTR OldPassword,
    IN LPCWSTR NewPassword
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserDel(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  LPCWSTR UserName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetUserGetGroups(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName,
    IN DWORD Level,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetUserGetInfo (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     username,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetUserGetLocalGroups(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR UserName,
    IN DWORD Level,
    IN DWORD Flags,
    OUT LPBYTE *Buffer,
    IN DWORD PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserModalsGet(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  DWORD   Level,
    OUT LPBYTE  *Buffer
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetUserSetInfo(
    IN  LPCWSTR ServerName OPTIONAL,
    IN  LPCWSTR UserName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetValidateName(
    IN  LPCWSTR             lpServer OPTIONAL,
    IN  LPCWSTR             lpName,
    IN  LPCWSTR             lpAccount OPTIONAL,
    IN  LPCWSTR             lpPassword OPTIONAL,
    IN  NETSETUP_NAME_TYPE  NameType
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetWkstaGetInfo(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfo (
    IN  LPWSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
UCHAR
APIENTRY
Netbios(
    PNCB pncb
    )
{
    return NRC_SYSTEM;
}

static
NTSTATUS
NetpApiStatusToNtStatus(
    NET_API_STATUS NetStatus
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetpIsRemote(
    IN  LPWSTR  ComputerName OPTIONAL,
    OUT LPDWORD LocalOrRemote,
    OUT LPWSTR  CanonicalizedName OPTIONAL,
    IN  DWORD   cchCanonName,
    IN  DWORD   Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetpUpgradePreNT5JoinInfo( VOID )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
NET_API_FUNCTION
NetServerGetInfo(
    IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
NET_API_STATUS
RxNetUserPasswordSet(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  LPTSTR  OldPassword,
    IN  LPTSTR  NewPassword
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(netapi32)
{
    DLPENTRY(DsAddressToSiteNamesW)
    DLPENTRY(DsEnumerateDomainTrustsW)
    DLPENTRY(DsGetDcNameW)
    DLPENTRY(DsGetDcNameWithAccountW)
    DLPENTRY(DsGetDcSiteCoverageW)
    DLPENTRY(DsRoleFreeMemory)
    DLPENTRY(DsRoleGetPrimaryDomainInformation)
    DLPENTRY(I_NetNameCanonicalize)
    DLPENTRY(I_NetNameValidate)
    DLPENTRY(NetAlertRaiseEx)
    DLPENTRY(NetApiBufferAllocate)
    DLPENTRY(NetApiBufferFree)
    DLPENTRY(NetDfsGetClientInfo)
    DLPENTRY(NetDfsGetInfo)
    DLPENTRY(NetEnumerateTrustedDomains)
    DLPENTRY(NetGetDCName)
    DLPENTRY(NetGetJoinInformation)
    DLPENTRY(NetJoinDomain)
    DLPENTRY(NetLocalGroupGetMembers)
    DLPENTRY(NetMessageBufferSend)
    DLPENTRY(NetQueryDisplayInformation)
    DLPENTRY(NetRemoteComputerSupports)
    DLPENTRY(NetRenameMachineInDomain)
    DLPENTRY(NetServerGetInfo)
    DLPENTRY(NetServerSetInfo)
    DLPENTRY(NetSessionEnum)
    DLPENTRY(NetShareAdd)
    DLPENTRY(NetShareDel)
    DLPENTRY(NetShareGetInfo)
    DLPENTRY(NetShareSetInfo)
    DLPENTRY(NetUnjoinDomain)
    DLPENTRY(NetUserAdd)
    DLPENTRY(NetUserChangePassword)
    DLPENTRY(NetUserDel)
    DLPENTRY(NetUserGetGroups)
    DLPENTRY(NetUserGetInfo)
    DLPENTRY(NetUserGetLocalGroups)
    DLPENTRY(NetUserModalsGet)
    DLPENTRY(NetUserSetInfo)
    DLPENTRY(NetValidateName)
    DLPENTRY(NetWkstaGetInfo)
    DLPENTRY(NetWkstaUserGetInfo)
    DLPENTRY(Netbios)
    DLPENTRY(NetpApiStatusToNtStatus)
    DLPENTRY(NetpIsRemote)
    DLPENTRY(NetpUpgradePreNT5JoinInfo)
    DLPENTRY(RxNetUserPasswordSet)
};

DEFINE_PROCNAME_MAP(netapi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\ntlsapi.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntlsapi.h>

static
LS_STATUS_CODE 
LS_API_ENTRY 
NtLicenseRequestW(
    LPWSTR      ProductName,
    LPWSTR      Version,
    LS_HANDLE   FAR *LicenseHandle,
    NT_LS_DATA  *NtData
    )
{
    return  STATUS_PROCEDURE_NOT_FOUND;
}

static
LS_STATUS_CODE 
LS_API_ENTRY 
NtLSFreeHandle(
    LS_HANDLE LicenseHandle
    )
{
    return  STATUS_PROCEDURE_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(ntlsapi)
{
    DLPENTRY(NtLSFreeHandle)
    DLPENTRY(NtLicenseRequestW)
};

DEFINE_PROCNAME_MAP(ntlsapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\pautoenr.c ===
#include "dspch.h"
#pragma hdrstop

#define _PAUTOENR_

static
HANDLE 
WINAPI
CertAutoEnrollment(IN HWND     hwndParent,
                   IN DWORD    dwStatus)
{
    return NULL;
}


static
BOOL 
WINAPI
CertAutoRemove(IN DWORD    dwFlags)
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(pautoenr)
{
    DLPENTRY(CertAutoEnrollment)
    DLPENTRY(CertAutoRemove)
};

DEFINE_PROCNAME_MAP(pautoenr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\pstorec.c ===
#include "dspch.h"
#pragma hdrstop

#define _PSTOREC_
#include <wincrypt.h>
#include <pstore.h>

static
HRESULT __stdcall PStoreCreateInstance(
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags)
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(pstorec)
{
    DLPENTRY(PStoreCreateInstance)
};

DEFINE_PROCNAME_MAP(pstorec)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\ntdskcc.c ===
#include "dspch.h"
#pragma hdrstop
#include <ntdsa.h>
#include <drs.h>

static
DWORD
KccInitialize(
    )
{
    return ERROR_PROC_NOT_FOUND;
}

// Tells the KCC to shut down, but does not wait to see if it does so
void
KccUnInitializeTrigger()
{
    return;
}


// Waits at most dwMaxWaitInMsec milliseconds for the current KCC task
// to complete.  You must call the trigger routine (above) first.
DWORD
KccUnInitializeWait(
    DWORD   dwMaxWaitInMsec
    )
{
    return ERROR_PROC_NOT_FOUND;
}

// Force the KCC to run a task (e.g., update the replication topology).
DWORD
KccExecuteTask(
    IN  DWORD                   dwMsgVersion,
    IN  DRS_MSG_KCC_EXECUTE *   pMsg
    )
{
    return ERROR_PROC_NOT_FOUND;
}

// Returns the contents of the connection or link failure cache.
DWORD
KccGetFailureCache(
    IN  DWORD                         InfoType,
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntdskcc)
{
    DLPENTRY(KccExecuteTask)
    DLPENTRY(KccGetFailureCache)
    DLPENTRY(KccInitialize)
    DLPENTRY(KccUnInitializeTrigger)
    DLPENTRY(KccUnInitializeWait)
};

DEFINE_PROCNAME_MAP(ntdskcc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\ntmarta.c ===
#include "dspch.h"
#pragma hdrstop

#include <accctrl.h>

static
DWORD
AccRewriteSetNamedRights(
    IN     LPWSTR               pObjectName,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN     BOOL                 bSkipInheritanceComputation
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntmarta)
{
    DLPENTRY(AccRewriteSetNamedRights)
};

DEFINE_PROCNAME_MAP(ntmarta)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\samlib.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntsam.h>
#include <ntsamp.h>

static
NTSTATUS
SamAddMemberToAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamAddMemberToGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamChangePasswordUser2(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamCloseHandle(
    IN SAM_HANDLE SamHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamConnect(
    IN PUNICODE_STRING ServerName,
    OUT PSAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamCreateAliasInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE AliasHandle,
    OUT PULONG RelativeId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamCreateGroupInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE GroupHandle,
    OUT PULONG RelativeId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamCreateUser2InDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE UserHandle,
    OUT PULONG GrantedAccess,
    OUT PULONG RelativeId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamCreateUserInDomain(
    IN SAM_HANDLE DomainHandle,
    IN PUNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT PSAM_HANDLE UserHandle,
    OUT PULONG RelativeId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamDeleteAlias(
    IN SAM_HANDLE AliasHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamDeleteGroup(
    IN SAM_HANDLE GroupHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamDeleteUser(
    IN SAM_HANDLE UserHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamEnumerateAliasesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamEnumerateDomainsInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamEnumerateGroupsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamEnumerateUsersInDomain(
    IN SAM_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN ULONG UserAccountControl,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamFreeMemory(
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetAliasMembership(
    IN SAM_HANDLE DomainHandle,
    IN ULONG PassedCount,
    IN PSID *Sids,
    OUT PULONG MembershipCount,
    OUT PULONG *Aliases
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetCompatibilityMode(
    IN  SAM_HANDLE ObjectHandle,
    OUT ULONG*     Mode
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetDisplayEnumerationIndex (
      IN    SAM_HANDLE        DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PUNICODE_STRING   Prefix,
      OUT   PULONG            Index
      )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetGroupsForUser(
    IN SAM_HANDLE UserHandle,
    OUT PGROUP_MEMBERSHIP * Groups,
    OUT PULONG MembershipCount
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetMembersInAlias(
    IN SAM_HANDLE AliasHandle,
    OUT PSID **MemberIds,
    OUT PULONG MemberCount
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamGetMembersInGroup(
    IN SAM_HANDLE GroupHandle,
    OUT PULONG * MemberIds,
    OUT PULONG * Attributes,
    OUT PULONG MemberCount
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamLookupDomainInSamServer(
    IN SAM_HANDLE ServerHandle,
    IN PUNICODE_STRING Name,
    OUT PSID * DomainId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamLookupIdsInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PUNICODE_STRING *Names,
    OUT PSID_NAME_USE *Use
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamLookupNamesInDomain(
    IN SAM_HANDLE DomainHandle,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PULONG *RelativeIds,
    OUT PSID_NAME_USE *Use
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamOpenAlias(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AliasId,
    OUT PSAM_HANDLE AliasHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamOpenDomain(
    IN SAM_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PSID DomainId,
    OUT PSAM_HANDLE DomainHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamOpenGroup(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG GroupId,
    OUT PSAM_HANDLE GroupHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamOpenUser(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG UserId,
    OUT PSAM_HANDLE UserHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryDisplayInformation (
      IN    SAM_HANDLE DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    ULONG      Index,
      IN    ULONG      EntryCount,
      IN    ULONG      PreferredMaximumLength,
      OUT   PULONG     TotalAvailable,
      OUT   PULONG     TotalReturned,
      OUT   PULONG     ReturnedEntryCount,
      OUT   PVOID      *SortedBuffer
      )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    OUT PVOID *Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PVOID *Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    OUT PVOID *Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQueryInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    OUT PVOID * Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamQuerySecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamRemoveMemberFromAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamRemoveMemberFromForeignDomain(
    IN SAM_HANDLE DomainHandle,
    IN PSID MemberId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamRemoveMemberFromGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamRidToSid(
    IN  SAM_HANDLE ObjectHandle,
    IN  ULONG      Rid,
    OUT PSID*      Sid
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetInformationDomain(
    IN SAM_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PVOID DomainInformation
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetMemberAttributesOfGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamSetSecurityObject(
    IN SAM_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamiChangeKeys()
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamiChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN BOOLEAN LmOldPresent,
    IN PLM_OWF_PASSWORD LmOldOwfPassword,
    IN PLM_OWF_PASSWORD LmNewOwfPassword,
    IN BOOLEAN NtPresent,
    IN PNT_OWF_PASSWORD NtOldOwfPassword,
    IN PNT_OWF_PASSWORD NtNewOwfPassword
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamValidatePassword(
    IN PUNICODE_STRING ServerName OPTIONAL,
    IN PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    IN PSAM_VALIDATE_INPUT_ARG InputArg,
    OUT PSAM_VALIDATE_OUTPUT_ARG *OutputArg
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(samlib)
{
    DLPENTRY(SamAddMemberToAlias)
    DLPENTRY(SamAddMemberToGroup)
    DLPENTRY(SamChangePasswordUser)
    DLPENTRY(SamChangePasswordUser2)
    DLPENTRY(SamCloseHandle)
    DLPENTRY(SamConnect)
    DLPENTRY(SamCreateAliasInDomain)
    DLPENTRY(SamCreateGroupInDomain)
    DLPENTRY(SamCreateUser2InDomain)
    DLPENTRY(SamCreateUserInDomain)
    DLPENTRY(SamDeleteAlias)
    DLPENTRY(SamDeleteGroup)
    DLPENTRY(SamDeleteUser)
    DLPENTRY(SamEnumerateAliasesInDomain)
    DLPENTRY(SamEnumerateDomainsInSamServer)
    DLPENTRY(SamEnumerateGroupsInDomain)
    DLPENTRY(SamEnumerateUsersInDomain)
    DLPENTRY(SamFreeMemory)
    DLPENTRY(SamGetAliasMembership)
    DLPENTRY(SamGetCompatibilityMode)
    DLPENTRY(SamGetDisplayEnumerationIndex)
    DLPENTRY(SamGetGroupsForUser)
    DLPENTRY(SamGetMembersInAlias)
    DLPENTRY(SamGetMembersInGroup)
    DLPENTRY(SamLookupDomainInSamServer)
    DLPENTRY(SamLookupIdsInDomain)
    DLPENTRY(SamLookupNamesInDomain)
    DLPENTRY(SamOpenAlias)
    DLPENTRY(SamOpenDomain)
    DLPENTRY(SamOpenGroup)
    DLPENTRY(SamOpenUser)
    DLPENTRY(SamQueryDisplayInformation)
    DLPENTRY(SamQueryInformationAlias)
    DLPENTRY(SamQueryInformationDomain)
    DLPENTRY(SamQueryInformationGroup)
    DLPENTRY(SamQueryInformationUser)
    DLPENTRY(SamQuerySecurityObject)
    DLPENTRY(SamRemoveMemberFromAlias)
    DLPENTRY(SamRemoveMemberFromForeignDomain)
    DLPENTRY(SamRemoveMemberFromGroup)
    DLPENTRY(SamRidToSid)
    DLPENTRY(SamSetInformationAlias)
    DLPENTRY(SamSetInformationDomain)
    DLPENTRY(SamSetInformationGroup)
    DLPENTRY(SamSetInformationUser)
    DLPENTRY(SamSetMemberAttributesOfGroup)
    DLPENTRY(SamSetSecurityObject)
    DLPENTRY(SamValidatePassword)
    DLPENTRY(SamiChangeKeys)
    DLPENTRY(SamiChangePasswordUser)
};

DEFINE_PROCNAME_MAP(samlib)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\samsrv.c ===
#include "dspch.h"
#pragma hdrstop

#include <ntsam.h>
#include <ntlsa.h>
#include <crypt.h>
#include <samrpc.h>
#include <samisrv.h>


static
NTSTATUS
SamIAccountRestrictions(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamIConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
VOID
SamIFreeSidAndAttributesList(
    IN  PSID_AND_ATTRIBUTES_LIST List
    )
{
    return;
}

static
VOID
SamIFree_SAMPR_GET_GROUPS_BUFFER (
    PSAMPR_GET_GROUPS_BUFFER Source
    )
{
    return;
}

static
VOID
SamIFree_SAMPR_ULONG_ARRAY (
    PSAMPR_ULONG_ARRAY Source
    )
{
    return;
}

static
VOID
SamIFree_SAMPR_USER_INFO_BUFFER (
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    )
{
    return;
}

static
NTSTATUS
SamIGetUserLogonInformationEx(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamIRetrievePrimaryCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamIUpdateLogonStatistics(
    IN SAM_HANDLE UserHandle,
    IN PSAM_LOGON_STATISTICS LogonStats
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamrCloseHandle(
    SAMPR_HANDLE *SamHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamrGetGroupsForUser(
    SAMPR_HANDLE UserHandle,
    PSAMPR_GET_GROUPS_BUFFER *Groups
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamrLookupNamesInDomain(
    SAMPR_HANDLE DomainHandle,
    ULONG Count,
    RPC_UNICODE_STRING Names[  ],
    PSAMPR_ULONG_ARRAY RelativeIds,
    PSAMPR_ULONG_ARRAY Use
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamrOpenDomain(
    SAMPR_HANDLE ServerHandle,
    ACCESS_MASK DesiredAccess,
    PRPC_SID DomainId,
    SAMPR_HANDLE *DomainHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamrOpenUser(
    SAMPR_HANDLE DomainHandle,
    ACCESS_MASK DesiredAccess,
    ULONG UserId,
    SAMPR_HANDLE *UserHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
SamrQueryInformationUser(
    SAMPR_HANDLE UserHandle,
    USER_INFORMATION_CLASS UserInformationClass,
    PSAMPR_USER_INFO_BUFFER *Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(samsrv)
{
    DLPENTRY(SamIAccountRestrictions)
    DLPENTRY(SamIConnect)
    DLPENTRY(SamIFreeSidAndAttributesList)
    DLPENTRY(SamIFree_SAMPR_GET_GROUPS_BUFFER)
    DLPENTRY(SamIFree_SAMPR_ULONG_ARRAY)
    DLPENTRY(SamIFree_SAMPR_USER_INFO_BUFFER)
    DLPENTRY(SamIGetUserLogonInformationEx)
    DLPENTRY(SamIRetrievePrimaryCredentials)
    DLPENTRY(SamIUpdateLogonStatistics)
    DLPENTRY(SamrCloseHandle)
    DLPENTRY(SamrGetGroupsForUser)
    DLPENTRY(SamrLookupNamesInDomain)
    DLPENTRY(SamrOpenDomain)
    DLPENTRY(SamrOpenUser)
    DLPENTRY(SamrQueryInformationUser)
};

DEFINE_PROCNAME_MAP(samsrv)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\secur32.c ===
#include "dspch.h"
#pragma hdrstop
#include <sspi.h>

#define SEC_ENTRY                              __stdcall
#define EXTENDED_NAME_FORMAT                   DWORD
#define PLSA_STRING                            PVOID
#define SECURITY_LOGON_TYPE                    DWORD
#define POLICY_NOTIFICATION_INFORMATION_CLASS  DWORD
#define PLSA_OPERATIONAL_MODE                  PULONG

static
BOOLEAN
SEC_ENTRY
GetUserNameExA(
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    PULONG nSize
    )
{
    return FALSE;
}

static
BOOLEAN
SEC_ENTRY
GetUserNameExW(
    EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer,
    PULONG nSize
    )
{
    return FALSE;
}

static
NTSTATUS
NTAPI
LsaCallAuthenticationPackage(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaConnectUntrusted (
    OUT PHANDLE LsaHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaDeregisterLogonProcess (
    IN HANDLE LsaHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaFreeReturnBuffer (
    IN PVOID Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaLogonUser (
    IN HANDLE LsaHandle,
    IN PLSA_STRING OriginName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG AuthenticationPackage,
    IN PVOID AuthenticationInformation,
    IN ULONG AuthenticationInformationLength,
    IN PTOKEN_GROUPS LocalGroups OPTIONAL,
    IN PTOKEN_SOURCE SourceContext,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PHANDLE Token,
    OUT PQUOTA_LIMITS Quotas,
    OUT PNTSTATUS SubStatus
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaLookupAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN PLSA_STRING PackageName,
    OUT PULONG AuthenticationPackage
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaRegisterLogonProcess (
    IN PLSA_STRING LogonProcessName,
    OUT PHANDLE LsaHandle,
    OUT PLSA_OPERATIONAL_MODE SecurityMode
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaRegisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
NTSTATUS
NTAPI
LsaUnregisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SetContextAttributesW(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOLEAN
SEC_ENTRY
TranslateNameW(
    LPCWSTR lpAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    LPWSTR lpTranslatedName,
    PULONG nSize
    )
{
    return FALSE;
}

static
SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS SEC_ENTRY
SetContextAttributesA(
    PCtxtHandle phContext,              // Context to Set
    unsigned long ulAttribute,          // Attribute to Set
    void SEC_FAR * pBuffer,             // Buffer for attributes
    unsigned long cbBuffer              // Size (in bytes) of Buffer
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
DecryptMessage( PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo,
                ULONG *             pfQOP)
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
EncryptMessage( PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle                 phContext,
    VOID * *                    TokenHandle
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslAcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslEnumerateProfilesA(
    OUT LPSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslEnumerateProfilesW(
    OUT LPWSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslGetContextOption(
    PCtxtHandle ContextHandle,
    ULONG Option,
    PVOID Value,
    ULONG Size,
    PULONG Needed OPTIONAL
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslGetProfilePackageA(
    IN LPSTR ProfileName,
    OUT PSecPkgInfoA * PackageInfo
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslGetProfilePackageW(
    IN LPWSTR ProfileName,
    OUT PSecPkgInfoW * PackageInfo
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslIdentifyPackageA(
    PSecBufferDesc  pInput,
    PSecPkgInfoA *   pPackage
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


static
SECURITY_STATUS
SEC_ENTRY
SaslIdentifyPackageW(
    PSecBufferDesc  pInput,
    PSecPkgInfoW *   pPackage
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslInitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPSTR                       pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslInitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SaslSetContextOption(
    PCtxtHandle ContextHandle,
    ULONG Option,
    PVOID Value,
    ULONG Size
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
SECURITY_STATUS
SEC_ENTRY
SecpSetIPAddress(
    PUCHAR  lpIpAddress,
    ULONG   cchIpAddress
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}

static
BOOLEAN
SEC_ENTRY
TranslateNameA (
    LPCSTR lpAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    LPSTR lpTranslatedName,
    LPDWORD nSize
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(secur32)
{
    DLPENTRY(AcceptSecurityContext)
    DLPENTRY(AcquireCredentialsHandleA)
    DLPENTRY(ApplyControlToken)
    DLPENTRY(DecryptMessage)
    DLPENTRY(DeleteSecurityContext)
    DLPENTRY(EncryptMessage)
    DLPENTRY(FreeContextBuffer)
    DLPENTRY(FreeCredentialsHandle)
    DLPENTRY(GetUserNameExA)
    DLPENTRY(GetUserNameExW)
    DLPENTRY(ImpersonateSecurityContext)
    DLPENTRY(InitializeSecurityContextA)
    DLPENTRY(InitializeSecurityContextW)
    DLPENTRY(LsaCallAuthenticationPackage)
    DLPENTRY(LsaConnectUntrusted)
    DLPENTRY(LsaDeregisterLogonProcess)
    DLPENTRY(LsaFreeReturnBuffer)
    DLPENTRY(LsaLogonUser)
    DLPENTRY(LsaLookupAuthenticationPackage)
    DLPENTRY(LsaRegisterLogonProcess)
    DLPENTRY(LsaRegisterPolicyChangeNotification)
    DLPENTRY(LsaUnregisterPolicyChangeNotification)
    DLPENTRY(QueryContextAttributesA)
    DLPENTRY(QueryContextAttributesW)
    DLPENTRY(QuerySecurityContextToken)
    DLPENTRY(RevertSecurityContext)
    DLPENTRY(SaslAcceptSecurityContext)
    DLPENTRY(SaslEnumerateProfilesA)
    DLPENTRY(SaslEnumerateProfilesW)
    DLPENTRY(SaslGetContextOption)
    DLPENTRY(SaslGetProfilePackageA)
    DLPENTRY(SaslGetProfilePackageW)
    DLPENTRY(SaslIdentifyPackageA)
    DLPENTRY(SaslIdentifyPackageW)
    DLPENTRY(SaslInitializeSecurityContextA)
    DLPENTRY(SaslInitializeSecurityContextW)
    DLPENTRY(SaslSetContextOption)
    DLPENTRY(SecpSetIPAddress)
    DLPENTRY(SetContextAttributesA)
    DLPENTRY(SetContextAttributesW)
    DLPENTRY(TranslateNameA)
    DLPENTRY(TranslateNameW)
};

DEFINE_PROCNAME_MAP(secur32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\scecli.c ===
#include "dspch.h"
#pragma hdrstop

#include <secedit.h>
#include <scesetup.h>

static
DWORD
WINAPI
SceSetupMoveSecurityFile(
    IN PWSTR FileToSetSecurity,
    IN PWSTR FileToSaveInDB OPTIONAL,
    IN PWSTR SDText OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SceSetupUnwindSecurityFile(
    IN PWSTR FileFullName,
    IN PSECURITY_DESCRIPTOR pSDBackup
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SceSetupUpdateSecurityFile(
     IN PWSTR FileFullName,
     IN UINT nFlag,
     IN PWSTR SDText
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SceSetupUpdateSecurityKey(
     IN HKEY hKeyRoot,
     IN PWSTR KeyPath,
     IN UINT nFlag,
     IN PWSTR SDText
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SceSetupUpdateSecurityService(
     IN PWSTR ServiceName,
     IN DWORD StartType,
     IN PWSTR SDText
     )
{
    return ERROR_PROC_NOT_FOUND;
}

static
SCESTATUS
WINAPI
SceSvcConvertSDToText(
    IN PSECURITY_DESCRIPTOR   pSD,
    IN SECURITY_INFORMATION   siSecurityInfo,
    OUT PWSTR                  *ppwszTextSD,
    OUT PULONG                 pulTextSize
    )
{
    return SCESTATUS_MOD_NOT_FOUND;
}

static
SCESTATUS
WINAPI
SceSvcConvertTextToSD (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pulSDSize,
    OUT PSECURITY_INFORMATION   psiSeInfo
    )
{
    return SCESTATUS_MOD_NOT_FOUND;
}

static
SCESTATUS
WINAPI
SceGetSecurityProfileInfo (
    IN  PVOID               hProfile,
    IN  SCETYPE             ProfileType,
    IN  AREA_INFORMATION    Area,
    IN OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    )
{
    return SCESTATUS_MOD_NOT_FOUND;
}
static
SCESTATUS
WINAPI
SceFreeProfileMemory (
    PSCE_PROFILE_INFO pProfile
    )
{
    return SCESTATUS_MOD_NOT_FOUND;
}
static
SCESTATUS
WINAPI
SceCloseProfile (
    IN PVOID *hProfile
    )
{
    return SCESTATUS_MOD_NOT_FOUND;
}
static
SCESTATUS
WINAPI
SceOpenProfile (
    IN PCWSTR ProfileName,
    IN SCE_FORMAT_TYPE  ProfileFormat,
    OUT PVOID *hProfile
    )
{
    return SCESTATUS_MOD_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(scecli)
{
    DLPENTRY(SceCloseProfile)
    DLPENTRY(SceFreeProfileMemory)
    DLPENTRY(SceGetSecurityProfileInfo)
    DLPENTRY(SceOpenProfile)
    DLPENTRY(SceSetupMoveSecurityFile)
    DLPENTRY(SceSetupUnwindSecurityFile)
    DLPENTRY(SceSetupUpdateSecurityFile)
    DLPENTRY(SceSetupUpdateSecurityKey)
    DLPENTRY(SceSetupUpdateSecurityService)
    DLPENTRY(SceSvcConvertSDToText)
    DLPENTRY(SceSvcConvertTextToSD)
};

DEFINE_PROCNAME_MAP(scecli)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\winscard.c ===
#include "dspch.h"
#pragma hdrstop

#define WINSCARDAPI
#include <winscard.h>

static
WINSCARDAPI LONG WINAPI
SCardCancel(
    IN SCARDCONTEXT hContext)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI
LONG
WINAPI
SCardEstablishContext(
    IN      DWORD dwScope,
    IN      LPCVOID pvReserved1,
    IN      LPCVOID pvReserved2,
    OUT     LPSCARDCONTEXT phContext)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardFreeMemory(
    IN SCARDCONTEXT hContext,
    IN LPCVOID pvMem)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN DWORD dwProviderId,
    OUT LPWSTR szProvider,
    IN OUT LPDWORD pcchProvider)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardGetStatusChangeW(
    IN SCARDCONTEXT hContext,
    IN DWORD dwTimeout,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardListCardsW(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT LPWSTR mszCards,
    IN OUT LPDWORD pcchCards)
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
WINAPI
SCardListReadersA(
    IN      SCARDCONTEXT hContext,
    IN      LPCSTR mszGroups,
    OUT     LPSTR mszReaders,
    IN OUT  LPDWORD pcchReaders)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI LONG WINAPI
SCardListReadersW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR mszGroups,
    OUT LPWSTR mszReaders,
    IN OUT LPDWORD pcchReaders)
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINSCARDAPI
LONG
WINAPI
SCardReleaseContext(
    IN      SCARDCONTEXT hContext)
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(winscard)
{
    DLPENTRY(SCardCancel)
    DLPENTRY(SCardEstablishContext)
    DLPENTRY(SCardFreeMemory)
    DLPENTRY(SCardGetCardTypeProviderNameW)
    DLPENTRY(SCardGetStatusChangeW)
    DLPENTRY(SCardListCardsW)
    DLPENTRY(SCardListReadersA)
    DLPENTRY(SCardListReadersW)
    DLPENTRY(SCardReleaseContext)
};

DEFINE_PROCNAME_MAP(winscard)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\wintrust.c ===
#include "dspch.h"
#pragma hdrstop

#include <wincrypt.h>
#include <wintrust.h>
#include <mscat.h>


static
LONG
WINAPI
WinVerifyTrust (
    HWND hwnd,
    GUID *pgActionID,
    LPVOID pWVTData
    )
{
    return E_UNEXPECTED;
}

static
LONG
WINAPI
WTHelperGetFileHash (
    IN LPCWSTR pwszFilename,
    IN DWORD dwFlags,
    IN OUT OPTIONAL PVOID *pvReserved,
    OUT OPTIONAL BYTE *pbFileHash,
    IN OUT OPTIONAL DWORD *pcbFileHash,
    OUT OPTIONAL ALG_ID *pHashAlgid
    )
{
    return E_UNEXPECTED;
}

static
CRYPT_PROVIDER_DATA *
WINAPI     
WTHelperProvDataFromStateData(
    IN HANDLE hStateData
    )
{
    return NULL;
}

static
CRYPT_PROVIDER_SGNR *
WINAPI
WTHelperGetProvSignerFromChain(
    IN CRYPT_PROVIDER_DATA *pProvData,
    IN DWORD idxSigner,
    IN BOOL fCounterSigner,
    IN DWORD idxCounterSigner
    )
{
    return NULL;
}

static
CRYPT_PROVIDER_CERT *
WINAPI     
WTHelperGetProvCertFromChain(
    IN CRYPT_PROVIDER_SGNR *pSgnr,
    IN DWORD idxCert
    )
{
    return NULL;
}

static
BOOL
WINAPI
CryptCATAdminAcquireContext(
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags) 
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
HCATINFO
WINAPI
CryptCATAdminEnumCatalogFromHash(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CryptCATAdminCalcHashFromFileHandle(
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
HCATINFO
WINAPI
CryptCATAdminAddCatalog(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OPTIONAL WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CryptCATCatalogInfoFromContext(
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminReleaseContext(
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminReleaseCatalogContext(
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminRemoveCatalog(
    IN HCATADMIN hCatAdmin,
    IN LPCWSTR pwszCatalogFile,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
CryptCATAdminResolveCatalogPath(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wintrust)
{
    DLPENTRY(CryptCATAdminAcquireContext)
    DLPENTRY(CryptCATAdminAddCatalog)
    DLPENTRY(CryptCATAdminCalcHashFromFileHandle)
    DLPENTRY(CryptCATAdminEnumCatalogFromHash)
    DLPENTRY(CryptCATAdminReleaseCatalogContext)
    DLPENTRY(CryptCATAdminReleaseContext)
    DLPENTRY(CryptCATAdminRemoveCatalog)
    DLPENTRY(CryptCATAdminResolveCatalogPath)
    DLPENTRY(CryptCATCatalogInfoFromContext)
    DLPENTRY(WTHelperGetFileHash)
    DLPENTRY(WTHelperGetProvCertFromChain)
    DLPENTRY(WTHelperGetProvSignerFromChain)
    DLPENTRY(WTHelperProvDataFromStateData)
    DLPENTRY(WinVerifyTrust)
};

DEFINE_PROCNAME_MAP(wintrust)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\userenv.c ===
#include "dspch.h"
#pragma hdrstop

#define _USERENV_
#include <userenv.h>
#include <userenvp.h>


static
BOOL
WINAPI
AddItemW (
    LPCWSTR lpGroupName,
    BOOL    bCommonGroup,
    LPCWSTR lpFileName,
    LPCWSTR lpCommandLine,
    LPCWSTR lpIconPath,
    int     iIconIndex,
    LPCWSTR lpWorkingDirectory,
    WORD    wHotKey,
    int     iShowCmd
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeleteItemW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup,
     IN LPCWSTR lpFileName,
     IN BOOL    bDeleteGroup)
{
    return FALSE;
}

static
BOOL
WINAPI
CreateEnvironmentBlock(
    OUT LPVOID *lpEnvironment,
    IN HANDLE  hToken,
    IN BOOL    bInherit)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CreateGroupW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CreateGroupExA(LPCSTR lpGroupName, BOOL bCommonGroup,
               LPCSTR lpResourceModuleName, UINT uResourceID)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CreateGroupExW(LPCWSTR lpGroupName, BOOL bCommonGroup,
               LPCWSTR lpResourceModuleName, UINT uResourceID)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CreateLinkFileW(
     IN INT csidl,
     IN LPCWSTR lpSubDirectory,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd,
     IN LPCWSTR lpDescription)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CreateLinkFileEx(INT     csidl,                LPCTSTR lpSubDirectory,
                 LPCTSTR lpFileName,           LPCTSTR lpCommandLine,
                 LPCTSTR lpIconPath,           int iIconIndex,
                 LPCTSTR lpWorkingDirectory,   WORD wHotKey,
                 int     iShowCmd,             LPCTSTR lpDescription,
                 LPCWSTR lpResourceModuleName, UINT uResourceID)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
DeleteGroupW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup)
{
    return FALSE;
}

static
BOOL
WINAPI
ExpandEnvironmentStringsForUserA(
    IN HANDLE hToken,
    IN LPCSTR lpSrc,
    OUT LPSTR lpDest,
    IN DWORD dwSize)
{
    return FALSE;
}

static
BOOL
WINAPI
ExpandEnvironmentStringsForUserW(
    IN HANDLE hToken,
    IN LPCWSTR lpSrc,
    OUT LPWSTR lpDest,
    IN DWORD dwSize)
{
    return FALSE;
}

static
BOOL
WINAPI
GetDefaultUserProfileDirectoryW(
    IN LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize)
{
    return FALSE;
}

static
BOOL
WINAPI
GetProfileType(
    OUT DWORD *dwFlags)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
InitializeProfiles(
    IN BOOL bGuiModeSetup)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
GetUserProfileDirectoryW(
    IN HANDLE  hToken,
    OUT LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
GetAllUsersProfileDirectoryW(
    OUT LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
GetProfilesDirectoryW(
    OUT LPWSTR lpProfilesDir,
    IN OUT LPDWORD lpcchSize)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
DestroyEnvironmentBlock(
    IN LPVOID  lpEnvironment)
{
    return FALSE;
}

static
USERENVAPI
BOOL 
WINAPI 
LoadUserProfileW 
(HANDLE hToken, 
 LPPROFILEINFOW lpProfileInfoW)
{
    return FALSE; 
}

static
USERENVAPI
BOOL 
WINAPI 
UnloadUserProfile
(HANDLE hToken, 
 HANDLE hProfile)
{
    return FALSE; 
}

static
BOOL 
WINAPI 
RegisterGPNotification(
    IN HANDLE hEvent, 
    IN BOOL bMachine )
{
    return FALSE;
}

static
BOOL 
WINAPI 
UnregisterGPNotification(
    IN HANDLE hEvent)

{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
DeleteLinkFile(INT csidl, LPCTSTR lpSubDirectory,
               LPCTSTR lpFileName, BOOL bDeleteSubDirectory)
{
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
DeleteProfileW (
        IN LPCWSTR lpSidString,
        IN LPCWSTR lpProfilePath,
        IN LPCWSTR lpComputerName)
{
    return FALSE;
}

static
USERENVAPI
DWORD 
WINAPI
GetGroupPolicyNetworkName(
    LPWSTR szNetworkName,
    LPDWORD pdwByteCount
    )
{
    return 0;
}

static
DWORD 
WINAPI 
GetUserAppDataPathW(
    HANDLE hToken, 
    BOOL fLocalAppData,
    LPWSTR lpFolderPath
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
USERENVAPI
BOOL
WINAPI
CopySystemProfile(
    IN BOOL bCleanInstall
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
GetUserProfileDirFromSidW(
    IN PSID pSid,
    OUT LPWSTR lpProfileDirW,
    IN OUT LPDWORD lpcchSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
USERENVAPI
BOOL
WINAPI
CopyProfileDirectoryW(
    IN  LPCWSTR lpSourceDir,
    IN  LPCWSTR lpDestinationDir,
    IN  DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(userenv)
{
    DLOENTRY(100, InitializeProfiles)
    DLOENTRY(102, CreateGroupW)
    DLOENTRY(104, DeleteGroupW)
    DLOENTRY(106, AddItemW)
    DLOENTRY(108, DeleteItemW)
    DLOENTRY(112, CopyProfileDirectoryW)
    DLOENTRY(120, CreateLinkFileW)
    DLOENTRY(122, DeleteLinkFileW)
    DLOENTRY(132, CreateEnvironmentBlock)
    DLOENTRY(136, CreateGroupExA)
    DLOENTRY(137, CreateGroupExW)
    DLOENTRY(139, CreateLinkFileExW)
    DLOENTRY(147, GetGroupPolicyNetworkName)
    DLOENTRY(149, GetUserAppDataPathW)
    DLOENTRY(155, CopySystemProfile)
    DLOENTRY(157, GetUserProfileDirFromSidW)

};

DEFINE_ORDINAL_MAP(userenv)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(userenv)
{
    DLPENTRY(CreateEnvironmentBlock)
    DLPENTRY(DeleteProfileW)
    DLPENTRY(DestroyEnvironmentBlock)
    DLPENTRY(ExpandEnvironmentStringsForUserA)
    DLPENTRY(ExpandEnvironmentStringsForUserW)
    DLPENTRY(GetAllUsersProfileDirectoryW)
    DLPENTRY(GetDefaultUserProfileDirectoryW)
    DLPENTRY(GetProfileType)
    DLPENTRY(GetProfilesDirectoryW)
    DLPENTRY(GetUserProfileDirectoryW)
    DLPENTRY(LoadUserProfileW)
    DLPENTRY(RegisterGPNotification)
    DLPENTRY(UnloadUserProfile)
    DLPENTRY(UnregisterGPNotification)
};

DEFINE_PROCNAME_MAP(userenv)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\wldap32.c ===
#include "dspch.h"
#pragma hdrstop

#define _WINLDAP_
#define LDAP_UNICODE    0
#include <winldap.h>

static
WINLDAPAPI
ULONG LDAPAPI
ldap_unbind(
    LDAP *ld
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_unbind_s(
    LDAP *ld
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
LdapMapErrorToWin32(
    ULONG LdapError
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINLDAPAPI
ULONG LDAPAPI
LdapGetLastError(
    VOID
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
WINLDAPAPI
LDAPMessage *LDAPAPI
ldap_first_entry(
    LDAP *ld,
    LDAPMessage *res
    )
{
    return NULL;
}

static
WINLDAPAPI
LDAPMessage *LDAPAPI
ldap_next_entry(
    LDAP *ld,
    LDAPMessage *entry
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_count_entries(
    LDAP *ld,
    LDAPMessage *res
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_result(
    LDAP            *ld,
    ULONG           msgid,
    ULONG           all,
    struct l_timeval  *timeout,
    LDAPMessage     **res
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_msgfree(
    LDAPMessage *res
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_bind_s(
    LDAP *ld,
    const PCHAR dn,
    const PCHAR cred,
    ULONG method
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
LDAP * LDAPAPI
cldap_openA(
    PCHAR HostName,
    ULONG PortNumber
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_add_sW(
    LDAP *ld,
    PWCHAR dn,
    LDAPModW *attrs[]
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_add_ext_sW(
    LDAP *ld,
    const PWCHAR dn,
    LDAPModW *attrs[],
    PLDAPControlW *ServerControls,
    PLDAPControlW *ClientControls
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_bind_sW(
    LDAP *ld,
    PWCHAR dn,
    PWCHAR cred,
    ULONG method
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_count_values_len(
    struct berval **vals
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_value_free_len(
    struct berval **vals
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_compare_sW(
    LDAP *ld,
    const PWCHAR dn,
    const PWCHAR attr,
    PWCHAR value
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_count_valuesW(
    PWCHAR *vals
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_delete_sW(
    LDAP *ld,
    const PWCHAR dn
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_delete_ext_sW(
    LDAP *ld,
    const PWCHAR dn,
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_escape_filter_elementA(
   PCHAR   sourceFilterElement,
   ULONG   sourceLength,
   PCHAR   destFilterElement,
   ULONG   destLength
   )
{
    return LDAP_NO_MEMORY;
}

static
PWCHAR __cdecl
ldap_get_dnW (
    LDAP *ExternalHandle,
    LDAPMessage *LdapMsg
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_get_next_page_s(
    PLDAP           ExternalHandle,
    PLDAPSearch     SearchHandle,
    struct l_timeval  *timeout,
    ULONG           PageSize,
    ULONG          *TotalCount,
    LDAPMessage     **Results
    )
{
    return LDAP_NO_MEMORY;
}


static
WINLDAPAPI
PWCHAR *LDAPAPI
ldap_get_valuesW(
    LDAP            *ld,
    LDAPMessage     *entry,
    const PWCHAR          attr
    )
{
    return NULL;
}

static
WINLDAPAPI
struct berval **LDAPAPI
ldap_get_values_lenA(
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    const PCHAR           attr
    )
{
    return NULL;
}

static
WINLDAPAPI
struct berval **LDAPAPI
ldap_get_values_lenW(
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    const PWCHAR          attr
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_modify_ext_sW(
    LDAP *ld,
    const PWCHAR dn,
    LDAPModW *mods[],
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_modify_sW(
    LDAP *ld,
    PWCHAR dn,
    LDAPModW *mods[]
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
LDAP * LDAPAPI
ldap_openW(
    const PWCHAR HostName,
    ULONG PortNumber
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_rename_ext_sW(
        LDAP *ld,
        const PWCHAR dn,
        const PWCHAR NewRDN,
        const PWCHAR NewParent,
        INT DeleteOldRdn,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_searchA(
    LDAP    *ld,
    const PCHAR   base,
    ULONG   scope,
    const PCHAR   filter,
    PCHAR   attrs[],
    ULONG   attrsonly
    )
{
    return -1;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_search_ext_sW(
    LDAP            *ld,
    const PWCHAR    base,
    ULONG           scope,
    const PWCHAR    filter,
    PWCHAR          attrs[],
    ULONG           attrsonly,
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls,
    struct l_timeval  *timeout,
    ULONG           SizeLimit,
    LDAPMessage     **res
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_search_sW(
    LDAP            *ld,
    const PWCHAR    base,
    ULONG           scope,
    const PWCHAR    filter,
    PWCHAR          attrs[],
    ULONG           attrsonly,
    LDAPMessage     **res
    )
{
    *res = NULL;
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_value_freeW(
    PWCHAR *vals
    )
{
    return LDAP_NO_MEMORY;
}

static
WINLDAPAPI
PCHAR LDAPAPI
ldap_err2stringA(
    ULONG err
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_set_optionW(
    LDAP *ld,
    int option,
    const void *invalue
    )
{
    return LDAP_NO_MEMORY;
}

static
VOID  __cdecl
ldap_memfreeW(
    PWCHAR  Block
    )
{
    return;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_search_abandon_page(
        PLDAP           ExternalHandle,
        PLDAPSearch     SearchBlock
    )
{
    return LDAP_NO_MEMORY;
}

WINLDAPAPI
PLDAPSearch LDAPAPI
ldap_search_init_pageW(
        PLDAP           ExternalHandle,
        const PWCHAR    DistinguishedName,
        ULONG           ScopeOfSearch,
        const PWCHAR    SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           PageTimeLimit,
        ULONG           TotalSizeLimit,
        PLDAPSortKeyW  *SortKeys
    )
{
    return NULL;
}

static
WINLDAPAPI
LDAP* LDAPAPI
ldap_initW(
    const PWCHAR HostName,
    ULONG PortNumber
    )
{
    return NULL;
}

static
WINLDAPAPI
ULONG LDAPAPI
ldap_get_optionW(
    LDAP *ld,
    int option,
    void *outvalue
    )
{
    return LDAP_NO_MEMORY;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//

DEFINE_ORDINAL_ENTRIES(wldap32)
{
    DLOENTRY(12,ldap_get_optionW)
    DLOENTRY(13,ldap_unbind)
    DLOENTRY(14,ldap_set_optionW)
    DLOENTRY(16,LdapGetLastError)
    DLOENTRY(18,LdapMapErrorToWin32)
    DLOENTRY(26,ldap_first_entry)
    DLOENTRY(27,ldap_next_entry)
    DLOENTRY(36,ldap_count_entries)
    DLOENTRY(40,ldap_result)
    DLOENTRY(41,ldap_msgfree)
    DLOENTRY(45,ldap_bind_s)
    DLOENTRY(46,ldap_unbind_s)
    DLOENTRY(55,cldap_openA)
    DLOENTRY(65,ldap_add_ext_sW)
    DLOENTRY(69,ldap_add_sW)
    DLOENTRY(73,ldap_bind_sW)
    DLOENTRY(77,ldap_count_values_len)
    DLOENTRY(79,ldap_value_free_len)
    DLOENTRY(87,ldap_compare_sW)
    DLOENTRY(97,ldap_count_valuesW)
    DLOENTRY(111,ldap_delete_ext_sW)
    DLOENTRY(113,ldap_delete_sW)
    DLOENTRY(117,ldap_err2stringA)
    DLOENTRY(119,ldap_escape_filter_elementA)
    DLOENTRY(133,ldap_get_dnW)
    DLOENTRY(135,ldap_get_next_page_s)
    DLOENTRY(140,ldap_get_valuesW)
    DLOENTRY(141,ldap_get_values_lenA)
    DLOENTRY(142,ldap_get_values_lenW)
    DLOENTRY(145,ldap_initW)
    DLOENTRY(147,ldap_memfreeW)
    DLOENTRY(155,ldap_modify_ext_sW)
    DLOENTRY(157,ldap_modify_sW)
    DLOENTRY(170,ldap_openW)
    DLOENTRY(188,ldap_rename_ext_sW)
    DLOENTRY(189,ldap_searchA)
    DLOENTRY(191,ldap_search_abandon_page)
    DLOENTRY(203,ldap_search_ext_sW)
    DLOENTRY(206,ldap_search_init_pageW)
    DLOENTRY(208,ldap_search_sW)
    DLOENTRY(224,ldap_value_freeW)
};

DEFINE_ORDINAL_MAP(wldap32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\dload\w32topl.c ===
#include "dspch.h"
#pragma hdrstop

#include <w32topl.h>

//
// Notes on stub behavior
//

//
// Whenever possible, STATUS_PROCEDURE_NOT_FOUHD, ERROR_PROC_NOT_FOUND, NULL,
// or FALSE is returned.
//

//
// Some of the functions below require the caller to look at an OUT
// parameter to determine whether the results of the function (in addition
// or independent of the return value).  Since these are private functions
// there is no need in shipping code to check for the validity of the OUT
// parameter (typically a pointer).  These values should always be present
// in RTM versions.
//

//
// Some functions don't return a status and were designed to never fail
// (for example, functions that effectively do a table lookup).  For these
// functions there is no reasonable return value.  However, this is not
// a practical issue since these API's would only be called after the DS
// initialized which means that API would have already been "snapped" in via
// GetProcAddress().
//
// Of course, it is possible to rewrite these routines to return errors,
// however, as above, this will have no practical effect.
//

static
TOPL_LIST
ToplListCreate(
    VOID
    )
{
    return NULL;
}

static
VOID 
ToplListFree(
    IN TOPL_LIST List,
    IN BOOLEAN   fRecursive   // TRUE implies free the elements contained 
                              // in the list
    )
{
    return;
}

static
VOID
ToplListSetIter(
    IN TOPL_LIST     List,
    IN TOPL_ITERATOR Iterator
    )
{
    return;
}

static
TOPL_LIST_ELEMENT
ToplListRemoveElem(
    IN TOPL_LIST         List,
    IN TOPL_LIST_ELEMENT Elem
    )
{
    return NULL;
}

static
VOID
ToplListAddElem(
    IN TOPL_LIST         List,
    IN TOPL_LIST_ELEMENT Elem
    )
{
    return;
}


static
DWORD
ToplListNumberOfElements(
    IN TOPL_LIST         List
    )
{
    return 0;
}

static
TOPL_ITERATOR
ToplIterCreate(
    VOID
    )
{
    return NULL;
}

static
VOID 
ToplIterFree(
    IN TOPL_ITERATOR Iterator
    )
{
    return;
}

static
TOPL_LIST_ELEMENT
ToplIterGetObject(
    IN TOPL_ITERATOR Iterator
    )
{
    return NULL;
}

static
VOID
ToplIterAdvance(
    IN TOPL_ITERATOR Iterator
    )
{
    return;
}

static
TOPL_EDGE
ToplEdgeCreate(
    VOID
    )
{
    return NULL;
}

static
VOID
ToplEdgeFree(
    IN TOPL_EDGE Edge
    )
{
    return;
}

static
VOID
ToplEdgeSetToVertex(
    IN TOPL_EDGE   Edge,
    IN TOPL_VERTEX ToVertex
    )
{
    return;
}

static
TOPL_VERTEX
ToplEdgeGetToVertex(
    IN TOPL_EDGE   Edge
    )
{
    return NULL;
}

static
VOID
ToplEdgeSetFromVertex(
    IN TOPL_EDGE   Edge,
    IN TOPL_VERTEX FromVertex
    )
{
    return;
}

static
TOPL_VERTEX
ToplEdgeGetFromVertex(
    IN TOPL_EDGE Edge
    )
{
    return NULL;
}

static
VOID
ToplEdgeAssociate(
    IN TOPL_EDGE Edge
    )
{
    return;
}

static
VOID
ToplEdgeDisassociate(
    IN TOPL_EDGE Edge
    )
{
    return;
}

static
VOID
ToplEdgeSetWeight(
    IN TOPL_EDGE Edge,
    IN DWORD     Weight
    )
{
    return;
}

static
DWORD
ToplEdgeGetWeight(
    IN TOPL_EDGE Edge
    )
{
    return 0;
}

static
TOPL_VERTEX
ToplVertexCreate(
    VOID
    )
{
    return NULL;
}

static
VOID
ToplVertexFree(
    IN TOPL_VERTEX Vertex
    )
{
    return;
}

static
VOID
ToplVertexSetId(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Id
    )
{
    return;
}

static
DWORD
ToplVertexGetId(
    IN TOPL_VERTEX Vertex
    )
{
    return 0;
}

static
DWORD
ToplVertexNumberOfInEdges(
    IN TOPL_VERTEX Vertex
    )
{
    return 0;
}

static
TOPL_EDGE
ToplVertexGetInEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    )
{
    return NULL;
}

static
DWORD
ToplVertexNumberOfOutEdges(
    IN TOPL_VERTEX Vertex
    )
{
    return 0;
}

static
TOPL_EDGE
ToplVertexGetOutEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    )
{
    return NULL;
}

static
VOID
ToplVertexSetParent(
    IN TOPL_VERTEX Vertex,
    IN TOPL_VERTEX Parent
    )
{
    return;
}

static
TOPL_VERTEX
ToplVertexGetParent(
    IN TOPL_VERTEX Vertex
    )
{
    return NULL;
}

static
TOPL_GRAPH
ToplGraphCreate(
    VOID
    )
{
    return NULL;
}

static
VOID
ToplGraphFree(
    IN TOPL_GRAPH Graph,
    IN BOOLEAN    fRecursive    // TRUE implies recursively free the vertices
                                // that have been added to this graph
    )
{
    return;
}

static
VOID
ToplGraphAddVertex(
    IN TOPL_GRAPH  Graph,
    IN TOPL_VERTEX VertexToAdd,
    IN PVOID       VertexName
    )
{
    return;
}

static
TOPL_VERTEX
ToplGraphRemoveVertex(
    IN TOPL_GRAPH  Graph,
    IN TOPL_VERTEX VertexToRemove
    )
{
    return NULL;
}

static
VOID
ToplGraphSetVertexIter(
    IN TOPL_GRAPH    Graph,
    IN TOPL_ITERATOR Iter
    )
{
    return;
}

static
DWORD
ToplGraphNumberOfVertices(
    IN TOPL_GRAPH    Graph
    )
{
    return 0;
}

static
VOID
ToplFree(
    VOID *p
    )
{
    return;
}

static
DWORD
ToplSetAllocator(
    IN  TOPL_ALLOC *    pfAlloc     OPTIONAL,
    IN  TOPL_REALLOC *  pfReAlloc   OPTIONAL,
    IN  TOPL_FREE *     pfFree      OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
VOID
ToplGraphMakeRing(
    IN TOPL_GRAPH  Graph,
    IN DWORD       Flags,
    OUT TOPL_LIST  EdgesToAdd,
    OUT TOPL_EDGE  **EdgesToKeep,
    OUT ULONG      *cEdgesToKeep
    )
{
    return;
}


static
TOPL_COMPONENTS*
ToplGraphFindEdgesForMST(
    IN  TOPL_GRAPH  Graph,
    IN  TOPL_VERTEX RootVertex,
    IN  TOPL_VERTEX VertexOfInterest,
    OUT TOPL_EDGE  **EdgesNeeded,
    OUT ULONG*      cEdgesNeeded
    )
{
    if (EdgesNeeded != NULL) {
        *EdgesNeeded = NULL;
    }
    if (cEdgesNeeded != NULL) {
        *cEdgesNeeded = 0;
    }
    return NULL;
}

static
VOID
ToplVertexInit(
    PVERTEX V
    )
{
    return;
}

static
VOID
ToplVertexDestroy(
    PVERTEX  V
    )
{
    return;
}

static
VOID
ToplGraphInit(
    PGRAPH G
    )
{
    return;
}

static
VOID
ToplGraphDestroy(
    PGRAPH  G
    )
{
    return;
}
static
VOID
ToplEdgeInit(
    PEDGE E
    )
{
    return;
}

static
VOID
ToplEdgeDestroy(
    PEDGE  E
    )
{
    return;
}

static
int
ToplIsToplException(
    DWORD ErrorCode
    )
{
    return EXCEPTION_CONTINUE_SEARCH;
}

static
TOPL_SCHEDULE
ToplGetAlwaysSchedule(
	IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    return NULL;
}

static
TOPL_SCHEDULE_CACHE
ToplScheduleCacheCreate(
    VOID
    )
{
    return NULL;
}

static
VOID
ToplScheduleCacheDestroy(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    return;
}

static
TOPL_SCHEDULE
ToplScheduleCreate(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN DWORD IntervalInMinutes,
	IN TOPL_SCHEDULE TemplateSchedule OPTIONAL,
	IN DWORD StaggeringNumber
	)
{
    return NULL;
}

static
DWORD
ToplScheduleDuration(
	IN TOPL_SCHEDULE Schedule
	)
{
    return 0;
}

static
PSCHEDULE
ToplScheduleExportReadonly(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN TOPL_SCHEDULE Schedule
    )
{
    return NULL;
}

static
TOPL_SCHEDULE
ToplScheduleImport(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN PSCHEDULE pExternalSchedule
    )
{
    return NULL;
}

static
BOOLEAN
ToplScheduleIsEqual(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule1,
	IN TOPL_SCHEDULE Schedule2
	)
{
    return FALSE;
}

static
DWORD
ToplScheduleMaxUnavailable(
	IN TOPL_SCHEDULE Schedule
	)
{
    return 0;
}

static
TOPL_SCHEDULE
ToplScheduleMerge(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN TOPL_SCHEDULE Schedule1,
    IN TOPL_SCHEDULE Schedule2,
    OUT PBOOLEAN fIsNever
	)
{
    if (fIsNever != NULL) {
        *fIsNever = FALSE;
    }
    return NULL;
}

static
DWORD
ToplScheduleNumEntries(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    return 0;
}

static
BOOLEAN
ToplScheduleValid(
    IN TOPL_SCHEDULE Schedule
    )
{
    return FALSE;
}

static
BOOLEAN
ToplPScheduleValid(
    IN PSCHEDULE Schedule
    )
{
    return FALSE;
}

static
VOID
ToplAddEdgeSetToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE_SET s
    )
{
    return;
}

static
PTOPL_MULTI_EDGE
ToplAddEdgeToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN DWORD numVtx,
    IN DWORD edgeType,
    IN PTOPL_REPL_INFO ri
    )
{
    return NULL;
}

static
VOID
ToplDeleteComponents(
    PTOPL_COMPONENTS pComponents
    )
{
    return;
}

static
VOID
ToplDeleteGraphState(
    PTOPL_GRAPH_STATE G
    )
{
    return;
}

static
VOID
ToplDeleteSpanningTreeEdges(
    PTOPL_MULTI_EDGE *stEdgeList,
    DWORD numStEdges )
{
    return;
}

static
VOID
ToplEdgeSetVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE e,
    IN DWORD whichVtx,
    IN PVOID vtxName
    )
{
    return;
}

static
PTOPL_MULTI_EDGE*
ToplGetSpanningTreeEdgesForVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PVOID whichVtxName,
    IN TOPL_COLOR_VERTEX *colorVtx,
    IN DWORD numColorVtx,
    OUT DWORD *numStEdges,
    OUT PTOPL_COMPONENTS pComponents
    )
{
    if (numStEdges != NULL) {
        *numStEdges = 0;
    }
    return NULL;
}

static
PTOPL_GRAPH_STATE
ToplMakeGraphState(
    IN PVOID* vertexNames,
    IN DWORD numVertices, 
    IN TOPL_COMPARISON_FUNC vnCompFunc,
    IN TOPL_SCHEDULE_CACHE schedCache
    )
{
    return NULL;
}



typedef struct _TOPL_HEAP_INFO
{       
    PVOID* Array;
    ULONG cArray;
    DWORD (*pfnKey)( VOID *p ); 
    ULONG MaxElements;

} TOPL_HEAP_INFO, *PTOPL_HEAP_INFO;

static
BOOLEAN
ToplHeapCreate(
    OUT PTOPL_HEAP_INFO Heap,
    IN  ULONG           cArray,
    IN  DWORD          (*pfnKey)( VOID *p )
    )
{
    return FALSE;
}

static
VOID
ToplHeapDestroy(
    IN OUT PTOPL_HEAP_INFO Heap
    )
{
    return;
}

static
PVOID
ToplHeapExtractMin(
    IN PTOPL_HEAP_INFO Heap
    )
{
    return NULL;
}

static
VOID
ToplHeapInsert(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    )
{
    return;
}

static
BOOLEAN
ToplHeapIsEmpty(
    IN PTOPL_HEAP_INFO Heap
    )
{
    return TRUE;
}

static
BOOLEAN
ToplHeapIsElementOf(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    )
{
    return FALSE;
}

typedef int (*STHEAP_COMPARE_FUNC)( PVOID el1, PVOID el2, PVOID extra );
typedef int (*STHEAP_GET_LOCN_FUNC)( PVOID el1, PVOID extra );
typedef VOID (*STHEAP_SET_LOCN_FUNC)( PVOID el1, int l, PVOID extra ); 
typedef struct {
    DWORD                   nextFreeSpot, maxSize;
    PVOID                   *data;
    STHEAP_COMPARE_FUNC     Comp;
    STHEAP_GET_LOCN_FUNC    GetLocn;
    STHEAP_SET_LOCN_FUNC    SetLocn;
    PVOID                   extra;
} STHEAP;
typedef STHEAP *PSTHEAP;

static
PSTHEAP
ToplSTHeapInit(
    DWORD                   maxSize,
    STHEAP_COMPARE_FUNC     Comp,
    STHEAP_GET_LOCN_FUNC    GetLocn,
    STHEAP_SET_LOCN_FUNC    SetLocn,
    PVOID                   extra
    )
{
    return NULL;
}

static
VOID
ToplSTHeapDestroy(
    PSTHEAP heap
    )
{
    return;
}

static
VOID
ToplSTHeapAdd(
    PSTHEAP heap,
    PVOID element
    )
{
    return;
}

static
PVOID
ToplSTHeapExtractMin(
    PSTHEAP heap
    )
{
    return NULL;
}

static
VOID
ToplSTHeapCostReduced(
    PSTHEAP heap,
    PVOID element
    )
{
    return;
}



//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(w32topl)
{
    DLPENTRY(ToplAddEdgeSetToGraph)
    DLPENTRY(ToplAddEdgeToGraph)
    DLPENTRY(ToplDeleteComponents)
    DLPENTRY(ToplDeleteGraphState)
    DLPENTRY(ToplDeleteSpanningTreeEdges)
    DLPENTRY(ToplEdgeAssociate)
    DLPENTRY(ToplEdgeCreate)
    DLPENTRY(ToplEdgeDestroy)
    DLPENTRY(ToplEdgeDisassociate)
    DLPENTRY(ToplEdgeFree)
    DLPENTRY(ToplEdgeGetFromVertex)
    DLPENTRY(ToplEdgeGetToVertex)
    DLPENTRY(ToplEdgeGetWeight)
    DLPENTRY(ToplEdgeInit)
    DLPENTRY(ToplEdgeSetFromVertex)
    DLPENTRY(ToplEdgeSetToVertex)
    DLPENTRY(ToplEdgeSetVtx)
    DLPENTRY(ToplEdgeSetWeight)
    DLPENTRY(ToplFree)
    DLPENTRY(ToplGetAlwaysSchedule)
    DLPENTRY(ToplGetSpanningTreeEdgesForVtx)
    DLPENTRY(ToplGraphAddVertex)
    DLPENTRY(ToplGraphCreate)
    DLPENTRY(ToplGraphDestroy)
    DLPENTRY(ToplGraphFindEdgesForMST)
    DLPENTRY(ToplGraphFree)
    DLPENTRY(ToplGraphInit)
    DLPENTRY(ToplGraphMakeRing)
    DLPENTRY(ToplGraphNumberOfVertices)
    DLPENTRY(ToplGraphRemoveVertex)
    DLPENTRY(ToplGraphSetVertexIter)
    DLPENTRY(ToplHeapCreate)
    DLPENTRY(ToplHeapDestroy)
    DLPENTRY(ToplHeapExtractMin)
    DLPENTRY(ToplHeapInsert)
    DLPENTRY(ToplHeapIsElementOf)
    DLPENTRY(ToplHeapIsEmpty)
    DLPENTRY(ToplIsToplException)
    DLPENTRY(ToplIterAdvance)
    DLPENTRY(ToplIterCreate)
    DLPENTRY(ToplIterFree)
    DLPENTRY(ToplIterGetObject)
    DLPENTRY(ToplListAddElem)
    DLPENTRY(ToplListCreate)
    DLPENTRY(ToplListFree)
    DLPENTRY(ToplListNumberOfElements)
    DLPENTRY(ToplListRemoveElem)
    DLPENTRY(ToplListSetIter)
    DLPENTRY(ToplMakeGraphState)
    DLPENTRY(ToplPScheduleValid)
    DLPENTRY(ToplSTHeapAdd)
    DLPENTRY(ToplSTHeapCostReduced)
    DLPENTRY(ToplSTHeapDestroy)
    DLPENTRY(ToplSTHeapExtractMin)
    DLPENTRY(ToplSTHeapInit)
    DLPENTRY(ToplScheduleCacheCreate)
    DLPENTRY(ToplScheduleCacheDestroy)
    DLPENTRY(ToplScheduleCreate)
    DLPENTRY(ToplScheduleDuration)
    DLPENTRY(ToplScheduleExportReadonly)
    DLPENTRY(ToplScheduleImport)
    DLPENTRY(ToplScheduleIsEqual)
    DLPENTRY(ToplScheduleMaxUnavailable)
    DLPENTRY(ToplScheduleMerge)
    DLPENTRY(ToplScheduleNumEntries)
    DLPENTRY(ToplScheduleValid)
    DLPENTRY(ToplSetAllocator)
    DLPENTRY(ToplVertexCreate)
    DLPENTRY(ToplVertexDestroy)
    DLPENTRY(ToplVertexFree)
    DLPENTRY(ToplVertexGetId)
    DLPENTRY(ToplVertexGetInEdge)
    DLPENTRY(ToplVertexGetOutEdge)
    DLPENTRY(ToplVertexGetParent)
    DLPENTRY(ToplVertexInit)
    DLPENTRY(ToplVertexNumberOfInEdges)
    DLPENTRY(ToplVertexNumberOfOutEdges)
    DLPENTRY(ToplVertexSetId)
    DLPENTRY(ToplVertexSetParent)
};

DEFINE_PROCNAME_MAP(w32topl)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\ds\sam\idl\makefile.inc ===
MIDL_OPTIMIZATION_NT5=-Oicf -robust -error all -no_format_opt

SERVER_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(SERVER_ACF) -client none -header $(O)\$(SERVER_INC_FILE)
NO_STUB_FLAGS = -server none

CPP = -cpp_cmd "$(MIDL_CPP)"

$(PRIVATE_INC_PATH)\$(IDL_NAME).h: $(O)\$(@F)
    $(PUBLISH_CMD) {$?=$@}

$(O)\$(IDL_NAME).h: $(IDL_NAME).idl $(SERVER_ACF)
    $(MIDL) $(CPP) $(SERVER_FLAGS) $(NO_STUB_FLAGS) $(MIDL_INCS) $(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\inc\makefile.inc ===
#
# The contents of this file was moved from windows\makefile0
#

!IFNDEF NO_STRICT
STRICT=1
!ENDIF

TARGETSRCS= \
            $(O)\ntsecapi.h  \
            $(O)\subauth.h \
            $(O)\ntsecpkg.h \
            $(O)\aclapi.h \
            $(O)\aclapip.h \
            $(O)\sddl.h \
            $(O)\sddlp.h \
            $(O)\winsafer.h \
            $(O)\winsaferp.h \
            $(O)\wincrypt.h

secinc: $(TARGETSRCS)

clean:
    -del /q /f $(TARGETSRCS) 2>nul


NTSECAPI_DEPENDS=ntlsa.w \
                 ntsam.w \
                 ntmsv1_0.w \
                 crypt.w \
                 kerbcon.w \
                 kerberos.w

NTSECPKG_DEPENDS=ntlsa.w \
                 ntsam.w \
                 secpkg.w

#######################################################################
# subauth.h
#

$(O)\subauth.h :            ntsam.w                           \
                            $(SDK_INC_PATH)\ntstatus.h        \
                            $(DS_INC_PATH)\crypt.h            \
                            $(DS_INC_PATH)\logonmsv.h         \
                            makefile.inc
    type << > $(O)\subauth.h
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    subauth.h

Abstract:

    This module defines types and macros for Subauthentication Packages.

Revision History:

--*/

#ifndef _NTSUBAUTH_
#define _NTSUBAUTH_

#ifdef __cplusplus
extern "C" {
#endif

#if (!defined(_NTDEF_)) && (!defined(_NTSECAPI_))
typedef LONG NTSTATUS, *PNTSTATUS;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING, *PSTRING;
#endif

#ifndef _NTDEF_

typedef struct _OLD_LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} OLD_LARGE_INTEGER, *POLD_LARGE_INTEGER;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#endif

<<
    hextract -o $(O)\subauth.h -lt ntsubauth -bt begin_ntsubauth end_ntsubauth ntsam.w
    hextract -o $(O)\subauth.h -lt ntsubauth -bt begin_ntsubauth end_ntsubauth $(DS_INC_PATH)\crypt.h
    hextract -o $(O)\subauth.h -lt ntsubauth -bt begin_ntsubauth end_ntsubauth $(DS_INC_PATH)\logonmsv.h
    hextract -o $(O)\subauth.h -lt ntsubauth -bt begin_ntsubauth end_ntsubauth $(SDK_INC_PATH)\ntstatus.h
    type << >> $(O)\subauth.h
#ifdef __cplusplus
}
#endif

#endif /* _NTSUBAUTH_ */

<<

########################################################################
# ntsecapi.h
#

$(O)\ntsecapi.h : $(NTSECAPI_DEPENDS) makefile.inc
    type << > $(O)\ntsecapi.h
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    ntsecapi.h

Abstract:

    This module defines the Local Security Authority APIs.

Revision History:

--*/

#ifndef _NTSECAPI_
#define _NTSECAPI_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _NTDEF_
typedef LONG NTSTATUS, *PNTSTATUS;
#endif

<<
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi ntlsa.w
    type << >> $(O)\ntsecapi.h
#ifndef _NTDEF_
typedef LSA_UNICODE_STRING UNICODE_STRING, *PUNICODE_STRING;
typedef LSA_STRING STRING, *PSTRING ;
#endif
<<
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi ntsam.w
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi ntmsv1_0.w
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi crypt.w
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi kerbcon.w
    hextract -o $(O)\ntsecapi.h -lt ntsecapi -bt begin_ntsecapi end_ntsecapi kerberos.w
    type << >> $(O)\ntsecapi.h

#ifdef __cplusplus
}
#endif

#endif /* _NTSECAPI_ */

<<


########################################################################
# ntsecpkg.h
#
$(O)\ntsecpkg.h : $(NTSECPKG_DEPENDS) makefile.inc
    type << > $(O)\ntsecpkg.h
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    ntsecpkg.h

Abstract:

    This module defines the structures and APIs for use by a
    authentication or security package.

Revision History:

--*/

#ifndef _NTSECPKG_
#define _NTSECPKG_

#ifdef __cplusplus
extern "C" {
#endif

<<
    hextract -o $(O)\ntsecpkg.h -lt ntsecpkg -bt begin_ntsecpkg end_ntsecpkg ntlsa.w
    hextract -o $(O)\ntsecpkg.h -lt ntsecpkg -bt begin_ntsecpkg end_ntsecpkg ntsam.w
    hextract -o $(O)\ntsecpkg.h -lt ntsecpkg -bt begin_ntsecpkg end_ntsecpkg secpkg.w
    type << >> $(O)\ntsecpkg.h

#ifdef __cplusplus
}
#endif

#endif /* _NTSECPKG_ */

<<


########################################################################
# wincrypt.h
#

$(O)\wincrypt.h : wincrypt.x
    wcshdr < $? > $@


########################################################################
# aclapi.h, aclapip.h, aclapip.x, aclapi.x
#

$(O)\aclapi.x $(O)\aclapip.x: aclapi.w
    hsplit -e -o $(O)\aclapi.x $(O)\aclapip.x aclapi.w

$(O)\aclapi.h : $(O)\aclapi.x
    wcshdr < $? > $@

$(O)\aclapip.h : $(O)\aclapip.x
    wcshdr < $? > $@

$(WINDOWS_INC_PATH)\aclapip.h : $(O)\aclapip.h
    $(PUBLISH_CMD) {$?=$@}

$(SDK_INC_PATH)\aclapi.h : $(O)\aclapi.h
    $(PUBLISH_CMD) {$?=$@}


#
# sddl.h, sddlp.x, sddl.x
#

$(O)\sddl.x $(O)\sddlp.x: sddl.w
    hsplit -e -o $(O)\sddl.x $(O)\sddlp.x sddl.w

$(O)\sddl.h : $(O)\sddl.x
    wcshdr < $? > $@

$(O)\sddlp.h : $(O)\sddlp.x
    wcshdr < $? > $@

########################################################################
# winsafer.h, winsaferp.h, winsaferp.x, winsafer.x
#

$(O)\winsafer.x $(O)\winsaferp.x: winsafer.w
    hsplit -e -o $(O)\winsafer.x $(O)\winsaferp.x winsafer.w

$(O)\winsafer.h : $(O)\winsafer.x
    wcshdr < $? > $@

$(O)\winsaferp.h : $(O)\winsaferp.x
    wcshdr < $? > $@

$(WINDOWS_INC_PATH)\winsaferp.h : $(O)\winsaferp.h
    $(PUBLISH_CMD) {$?=$@}

$(SDK_INC_PATH)\winsafer.h : $(O)\winsafer.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\lsa\makefile.inc ===
MIDL_OPTIMIZATION_NT5=-Oicf -robust -error all -no_format_opt -protocol all

SERVER_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(SERVER_ACF) -client none -header $(O)\$(SERVER_INC_FILE)
NO_STUB_FLAGS = -server none

CPP = -cpp_cmd "$(MIDL_CPP)"

$(DS_INC_PATH)\$(IDL_NAME).idl: $(@F)
    $(PUBLISH_CMD) {$?=$@}

$(DS_INC_PATH)\$(SERVER_ACF): $(@F)
    $(PUBLISH_CMD) {$?=$@}

$(DS_INC_PATH)\$(IMPORT_FILE): $(@F)
    $(PUBLISH_CMD) {$?=$@}

$(DS_INC_PATH)\$(IDL_NAME).h: $(O)\$(@F)
    $(PUBLISH_CMD) {$?=$@}

$(O)\$(IDL_NAME).h: $(IDL_NAME).idl $(SERVER_ACF)
    $(MIDL) $(CPP) $(SERVER_FLAGS) $(NO_STUB_FLAGS) $(MIDL_INCS) $(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\userenv\makefile.inc ===
#
# The contents of this file was moved from windows\makefile0
#

!IFNDEF NO_STRICT
STRICT=1
!ENDIF

TARGETSRCS0= $(SDK_INC_PATH)\userenv.h

TARGETSRCS1= $(DS_INC_PATH)\userenvp.h

TARGETSRCS2= $(SDK_INC_PATH)\profinfo.h

TARGETSRCS= $(TARGETSRCS0) $(TARGETSRCS1) $(TARGETSRCS2)

wininc: $(TARGETSRCS)

#
# userenvp.h, userenv.h, userenvp.x, userenv.x
#

$(O)\userenv.x $(O)\userenvp.x: userenv.w
    hsplit -e -o $(O)\userenv.x $(O)\userenvp.x userenv.w

$(O)\userenv.h: $(O)\userenv.x
    wcshdr < $? > $@

$(O)\userenvp.h: $(O)\userenvp.x
    wcshdr < $? > $@

$(O)\profinfo.h: profinfo.w
    wcshdr < $? > $@

$(SDK_INC_PATH)\userenv.h: $(O)\userenv.h
    $(PUBLISH_CMD) {$?=$@}

$(DS_INC_PATH)\userenvp.h: $(O)\userenvp.h
    $(PUBLISH_CMD) {$?=$@}

$(SDK_INC_PATH)\profinfo.h: $(O)\profinfo.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\safealloca\alloca.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    alloca.c

Abstract:

    This module implements a safe stack-based allocator with fallback to the heap.

Author:

    Jonathan Schwartz (JSchwart)  16-Mar-2001

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>   // _resetstkoflw()

#include <alloca.h>


//
// Globals used to control SafeAlloca behavior
//

SIZE_T  g_ulMaxStackAllocSize;
SIZE_T  g_ulAdditionalProbeSize;

SAFEALLOC_ALLOC_PROC  g_pfnAllocate;
SAFEALLOC_FREE_PROC   g_pfnFree;


//
// Local function declarations
//

PVOID
SafeAllocaAllocateFromHeap(
    SIZE_T Size
    );

VOID
SafeAllocaFreeToHeap(
    PVOID BaseAddress
    );


//+-------------------------------------------------------------------------
//
//  Function:   SafeAllocaInitialize
//
//  Synopsis:   Initialize globals used to control SafeAlloca behavior
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Must be called before SafeAlloca is used to allocate space
//
//--------------------------------------------------------------------------

VOID
SafeAllocaInitialize(
    IN  OPTIONAL SIZE_T                ulMaxStackAllocSize,
    IN  OPTIONAL SIZE_T                ulAdditionalProbeSize,
    IN  OPTIONAL SAFEALLOC_ALLOC_PROC  pfnAllocate,
    IN  OPTIONAL SAFEALLOC_FREE_PROC   pfnFree
    )
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PPEB Peb = NtCurrentPeb();

    //
    // Make sure this is the first and only time the init is being called for this
    // binary (either DLL or EXE since this is a code LIB).  Otherwise, we could
    // end up with the free routine after memory is allocated using a completely
    // unrelated allocator.
    //

    ASSERT((g_pfnAllocate == NULL || g_pfnAllocate == pfnAllocate
              || (g_pfnAllocate == SafeAllocaAllocateFromHeap && pfnAllocate == NULL))
            &&
           (g_pfnFree == NULL || g_pfnFree == pfnFree
              || (g_pfnFree == SafeAllocaFreeToHeap && pfnFree == NULL)));

    if (NtCurrentPeb()->BeingDebugged)
    {
        //
        // Usermode debugger is attached to this process, which can cause issues
        // when the first-chance overflow exception on stack probes is caught by
        // the debugger rather than the probe exception handler.  Force all
        // allocations to the heap.
        //

        g_ulMaxStackAllocSize = 0;
    }
    else if (ulMaxStackAllocSize == SAFEALLOCA_USE_DEFAULT)
    {
        //
        // Default is stack size from the image header
        //

        NtHeaders = RtlImageNtHeader(Peb->ImageBaseAddress);

        if (NtHeaders == NULL)
        {
            //
            // This shouldn't happen -- it implies the binary is bad.
            // Set the default to force heap allocations only.
            //

            ASSERT(NtHeaders != NULL);
            g_ulMaxStackAllocSize = 0;
        }
        else
        {
            g_ulMaxStackAllocSize = NtHeaders->OptionalHeader.SizeOfStackCommit;
        }
    }
    else
    {
        g_ulMaxStackAllocSize = ulMaxStackAllocSize;
    }

    if (ulAdditionalProbeSize == SAFEALLOCA_USE_DEFAULT)
    {
        //
        // Default is stack size from the image header
        //

        if (NtHeaders == NULL)
        {
            NtHeaders = RtlImageNtHeader(Peb->ImageBaseAddress);
        }

        if (NtHeaders == NULL)
        {
            //
            // This shouldn't happen -- it implies the binary is bad.
            // Set the default to force heap allocations only.
            //

            ASSERT(NtHeaders != NULL);
            g_ulAdditionalProbeSize = 0xffffffff;
        }
        else
        {
            g_ulAdditionalProbeSize = NtHeaders->OptionalHeader.SizeOfStackCommit;
        }
    }
    else
    {
        g_ulAdditionalProbeSize = ulAdditionalProbeSize;
    }

    if (pfnAllocate == NULL)
    {
        g_pfnAllocate = SafeAllocaAllocateFromHeap;
    }
    else
    {
        g_pfnAllocate = pfnAllocate;
    }

    if (pfnFree == NULL)
    {
        g_pfnFree = SafeAllocaFreeToHeap;
    }
    else
    {
        g_pfnFree = pfnFree;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   SafeAllocaAllocateFromHeap
//
//  Synopsis:   Default fallback heap allocator for SafeAlloca
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  
//
//--------------------------------------------------------------------------

PVOID
SafeAllocaAllocateFromHeap(
    SIZE_T Size
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, Size);
}


//+-------------------------------------------------------------------------
//
//  Function:   SafeAllocaFreeToHeap
//
//  Synopsis:   Default fallback heap free routine for SafeAlloca
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  
//
//--------------------------------------------------------------------------

VOID
SafeAllocaFreeToHeap(
    PVOID BaseAddress
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, BaseAddress);
}


//+-------------------------------------------------------------------------
//
//  Function:   VerifyStackAvailable
//
//  Synopsis:   Routine to probe the stack to ensure the allocation size
//              plus additional probe size is available.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  
//
//--------------------------------------------------------------------------

BOOL
VerifyStackAvailable(
    SIZE_T Size
    )
{
    BOOL fStackAvailable = TRUE;

    __try
    {
        PVOID p = _alloca(Size);
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH)
    {
        fStackAvailable = FALSE;
        _resetstkoflw();
    }

    return fStackAvailable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\scard\makefile.inc ===
SCHEADERS=$(SDK_INC_PATH)\winscard.h \
          $(SDK_INC_PATH)\winsmcrd.h \
          $(SDK_INC_PATH)\scarderr.h

ALLHEADERS : $(SCHEADERS)

$(SDK_INC_PATH)\winscard.h : $(O)\winscard.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winscard.h : winscard.x
    wcshdr < $? > $@

$(SDK_INC_PATH)\winsmcrd.h : $(O)\winsmcrd.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winsmcrd.h : winsmcrd.x
    wcshdr < $? > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\published\inc\upssvc.h ===
/*++

Copyright (c) 2000 Microsoft Corporation. All rights reserved.

Module Name:

    upssvc.h

Abstract:

    This file defines the interface to the serial UPS service in 
    Windows 2000.  Please see the UPS documentation in the DDK
    for more information.


--*/

#ifndef _INC_UPS_DRIVER_H_
#define _INC_UPS_DRIVER_H_


//
// values that represent the state of the
// UPS system - these values are used in the
// UPSGetState and UPSWaitForStateChange functions
//
#define UPS_ONLINE 1
#define UPS_ONBATTERY 2
#define UPS_LOWBATTERY 4
#define UPS_NOCOMM 8
#define UPS_CRITICAL 16


//
// possible error codes returned from UPSInit
//
#define UPS_INITUNKNOWNERROR    0
#define UPS_INITOK              1
#define UPS_INITNOSUCHDRIVER    2
#define UPS_INITBADINTERFACE    3
#define UPS_INITREGISTRYERROR   4
#define UPS_INITCOMMOPENERROR   5
#define UPS_INITCOMMSETUPERROR  6


/**
* UPSInit
*
* Description:
*   
*   The UPSInit function must be called before any
*   other function in this file
*
* Parameters:
*   None
*
* Returns:
*   UPS_INITOK: Initalization was successful
*   UPS_INITNOSUCHDRIVER:   The configured driver DLL can't be opened    
*   UPS_INITBADINTERFACE:   The configured driver DLL doesn't support 
*                           the UPS driver interface
*   UPS_INITREGISTRYERROR:  The 'Options' registry value is corrupt
*   UPS_INITCOMMOPENERROR:  The comm port could not be opened
*   UPS_INITCOMMSETUPERROR: The comm port could not be configured
*   UPS_INITUNKNOWNERROR:   Undefined error has occurred
*   
*/
DWORD UPSInit(void);


/**
* UPSStop
*
* Description:
*   After a call to UPSStop, only the UPSInit
*   function is valid.  This call will unload the
*   UPS driver interface and stop monitoring of the
*   UPS system
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSStop(void);


/**
* UPSWaitForStateChange
*
* Description:
*   Blocks until the state of the UPS differs
*   from the value passed in via aCurrentState or 
*   anInterval milliseconds has expired.  If
*   anInterval has a value of INFINITE this 
*   function will never timeout
*
* Parameters:
*   aState: defines the state to wait for a change from,
*           possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*
*   anInterval: timeout in milliseconds, or INFINITE for
*               no timeout interval
*
* Returns:
*   None
*   
*/
void UPSWaitForStateChange(DWORD aCurrentState, DWORD anInterval);


/**
* UPSGetState
*
* Description:
*   returns the current state of the UPS
*
* Parameters:
*   None
*
* Returns: 
*   possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*   
*/
DWORD UPSGetState(void);


/**
* UPSCancelWait
*
* Description:
*   interrupts pending calls to UPSWaitForStateChange
*   without regard to timout or state change
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSCancelWait(void);


/**
* UPSTurnOff
*
* Description:
*   Attempts to turn off the outlets on the UPS
*   after the specified delay.  This call must
*   return immediately.  Any work, such as a timer,
*   must be performed on a another thread.
*
* Parameters:
*   aTurnOffDelay: the minimum amount of time to wait before
*                  turning off the outlets on the UPS
*
* Returns:
*   None
*   
*/
void UPSTurnOff(DWORD aTurnOffDelay);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\adtgen.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T G E N . C
//
// Contents:    definitions of types/functions required for 
//              generating generic audits.
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "authz.h"

//------------------------------------------------------------------------
//
// internal routines
//
NTSTATUS
LsapApiReturnResult(
    ULONG ExceptionCode
    );


//------------------------------------------------------------------------


BOOL
AuthzpRegisterAuditEvent(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT AUDIT_HANDLE*     phAuditContext
    )
/*++

Routine Description:
    Register the specified event with LSA. This causes LSA to
    generate and return an audit context. This context handle
    is required to publish event of the specified type.

Arguments:
    pAuditEventType - pointer to audit event info structure
                      that defines which event to register.

    phAuditContext  - pointer to audit context handle returned

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:
    Note that this function does NOT register the schema of an event. It is
    assumed that the schema has been registered *before* calling
    this function.

    The schema of legacy audit events is stored in a .mc file.

--*/
{
    DWORD dwStatus;
    
    //
    // since we use the same var to store NTSTATUS and win32 error
    // make sure that this is not a problem
    //
    ASSERT( sizeof(NTSTATUS) == sizeof(DWORD) );

    //
    // we generate a unique ID and store it in the audit handle
    // the server will copy this into the corresponding structure
    // on the server side. This ID allows us to track which server side
    // audit-context corresponds to which client side event handle.
    // This is very useful in debugging.
    //
    NtAllocateLocallyUniqueId( &pAuditEventType->LinkId );
    
    RpcTryExcept
    {
        dwStatus = LsarRegisterAuditEvent( pAuditEventType, phAuditContext );
    }
    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
    {
        dwStatus = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;
    

    if (!NT_SUCCESS(dwStatus))
    {
        dwStatus = RtlNtStatusToDosError( dwStatus );
        SetLastError( dwStatus );
        
        return FALSE;
    }
    
    return TRUE;
}


BOOL
AuthzpSendAuditToLsa(
    IN AUDIT_HANDLE  hAuditContext,
    IN DWORD         dwFlags,
    IN AUDIT_PARAMS* pAuditParams,
    IN PVOID         pReserved
    )
/*++

Routine Description:
    Send an event to LSA for publishing. 
    

Arguments:

    hAuditContext - handle of audit-context previously obtained
                    by calling LsaRegisterAuditEvent

    dwFlags       - TBD

    pAuditParams  - pointer to audit event parameters

    pReserved     - reserved for future enhancements

Return Value:

    STATUS_SUCCESS         -- if all is well
    NTSTATUS error code otherwise.

Notes:

--*/
{
    DWORD dwStatus;
    
    UNREFERENCED_PARAMETER(pReserved);

    //
    // since we use the same var to store NTSTATUS and win32 error
    // make sure that this is not a problem
    //
    ASSERT( sizeof(NTSTATUS) == sizeof(DWORD) );
    
    RpcTryExcept
    {
        dwStatus = LsarGenAuditEvent( hAuditContext, dwFlags, pAuditParams );
    }
    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
    {
        dwStatus = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(dwStatus))
    {
        dwStatus = RtlNtStatusToDosError( dwStatus );
        SetLastError( dwStatus );
        
        return FALSE;
    }
    
    return TRUE;
}


BOOL
AuthzpUnregisterAuditEvent(
    IN OUT AUDIT_HANDLE* phAuditContext
    )
/*++

Routine Description:
    Unregister the specified event. This causes LSA to
    free resources associated with the context.
    

Arguments:

    hAuditContext -  handle to the audit context to unregister

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:


--*/
{
    DWORD dwStatus;
    
    //
    // since we use the same var to store NTSTATUS and win32 error
    // make sure that this is not a problem
    //
    ASSERT( sizeof(NTSTATUS) == sizeof(DWORD) );
    
    RpcTryExcept
    {
        dwStatus = LsarUnregisterAuditEvent( phAuditContext );
    }
    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
    {
        dwStatus = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;
    
    if (!NT_SUCCESS(dwStatus))
    {
        dwStatus = RtlNtStatusToDosError( dwStatus );
        SetLastError( dwStatus );
        
        return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\adtqueue.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adtqueue.c

Abstract:

   This module implements the routines for the Authz audit queue.

Author:

    Jeff Hamblin - May 2000

Environment:

    User mode only.

Revision History:

    Created - May 2000

--*/

/*++

The Authz Audit Queue Algorithm

    The following are used in the queueing algorithm:

    hAuthzAuditQueueLowEvent - event that is signalled when threads are free 
    to place audits on the queue (queue is below high water mark).  Note that 
    this is an auto reset event: when the event is signalled, exactly one 
    waiting thread is scheduled to run and the event then returns to a 
    nonsignalled state.  

    bAuthzAuditQueueHighEvent - boolean indicating that audits may not be 
    added (queue is over high water mark).  

    hAuthzAuditAddedEvent - event that is signalled when the queue is empty and an 
    audit get placed on the queue.  The dequeueing thread runs when this is signalled.  

    hAuthzAuditQueueEmptyEvent - signals when the queue is empty.  
    
    AuthzAuditQueue - doubly linked list.  This is the audit queue.  

    AuthzAuditQueueLength - The current number of audits in the queue.  

    hAuthzAuditThread - the dequeueing thread.  
        
    AuthzAuditQueueLock - critical section locking the queue and related 
    variables.  

    Assume that the Resource Manager wishes to monitor the queue length and 
    has specified High and Low water marks to control the growth of the queue.  
    If the queue length reaches the High water mark, then all queueing threads 
    will be blocked until the dequeueing thread has reduced the queue length 
    to the Low water mark.  

    Here is the flow of code for a thread attempting to log an audit (via 
    AuthziLogAuditEvent()) when the Resource Manager is monitoring the queue 
    length: 

      if QueueLength > .75 * HighWater          # this is heuristic to save unnecessary         
         wait until the LowEvent is signalled  # kernel transitions
      enter queue critical section
      {
          insert audit on queue
          QueueLength ++
          signal AuditAddedEvent               # notifying the dequeue thread
          if (QueueLength >= HighWater)
          {
            bHigh = TRUE
          }
      } 
      leave critical section    
      
      ...[code overhead, execute cleanup code in AuthziLogAuditEvent ...]
      
      enter queue critical section
      {
          if (!bHigh)
          {   
              if (QueueLength <= HighWater)
              {    
                   signal LowEvent                  #allow other threads to run
              }
          }
                ASSERT(FALSE);
      }                   
      leave critical section
             
Here is the algorithm for the dequeueing thread:

      while (TRUE)
      {
          wait for AuditAdded event
          while (QueueLength > 0)
          {    
              enter queue critical section
              {    
                  remove audit from head of list
                  QueueLength--
                  if (bHigh)
                  {
                      if (QueueLength <= LowWater)
                      {
                          bHigh = FALSE
                          signal LowEvent                 # tell threads it is okay to queue
                      }
                  }
              }
              release critical section
              
              Send to LSA
          }
          
          enter critical section
          {
              if (QueueLength == 0)
              {
                  reset AuditAdded event                 # make myself wait 
              }
          }
          release critical section            
      }

--*/

#include "pch.h"

#pragma hdrstop

#include <authzp.h>
#include <authzi.h>

#ifdef AUTHZ_AUDIT_COUNTER
LONG AuthzpAuditsEnqueued = 0;
LONG AuthzpAuditsDequeued = 0;
#endif


BOOL
AuthzpEnQueueAuditEvent(
    PAUTHZI_AUDIT_QUEUE pQueue,
    PAUTHZ_AUDIT_QUEUE_ENTRY pAudit
    )

/*++

Routine Description

    This enqueues an audit without regard to any queue size limits.  It does minimal event management.
    
Arguments

    pQueue - Pointer to the queue to place the audit on.
    pAudit - Pointer to the audit to enqueue.
    
Return Value

    Boolean, TRUE on success, FALSE on failure.
    Extended information available with GetLastError().
    
--*/

{
    BOOL b = TRUE;

    RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
    InsertTailList(&pQueue->AuthzAuditQueue, &pAudit->list);
    pQueue->AuthzAuditQueueLength++;
    
#ifdef AUTHZ_AUDIT_COUNTER
    InterlockedIncrement(&AuthzpAuditsEnqueued);
#endif

    //
    // Only set the AuditAdded event if the length goes from 0 to 1.  This 
    // saves us redundant kernel transitions.
    //

    if (pQueue->AuthzAuditQueueLength == 1)
    {
        b = SetEvent(pQueue->hAuthzAuditAddedEvent);
        if (!b)
        {
            ASSERT(L"AUTHZ: SetEvent on hAuthzAuditAddedEvent handle failed." && FALSE);
            goto Cleanup;
        }
        
        b = ResetEvent(pQueue->hAuthzAuditQueueEmptyEvent);
        if (!b)
        {
            ASSERT(L"AUTHZ: ResetEvent on hAuthzAuditQueueEmptyEvent handle failed." && FALSE);
            goto Cleanup;
        }
    }

Cleanup:

    RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);
    return b;
}


BOOL
AuthzpEnQueueAuditEventMonitor(
    PAUTHZI_AUDIT_QUEUE pQueue,
    PAUTHZ_AUDIT_QUEUE_ENTRY pAudit
    )

/*++

Routine Description

    This enqueues an audit and sets appropriate events for queue size monitoring.
    
Arguments

    pQueue - pointer to the queue to place audit on.
    pAudit - pointer to the audit to queue.
    
Return Value

    Boolean, TRUE on success, FALSE on failure.
    Extended information available with GetLastError().
    
--*/

{
    BOOL b = TRUE;

    RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
    InsertTailList(&pQueue->AuthzAuditQueue, &pAudit->list);
    pQueue->AuthzAuditQueueLength++;
    
#ifdef AUTHZ_AUDIT_COUNTER
    InterlockedIncrement(&AuthzpAuditsEnqueued);
#endif

    //
    // Only set the AuditAdded event if the length goes from 0 to 1.  This 
    // saves us redundant kernel transitions.
    //

    if (pQueue->AuthzAuditQueueLength == 1)
    {
        b = SetEvent(pQueue->hAuthzAuditAddedEvent);
        if (!b)
        {
            ASSERT(L"AUTHZ: SetEvent on hAuthzAuditAddedEvent handle failed." && FALSE);
            goto Cleanup;
        }

        b = ResetEvent(pQueue->hAuthzAuditQueueEmptyEvent);
        if (!b)
        {
            ASSERT(L"AUTHZ: ResetEvent on hAuthzAuditQueueEmptyEvent handle failed." && FALSE);
            goto Cleanup;
        }
    }

    if (pQueue->AuthzAuditQueueLength >= pQueue->dwAuditQueueHigh)
    {
#ifdef AUTHZ_DEBUG_QUEUE
        wprintf(L"___Setting HIGH water mark ON\n");
        fflush(stdout);
#endif
        pQueue->bAuthzAuditQueueHighEvent = TRUE;
    }

Cleanup:

    RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);
    return b;
}


ULONG
AuthzpDeQueueThreadWorker(
    LPVOID lpParameter
    )

/*++

Routine Description

    This is the function run by the dequeueing thread.  It pulls audits from the queue 
    and sends them to LSA.
    
Arguments

    lpParameter - generic thread parameter.  The actual parameter passed in is of 
        type PAUTHZI_AUDIT_QUEUE.
    
Return Value

    None.
    
--*/

{
    BOOL                     b;
    PAUTHZ_AUDIT_QUEUE_ENTRY pAuditEntry  = NULL; 
    PAUTHZI_AUDIT_QUEUE      pQueue       = (PAUTHZI_AUDIT_QUEUE) lpParameter;
    DWORD                    dwError;

    while (pQueue->bWorker)
    {

        //
        // The thread waits until there are audits in the queue.
        //

        dwError = WaitForSingleObject(
                     pQueue->hAuthzAuditAddedEvent,
                     INFINITE
                     );

        //
        // If the wait does not succeed either something is very wrong or the hAuthzAuditAddedEvent 
        // was closed, indicating that the RM is freeing its hRMAuditInfo.  The thread should exit.
        //

        if (WAIT_OBJECT_0 != dwError)
        {
            ASSERT(L"WaitForSingleObject on hAuthzAuditAddedEvent failed." && FALSE);
        }

        //
        // The thread remains active while there are audits in the queue.
        //

        while (pQueue->AuthzAuditQueueLength > 0)
        {
            RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
            pAuditEntry = (PAUTHZ_AUDIT_QUEUE_ENTRY) (pQueue->AuthzAuditQueue).Flink;
            RemoveEntryList(&pAuditEntry->list);
            pQueue->AuthzAuditQueueLength--;

#ifdef AUTHZ_AUDIT_COUNTER
            InterlockedIncrement(&AuthzpAuditsDequeued);
#endif
            
            if (FLAG_ON(pQueue->Flags, AUTHZ_MONITOR_AUDIT_QUEUE_SIZE))
            {
                if (TRUE == pQueue->bAuthzAuditQueueHighEvent)
                {
                    if (pQueue->AuthzAuditQueueLength <= pQueue->dwAuditQueueLow)
                    {
                        
                        //
                        // If the High flag is on and the length is now reduced to the low water mark, then
                        // set appropriate events.
                        //
                        
                        pQueue->bAuthzAuditQueueHighEvent = FALSE;
                        b = SetEvent(pQueue->hAuthzAuditQueueLowEvent);
                        if (!b)
                        {
                            ASSERT(L"SetEvent on hAuthzAuditQueueLowEvent failed." && FALSE);
                        }
#ifdef AUTHZ_DEBUG_QUEUE
        wprintf(L"** _____ TURNING HIGH WATER OFF _____\n");
        fflush(stdout);
#endif
                    }
                }
            }
            
            RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);

            b = AuthzpSendAuditToLsa(
                    (AUDIT_HANDLE)(pAuditEntry->pAAETO->hAudit),
                    pAuditEntry->Flags,
                    pAuditEntry->pAuditParams,
                    pAuditEntry->pReserved
                    );

#ifdef AUTHZ_DEBUG_QUEUE
            if (!b)
            {
                DbgPrint("Error in AuthzpSendAuditToLsa() :: Error = %d = 0x%x\n", GetLastError(), GetLastError());
                DbgPrint("Context = 0x%x\n", pAuditEntry->pAAETO->hAudit);
                DbgPrint("Flags   = 0x%x\n", pAuditEntry->Flags);
                DbgPrint("Params  = 0x%x\n", pAuditEntry->pAuditParams);
                ASSERT(FALSE);
            }
#endif
            b = AuthzpDereferenceAuditEventType((AUTHZ_AUDIT_EVENT_TYPE_HANDLE)pAuditEntry->pAAETO);
            if (!b)
            {
                ASSERT(FALSE && L"Deref AuditEventType failed.");
            }
            AuthzpFree(pAuditEntry->pAuditParams);
            AuthzpFree(pAuditEntry);
        }

        RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
        if (0 == pQueue->AuthzAuditQueueLength)
        {
            b = ResetEvent(pQueue->hAuthzAuditAddedEvent);
            if (!b)
            {
                ASSERT(L"ResetEvent on hAuthzAuditAddedEvent failed." && FALSE);
            }
            b = SetEvent(pQueue->hAuthzAuditQueueEmptyEvent);
            if (!b)
            {
                ASSERT(L"SetEvent on hAuthzAuditQueueEmptyEvent failed." && FALSE);
            }
        }
        RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);
    }
    
    return STATUS_SUCCESS;
}


BOOL
AuthzpCreateAndLogAudit(
    IN DWORD AuditTypeFlag,
    IN PAUTHZI_CLIENT_CONTEXT pAuthzClientContext,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent,
    IN PAUTHZI_RESOURCE_MANAGER pRM,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PAUTHZ_ACCESS_REPLY pReply
    )

/*++

Routine Description

    This is called from AuthzpGenerateAudit as a wrapper around LSA and
    AuthziLogAuditEvent functionality.  It places the appropriate audit
    information on a queue for sending to LSA.

Arguments

    AuditTypeFlag - mask to specify success | failure audit generation.  Only
    one bit at a time.

    pAuthzClientContext - pointer to Authz context representing the client.

    pAuditEvent - Object specific audit info will be passed in this structure.

    pRM - Resource manager that generates the audit.

    LocalTypeList - Internal object type list structure.

    pRequest - specifies the desired access mask, principal self sid, the
    object type list structure (if any).

    pReply - The reply structure to return the results.

Return Value

    TRUE if successful, FALSE if not.
    Extended information available with GetLastError().

--*/

{

#define AUTHZ_BUFFER_CAPTURE_MAX 200

    BOOL                b;
    AUDIT_PARAMS        AuditParams                          = {0};
    AUDIT_PARAM         ParamArray[SE_MAX_AUDIT_PARAMETERS]  = {0};
    PAUTHZI_AUDIT_EVENT pCapturedAuditEvent                  = NULL;
    UCHAR               pBuffer[AUTHZ_BUFFER_CAPTURE_MAX]    = {0};
    AUDIT_OBJECT_TYPE   FixedObjectTypeToAudit               = {0};
    AUDIT_OBJECT_TYPES  ObjectTypeListAudit                  = {0};
    PAUDIT_OBJECT_TYPE  ObjectTypesToAudit                   = NULL;
    USHORT              ObjectTypeAuditCount                 = 0;
    LONG                i                                    = 0;
    LONG                j                                    = 0;
    DWORD               APF_AuditTypeFlag                    = 0;
    ACCESS_MASK         MaskToAudit                          = 0;
    
    //
    // Capture pAuditEvent, as we may change the pAuditParams member and would like to
    // avoid the inevitable race that would follow.
    //

    if (AUTHZ_BUFFER_CAPTURE_MAX >= pAuditEvent->dwSize)
    {
        pCapturedAuditEvent = (PAUTHZI_AUDIT_EVENT) pBuffer;
        RtlCopyMemory(
            pCapturedAuditEvent,
            pAuditEvent,
            pAuditEvent->dwSize
            );
    }
    else
    {
        pCapturedAuditEvent = AuthzpAlloc(pAuditEvent->dwSize);
        
        if (AUTHZ_ALLOCATION_FAILED(pCapturedAuditEvent))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        RtlCopyMemory(
            pCapturedAuditEvent,
            pAuditEvent,
            pAuditEvent->dwSize
            );

    }

    //
    // Make sure only one valid bit is on in the AuditTypeFlag.  If a RM needs to generate
    // both success and failure audits, then two separate calls should be made.
    //

    ASSERT(!(
              FLAG_ON(AuditTypeFlag, AUTHZ_OBJECT_SUCCESS_AUDIT) &&
              FLAG_ON(AuditTypeFlag, AUTHZ_OBJECT_FAILURE_AUDIT)
             ));

    //
    // Set the APF_AuditTypeFlag.  LSA has its own flags for audit success
    // and audit failure.  Authz must map the Authz flag to the LSA APF equivalent.
    //

    if (FLAG_ON(AuditTypeFlag, AUTHZ_OBJECT_SUCCESS_AUDIT))
    {
        APF_AuditTypeFlag = APF_AuditSuccess;
        
        //
        // Test if the RM specifically disabled success audits
        //

        if (FLAG_ON(pCapturedAuditEvent->Flags, AUTHZ_NO_SUCCESS_AUDIT))
        {
            b = TRUE;
            goto Cleanup;
        }
    }
    else if (FLAG_ON(AuditTypeFlag, AUTHZ_OBJECT_FAILURE_AUDIT))
    {
        APF_AuditTypeFlag = APF_AuditFailure;
        
        //
        // Test if the RM specifically disabled failure audits
        //

        if (FLAG_ON(pCapturedAuditEvent->Flags, AUTHZ_NO_FAILURE_AUDIT))
        {
            b = TRUE;
            goto Cleanup;
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

    //
    // Set the AUTHZ_AUDIT_QUEUE_HANDLE and AUTHZ_AUDIT_EVENT_TYPE_HANDLE of the AuditEvent if they are not yet set.
    // 

    if (NULL == pCapturedAuditEvent->hAET)
    {
        if (FLAG_ON(pCapturedAuditEvent->Flags, AUTHZ_DS_CATEGORY_FLAG))
        {
            pCapturedAuditEvent->hAET = pRM->hAETDS;
        }
        else
        {
            pCapturedAuditEvent->hAET = pRM->hAET;
        }
    }

    if (NULL == pAuditEvent->hAuditQueue)
    {
        pCapturedAuditEvent->hAuditQueue = pRM->hAuditQueue;
        InterlockedCompareExchangePointer(
            &pAuditEvent->hAuditQueue,
            pRM->hAuditQueue,
            NULL
            );
    }
    
    //
    // Decide what access bits we should audit
    //

    MaskToAudit = (APF_AuditTypeFlag == APF_AuditSuccess) ? pReply->GrantedAccessMask[0] : pRequest->DesiredAccess;

    //
    // If the RM gives us an AUDIT_PARAMS structure to marshall, then we don't
    // need to generate our own.
    //

    if (AUTHZ_NON_NULL_PTR(pCapturedAuditEvent->pAuditParams))
    {
        
        // 
        // Capture the AuditParams so that we can change the User SID without racing.
        //

        RtlCopyMemory(
            &AuditParams, 
            pCapturedAuditEvent->pAuditParams, 
            sizeof(AUDIT_PARAMS)
            );

        ASSERT(pCapturedAuditEvent->pAuditParams->Count <= SE_MAX_AUDIT_PARAMETERS);

        RtlCopyMemory(
            ParamArray, 
            pCapturedAuditEvent->pAuditParams->Parameters, 
            sizeof(AUDIT_PARAM) * pCapturedAuditEvent->pAuditParams->Count
            );

        AuditParams.Parameters = ParamArray;

        //
        // Replace the SID in the AUDIT_PARAMS with the SID of the current Client Context.
        //

        if (AUTHZ_NON_NULL_PTR(pAuthzClientContext->Sids[0].Sid))
        {
            AuditParams.Parameters[0].Data0 = (ULONG_PTR) pAuthzClientContext->Sids[0].Sid;
        }

        AuditParams.Flags = APF_AuditTypeFlag;

        pCapturedAuditEvent->pAuditParams = &AuditParams;

        b = AuthziLogAuditEvent(
                0,
                (AUTHZ_AUDIT_EVENT_HANDLE)pCapturedAuditEvent,
                0
                );

        goto Cleanup;
    }

    //
    // The caller has not given us an audit to generate.  We will create one, provided that
    // the AuditID specifies the generic object access (SE_AUDITID_OBJECT_OPERATION)
    //

    if ((NULL != pCapturedAuditEvent->hAET) && 
        (((PAUTHZ_AUDIT_EVENT_TYPE_OLD)pCapturedAuditEvent->hAET)->u.Legacy.AuditId != SE_AUDITID_OBJECT_OPERATION))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

    //
    // Create the generic object access audit.  There are two codepaths
    // that initialize the AuditParams structure.  The first path is taken if
    // there is no ObjectTypeList.  The second path is taken if there is an
    // ObjectTypeList.
    //

    AuditParams.Parameters           = ParamArray;
    pCapturedAuditEvent->pAuditParams = &AuditParams;

    //
    // Check if there is an ObjectTypeList.
    //

    if (AUTHZ_NON_NULL_PTR(pRequest->ObjectTypeList))
    {

        //
        // If the length of the structure is 1 then the caller only wants access
        // at the root of the tree.
        //

        if (1 == pReply->ResultListLength)
        {

            //
            // Caller only wants access at ObjectTypeList root, so only one ObjectType to
            // audit.  For efficiency simply use the stack variable.
            //

            ObjectTypesToAudit                = &FixedObjectTypeToAudit;
            ObjectTypeAuditCount              = 1;
            FixedObjectTypeToAudit.AccessMask = pReply->GrantedAccessMask[0];

            RtlCopyMemory(
                &FixedObjectTypeToAudit.ObjectType,
                &LocalTypeList[0].ObjectType,
                sizeof(GUID)
                );
        }
        else
        {

            //
            // The caller wants more than access at ObjectTypeList root.  He wants the
            // whole thing.
            //

            //
            // Determine how many GUIDs the client has access to which should be audited
            //

            for (ObjectTypeAuditCount = 0, i = 0; i < (LONG) pReply->ResultListLength; i++)
            {
                if (FLAG_ON(LocalTypeList[i].Flags, AuditTypeFlag))
                {
                    ObjectTypeAuditCount++;
                }
            }

            //
            // Allocate appropriate storage space for GUID list
            //

            ObjectTypesToAudit = AuthzpAlloc(sizeof(AUDIT_OBJECT_TYPE) * ObjectTypeAuditCount);

            if (AUTHZ_ALLOCATION_FAILED(ObjectTypesToAudit))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                b = FALSE;
                goto Cleanup;
            }

            RtlZeroMemory(
                ObjectTypesToAudit,
                sizeof(AUDIT_OBJECT_TYPE) * ObjectTypeAuditCount
                );

            for (i = 0, j = -1; i < ObjectTypeAuditCount; i++)
            {

                //
                // One counter tracks position in the alloc'ed array of ObjectTypesToAudit.
                // The other counter picks out the indices in the pReply and LocalTypeList
                // structures that need to be audited for success.
                //

                //
                // find the next GUID to audit in pReply that client was granted access to.
                //

                do
                {
                    j++;
                }
                while (!FLAG_ON(LocalTypeList[j].Flags, AuditTypeFlag));

                //
                // In the success audit, the AccessMask records the actual
                // granted bits.
                //

                ObjectTypesToAudit[i].AccessMask = pReply->GrantedAccessMask[j];
                ObjectTypesToAudit[i].Level      = LocalTypeList[j].Level;
                ObjectTypesToAudit[i].Flags      = 0;

                RtlCopyMemory(
                    &ObjectTypesToAudit[i].ObjectType,
                    &LocalTypeList[j].ObjectType,
                    sizeof(GUID)
                    );
            }

        }

        ObjectTypeListAudit.Count        = ObjectTypeAuditCount;
        ObjectTypeListAudit.pObjectTypes = ObjectTypesToAudit;
        ObjectTypeListAudit.Flags        = 0;

        b = AuthziInitializeAuditParamsWithRM(
                APF_AuditTypeFlag,
                (AUTHZ_RESOURCE_MANAGER_HANDLE)pRM,
                AUTHZP_NUM_PARAMS_FOR_SE_AUDITID_OBJECT_OPERATION,
                &AuditParams,
                APT_String,         pRM->szResourceManagerName,
                APT_String,         pCapturedAuditEvent->szOperationType,
                APT_String,         pCapturedAuditEvent->szObjectType,
                APT_String,         pCapturedAuditEvent->szObjectName,
                APT_String,         L"-",
                APT_LogonId | AP_PrimaryLogonId,
                APT_LogonId,  pAuthzClientContext->AuthenticationId,
                APT_Ulong   | AP_AccessMask, MaskToAudit, 2,
                APT_ObjectTypeList, &ObjectTypeListAudit, 2,
                APT_String,         pCapturedAuditEvent->szAdditionalInfo,
                APT_String,         pCapturedAuditEvent->szAdditionalInfo2,
                APT_Ulong   | AP_FormatHex,  MaskToAudit
                );

        if (!b)
        {
#ifdef AUTHZ_DEBUG_QUEUE
            DbgPrint("AuthzInitializeAuditParams failed %d\n", GetLastError());
#endif
            goto Cleanup;
        }
    } // matches "if (AUTHZ_NON_NULL_PTR(pRequest->ObjectTypeList))"
    else
    {
        b = AuthziInitializeAuditParamsWithRM(
                APF_AuditTypeFlag,
                (AUTHZ_RESOURCE_MANAGER_HANDLE)pRM,
                AUTHZP_NUM_PARAMS_FOR_SE_AUDITID_OBJECT_OPERATION,
                &AuditParams,
                APT_String,         pRM->szResourceManagerName,
                APT_String,         pCapturedAuditEvent->szOperationType,
                APT_String,         pCapturedAuditEvent->szObjectType,
                APT_String,         pCapturedAuditEvent->szObjectName,
                APT_String,         L"-",
                APT_LogonId | AP_PrimaryLogonId,
                APT_LogonId,  pAuthzClientContext->AuthenticationId,
                APT_Ulong   | AP_AccessMask, MaskToAudit, 2,
                APT_String,         L"-",
                APT_String,         pCapturedAuditEvent->szAdditionalInfo,
                APT_String,         pCapturedAuditEvent->szAdditionalInfo2,
                APT_Ulong   | AP_FormatHex,  MaskToAudit
                );

        if (!b)
        {
#ifdef AUTHZ_DEBUG_QUEUE
            DbgPrint("AuthzInitializeAuditParams failed %d\n", GetLastError());
#endif
            goto Cleanup;
        }
    }

    //
    // Replace the SID in the AUDIT_PARAMS with the SID of the current Client Context.
    //

    if (AUTHZ_NON_NULL_PTR(pAuthzClientContext->Sids[0].Sid))
    {
        //
        // Free an existing sid if alloc'd from heap
        //

        if (pCapturedAuditEvent->pAuditParams->Parameters[0].Data0 &&
            pCapturedAuditEvent->pAuditParams->Parameters[0].Type == APT_Sid &&
            (pCapturedAuditEvent->pAuditParams->Parameters[0].Flags & AUTHZP_PARAM_FREE_SID))
        {
            AuthzpFree((PVOID)(pCapturedAuditEvent->pAuditParams->Parameters[0].Data0));
            pCapturedAuditEvent->pAuditParams->Parameters[0].Flags &= ~AUTHZP_PARAM_FREE_SID;
        }

        pCapturedAuditEvent->pAuditParams->Parameters[0].Data0 = (ULONG_PTR) pAuthzClientContext->Sids[0].Sid;
    }

    //
    // At this point, AuditParams is initialized for an audit.  Send to the LSA.
    //

    b = AuthziLogAuditEvent(
            0,
            (AUTHZ_AUDIT_EVENT_HANDLE)pCapturedAuditEvent,
            0
            );

    if (!b)
    {
        goto Cleanup;
    }

Cleanup:

    if (ObjectTypesToAudit != &FixedObjectTypeToAudit)
    {
        AuthzpFreeNonNull(ObjectTypesToAudit);
    }

    if (pCapturedAuditEvent != (PAUTHZI_AUDIT_EVENT)pBuffer)
    {
        AuthzpFreeNonNull(pCapturedAuditEvent);
    }

    return b;
}


BOOL
AuthzpMarshallAuditParams(
    OUT PAUDIT_PARAMS * ppMarshalledAuditParams,
    IN  PAUDIT_PARAMS   pAuditParams
    )

/*++

Routine Description:

    This routine will take an AUDIT_PARAMS structure and create a new 
    structure that is suitable for sending to LSA.  It will be allocated 
    as a single chunk of memory.  

Arguments:

    ppMarshalledAuditParams - pointer to pointer that will receive the 
        marshalled audit parameters.  This memory is allocated within the routine.  
        The dequeue thread frees this memory.  

    pAuditParams - Original, unmarshalled version of the AUDIT_PARAMS.  

Return Value:

    Boolean: TRUE if success, FALSE if failure.  
    Extended information available with GetLastError().

--*/

{
    DWORD           i                        = 0;
    DWORD           AuditParamsSize          = 0;
    PAUDIT_PARAMS   pMarshalledAuditParams   = NULL;
    BOOL            b                        = TRUE;
    PUCHAR          Base                     = NULL;
    PUCHAR          inData0                  = NULL;
    
    *ppMarshalledAuditParams = NULL;

    //
    // Begin calculating the total size required for the marshalled version
    // of pAuditParams.
    //

    AuditParamsSize = sizeof(AUDIT_PARAMS) + sizeof(AUDIT_PARAM) * pAuditParams->Count;
    AuditParamsSize = PtrAlignSize( AuditParamsSize );

    //
    // Determine how much memory each parameter requires.
    //

    for (i = 0; i < pAuditParams->Count; i++) 
    {   
        inData0 = (PUCHAR) pAuditParams->Parameters[i].Data0;

        switch (pAuditParams->Parameters[i].Type)
        {
        case APT_String:
            {

                //
                // wcslen returns the number of characters, excluding the terminating NULL.  Must check for NULL 
                // because the AdditionalInfo string is OPTIONAL.
                //

                if (AUTHZ_NON_NULL_PTR(inData0))
                {
                    AuditParamsSize += (DWORD)(sizeof(WCHAR) * wcslen((PWSTR) inData0) + sizeof(WCHAR));
                    AuditParamsSize = PtrAlignSize( AuditParamsSize );
                }
                break;
            }
        case APT_Pointer:
        case APT_Ulong:
        case APT_Int64:
        case APT_LogonId:
        case APT_Luid:
        case APT_Time:
            {
                break;
            }
        case APT_Sid:
            {
                AuditParamsSize += RtlLengthSid((PSID) inData0);
                AuditParamsSize = PtrAlignSize( AuditParamsSize );
                break;
            }
        case APT_Guid:
            {
                AuditParamsSize += sizeof(GUID);
                AuditParamsSize = PtrAlignSize( AuditParamsSize );
                break;
            }
        case APT_ObjectTypeList:
            {
                AUDIT_OBJECT_TYPES * aot = (AUDIT_OBJECT_TYPES *) inData0;

                //
                // Need space for AUDIT_OBJECT_TYPES structure, and the AUDIT_OBJECT_TYPE 
                // array that it contains.
                //

                AuditParamsSize += sizeof (AUDIT_OBJECT_TYPES);
                AuditParamsSize = PtrAlignSize( AuditParamsSize );
                AuditParamsSize += sizeof(AUDIT_OBJECT_TYPE) * aot->Count;
                AuditParamsSize = PtrAlignSize( AuditParamsSize );
                break;
            }
        default:
            {
                ASSERT(L"Invalid Authz audit parameter" && FALSE);
                SetLastError(ERROR_INVALID_PARAMETER);
                b = FALSE;
                break;
            }
        }

        if (!b)
        {
            goto Cleanup;
        }
    }

    //
    // Allocate space for the marshalled blob.
    //

    pMarshalledAuditParams = (PAUDIT_PARAMS) AuthzpAlloc(AuditParamsSize);

    if (AUTHZ_ALLOCATION_FAILED(pMarshalledAuditParams))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        b = FALSE;
        goto Cleanup;
    }

    //
    // Set the fields of the marshalled AUDIT_PARAMS
    //

    pMarshalledAuditParams->Count      = pAuditParams->Count;
    pMarshalledAuditParams->Flags      = pAuditParams->Flags;
    pMarshalledAuditParams->Length     = pAuditParams->Length;
    pMarshalledAuditParams->Parameters = (AUDIT_PARAM *)((PUCHAR)pMarshalledAuditParams + sizeof(AUDIT_PARAMS));

    //
    // Base points to the beginning of the "data" section of the marshalled space, 
    // that is, Base is the area to copy member fields in and subsequently point at.
    //

    Base = (PUCHAR)pMarshalledAuditParams;
    Base += PtrAlignSize( sizeof(AUDIT_PARAMS) + sizeof(AUDIT_PARAM) * pAuditParams->Count );

    ASSERT(Base > (PUCHAR)pMarshalledAuditParams);
    ASSERT(Base < (PUCHAR)((PUCHAR)pMarshalledAuditParams + AuditParamsSize));

    //
    // Move the Parameters array into the marshalled blob.
    //

    RtlCopyMemory(
        pMarshalledAuditParams->Parameters,
        pAuditParams->Parameters,
        sizeof(AUDIT_PARAM) * pAuditParams->Count
        );

    for (i = 0; i < pMarshalledAuditParams->Count; i++) 
    {
        inData0 = (PUCHAR) pAuditParams->Parameters[i].Data0;

        switch (pMarshalledAuditParams->Parameters[i].Type)
        {
        case APT_String:
            {
                if (AUTHZ_NON_NULL_PTR(inData0))
                {
                    DWORD StringLength = (DWORD)(sizeof(WCHAR) * wcslen((PWSTR) inData0) + sizeof(WCHAR));
                    pMarshalledAuditParams->Parameters[i].Data0 = (ULONG_PTR) Base;

                    RtlCopyMemory(
                        (PVOID) Base,
                        (PWSTR) inData0,
                        StringLength
                        );

                    Base += PtrAlignSize( StringLength );
                    ASSERT(Base > (PUCHAR)pMarshalledAuditParams);
                    ASSERT(Base <= (PUCHAR)((PUCHAR)pMarshalledAuditParams + AuditParamsSize));
                }
                break;
            }
        case APT_Pointer:
        case APT_Ulong:
        case APT_LogonId:
        case APT_Luid:
        case APT_Time:
            {
                break;
            }
        case APT_Sid:
            {
                DWORD SidLength = RtlLengthSid((PSID) inData0);
                pMarshalledAuditParams->Parameters[i].Data0 = (ULONG_PTR) Base;

                RtlCopyMemory(
                    (PVOID) Base,
                    (PSID) inData0,
                    SidLength
                    );
                Base += PtrAlignSize( SidLength );
                ASSERT(Base > (PUCHAR)pMarshalledAuditParams);
                ASSERT(Base <= (PUCHAR)((PUCHAR)pMarshalledAuditParams + AuditParamsSize));
                break;
            }
        case APT_Guid:
            {
                pMarshalledAuditParams->Parameters[i].Data0 = (ULONG_PTR) Base;

                RtlCopyMemory(
                    (PVOID) Base,
                    (GUID *) inData0,
                    sizeof(GUID)
                    );
                Base += PtrAlignSize( sizeof(GUID) );
                ASSERT(Base > (PUCHAR)pMarshalledAuditParams);
                ASSERT(Base <= (PUCHAR)((PUCHAR)pMarshalledAuditParams + AuditParamsSize));
                break;
            }
        case APT_ObjectTypeList:
            {
                AUDIT_OBJECT_TYPES *aot = (AUDIT_OBJECT_TYPES *) inData0;
                DWORD OTLength = sizeof(AUDIT_OBJECT_TYPE) * aot->Count;
                
                pMarshalledAuditParams->Parameters[i].Data0 = (ULONG_PTR) Base;

                //
                // Copy the AUDIT_OBJECT_TYPES structure
                //

                RtlCopyMemory(
                    (PVOID) Base,
                    aot,
                    sizeof(AUDIT_OBJECT_TYPES)
                    );

                Base += PtrAlignSize( sizeof(AUDIT_OBJECT_TYPES) );

                //
                // Point the pObjectTypes field at the end of the copied blob.
                //

                ((AUDIT_OBJECT_TYPES *)pMarshalledAuditParams->Parameters[i].Data0)->pObjectTypes = (AUDIT_OBJECT_TYPE *) Base;

                //
                // Copy the AUDIT_OBJECT_TYPE array (pObjectTypes)
                //

                RtlCopyMemory(
                    (PVOID) Base,
                    (AUDIT_OBJECT_TYPE *) aot->pObjectTypes,
                    OTLength
                    );
                
                Base += PtrAlignSize( OTLength );
                ASSERT(Base > (PUCHAR)pMarshalledAuditParams);
                ASSERT(Base <= (PUCHAR)((PUCHAR)pMarshalledAuditParams + AuditParamsSize));
                break;
            }
        default:
            {
                ASSERT(L"Invalid Authz audit parameter" && FALSE);
                b = FALSE;
                SetLastError(ERROR_INVALID_PARAMETER);
                break;
            }
        }

        if (!b)
        {
            goto Cleanup;
        }
    }

    //
    // Sanity check on the Base value.  If this assertion passes, then I have
    // not exceeded my allocated space.
    //

    ASSERT(Base == ((PUCHAR)pMarshalledAuditParams + AuditParamsSize));

Cleanup:
    
    if (b)
    {
        *ppMarshalledAuditParams = pMarshalledAuditParams;
    }
    else
    {
        AuthzpFreeNonNull(pMarshalledAuditParams);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\authz.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    authz.c

Abstract:

   This module implements the user mode authorization APIs exported to the
   external world.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/

#include "pch.h"

#pragma hdrstop

#include <authzp.h>
#include <authzi.h>
#include <sddl.h>
#include <overflow.h>

GUID AuthzpNullGuid = { 0 };

DWORD
DeleteKeyRecursivelyW(
    IN HKEY   hkey,
    IN LPCWSTR pwszSubKey
    );

BOOL
AuthzAccessCheck(
    IN     DWORD                              Flags,
    IN     AUTHZ_CLIENT_CONTEXT_HANDLE        hAuthzClientContext,
    IN     PAUTHZ_ACCESS_REQUEST              pRequest,
    IN     AUTHZ_AUDIT_EVENT_HANDLE           hAuditEvent OPTIONAL,
    IN     PSECURITY_DESCRIPTOR               pSecurityDescriptor,
    IN     PSECURITY_DESCRIPTOR               *OptionalSecurityDescriptorArray OPTIONAL,
    IN     DWORD                              OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY                pReply,
    OUT    PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults             OPTIONAL
    )

/*++

Routine Description:

    This API decides what access bits may be granted to a client for a given set
    of security security descriptors. The pReply structure is used to return an
    array of granted access masks and error statuses. There is an option to
    cache the access masks that will always be granted. A handle to cached
    values is returned if the caller asks for caching.

Arguments:

    Flags - AUTHZ_ACCESS_CHECK_NO_DEEP_COPY_SD - do not deep copy the SD information into the caching
                                    handle.  Default behaviour is to perform a deep copy.

    hAuthzClientContext - Authz context representing the client.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    hAuditEvent - Object specific audit event will be passed in this handle.
        Non-null parameter is an automatic request for audit. 
        
    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primay security descriptor.

    pReply - Supplies a pointer to a reply structure used to return the results
        of access check as an array of (GrantedAccessMask, ErrorValue) pairs.
        The number of results to be returned in supplied by the caller in
        pResult->ResultListLength.

        Expected error values are:

          ERROR_SUCCESS - If all the access bits (not including MAXIMUM_ALLOWED)
            are granted and GrantedAccessMask is not zero.

          ERROR_PRIVILEGE_NOT_HELD - if the DesiredAccess includes
          ACCESS_SYSTEM_SECURITY and the client does not have SeSecurityPrivilege.

          ERROR_ACCESS_DENIED in each of the following cases -
            1. any of the bits asked for is not granted.
            2. MaximumAllowed bit it on and granted access is zero.
            3. DesiredAccess is 0.

    phAccessCheckResults - Supplies a pointer to return a handle to the cached results
        of access check. Non-null phAccessCheckResults is an implicit request to cache
        results of this access check call and will result in a MAXIMUM_ALLOWED
        check.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL                   b                    = TRUE;
    DWORD                  LocalTypeListLength  = 0;
    PIOBJECT_TYPE_LIST     LocalTypeList        = NULL;
    PIOBJECT_TYPE_LIST     LocalCachingTypeList = NULL;
    PAUTHZI_CLIENT_CONTEXT pCC                  = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    PAUTHZI_AUDIT_EVENT    pAuditEvent          = (PAUTHZI_AUDIT_EVENT) hAuditEvent;
    IOBJECT_TYPE_LIST      FixedTypeList        = {0};
    IOBJECT_TYPE_LIST      FixedCachingTypeList = {0};

    UNREFERENCED_PARAMETER(Flags);

#ifdef AUTHZ_PARAM_CHECK
    //
    // Verify that the arguments passed are valid.
    // Also, initialize the output parameters to default.
    //

    b = AuthzpVerifyAccessCheckArguments(
            pCC,
            pRequest,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            pReply,
            phAccessCheckResults
            );

    if (!b)
    {
        return FALSE;
    }
#endif

    //
    // No client should be able to open an object by asking for zero access.
    // If desired access is 0 then return an error.
    //
    // Note: No audit is generated in this case.
    //

    if (0 == pRequest->DesiredAccess)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_ACCESS_DENIED,
            0
            );

        return TRUE;
    }

    //
    // Generic bits should be mapped to specific ones by the resource manager.
    //

    if (FLAG_ON(pRequest->DesiredAccess, (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)))
    {
        SetLastError(ERROR_GENERIC_NOT_MAPPED);
        return FALSE;
    }

    //
    // In the simple case, there is no object type list. Fake one of length = 1
    // to represent the entire object.
    //

    if (0 == pRequest->ObjectTypeListLength)
    {
        LocalTypeList = &FixedTypeList;
        FixedTypeList.ParentIndex = -1;
        LocalTypeListLength = 1;

        //
        // If the caller has asked for caching, fake an object type list that'd
        // be used for computing static "always granted" access.
        //

        if (ARGUMENT_PRESENT(phAccessCheckResults))
        {
            RtlCopyMemory(
                &FixedCachingTypeList,
                &FixedTypeList,
                sizeof(IOBJECT_TYPE_LIST)
                );

            LocalCachingTypeList = &FixedCachingTypeList;
        }
    }
    else
    {
        DWORD Size = sizeof(IOBJECT_TYPE_LIST) * pRequest->ObjectTypeListLength;

        //
        // Allocate size for capturing object type list into local structure.
        //

        if (ARGUMENT_PRESENT(phAccessCheckResults))
        {
            //
            // We need twice the size in case of caching.
            //

            SafeAllocaAllocate(LocalTypeList, (2 * Size));

            if (AUTHZ_ALLOCATION_FAILED(LocalTypeList))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }

            LocalCachingTypeList = (PIOBJECT_TYPE_LIST) (((PUCHAR) LocalTypeList) + Size);
        }
        else
        {
            SafeAllocaAllocate(LocalTypeList, Size);

            if (AUTHZ_ALLOCATION_FAILED(LocalTypeList))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
        }

        //
        // Capture the object type list into an internal structure.
        //

        b = AuthzpCaptureObjectTypeList(
                pRequest->ObjectTypeList,
                pRequest->ObjectTypeListLength,
                LocalTypeList,
                LocalCachingTypeList
                );

        if (!b)
        {
            goto Cleanup;
        }

        LocalTypeListLength = pRequest->ObjectTypeListLength;
    }

    //
    // There are three cases when we have to perform a MaximumAllowed access
    // check and traverse the whole acl:
    //     1. RM has requested for caching.
    //     2. DesiredAccessMask has MAXIMUM_ALLOWED turned on.
    //     3. ObjectTypeList is present and pReply->ResultList has a length > 1
    //

    if (ARGUMENT_PRESENT(phAccessCheckResults)            ||
        FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED) ||
        (pReply->ResultListLength > 1))
    {
        b = AuthzpAccessCheckWithCaching(
                Flags,
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                phAccessCheckResults,
                LocalTypeList,
                LocalCachingTypeList,
                LocalTypeListLength
                );
    }
    else
    {
        //
        // Perform a normal access check in the default case. Acl traversal may
        // be abandoned if any of the desired access bits are denied before they
        // are granted.
        //

        b = AuthzpNormalAccessCheckWithoutCaching(
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                LocalTypeList,
                LocalTypeListLength
                );
    }

    if (!b) 
    {
        goto Cleanup;
    }

    //
    // Check if an audit needs to be generated if the RM has requested audit
    // generation by passing a non-null AuditEvent structure.
    //

    if (ARGUMENT_PRESENT(pAuditEvent))
    {
        b = AuthzpGenerateAudit(
                pCC,
                pRequest,
                pAuditEvent,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                LocalTypeList
                );

        if (!b) 
        {
            goto Cleanup;
        }
    }

Cleanup:

    //
    // Clean up allocated memory.
    //

    if ((&FixedTypeList != LocalTypeList) && (AUTHZ_NON_NULL_PTR(LocalTypeList)))
    {
        SafeAllocaFree(LocalTypeList);
    }

    return b;
}


BOOL
AuthzCachedAccessCheck(
    IN DWORD                             Flags,
    IN AUTHZ_ACCESS_CHECK_RESULTS_HANDLE hAccessCheckResults,
    IN PAUTHZ_ACCESS_REQUEST             pRequest,
    IN AUTHZ_AUDIT_EVENT_HANDLE          hAuditEvent          OPTIONAL,
    IN OUT PAUTHZ_ACCESS_REPLY           pReply
    )

/*++

Routine Description:

    This API performs a fast access check based on a cached handle which holds
    the static granted bits evaluated at the time of a previously made
    AuthzAccessCheck call. The pReply structure is used to return an array of
    granted access masks and error statuses.

Assumptions:
    The client context pointer is stored in the hAccessCheckResults. The structure of
    the client context must be exactly the same as it was at the time the
    hAccessCheckResults was created. This restriction is for the following fields:
    Sids, RestrictedSids, Privileges.
    Pointers to the primary security descriptor and the optional security
    descriptor array are stored in the hAccessCheckResults at the time of handle
    creation. These must still be valid.

Arguments:

    Flags - TBD.
    
    hAccessCheckResults - Handle to the cached access check results.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    AuditEvent - Object specific audit info will be passed in this structure.
        Non-null parameter is an automatic request for audit. 

    pReply - Supplies a pointer to a reply structure used to return the results
        of access check as an array of (GrantedAccessMask, ErrorValue) pairs.
        The number of results to be returned in supplied by the caller in
        pResult->ResultListLength.

        Expected error values are:

          ERROR_SUCCESS - If all the access bits (not including MAXIMUM_ALLOWED)
            are granted and GrantedAccessMask is not zero.

          ERROR_PRIVILEGE_NOT_HELD - if the DesiredAccess includes
          ACCESS_SYSTEM_SECURITY and the client does not have SeSecurityPrivilege.

          ERROR_ACCESS_DENIED in each of the following cases -
            1. any of the bits asked for is not granted.
            2. MaximumAllowed bit it on and granted access is zero.
            3. DesiredAccess is 0.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD               i                   = 0;
    DWORD               LocalTypeListLength = 0;
    PIOBJECT_TYPE_LIST  LocalTypeList       = NULL;
    PACL                pAcl                = NULL;
    PAUTHZI_HANDLE      pAH                 = (PAUTHZI_HANDLE) hAccessCheckResults;
    BOOL                b                   = TRUE;
    PAUTHZI_AUDIT_EVENT pAuditEvent         = (PAUTHZI_AUDIT_EVENT) hAuditEvent;
    IOBJECT_TYPE_LIST   FixedTypeList       = {0};

    UNREFERENCED_PARAMETER(Flags);

#ifdef AUTHZ_PARAM_CHECK
    b = AuthzpVerifyCachedAccessCheckArguments(
            pAH,
            pRequest,
            pReply
            );

    if (!b)
    {
        return FALSE;
    }
#endif

    //
    // No client should be able to open an object by asking for zero access.
    // If desired access is 0 then return an error.
    //
    // Note: No audit is generated in this case.
    //

    if (0 == pRequest->DesiredAccess)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_ACCESS_DENIED,
            0
            );

        return TRUE;
    }

    //
    // Generic bits should be mapped to specific ones by the resource manager.
    //

    if (FLAG_ON(pRequest->DesiredAccess, (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)))
    {
        SetLastError(ERROR_GENERIC_NOT_MAPPED);
        return FALSE;
    }

    //
    // Capture the object type list if one has been passed in or fake one with
    // just one element.
    //

    if (0 == pRequest->ObjectTypeListLength)
    {
        LocalTypeList = &FixedTypeList;
        LocalTypeListLength = 1;
        FixedTypeList.ParentIndex = -1;
    }
    else
    {
        DWORD Size = sizeof(IOBJECT_TYPE_LIST) * pRequest->ObjectTypeListLength;

        SafeAllocaAllocate(LocalTypeList, Size);

        if (AUTHZ_ALLOCATION_FAILED(LocalTypeList))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    
        b = AuthzpCaptureObjectTypeList(
                pRequest->ObjectTypeList,
                pRequest->ObjectTypeListLength,
                LocalTypeList,
                NULL
                );

        if (!b)
        {
            goto Cleanup;
        }

        LocalTypeListLength = pRequest->ObjectTypeListLength;
    }

    //
    // If all the bits have already been granted then just copy the results and
    // skip access check.
    //

    if (!FLAG_ON(pRequest->DesiredAccess, ~pAH->GrantedAccessMask[i]))
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_SUCCESS,
            pRequest->DesiredAccess
            );

        goto GenerateAudit;
    }

    //
    // The assumption is privileges can not be changed. Thus, if the client did
    // not have SecurityPrivilege previously then he does not have it now.
    //

    if (FLAG_ON(pRequest->DesiredAccess, ACCESS_SYSTEM_SECURITY))
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_PRIVILEGE_NOT_HELD,
            0
            );

        goto GenerateAudit;
    }

    //
    // If all aces are simple aces then there's nothing to do. All access bits
    // are static.
    //

    if ((!FLAG_ON(pAH->Flags, AUTHZ_DYNAMIC_EVALUATION_PRESENT)) &&
        (!FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED)))
    {
        AuthzpFillReplyStructureFromCachedGrantedAccessMask(
            pReply,
            pRequest->DesiredAccess,
            pAH->GrantedAccessMask
            );

        goto GenerateAudit;
    }

    //
    // Get the access bits from the last static access check.
    //

    for (i = 0; i < LocalTypeListLength; i++)
    {
        LocalTypeList[i].CurrentGranted = pAH->GrantedAccessMask[i];
        LocalTypeList[i].Remaining = pRequest->DesiredAccess & ~pAH->GrantedAccessMask[i];
    }


    //
    // NULL Dacl is synonymous with Full Control.
    //

    pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pAH->pSecurityDescriptor);

    if (!AUTHZ_NON_NULL_PTR(pAcl))
    {
        for (i = 0; i < LocalTypeListLength; i++)
        {
             LocalTypeList[i].CurrentGranted |= (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL);
        }
    }
    else
    {
        //
        // If there are no deny aces, then perform a quick access check evaluating
        // only the allow aces that are dynamic or have principal self sid in them.
        //

        if (!FLAG_ON(pAH->Flags, (AUTHZ_DENY_ACE_PRESENT | AUTHZ_DYNAMIC_DENY_ACE_PRESENT)))
        {
            if (FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED) ||
                (pReply->ResultListLength > 1))
            {
                b = AuthzpQuickMaximumAllowedAccessCheck(
                        pAH->pAuthzClientContext,
                        pAH,
                        pRequest,
                        pReply,
                        LocalTypeList,
                        LocalTypeListLength
                        );
            }
            else
            {
                b = AuthzpQuickNormalAccessCheck(
                        pAH->pAuthzClientContext,
                        pAH,
                        pRequest,
                        pReply,
                        LocalTypeList,
                        LocalTypeListLength
                        );
            }
        }
        else if ((0 != pRequest->ObjectTypeListLength) || (FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED)))
        {
            //
            // Now we have to evaluate the entire acl since there are deny aces
            // and the caller has asked for a result list.
            //

            b = AuthzpAccessCheckWithCaching(
                    Flags,
                    pAH->pAuthzClientContext,
                    pRequest,
                    pAH->pSecurityDescriptor,
                    pAH->OptionalSecurityDescriptorArray,
                    pAH->OptionalSecurityDescriptorCount,
                    pReply,
                    NULL,
                    LocalTypeList,
                    NULL,
                    LocalTypeListLength
                    );
        }
        else
        {
            //
            // There are deny aces in the acl but the caller has not asked for
            // entire resultlist. Preform a normal access check.
            //

            b = AuthzpNormalAccessCheckWithoutCaching(
                    pAH->pAuthzClientContext,
                    pRequest,
                    pAH->pSecurityDescriptor,
                    pAH->OptionalSecurityDescriptorArray,
                    pAH->OptionalSecurityDescriptorCount,
                    pReply,
                    LocalTypeList,
                    LocalTypeListLength
                    );
        }

        if (!b) 
        {
            goto Cleanup;
        }

    }

    AuthzpFillReplyFromParameters(
        pRequest,
        pReply,
        LocalTypeList
        );

GenerateAudit:

    if (ARGUMENT_PRESENT(pAuditEvent))
    {
        b = AuthzpGenerateAudit(
                pAH->pAuthzClientContext,
                pRequest,
                pAuditEvent,
                pAH->pSecurityDescriptor,
                pAH->OptionalSecurityDescriptorArray,
                pAH->OptionalSecurityDescriptorCount,
                pReply,
                LocalTypeList
                );

        if (!b) goto Cleanup;
    }

Cleanup:

    if ((&FixedTypeList != LocalTypeList) && (AUTHZ_NON_NULL_PTR(LocalTypeList)))
    {
        SafeAllocaFree(LocalTypeList);
    }

    return b;
}


BOOL
AuthzOpenObjectAudit(
    IN DWORD                       Flags,
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PAUTHZ_ACCESS_REQUEST       pRequest,
    IN AUTHZ_AUDIT_EVENT_HANDLE    hAuditEvent,
    IN PSECURITY_DESCRIPTOR        pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR        *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD                       OptionalSecurityDescriptorCount,
    IN PAUTHZ_ACCESS_REPLY         pReply
    )

/*++

Routine Description

    This API examines the SACL in the passed security descriptor(s) and generates 
    any appropriate audits.  

Arguments

    Flags - TBD.
    
    hAuthzClientContext - Client context to perform the SACL evaluation against.
    
    pRequest - pointer to request structure.
    
    hAuditEvent - Handle to the audit that may be generated.
    
    pSecurityDescriptor - Pointer to a security descriptor.
    
    OptionalSecurityDescriptorArray - Optional array of security descriptors.
    
    OptionalSecurityDescriptorCount - Size of optional security descriptor array.
    
    pReply - Pointer to the reply structure.

Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
--*/

{
    BOOL                   b                   = TRUE;
    DWORD                  LocalTypeListLength = 0;
    PIOBJECT_TYPE_LIST     LocalTypeList       = NULL;
    PAUTHZI_CLIENT_CONTEXT pCC                 = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    PAUTHZI_AUDIT_EVENT    pAuditEvent         = (PAUTHZI_AUDIT_EVENT) hAuditEvent;
    IOBJECT_TYPE_LIST      FixedTypeList       = {0};

    UNREFERENCED_PARAMETER(Flags);

    //
    // Verify that the arguments passed are valid.
    //
    
    b = AuthzpVerifyOpenObjectArguments(
            pCC,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            pAuditEvent
            );

    if (!b)
    {
        return FALSE;
    }

    //
    // In the simple case, there is no object type list. Fake one of length = 1
    // to represent the entire object.
    //
    
    if (0 == pRequest->ObjectTypeListLength)
    {
        LocalTypeList = &FixedTypeList;
        FixedTypeList.ParentIndex = -1;
        LocalTypeListLength = 1;
    }
    else
    {
        DWORD Size = sizeof(IOBJECT_TYPE_LIST) * pRequest->ObjectTypeListLength;

        SafeAllocaAllocate(LocalTypeList, Size);

        if (AUTHZ_ALLOCATION_FAILED(LocalTypeList))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        //
        // Capture the object type list into an internal structure.
        //

        b = AuthzpCaptureObjectTypeList(
                pRequest->ObjectTypeList,
                pRequest->ObjectTypeListLength,
                LocalTypeList,
                NULL
                );

        if (!b)
        {
            goto Cleanup;
        }

        LocalTypeListLength = pRequest->ObjectTypeListLength;
    }

    b = AuthzpGenerateAudit(
            pCC,
            pRequest,
            pAuditEvent,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            pReply,
            LocalTypeList
            );

    if (!b)
    {
        goto Cleanup;
    }

Cleanup:

    //
    // Clean up allocated memory.
    //

    if (&FixedTypeList != LocalTypeList)
    {
        SafeAllocaFree(LocalTypeList);
    }

    return b;
}


BOOL
AuthzFreeHandle(
    IN OUT AUTHZ_ACCESS_CHECK_RESULTS_HANDLE hAccessCheckResults
    )

/*++

Routine Description:

    This API finds and deletes the input handle from the handle list.

Arguments:

    hAcc - Handle to be freed.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_HANDLE pAH      = (PAUTHZI_HANDLE) hAccessCheckResults;
    PAUTHZI_HANDLE pCurrent = NULL;
    PAUTHZI_HANDLE pPrev    = NULL;
    BOOL           b        = TRUE;
    
    //
    // Validate parameters.
    //

    if (!ARGUMENT_PRESENT(pAH) ||
        !AUTHZ_NON_NULL_PTR(pAH->pAuthzClientContext) ||
        !AUTHZ_NON_NULL_PTR(pAH->pAuthzClientContext->AuthzHandleHead))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    AuthzpAcquireClientCacheWriteLock(pAH->pAuthzClientContext);

    pCurrent = pAH->pAuthzClientContext->AuthzHandleHead;

    //
    // Check if the handle is at the beginning of the list.
    //

    if (pCurrent == pAH)
    {
        pAH->pAuthzClientContext->AuthzHandleHead = pAH->pAuthzClientContext->AuthzHandleHead->next;
    }
    else
    {
        //
        // The handle is not the head of the list. Loop thru the list to find
        // it.
        //

        pPrev = pCurrent;
        pCurrent = pCurrent->next;

        for (; AUTHZ_NON_NULL_PTR(pCurrent); pPrev = pCurrent, pCurrent = pCurrent->next)
        {
            if (pCurrent == pAH)
            {
                pPrev->next = pCurrent->next;
                break;
            }
        }

        //
        // The caller has sent us an invalid handle.
        //

        if (!AUTHZ_NON_NULL_PTR(pCurrent))
        {
            b = FALSE;
            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    AuthzpReleaseClientCacheLock(pCC);

    //
    // Free the handle node.
    //

    if (b)
    {    
        AuthzpFree(pAH);
    }

    return b;
}


BOOL
AuthzInitializeResourceManager(
    IN  DWORD                            Flags,
    IN  PFN_AUTHZ_DYNAMIC_ACCESS_CHECK   pfnDynamicAccessCheck   OPTIONAL,
    IN  PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups OPTIONAL,
    IN  PFN_AUTHZ_FREE_DYNAMIC_GROUPS    pfnFreeDynamicGroups    OPTIONAL,
    IN  PCWSTR                           szResourceManagerName,
    OUT PAUTHZ_RESOURCE_MANAGER_HANDLE   phAuthzResourceManager
    )

/*++

Routine Description:

    This API allocates and initializes a resource manager structure.

Arguments:
    
    Flags - AUTHZ_RM_FLAG_NO_AUDIT - use if the RM will never generate an audit to
        save some cycles.
    
          - AUTHZ_RM_FLAG_INITIALIZE_UNDER_IMPERSONATION - if the current thread is 
            impersonating then use the impersonation token as the identity of the
            resource manager.
                        
    pfnAccessCheck - Pointer to the RM supplied access check function to be
    called when a callback ace is encountered by the access check algorithm.

    pfnComputeDynamicGroups - Pointer to the RM supplied function to compute
    groups to be added to the client context at the time of its creation.

    pfnFreeDynamicGroups - Pointer to the function to free the memory allocated
    by the pfnComputeDynamicGroups function.

    szResourceManagerName - the name of the resource manager.
    
    pAuthzResourceManager - To return the resource manager handle. The returned
    handle must be freed using AuthzFreeResourceManager.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_RESOURCE_MANAGER pRM    = NULL;
    BOOL                     b      = TRUE;
    ULONG                    len    = 0;

    if (!ARGUMENT_PRESENT(phAuthzResourceManager) ||
        (Flags & ~AUTHZ_VALID_RM_INIT_FLAGS))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuthzResourceManager = NULL;

    if (AUTHZ_NON_NULL_PTR(szResourceManagerName))
    {
        len = (ULONG) wcslen(szResourceManagerName) + 1;
    }
   
    pRM = (PAUTHZI_RESOURCE_MANAGER)
              AuthzpAlloc(sizeof(AUTHZI_RESOURCE_MANAGER) + sizeof(WCHAR) * len);

    if (AUTHZ_ALLOCATION_FAILED(pRM))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // Use the default pessimistic function if none has been specified.
    //

    if (AUTHZ_NON_NULL_PTR(pfnDynamicAccessCheck))
    {
        pRM->pfnDynamicAccessCheck = pfnDynamicAccessCheck;
    }
    else
    {
        pRM->pfnDynamicAccessCheck = &AuthzpDefaultAccessCheck;
    }

    if (!FLAG_ON(Flags, AUTHZ_RM_FLAG_NO_AUDIT))
    {
        
        //
        // Initialize the generic audit queue and generic audit events.
        //

        b = AuthziInitializeAuditQueue(
                AUTHZ_MONITOR_AUDIT_QUEUE_SIZE,
                1000,
                100,
                NULL,
                &pRM->hAuditQueue
                );

        if (!b)
        {
            goto Cleanup;
        }

        //
        // Initialize the generic audit event.
        //

        b = AuthziInitializeAuditEventType(
                AUTHZP_DEFAULT_RM_EVENTS | AUTHZP_INIT_GENERIC_AUDIT_EVENT,
                0,
                0,
                0,
                &pRM->hAET
                );

        if (!b)
        {
            goto Cleanup;
        }

        b = AuthziInitializeAuditEventType(
                AUTHZP_DEFAULT_RM_EVENTS,
                SE_CATEGID_DS_ACCESS,
                SE_AUDITID_OBJECT_OPERATION,
                AUTHZP_NUM_PARAMS_FOR_SE_AUDITID_OBJECT_OPERATION,
                &pRM->hAETDS
                );

        if (!b)
        {
            goto Cleanup;
        }
    }

    pRM->pfnComputeDynamicGroups        = pfnComputeDynamicGroups;
    pRM->pfnFreeDynamicGroups           = pfnFreeDynamicGroups;
    pRM->Flags                          = Flags;
    pRM->pUserSID                       = NULL;
    pRM->szResourceManagerName          = (PWSTR)((PUCHAR)pRM + sizeof(AUTHZI_RESOURCE_MANAGER));
    
    if (FLAG_ON(Flags, AUTHZ_RM_FLAG_INITIALIZE_UNDER_IMPERSONATION))
    {
        b = AuthzpGetThreadTokenInfo(
            &pRM->pUserSID,
            &pRM->AuthID
            );

        if (!b)
        {
            goto Cleanup;
        }
    }
    else
    {
        b = AuthzpGetProcessTokenInfo(
                &pRM->pUserSID,
                &pRM->AuthID
                );

        if (!b)
        {
            goto Cleanup;
        }
    }

    if (0 != len)
    {    
        RtlCopyMemory(
            pRM->szResourceManagerName,
            szResourceManagerName,
            sizeof(WCHAR) * len
            );
    }
    else 
    {
        pRM->szResourceManagerName = NULL;
    }

    *phAuthzResourceManager = (AUTHZ_RESOURCE_MANAGER_HANDLE) pRM;

Cleanup:

    if (!b)
    {
        //
        // Copy LastError value, since the calls to AuthziFreeAuditEventType can succeed and 
        // overwrite it with 0x103 (STATUS_PENDING).
        //

        DWORD dwError = GetLastError();

        if (NULL != pRM)
        {
            if (!FLAG_ON(Flags, AUTHZ_RM_FLAG_NO_AUDIT))
            {
                AuthziFreeAuditQueue(pRM->hAuditQueue);
                AuthziFreeAuditEventType(pRM->hAET);
                AuthziFreeAuditEventType(pRM->hAETDS);
            }
            AuthzpFreeNonNull(pRM->pUserSID);
            AuthzpFree(pRM);
        }
        
        SetLastError(dwError);
    }

    return b;
}


BOOL
AuthzFreeResourceManager(
    IN OUT AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager
    )

/*++

Routine Description:

    This API frees up a resource manager.  If the default queue is in use, this call will wait for that
    queue to empty.
    
Arguments:

    hAuthzResourceManager - Handle to the resource manager object to be freed.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_RESOURCE_MANAGER pRM = (PAUTHZI_RESOURCE_MANAGER) hAuthzResourceManager;
    
    if (!ARGUMENT_PRESENT(pRM))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!FLAG_ON(pRM->Flags, AUTHZ_RM_FLAG_NO_AUDIT))
    {
        (VOID) AuthziFreeAuditQueue(pRM->hAuditQueue);
        (VOID) AuthziFreeAuditEventType(pRM->hAET);
        (VOID) AuthziFreeAuditEventType(pRM->hAETDS);
    }

    AuthzpFreeNonNull(pRM->pUserSID);
    AuthzpFree(pRM);
    return TRUE;
}


BOOL
AuthzInitializeContextFromToken(
    IN  DWORD                         Flags,
    IN  HANDLE                        TokenHandle,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext
    )

/*++

Routine Description:

    Initialize the authz context from the handle to the kernel token. The token
    must have been opened for TOKEN_QUERY.

Arguments:

    Flags - None

    TokenHandle - Handle to the client token from which the authz context will
    be initialized. The token must have been opened with TOKEN_QUERY access.

    AuthzResourceManager - The resource manager handle creating this client
    context. This will be stored in the client context structure.

    pExpirationTime - To set for how long the returned context structure is
    valid. If no value is passed then the token never expires.
    Expiration time is not currently enforced in the system.

    Identifier - Resource manager manager specific identifier. This is never
    interpreted by Authz.

    DynamicGroupArgs - To be passed to the callback function that computes
    dynamic groups

    pAuthzClientContext - To return a handle to the AuthzClientContext

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    UCHAR Buffer[AUTHZ_MAX_STACK_BUFFER_SIZE];

    NTSTATUS                     Status               = STATUS_SUCCESS;
    PUCHAR                       pBuffer              = (PVOID) Buffer;
    BOOL                         b                    = TRUE;
    BOOL                         bAllocatedSids       = FALSE;
    BOOL                         bLockHeld            = FALSE;
    PTOKEN_GROUPS_AND_PRIVILEGES pTokenInfo           = NULL;
    PAUTHZI_RESOURCE_MANAGER     pRM                  = NULL;
    PAUTHZI_CLIENT_CONTEXT       pCC                  = NULL;
    DWORD                        Length               = 0;
    LARGE_INTEGER                ExpirationTime       = {0, 0};

    UNREFERENCED_PARAMETER(Flags);

    if (!ARGUMENT_PRESENT(TokenHandle)           ||
        !ARGUMENT_PRESENT(hAuthzResourceManager) ||
        !ARGUMENT_PRESENT(phAuthzClientContext))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuthzClientContext = NULL;

    //
    // Query the token information into user mode buffer. A local stack buffer
    // is used in the first call hoping that it would be sufficient to hold
    // the return values.
    //

    Status = NtQueryInformationToken(
                 TokenHandle,
                 TokenGroupsAndPrivileges,
                 pBuffer,
                 AUTHZ_MAX_STACK_BUFFER_SIZE,
                 &Length
                 );

    if (STATUS_BUFFER_TOO_SMALL == Status)
    {
        pBuffer = (PVOID) AuthzpAlloc(Length);

        if (AUTHZ_ALLOCATION_FAILED(pBuffer))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        Status = NtQueryInformationToken(
                     TokenHandle,
                     TokenGroupsAndPrivileges,
                     pBuffer,
                     Length,
                     &Length
                     );
    }

    if (!NT_SUCCESS(Status))
    {

#ifdef AUTHZ_DEBUG
        wprintf(L"\nNtQueryInformationToken failed with %d\n", Status);
#endif

        SetLastError(RtlNtStatusToDosError(Status));
        b = FALSE;
        goto Cleanup;
    }

    pTokenInfo = (PTOKEN_GROUPS_AND_PRIVILEGES) pBuffer;

    pRM = (PAUTHZI_RESOURCE_MANAGER) hAuthzResourceManager;

    if (ARGUMENT_PRESENT(pExpirationTime))
    {
        ExpirationTime = *pExpirationTime;
    }

    //
    // Initialize the client context. The callee allocates memory for the client
    // context structure.
    //

    b = AuthzpAllocateAndInitializeClientContext(
            &pCC,
            NULL,
            AUTHZ_CURRENT_CONTEXT_REVISION,
            Identifier,
            ExpirationTime,
            0,
            pTokenInfo->SidCount,
            pTokenInfo->SidLength,
            pTokenInfo->Sids,
            pTokenInfo->RestrictedSidCount,
            pTokenInfo->RestrictedSidLength,
            pTokenInfo->RestrictedSids,
            pTokenInfo->PrivilegeCount,
            pTokenInfo->PrivilegeLength,
            pTokenInfo->Privileges,
            pTokenInfo->AuthenticationId,
            NULL,
            pRM
            );

    if (!b)
    {
        goto Cleanup;
    }

    AuthzpAcquireClientContextReadLock(pCC);

    bLockHeld = TRUE;

    //
    // Add dynamic sids to the token.
    //

    b = AuthzpAddDynamicSidsToToken(
            pCC,
            pRM,
            DynamicGroupArgs,
            pTokenInfo->Sids,
            pTokenInfo->SidLength,
            pTokenInfo->SidCount,
            pTokenInfo->RestrictedSids,
            pTokenInfo->RestrictedSidLength,
            pTokenInfo->RestrictedSidCount,
            pTokenInfo->Privileges,
            pTokenInfo->PrivilegeLength,
            pTokenInfo->PrivilegeCount,
            FALSE
            );

    if (!b) 
    {
        goto Cleanup;
    }

    bAllocatedSids = TRUE;
    *phAuthzClientContext = (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC;

    AuthzPrintContext(pCC);
    
    //
    // initialize the sid hash for regular sids
    //

    AuthzpInitSidHash(
        pCC->Sids,
        pCC->SidCount,
        pCC->SidHash
        );

    //
    // initialize the sid hash for restricted sids
    //

    AuthzpInitSidHash(
        pCC->RestrictedSids,
        pCC->RestrictedSidCount,
        pCC->RestrictedSidHash
        );

Cleanup:

    if ((PVOID) Buffer != pBuffer)
    {
        AuthzpFreeNonNull(pBuffer);
    }

    if (!b)
    {
        DWORD dwSavedError = GetLastError();
        
        if (AUTHZ_NON_NULL_PTR(pCC))
        {
            if (bAllocatedSids)
            {
                AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE)pCC);
                SetLastError(dwSavedError);
            }
            else
            {
                AuthzpFree(pCC);
            }
        }
    }

    if (bLockHeld)
    {
        AuthzpReleaseClientContextLock(pCC);
    }

    return b;
}


BOOL
AuthzpInitializeContextFromSid(
    IN  DWORD                         Flags,
    IN  PSID                          UserSid,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext,
    IN  BOOL                          bIsInternalRoutine
    )

/*++

Routine Description:

    This API takes a user sid and creates a user mode client context from it.
    It fetches the TokenGroups attributes from the AD in case of domain sids.
    The machine local groups are computed on the ServerName specified. The
    resource manager may dynamic groups using callback mechanism.

Arguments:

    Flags -
      AUTHZ_SKIP_TOKEN_GROUPS -  Do not token groups if this is on.

    UserSid - The sid of the user for whom a client context will be created.

    ServerName - The machine on which local groups should be computed. A NULL
    server name defaults to the local machine.

    AuthzResourceManager - The resource manager handle creating this client
    context. This will be stored in the client context structure.

    pExpirationTime - To set for how long the returned context structure is
    valid. If no value is passed then the token never expires.
    Expiration time is not currently enforced in the system.

    Identifier - Resource manager manager specific identifier. This is never
    interpreted by Authz.

    DynamicGroupArgs - To be passed to the callback function that computes
    dynamic groups

    pAuthzClientContext - To return a handle to the AuthzClientContext
    structure. The returned handle must be freed using AuthzFreeContext.

    bIsInternalRoutine - When this is on, Group context is built recursively.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PSID_AND_ATTRIBUTES      pSidAttr         = NULL;
    PAUTHZI_CLIENT_CONTEXT   pCC              = NULL;
    BOOL                     b                = FALSE;
    DWORD                    SidCount         = 0;
    DWORD                    SidLength        = 0;
    LARGE_INTEGER            ExpirationTime   = {0, 0};
    LUID                     NullLuid         = {0, 0};
    PAUTHZI_RESOURCE_MANAGER pRM              = (PAUTHZI_RESOURCE_MANAGER) hAuthzResourceManager;

    if (!ARGUMENT_PRESENT(UserSid)               ||
        !ARGUMENT_PRESENT(hAuthzResourceManager) ||
        !ARGUMENT_PRESENT(phAuthzClientContext))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuthzClientContext = NULL;

    if ((0 == (Flags & AUTHZ_SKIP_TOKEN_GROUPS)) && (FALSE == bIsInternalRoutine))
    {
        DWORD LocalFlags = 0;

        //
        // If the caller did not supply AUTHZ_SKIP_TOKEN_GROUPS, check whether
        // we should add it ourselves. This should be done for WellKnown and
        // Builtins.
        //

        b = AuthzpComputeSkipFlagsForWellKnownSid(UserSid, &LocalFlags);

        if (!b)
        {
            return FALSE;
        }

        Flags |= LocalFlags;
    }

    //
    // Compute the token groups and the machine local groups. These will be
    // returned in memory allocated by the callee.
    //

    b = AuthzpGetAllGroupsBySid(
            UserSid,
            Flags,
            &pSidAttr,
            &SidCount,
            &SidLength
            );

    if (!b) 
    {
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(pExpirationTime))
    {
        ExpirationTime = *pExpirationTime;
    }

    //
    // Initialize the client context. The callee allocates memory for the client
    // context structure.
    //

    b = AuthzpAllocateAndInitializeClientContext(
            &pCC,
            NULL,
            AUTHZ_CURRENT_CONTEXT_REVISION,
            Identifier,
            ExpirationTime,
            0,
            SidCount,
            SidLength,
            pSidAttr,
            0,
            0,
            NULL,
            0,
            0,
            NULL,
            NullLuid,
            NULL,
            pRM
            );

    if (!b) goto Cleanup;

    //
    // Add dynamic sids to the token.
    //

    b = AuthzpAddDynamicSidsToToken(
            pCC,
            pRM,
            DynamicGroupArgs,
            pSidAttr,
            SidLength,
            SidCount,
            NULL,
            0,
            0,
            NULL,
            0,
            0,
            TRUE
            );

    if (!b) goto Cleanup;

    *phAuthzClientContext = (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC;

    AuthzPrintContext(pCC);
    
    //
    // initialize the sid hash for regular sids
    //

    AuthzpInitSidHash(
        pCC->Sids,
        pCC->SidCount,
        pCC->SidHash
        );

    //
    // initialize the sid hash for restricted sids
    //

    AuthzpInitSidHash(
        pCC->RestrictedSids,
        pCC->RestrictedSidCount,
        pCC->RestrictedSidHash
        );

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pSidAttr);
        if (AUTHZ_NON_NULL_PTR(pCC))
        {
            if (pSidAttr != pCC->Sids)
            {
                AuthzpFreeNonNull(pCC->Sids);
            }

            AuthzpFreeNonNull(pCC->RestrictedSids);
            AuthzpFree(pCC);
        }
    }
    else
    {
        if (pSidAttr != pCC->Sids)
        {
            AuthzpFree(pSidAttr);
        }
    }

    return b;
}



BOOL
AuthzInitializeContextFromSid(
    IN  DWORD                         Flags,
    IN  PSID                          UserSid,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext
    )

/*++

Routine Description:

    This API takes a user sid and creates a user mode client context from it.
    It fetches the TokenGroups attributes from the AD in case of domain sids.
    The machine local groups are computed on the ServerName specified. The
    resource manager may dynamic groups using callback mechanism.

Arguments:

    Flags -
      AUTHZ_SKIP_TOKEN_GROUPS -  Do not evaluate token groups if this is on.

    UserSid - The sid of the user for whom a client context will be created.

    ServerName - The machine on which local groups should be computed. A NULL
    server name defaults to the local machine.

    AuthzResourceManager - The resource manager handle creating this client
    context. This will be stored in the client context structure.

    pExpirationTime - To set for how long the returned context structure is
    valid. If no value is passed then the token never expires.
    Expiration time is not currently enforced in the system.

    Identifier - Resource manager manager specific identifier. This is never
    interpreted by Authz.

    DynamicGroupArgs - To be passed to the callback function that computes
    dynamic groups

    pAuthzClientContext - To return a handle to the AuthzClientContext
    structure. The returned handle must be freed using AuthzFreeContext.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    return AuthzpInitializeContextFromSid(
               Flags,
               UserSid,
               hAuthzResourceManager,
               pExpirationTime,
               Identifier,
               DynamicGroupArgs,
               phAuthzClientContext,
               FALSE // This is not the internal routine.
               );
}


BOOL
AuthziInitializeContextFromSid(
    IN  DWORD                         Flags,
    IN  PSID                          UserSid,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext
    )

/*++

Routine Description:

    This API takes a user sid and creates a user mode client context from it.
    It fetches the TokenGroups attributes from the AD in case of domain sids.
    The machine local groups are computed on the ServerName specified. The
    resource manager may dynamic groups using callback mechanism.

Arguments:

    Flags -
      AUTHZ_SKIP_TOKEN_GROUPS -  Do not evaluate token groups if this is on.

    UserSid - The sid of the user for whom a client context will be created.

    ServerName - The machine on which local groups should be computed. A NULL
    server name defaults to the local machine.

    AuthzResourceManager - The resource manager handle creating this client
    context. This will be stored in the client context structure.

    pExpirationTime - To set for how long the returned context structure is
    valid. If no value is passed then the token never expires.
    Expiration time is not currently enforced in the system.

    Identifier - Resource manager manager specific identifier. This is never
    interpreted by Authz.

    DynamicGroupArgs - To be passed to the callback function that computes
    dynamic groups

    pAuthzClientContext - To return a handle to the AuthzClientContext
    structure. The returned handle must be freed using AuthzFreeContext.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    return AuthzpInitializeContextFromSid(
               Flags,
               UserSid,
               hAuthzResourceManager,
               pExpirationTime,
               Identifier,
               DynamicGroupArgs,
               phAuthzClientContext,
               TRUE // This is the internal routine.
               );
}

BOOL
AuthzInitializeContextFromAuthzContext(
    IN  DWORD                        Flags,
    IN  AUTHZ_CLIENT_CONTEXT_HANDLE  hAuthzClientContext,
    IN  PLARGE_INTEGER               pExpirationTime         OPTIONAL,
    IN  LUID                         Identifier,
    IN  PVOID                        DynamicGroupArgs,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE phNewAuthzClientContext
    )

/*++

Routine Description:

    This API creates an AUTHZ_CLIENT_CONTEXT based on another AUTHZ_CLIENT_CONTEXT.

Arguments:

    Flags - TBD

    hAuthzClientContext - Client context to duplicate

    pExpirationTime - To set for how long the returned context structure is
    valid. If no value is passed then the token never expires.
    Expiration time is not currently enforced in the system.

    Identifier - Resource manager manager specific identifier.

    DynamicGroupArgs - To be passed to the callback function that computes
    dynamic groups.  If NULL then callback not called.

    phNewAuthzClientContext - Duplicate of context.  Must be freed using AuthzFreeContext.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_CLIENT_CONTEXT pCC                = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    PAUTHZI_CLIENT_CONTEXT pNewCC             = NULL;
    PAUTHZI_CLIENT_CONTEXT pServer            = NULL;
    BOOL                   b                  = FALSE;
    BOOL                   bAllocatedSids     = FALSE;
    LARGE_INTEGER          ExpirationTime     = {0, 0};


    if (!ARGUMENT_PRESENT(phNewAuthzClientContext) ||
        !ARGUMENT_PRESENT(hAuthzClientContext))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    *phNewAuthzClientContext = NULL;

    //
    // Determine the ExpirationTime of the new context.
    //

    if (ARGUMENT_PRESENT(pExpirationTime))
    {
        ExpirationTime = *pExpirationTime;
    }
    
    AuthzpAcquireClientContextReadLock(pCC);

    if (AUTHZ_NON_NULL_PTR(pCC->Server))
    {
       b = AuthzInitializeContextFromAuthzContext(
               0,
               (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC->Server,
               NULL,
               pCC->Server->Identifier,
               NULL,
               (PAUTHZ_CLIENT_CONTEXT_HANDLE) &pServer
               );

       if (!b)
       {
           goto Cleanup;
       }
    }

    //
    // Now initialize the new context.
    //

    b = AuthzpAllocateAndInitializeClientContext(
            &pNewCC,
            pServer,
            pCC->Revision,
            Identifier,
            ExpirationTime,
            Flags,
            pCC->SidCount,
            pCC->SidLength,
            pCC->Sids,
            pCC->RestrictedSidCount,
            pCC->RestrictedSidLength,
            pCC->RestrictedSids,
            pCC->PrivilegeCount,
            pCC->PrivilegeLength,
            pCC->Privileges,
            pCC->AuthenticationId,
            NULL,
            pCC->pResourceManager
            );

    if (!b)
    {
        goto Cleanup;
    }

    b = AuthzpAddDynamicSidsToToken(
            pNewCC,
            pNewCC->pResourceManager,
            DynamicGroupArgs,
            pNewCC->Sids,
            pNewCC->SidLength,
            pNewCC->SidCount,
            pNewCC->RestrictedSids,
            pNewCC->RestrictedSidLength,
            pNewCC->RestrictedSidCount,
            pNewCC->Privileges,
            pNewCC->PrivilegeLength,
            pNewCC->PrivilegeCount,
            FALSE
            );

    if (!b)
    {
        goto Cleanup;
    }

    bAllocatedSids = TRUE;
    *phNewAuthzClientContext = (AUTHZ_CLIENT_CONTEXT_HANDLE) pNewCC;

#ifdef AUTHZ_DEBUG
    wprintf(L"ContextFromAuthzContext: Original Context:\n");
    AuthzPrintContext(pCC);
    wprintf(L"ContextFromAuthzContext: New Context:\n");
    AuthzPrintContext(pNewCC);
#endif

    //
    // initialize the sid hash for regular sids
    //

    AuthzpInitSidHash(
        pNewCC->Sids,
        pNewCC->SidCount,
        pNewCC->SidHash
        );

    //
    // initialize the sid hash for restricted sids
    //

    AuthzpInitSidHash(
        pNewCC->RestrictedSids,
        pNewCC->RestrictedSidCount,
        pNewCC->RestrictedSidHash
        );

Cleanup:

    if (!b)
    {
        DWORD dwSavedError = GetLastError();

        if (AUTHZ_NON_NULL_PTR(pNewCC))
        {
            if (bAllocatedSids)
            {
                AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE)pNewCC);
            }
            else
            {
                AuthzpFree(pNewCC);
            }
        }
        else
        {
            if (AUTHZ_NON_NULL_PTR(pServer))
            {
                AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE)pServer);
            }
        }
        SetLastError(dwSavedError);
    }

    AuthzpReleaseClientContextLock(pCC);

    return b;
}


BOOL
AuthzAddSidsToContext(
    IN  AUTHZ_CLIENT_CONTEXT_HANDLE  hAuthzClientContext,
    IN  PSID_AND_ATTRIBUTES          Sids                    OPTIONAL,
    IN  DWORD                        SidCount,
    IN  PSID_AND_ATTRIBUTES          RestrictedSids          OPTIONAL,
    IN  DWORD                        RestrictedSidCount,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE phNewAuthzClientContext
    )

/*++

Routine Description:

    This API creates a new context given a set of sids as well as restricted sids
    and an already existing context.  The original is unchanged.

Arguments:

    hAuthzClientContext - Client context to which the given sids will be added

    Sids - Sids and attributes to be added to the normal part of the client
    context

    SidCount - Number of sids to be added

    RestrictedSids - Sids and attributes to be added to the restricted part of
    the client context

    RestrictedSidCount - Number of restricted sids to be added

    phNewAuthzClientContext - The new context with the additional sids.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                  i                   = 0;
    DWORD                  SidLength           = 0;
    DWORD                  RestrictedSidLength = 0;
    PSID_AND_ATTRIBUTES    pSidAttr            = NULL;
    PSID_AND_ATTRIBUTES    pRestrictedSidAttr  = NULL;
    BOOL                   b                   = TRUE;
    PAUTHZI_CLIENT_CONTEXT pCC                 = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    PAUTHZI_CLIENT_CONTEXT pNewCC              = NULL;
    PAUTHZI_CLIENT_CONTEXT pServer             = NULL;
    PLUID_AND_ATTRIBUTES   pPrivileges         = NULL;

    if ((!ARGUMENT_PRESENT(phNewAuthzClientContext)) ||
        (!ARGUMENT_PRESENT(hAuthzClientContext))     ||
        (0 != SidCount && !ARGUMENT_PRESENT(Sids))   ||
        (0 != RestrictedSidCount && !ARGUMENT_PRESENT(RestrictedSids)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phNewAuthzClientContext = NULL;

    AuthzpAcquireClientContextReadLock(pCC);

    //
    // Recursively duplicate the server
    //

    if (AUTHZ_NON_NULL_PTR(pCC->Server))
    {

        b = AuthzInitializeContextFromAuthzContext(
                0,
                (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC->Server,
                NULL,
                pCC->Server->Identifier,
                NULL,
                (PAUTHZ_CLIENT_CONTEXT_HANDLE) &pServer
                );

       if (!b)
       {
           goto Cleanup;
       }
    }

    //
    // Duplicate the context, and do all further work on the duplicate.
    //

    b = AuthzpAllocateAndInitializeClientContext(
            &pNewCC,
            pServer,
            pCC->Revision,
            pCC->Identifier,
            pCC->ExpirationTime,
            pCC->Flags,
            0,
            0,
            NULL,
            0,
            0,
            NULL,
            0,
            0,
            NULL,
            pCC->AuthenticationId,
            NULL,
            pCC->pResourceManager
            );

    if (!b)
    {
        goto Cleanup;
    }

    SidLength = sizeof(SID_AND_ATTRIBUTES) * SidCount;

    //
    // Compute the length required to hold the new sids.
    //

    for (i = 0; i < SidCount; i++)
    {
#ifdef AUTHZ_PARAM_CHECK
        if (FLAG_ON(Sids[i].Attributes, ~AUTHZ_VALID_SID_ATTRIBUTES) ||
            !FLAG_ON(Sids[i].Attributes, AUTHZ_VALID_SID_ATTRIBUTES))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }

        if (!RtlValidSid(Sids[i].Sid))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }
#endif
        SidLength += RtlLengthSid(Sids[i].Sid);
    }

    RestrictedSidLength = sizeof(SID_AND_ATTRIBUTES) * RestrictedSidCount;

    //
    // Compute the length required to hold the new restricted sids.
    //

    for (i = 0; i < RestrictedSidCount; i++)
    {
#ifdef AUTHZ_PARAM_CHECK
        if (FLAG_ON(RestrictedSids[i].Attributes, ~AUTHZ_VALID_SID_ATTRIBUTES) ||
            !FLAG_ON(RestrictedSids[i].Attributes, AUTHZ_VALID_SID_ATTRIBUTES))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }

        if (!RtlValidSid(RestrictedSids[i].Sid))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }
#endif
        RestrictedSidLength += RtlLengthSid(RestrictedSids[i].Sid);
    }

    //
    // Copy the existing sids and the new ones into the allocated memory.
    //

    SidLength += pCC->SidLength;

    if (0 != SidLength)
    {

        pSidAttr = (PSID_AND_ATTRIBUTES) AuthzpAlloc(SidLength);

        if (AUTHZ_ALLOCATION_FAILED(pSidAttr))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        b = AuthzpCopySidsAndAttributes(
                pSidAttr,
                pCC->Sids,
                pCC->SidCount,
                Sids,
                SidCount
                );

        if (!b)
        {
            goto Cleanup;
        }

    }

    //
    // Copy the existing restricted sids and the new ones into the allocated
    // memory.
    //

    RestrictedSidLength += pCC->RestrictedSidLength;

    if (0 != RestrictedSidLength)
    {

        pRestrictedSidAttr = (PSID_AND_ATTRIBUTES) AuthzpAlloc(RestrictedSidLength);

        if (AUTHZ_ALLOCATION_FAILED(pRestrictedSidAttr))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        b = AuthzpCopySidsAndAttributes(
                pRestrictedSidAttr,
                pCC->RestrictedSids,
                pCC->RestrictedSidCount,
                RestrictedSids,
                RestrictedSidCount
                );

        if (!b)
        {
            goto Cleanup;
        }
    }

    //
    // Copy the existing privileges into the allocated memory.
    //

    pPrivileges = (PLUID_AND_ATTRIBUTES) AuthzpAlloc(pCC->PrivilegeLength);

    if (AUTHZ_ALLOCATION_FAILED(pPrivileges))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        b = FALSE;
        goto Cleanup;
    }

    AuthzpCopyLuidAndAttributes(
        pNewCC,
        pCC->Privileges,
        pCC->PrivilegeCount,
        pPrivileges
        );

    //
    // Update fields in the client context.
    //

    pNewCC->Sids = pSidAttr;
    pNewCC->SidLength = SidLength;
    pNewCC->SidCount = SidCount + pCC->SidCount;
    pSidAttr = NULL;

    pNewCC->RestrictedSids = pRestrictedSidAttr;
    pNewCC->RestrictedSidLength = RestrictedSidLength;
    pNewCC->RestrictedSidCount = RestrictedSidCount + pCC->RestrictedSidCount;
    pRestrictedSidAttr = NULL;

    pNewCC->Privileges = pPrivileges;
    pNewCC->PrivilegeCount = pCC->PrivilegeCount;
    pNewCC->PrivilegeLength = pCC->PrivilegeLength;
    pPrivileges = NULL;

    *phNewAuthzClientContext = (AUTHZ_CLIENT_CONTEXT_HANDLE) pNewCC;

#ifdef AUTHZ_DEBUG
    wprintf(L"AddSids: Original Context:\n");
    AuthzPrintContext(pCC);
    wprintf(L"AddSids: New Context:\n");
    AuthzPrintContext(pNewCC);
#endif

    //
    // initialize the sid hash for regular sids
    //

    AuthzpInitSidHash(
        pNewCC->Sids,
        pNewCC->SidCount,
        pNewCC->SidHash
        );

    //
    // initialize the sid hash for restricted sids
    //

    AuthzpInitSidHash(
        pNewCC->RestrictedSids,
        pNewCC->RestrictedSidCount,
        pNewCC->RestrictedSidHash
        );

Cleanup:

    AuthzpReleaseClientContextLock(pCC);

    //
    // These statements are relevant in the failure case.
    // In the success case, the pointers are set to NULL.
    //

    if (!b)
    {
        DWORD dwSavedError = GetLastError();
        
        AuthzpFreeNonNull(pSidAttr);
        AuthzpFreeNonNull(pRestrictedSidAttr);
        AuthzpFreeNonNull(pPrivileges);
        if (AUTHZ_NON_NULL_PTR(pNewCC))
        {
            AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE)pNewCC);
        }
        SetLastError(dwSavedError);
    }
    return b;
}


BOOL
AuthzGetInformationFromContext(
    IN  AUTHZ_CLIENT_CONTEXT_HANDLE     hAuthzClientContext,
    IN  AUTHZ_CONTEXT_INFORMATION_CLASS InfoClass,
    IN  DWORD                           BufferSize,
    OUT PDWORD                          pSizeRequired,
    OUT PVOID                           Buffer
    )

/*++

Routine Description:

    This API returns information about the client context in a buffer supplied
    by the caller. It also returns the size of the buffer required to hold the
    requested information.

Arguments:

    AuthzClientContext - Authz client context from which requested information
    will be read.

    InfoClass - Type of information to be returned. The caller can ask for
            a. privileges
                   TOKEN_PRIVILEGES
            b. sids and their attributes
                   TOKEN_GROUPS
            c. restricted sids and their attributes
                   TOKEN_GROUPS
            d. authz context persistent structure which can be saved to and
               read from the disk.
                   PVOID
            e. User sid
                   TOKEN_USER
            f. Server Context one level higher
                   PAUTHZ_CLIENT_CONTEXT
            g. Expiration time
                   LARGE_INTEGER
            h. Identifier
                   LUID

     BufferSize - Size of the supplied buffer.

     pSizeRequired - To return the size of the structure needed to hold the results.

     Buffer - To hold the information requested. The structure returned will
     depend on the information class requested.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                  LocalSize = 0;
    PAUTHZI_CLIENT_CONTEXT pCC       = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;

    if (!ARGUMENT_PRESENT(hAuthzClientContext)         ||
        (!ARGUMENT_PRESENT(Buffer) && BufferSize != 0) ||
        !ARGUMENT_PRESENT(pSizeRequired))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *pSizeRequired = 0;

    switch(InfoClass)
    {
    case AuthzContextInfoUserSid:

        LocalSize = RtlLengthSid(pCC->Sids[0].Sid) + sizeof(TOKEN_USER);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        //
        // xor SE_GROUP_ENABLED from the User attributes.  Authz sets this because it simplifies
        // access check logic.
        //

        ((PTOKEN_USER)Buffer)->User.Attributes = pCC->Sids[0].Attributes ^ SE_GROUP_ENABLED;
        ((PTOKEN_USER)Buffer)->User.Sid        = ((PUCHAR) Buffer) + sizeof(TOKEN_USER);

        RtlCopyMemory(
            ((PTOKEN_USER)Buffer)->User.Sid,
            pCC->Sids[0].Sid,
            RtlLengthSid(pCC->Sids[0].Sid)
            );

        return TRUE;

    case AuthzContextInfoGroupsSids:

        LocalSize = pCC->SidLength +
                    sizeof(TOKEN_GROUPS) -
                    RtlLengthSid(pCC->Sids[0].Sid) -
                    2 * sizeof(SID_AND_ATTRIBUTES);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        ((PTOKEN_GROUPS) Buffer)->GroupCount = pCC->SidCount - 1;

        return AuthzpCopySidsAndAttributes(
                   ((PTOKEN_GROUPS) Buffer)->Groups,
                   pCC->Sids + 1,
                   pCC->SidCount - 1,
                   NULL,
                   0
                   );

    case AuthzContextInfoRestrictedSids:

        LocalSize = pCC->RestrictedSidLength + 
                    sizeof(TOKEN_GROUPS) -
                    sizeof(SID_AND_ATTRIBUTES);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        ((PTOKEN_GROUPS) Buffer)->GroupCount = pCC->RestrictedSidCount;

        return AuthzpCopySidsAndAttributes(
                   ((PTOKEN_GROUPS) Buffer)->Groups,
                   pCC->RestrictedSids,
                   pCC->RestrictedSidCount,
                   NULL,
                   0
                   );

    case AuthzContextInfoPrivileges:

        LocalSize = pCC->PrivilegeLength + 
                    sizeof(TOKEN_PRIVILEGES) - 
                    sizeof(LUID_AND_ATTRIBUTES);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        ((PTOKEN_PRIVILEGES) Buffer)->PrivilegeCount = pCC->PrivilegeCount;

        memcpy(
            ((PTOKEN_PRIVILEGES) Buffer)->Privileges,
            pCC->Privileges,
            pCC->PrivilegeLength
            );

        return TRUE;

    case AuthzContextInfoExpirationTime:

        LocalSize = sizeof(LARGE_INTEGER);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PLARGE_INTEGER) Buffer) = pCC->ExpirationTime;

        return TRUE;

    case AuthzContextInfoIdentifier:

        LocalSize = sizeof(LUID);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PLUID) Buffer) = pCC->Identifier;

        return TRUE;

    case AuthzContextInfoAuthenticationId:

        LocalSize = sizeof(LUID);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PLUID) Buffer) = pCC->AuthenticationId;

        return TRUE;

    case AuthzContextInfoServerContext:

        LocalSize = sizeof(AUTHZ_CLIENT_CONTEXT_HANDLE);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PAUTHZ_CLIENT_CONTEXT_HANDLE) Buffer) = (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC->Server;

        return TRUE;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}


BOOL
AuthzFreeContext(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext
    )

/*++

Routine Description:

    This API frees up all the structures/memory accociated with the client
    context. Note that the list of handles for this client will be freed in
    this call.

Arguments:

    AuthzClientContext - Context to be freed.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_CLIENT_CONTEXT pCC      = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    BOOL                   b        = TRUE;
    PAUTHZI_HANDLE         pCurrent = NULL;
    PAUTHZI_HANDLE         pPrev    = NULL;

    if (!ARGUMENT_PRESENT(pCC))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    AuthzpAcquireClientContextWriteLock(pCC);

    AuthzpFreeNonNull(pCC->Privileges);
    AuthzpFreeNonNull(pCC->Sids);
    AuthzpFreeNonNull(pCC->RestrictedSids);

    pCurrent = pCC->AuthzHandleHead;

    //
    // Loop thru all the handles and free them up.
    //

    while (AUTHZ_NON_NULL_PTR(pCurrent))
    {
        pPrev = pCurrent;
        pCurrent = pCurrent->next;
        AuthzpFree(pPrev);
    }

    //
    // Free up the server context. The context is a recursive structure.
    //

    if (AUTHZ_NON_NULL_PTR(pCC->Server))
    {
        b = AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE) pCC->Server);
    }

    AuthzpFree(pCC);

    return b;
}

AUTHZAPI
BOOL
WINAPI
AuthzInitializeObjectAccessAuditEvent(
    IN  DWORD                         Flags,
    IN  AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType,
    IN  PWSTR                         szOperationType,
    IN  PWSTR                         szObjectType,
    IN  PWSTR                         szObjectName,
    IN  PWSTR                         szAdditionalInfo,
    OUT PAUTHZ_AUDIT_EVENT_HANDLE     phAuditEvent,
    IN  DWORD                         dwAdditionalParameterCount,
    ...
    )

/*++

Routine Description:

    Allocates and initializes an AUTHZ_AUDIT_EVENT_HANDLE for use with AuthzAccessCheck.  
    The handle is used for storing information for audit generation.  
    
Arguments:

    Flags - Audit flags.  Currently defined bits are:
        AUTHZ_NO_SUCCESS_AUDIT - disables generation of success audits
        AUTHZ_NO_FAILURE_AUDIT - disables generation of failure audits
        AUTHZ_NO_ALLOC_STRINGS - storage space is not allocated for the 4 wide character strings.  Rather,
            the handle will only hold pointers to resource manager memory.
    
    hAuditEventType - for future use.  Should be NULL.
    
    szOperationType - Resource manager defined string that indicates the operation being
        performed that is to be audited.

    szObjectType - Resource manager defined string that indicates the type of object being
        accessed.

    szObjectName - the name of the specific object being accessed.
    
    szAdditionalInfo - Resource Manager defined string for additional audit information.

    phAuditEvent - pointer to AUTHZ_AUDIT_EVENT_HANDLE.  Space for this is allocated in the function.
    
    dwAdditionalParameterCount - Must be zero.
    
Return Value:

    Returns TRUE if successful, FALSE if unsuccessful.  
    Extended information available with GetLastError().    
    
--*/

{
    UNREFERENCED_PARAMETER(dwAdditionalParameterCount);

    return AuthzInitializeObjectAccessAuditEvent2(
               Flags,
               hAuditEventType,
               szOperationType,
               szObjectType,
               szObjectName,
               szAdditionalInfo,
               L"\0",
               phAuditEvent,
               0
               );
}

AUTHZAPI
BOOL
WINAPI
AuthzInitializeObjectAccessAuditEvent2(
    IN  DWORD                         Flags,
    IN  AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType,
    IN  PWSTR                         szOperationType,
    IN  PWSTR                         szObjectType,
    IN  PWSTR                         szObjectName,
    IN  PWSTR                         szAdditionalInfo,
    IN  PWSTR                         szAdditionalInfo2,
    OUT PAUTHZ_AUDIT_EVENT_HANDLE     phAuditEvent,
    IN  DWORD                         dwAdditionalParameterCount,
    ...
    )

/*++

Routine Description:

    Allocates and initializes an AUTHZ_AUDIT_EVENT_HANDLE for use with AuthzAccessCheck.  
    The handle is used for storing information for audit generation.  
    
Arguments:

    Flags - Audit flags.  Currently defined bits are:
        AUTHZ_NO_SUCCESS_AUDIT - disables generation of success audits
        AUTHZ_NO_FAILURE_AUDIT - disables generation of failure audits
        AUTHZ_NO_ALLOC_STRINGS - storage space is not allocated for the 4 wide character strings.  Rather,
            the handle will only hold pointers to resource manager memory.
    
    hAuditEventType - for future use.  Should be NULL.
    
    szOperationType - Resource manager defined string that indicates the operation being
        performed that is to be audited.

    szObjectType - Resource manager defined string that indicates the type of object being
        accessed.

    szObjectName - the name of the specific object being accessed.
    
    szAdditionalInfo - Resource Manager defined string for additional audit information.
    
    szAdditionalInfo2 - Resource Manager defined string for additional audit information.

    phAuditEvent - pointer to AUTHZ_AUDIT_EVENT_HANDLE.  Space for this is allocated in the function.
    
    dwAdditionalParameterCount - Must be zero.
    
Return Value:

    Returns TRUE if successful, FALSE if unsuccessful.  
    Extended information available with GetLastError().    
    
--*/

{
    PAUTHZI_AUDIT_EVENT pAuditEvent             = NULL;
    BOOL                b                       = TRUE;
    DWORD               dwStringSize            = 0;
    DWORD               dwObjectTypeLength      = 0;
    DWORD               dwObjectNameLength      = 0;
    DWORD               dwOperationTypeLength   = 0;
    DWORD               dwAdditionalInfoLength  = 0;
    DWORD               dwAdditionalInfo2Length = 0;

    if ((!ARGUMENT_PRESENT(phAuditEvent))      ||
        (NULL != hAuditEventType)              ||
        (0 != dwAdditionalParameterCount)      ||
        (!ARGUMENT_PRESENT(szOperationType))   ||
        (!ARGUMENT_PRESENT(szObjectType))      ||
        (!ARGUMENT_PRESENT(szObjectName))      ||
        (!ARGUMENT_PRESENT(szAdditionalInfo))  ||
        (!ARGUMENT_PRESENT(szAdditionalInfo2)) ||
        (Flags & (~(AUTHZ_VALID_OBJECT_ACCESS_AUDIT_FLAGS | AUTHZ_DS_CATEGORY_FLAG))))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuditEvent = NULL;
    
    //
    // Allocate and initialize a new AUTHZI_AUDIT_EVENT.  Include for the string in the contiguous memory, if
    // needed.
    //

    if (FLAG_ON(Flags, AUTHZ_NO_ALLOC_STRINGS))
    {
        dwStringSize = 0;
    } 
    else
    {
        dwOperationTypeLength   = (DWORD) wcslen(szOperationType) + 1;
        dwObjectTypeLength      = (DWORD) wcslen(szObjectType) + 1;
        dwObjectNameLength      = (DWORD) wcslen(szObjectName) + 1;
        dwAdditionalInfoLength  = (DWORD) wcslen(szAdditionalInfo) + 1;
        dwAdditionalInfo2Length = (DWORD) wcslen(szAdditionalInfo2) + 1;

        dwStringSize = sizeof(WCHAR) * (dwOperationTypeLength + dwObjectTypeLength + dwObjectNameLength + dwAdditionalInfoLength + dwAdditionalInfo2Length);
    }

    pAuditEvent = (PAUTHZI_AUDIT_EVENT) AuthzpAlloc(sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize);

    if (AUTHZ_ALLOCATION_FAILED(pAuditEvent))
    {
        b = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    if (FLAG_ON(Flags, AUTHZ_NO_ALLOC_STRINGS))
    {
        pAuditEvent->szOperationType   = szOperationType;
        pAuditEvent->szObjectType      = szObjectType;
        pAuditEvent->szObjectName      = szObjectName;
        pAuditEvent->szAdditionalInfo  = szAdditionalInfo;
        pAuditEvent->szAdditionalInfo2 = szAdditionalInfo2;
    }
    else
    {
        //
        // Set the string pointers into the contiguous memory.
        //

        pAuditEvent->szOperationType = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT));
        
        RtlCopyMemory(
            pAuditEvent->szOperationType,
            szOperationType,
            sizeof(WCHAR) * dwOperationTypeLength
            );

    
        pAuditEvent->szObjectType = (PWSTR)((PUCHAR)pAuditEvent->szOperationType + (sizeof(WCHAR) * dwOperationTypeLength));

        RtlCopyMemory(
            pAuditEvent->szObjectType,
            szObjectType,
            sizeof(WCHAR) * dwObjectTypeLength
            );

        pAuditEvent->szObjectName = (PWSTR)((PUCHAR)pAuditEvent->szObjectType + (sizeof(WCHAR) * dwObjectTypeLength));

        RtlCopyMemory(
            pAuditEvent->szObjectName,
            szObjectName,
            sizeof(WCHAR) * dwObjectNameLength
            );

        pAuditEvent->szAdditionalInfo = (PWSTR)((PUCHAR)pAuditEvent->szObjectName + (sizeof(WCHAR) * dwObjectNameLength));

        RtlCopyMemory(
            pAuditEvent->szAdditionalInfo,
            szAdditionalInfo,
            sizeof(WCHAR) * dwAdditionalInfoLength
            );

        pAuditEvent->szAdditionalInfo2 = (PWSTR)((PUCHAR)pAuditEvent->szAdditionalInfo + (sizeof(WCHAR) * dwAdditionalInfoLength));

        RtlCopyMemory(
            pAuditEvent->szAdditionalInfo2,
            szAdditionalInfo2,
            sizeof(WCHAR) * dwAdditionalInfo2Length
            );
    }

    //
    // AEI and Queue will be filled in from RM in AuthzpCreateAndLogAudit
    //

    pAuditEvent->hAET            = NULL;
    pAuditEvent->hAuditQueue     = NULL;
    pAuditEvent->pAuditParams    = NULL;
    pAuditEvent->Flags           = Flags;
    pAuditEvent->dwTimeOut       = INFINITE;
    pAuditEvent->dwSize          = sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize;

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pAuditEvent);
    }
    else
    {
        *phAuditEvent = (AUTHZ_AUDIT_EVENT_HANDLE) pAuditEvent;
    }
    return b;
}


BOOL
AuthzGetInformationFromAuditEvent(
    IN  AUTHZ_AUDIT_EVENT_HANDLE            hAuditEvent,
    IN  AUTHZ_AUDIT_EVENT_INFORMATION_CLASS InfoClass,
    IN  DWORD                               BufferSize,
    OUT PDWORD                              pSizeRequired,
    OUT PVOID                               Buffer
    )

/*++

Routine Description

    Queries information in the AUTHZ_AUDIT_EVENT_HANDLE.
    
Arguments

    hAuditEvent - the AUTHZ_AUDIT_EVENT_HANDLE to query.
    
    InfoClass - The class of information to query.  Valid values are:
        
        a. AuthzAuditEventInfoFlags - returns the flags set for the handle.  Type is DWORD.
        e. AuthzAuditEventInfoOperationType - returns the operation type.  Type is PCWSTR.
        e. AuthzAuditEventInfoObjectType - returns the object type.  Type is PCWSTR.
        f. AuthzAuditEventInfoObjectName - returns the object name.  Type is PCWSTR.
        g. AuthzAuditEventInfoAdditionalInfo - returns the additional info field.  Type is PCWSTR.
    
    BufferSize - Size of the supplied buffer.

    pSizeRequired - To return the size of the structure needed to hold the results.

    Buffer - To hold the information requested. The structure returned will
        depend on the information class requested.

Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().

--*/

{

    DWORD               LocalSize  = 0;
    PAUTHZI_AUDIT_EVENT pAuditEvent = (PAUTHZI_AUDIT_EVENT) hAuditEvent;

    if ((!ARGUMENT_PRESENT(hAuditEvent))             ||
        (!ARGUMENT_PRESENT(pSizeRequired))           ||
        (!ARGUMENT_PRESENT(Buffer) && BufferSize > 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *pSizeRequired = 0;

    switch(InfoClass)
    {
    case AuthzAuditEventInfoFlags:
        
        LocalSize = sizeof(DWORD);
        
        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }
        
        *((PDWORD)Buffer) = pAuditEvent->Flags;

        return TRUE;

    case AuthzAuditEventInfoOperationType:
    
        LocalSize = (DWORD)(sizeof(WCHAR) * (wcslen(pAuditEvent->szOperationType) + 1));

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        RtlCopyMemory(
            Buffer,
            pAuditEvent->szOperationType,
            LocalSize
            );

        return TRUE;

    case AuthzAuditEventInfoObjectType:
    
        LocalSize = (DWORD)(sizeof(WCHAR) * (wcslen(pAuditEvent->szObjectType) + 1));

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        RtlCopyMemory(
            Buffer,
            pAuditEvent->szObjectType,
            LocalSize
            );

        return TRUE;

    case AuthzAuditEventInfoObjectName:
    
        LocalSize = (DWORD)(sizeof(WCHAR) * (wcslen(pAuditEvent->szObjectName) + 1));

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        RtlCopyMemory(
            Buffer,
            pAuditEvent->szObjectName,
            LocalSize
            );

        return TRUE;

    case AuthzAuditEventInfoAdditionalInfo:

        if (NULL == pAuditEvent->szAdditionalInfo)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        LocalSize = (DWORD)(sizeof(WCHAR) * (wcslen(pAuditEvent->szAdditionalInfo) + 1));

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        RtlCopyMemory(
            Buffer,
            pAuditEvent->szAdditionalInfo,
            LocalSize
            );

        return TRUE;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}


BOOL
AuthzFreeAuditEvent(
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent
    )

/*++

Routine Description:

    Frees hAuditEvent and notifies the appropriate queue to unregister the audit context in LSA.
    
Arguments:

    hAuditEvent - AUTHZ_AUDIT_EVENT_HANDLE.  Must have initially been created 
        with AuthzRMInitializeObjectAccessAuditEvent or AuthzInitializeAuditEvent().
        
Return Value:

    Boolean: TRUE if successful; FALSE if failure.  
    Extended information available with GetLastError().
    
--*/

{
    PAUTHZI_AUDIT_EVENT pAuditEvent = (PAUTHZI_AUDIT_EVENT) hAuditEvent;

    if (!ARGUMENT_PRESENT(hAuditEvent))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the RM specified the AuditEvent, then we should deref the context.  If the AuditEvent
    // has not been used, or was a default event type, then this field will be NULL.
    //

    if (AUTHZ_NON_NULL_PTR(pAuditEvent->hAET))
    {
        AuthzpDereferenceAuditEventType(pAuditEvent->hAET);
    }

    AuthzpFree(pAuditEvent);
    return TRUE;
}


//
// Routines for internal callers.
//


BOOL
AuthziInitializeAuditEventType(
    IN DWORD Flags,
    IN USHORT CategoryID,
    IN USHORT AuditID,
    IN USHORT ParameterCount,
    OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
    )

/*++

Routine Description

    Initializes an AUTHZ_AUDIT_EVENT_TYPE_HANDLE for use in AuthzInitializeAuditEvent().
    
Arguments

    phAuditEventType - pointer to pointer to receive memory allocated for AUTHZ_AUDIT_EVENT_TYPE_HANDLE.
    
    dwFlags - Flags that control behavior of function.
        AUTHZ_INIT_GENERIC_AUDIT_EVENT - initialize the AUTHZ_AUDIT_EVENT_TYPE for generic object 
        access audits.  When this flag is specified, none of the optional parameters need to 
        be passed.  This is equivalent to calling:
           
           AuthzInitializeAuditEvent(
               &hAEI,
               0,
               SE_CATEGID_OBJECT_ACCESS,
               SE_AUDITID_OBJECT_OPERATION,
               AUTHZP_NUM_PARAMS_FOR_SE_AUDITID_OBJECT_OPERATION
               );

    CategoryID - The category id of the audit.
    
    AuditID - The ID of the audit in msaudite.
    
    ParameterCount - The number of fields in the audit.        
        
Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().

--*/

{
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAET   = NULL;
    BOOL                        b      = TRUE;
    AUDIT_HANDLE                hAudit = NULL;

    if (!ARGUMENT_PRESENT(phAuditEventType))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuditEventType = NULL;

    pAET = AuthzpAlloc(sizeof(AUTHZ_AUDIT_EVENT_TYPE_OLD));

    if (AUTHZ_ALLOCATION_FAILED(pAET))
    {
        b = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    if (FLAG_ON(Flags, AUTHZP_INIT_GENERIC_AUDIT_EVENT))
    {
        pAET->Version                 = AUDIT_TYPE_LEGACY;
        pAET->u.Legacy.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
        pAET->u.Legacy.AuditId        = SE_AUDITID_OBJECT_OPERATION;
        pAET->u.Legacy.ParameterCount = AUTHZP_NUM_PARAMS_FOR_SE_AUDITID_OBJECT_OPERATION + AUTHZP_NUM_FIXED_HEADER_PARAMS;
    }
    else
    {
        pAET->Version                 = AUDIT_TYPE_LEGACY;
        pAET->u.Legacy.CategoryId     = CategoryID;
        pAET->u.Legacy.AuditId        = AuditID;
        
        // 
        // ParameterCount gets increased by 2 because the LSA expects the first two
        // parameters to be the user sid and subsystem name.
        //

        pAET->u.Legacy.ParameterCount = ParameterCount + AUTHZP_NUM_FIXED_HEADER_PARAMS;
    }

    b = AuthzpRegisterAuditEvent( 
            pAET, 
            &hAudit 
            ); 

    if (!b)
    {
        goto Cleanup;
    }

    pAET->hAudit     = (ULONG_PTR) hAudit;
    pAET->dwFlags    = Flags & ~AUTHZP_INIT_GENERIC_AUDIT_EVENT;

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pAET);
    }
    else
    {
        AuthzpReferenceAuditEventType((AUTHZ_AUDIT_EVENT_TYPE_HANDLE)pAET);
        *phAuditEventType = (AUTHZ_AUDIT_EVENT_TYPE_HANDLE)pAET;
    }
    return b;
}


BOOL
AuthziModifyAuditEventType(
    IN DWORD Flags,
    IN USHORT CategoryID,
    IN USHORT AuditID,
    IN USHORT ParameterCount,
    IN OUT AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType
    )

/*++

Routine Description

    Modifies an existing AuditEventType.
    
Arguments

    Flags - AUTHZ_AUDIT_EVENT_TYPE_AUDITID
    
Return Value

--*/
{
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAAETO = (PAUTHZ_AUDIT_EVENT_TYPE_OLD) hAuditEventType;
    BOOL                        b      = TRUE;

    if (!ARGUMENT_PRESENT(hAuditEventType))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    UNREFERENCED_PARAMETER(CategoryID);
    UNREFERENCED_PARAMETER(ParameterCount);

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_TYPE_AUDITID))
    {
        pAAETO->u.Legacy.AuditId = AuditID;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_TYPE_CATEGID))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_TYPE_PARAM))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

Cleanup:

    return b;
}


BOOL
AuthziFreeAuditEventType(
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType
    )

/*++

Routine Description

    Frees the PAUDIT_EVENT_TYPE allocated by AuthzInitializeAuditEventType().
    
Arguments

    pAuditEventType - pointer to memory to free.
    
Return Value
    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
    
--*/

{
    BOOL b = TRUE;

    if (!ARGUMENT_PRESENT(hAuditEventType))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    b = AuthzpDereferenceAuditEventType(
            hAuditEventType
            );
    
    return b;
}


AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditQueue(
    IN DWORD Flags,
    IN DWORD dwAuditQueueHigh,
    IN DWORD dwAuditQueueLow,
    IN PVOID Reserved,
    OUT PAUTHZ_AUDIT_QUEUE_HANDLE phAuditQueue
    )

/*++

Routine Description

    Creates an audit queue.
    
Arguments

    phAuditQueue - pointer to handle for the audit queue.
    
    Flags -
        
        AUTHZ_MONITOR_AUDIT_QUEUE_SIZE - notifies Authz that it should not let the size of the 
        audit queue grow unchecked.  
        
    dwAuditQueueHigh - high water mark for the audit queue.
    
    dwAuditQueueLow - low water mark for the audit queue.
        
    Reserved - for future expansion.                  

Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
--*/

{
    PAUTHZI_AUDIT_QUEUE pQueue = NULL;
    BOOL                b      = TRUE;
    BOOL                bCrit  = FALSE;
    NTSTATUS            Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(Reserved);

    if (!ARGUMENT_PRESENT(phAuditQueue))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuditQueue = NULL;

    pQueue = AuthzpAlloc(sizeof(AUTHZI_AUDIT_QUEUE));

    if (AUTHZ_ALLOCATION_FAILED(pQueue))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        b = FALSE;
        goto Cleanup;
    }

    pQueue->dwAuditQueueHigh = dwAuditQueueHigh;
    pQueue->dwAuditQueueLow  = dwAuditQueueLow;
    pQueue->bWorker          = TRUE;
    pQueue->Flags            = Flags;


    //
    // This event is set whenever an audit is queued with AuthziLogAuditEvent().  It
    // notifies the dequeueing thread that there is work to do.  
    //

    pQueue->hAuthzAuditAddedEvent = CreateEvent(
                                        NULL,
                                        TRUE,  
                                        FALSE, // Initially not signaled, since no audit has been added yet.
                                        NULL
                                        );

    if (NULL == pQueue->hAuthzAuditAddedEvent)
    {
        b = FALSE;
        goto Cleanup;
    }

    //
    // This event is set when the audit queue is empty.
    //

    pQueue->hAuthzAuditQueueEmptyEvent = CreateEvent(
                                             NULL,
                                             TRUE, 
                                             TRUE, // Initially signaled.
                                             NULL
                                             );

    if (NULL == pQueue->hAuthzAuditQueueEmptyEvent)
    {
        b = FALSE;
        goto Cleanup;
    }

    //
    // This event is set when the audit queue is below the low water mark.
    //

    pQueue->hAuthzAuditQueueLowEvent = CreateEvent(
                                           NULL,
                                           FALSE,// The system only schedules one thread waiting on this event (auto reset event).
                                           TRUE, // Initially set.
                                           NULL
                                           );

    if (NULL == pQueue->hAuthzAuditQueueLowEvent)
    {
        b = FALSE;
        goto Cleanup;
    }
    
    //
    // This boolean is true only when the high water mark has been reached
    //

    pQueue->bAuthzAuditQueueHighEvent = FALSE;

    //
    // This lock is taken whenever audits are being added or removed from the queue, or events / boolean being set.
    //

    Status = RtlInitializeCriticalSection(&pQueue->AuthzAuditQueueLock);
    if (!NT_SUCCESS(Status))
    {
        SetLastError(RtlNtStatusToDosError(Status));
        b = FALSE;
        goto Cleanup;
    }
    bCrit = TRUE;

    //
    // Initialize the list
    //

    InitializeListHead(&pQueue->AuthzAuditQueue);
    
    //
    // Create the worker thread that sends audits to LSA.
    //

    pQueue->hAuthzAuditThread = CreateThread(
                                    NULL,
                                    0,
                                    AuthzpDeQueueThreadWorker,
                                    pQueue,
                                    0,
                                    NULL
                                    );

    if (NULL == pQueue->hAuthzAuditThread)
    {
        b = FALSE;
        goto Cleanup;
    }

Cleanup:
    
    if (!b)
    {
        if (AUTHZ_NON_NULL_PTR(pQueue))
        {
            if (bCrit)
            {
                RtlDeleteCriticalSection(&pQueue->AuthzAuditQueueLock);
            }
            AuthzpCloseHandleNonNull(pQueue->hAuthzAuditQueueLowEvent);
            AuthzpCloseHandleNonNull(pQueue->hAuthzAuditAddedEvent);
            AuthzpCloseHandleNonNull(pQueue->hAuthzAuditQueueEmptyEvent);
            AuthzpCloseHandleNonNull(pQueue->hAuthzAuditThread);
            AuthzpFree(pQueue);
        }
    }
    else
    {
        *phAuditQueue = (AUTHZ_AUDIT_QUEUE_HANDLE)pQueue;
    }
    return b;
}
    

AUTHZAPI
BOOL
WINAPI
AuthziModifyAuditQueue(
    IN OUT AUTHZ_AUDIT_QUEUE_HANDLE hQueue OPTIONAL,
    IN DWORD Flags,
    IN DWORD dwQueueFlags OPTIONAL,
    IN DWORD dwAuditQueueSizeHigh OPTIONAL,
    IN DWORD dwAuditQueueSizeLow OPTIONAL,
    IN DWORD dwThreadPriority OPTIONAL
    )

/*++

Routine Description

    Allows the Resource Manager to modify audit queue information.

Arguments

    Flags - Flags specifying which fields are to be reinitialized.  Valid flags are:
        
        AUTHZ_AUDIT_QUEUE_HIGH            
        AUTHZ_AUDIT_QUEUE_LOW             
        AUTHZ_AUDIT_QUEUE_THREAD_PRIORITY 
        AUTHZ_AUDIT_QUEUE_FLAGS           

        Specifying one of the above flags in the Flags field causes the appropriate field of 
        the resource manager to be modified to the correct value below:
        
    dwQueueFlags - set the flags for the audit queue.
                                                                                          
    dwAuditQueueSizeHigh - High water mark for the audit queue.
    
    dwAuditQueueSizeLow - Low water mark for the audit queue.
    
    dwThreadPriority - Changes the priority of the audit dequeue thread.  Valid values are described
        in the SetThreadPriority API.  A RM may wish to change the priority of the thread if, for example,
         the high water mark is being reached too frequently and the RM does not want to allow the queue to
         grow beyond its current size.

Return Value

    Boolean: TRUE on success; FALSE on failure.  
    Extended information available with GetLastError().

--*/

{
    BOOL                b      = TRUE;
    PAUTHZI_AUDIT_QUEUE pQueue = NULL;

    if (!ARGUMENT_PRESENT(hQueue))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pQueue = (PAUTHZI_AUDIT_QUEUE)hQueue;

    //
    // Set the fields that the caller has asked us to initialize.
    //

    if (FLAG_ON(Flags, AUTHZ_AUDIT_QUEUE_FLAGS))
    {
        pQueue->Flags = dwQueueFlags;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_QUEUE_HIGH))
    {
        pQueue->dwAuditQueueHigh = dwAuditQueueSizeHigh;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_QUEUE_LOW))
    {
        pQueue->dwAuditQueueLow = dwAuditQueueSizeLow;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_QUEUE_THREAD_PRIORITY))
    {
        b = SetThreadPriority(pQueue->hAuthzAuditThread, dwThreadPriority);
        if (!b)
        {
            goto Cleanup;
        }
    }

Cleanup:    
    
    return b;
}


AUTHZAPI
BOOL
WINAPI
AuthziFreeAuditQueue(
    IN AUTHZ_AUDIT_QUEUE_HANDLE hQueue OPTIONAL
    )

/*++

Routine Description

    This API flushes and frees a queue.  The actual freeing of queue memory occurs in the dequeueing thread,
    after all audits have been flushed.
        
Arguments

    hQueue - handle to the queue object to free.
    
Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
    
--*/

{
    PAUTHZI_AUDIT_QUEUE pQueue  = (PAUTHZI_AUDIT_QUEUE) hQueue;
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                b       = TRUE;

    if (!ARGUMENT_PRESENT(hQueue))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    dwError = WaitForSingleObject(
                  pQueue->hAuthzAuditQueueEmptyEvent, 
                  INFINITE
                  );

    if (WAIT_OBJECT_0 != dwError)
    {
        ASSERT(L"WaitForSingleObject on hAuthzAuditQueueEmptyEvent failed." && FALSE);
        SetLastError(dwError);
        b = FALSE;
        goto Cleanup;
    }

    //
    // Set this BOOL to FALSE so that the dequeueing thread knows it can terminate.  Set the 
    // AddedEvent so that the thread can be scheduled.
    //

    pQueue->bWorker = FALSE;        

    b = SetEvent(
            pQueue->hAuthzAuditAddedEvent
            );

    if (!b)
    {
        goto Cleanup;
    }

    //
    // Wait for the thread to terminate.
    //

    dwError = WaitForSingleObject(
                  pQueue->hAuthzAuditThread, 
                  INFINITE
                  );

    //
    // The wait should succeed since we have told the thread to finish working.
    //

    if (WAIT_OBJECT_0 != dwError)
    {
        ASSERT(L"WaitForSingleObject on hAuthzAuditThread failed." && FALSE);
        SetLastError(dwError);
        b = FALSE;
        goto Cleanup;
    }
    
    RtlDeleteCriticalSection(&pQueue->AuthzAuditQueueLock);
    AuthzpCloseHandle(pQueue->hAuthzAuditAddedEvent);
    AuthzpCloseHandle(pQueue->hAuthzAuditQueueLowEvent);
    AuthzpCloseHandle(pQueue->hAuthzAuditQueueEmptyEvent);
    AuthzpCloseHandle(pQueue->hAuthzAuditThread);
    AuthzpFree(pQueue);

Cleanup:

    return b;
}
    

BOOL
AuthziLogAuditEvent(
    IN DWORD Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent,
    IN PVOID pReserved
    )

/*++

Routine Description:

    This API manages the logging of Audit Records.  The function constructs an 
    Audit Record from the information provided and appends it to the Audit 
    Record Queue, a doubly-linked list of Audit Records awaiting output to the 
    Audit Log.  A dedicated thread reads this queue, sending the Audit Records 
    to the LSA and removing them from the Audit Queue.  
        
    This call is not guaranteed to return without latency.  If the queue is at 
    or above the high water mark for size, then the calling thread will be 
    suspended until such time that the queue reaches the low water mark.  Be 
    aware of this latency when fashioning your calls to AuthziLogAuditEvent.  
    If such latency is not allowable for the audit that is being generated, 
    then specify the correct flag when initializing the 
    AUTHZ_AUDIT_EVENT_HANDLE (in AuthzInitAuditEventHandle()).  Flags are listed 
    in that routines description.  
        
Arguments:

    hAuditEvent   - handle previously obtained by calling AuthzInitAuditEventHandle

    Flags       - TBD

    pReserved     - reserved for future enhancements

Return Value:

    Boolean: TRUE on success, FALSE on failure.  
    Extended information available with GetLastError().
                    
--*/
                    
{
    DWORD                    dwError                 = ERROR_SUCCESS;
    BOOL                     b                       = TRUE;
    BOOL                     bRef                    = FALSE;
    PAUTHZI_AUDIT_QUEUE      pQueue                  = NULL;
    PAUDIT_PARAMS            pMarshalledAuditParams  = NULL;
    PAUTHZ_AUDIT_QUEUE_ENTRY pAuthzAuditEntry        = NULL;
    PAUTHZI_AUDIT_EVENT      pAuditEvent             = (PAUTHZI_AUDIT_EVENT)hAuditEvent;
    
    //
    // Verify what the caller has passed in.
    //

    if (!ARGUMENT_PRESENT(hAuditEvent))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    //
    // Make a self relative copy of the pAuditEvent->pAuditParams.
    //

    b = AuthzpMarshallAuditParams(
            &pMarshalledAuditParams, 
            pAuditEvent->pAuditParams
            );

    if (!b)
    {
        goto Cleanup;
    }

    pQueue = (PAUTHZI_AUDIT_QUEUE)pAuditEvent->hAuditQueue;

    if (NULL == pQueue)
    {
        
        b = AuthzpSendAuditToLsa(
                (AUDIT_HANDLE)((PAUTHZ_AUDIT_EVENT_TYPE_OLD)pAuditEvent->hAET)->hAudit,
                0,
                pMarshalledAuditParams,
                NULL
                );
        
        goto Cleanup;
    }
    else
    {

        //
        // Create the audit queue entry.
        //

        pAuthzAuditEntry = AuthzpAlloc(sizeof(AUTHZ_AUDIT_QUEUE_ENTRY));

        if (AUTHZ_ALLOCATION_FAILED(pAuthzAuditEntry))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        pAuthzAuditEntry->pAAETO        = (PAUTHZ_AUDIT_EVENT_TYPE_OLD)pAuditEvent->hAET;
        pAuthzAuditEntry->Flags         = Flags;
        pAuthzAuditEntry->pReserved     = pReserved;
        pAuthzAuditEntry->pAuditParams  = pMarshalledAuditParams;
    
        AuthzpReferenceAuditEventType(pAuditEvent->hAET);
        bRef = TRUE;

        if (FLAG_ON(pQueue->Flags, AUTHZ_MONITOR_AUDIT_QUEUE_SIZE))
        {
            
            //
            // Monitor queue size if specified by the Resource Manager.
            //

            //
            // If we are closing in on the high water mark then wait for the queue 
            // to be below the low water mark.
            //

#define AUTHZ_QUEUE_WAIT_HEURISTIC .75

            if (pQueue->AuthzAuditQueueLength > pQueue->dwAuditQueueHigh * AUTHZ_QUEUE_WAIT_HEURISTIC)
            {
                dwError = WaitForSingleObject(
                              pQueue->hAuthzAuditQueueLowEvent, 
                              pAuditEvent->dwTimeOut
                              );

                if (WAIT_FAILED == dwError)
                {
                    ASSERT(L"WaitForSingleObject on hAuthzAuditQueueLowEvent failed." && FALSE);
                }

                if (WAIT_OBJECT_0 != dwError)
                {
                    b = FALSE;
                    
                    //
                    // Don't set last error if WAIT_FAILED, because it is already set.
                    //
                    
                    if (WAIT_FAILED != dwError)
                    {
                        SetLastError(dwError);
                    }
                    goto Cleanup;
                }
            }

            //
            // Queue the event and modify appropriate events.
            //

            b = AuthzpEnQueueAuditEventMonitor(
                    pQueue,
                    pAuthzAuditEntry
                    );
            
            goto Cleanup;
        }
        else
        {

            //
            // If we are not to monitor the audit queue then simply queue the entry.
            //

            b = AuthzpEnQueueAuditEvent(
                    pQueue,
                    pAuthzAuditEntry
                    );

            goto Cleanup;
        }
    }

Cleanup:

    if (pQueue)
    {
        if (FALSE == b)
        {
            if (bRef)
            {
                AuthzpDereferenceAuditEventType(pAuditEvent->hAET);
            }
            AuthzpFreeNonNull(pAuthzAuditEntry);
            AuthzpFreeNonNull(pMarshalledAuditParams);
        }

        //
        // hAuthzAuditQueueLowEvent is an auto reset event.  Only one waiting thread is released when it is signalled, and then
        // event is automatically switched to a nonsignalled state.  This is appropriate here because it keeps many threads from
        // running and overflowing the high water mark.  However, I must always resignal the event myself if the conditions
        // for signaling are true.
        //

        RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
        if (!pQueue->bAuthzAuditQueueHighEvent)
        {
            if (pQueue->AuthzAuditQueueLength <= pQueue->dwAuditQueueHigh)
            {
                BOOL bSet;
                bSet = SetEvent(pQueue->hAuthzAuditQueueLowEvent);
                if (!bSet)
                {
                    ASSERT(L"SetEvent on hAuthzAuditQueueLowEvent failed" && FALSE);
                }

            }
        }
        RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);
    }
    else
    {
        AuthzpFreeNonNull(pMarshalledAuditParams);
    }
    return b;
}



BOOL
AuthziAllocateAuditParams(
    OUT PAUDIT_PARAMS * ppParams,
    IN USHORT NumParams
    )
/*++

Routine Description:

    Allocate the AUDIT_PARAMS structure for the correct number of parameters.
     
Arguments:

    ppParams       - pointer to PAUDIT_PARAMS structure to be initialized.

    NumParams     - number of parameters passed in the var-arg section.
                    This must be SE_MAX_AUDIT_PARAMETERS or less.
Return Value:
    
     Boolean: TRUE on success, FALSE on failure.  Extended information available with GetLastError().

--*/
{
    BOOL                     b               = TRUE;
    PAUDIT_PARAMS            pAuditParams    = NULL;
    
    if (!ARGUMENT_PRESENT(ppParams))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    *ppParams = NULL;

    //
    // the first two params are always fixed. thus the total number
    // is 2 + the passed number.
    //

    if ((NumParams + 2) > SE_MAX_AUDIT_PARAMETERS)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

    pAuditParams = AuthzpAlloc(sizeof(AUDIT_PARAMS) + (sizeof(AUDIT_PARAM) * (NumParams + 2)));
    
    if (AUTHZ_ALLOCATION_FAILED(pAuditParams))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        b = FALSE;
        goto Cleanup;
    }

    pAuditParams->Parameters = (PAUDIT_PARAM)((PUCHAR)pAuditParams + sizeof(AUDIT_PARAMS));

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pAuditParams);
    }
    else
    {
        *ppParams = pAuditParams;
    }
    return b;
}


BOOL
AuthziInitializeAuditParamsWithRM(
    IN DWORD Flags,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hResourceManager,
    IN USHORT NumParams,
    OUT PAUDIT_PARAMS pParams,
    ...
    )
/*++

Routine Description:

    Initialize the AUDIT_PARAMS structure based on the passed
    data. This is the recommended way to init AUDIT_PARAMS.  It is
    faster than AuthzInitializeAuditParams and works with an 
    impersonating caller.

    The caller passes in type ~ value pairs in the vararg section.
    This function will initialize the corresponding array elements
    based on each such pair. In case of certain types, there may
    be more than one value argument required. This requirement
    is documented next to each param-type.

Arguments:

    pParams       - pointer to AUDIT_PARAMS structure to be initialized
                    the size of pParams->Parameters member must be big enough
                    to hold NumParams elements. The caller must allocate
                    memory for this structure and its members.

    hResourceManager - Handle to the Resource manager that is creating the audit.
    
    Flags       - control flags. one or more of the following:
                    APF_AuditSuccess

    NumParams     - number of parameters passed in the var-arg section.
                    This must be SE_MAX_AUDIT_PARAMETERS or less.

    ...           - The format of the variable arg portion is as follows:
                    
                    <one of APT_ * flags> <zero or more values>

                    APT_String  <pointer to null terminated string>

                                Flags:
                                AP_Filespec  : treats the string as a filename
                    
                    APT_Ulong   <ulong value> [<object-type-index>]
                    
                                Flags:
                                AP_FormatHex : number appears in hex
                                               in eventlog
                                AP_AccessMask: number is treated as
                                               an access-mask
                                               Index to object type must follow

                    APT_Pointer <pointer/handle>
                                32 bit on 32 bit systems and
                                64 bit on 64 bit systems

                    APT_Sid     <pointer to sid>

                    APT_Luid    <Luid>
                    
                    APT_Guid    <pointer to guid>
                    
                    APT_LogonId [<logon-id>]
                    
                                Flags:
                                AP_PrimaryLogonId : logon-id is captured
                                                    from the process token.
                                                    No need to specify one.

                                AP_ClientLogonId  : logon-id is captured
                                                    from the thread token.
                                                    No need to specify one.
                                                    
                                no flags          : need to supply a logon-id

                    APT_ObjectTypeList <ptr to obj type list> <obj-type-index>
                                Index to object type must be specified

                    APT_Time    <filetime>

                    APT_Int64   <ULONGLONG or LARGE_INTEGER>

Return Value:
    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,
    which will be one of the following:

    ERROR_INVALID_PARAMETER if one of the params is incorrect
    

Notes:

--*/
{
    PAUTHZI_RESOURCE_MANAGER pRM             = (PAUTHZI_RESOURCE_MANAGER) hResourceManager;
    PSID                     pUserSid        = NULL;
    DWORD                    dwError         = NO_ERROR;
    BOOL                     b               = TRUE;
    LUID                     AuthIdThread    = {0};

    va_list(arglist);

    if (!ARGUMENT_PRESENT(hResourceManager)       ||
        !ARGUMENT_PRESENT(pParams)                ||
        (NumParams + AUTHZP_NUM_FIXED_HEADER_PARAMS) > SE_MAX_AUDIT_PARAMETERS)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    va_start(arglist, pParams);


    //
    // If we are not impersonating we want to use the sid stored
    // in the RM as the user sid of the audit.
    //

    b = AuthzpGetThreadTokenInfo( 
            &pUserSid, 
            &AuthIdThread 
            );

    if (!b)
    {
        dwError = GetLastError();

        if (dwError == ERROR_NO_TOKEN)
        {
            //
            // We are not impersonating ...
            //

            pUserSid = pRM->pUserSID;
            dwError = NO_ERROR;
            b = TRUE;
        }
        else
        {
            goto Cleanup;
        }
    }


    //
    // This is only a temporary solution and should be replaced after .net ships.
    //

    if (wcsncmp(pRM->szResourceManagerName, L"DS", 2) == 0)
    {
        Flags |= AUTHZP_INIT_PARAMS_SOURCE_DS;
    }

    b = AuthzpInitializeAuditParamsV(
            Flags,
            pParams,
            &pUserSid,
            NULL,
            0,
            NumParams,
            arglist
            );

Cleanup:

    if ( dwError != NO_ERROR )
    {
        SetLastError( dwError );
        b = FALSE;
    }

    if ( !b )
    {
        if (pUserSid != pRM->pUserSID)
        {
            AuthzpFreeNonNull( pUserSid );
        }
    }
    else
    {
        //
        // ugly hack to mark the dynamically allocated sid so we
        // know we'll have to free it in AuthziFreeAuditParam.
        //

        if (pUserSid != pRM->pUserSID)
        {
            pParams->Parameters->Flags |= AUTHZP_PARAM_FREE_SID;
        }
        else
        {
            pParams->Parameters->Flags &= ~AUTHZP_PARAM_FREE_SID;
        }
    }

    va_end (arglist);

    return b;
}


BOOL
AuthziInitializeAuditParamsFromArray(
    IN DWORD Flags,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hResourceManager,
    IN USHORT NumParams,
    IN PAUDIT_PARAM pParamArray,
    OUT PAUDIT_PARAMS pParams
    )
/*++

Routine Description:

    Initialize the AUDIT_PARAMS structure based on the passed
    data. 

Arguments:

    pParams       - pointer to AUDIT_PARAMS structure to be initialized
                    the size of pParams->Parameters member must be big enough
                    to hold NumParams elements. The caller must allocate
                    memory for this structure and its members.

    hResourceManager - Handle to the Resource manager that is creating the audit.
    
    Flags       - control flags. one or more of the following:
                    APF_AuditSuccess

    pParamArray - an array of type AUDIT_PARAM

Return Value:
    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,
    which will be one of the following:

    ERROR_INVALID_PARAMETER if one of the params is incorrect
    

Notes:

--*/
{
    PAUTHZI_RESOURCE_MANAGER pRM             = (PAUTHZI_RESOURCE_MANAGER) hResourceManager;
    DWORD                    dwError         = NO_ERROR;
    BOOL                     b               = TRUE;
    BOOL                     bImpersonating  = TRUE;
    PAUDIT_PARAM             pParam          = NULL;
    LUID                     AuthIdThread;
    PSID                     pThreadSID      = NULL;
    DWORD                    i;

    //
    // the first two params are always fixed. thus the total number
    // is 2 + the passed number.
    //

    if (!ARGUMENT_PRESENT(hResourceManager)       ||
        !ARGUMENT_PRESENT(pParams)                ||
        !ARGUMENT_PRESENT(pParamArray)            ||
        (NumParams + AUTHZP_NUM_FIXED_HEADER_PARAMS) > SE_MAX_AUDIT_PARAMETERS)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    b = AuthzpGetThreadTokenInfo( 
            &pThreadSID, 
            &AuthIdThread 
            );

    if (!b)
    {
        dwError = GetLastError();

        if (dwError == ERROR_NO_TOKEN)
        {
            bImpersonating = FALSE;
            dwError = NO_ERROR;
            b = TRUE;
        }
        else
        {
            goto Cleanup;
        }
    }

    pParams->Length = 0;
    pParams->Flags  = Flags;
    pParams->Count  = NumParams+AUTHZP_NUM_FIXED_HEADER_PARAMS;

    pParam          = pParams->Parameters;

    //
    // the first param is always the sid of the user in thread token
    // if thread is not impersonating, sid in the primary token is used.
    //

    pParam->Type = APT_Sid;
    if (bImpersonating)
    {
        pParam->Data0 = (ULONG_PTR) pThreadSID;

        //
        // ugly hack to mark the dynamically allocated sid so we
        // know we'll have to free it in AuthziFreeAuditParam.
        //

        pParam->Flags |= AUTHZP_PARAM_FREE_SID;

    }
    else
    {
        pParam->Data0 = (ULONG_PTR) pRM->pUserSID;
        pParam->Flags &= ~AUTHZP_PARAM_FREE_SID;
    }

    pParam++;

    //
    // the second param is always the sub-system name
    //

    pParam->Type    = APT_String;
    pParam->Data0   = (ULONG_PTR) pRM->szResourceManagerName;

    pParam++;
    
    //
    // now initialize the rest using the array.
    //

    RtlCopyMemory(
        pParam,
        pParamArray,
        sizeof(AUDIT_PARAM) * NumParams
        );

    //
    // Walk through the parameters and increment by 2 the Data1 member of
    // any instance of AccessMask or ObjectTypeList.  This is done to correct
    // for the usersid / subsystem elements that are inserted in the param 
    // array.  The data1 member of these 2 types should point to the ObjectTypeIndex,
    // which is otherwise off by 2.
    // 

    for (i = 0; i < pParams->Count; i++)
    {
        ULONG TypeFlags = pParams->Parameters[i].Type;
        if ((ApExtractType(TypeFlags) == APT_ObjectTypeList) ||
            (ApExtractType(TypeFlags) == APT_Ulong && FLAG_ON(ApExtractFlags(TypeFlags), AP_AccessMask)))
        {
            pParams->Parameters[i].Data1 += 2;
        }
    }

Cleanup:    
    if ( dwError != NO_ERROR )
    {
        SetLastError( dwError );
        b = FALSE;
        AuthzpFreeNonNull( pThreadSID );
    }

    return b;
}


BOOL
AuthziInitializeAuditParams(
    IN  DWORD         dwFlags,
    OUT PAUDIT_PARAMS pParams,
    OUT PSID*         ppUserSid,
    IN  PCWSTR        SubsystemName,
    IN  USHORT        NumParams,
    ...
    )
/*++

Routine Description:

    Initialize the AUDIT_PARAMS structure based on the passed
    data.

    The caller passes in type ~ value pairs in the vararg section.
    This function will initialize the corresponding array elements
    based on each such pair. In case of certain types, there may
    be more than one value argument required. This requirement
    is documented next to each param-type.

Arguments:

    pParams       - pointer to AUDIT_PARAMS structure to be initialized
                    the size of pParams->Parameters member must be big enough
                    to hold NumParams elements. The caller must allocate
                    memory for this structure and its members.

    ppUserSid     - pointer to user sid allocated. This sid is referenced
                    by the first parameter (index 0) in AUDIT_PARAMS structure.
                    The caller should free this by calling LocalFree
                    *after* freeing the AUDIT_PARAMS structure.

    SubsystemName - name of Subsystem that is generating audit

    dwFlags       - control flags. one or more of the following:
                    APF_AuditSuccess

    NumParams     - number of parameters passed in the var-arg section.
                    This must be SE_MAX_AUDIT_PARAMETERS or less.

    ...           - The format of the variable arg portion is as follows:
                    
                    <one of APT_ * flags> <zero or more values>

                    APT_String  <pointer to null terminated string>

                                Flags:
                                AP_Filespec  : treats the string as a filename
                    
                    APT_Ulong   <ulong value> [<object-type-index>]
                    
                                Flags:
                                AP_FormatHex : number appears in hex
                                               in eventlog
                                AP_AccessMask: number is treated as
                                               an access-mask
                                               Index to object type must follow

                    APT_Pointer <pointer/handle>
                                32 bit on 32 bit systems and
                                64 bit on 64 bit systems

                    APT_Sid     <pointer to sid>

                    APT_Luid    <Luid>
                    
                    APT_Guid    <pointer to guid>
                    
                    APT_LogonId [<logon-id>]
                    
                                Flags:
                                AP_PrimaryLogonId : logon-id is captured
                                                    from the process token.
                                                    No need to specify one.

                                AP_ClientLogonId  : logon-id is captured
                                                    from the thread token.
                                                    No need to specify one.
                                                    
                                no flags          : need to supply a logon-id

                    APT_ObjectTypeList <ptr to obj type list> <obj-type-index>
                                Index to object type must be specified

                    APT_Time    <filetime>

                    APT_Int64   <ULONGLONG or LARGE_INTEGER>

Return Value:
    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,
    which will be one of the following:

    ERROR_INVALID_PARAMETER if one of the params is incorrect
    

Notes:

--*/

{
    BOOL fResult = TRUE;

    va_list(arglist);
    
    *ppUserSid = NULL;
    
    va_start (arglist, NumParams);
    
    //
    // Turn off any flags that don't belong.  Only success/failure flag is permitted.
    //

    dwFlags = dwFlags & APF_ValidFlags;

    UNREFERENCED_PARAMETER(SubsystemName);

    fResult = AuthzpInitializeAuditParamsV(
                  dwFlags,
                  pParams,
                  ppUserSid,
                  NULL, // subsystemname will be forced to "Security"
                  0,
                  NumParams,
                  arglist
                  );

    if (!fResult)
    {
        goto Cleanup;
    }

Cleanup:    

    if (!fResult)
    {    
        if (AUTHZ_NON_NULL_PTR(*ppUserSid)) 
        {
            AuthzpFree(*ppUserSid);
            *ppUserSid = NULL;
        }
    }

    va_end (arglist);
    return fResult;
}


BOOL
AuthziFreeAuditParams(
    PAUDIT_PARAMS pParams
    )

/*++

Routine Description

    Frees the AUDIT_PARAMS created by AuthzAllocateInitializeAuditParamsWithRM.

Arguments

    pParams - pointer to AUDIT_PARAMS.

Return Value

    Boolean: TRUE on success, FALSE on failure.

--*/

{
    if (!ARGUMENT_PRESENT(pParams))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pParams->Parameters)
    {
        if (pParams->Parameters->Data0 &&
            pParams->Parameters->Type == APT_Sid &&
            (pParams->Parameters->Flags & AUTHZP_PARAM_FREE_SID))
        {
            AuthzpFree((PVOID)(pParams->Parameters->Data0));
        }
    }

    AuthzpFree(pParams);

    return TRUE;
}



BOOL
AuthziInitializeAuditEvent(
    IN  DWORD                         Flags,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hRM,
    IN  AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET OPTIONAL,
    IN  PAUDIT_PARAMS                 pAuditParams OPTIONAL,
    IN  AUTHZ_AUDIT_QUEUE_HANDLE      hAuditQueue OPTIONAL,
    IN  DWORD                         dwTimeOut,
    IN  PWSTR                         szOperationType,
    IN  PWSTR                         szObjectType,
    IN  PWSTR                         szObjectName,
    IN  PWSTR                         szAdditionalInfo OPTIONAL,
    OUT PAUTHZ_AUDIT_EVENT_HANDLE     phAuditEvent
    )

/*++

Routine Description:

    Allocates and initializes an AUTHZ_AUDIT_EVENT_HANDLE.  The handle is used for storing information 
    for audit generation per AuthzAccessCheck().  
    
Arguments:

    phAuditEvent - pointer to AUTHZ_AUDIT_EVENT_HANDLE.  Space for this is allocated in the function.

    Flags - Audit flags.  Currently defined bits are:
        AUTHZ_NO_SUCCESS_AUDIT - disables generation of success audits
        AUTHZ_NO_FAILURE_AUDIT - disables generation of failure audits
        AUTHZ_DS_CATEGORY_FLAG - swithces the default audit category from OBJECT_ACCESS to DS_ACCESS.
        AUTHZ_NO_ALLOC_STRINGS - storage space is not allocated for the 4 wide character strings.  Rather,
            the handle will only hold pointers to resource manager memory.
            
    hRM - handle to a Resource Manager.            
    
    hAET - pointer to an AUTHZ_AUDIT_EVENT_TYPE structure.  This is needed if the resource manager
        is creating its own audit types.  This is not needed for generic object operation audits.  
        
    pAuditParams - If this is specified, then pAuditParams will be used to 
        create the audit.  If NULL is passed, then a generic AUDIT_PARAMS will
        be constructed that is suitable for the generic object access audit.  

    hAuditQueue - queue object created with AuthzInitializeAuditQueue.  If none is specified, the 
        default RM queue will be used.
        
    dwTimeOut - milliseconds that a thread attempting to generate an audit with this 
        AUTHZ_AUDIT_EVENT_HANDLE should wait for access to the queue.  Use INFINITE to 
        specify an unlimited timeout.
                     
    szOperationType - Resource manager defined string that indicates the operation being
        performed that is to be audited.

    szObjectType - Resource manager defined string that indicates the type of object being
        accessed.

    szObjectName - the name of the specific object being accessed.
    
    szAdditionalInfo - Resource Manager defined string for additional audit information.

Return Value:

    Returns TRUE if successful, FALSE if unsuccessful.  
    Extended information available with GetLastError().    
    
--*/

{
    PAUTHZI_AUDIT_EVENT      pAuditEvent            = NULL;
    BOOL                     b                      = TRUE;
    BOOL                     bRef                   = FALSE;
    DWORD                    dwStringSize           = 0;
    DWORD                    dwObjectTypeLength     = 0;
    DWORD                    dwObjectNameLength     = 0;
    DWORD                    dwOperationTypeLength  = 0;
    DWORD                    dwAdditionalInfoLength = 0;
    PAUTHZI_RESOURCE_MANAGER pRM                    = (PAUTHZI_RESOURCE_MANAGER) hRM;

    if (!ARGUMENT_PRESENT(phAuditEvent)                                ||
        (!ARGUMENT_PRESENT(hAET) && !ARGUMENT_PRESENT(hRM))            ||
        !ARGUMENT_PRESENT(szOperationType)                             ||
        !ARGUMENT_PRESENT(szObjectType)                                ||
        !ARGUMENT_PRESENT(szObjectName)                                ||
        !ARGUMENT_PRESENT(szAdditionalInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuditEvent = NULL;
    
    //
    // Allocate and initialize a new AUTHZI_AUDIT_EVENT.
    //

    if (FLAG_ON(Flags, AUTHZ_NO_ALLOC_STRINGS))
    {
        dwStringSize = 0;
    } 
    else
    {
        dwOperationTypeLength  = (DWORD) wcslen(szOperationType) + 1;
        dwObjectTypeLength     = (DWORD) wcslen(szObjectType) + 1;
        dwObjectNameLength     = (DWORD) wcslen(szObjectName) + 1;
        dwAdditionalInfoLength = (DWORD) wcslen(szAdditionalInfo) + 1;

        dwStringSize = sizeof(WCHAR) * (dwOperationTypeLength + dwObjectTypeLength + dwObjectNameLength + dwAdditionalInfoLength);
    }

    pAuditEvent = (PAUTHZI_AUDIT_EVENT) AuthzpAlloc(sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize);

    if (AUTHZ_ALLOCATION_FAILED(pAuditEvent))
    {
        b = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    RtlZeroMemory(
        pAuditEvent, 
        sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize
        );
    

    if (FLAG_ON(Flags, AUTHZ_NO_ALLOC_STRINGS))
    {
        pAuditEvent->szOperationType  = szOperationType;
        pAuditEvent->szObjectType     = szObjectType;
        pAuditEvent->szObjectName     = szObjectName;
        pAuditEvent->szAdditionalInfo = szAdditionalInfo;
    }
    else
    {
        //
        // Set the string pointers into the contiguous memory.
        //

        pAuditEvent->szOperationType  = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT));
    
        pAuditEvent->szObjectType     = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT) 
                                               + (sizeof(WCHAR) * dwOperationTypeLength));

        pAuditEvent->szObjectName     = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT) 
                                               + (sizeof(WCHAR) * (dwOperationTypeLength + dwObjectTypeLength)));

        pAuditEvent->szAdditionalInfo = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT) 
                                               + (sizeof(WCHAR) * (dwOperationTypeLength + dwObjectTypeLength + dwObjectNameLength)));

        RtlCopyMemory(
            pAuditEvent->szOperationType,
            szOperationType,
            sizeof(WCHAR) * dwOperationTypeLength
            );

        RtlCopyMemory(
            pAuditEvent->szObjectType,
            szObjectType,
            sizeof(WCHAR) * dwObjectTypeLength
            );

        RtlCopyMemory(
            pAuditEvent->szObjectName,
            szObjectName,
            sizeof(WCHAR) * dwObjectNameLength
            );

        RtlCopyMemory(
            pAuditEvent->szAdditionalInfo,
            szAdditionalInfo,
            sizeof(WCHAR) * dwAdditionalInfoLength
            );
    }

    //
    // Use the passed audit event type if present, otherwise use the RM's generic Audit Event.
    //

    if (ARGUMENT_PRESENT(hAET))
    {
        pAuditEvent->hAET = hAET;
    }
    else
    {
        if (FLAG_ON(Flags, AUTHZ_DS_CATEGORY_FLAG))
        {
            pAuditEvent->hAET = pRM->hAETDS;
        }
        else
        {
            pAuditEvent->hAET = pRM->hAET;
        }
    }

    AuthzpReferenceAuditEventType(pAuditEvent->hAET);
    bRef = TRUE;

    //
    // Use the specified queue, if it exists.  Else use the RM queue.
    //

    if (ARGUMENT_PRESENT(hAuditQueue))
    {
        pAuditEvent->hAuditQueue = hAuditQueue;
    }
    else if (ARGUMENT_PRESENT(hRM))
    {
        pAuditEvent->hAuditQueue = pRM->hAuditQueue;
    } 

    pAuditEvent->pAuditParams = pAuditParams;
    pAuditEvent->Flags        = Flags;
    pAuditEvent->dwTimeOut    = dwTimeOut;
    pAuditEvent->dwSize       = sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize;

Cleanup:

    if (!b)
    {
        if (bRef)
        {
            AuthzpDereferenceAuditEventType(pAuditEvent->hAET);
        }
        AuthzpFreeNonNull(pAuditEvent);
    }
    else
    {
        *phAuditEvent = (AUTHZ_AUDIT_EVENT_HANDLE) pAuditEvent;
    }
    return b;
}


BOOL
AuthziModifyAuditEvent(
    IN DWORD                    Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent,
    IN DWORD                    NewFlags,
    IN PWSTR                    szOperationType,
    IN PWSTR                    szObjectType,
    IN PWSTR                    szObjectName,
    IN PWSTR                    szAdditionalInfo
    )

{
    return AuthziModifyAuditEvent2(
               Flags,
               hAuditEvent,
               NewFlags,
               szOperationType,
               szObjectType,
               szObjectName,
               szAdditionalInfo,
               NULL
               );
}


BOOL
AuthziModifyAuditEvent2(
    IN DWORD                    Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent,
    IN DWORD                    NewFlags,
    IN PWSTR                    szOperationType,
    IN PWSTR                    szObjectType,
    IN PWSTR                    szObjectName,
    IN PWSTR                    szAdditionalInfo,
    IN PWSTR                    szAdditionalInfo2
    )

/*++

Routine Description

Arguments

    Flags - flags to specify which field of the hAuditEvent to modify.  Valid flags are:
        
        AUTHZ_AUDIT_EVENT_FLAGS           
        AUTHZ_AUDIT_EVENT_OPERATION_TYPE  
        AUTHZ_AUDIT_EVENT_OBJECT_TYPE     
        AUTHZ_AUDIT_EVENT_OBJECT_NAME     
        AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO 
        AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO2
        
    hAuditEvent - handle to modify.  Must be created with AUTHZ_NO_ALLOC_STRINGS flag.

    NewFlags - replacement flags for hAuditEvent.
    
    szOperationType - replacement string for hAuditEvent.
    
    szObjectType - replacement string for hAuditEvent.
    
    szObjectName - replacement string for hAuditEvent.
    
    szAdditionalInfo - replacement string for hAuditEvent.
    
Return Value
    
    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
    
--*/

{
    PAUTHZI_AUDIT_EVENT pAuditEvent = (PAUTHZI_AUDIT_EVENT) hAuditEvent;

    if ((!ARGUMENT_PRESENT(hAuditEvent))                       ||
        (Flags & ~AUTHZ_VALID_MODIFY_AUDIT_EVENT_FLAGS)        ||
        (!FLAG_ON(pAuditEvent->Flags, AUTHZ_NO_ALLOC_STRINGS)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_FLAGS))
    {
       pAuditEvent->Flags = NewFlags;
    }

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_OPERATION_TYPE))
    {
       pAuditEvent->szOperationType = szOperationType;
    }

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_OBJECT_TYPE))
    {
       pAuditEvent->szObjectType = szObjectType;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_OBJECT_NAME))
    {
        pAuditEvent->szObjectName = szObjectName;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO))
    {
        pAuditEvent->szAdditionalInfo = szAdditionalInfo;
    }

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO2))
    {
        pAuditEvent->szAdditionalInfo2 = szAdditionalInfo2;
    }

    return TRUE;
}

BOOLEAN
AuthzInitialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )

/*++

Routine Description

    This is the dll initialization rotuine.

Arguments
    Standard arguments.

Return Value
    
    Boolean: TRUE on success; FALSE on failure.
    
--*/

{

    UNREFERENCED_PARAMETER(hmod);
    UNREFERENCED_PARAMETER(Context);

    switch (Reason) 
    {
        case DLL_PROCESS_ATTACH:

            SafeAllocaInitialize(
                    SAFEALLOCA_USE_DEFAULT,
                    SAFEALLOCA_USE_DEFAULT,
                    NULL,
                    NULL);
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}

#define PER_USER_POLICY_KEY_NAME L"SYSTEM\\CurrentControlSet\\Control\\Lsa\\Audit\\PerUserAuditing"
#define PER_USER_POLICY_SYSTEM_KEY_NAME L"SYSTEM\\CurrentControlSet\\Control\\Lsa\\Audit\\PerUserAuditing\\System"
#define SYSTEM_RM_NAME L"System"
#define POLICY_BUFFER_BYTE_SIZE 8


BOOL
AuthziSetAuditPolicy(
    IN DWORD                       dwFlags,
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hContext,
    IN PCWSTR                      szResourceManager OPTIONAL,
    IN PTOKEN_AUDIT_POLICY         pPolicy
    )

/*++

Routine Description:

    This routine sets a per user policy for a user.
    
Arguments:

    dwFlags - currently unused.
    
    hContext - handle to a client context for which to set the policy.
    
    szResourceManager - should be NULL.  For future use.
    
    pPolicy - the policy that is to be set for the user.
    
Return Value:

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
    
--*/

{
    PAUTHZI_CLIENT_CONTEXT pContext = (PAUTHZI_CLIENT_CONTEXT) hContext;
    DWORD                  dwError  = ERROR_SUCCESS;
    HKEY                   hRMRoot  = NULL;
    LPWSTR                 szSid    = NULL;
    BOOL                   b;
    DWORD                  Disposition;
    UCHAR                  RegPolicy[POLICY_BUFFER_BYTE_SIZE];

    UNREFERENCED_PARAMETER(dwFlags);

    RtlZeroMemory(RegPolicy, sizeof(RegPolicy));

    if (NULL == hContext || NULL == pPolicy)
    {
        b = FALSE;
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Only allow System RM to be specified.  If no RM is given then default to system.
    //

    if (NULL == szResourceManager || 0 == wcsncmp(
                                              SYSTEM_RM_NAME, 
                                              szResourceManager, 
                                              sizeof(SYSTEM_RM_NAME) / sizeof(WCHAR)
                                              ))
    {
        dwError = RegCreateKeyEx(
                      HKEY_LOCAL_MACHINE,
                      PER_USER_POLICY_SYSTEM_KEY_NAME,
                      0,
                      NULL,
                      0,
                      KEY_SET_VALUE,
                      NULL,
                      &hRMRoot,
                      &Disposition
                      );
        
        if (ERROR_SUCCESS != dwError)
        {
            b = FALSE;
            goto Cleanup;
        }
    }
    else
    {
        b = FALSE;
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    b = ConvertSidToStringSid(
            pContext->Sids[0].Sid, 
            &szSid
            );

    if (!b)
    {
        dwError = GetLastError();
        goto Cleanup;
    }
    
    b = AuthzpConstructRegistryPolicyPerUserAuditing(
            pPolicy,
            (PULONGLONG)RegPolicy
            );

    if (!b)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    dwError = RegSetValueEx(
                  hRMRoot,
                  szSid,
                  0,
                  REG_BINARY,
                  RegPolicy,
                  sizeof(RegPolicy)
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

Cleanup:

    if (!b)
    {
        SetLastError(dwError);
    }

    if (hRMRoot)
    {
        dwError = RegCloseKey(hRMRoot);
        ASSERT(ERROR_SUCCESS == dwError);
    }

    if (szSid)
    {
        AuthzpFree(szSid);
    }

    return b;
}
    

BOOL
AuthziQueryAuditPolicy(
    IN     DWORD                       dwFlags,
    IN     AUTHZ_CLIENT_CONTEXT_HANDLE hContext,
    IN     PCWSTR                      szResourceManager OPTIONAL,
    IN     DWORD                       dwEventID,
    OUT    PTOKEN_AUDIT_POLICY         pPolicy,
    IN OUT PDWORD                      pPolicySize
    )

/*++

  Routine Description:
 
   This function retrieves the audit policy for a specific context handle.
 
  Arguments:
 
   dwFlags - TBD.
   
   hContext - context handle for the target user.
   
   szResourceManager - Must be NULL.  For future use.
   
   dwEventID - Should be zero.  For future use.
   
   pPolicy - pointer to a structure storing the policy.
   
   pPolicySize - pointer to DWORD containing size of pPolicy buffer.
   
  Return Value:
 
   Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().

--*/

{
    PAUTHZI_CLIENT_CONTEXT pContext = (PAUTHZI_CLIENT_CONTEXT) hContext;
    DWORD                  dwError  = ERROR_SUCCESS;
    HKEY                   hRMRoot  = NULL;
    DWORD                  Type;
    BOOL                   b;
    NTSTATUS               Status;
    UCHAR                  ValueBuffer[POLICY_BUFFER_BYTE_SIZE];
    DWORD                  BufferSize = sizeof(ValueBuffer);
    UNICODE_STRING         szSid = {0};
    WCHAR                  StringBuffer[256];

    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(dwEventID);

    RtlZeroMemory(ValueBuffer, sizeof(ValueBuffer));

    if (NULL == pContext || NULL == pPolicySize || NULL == pPolicy)
    {
        dwError = ERROR_INVALID_PARAMETER;
        b = FALSE;
        goto Cleanup;
    }

    if (NULL == szResourceManager || 0 == wcsncmp(
                                              SYSTEM_RM_NAME, 
                                              szResourceManager, 
                                              sizeof(SYSTEM_RM_NAME) / sizeof(WCHAR)
                                              ))
    {
        //
        // Default to the system RM.
        //

        dwError = RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     PER_USER_POLICY_SYSTEM_KEY_NAME,
                     0,
                     KEY_QUERY_VALUE,
                     &hRMRoot
                     );

        if (dwError != ERROR_SUCCESS)
        {
            b = FALSE;
            goto Cleanup;
        }
    }
    else
    {
        //
        // For now no RM can be specified.  
        //

        dwError = ERROR_INVALID_PARAMETER;
        b = FALSE;
        goto Cleanup;
    }

    RtlZeroMemory(
        StringBuffer, 
        sizeof(StringBuffer)
        );

    szSid.Buffer = (PWSTR)StringBuffer;
    szSid.Length = 0;
    szSid.MaximumLength = sizeof(StringBuffer);

    Status = RtlConvertSidToUnicodeString(
                &szSid,
                pContext->Sids[0].Sid,
                FALSE
                );

    if (ERROR_BUFFER_OVERFLOW == Status)
    {
        Status = RtlConvertSidToUnicodeString(
                    &szSid,
                    pContext->Sids[0].Sid,
                    TRUE
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        dwError = RtlNtStatusToDosError(Status);
        b = FALSE;
        goto Cleanup;
    }

    //
    // Get the policy value for the SID under the given RM.
    //

    dwError = RegQueryValueEx(
                  hRMRoot,
                  szSid.Buffer,
                  NULL,
                  &Type,
                  ValueBuffer,
                  &BufferSize
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

    //
    // Sanity check the buffer type.
    //

    if (REG_BINARY != Type)
    {
        b = FALSE;
        dwError = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    b = AuthzpConstructPolicyPerUserAuditing(
            *((PULONGLONG) ValueBuffer),
            (PTOKEN_AUDIT_POLICY) pPolicy,
            pPolicySize
            );

    if (!b)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

Cleanup:

    if (!b)
    {
        SetLastError(dwError);
    }

    if (szSid.Buffer != StringBuffer)
    {
        RtlFreeUnicodeString(&szSid);
    }

    if (hRMRoot)
    {
        RegCloseKey(hRMRoot);
    }

    return b;
}


BOOL
AuthziSourceAudit(
    IN DWORD dwFlags,
    IN USHORT CategoryId,
    IN USHORT AuditId,
    IN PWSTR szSource,
    IN PSID pUserSid OPTIONAL,
    IN USHORT Count,
    ...
    )

/**

Routine Description:

    This is used to generate an audit with any source.  An audit of type
    SE_AUDITID_GENERIC_AUDIT_EVENT is sent to the LSA, and the event viewer
    interprets this audit in a special manner.  The first 2 parameters will be
    treated as the actual source and id to be displayed in the security log.  The
    source listed must be a valid source listed under the EventLog\Security key.
    
Arguments:

    dwFlags         - APF_AuditSuccess
    CategoryId      - The category of the audit.
    AuditId         - The audit id to be generated.
    szSource        - the Source that should be listed in the security log.
    pUserSid        - optional pointer to Sid for audit to be created as.
    Count           - number of parameters in the VA section.  
    ...             - VA list of parameters, the semantics of which are described 
                      in the comment for AuthziInitializeAuditParams.
    
Return Value:

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
          
**/

{
    BOOL                          b;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET      = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE      hAE       = NULL;
    PAUDIT_PARAMS                 pParams   = NULL;
    PSID                          pDummySid = NULL;
    va_list                       arglist;

    va_start(
        arglist, 
        Count
        );

    //
    // add in 2 because we store the actual audit id and the source
    // string in the audit params.
    //

    b = AuthziAllocateAuditParams(
            &pParams,
            Count + 2
            );

    if (!b)
    {
        goto Cleanup;
    }

    b = AuthziInitializeAuditEventType(
            0,
            CategoryId,
            SE_AUDITID_GENERIC_AUDIT_EVENT,
            Count + 2,
            &hAET
            );

    if (!b)
    {
        goto Cleanup;
    }

    b = AuthzpInitializeAuditParamsV(
            dwFlags | AUTHZP_INIT_PARAMS_SOURCE_INFO,
            pParams,
            &pDummySid,
            szSource,
            AuditId,
            Count,
            arglist
            );

    if (!b)
    {
        goto Cleanup;
    }

    if (pUserSid)
    {
        //
        // this is ugly, but currently there is no other way
        //

        pParams->Parameters[0].Data0 = (ULONG_PTR) pUserSid;
    }

    b = AuthziInitializeAuditEvent(
            0,
            NULL,
            hAET,
            pParams,
            NULL,
            INFINITE,
            L"",
            L"",
            L"",
            L"",
            &hAE
            );

    if (!b)
    {
        goto Cleanup;
    }

    b = AuthziLogAuditEvent(
            0,
            hAE,
            NULL
            );

    if (!b)
    {
        goto Cleanup;
    }

Cleanup:

    va_end(arglist);

    if (hAET)
    {
        AuthziFreeAuditEventType(
            hAET
            );
    }

    if (hAE)
    {
        AuthzFreeAuditEvent(
            hAE
            );
    }

    if (pParams)
    {
        AuthziFreeAuditParams(
            pParams
            );
    }

    if (pDummySid)
    {
        AuthzpFree(
            pDummySid
            );
    }

    return b;
}


BOOL 
AuthzInstallSecurityEventSource(
    IN DWORD dwFlags,
    IN PAUTHZ_SOURCE_SCHEMA_REGISTRATION pRegistration
    )

/**

Routine Description:

    This installs a 3rd party as a security event source.
    
    - add the name to the security sources key
    
Arguments:

Return Value:

**/

{
    HKEY hkSecurity = NULL;
    DWORD dwError;
    BOOL b = TRUE;
    PWCHAR pBuffer = NULL;
    DWORD dwDisp;
    HKEY hkSource = NULL;
    HKEY hkObjectNames = NULL;
    DWORD i;
    
#if 0
    DWORD dwType;
    DWORD dwLength = 0;
    DWORD dwBuffer;
#endif

    UNREFERENCED_PARAMETER(dwFlags);

    if (NULL == pRegistration)
    {
        b = FALSE;
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

#define SECURITY_KEY_NAME L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Security"
    
    //
    // Open the Security key.
    //

    dwError = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SECURITY_KEY_NAME,
                  0,
                  KEY_READ | KEY_WRITE,
                  &hkSecurity
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

    //
    // First make sure that there is not already an installed EventSource with the specified name.
    // If createkey returns the wrong disposition then we know this source is already installed.
    //

    dwError = RegCreateKeyEx(
                  hkSecurity,
                  pRegistration->szEventSourceName,
                  0,
                  NULL,
                  0,
                  KEY_WRITE,
                  NULL,
                  &hkSource,
                  &dwDisp
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

    if (REG_OPENED_EXISTING_KEY == dwDisp)
    {
        b = FALSE;
        dwError = ERROR_OBJECT_ALREADY_EXISTS;
        goto Cleanup;
    }

    ASSERT(dwDisp == REG_CREATED_NEW_KEY);

    dwError = RegSetValueEx(
                  hkSource,
                  L"EventSourceFlags",
                  0,
                  REG_DWORD,
                  (LPBYTE)&pRegistration->dwFlags,
                  sizeof(DWORD)
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

    //
    // We created the new key for the Source.  We are the only instance of
    // this EventSource being installed.  Continue and add the message file
    // and access bit file information under the newly formed Source key.
    //

    if (pRegistration->szEventMessageFile)
    {
        dwError = RegSetValueEx(
                      hkSource,
                      L"EventMessageFile",
                      0,
                      REG_SZ,
                      (LPBYTE)pRegistration->szEventMessageFile,
                      (DWORD)(sizeof(WCHAR) * (wcslen(pRegistration->szEventMessageFile) + 1))
                      );

        if (ERROR_SUCCESS != dwError)
        {
            b = FALSE;
            goto Cleanup;
        }
    }

    if (pRegistration->szEventAccessStringsFile)
    {
        dwError = RegSetValueEx(
                      hkSource,
                      L"ParameterMessageFile",
                      0,
                      REG_SZ,
                      (LPBYTE)pRegistration->szEventAccessStringsFile,
                      (DWORD)(sizeof(WCHAR) * (wcslen(pRegistration->szEventAccessStringsFile) + 1))
                      );

        if (ERROR_SUCCESS != dwError)
        {
            b = FALSE;
            goto Cleanup;
        }
    }

    if (pRegistration->szExecutableImagePath)
    {
        dwError = RegSetValueEx(
                      hkSource,
                      L"ExecutableImagePath",
                      0,
                      REG_MULTI_SZ,
                      (LPBYTE)pRegistration->szExecutableImagePath,
                      (DWORD)(sizeof(WCHAR) * (wcslen(pRegistration->szExecutableImagePath) + 1))
                      );

        if (ERROR_SUCCESS != dwError)
        {
            b = FALSE;
            goto Cleanup;
        }
    }
    
    if (pRegistration->szEventSourceXmlSchemaFile)
    {
        dwError = RegSetValueEx(
                      hkSource,
                      L"XmlSchemaFile",
                      0,
                      REG_SZ,
                      (LPBYTE)pRegistration->szEventSourceXmlSchemaFile,
                      (DWORD)(sizeof(WCHAR) * (wcslen(pRegistration->szEventSourceXmlSchemaFile) + 1))
                      );

        if (ERROR_SUCCESS != dwError)
        {
            b = FALSE;
            goto Cleanup;
        }
    }

//     if (pRegistration->szCategoryMessageFile)
//     {
//         dwError = RegSetValueEx(
//                       hkSource,
//                       L"CategoryMessageFile",
//                       0,
//                       REG_SZ,
//                       (LPBYTE)pRegistration->szCategoryMessageFile,
//                       (DWORD)(sizeof(WCHAR) * (wcslen(pRegistration->szEventMessageFile) + 1))
//                       );
//
//         if (ERROR_SUCCESS != dwError)
//         {
//             b = FALSE;
//             goto Cleanup;
//         }
//     }

    if (pRegistration->dwObjectTypeNameCount)
    {
        //
        // There are object names to be registered.  Create an ObjectNames subkey under
        // hkSource and populate it.
        //

        dwError = RegCreateKeyEx(
                      hkSource,
                      L"ObjectNames",
                      0,
                      NULL,
                      0,
                      KEY_WRITE,
                      NULL,
                      &hkObjectNames,
                      &dwDisp
                      );

        if (ERROR_SUCCESS != dwError)
        {
            b = FALSE;
            goto Cleanup;
        }

        //
        // It would be strange for this to not be a brand new key, given that we just
        // created the parent of hkObjectNames a few lines above...
        //

        ASSERT(dwDisp == REG_CREATED_NEW_KEY);

        for (i = 0; i < pRegistration->dwObjectTypeNameCount; i++)
        {
            dwError = RegSetValueEx(
                          hkObjectNames,
                          pRegistration->ObjectTypeNames[i].szObjectTypeName,
                          0,
                          REG_DWORD,
                          (LPBYTE)&(pRegistration->ObjectTypeNames[i].dwOffset),
                          sizeof(DWORD)
                          );

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }
        }
    }

#if 0

    //
    // The subkey for the source is now complete.  All that remains is to add
    // the source name to the REG_MULTI_SZ Sources value.  First determine the
    // size of the value.
    //

    dwError = RegQueryValueEx(
                  hkSecurity,
                  L"Sources",
                  NULL,
                  &dwType,
                  NULL,
                  &dwLength
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

    ASSERT(dwType == REG_MULTI_SZ);

    //
    // Allocate space for the new value of Sources.  We need space for
    // the current value as well as the new event source to be added.  +2
    // because of the need for double terminators.
    //
    
    dwBuffer = dwLength + (wcslen(pRegistration->szEventSourceName) + 2) * sizeof(WCHAR);

    pBuffer = AuthzpAlloc(dwBuffer);

    if (NULL == pBuffer)
    {
        b = FALSE;
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(
        pBuffer,
        dwBuffer
        );

    //
    // Read in the Sources value.
    //

    dwError = RegQueryValueEx(
                  hkSecurity,
                  L"Sources",
                  NULL,
                  &dwType,
                  (LPBYTE)pBuffer,
                  &dwLength
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

    ASSERT(dwType == REG_MULTI_SZ);
    
    //
    // Now place the new event source into pBuffer at dwLength - 1
    // position (to remove one of the double NULL terminators.  We don't
    // explicitly terminate the pBuffer because it has already been zeroed
    // out.
    //

    dwLength -= sizeof(WCHAR);

    RtlCopyMemory(
        &((PUCHAR)pBuffer)[dwLength],
        pRegistration->szEventSourceName,
        wcslen(pRegistration->szEventSourceName) * sizeof(WCHAR)
        );

    dwLength += wcslen(pRegistration->szEventSourceName) * sizeof(WCHAR) + 2 * sizeof(WCHAR); // to add back in the double NULL
    
    dwError = RegSetValueEx(
                hkSecurity,
                L"Sources",
                0,
                REG_MULTI_SZ,
                (LPBYTE)pBuffer,
                dwLength
                );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

#endif

Cleanup:

    if (!b)
    {
        SetLastError(dwError);
    }

    if (pBuffer)
    {
        LocalFree(pBuffer);
    }

    if (hkSecurity)
    {
        RegCloseKey(hkSecurity);
    }

    if (hkSource)
    {
        RegCloseKey(hkSource);
    }

    if (hkObjectNames)
    {
        RegCloseKey(hkObjectNames);
    }

    return b;
}


BOOL
AuthzUninstallSecurityEventSource(
    IN DWORD dwFlags,
    IN PCWSTR szEventSourceName
    )

/**

Routine Description:

    This will remove the source from the security key and remove the source string
    from the list of valid sources.
    
Arguments:

Return Value:

**/

{
    HKEY hkSecurity = NULL;
    DWORD dwError;
    BOOL b = TRUE;
    PUCHAR pBuffer = NULL;
#if 0
    DWORD dwLength = 0;
    DWORD dwType;
    PUCHAR pCurrentString = NULL;
    PUCHAR pNextString = NULL;
    BOOL bFound = FALSE;
    DWORD dwSourceStringByteLength;
#endif    
    UNREFERENCED_PARAMETER(dwFlags);

    if (NULL == szEventSourceName)
    {
        b = FALSE;
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Open the Security key.
    //

    dwError = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SECURITY_KEY_NAME,
                  0,
                  KEY_READ | KEY_WRITE,
                  &hkSecurity
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

#if 0

    //
    // Remove the source name from the Sources value.
    //

    dwError = RegQueryValueEx(
                  hkSecurity,
                  L"Sources",
                  NULL,
                  &dwType,
                  NULL,
                  &dwLength
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

    ASSERT(dwType == REG_MULTI_SZ);

    //
    // Allocate space for the current value of Sources. 
    //
    
    pBuffer = AuthzpAlloc(dwLength);

    if (NULL == pBuffer)
    {
        b = FALSE;
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Read in the Sources value.
    //

    dwError = RegQueryValueEx(
                  hkSecurity,
                  L"Sources",
                  NULL,
                  &dwType,
                  (LPBYTE)pBuffer,
                  &dwLength
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

    ASSERT(dwType == REG_MULTI_SZ);
    
    //
    // Now find the substring in the pBuffer that matches the sourcename 
    // we wish to delete.
    //

    pCurrentString = pBuffer;
    dwSourceStringByteLength = (DWORD)(sizeof(WCHAR) * (wcslen(szEventSourceName) + 1));
    bFound = FALSE;
    while (pCurrentString < (pBuffer + dwLength))
    {
        if (dwSourceStringByteLength == RtlCompareMemory(
                                            szEventSourceName, 
                                            pCurrentString, 
                                            dwSourceStringByteLength
                                            ))
        {
            //
            // We have found the substring of Sources that matches the event source
            // name.
            //

            bFound = TRUE;
            break;

        }
        else
        {
            //
            // Move the pointer to the next string location.
            //

            pCurrentString += (sizeof(WCHAR) * (1 + wcslen((PWCHAR)pCurrentString)));
        }
    }

    if (bFound)
    {
        //
        // pCurrentString points at the source name in the pBuffer.
        // Remove this string from the value by copying over it.
        //

        pNextString = pCurrentString + dwSourceStringByteLength;

        ASSERT(pNextString <= (pBuffer + dwLength));

        RtlCopyMemory(
            pCurrentString,
            pNextString,
            pBuffer + dwLength - pNextString
            );
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
        b = FALSE;
        goto Cleanup;
    }

    dwError = RegSetValueEx(
                hkSecurity,
                L"Sources",
                0,
                REG_MULTI_SZ,
                (LPBYTE)pBuffer,
                dwLength - dwSourceStringByteLength
                );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

#endif

    // 
    // Delete the key for this source, and the ObjectNames subkey.
    //

    dwError = DeleteKeyRecursivelyW(
                  hkSecurity,
                  szEventSourceName
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

Cleanup:

    if (pBuffer)
    {
        AuthzpFree(pBuffer);
    }

    if (hkSecurity)
    {
        RegCloseKey(hkSecurity);
    }

    if (!b)
    {
        SetLastError(dwError);
    }

    return b;
}


BOOL
AuthzEnumerateSecurityEventSources(
    IN DWORD dwFlags,
    OUT PAUTHZ_SOURCE_SCHEMA_REGISTRATION pBuffer,
    OUT PDWORD pdwCount,
    IN OUT PDWORD pdwLength
    )

/**

Routine Description:

Arguments:

Return Value:

**/

{
    HKEY hkSecurity = NULL;
    HKEY hkSource = NULL;
    DWORD dwSourceCount = 0;
    DWORD dwLength = 0;
    PWSTR pName = NULL;
    WCHAR Buffer[128];
    DWORD dwTotalLengthNeeded = 0;
    BOOL b = TRUE;
    DWORD dwError = ERROR_SUCCESS;
    FILETIME Time;

    UNREFERENCED_PARAMETER(dwFlags);

    //
    // Open the Security key.
    //

    dwError = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SECURITY_KEY_NAME,
                  0,
                  KEY_READ,
                  &hkSecurity
                  );

    if (ERROR_SUCCESS != dwError)
    {
        b = FALSE;
        goto Cleanup;
    }

    do
    {
        pName = Buffer;
        dwLength = sizeof(Buffer) / sizeof(WCHAR);

        dwError = RegEnumKeyEx(
                      hkSecurity,
                      dwSourceCount,
                      pName,
                      &dwLength,
                      NULL,
                      NULL,
                      NULL,
                      &Time
                      );

        dwLength *= sizeof(WCHAR);

        if (dwError == ERROR_INSUFFICIENT_BUFFER)
        {
            pName = (PWSTR)AuthzpAlloc(dwLength);

            if (NULL == pName)
            {
                b = FALSE;
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            else
            {
                dwLength /= sizeof(WCHAR);

                dwError = RegEnumKeyEx(
                              hkSecurity,
                              dwSourceCount,
                              pName,
                              &dwLength,
                              NULL,
                              NULL,
                              NULL,
                              &Time
                              );

                dwLength *= sizeof(WCHAR);
            }
        }

        if (dwError == ERROR_NO_MORE_ITEMS)
        {
            //
            // Do nothing.  This will fall us through to the end of the
            // while loop and still hit the correct cleanup code.
            //
        }
        else if (dwError != ERROR_SUCCESS)
        {
            b = FALSE;
            goto Cleanup;
        }
        else if (dwError == ERROR_SUCCESS)
        {
            //
            // Space for the Structure
            //

            dwTotalLengthNeeded += sizeof(AUTHZ_SOURCE_SCHEMA_REGISTRATION);

            //
            // Space for the Source name + NULL terminator
            //

            dwTotalLengthNeeded += PtrAlignSize(dwLength + sizeof(WCHAR));

            //
            // Open the subkey identified by pName and determine the 
            // sizes of the values listed therein. 
            //

            dwError = RegOpenKeyEx(
                          hkSecurity,
                          pName,
                          0,
                          KEY_READ,
                          &hkSource
                          );

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }

            dwLength = 0;

            dwError = RegQueryValueEx(
                          hkSource,
                          L"EventMessageFile",
                          NULL,
                          NULL,
                          NULL,
                          &dwLength
                          );

            if (ERROR_FILE_NOT_FOUND == dwError)
            {
                dwError = ERROR_SUCCESS;
            }

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }
            else
            {
                //
                // Space for the value + NULL terminator
                //

                dwTotalLengthNeeded += PtrAlignSize(dwLength + sizeof(WCHAR));
            }

            dwLength = 0;

            dwError = RegQueryValueEx(
                          hkSource,
                          L"ParameterMessageFile",
                          NULL,
                          NULL,
                          NULL,
                          &dwLength
                          );

            if (ERROR_FILE_NOT_FOUND == dwError)
            {
                dwError = ERROR_SUCCESS;
            }

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }
            else
            {
                //
                // Space for the value + NULL terminator
                //

                dwTotalLengthNeeded += PtrAlignSize(dwLength + sizeof(WCHAR));
            }

            dwLength = 0;
            dwError = RegQueryValueEx(
                          hkSource,
                          L"XmlSchemaFile",
                          NULL,
                          NULL,
                          NULL,
                          &dwLength
                          );

            if (ERROR_FILE_NOT_FOUND == dwError)
            {
                dwError = ERROR_SUCCESS;
            }

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }
            else
            {
                //
                // Space for the value + NULL terminator
                //

                dwTotalLengthNeeded += PtrAlignSize(dwLength + sizeof(WCHAR));
            }
            
            RegCloseKey(hkSource);
            hkSource = NULL;
            dwSourceCount++;
        }

        if ((pName != NULL) && (pName != Buffer))
        {
            //
            // free the temporary storage used for the key name.
            //

            AuthzpFree(pName);
        }
    }
    while (dwError == ERROR_SUCCESS);

    if (dwTotalLengthNeeded > *pdwLength)
    {
        b = FALSE;
        dwError = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }
    else
    {
        //
        // The passed buffer is big enough.  Set it up.
        // Each structure contains string pointers, which point to memory in the 
        // blob after the structures.
        //

        PUCHAR pData;
        DWORD i;
        DWORD dwSpaceUsed = 0;

        RtlZeroMemory(
            pBuffer, 
            *pdwLength
            );

        //
        // The data for the Schema structures begins at pData.
        //
        
        pData = (PUCHAR)((PUCHAR)pBuffer + PtrAlignSize(dwSourceCount * sizeof(AUTHZ_SOURCE_SCHEMA_REGISTRATION)));

        dwSpaceUsed = PtrAlignSize(dwSourceCount * (sizeof(AUTHZ_SOURCE_SCHEMA_REGISTRATION)));

        for (i = 0; i < dwSourceCount; i++)
        {
            pBuffer[i].szEventSourceName = (PWSTR)pData;
            dwLength = (*pdwLength - dwSpaceUsed) / sizeof(WCHAR);

            dwError = RegEnumKeyEx(
                          hkSecurity,
                          i,
                          pBuffer[i].szEventSourceName,
                          &dwLength,
                          NULL,
                          NULL,
                          NULL,
                          &Time
                          );

            dwLength *= sizeof(WCHAR);

            if (ERROR_NO_MORE_ITEMS == dwError)
            {
                b = TRUE;
                goto Cleanup;
            }

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }

            dwSpaceUsed += PtrAlignSize(dwLength + sizeof(WCHAR));

            //
            // Open the subkey identified by szEventSourceName and 
            // copy the values listed therein.
            //

            dwError = RegOpenKeyEx(
                          hkSecurity,
                          pBuffer[i].szEventSourceName,
                          0,
                          KEY_READ,
                          &hkSource
                          );

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }

            pData += PtrAlignSize(dwLength + sizeof(WCHAR));
            pBuffer[i].szEventMessageFile = (PWSTR)pData;
            dwLength = *pdwLength - dwSpaceUsed;

            dwError = RegQueryValueEx(
                          hkSource,
                          L"EventMessageFile",
                          NULL,
                          NULL,
                          (PBYTE)pBuffer[i].szEventMessageFile,
                          &dwLength
                          );

            if (ERROR_FILE_NOT_FOUND == dwError)
            {
                dwError = ERROR_SUCCESS;
                dwLength = 0;
                pBuffer[i].szEventMessageFile = NULL;
            }

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }

            dwSpaceUsed += PtrAlignSize(dwLength + sizeof(WCHAR));
            pData += PtrAlignSize(dwLength + sizeof(WCHAR));
            pBuffer[i].szEventAccessStringsFile = (PWSTR)pData;
            dwLength = *pdwLength - dwSpaceUsed;

            dwError = RegQueryValueEx(
                          hkSource,
                          L"ParameterMessageFile",
                          NULL,
                          NULL,
                          (PBYTE)pBuffer[i].szEventAccessStringsFile,
                          &dwLength
                          );

            if (ERROR_FILE_NOT_FOUND == dwError)
            {
                dwError = ERROR_SUCCESS;
                dwLength = 0;
                pBuffer[i].szEventAccessStringsFile = NULL;
            }

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }

            dwSpaceUsed += PtrAlignSize(dwLength + sizeof(WCHAR));
            pData += PtrAlignSize(dwLength + sizeof(WCHAR));
            pBuffer[i].szEventSourceXmlSchemaFile = (PWSTR)pData;
            dwLength = *pdwLength - dwSpaceUsed;

            dwError = RegQueryValueEx(
                          hkSource,
                          L"XmlSchemaFile",
                          NULL,
                          NULL,
                          (PBYTE)pBuffer[i].szEventSourceXmlSchemaFile,
                          &dwLength
                          );

            if (ERROR_FILE_NOT_FOUND == dwError)
            {
                dwError = ERROR_SUCCESS;
                dwLength = 0;
                pBuffer[i].szEventSourceXmlSchemaFile = NULL;
            }

            if (ERROR_SUCCESS != dwError)
            {
                b = FALSE;
                goto Cleanup;
            }
            
            RegCloseKey(hkSource);
            hkSource = NULL;
        }
    }

Cleanup:

    if (hkSecurity)
    {
        RegCloseKey(hkSecurity);
    }
    if (hkSource)
    {
        RegCloseKey(hkSource);
    }
    if ((pName != NULL) && (pName != (PWSTR)Buffer))
    {
        AuthzpFree(pName);
    }
    if (!b)
    {
        SetLastError(dwError);
    }

    *pdwLength = dwTotalLengthNeeded;
    *pdwCount = dwSourceCount;

    return b;
}


BOOL
AuthzRegisterSecurityEventSource(
    IN  DWORD                                 dwFlags,
    IN  PCWSTR                                szEventSourceName,
    OUT PAUTHZ_SECURITY_EVENT_PROVIDER_HANDLE phEventProvider
    )

/**

Routine Description:

    This allows the client to register a provider with the LSA.
                   
Arguments:

    dwFlags - TBD
    
    szEventSourceName - the provider name
    
    phEventProvider - pointer to provider handle to initialize.
    
Return Value:

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
    
**/

{
    NTSTATUS Status;
    BOOL     b       = TRUE;

    UNREFERENCED_PARAMETER(dwFlags);

    if (NULL == szEventSourceName || wcslen(szEventSourceName) == 0 || NULL == phEventProvider)
    {
        b = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    RpcTryExcept {

        Status = LsarAdtRegisterSecurityEventSource(
                     0,
                     szEventSourceName,
                     phEventProvider
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if (!NT_SUCCESS(Status))
    {
        b = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
        goto Cleanup;
    }

Cleanup:

    return b;
}
    
BOOL
AuthzUnregisterSecurityEventSource(
    IN     DWORD                                 dwFlags,
    IN OUT PAUTHZ_SECURITY_EVENT_PROVIDER_HANDLE phEventProvider
    )

/**

Routine Description:

    Unregisters a provider with the LSA.

Arguments:

    dwFlags - TBD
    
    hEventProvider - the handle returned by AuthzRegisterSecurityEventSource

Return Value:

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().

**/

{
    NTSTATUS Status;
    BOOL     b       = TRUE;

    UNREFERENCED_PARAMETER(dwFlags);

    if (NULL == phEventProvider)
    {
        b = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    RpcTryExcept {
        
        Status = LsarAdtUnregisterSecurityEventSource(
                     0,
                     phEventProvider
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;

    if (!NT_SUCCESS(Status))
    {
        b = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
        goto Cleanup;
    }

Cleanup:

    return b;
}

BOOL
AuthzReportSecurityEvent(
    IN DWORD                                dwFlags,
    IN AUTHZ_SECURITY_EVENT_PROVIDER_HANDLE hEventProvider,
    IN DWORD                                dwAuditId,
    IN PSID                                 pUserSid        OPTIONAL,
    IN DWORD                                dwCount,
    ...    
    )

/**

Routine Description:

    Allows a client to generate an audit.

Arguments:

    dwFlags - APF_AuditSuccess APF_AuditFailure
    
    hEventProvider - handle to the provider registered.
    
    dwAuditId - the ID of the audit
    
    pUserSid - the SID that the audit should appear as being generated by in
        the eventlog
        
    dwCount - the number of APF type-value pairs that follow in the VA section                       

Return Value:

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().

**/

{
    BOOL         b;
    AUDIT_PARAMS AuditParams    = {0};
    AUDIT_PARAM  ParamArray[SE_MAX_AUDIT_PARAMETERS] = {0};

    va_list(arglist);

    AuditParams.Count      = (USHORT)dwCount;
    AuditParams.Parameters = ParamArray;

    va_start (arglist, dwCount);

    b = AuthzpInitializeAuditParamsV(
            dwFlags | AUTHZP_INIT_PARAMS_SKIP_HEADER,
            &AuditParams,
            NULL, 
            NULL,
            0,
            (USHORT)dwCount,
            arglist
            );

    if (!b)
    {
        goto Cleanup;
    }

    b = AuthzReportSecurityEventFromParams(
            dwFlags,
            hEventProvider,
            dwAuditId,
            pUserSid,
            &AuditParams
            );

    if (!b)
    {
        goto Cleanup;
    }

Cleanup:

    return b;
}

BOOL
AuthzReportSecurityEventFromParams(
    IN DWORD                                dwFlags,
    IN AUTHZ_SECURITY_EVENT_PROVIDER_HANDLE hEventProvider,
    IN DWORD                                dwAuditId,
    IN PSID                                 pUserSid        OPTIONAL,
    IN PAUDIT_PARAMS                        pParams
    )

/**

Routine Description:

    This generates an audit from the passed parameter array.

Arguments:

    dwFlags - APF_AuditSuccess APF_AuditFailure
    
    hEventProvider - handle to the provider registered
    
    dwAuditId - the ID of the audit
    
    pUserSid - the SID that the audit should appear as being generated by in.  If NULL the
        effective token is used.
        
    pParams - array of audit parameters.

Return Value:

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().

**/

{
    NTSTATUS Status;
    LUID     Luid;
    BOOL     b        = TRUE;
    BOOL     bFreeSid = FALSE;

    UNREFERENCED_PARAMETER(dwFlags);

    if (NULL == hEventProvider || NULL == pParams)
    {
        b = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    if (NULL == pUserSid)
    {
        bFreeSid = TRUE;
        b = AuthzpGetThreadTokenInfo(
                &pUserSid, 
                &Luid
                );

        if (!b)
        {
            //
            // Failed to get the thread token, try for the process
            // token.
            //

            b = AuthzpGetProcessTokenInfo(
                    &pUserSid, 
                    &Luid
                    );

            if (!b)
            {
                goto Cleanup;
            }
        }
    }

    RpcTryExcept {

        Status = LsarAdtReportSecurityEvent(
                     0,
                     hEventProvider,
                     dwAuditId,
                     pUserSid,
                     pParams
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = RpcExceptionCode();

    } RpcEndExcept;
    
    if (!NT_SUCCESS(Status))
    {
        b = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
        goto Cleanup;
    }

Cleanup:

    if (bFreeSid && pUserSid)
    {
        AuthzpFree(pUserSid);
    }

    return b;
}

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

DWORD
DeleteKeyRecursivelyW(
    IN HKEY   hkey, 
    IN LPCWSTR pwszSubKey
    )
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExW(hkey, pwszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        WCHAR   wszSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(wszSubKeyName);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyW(hkSubKey, NULL, NULL, NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyW(hkSubKey, --dwIndex, wszSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursivelyW(hkSubKey, wszSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        if (pwszSubKey)
        {
            dwRet = RegDeleteKeyW(hkey, pwszSubKey);
        }
        else
        {
            //  we want to delete all the values by hand
            cchSubKeyName = ARRAYSIZE(wszSubKeyName);
            while (ERROR_SUCCESS == RegEnumValueW(hkey, 0, wszSubKeyName, &cchSubKeyName, NULL, NULL, NULL, NULL))
            {
                //  avoid looping infinitely when we cant delete the value
                if (RegDeleteValueW(hkey, wszSubKeyName))
                    break;
                    
                cchSubKeyName = ARRAYSIZE(wszSubKeyName);
            }
        }
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\authzdebug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    authzdebug.c

Abstract:

   This module implements debug helper functions for the user mode
   authorization APIs.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/


#include "pch.h"

#pragma hdrstop

#include <authzp.h>


//
// Function name: AuthzPrintContext
//
// Purpose: Debug support
//


VOID
AuthzPrintContext(
    IN PAUTHZI_CLIENT_CONTEXT pCC
    )
{

#ifdef AUTHZ_DEBUG

    DWORD i = 0;
    NTSTATUS Status;
    UNICODE_STRING mystr;
    WCHAR StrBuf[512];

    mystr.Length = 512;
    mystr.MaximumLength = 512;
    mystr.Buffer = (LPWSTR) StrBuf;

    fflush(stdout);

    wprintf(L"Server = %u", pCC->Server);
    wprintf(L"\t Revision = %x\n", pCC->Revision);
    wprintf(L"Flags = %x\n", pCC->Flags);
    wprintf(L"\t SidCount = %x\n", pCC->SidCount);

    for (i = 0; i < pCC->SidCount; i++ )
    {
        Status = RtlConvertSidToUnicodeString(&mystr, pCC->Sids[i].Sid, FALSE);

        if (!NT_SUCCESS(Status))
        {

            wprintf(L"RtlConvertSidToUnicode failed with %x\n", Status);

            return;
        }

        wprintf(L"Attrib = %x, Sid = %s\n", pCC->Sids[i].Attributes, mystr.Buffer);
    }

    wprintf(L"\n");


    for (i = 0; i < pCC->RestrictedSidCount; i++ )
    {
        Status = RtlConvertSidToUnicodeString(&mystr, pCC->RestrictedSids[i].Sid, FALSE);

        if (!NT_SUCCESS(Status))
        {
            return;
        }

        wprintf(L"Attrib = %x, Sid = %s\n", pCC->RestrictedSids[i].Attributes, mystr.Buffer);
    }

    wprintf(L"\n");

#if 0
    for (i = 0; i < pTPrivs->PrivilegeCount ; i++ )
    {
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);
    }
#endif

    fflush(stdout);
#else
    UNREFERENCED_PARAMETER(pCC);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\adtutil.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T U T I L . C
//
// Contents:    Functions to construct audit event parameters
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "adtgen.h"
#include "authzp.h"



BOOL
AuthzpGetTokenInfo(
    IN     HANDLE       hToken,
    OUT    PSID*        ppUserSid,         OPTIONAL
    OUT    PLUID        pAuthenticationId
    )
/*++

Routine Description:

    Get user-sid and the user-logon-id from a token.

Arguments:

    hToken            - handle of token to query

    ppUserSid         - pointer to user sid
                        if non NULL, allocate and copy the user sid
                        from the token. callers must free it using AuthzpFree

    pAuthenticationId - pointer to logon-id

Return Value:

    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,

Notes:
    Caller must have TOKEN_QUERY access right.

--*/
{
    BOOL  fResult = FALSE;
    TOKEN_STATISTICS TokenStats;
#define MAX_TOKEN_USER_INFO_SIZE (sizeof(TOKEN_USER)+SECURITY_MAX_SID_SIZE)
    BYTE TokenInfoBuf[MAX_TOKEN_USER_INFO_SIZE];
    TOKEN_USER* pTokenUserInfo = (TOKEN_USER*) TokenInfoBuf;
    DWORD dwSize;

    if ( ARGUMENT_PRESENT(ppUserSid) )
    {
        *ppUserSid = NULL;

        if ( GetTokenInformation( hToken, TokenUser, pTokenUserInfo,
                                  MAX_TOKEN_USER_INFO_SIZE, &dwSize ))
        {
            dwSize = GetLengthSid( pTokenUserInfo->User.Sid );

            *ppUserSid = AuthzpAlloc( dwSize );

            if (*ppUserSid == NULL)
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                goto Finish;
            }

            CopyMemory( *ppUserSid, pTokenUserInfo->User.Sid, dwSize );
        }
        else
        {
            //
            // GetTokenInformation already sets last error.
            //

            goto Finish;
        }
    }
    
    if ( GetTokenInformation( hToken, TokenStatistics,
                              (PVOID) &TokenStats,
                              sizeof(TOKEN_STATISTICS), &dwSize ) )
    {
        *pAuthenticationId = TokenStats.AuthenticationId;
        fResult = TRUE;
        goto Finish;
    }

    //
    // error case
    //

    if ( ppUserSid && *ppUserSid )
    {
        AuthzpFree( *ppUserSid );
        *ppUserSid = NULL;
    }

Finish:
    return fResult;
}


BOOL
AuthzpGetThreadTokenInfo(
    OUT    PSID*        ppUserSid,         OPTIONAL
    OUT    PLUID        pAuthenticationId
    )
/*++

Routine Description:

    Get user-sid and the user-logon-id from the thread token.

Arguments:

    ppUserSid         - pointer to user sid
                        if non NULL, allocate and copy the user sid
                        from the token. callers must free it using AuthzpFree

    pAuthenticationId - pointer to logon id

Return Value:

    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,


Notes:
    Caller must have TOKEN_QUERY access right.

--*/
{
    BOOL  fResult = FALSE;
    HANDLE hToken=NULL;


    if ( OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken ) )
    {
        fResult = AuthzpGetTokenInfo( hToken, ppUserSid, pAuthenticationId );
        CloseHandle( hToken );
    }

    return fResult;
}


BOOL
AuthzpGetProcessTokenInfo(
    OUT    PSID*        ppUserSid,         OPTIONAL
    OUT    PLUID        pAuthenticationId
    )
/*++

Routine Description:

    Get user-sid and the user-logon-id from the process token.

Arguments:

    ppUserSid         - pointer to user sid
                        if non NULL, allocate and copy the user sid
                        from the token. callers must free it using AuthzpFree

    pAuthenticationId - pointer to logon id

Return Value:

    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,


Notes:
    Caller must have TOKEN_QUERY access right.

--*/
{
    BOOL  fResult = FALSE;
    HANDLE hToken=NULL;


    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ) )
    {
        fResult = AuthzpGetTokenInfo( hToken, ppUserSid, pAuthenticationId );
        CloseHandle( hToken );
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\context.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    context.c

Abstract:

   This module implements the internal worker routines to create and manipulate
   client context.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/

#include "pch.h"

#pragma hdrstop

#include <authzp.h>

LUID AuthzTakeOwnershipPrivilege = {SE_TAKE_OWNERSHIP_PRIVILEGE, 0};
LUID AuthzSecurityPrivilege = {SE_SECURITY_PRIVILEGE, 0};


//
// Definitions used by AuthzpGetAllGroups.
//

const DWORD                     c_dwMaxSidCount = LSAI_CONTEXT_SID_LIMIT;
static DWORD                    s_dwPageSize = 0;

typedef struct _SID_DESC
{
    DWORD                       dwAttributes;
    DWORD                       dwLength;
    BYTE                        sid[SECURITY_MAX_SID_SIZE];
}
SID_DESC, *PSID_DESC;

typedef struct _SID_SET
{
    DWORD                               dwCount;
    DWORD                               dwMaxCount;
    PSID_DESC                           pSidDesc;

    DWORD                               dwFlags;
    DWORD                               dwBaseCount;

    // user information
    PSID                                pUserSid;
    PSID                                pDomainSid;
    PUNICODE_STRING                     pusUserName;
    PUNICODE_STRING                     pusDomainName;

    // user name & domain
    PLSA_TRANSLATED_NAME                pNames;
    PLSA_REFERENCED_DOMAIN_LIST         pDomains;
    PWSTR                               pDomainsName;
    PLSA_TRANSLATED_SID2                pSids;
    SID_NAME_USE                        sidUse;

    // information about the local machine
    PPOLICY_ACCOUNT_DOMAIN_INFO         pAccountInfo;
    PPOLICY_PRIMARY_DOMAIN_INFO         pPrimaryInfo;
    PWSTR                               pPrimaryInfoName;
    BOOL                                bStandalone;
    BOOL                                bSkipNonLocal;

    // user domain dc info
    PDOMAIN_CONTROLLER_INFO             pUdDcInfo;
    PDOMAIN_CONTROLLER_INFO             pPdDcInfo;
    PDOMAIN_CONTROLLER_INFO             pRdDcInfo;

    // role information for user domain & primary domain
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pUdBasicInfo;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pPdBasicInfo;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pRdBasicInfo;

    // name of the user domain DC
    PWSTR                               pszUdDcName;
    PWSTR                               pszRdDcName;
}
SID_SET, *PSID_SET;


//
// Forward declarations of functions called by
// AuthzpGetAllGroups.
//

DWORD
AuthzpAddWellKnownSids(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetTokenGroupsXp(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetTokenGroupsDownlevel(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetAccountDomainGroupsDs(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetAccountDomainGroupsSam(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetResourceDomainGroups(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetLocalGroups(
    IN BOOL bAddPrimaryGroup,
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetSidHistory(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetPrimaryGroup(
    IN SAM_HANDLE hSam,
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetAliasMembership(
    IN SAM_HANDLE hSam,
    IN PSID pDomainSid,
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpInitializeSidSetByName(
    IN PUNICODE_STRING pusUserName,
    IN PUNICODE_STRING pusDomainName,
    IN DWORD dwFlags,
    IN PSID_SET pSidSet
    );

DWORD
AuthzpIsDC(
    OUT PBOOL pbIsDC
    );

DWORD
AuthzpInitializeSidSetBySid(
    IN PSID pUserSid,
    IN DWORD dwFlags,
    IN PSID_SET pSidSet
    );

DWORD
AuthzpDeleteSidSet(
    IN PSID_SET pSidSet
    );

DWORD
AuthzpAddSidToSidSet(
    IN PSID_SET pSidSet,
    IN PSID pSid,
    IN DWORD dwSidLength,
    IN DWORD dwAttributes,
    OUT PBOOL pbAdded OPTIONAL,
    OUT PSID* ppSid OPTIONAL
    );

DWORD
AuthzpGetUserDomainSid(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetUserDomainName(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetLocalInfo(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetDcName(
    IN LPCTSTR pszDomain,
    IN OUT PDOMAIN_CONTROLLER_INFO* ppDcInfo
    );

VOID
AuthzpConvertSidToEdn(
    IN PSID pSid,
    OUT PWSTR pszSid
    );


BOOL
AuthzpCopySidsAndAttributes(
    IN OUT PSID_AND_ATTRIBUTES DestSidAttr,
    IN PSID_AND_ATTRIBUTES SidAttr1,
    IN DWORD Count1,
    IN PSID_AND_ATTRIBUTES SidAttr2,
    IN DWORD Count2
    )

/*++

Routine description:

    This routine takes two sets of sid and attribute strucutes and concatenates
    them into a single one. The new structure is constructed into the buffer
    supplied by the caller.

Arguments:

    DestSidAttr - Caller supplied buffer into which the resultant structure
        will be copied. The caller has already computed the size of the buffer
        required to hold the output.

    SidAttr1 - The first sid and attributes structure.

    Count1 - The number of elements in SidAttr1 structure.

    SidAttr2 - The second sid and attributes structure.

    Count2 - The number of elements in SidAttr2 structure.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PUCHAR   pCurrent = ((PUCHAR) DestSidAttr) + (sizeof(SID_AND_ATTRIBUTES) * (Count1 + Count2));
    NTSTATUS Status   = STATUS_SUCCESS;
    DWORD    Length   = 0;
    DWORD    i        = 0;

    //
    // Loop thru the first set and copy the sids and their attribtes.
    //

    for (i = 0; i < Count1; i++)
    {
        Length = RtlLengthSid(SidAttr1[i].Sid);

        Status = RtlCopySid(
                     Length,
                     pCurrent,
                     SidAttr1[i].Sid
                     );

        if (!NT_SUCCESS(Status))
        {
            SetLastError(RtlNtStatusToDosError(Status));
            return FALSE;
        }

        DestSidAttr[i].Sid = (PSID) pCurrent;
        DestSidAttr[i].Attributes = SidAttr1[i].Attributes;
        pCurrent += Length;
    }

    //
    // Loop thru the second set and copy the sids and their attribtes.
    //

    for (; i < (Count1 + Count2); i++)
    {
        Length = RtlLengthSid(SidAttr2[i - Count1].Sid);

        Status = RtlCopySid(
                     Length,
                     pCurrent,
                     SidAttr2[i - Count1].Sid
                     );

        if (!NT_SUCCESS(Status))
        {
            SetLastError(RtlNtStatusToDosError(Status));
            return FALSE;
        }

        DestSidAttr[i].Sid = (PSID) pCurrent;
        DestSidAttr[i].Attributes = SidAttr2[i - Count1].Attributes;
        pCurrent += Length;
    }

    return TRUE;
}


VOID
AuthzpCopyLuidAndAttributes(
    IN OUT PAUTHZI_CLIENT_CONTEXT pCC,
    IN PLUID_AND_ATTRIBUTES Source,
    IN DWORD Count,
    IN OUT PLUID_AND_ATTRIBUTES Destination
)

/*++

Routine description:

    This routine takes a luid and attributes array and copies them into a caller
    supplied buffer. It also records presence of SecurityPrivilege and
    SeTakeOwnershipPrivilege into the client context flags.

Arguments:

    pCC - Pointer to the client context structure into which the presence of
        privileges would be recorded.

    Source - The array of privileges and attributes to be copied into a supplied
        buffer.

    Count - Number of elements in the array.

    Destination - Caller allocated buffer into which the input array will be
        copied.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD i = 0;

    for (i = 0; i < Count; i++)
    {
        //
        // Record the presence of SecurityPrivilege or SeTakeOwnershipPrivilege.
        //

        if ((RtlEqualLuid(&AuthzTakeOwnershipPrivilege, &Source[i].Luid)) &&
            (Source[i].Attributes & SE_PRIVILEGE_ENABLED))
        {
            pCC->Flags |= AUTHZ_TAKE_OWNERSHIP_PRIVILEGE_ENABLED;
        }
        else if ((RtlEqualLuid(&AuthzSecurityPrivilege, &Source[i].Luid)) &&
                 (Source[i].Attributes & SE_PRIVILEGE_ENABLED))
        {
            pCC->Flags |= AUTHZ_SECURITY_PRIVILEGE_ENABLED;
        }

        RtlCopyLuid(&(Destination[i].Luid), &(Source[i].Luid));

        Destination[i].Attributes = Source[i].Attributes;
    }
}


BOOL
AuthzpGetAllGroupsByName(
    IN PUNICODE_STRING pusUserName,
    IN PUNICODE_STRING pusDomainName,
    IN DWORD dwFlags,
    OUT PSID_AND_ATTRIBUTES* ppSidAndAttributes,
    OUT PDWORD pdwSidCount,
    OUT PDWORD pdwSidLength
    )

/*++

Routine description:

    This routine works as AuthzpGetAllGroupsBySid but takes a username
    domain name pair instead of a SID. It also accepts a UPN as the
    username and an empty domain name.


Arguments:

    pusUserName - Name of the user. Can be a UPN.

    pusDomainName - domain name of the user account or NULL in case
        the user name is a UPN.

    Flags -
      AUTHZ_SKIP_TOKEN_GROUPS - Do not compute TokenGroups.
      AUTHZ_SKIP_WORLD_SID    - Do not add the WORLD SID to the context.

    ppSidAttr - Returns SidAndAttribute array. The routine allocates memory
        for this array.

    pSidCount - Returns the number of sids in the array.

    pSidLength - Returns the size of memory allocated to hold the array.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                       dwError;
    BOOL                        bStatus             = TRUE;
    SID_SET                     sidSet              = {0};
    PSID_DESC                   pSidDesc;
    PBYTE                       pSid;
    PSID_AND_ATTRIBUTES         pSidAndAttribs;
    DWORD                       i;


    //
    // Initialize output parameters to zero.
    //

    *ppSidAndAttributes = 0;
    *pdwSidCount = 0;
    *pdwSidLength = 0;


    //
    // Initialize the SID set
    //

    dwError = AuthzpInitializeSidSetByName(
                  pusUserName,
                  pusDomainName,
                  dwFlags,
                  &sidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    if (sidSet.dwFlags & AUTHZ_SKIP_TOKEN_GROUPS)
    {
        //
        // Initialize the user SID.
        //

        dwError = AuthzpGetUserDomainSid(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        //
        // Stick the user SID, the WORLD SID and others
        // into the set if requested.
        //

        dwError = AuthzpAddWellKnownSids(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }
    else
    {
        dwError = AuthzpGetTokenGroupsXp(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            //
            // Detect the downlevel case.
            //

            // if (dwError != SEC_E_NO_S4U_PROT_SUPPORT)
            // {
                // goto Cleanup;
            // }


            //
            // Initialize the user SID.
            //

            dwError = AuthzpGetUserDomainSid(
                          &sidSet
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }


            //
            // Stick the user SID, the WORLD SID and others
            // into the set if requested.
            //

            dwError = AuthzpAddWellKnownSids(
                          &sidSet
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }


            //
            // In case AuthzpAddWellKnownSids finds that the SID is the
            // Anonymous SID, it sets the AUTHZ_SKIP_TOKEN_GROUPS flag.
            //

            if (!(sidSet.dwFlags & AUTHZ_SKIP_TOKEN_GROUPS))
            {
                //
                // Try the downlevel scenario.
                //

                dwError = AuthzpGetTokenGroupsDownlevel(
                              &sidSet
                              );

                if (dwError != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
            }
        }

    }

    //
    // Allocate memory and copy all SIDs
    // from the SID set into ppSidAndAttributes.
    //

    *pdwSidCount = sidSet.dwCount;
    *pdwSidLength = sidSet.dwCount * sizeof(SID_AND_ATTRIBUTES);

    pSidDesc = sidSet.pSidDesc;

    for (i=0;i < sidSet.dwCount;i++,pSidDesc++)
    {
        *pdwSidLength += pSidDesc->dwLength;
    }

    *ppSidAndAttributes = (PSID_AND_ATTRIBUTES)AuthzpAlloc(*pdwSidLength);

    if (*ppSidAndAttributes == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pSid = ((PBYTE)*ppSidAndAttributes) +
            sidSet.dwCount * sizeof(SID_AND_ATTRIBUTES);
    pSidDesc = sidSet.pSidDesc;
    pSidAndAttribs = *ppSidAndAttributes;

    for (i=0;i < sidSet.dwCount;i++,pSidDesc++,pSidAndAttribs++)
    {
        pSidAndAttribs->Attributes = pSidDesc->dwAttributes;
        pSidAndAttribs->Sid = pSid;

        RtlCopyMemory(
            pSid,
            pSidDesc->sid,
            pSidDesc->dwLength
            );

        pSid += pSidDesc->dwLength;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        bStatus = FALSE;

        *pdwSidCount = 0;
        *pdwSidLength = 0;

        if (*ppSidAndAttributes)
        {
            AuthzpFree(*ppSidAndAttributes);
            *ppSidAndAttributes = 0;
        }
    }

    AuthzpDeleteSidSet(&sidSet);

    return bStatus;
}


BOOL
AuthzpGetAllGroupsBySid(
    IN PSID pUserSid,
    IN DWORD dwFlags,
    OUT PSID_AND_ATTRIBUTES* ppSidAndAttributes,
    OUT PDWORD pdwSidCount,
    OUT PDWORD pdwSidLength
    )

/*++

Routine description:

    This routine computes the groups a given user is a member of.
    It uses a data structure called a SID_SET for collecting the SIDs.

    1. Initialize the SID_SET.

    2. Put the user SID into the set.
       If requested, put the EVERYONE SID into the set.
       Add Well Known SIDs.

    3. If requested, put the SIDs for non-local groups the user is
       a member of into the set. There are three scenarios for this
       step, depending on the version of the DC we are talking to:

       xp:  Use LsaLogonUser with the Kerberos S4U package and
            extract the groups from the token returned
            (AuthzpGetWXPDomainTokenGroups).

       W2k: Use ldap and the SAM API to compute memberships in
       NT4: the account and primary domain and to get the SID history
            (AuthzpGetW2kDomainTokenGroups).

    4. Transmogrify the SID_SET into a SID_AND_ATTRIBUTES array
       and free the SID_SET.

Arguments:

    pUserSid - The user SID for which the groups should be computed.

    Flags -
      AUTHZ_SKIP_TOKEN_GROUPS - Do not compute TokenGroups.
      AUTHZ_SKIP_WORLD_SID    - Do not add the WORLD SID to the context.
      AUTHZ_REQUIRE_S4U_LOGON - Do not use the downlevel codepaths.  Force S4U or fail.
                                This is to enforce account restrictions.
                                
    ppSidAttr - Returns SidAndAttribute array. The routine allocates memory
        for this array.

    pSidCount - Returns the number of sids in the array.

    pSidLength - Returns the size of memory allocated to hold the array.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                       dwError;
    BOOL                        bStatus             = TRUE;
    SID_SET                     sidSet              = {0};
    PSID_DESC                   pSidDesc;
    PBYTE                       pSid;
    PSID_AND_ATTRIBUTES         pSidAndAttribs;
    DWORD                       i;


    //
    // Initialize output parameters to zero.
    //

    *ppSidAndAttributes = 0;
    *pdwSidCount = 0;
    *pdwSidLength = 0;


    //
    // Initialize the SID set
    //

    dwError = AuthzpInitializeSidSetBySid(
                  pUserSid,
                  dwFlags,
                  &sidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    if (sidSet.dwFlags & AUTHZ_SKIP_TOKEN_GROUPS)
    {
        //
        // Stick the user SID, the WORLD SID and others
        // into the set if requested.
        //

        dwError = AuthzpAddWellKnownSids(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }
    else
    {
        //
        // Initialize user and domain name members of the sid set.
        //

        dwError = AuthzpGetUserDomainName(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        if (sidSet.pNames->Use == SidTypeAlias ||
            sidSet.pNames->Use == SidTypeGroup ||
            sidSet.pNames->Use == SidTypeWellKnownGroup)
        {
            //
            // LsaLogonUser cannot log on groups...
            //

            dwError = ERROR_NOT_SUPPORTED;
        }
        else
        {
            dwError = AuthzpGetTokenGroupsXp(
                          &sidSet
                          );
        }

        if (dwError != ERROR_SUCCESS)
        {
            //
            // Xp logon code failed.  If user prohibits the downlevel path,
            // then exit now.
            //

            if (dwFlags & AUTHZ_REQUIRE_S4U_LOGON)
            {
                goto Cleanup;
            }

            //
            // Detect the downlevel case.
            //

            // if (dwError != SEC_E_NO_S4U_PROT_SUPPORT)
            // {
                // goto Cleanup;
            // }

            //
            //
            // Stick the user SID, the WORLD SID and others
            // into the set if requested.
            //

            dwError = AuthzpAddWellKnownSids(
                          &sidSet
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }


            //
            // In case AuthzpAddWellKnownSids finds that the SID is the
            // Anonymous SID, it sets the AUTHZ_SKIP_TOKEN_GROUPS flag.
            //

            if (!(sidSet.dwFlags & AUTHZ_SKIP_TOKEN_GROUPS))
            {
                //
                // Try the downlevel scenario.
                //

                dwError = AuthzpGetTokenGroupsDownlevel(
                              &sidSet
                              );

                if (dwError != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
            }
        }
    }


    //
    // Allocate memory and copy all SIDs
    // from the SID set into ppSidAndAttributes.
    //

    *pdwSidCount = sidSet.dwCount;
    *pdwSidLength = sidSet.dwCount * sizeof(SID_AND_ATTRIBUTES);

    pSidDesc = sidSet.pSidDesc;

    for (i=0;i < sidSet.dwCount;i++,pSidDesc++)
    {
        *pdwSidLength += pSidDesc->dwLength;
    }

    *ppSidAndAttributes = (PSID_AND_ATTRIBUTES)AuthzpAlloc(*pdwSidLength);

    if (*ppSidAndAttributes == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pSid = ((PBYTE)*ppSidAndAttributes) +
            sidSet.dwCount * sizeof(SID_AND_ATTRIBUTES);
    pSidDesc = sidSet.pSidDesc;
    pSidAndAttribs = *ppSidAndAttributes;

    for (i=0;i < sidSet.dwCount;i++,pSidDesc++,pSidAndAttribs++)
    {
        pSidAndAttribs->Attributes = pSidDesc->dwAttributes;
        pSidAndAttribs->Sid = pSid;

        RtlCopyMemory(
            pSid,
            pSidDesc->sid,
            pSidDesc->dwLength
            );

        pSid += pSidDesc->dwLength;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        bStatus = FALSE;

        *pdwSidCount = 0;
        *pdwSidLength = 0;

        if (*ppSidAndAttributes)
        {
            AuthzpFree(*ppSidAndAttributes);
            *ppSidAndAttributes = 0;
        }
    }

    AuthzpDeleteSidSet(&sidSet);

    return bStatus;
}


DWORD
AuthzpAddWellKnownSids(
    IN OUT PSID_SET pSidSet
    )
{
    DWORD                       dwError;
    BOOL                        bStatus;
    BOOL                        bEqual;
    BOOL                        bAddEveryone        = TRUE;
    BOOL                        bAddAuthUsers       = TRUE;
    BOOL                        bAddAdministrators  = FALSE;
    BYTE                        sid[SECURITY_MAX_SID_SIZE];
    PSID                        pSid                = (PSID)sid;
    DWORD                       dwLengthSid;


    //
    // Stick the user SID into the set
    //

    dwError = AuthzpAddSidToSidSet(
                  pSidSet,
                  pSidSet->pUserSid,
                  0,
                  SE_GROUP_ENABLED,
                  0,
                  0
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    pSidSet->dwBaseCount = 1;

    //
    // Test for some well known SIDs.
    //
    // If the SID passed in is the Anonymous SID, then check the registry
    // value to determine if the Everyone SID should be included in the
    // resulting client context.
    //

    if (IsWellKnownSid(
            pSidSet->pUserSid,
            WinAnonymousSid))
    {
        bAddEveryone = FALSE;
        bAddAuthUsers = FALSE;

        bStatus = AuthzpEveryoneIncludesAnonymous(
                      &bAddEveryone
                      );

        if (bStatus == FALSE)
        {
            bAddEveryone = FALSE;
        }

        pSidSet->dwFlags |= AUTHZ_SKIP_TOKEN_GROUPS;
    }
    else if (IsWellKnownSid(
                 pSidSet->pUserSid,
                 WinLocalSystemSid))
    {
        bAddEveryone = TRUE;
        bAddAuthUsers = TRUE;
        bAddAdministrators = TRUE;

        pSidSet->dwFlags |= AUTHZ_SKIP_TOKEN_GROUPS;
    }
    else
    {
        // 
        // This is a dummy context. Return now.
        //
    
        if (pSidSet->dwFlags & AUTHZ_SKIP_TOKEN_GROUPS)
        {
            return ERROR_SUCCESS;
        }   

        dwLengthSid = SECURITY_MAX_SID_SIZE;

        bStatus = CreateWellKnownSid(
                      WinBuiltinDomainSid,
                      0,
                      pSid,
                      &dwLengthSid
                      );

        if (bStatus == FALSE)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        bStatus = EqualDomainSid(
                      pSidSet->pUserSid,
                      pSid,
                      &bEqual
                      );
        //
        // ERROR_NON_DOMAIN_SID is returned for wellknown sids.
        // It is ok to ignore this error and continue.
        //

        if ((bStatus == FALSE) && (GetLastError() != ERROR_NON_DOMAIN_SID))
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        if (bEqual)
        {
            pSidSet->bSkipNonLocal = TRUE;
        }
        else
        {
            bAddEveryone = TRUE;
            bAddAuthUsers = TRUE;
        }
    }

    if (bAddEveryone)
    {
        dwLengthSid = SECURITY_MAX_SID_SIZE;

        bStatus = CreateWellKnownSid(
                      WinWorldSid,
                      0,
                      pSid,
                      &dwLengthSid
                      );

        if (bStatus == FALSE)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pSid,
                      dwLengthSid,
                      SE_GROUP_MANDATORY
                        | SE_GROUP_ENABLED_BY_DEFAULT
                        | SE_GROUP_ENABLED,
                      0,
                      0
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->dwBaseCount++;
    }

    //
    // Add  NT AUTHORITY\Authenticated Users  to the set
    // only if the user does not have the Guest RID
    //

    if (bAddAuthUsers &&
        *RtlSubAuthorityCountSid(pSidSet->pUserSid) > 0 &&
        (*RtlSubAuthoritySid(
            pSidSet->pUserSid,
            (ULONG)(*RtlSubAuthorityCountSid(
                        pSidSet->pUserSid)) - 1) != DOMAIN_USER_RID_GUEST) &&
        (*RtlSubAuthoritySid(
            pSidSet->pUserSid,
            (ULONG)(*RtlSubAuthorityCountSid(
                        pSidSet->pUserSid)) - 1) != DOMAIN_GROUP_RID_GUESTS))
    {
        dwLengthSid = SECURITY_MAX_SID_SIZE;

        bStatus = CreateWellKnownSid(
                      WinAuthenticatedUserSid,
                      0,
                      pSid,
                      &dwLengthSid
                      );

        if (bStatus == FALSE)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pSid,
                      dwLengthSid,
                      SE_GROUP_MANDATORY
                        | SE_GROUP_ENABLED_BY_DEFAULT
                        | SE_GROUP_ENABLED,
                      0,
                      0
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->dwBaseCount++;
    }

    if (bAddAdministrators)
    {
        dwLengthSid = SECURITY_MAX_SID_SIZE;

        bStatus = CreateWellKnownSid(
                      WinBuiltinAdministratorsSid,
                      0,
                      pSid,
                      &dwLengthSid
                      );

        if (bStatus == FALSE)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pSid,
                      dwLengthSid,
                      SE_GROUP_MANDATORY
                        | SE_GROUP_ENABLED_BY_DEFAULT
                        | SE_GROUP_ENABLED,
                      0,
                      0
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->dwBaseCount++;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    return dwError;
}


DWORD
AuthzpGetTokenGroupsXp(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the domain specified by the SID and
    retrieves the list of groups to which the user belongs.
    This routine assumes we are talking to a WinXP DC.
    We take advantage of the new LsaLogonUser package, KerbS4ULogon.

Arguments:

    pUserSid - user SID for which the lookup should be performed.

    pSidSet - SID_SET in which we collect the SIDs of the groups
        we found in the token.

Return Value:

    Win32 error code:

    - ERROR_NOT_SUPPORTED if the DC does not support the call
        (pre ~2475 or client)
    - ERROR_INVALID_PARAMETER if the code is running on a
        pre XP platform

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    BOOL                        bStatus;
    NTSTATUS                    status;
    HANDLE                      hLsa                = 0;
    LSA_STRING                  asProcessName;
    LSA_STRING                  asPackageName;
    ULONG                       ulAuthPackage;
    TOKEN_SOURCE                sourceContext;
    PVOID                       pProfileBuffer      = 0;
    ULONG                       ulProfileLength     = 0;
    LUID                        luidLogonId;
    HANDLE                      hToken              = 0;
    QUOTA_LIMITS                quota;
    NTSTATUS                    subStatus;
    DWORD                       dwLength;
    DWORD                       i;
    PTOKEN_USER                 pTokenUser          = 0;
    PTOKEN_GROUPS               pTokenGroups        = 0;
    PSID_AND_ATTRIBUTES         pSidAndAttribs;
    ULONG                       ulPackageSize;
    PKERB_S4U_LOGON             pPackage            = 0;


    //
    // Set up the authentication package.
    //

    ulPackageSize = sizeof(KERB_S4U_LOGON);
    ulPackageSize += pSidSet->pusUserName->Length;

    if (pSidSet->pusDomainName)
    {
        ulPackageSize += pSidSet->pusDomainName->Length;
    }

    pPackage = (PKERB_S4U_LOGON)LocalAlloc(
                    LMEM_FIXED,
                    ulPackageSize
                    );

    if (pPackage == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pPackage->MessageType = KerbS4ULogon;
    pPackage->Flags = 0;

    pPackage->ClientUpn.Length = pSidSet->pusUserName->Length;
    pPackage->ClientUpn.MaximumLength = pSidSet->pusUserName->Length;
    pPackage->ClientUpn.Buffer = (PWSTR)(pPackage + 1);

    RtlCopyMemory(
        pPackage->ClientUpn.Buffer,
        pSidSet->pusUserName->Buffer,
        pSidSet->pusUserName->Length
        );

    if (pSidSet->pusDomainName)
    {
        pPackage->ClientRealm.Length = pSidSet->pusDomainName->Length;
        pPackage->ClientRealm.MaximumLength = pSidSet->pusDomainName->Length;
        pPackage->ClientRealm.Buffer = (PWSTR)
            (((PBYTE)(pPackage->ClientUpn.Buffer)) + pPackage->ClientUpn.Length);

        RtlCopyMemory(
            pPackage->ClientRealm.Buffer,
            pSidSet->pusDomainName->Buffer,
            pSidSet->pusDomainName->Length
            );
    }
    else
    {
        pPackage->ClientRealm.Length = 0;
        pPackage->ClientRealm.MaximumLength = 0;
        pPackage->ClientRealm.Buffer = 0;
    }


    //
    // Our name is AuthzApi.
    //

    RtlInitString(
        &asProcessName,
        "AuthzApi"
        );


    //
    // Set up the process name and
    // register with the LSA.
    //

    status = LsaConnectUntrusted(
                 &hLsa
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }


    //
    // Get the authentication package.
    //

    RtlInitString(&asPackageName, MICROSOFT_KERBEROS_NAME_A);

    status = LsaLookupAuthenticationPackage(
                 hLsa,
                 &asPackageName,
                 &ulAuthPackage
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }


    //
    // Prepare the source context.
    //

    RtlCopyMemory(
        sourceContext.SourceName,
        "Authz   ",
        sizeof(sourceContext.SourceName)
        );

    status = NtAllocateLocallyUniqueId(
                 &sourceContext.SourceIdentifier
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Do the logon.
    //

    status = LsaLogonUser(
                 hLsa,
                 &asProcessName,
                 Network,
                 ulAuthPackage,
                 pPackage,
                 ulPackageSize,
                 0,                          // no LocalGroups
                 &sourceContext,
                 &pProfileBuffer,
                 &ulProfileLength,
                 &luidLogonId,
                 &hToken,
                 &quota,
                 &subStatus
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }


    //
    // Figure out how much memory to allocate for the user info.
    //

    dwLength = 0;

    bStatus = GetTokenInformation(
                  hToken,
                  TokenUser,
                  0,
                  0,
                  &dwLength
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Cleanup;
        }
    }

    pTokenUser = (PTOKEN_USER)LocalAlloc(
                        LMEM_FIXED,
                        dwLength
                        );

    if (pTokenUser == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }


    //
    // Extract the user SID from the token and
    // add it to pSidSet.
    //

    bStatus = GetTokenInformation(
                  hToken,
                  TokenUser,
                  pTokenUser,
                  dwLength,
                  &dwLength
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }


    //
    // Stick the user SID into the set.
    //

    if (!FLAG_ON(pTokenUser->User.Attributes, SE_GROUP_USE_FOR_DENY_ONLY))
    {
        pTokenUser->User.Attributes |= SE_GROUP_ENABLED;
    }

    dwError = AuthzpAddSidToSidSet(
                  pSidSet,
                  pTokenUser->User.Sid,
                  0,
                  pTokenUser->User.Attributes,
                  0,
                  0
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }


    //
    // Figure out how much memory to allocate for the token groups.
    //

    dwLength = 0;

    bStatus = GetTokenInformation(
                  hToken,
                  TokenGroups,
                  0,
                  0,
                  &dwLength
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Cleanup;
        }
    }

    pTokenGroups = (PTOKEN_GROUPS)LocalAlloc(
                        LMEM_FIXED,
                        dwLength
                        );

    if (pTokenGroups == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }


    //
    // Extract the user groups from the token and
    // add them to pSidSet.
    //

    bStatus = GetTokenInformation(
                  hToken,
                  TokenGroups,
                  pTokenGroups,
                  dwLength,
                  &dwLength
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }


    //
    // Stick the group SIDs into the set
    // except for the Network and the LUID SID.
    //

    pSidAndAttribs = pTokenGroups->Groups;

    for (i=0;i < pTokenGroups->GroupCount;i++,pSidAndAttribs++)
    {
        if (!IsWellKnownSid(
                pSidAndAttribs->Sid,
                WinNetworkSid) &&
            !IsWellKnownSid(
                pSidAndAttribs->Sid,
                WinLogonIdsSid))
        {
            dwError = AuthzpAddSidToSidSet(
                          pSidSet,
                          pSidAndAttribs->Sid,
                          0,
                          pSidAndAttribs->Attributes,
                          0,
                          0
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pTokenUser)
    {
        AuthzpFree((HLOCAL)pTokenUser);
    }

    if (pTokenGroups)
    {
        AuthzpFree((HLOCAL)pTokenGroups);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (pProfileBuffer)
    {
        LsaFreeReturnBuffer(pProfileBuffer);
    }

    if (hLsa)
    {
        LsaDeregisterLogonProcess(hLsa);
    }

    if (pPackage)
    {
        AuthzpFree((HLOCAL)pPackage);
    }

    return dwError;
}


DWORD
AuthzpGetTokenGroupsDownlevel(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the domain specified by the SID and
    retrieves the list of groups to which the user belongs.
    This routine assumes we are talking to a Win2k DC.
    First get the users domain universal and global groups
    memberships.
    Next check for nested memberships in the primary domain.
    The last step is getting the SID history for each SID collected
    so far.

Arguments:

    pUserSid - user SID for which the lookup should be performed.

    pSidSet - Returns the number of rids in the alias list

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError;
    BOOL                        bUdIsNative         = FALSE;
    BOOL                        bRdIsNative         = FALSE;
    BOOL                        bAddPrimaryGroup    = FALSE;


    //
    // Retrieve information about the machine.
    //

    dwError = AuthzpGetLocalInfo(pSidSet);

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    if (pSidSet->bStandalone ||
        pSidSet->bSkipNonLocal)
    {
        //
        // In the standalone case there is no need to hit the wire.
        // We don't have to do anything here since local group
        // memberships are computed later anyway.
        //

        bAddPrimaryGroup = TRUE;
        goto LocalGroups;
    }


    //
    // Compare the user domain SID to the machine domain SID.
    // If they are equal, we can use the local machine for
    // global group computing since the account is either
    // a local account or we are sitting on a DC.
    // The SID of the local machine is never zero in a non
    // standalone / workgroup case.
    //

    if (pSidSet->pAccountInfo->DomainSid &&
        RtlEqualSid(
            pSidSet->pDomainSid,
            pSidSet->pAccountInfo->DomainSid))
    {
        BOOL bIsDC = FALSE;

        pSidSet->pszUdDcName = 0;


        //
        // Find out if this is a DC.
        //

        dwError = AuthzpIsDC(&bIsDC);

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }


        //
        // If this is not a DC then give up on global group computing.
        //

        if (FALSE == bIsDC)
        {
            bAddPrimaryGroup = TRUE;
            goto LocalGroups;
        }


        //
        // Local machine is a DC. Since AuthZ is not supported on nt4 we can
        // safely assume it is at least w2k.
        //
    }
    else
    {
        //
        // Find a DC and get its name.
        //

        dwError = AuthzpGetDcName(
                      pSidSet->pusDomainName->Buffer,
                      &pSidSet->pUdDcInfo
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->pszUdDcName = pSidSet->pUdDcInfo->DomainControllerName;
    }


    //
    // User domain can only be in native mode if DS is running.
    //

    if ((pSidSet->pUdDcInfo == 0) ||
        (pSidSet->pUdDcInfo->Flags & DS_DS_FLAG) != 0)
    {
        //
        // Collect information about the domain.
        //

        dwError = DsRoleGetPrimaryDomainInformation(
                      pSidSet->pszUdDcName,
                      DsRolePrimaryDomainInfoBasic,
                      (PBYTE*)&pSidSet->pUdBasicInfo
                      );

        if (dwError != ERROR_SUCCESS)
        {
            //
            // If the domain is in mixed mode and we are passing in a DNS
            // name, the call fails with RPC_S_SERVER_UNAVAILABLE. 
            // We have to get rid of the DC name and get a flat one and
            // then try again.
            //

            if (dwError == RPC_S_SERVER_UNAVAILABLE &&
                pSidSet->pUdDcInfo &&
                (pSidSet->pUdDcInfo->Flags & DS_INET_ADDRESS))
            {
                NetApiBufferFree(pSidSet->pUdDcInfo);
                pSidSet->pUdDcInfo = 0;

                dwError = DsGetDcName(
                              0,
                              pSidSet->pDomainsName,
                              0,
                              0,
                              0,
                              &pSidSet->pUdDcInfo
                              );

                if (dwError != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }

                pSidSet->pszUdDcName = pSidSet->pUdDcInfo->DomainControllerName;

                dwError = DsRoleGetPrimaryDomainInformation(
                              pSidSet->pszUdDcName,
                              DsRolePrimaryDomainInfoBasic,
                              (PBYTE*)&pSidSet->pUdBasicInfo
                              );

                if (dwError != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
            }
            else
            {
                goto Cleanup;
            }
        }

        if ((pSidSet->pUdBasicInfo->Flags & DSROLE_PRIMARY_DS_RUNNING) &&
            (pSidSet->pUdBasicInfo->Flags & DSROLE_PRIMARY_DS_MIXED_MODE) == 0)
        {
            bUdIsNative = TRUE;
        }
    }


    //
    // Check whether the account domain is in native or mixed mode
    // and call the appropriate routine to get the groups.
    //

    if (bUdIsNative)
    {
        //
        // User domain is in native mode.
        //

        dwError = AuthzpGetAccountDomainGroupsDs(
                      pSidSet
                      );
    }
    else
    {
        //
        // User domain is in mixed mode.
        //

        dwError = AuthzpGetAccountDomainGroupsSam(
                      pSidSet
                      );
    }

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }


    //
    // Check whether user domain and resource domain are different.
    //

    if (pSidSet->pPrimaryInfo->Sid &&
        RtlEqualSid(
            pSidSet->pDomainSid,
            pSidSet->pPrimaryInfo->Sid))
    {
        pSidSet->pszRdDcName = pSidSet->pszUdDcName;
        pSidSet->pRdDcInfo = pSidSet->pUdDcInfo;
        pSidSet->pRdBasicInfo = pSidSet->pUdBasicInfo;
        bRdIsNative = bUdIsNative;
    }
    else
    {
        //
        // Find a DC and get its name.
        //

        dwError = AuthzpGetDcName(
                      pSidSet->pPrimaryInfoName,
                      &pSidSet->pPdDcInfo
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->pszRdDcName = pSidSet->pPdDcInfo->DomainControllerName;
        pSidSet->pRdDcInfo = pSidSet->pPdDcInfo;


        //
        // Resource domain can only be in native mode if DS is running.
        //

        if (pSidSet->pRdDcInfo->Flags & DS_DS_FLAG)
        {
            dwError = DsRoleGetPrimaryDomainInformation(
                          pSidSet->pszRdDcName,
                          DsRolePrimaryDomainInfoBasic,
                          (PBYTE*)&pSidSet->pPdBasicInfo
                          );

            if (dwError != ERROR_SUCCESS)
            {
                //
                // If the domain is in mixed mode and we are passing in a DNS
                // name, the call fails. We have to get rid of the DC name
                // and get a flat one and then try again.
                //

                if (dwError == RPC_S_SERVER_UNAVAILABLE &&
                    pSidSet->pPdDcInfo &&
                    (pSidSet->pPdDcInfo->Flags & DS_INET_ADDRESS))
                {
                    NetApiBufferFree(pSidSet->pPdDcInfo);
                    pSidSet->pPdDcInfo = 0;
                    pSidSet->pRdDcInfo = 0;

                    dwError = DsGetDcName(
                                  0,
                                  pSidSet->pPrimaryInfoName,
                                  0,
                                  0,
                                  0,
                                  &pSidSet->pPdDcInfo
                                  );

                    if (dwError != ERROR_SUCCESS)
                    {
                        goto Cleanup;
                    }

                    pSidSet->pRdDcInfo = pSidSet->pPdDcInfo;
                    pSidSet->pszRdDcName = pSidSet->pRdDcInfo->DomainControllerName;

                    dwError = DsRoleGetPrimaryDomainInformation(
                                  pSidSet->pszRdDcName,
                                  DsRolePrimaryDomainInfoBasic,
                                  (PBYTE*)&pSidSet->pPdBasicInfo
                                  );

                    if (dwError != ERROR_SUCCESS)
                    {
                        goto Cleanup;
                    }
                }
                else
                {
                    goto Cleanup;
                }
            }

            pSidSet->pRdBasicInfo = pSidSet->pPdBasicInfo;

            if ((pSidSet->pRdBasicInfo->Flags & DSROLE_PRIMARY_DS_RUNNING) &&
                (pSidSet->pRdBasicInfo->Flags & DSROLE_PRIMARY_DS_MIXED_MODE) == 0)
            {
                bRdIsNative = TRUE;
            }
        }
    }


    //
    // Get domain local groups.
    //

    if (bRdIsNative)
    {
        //
        // Primary domain operates in native mode.
        // This means there could be domain local groups in the token.
        //

        dwError = AuthzpGetResourceDomainGroups(
                      pSidSet);

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }

LocalGroups:


    //
    // Collect local groups information.
    // If this is the local user case, we have to add the primary group
    // for the user.
    //

    dwError = AuthzpGetLocalGroups(
                  bAddPrimaryGroup,
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

Cleanup:

    return dwError;
}


DWORD
AuthzpGetAccountDomainGroupsDs(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the user domain and queries AD for 
    the list of groups (global and universal) the user belongs to.

Arguments:

    pbNativeDomain - Pointer to a BOOL that will receive TRUE or FALSE depending
        on the domain operation mode (native or mixed, resp).

    pSidSet - Pointer to set of SIDs. New groups will be added to this set.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError;
    PLDAP                       pLdap               = 0;
    LDAPMessage*                pResult             = 0;
    LDAPMessage*                pEntry              = 0;
    PLDAP_BERVAL*               ppValue             = 0;
    PWCHAR                      ppszAttributes[]    = {L"tokenGroupsGlobalAndUniversal", 0};
    DWORD                       i;
    DWORD                       dwSidCount;
    WCHAR                       szSidEdn[SECURITY_MAX_SID_SIZE * 2 + 8];

    AuthzpConvertSidToEdn(
        pSidSet->pUserSid,
        szSidEdn
        );


    //
    // We now have the user's SID in LDAP readable form. Fetch the
    // tokenGroupsGlobalAndUniversal attribute.
    //

    pLdap = ldap_init(
                pSidSet->pszUdDcName ? pSidSet->pszUdDcName + 2 : 0,
                LDAP_PORT
                );

    if (pLdap == 0)
    {
        dwError = LdapMapErrorToWin32(LdapGetLastError());
        goto Cleanup;
    }

    if (pSidSet->pszUdDcName)
    {
        dwError = ldap_set_option(
                      pLdap,
                      LDAP_OPT_AREC_EXCLUSIVE,
                      LDAP_OPT_ON
                      );

        if (dwError != LDAP_SUCCESS)
        {
            dwError = LdapMapErrorToWin32(dwError);
            goto Cleanup;
        }
    }


    //
    // Set the sign and seal options to true.
    //

    dwError = ldap_set_option(
                  pLdap,
                  LDAP_OPT_SIGN,
                  LDAP_OPT_ON
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }

    dwError = ldap_set_option(
                  pLdap,
                  LDAP_OPT_ENCRYPT,
                  LDAP_OPT_ON
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }

    dwError = ldap_bind_s(
                  pLdap,
                  0,
                  0,
                  LDAP_AUTH_NEGOTIATE
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }

    dwError = ldap_search_s(
                  pLdap,
                  szSidEdn,
                  LDAP_SCOPE_BASE,
                  L"objectClass=*",
                  ppszAttributes,
                  FALSE,
                  &pResult
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }

    pEntry = ldap_first_entry(
                 pLdap,
                 pResult
                 );

    if (pEntry == 0)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    ppValue = ldap_get_values_len(
                  pLdap,
                  pEntry,
                  ppszAttributes[0]
                  );

    if (ppValue == 0)
    {
        switch (pSidSet->sidUse)
        {
        case SidTypeAlias:
        case SidTypeWellKnownGroup:
        case SidTypeInvalid:
        case SidTypeUnknown:
        case SidTypeGroup:
            break;
        case SidTypeComputer:
        case SidTypeDomain:
        case SidTypeDeletedAccount:
        case SidTypeUser:
        default:
            dwError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }
    }

    dwSidCount = ldap_count_values_len(ppValue);


    //
    // Merge the groups for our user into the result set.
    //

    for (i=0;i < dwSidCount;i++)
    {
        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      (*ppValue[i]).bv_val,
                      (*ppValue[i]).bv_len,
                      SE_GROUP_ENABLED,
                      0,
                      0
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (ppValue)
    {
        ldap_value_free_len(ppValue);
    }

    if (pResult)
    {
        ldap_msgfree(pResult);
    }

    if (pLdap)
    {
        ldap_unbind(pLdap);
    }

    return dwError;
}


DWORD
AuthzpGetAccountDomainGroupsSam(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the domain specified by the SID and
    retrieves the list of groups to which the user belongs.
    This resembles what the NetUserGetGroups API does. We are
    not using it, because the Net APIs are name based and we
    are working with SIDs.

Arguments:

    pusDcName - DC on which the lookup should be performed.

    pSidSet - Returns the number of SIDs in the alias list.

Return Value:

    Win32 error code.

--*/

{
    NTSTATUS                    status;
    DWORD                       dwError             = ERROR_SUCCESS;
    PGROUP_MEMBERSHIP           pGroups             = 0;
    PGROUP_MEMBERSHIP           pGroup;
    DWORD                       dwGroupCount        = 0;
    DWORD                       dwRelativeId        = 0;
    DWORD                       i;
    PSID                        pSid                = 0;
    SAM_HANDLE                  hSam                = 0;
    SAM_HANDLE                  hDomain             = 0;
    SAM_HANDLE                  hUser               = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    UNICODE_STRING              usUdDcName          = {0};


    //
    // If the sid is not a principal,
    // it won't be a member of a SAM group.
    //

    if (pSidSet->sidUse != SidTypeUser &&
        pSidSet->sidUse != SidTypeComputer)
    {
        goto Cleanup;
    }


    //
    // Connect to the SAM server on the DC.
    // If we are on the DC, connect locally.
    //

    if (pSidSet->pszUdDcName)
    {
        RtlInitUnicodeString(
            &usUdDcName,
            pSidSet->pszUdDcName);

        status = SamConnect(
                     &usUdDcName,
                     &hSam,
                     SAM_SERVER_LOOKUP_DOMAIN,
                     &obja
                     );
    }
    else
    {
        status = SamConnect(
                     0,
                     &hSam,
                     SAM_SERVER_LOOKUP_DOMAIN,
                     &obja
                     );
    }

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Open the domain we are interested in.
    //

    status = SamOpenDomain(
                 hSam,
                 DOMAIN_LOOKUP,
                 pSidSet->pDomainSid,
                 &hDomain
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Finally, get a SAM handle to the user.
    //

    dwRelativeId = *RtlSubAuthoritySid(
                        pSidSet->pUserSid,
                        *RtlSubAuthorityCountSid(pSidSet->pUserSid) - 1
                        );

    status = SamOpenUser(
                 hDomain,
                 USER_LIST_GROUPS,
                 dwRelativeId,
                 &hUser
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Request all groups the user is a member of.
    //

    status = SamGetGroupsForUser(
                 hUser,
                 &pGroups,
                 &dwGroupCount
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Stuff the group SIDs into pSidSet.
    //

    pGroup = pGroups;

    for (i=0;i < dwGroupCount;i++,pGroup++)
    {
        status = SamRidToSid(
                     hDomain,
                     pGroup->RelativeId,
                     &pSid
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = RtlNtStatusToDosError(status);
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pSid,
                      0,
                      pGroup->Attributes,
                      0,
                      0
                      );

        SamFreeMemory(pSid);
        pSid = 0;

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pGroups)
    {
        SamFreeMemory(pGroups);
    }

    if (hUser)
    {
        SamCloseHandle(hUser);
    }

    if (hDomain)
    {
        SamCloseHandle(hDomain);
    }

    if (hSam)
    {
        SamCloseHandle(hSam);
    }

    return dwError;
}


DWORD
AuthzpGetResourceDomainGroups(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the primary (resource) domain and
    queries SAM for nested memberships.

Arguments:

    pSidSet - Pointer to set of SIDs. New groups will be added to this set.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           obja                = {0};
    SAM_HANDLE                  hSam                = 0;
    UNICODE_STRING              usRdDcName;


    //
    // Open a SAM handle to the resource domain.
    //

    if (pSidSet->pszRdDcName)
    {
        RtlInitUnicodeString(
            &usRdDcName,
            pSidSet->pszRdDcName);

        status = SamConnect(
                     &usRdDcName,
                     &hSam,
                     SAM_SERVER_LOOKUP_DOMAIN,
                     &obja
                     );
    }
    else
    {
        status = SamConnect(
                     0,
                     &hSam,
                     SAM_SERVER_LOOKUP_DOMAIN,
                     &obja
                     );
    }

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Call AuthzpGetAliasMembership to get nested memberships.
    //

    dwError = AuthzpGetAliasMembership(
                  hSam,
                  pSidSet->pPrimaryInfo->Sid,
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }


    //
    // Retrieve the SID history.
    //

    dwError = AuthzpGetSidHistory(
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (hSam)
    {
        SamCloseHandle(hSam);
    }

    return dwError;
}


DWORD
AuthzpGetLocalGroups(
    IN BOOL bAddPrimaryGroup,
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the domain specified by the caller and
    retrieves the list of groups to which the user belongs. 
    We are checking the account domain and the builtin domain
    using Sam APIs.

Arguments:

    bAddPrimaryGroup - Boolean that indicates wheter the primary group of the
        user should be computed and added to the sid set.

    pSidSet - Pointer to the SID of the user for which group membership array
        will be returned.

Return Value:

    Win32 error.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    NTSTATUS                    status;
    SAM_HANDLE                  hSam                = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    BOOL                        bStatus;
    BYTE                        sid[SECURITY_MAX_SID_SIZE];
    PSID                        pBuiltinSid         = (PSID)sid;
    DWORD                       dwLengthSid         = SECURITY_MAX_SID_SIZE;


    //
    // Open a handle to the SAM on the local computer.
    //

    status = SamConnect(
                 0,
                 &hSam,
                 SAM_SERVER_LOOKUP_DOMAIN,
                 &obja
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Add primary group information if requested.
    //

    if (bAddPrimaryGroup)
    {
        dwError = AuthzpGetPrimaryGroup(
                      hSam,
                      pSidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }


    //
    // Retrieve recursive membership for the account domain.
    //

    dwError = AuthzpGetAliasMembership(
                  hSam,
                  pSidSet->pAccountInfo->DomainSid,
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }


    //
    // Retrieve recursive membership for the BUILTIN domain.
    //

    bStatus = CreateWellKnownSid(
                  WinBuiltinDomainSid,
                  0,
                  pBuiltinSid,
                  &dwLengthSid
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    dwError = AuthzpGetAliasMembership(
                  hSam,
                  pBuiltinSid,
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (hSam)
    {
        SamCloseHandle(hSam);
    }

    return dwError;
}


DWORD
AuthzpGetSidHistory(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine queries ldap for the sidHistory attribute for every SID
    in the set and adds the history SIDs the the set as well.

Arguments:

    pszDomainName - Name of the domain to connect to.

    pSidSet - Pointer to set of SIDs. New groups will be added to this set.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    PLDAP                       pLdap               = 0;
    LDAPMessage*                pResult             = 0;
    LDAPMessage*                pEntry              = 0;
    PLDAP_BERVAL*               ppValue             = 0;
    PWCHAR                      ppszAttributes[]    = {L"sidHistory", 0};
    DWORD                       i, j;
    DWORD                       dwSidCount;
    DWORD                       dwValueCount;
    PSID_DESC                   pSidDesc;
    WCHAR                       szSidEdn[SECURITY_MAX_SID_SIZE * 2 + 8];


    //
    // Open a ldap connection to the primary domain.
    // Get rid of the leading \\ before using the DC name.
    //

    pLdap = ldap_init(
                pSidSet->pszRdDcName ? pSidSet->pszRdDcName + 2 : 0,
                LDAP_PORT
                );

    if (pLdap == 0)
    {
        dwError = LdapMapErrorToWin32(LdapGetLastError());
        goto Cleanup;
    }

    if (pSidSet->pszRdDcName)
    {
        dwError = ldap_set_option(
                      pLdap,
                      LDAP_OPT_AREC_EXCLUSIVE,
                      LDAP_OPT_ON
                      );

        if (dwError != LDAP_SUCCESS)
        {
            dwError = LdapMapErrorToWin32(dwError);
            goto Cleanup;
        }
    }

    //
    // Set the sign and seal options to true.
    //

    dwError = ldap_set_option(
                  pLdap,
                  LDAP_OPT_SIGN,
                  LDAP_OPT_ON
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }

    dwError = ldap_set_option(
                  pLdap,
                  LDAP_OPT_ENCRYPT,
                  LDAP_OPT_ON
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }

    dwError = ldap_bind_s(
                  pLdap,
                  0,
                  0,
                  LDAP_AUTH_NEGOTIATE
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }


    //
    // Loop through all SIDs and retrieve the history attribute
    // for each one of them.
    //

    dwSidCount = pSidSet->dwCount;
    pSidDesc = pSidSet->pSidDesc;

    for (i=0;i < dwSidCount;i++,pSidDesc++)
    {
        AuthzpConvertSidToEdn(
            pSidDesc->sid,
            szSidEdn
            );

        dwError = ldap_search_s(
                      pLdap,
                      szSidEdn,
                      LDAP_SCOPE_BASE,
                      L"objectClass=*",
                      ppszAttributes,
                      FALSE,
                      &pResult
                      );

        if (dwError != LDAP_SUCCESS)
        {
            if (dwError == LDAP_NO_SUCH_OBJECT)
            {
                //
                // The SID was not found, this is not an error.
                //
                dwError = ERROR_SUCCESS;

                if (pResult)
                {
                    ldap_msgfree(pResult);
                    pResult = NULL;
                }

                continue;
            }

            dwError = LdapMapErrorToWin32(dwError);
            goto Cleanup;
        }

        pEntry = ldap_first_entry(
            pLdap,
            pResult);

        if (pEntry == 0)
        {
            dwError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }

        ppValue = ldap_get_values_len(
                      pLdap,
                      pEntry,
                      ppszAttributes[0]
                      );


        //
        // Now we have the history attribute for our group.
        // Merge it into the result set.
        //

        dwValueCount = ldap_count_values_len(ppValue);

        for (j=0;j < dwValueCount;j++)
        {
            dwError = AuthzpAddSidToSidSet(
                          pSidSet,
                          (*ppValue[j]).bv_val,
                          (*ppValue[j]).bv_len,
                          SE_GROUP_MANDATORY
                            | SE_GROUP_ENABLED_BY_DEFAULT
                            | SE_GROUP_ENABLED,
                          0,
                          0
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }

        if (ppValue)
        {
            ldap_value_free_len(ppValue);
            ppValue = 0;
        }

        if (pResult)
        {
            ldap_msgfree(pResult);
            pResult = 0;
        }
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (ppValue)
    {
        ldap_value_free_len(ppValue);
    }

    if (pResult)
    {
        ldap_msgfree(pResult);
    }

    if (pLdap)
    {
        ldap_unbind(pLdap);
    }

    return dwError;
}


DWORD
AuthzpGetAliasMembership(
    IN SAM_HANDLE hSam,
    IN PSID pDomainSid,
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    We try to find nested groups here. This only makes sense on domains
    in native mode.
    This routine calls SamGetAliasMembership iteratively until no
    more nested groups are returned.

Arguments:

    hSam - Handle to the SAM database.

    pDomainSid - SID of the domain to operate on.

    ppSidSet - Set of SIDs that are checked for membership. Newly
        found group SIDs are added to the set.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    NTSTATUS                    status;
    PSID                        pSid                = 0;
    SAM_HANDLE                  hDomain             = 0;
    DWORD                       dwSidCount;
    DWORD                       dwSidCountNew;
    DWORD                       dwSidListSize;
    DWORD                       i;
    BOOL                        bAdded;
    PSID*                       ppSidList           = 0;
    PDWORD                      pRidList            = 0;
    PDWORD                      pRid;


    //
    // Get a SAM handle to the domain.
    //

    status = SamOpenDomain(
                 hSam,
                 DOMAIN_GET_ALIAS_MEMBERSHIP,
                 pDomainSid,
                 &hDomain
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Retrieve the memberships iteratively.
    //

    dwSidCount = pSidSet->dwCount;
    dwSidListSize = dwSidCount;

    ppSidList = (PSID*)AuthzpAlloc(
                    dwSidCount * sizeof(PSID)
                    );

    if (ppSidList == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    for (i=0;i < dwSidCount;i++)
    {
        ppSidList[i] = pSidSet->pSidDesc[i].sid;
    }

    do
    {
        status = SamGetAliasMembership(
                     hDomain,
                     dwSidCount,
                     ppSidList,
                     &dwSidCountNew,
                     &pRidList
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = RtlNtStatusToDosError(status);
            goto Cleanup;
        }

        if (dwSidCountNew > dwSidListSize)
        {
            AuthzpFree(ppSidList);

            ppSidList = (PSID*)AuthzpAlloc(
                            dwSidCountNew * sizeof(PSID)
                            );

            if (ppSidList == 0)
            {
                dwError = GetLastError();
                goto Cleanup;
            }

            dwSidListSize = dwSidCountNew;
        }

        dwSidCount = 0;
        pRid = pRidList;

        for (i=0;i < dwSidCountNew;i++,pRid++)
        {
            status = SamRidToSid(
                         hDomain,
                         *pRid,
                         &pSid
                         );

            if (!NT_SUCCESS(status))
            {
                dwError = RtlNtStatusToDosError(status);
                goto Cleanup;
            }

            dwError = AuthzpAddSidToSidSet(
                          pSidSet,
                          pSid,
                          0,
                          SE_GROUP_MANDATORY
                            | SE_GROUP_ENABLED_BY_DEFAULT
                            | SE_GROUP_ENABLED,
                          &bAdded,
                          ppSidList + dwSidCount
                          );

            SamFreeMemory(pSid);
            pSid = 0;

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }

            if (bAdded)
            {
                dwSidCount++;
            }
        }

        if (pRidList)
        {
            SamFreeMemory(pRidList);
            pRidList = 0;
        }
    }
    while (dwSidCount);

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pRidList)
    {
        SamFreeMemory(pRidList);
    }

    if (ppSidList)
    {
        AuthzpFree(ppSidList);
    }

    if (hDomain)
    {
        SamCloseHandle(hDomain);
    }

    return dwError;
}


DWORD
AuthzpGetPrimaryGroup(
    IN SAM_HANDLE hSam,
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    Add the primary group of the user to the sid set.

Arguments:

    hSam - Handle to the SAM database.

    pSidSet - Add the sid of the primary group to this set.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    NTSTATUS                    status;
    SAM_HANDLE                  hDomain             = 0;
    SAM_HANDLE                  hUser               = 0;
    PUSER_PRIMARY_GROUP_INFORMATION
                                pInfo               = 0;
    PSID                        pPrimaryGroupSid    = NULL;
    DWORD                       dwRelativeId        = 0;


    //
    // Open the account domain.
    //

    status = SamOpenDomain(
                 hSam,
                 DOMAIN_LOOKUP,
                 pSidSet->pDomainSid,
                 &hDomain
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Extract the rid from the user sid.
    //

    dwRelativeId = *RtlSubAuthoritySid(
                        pSidSet->pUserSid,
                        *RtlSubAuthorityCountSid(pSidSet->pUserSid) - 1
                        );


    //
    // Open the user for read.
    //

    status = SamOpenUser(
                 hDomain,
                 USER_READ_GENERAL,
                 dwRelativeId,
                 &hUser
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Get the primary group information for the user.
    //

    status = SamQueryInformationUser(
                 hUser,
                 UserPrimaryGroupInformation,
                 &pInfo
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Convert the group rid to a sid.
    //

    status = SamRidToSid(
                 hDomain,
                 pInfo->PrimaryGroupId,
                 &pPrimaryGroupSid
                 );

    SamFreeMemory(pInfo);

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Add the group sid to the set.
    //

    dwError = AuthzpAddSidToSidSet(
                  pSidSet,
                  pPrimaryGroupSid,
                  0,
                  SE_GROUP_ENABLED,
                  0,
                  0
                  );

    SamFreeMemory(pPrimaryGroupSid);

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (hUser)
    {
        SamCloseHandle(hUser);
    }

    if (hDomain)
    {
        SamCloseHandle(hDomain);
    }

    return dwError;
}


DWORD
AuthzpInitializeSidSetByName(
    IN PUNICODE_STRING pusUserName,
    IN PUNICODE_STRING pusDomainName,
    IN DWORD dwFlags,
    IN PSID_SET pSidSet
    )

/*++

Routine description:

    Initializes a sid set and reserves memory for the
    max amount of memory it will ever need.
    The memory is not allocated yet. This only happens as SIDs get
    added to the set. All members are initialized to meaningful values.

Arguments:

    pSidSet - The sid set to operate on.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    SYSTEM_INFO                 sysInfo;

    if (s_dwPageSize == 0)
    {
        GetSystemInfo(&sysInfo);

        s_dwPageSize = sysInfo.dwPageSize;
    }

    pSidSet->pSidDesc = (PSID_DESC)VirtualAlloc(
                            0,
                            c_dwMaxSidCount * sizeof(SID_DESC),
                            MEM_RESERVE,
                            PAGE_NOACCESS
                            );

    if (pSidSet->pSidDesc == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pSidSet->dwCount = 0;
    pSidSet->dwMaxCount = 0;

    pSidSet->dwBaseCount = 0;
    pSidSet->dwFlags = dwFlags;

    pSidSet->pUserSid = 0;
    pSidSet->pDomainSid = 0;
    pSidSet->pusUserName = pusUserName;


    //
    // Verify for once we got a valid domain.
    // Otherwise we assume we got a UPN in pusUserName.
    //

    if (pusDomainName &&
        pusDomainName->Length &&
        pusDomainName->Buffer)
    {
        pSidSet->pusDomainName = pusDomainName;
    }
    else
    {
        pSidSet->pusDomainName = 0;
    }

    pSidSet->pNames = 0;
    pSidSet->pDomains = 0;
    pSidSet->pDomainsName = 0;
    pSidSet->pSids = 0;
    pSidSet->sidUse = SidTypeUnknown;

    pSidSet->pAccountInfo = 0;
    pSidSet->pPrimaryInfo = 0;
    pSidSet->pPrimaryInfoName = 0;
    pSidSet->bStandalone = TRUE;
    pSidSet->bSkipNonLocal = FALSE;

    pSidSet->pUdDcInfo = 0;
    pSidSet->pPdDcInfo = 0;
    pSidSet->pRdDcInfo = 0;

    pSidSet->pUdBasicInfo = 0;
    pSidSet->pPdBasicInfo = 0;
    pSidSet->pRdBasicInfo = 0;

    pSidSet->pszUdDcName = 0;
    pSidSet->pszRdDcName = 0;

    dwError = ERROR_SUCCESS;

Cleanup:

    return dwError;
}


DWORD
AuthzpInitializeSidSetBySid(
    IN PSID pUserSid,
    IN DWORD dwFlags,
    IN PSID_SET pSidSet
    )

/*++

Routine description:

    Initializes a sid set and reserves memory for the
    max amount of memory it will ever need.
    The memory is not allocated yet. This only happens as SIDs get
    added to the set. All members are initialized to meaningful values.

Arguments:

    pSidSet - The sid set to operate on.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    SYSTEM_INFO                 sysInfo;

    if (s_dwPageSize == 0)
    {
        GetSystemInfo(&sysInfo);

        s_dwPageSize = sysInfo.dwPageSize;
    }

    if (!RtlValidSid(pUserSid))
    {
        dwError = ERROR_INVALID_SID;
        goto Cleanup;
    }

    pSidSet->pSidDesc = (PSID_DESC)VirtualAlloc(
                            0,
                            c_dwMaxSidCount * sizeof(SID_DESC),
                            MEM_RESERVE,
                            PAGE_NOACCESS
                            );

    if (pSidSet->pSidDesc == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pSidSet->dwCount = 0;
    pSidSet->dwMaxCount = 0;

    pSidSet->dwBaseCount = 0;
    pSidSet->dwFlags = dwFlags;

    pSidSet->pUserSid = pUserSid;
    pSidSet->pDomainSid = 0;
    pSidSet->pusUserName = 0;
    pSidSet->pusDomainName = 0;

    pSidSet->pNames = 0;
    pSidSet->pDomains = 0;
    pSidSet->pDomainsName = 0;
    pSidSet->pSids = 0;
    pSidSet->sidUse = SidTypeUnknown;

    pSidSet->pAccountInfo = 0;
    pSidSet->pPrimaryInfo = 0;
    pSidSet->pPrimaryInfoName = 0;
    pSidSet->bStandalone = TRUE;
    pSidSet->bSkipNonLocal = FALSE;

    pSidSet->pUdDcInfo = 0;
    pSidSet->pPdDcInfo = 0;
    pSidSet->pRdDcInfo = 0;

    pSidSet->pUdBasicInfo = 0;
    pSidSet->pPdBasicInfo = 0;
    pSidSet->pRdBasicInfo = 0;

    pSidSet->pszUdDcName = 0;
    pSidSet->pszRdDcName = 0;

    dwError = ERROR_SUCCESS;

Cleanup:

    return dwError;
}


DWORD
AuthzpDeleteSidSet(
    IN PSID_SET pSidSet
    )

/*++

Routine description:

    Deletes all memory allocated to the sid set
    structure and resets all members to zero.

Arguments:

    pSidSet - The sid set to operate on.

Return Value:

    Win32 error code.

--*/

{
    if (pSidSet->pSidDesc)
    {
        VirtualFree(pSidSet->pSidDesc, 0, MEM_RELEASE);
    }

    if (pSidSet->pNames)
    {
        LsaFreeMemory(pSidSet->pNames);
    }

    if (pSidSet->pDomains)
    {
        LsaFreeMemory(pSidSet->pDomains);
    }

    if (pSidSet->pDomainsName)
    {
        AuthzpFree(pSidSet->pDomainsName);
    }

    if (pSidSet->pSids)
    {
        LsaFreeMemory(pSidSet->pSids);
    }

    if (pSidSet->pAccountInfo)
    {
        LsaFreeMemory(pSidSet->pAccountInfo);
    }

    if (pSidSet->pPrimaryInfo)
    {
        LsaFreeMemory(pSidSet->pPrimaryInfo);
    }

    if (pSidSet->pPrimaryInfoName)
    {
        AuthzpFree(pSidSet->pPrimaryInfoName);
    }

    if (pSidSet->pUdDcInfo)
    {
        NetApiBufferFree(pSidSet->pUdDcInfo);
    }

    if (pSidSet->pPdDcInfo)
    {
        NetApiBufferFree(pSidSet->pPdDcInfo);
    }

    if (pSidSet->pUdBasicInfo)
    {
        DsRoleFreeMemory(pSidSet->pUdBasicInfo);
    }

    if (pSidSet->pPdBasicInfo)
    {
        DsRoleFreeMemory(pSidSet->pPdBasicInfo);
    }

    RtlZeroMemory(
        pSidSet,
        sizeof(SID_SET));

    return ERROR_SUCCESS;
}


DWORD
AuthzpAddSidToSidSet(
    IN PSID_SET pSidSet,
    IN PSID pSid,
    IN DWORD dwSidLength OPTIONAL,
    IN DWORD dwAttributes,
    OUT PBOOL pbAdded OPTIONAL,
    OUT PSID* ppSid OPTIONAL
    )

/*++

Routine description:

    Check if the given SID already exists in the set. If yes, return.
    Otherwise, add it to the set.

Arguments:

    pSidSet - The sid set to operate on.

    pSid - The SID to add to the set.

    dwSidLength - Length of the SID in bytes. If zero is passed in,
        the routine calculates the length itself.

    dwAttributes - Attributes of the SID like in the
        SID_AND_ATTRIBUTES structure.

    pbAdded - Optional pointer that receives indication if the SID
        was indeed added or not (because it was a duplicate).

    ppSid - Optional pointer to where the new sid is stored.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    DWORD                       i;
    DWORD                       dwSize;
    BOOL                        bAdded              = FALSE;
    PSID_DESC                   pSidDesc;

    if (dwSidLength == 0)
    {
        dwSidLength = RtlLengthSid(pSid);
    }

    pSidDesc = pSidSet->pSidDesc;

    for (i=0;i < pSidSet->dwCount;i++,pSidDesc++)
    {
        if (dwSidLength == pSidDesc->dwLength)
        {
            if (RtlEqualSid(
                    pSid,
                    pSidDesc->sid))
            {
                goto Cleanup;
            }
        }
    }

    if (pSidSet->dwCount >= pSidSet->dwMaxCount)
    {
        if (pSidSet->dwCount >= c_dwMaxSidCount)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        //
        // Commit one more page in the buffer.
        //

        dwSize = (pSidSet->dwCount + 1) * sizeof(SID_DESC);
        dwSize += s_dwPageSize - 1;
        dwSize &= ~(s_dwPageSize - 1);

        pSidDesc = (PSID_DESC)VirtualAlloc(
                       pSidSet->pSidDesc,
                       dwSize,
                       MEM_COMMIT,
                       PAGE_READWRITE
                       );

        if (pSidDesc != pSidSet->pSidDesc)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        pSidSet->dwMaxCount = dwSize / sizeof(SID_DESC);
    }

    pSidDesc = pSidSet->pSidDesc + pSidSet->dwCount;

    pSidDesc->dwAttributes = dwAttributes;
    pSidDesc->dwLength = dwSidLength;

    RtlCopyMemory(
        pSidDesc->sid,
        pSid,
        dwSidLength
        );

    bAdded = TRUE;

    pSidSet->dwCount++;

    if (ppSid)
    {
        *ppSid = pSidDesc->sid;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pbAdded)
    {
        *pbAdded = bAdded;
    }

    return dwError;
}


DWORD
AuthzpGetUserDomainSid(
    PSID_SET pSidSet
    )
{
    DWORD                       dwError;
    NTSTATUS                    status;
    LSA_HANDLE                  hPolicy             = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    SECURITY_QUALITY_OF_SERVICE sqos;
    WCHAR                       wc[2]               = L"\\";
    UNICODE_STRING              usName              = {0};
    PUNICODE_STRING             pusName             = 0;


    //
    // Build the string domain - name string that should be
    // translated.
    //

    if (pSidSet->pusDomainName)
    {
        usName.MaximumLength = 
                            pSidSet->pusDomainName->Length +
                            sizeof(WCHAR) +
                            pSidSet->pusUserName->Length +
                            sizeof(WCHAR);

        usName.Buffer = (PWSTR)LocalAlloc(
                            LMEM_FIXED,
                            usName.MaximumLength
                            );

        if (usName.Buffer == 0)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        RtlCopyMemory(
            usName.Buffer,
            pSidSet->pusDomainName->Buffer,
            pSidSet->pusDomainName->Length
            );

        usName.Length = (USHORT)(usName.Length + pSidSet->pusDomainName->Length);

        RtlCopyMemory(
            ((PBYTE)usName.Buffer) + usName.Length,
            wc + 0,
            sizeof(WCHAR)
            );

        usName.Length += sizeof(WCHAR);

        RtlCopyMemory(
            ((PBYTE)usName.Buffer) + usName.Length,
            pSidSet->pusUserName->Buffer,
            pSidSet->pusUserName->Length
            );

        usName.Length = (USHORT)(usName.Length + pSidSet->pusUserName->Length);

        RtlCopyMemory(
            ((PBYTE)usName.Buffer) + usName.Length,
            wc + 1,
            sizeof(WCHAR)
            );

        pusName = &usName;
    }
    else
    {
        //
        // Assume we got a UPN.
        //

        pusName = pSidSet->pusUserName;
    }

    //
    // set up the object attributes prior to opening the LSA
    //

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    obja.SecurityQualityOfService = &sqos;


    //
    // open the LSA policy
    //

    status = LsaOpenPolicy(
                 0,
                 &obja,
                 POLICY_LOOKUP_NAMES,
                 &hPolicy
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    status = LsaLookupNames2(
                 hPolicy,
                 0,          // no flags
                 1,
                 pusName,
                 &pSidSet->pDomains,
                 &pSidSet->pSids
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    if (pSidSet->pSids == 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch (pSidSet->pSids->Use)
    {
    case SidTypeDomain:
    case SidTypeInvalid:
    case SidTypeUnknown:
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // The name was successfully translated.
    // There should be exactly one domain and its index should be zero.
    //

    ASSERT(pSidSet->pDomains->Entries == 1);
    ASSERT(pSidSet->pDomains->Domains != 0);
    ASSERT(pSidSet->pSids->DomainIndex == 0);

    pSidSet->pUserSid = pSidSet->pSids->Sid;
    pSidSet->pDomainSid = pSidSet->pDomains->Domains->Sid;
    pSidSet->sidUse = pSidSet->pSids->Use;

    pSidSet->pDomainsName = (PWSTR) AuthzpAlloc(pSidSet->pDomains->Domains->Name.Length + sizeof(WCHAR));

    if (pSidSet->pDomainsName == NULL) 
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;

    }

    wcsncpy(pSidSet->pDomainsName, pSidSet->pDomains->Domains->Name.Buffer, pSidSet->pDomains->Domains->Name.Length/sizeof(WCHAR)); 
    pSidSet->pDomainsName[pSidSet->pDomains->Domains->Name.Length/sizeof(WCHAR)] = L'\0';

    dwError = ERROR_SUCCESS;

Cleanup:

    if (hPolicy)
    {
        LsaClose(hPolicy);
    }

    if (usName.Buffer)
    {
        AuthzpFree((HLOCAL)usName.Buffer);
    }

    return dwError;
}


DWORD
AuthzpGetUserDomainName(
    PSID_SET pSidSet
    )
{
    DWORD                       dwError;
    NTSTATUS                    status;
    LSA_HANDLE                  hPolicy             = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    SECURITY_QUALITY_OF_SERVICE sqos;


    //
    // set up the object attributes prior to opening the LSA
    //

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    obja.SecurityQualityOfService = &sqos;


    //
    // open the LSA policy
    //

    status = LsaOpenPolicy(
                 0,
                 &obja,
                 POLICY_LOOKUP_NAMES,
                 &hPolicy
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    status = LsaLookupSids(
                 hPolicy,
                 1,
                 &pSidSet->pUserSid,
                 &pSidSet->pDomains,
                 &pSidSet->pNames
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    if (pSidSet->pNames == 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch (pSidSet->pNames->Use)
    {
    case SidTypeDomain:
    case SidTypeUnknown:
    case SidTypeInvalid:
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // The SID was successfully translated.
    // There should be exactly one domain and its index should be zero.
    //

    ASSERT(pSidSet->pDomains->Entries == 1);
    ASSERT(pSidSet->pDomains->Domains != 0);
    ASSERT(pSidSet->pNames->DomainIndex == 0);

    pSidSet->pDomainSid = pSidSet->pDomains->Domains->Sid;
    pSidSet->pusUserName = &pSidSet->pNames->Name;
    pSidSet->pusDomainName = &pSidSet->pDomains->Domains->Name;
    pSidSet->sidUse = pSidSet->pNames->Use;

    dwError = ERROR_SUCCESS;

Cleanup:

    if (hPolicy)
    {
        LsaClose(hPolicy);
    }

    return dwError;
}


DWORD
AuthzpGetLocalInfo(
    IN PSID_SET pSidSet
    )
{
    DWORD                       dwError;
    NTSTATUS                    status;
    LSA_HANDLE                  hPolicy             = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    SECURITY_QUALITY_OF_SERVICE sqos;
    NT_PRODUCT_TYPE             ProductType;
    PPOLICY_LSA_SERVER_ROLE_INFO    pRole           = 0;


    //
    // Set up the object attributes prior to opening the LSA.
    //

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    obja.SecurityQualityOfService = &sqos;


    //
    // open LSA policy
    //

    status = LsaOpenPolicy(
                 0,
                 &obja,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 &hPolicy
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    status = LsaQueryInformationPolicy(
                 hPolicy,
                 PolicyAccountDomainInformation,
                 (PVOID*)&pSidSet->pAccountInfo
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    status = LsaQueryInformationPolicy(
                 hPolicy,
                 PolicyPrimaryDomainInformation,
                 (PVOID*)&pSidSet->pPrimaryInfo
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }


    pSidSet->pPrimaryInfoName = (PWSTR) AuthzpAlloc(pSidSet->pPrimaryInfo->Name.Length + sizeof(WCHAR));

    if (pSidSet->pPrimaryInfoName == NULL) 
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;

    }

    wcsncpy(pSidSet->pPrimaryInfoName, pSidSet->pPrimaryInfo->Name.Buffer, pSidSet->pPrimaryInfo->Name.Length/sizeof(WCHAR)); 
    pSidSet->pPrimaryInfoName[pSidSet->pPrimaryInfo->Name.Length/sizeof(WCHAR)] = L'\0';

    //
    // Determine the role of the machine.
    //

    if (RtlGetNtProductType(&ProductType) == FALSE)
    {
        dwError = ERROR_GEN_FAILURE;
        goto Cleanup;
    }

    switch (ProductType)
    {
    case NtProductWinNt:
    case NtProductServer:
        pSidSet->bStandalone = pSidSet->pPrimaryInfo->Sid == 0 ? TRUE : FALSE;
        break;
    
    case NtProductLanManNt:
        status = LsaQueryInformationPolicy(
                     hPolicy,
                     PolicyLsaServerRoleInformation,
                     (PVOID*)&pRole
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = LsaNtStatusToWinError(status);
            goto Cleanup;
        }

        pSidSet->bStandalone = FALSE;

        if (pRole->LsaServerRole == PolicyServerRolePrimary)
        {
            //
            // If we think we're a primary domain controller, we'll need to
            // guard against the case where we're actually standalone
            // during setup
            //

            if (pSidSet->pPrimaryInfo->Sid == 0 ||
                pSidSet->pAccountInfo->DomainSid == 0 ||
                !RtlEqualSid(
                    pSidSet->pPrimaryInfo->Sid,
                    pSidSet->pAccountInfo->DomainSid))
            {
                pSidSet->bStandalone = TRUE;
            }
        }
        break;

    default:
        dwError = ERROR_GEN_FAILURE;
        goto Cleanup;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pRole)
    {
        LsaFreeMemory(pRole);
    }

    if (hPolicy)
    {
        LsaClose(hPolicy);
    }

    return dwError;
}


DWORD
AuthzpGetDcName(
    IN LPCTSTR pszDomain,
    IN OUT PDOMAIN_CONTROLLER_INFO* ppDcInfo
    )
{
    DWORD                       dwError;


    //
    // First try to get a DC with DS running.
    //

    dwError = DsGetDcName(
                  0,
                  pszDomain,
                  0,
                  0,
                  DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                  ppDcInfo
                  );

    if (dwError == ERROR_NO_SUCH_DOMAIN)
    {
        //
        // Try again with no flags set, because this is the only way
        // an NT4 domain will reveal its secrets.
        //

        dwError = DsGetDcName(
                      0,
                      pszDomain,
                      0,
                      0,
                      0,
                      ppDcInfo
                      );
    }

    return dwError;
}


VOID
AuthzpConvertSidToEdn(
    IN PSID pSid,
    OUT PWSTR pszSidEdn
    )

/*++

    Print pSid into pszSidEdn as an Extended Distinguished Name.

    pszSidEdn should provide room for at least
    SECURITY_MAX_SID_SIZE * 2 + 8 WCHARs.

--*/

{
    DWORD                       dwLength            = RtlLengthSid(pSid);
    DWORD                       i;
    PBYTE                       pbSid               = (PBYTE)pSid;
    PWCHAR                      pChar               = pszSidEdn;
    static WCHAR                szHex[]             = L"0123456789ABCDEF";

    *pChar++ = L'<';
    *pChar++ = L'S';
    *pChar++ = L'I';
    *pChar++ = L'D';
    *pChar++ = L'=';
    
    for (i=0;i < dwLength;i++,pbSid++)
    {
        *pChar++ = szHex[*pbSid >> 4];
        *pChar++ = szHex[*pbSid & 0x0F];
    }

    *pChar++ = L'>';
    *pChar = L'\0';
}


BOOL
AuthzpAllocateAndInitializeClientContext(
    OUT PAUTHZI_CLIENT_CONTEXT *ppCC,
    IN PAUTHZI_CLIENT_CONTEXT Server,
    IN DWORD Revision,
    IN LUID Identifier,
    IN LARGE_INTEGER ExpirationTime,
    IN DWORD Flags,
    IN DWORD SidCount,
    IN DWORD SidLength,
    IN PSID_AND_ATTRIBUTES Sids,
    IN DWORD RestrictedSidCount,
    IN DWORD RestrictedSidLength,
    IN PSID_AND_ATTRIBUTES RestrictedSids,
    IN DWORD PrivilegeCount,
    IN DWORD PrivilegeLength,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN LUID AuthenticationId,
    IN PAUTHZI_HANDLE AuthzHandleHead,
    IN PAUTHZI_RESOURCE_MANAGER pRM
)

/*++

Routine description:

    This routine initializes fields in a client context. It is called by all the
    AuthzInitializClientContextFrom* routines.

Arguments:

    ppCC - Returns the newly allocated and initialized client context structure.

    Rest of the parameters are copied into the client context. For explanation
    of these, see the definition of AUTHZI_CLIENT_CONTEXT.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_CLIENT_CONTEXT pCC = (PAUTHZI_CLIENT_CONTEXT) AuthzpAlloc(sizeof(AUTHZI_CLIENT_CONTEXT));

    if (AUTHZ_ALLOCATION_FAILED(pCC))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    *ppCC = pCC;

    RtlZeroMemory(
        pCC,
        sizeof(AUTHZ_CLIENT_CONTEXT_HANDLE)
        );

    pCC->AuthenticationId = AuthenticationId;
    pCC->AuthzHandleHead = AuthzHandleHead;
    pCC->ExpirationTime = ExpirationTime;
    pCC->Flags = Flags;
    pCC->Identifier = Identifier;
    pCC->pResourceManager = pRM;
    pCC->PrivilegeCount = PrivilegeCount;
    pCC->PrivilegeLength = PrivilegeLength;
    pCC->Privileges = Privileges;
    pCC->RestrictedSidCount = RestrictedSidCount;
    pCC->RestrictedSidLength = RestrictedSidLength;
    pCC->RestrictedSids = RestrictedSids;
    pCC->Revision = Revision;
    pCC->Server = Server;
    pCC->SidCount = SidCount;
    pCC->SidLength = SidLength;
    pCC->Sids = Sids;

    return TRUE;
}


BOOL
AuthzpAddDynamicSidsToToken(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_RESOURCE_MANAGER pRM,
    IN PVOID DynamicGroupArgs,
    IN PSID_AND_ATTRIBUTES Sids,
    IN DWORD SidLength,
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES RestrictedSids,
    IN DWORD RestrictedSidLength,
    IN DWORD RestrictedSidCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN DWORD PrivilegeLength,
    IN DWORD PrivilegeCount,
    IN BOOL bAllocated
)

/*++

Routine description:

    This routine computes resource manager specific groups and add them to the
    client context. This is a worker routine for all AuthzInitializeFrom*
    routines.

Arguments:

    pCC - Pointer to the client context structure for which the three fields
        will be set - sids, restricted sids, privileges.

    pRM - Pointer to the resource manager structure, supplies the callback
        function to be used.

    DynamicGroupArgs - Caller supplied argument pointer to be passed as an input
        to the callback function that'd compute dynamic groups

    Sids - The sid and atttribute array for the normal part of the client
        context.

    SidLength - Size of the buffer required to hold this array.

    SidCount - Number of sids in the array.

    RestrictedSids - The sid and atttribute array for the normal part of the
        client context.

    RestrictedSidLength - Size of the buffer required to hold this array.

    RestrictedSidCount - Number of restricted sids in the array.

    Privileges - The privilege and attribute array.

    PrivilegeLength - Size required to hold this array.

    PrivilegeCount - The number of privileges in the array.

    bAllocated - To specify whether the Sids and RestrictedSids pointers in
        client context have been allocated separately.

    When the client context has been created thru a token, the two pointers
    point somewhere into a buffer and a new buffer has to be allocated to store
    these.

    When the client context has been created thru a sid, the buffer is a valid
    allocated one. If no dynamic groups need to be added then we do not have to
    do anything int this case.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL                         b                        = TRUE;
    PSID_AND_ATTRIBUTES          pRMSids                  = NULL;
    PSID_AND_ATTRIBUTES          pRMRestrictedSids        = NULL;
    PSID_AND_ATTRIBUTES          pLocalSids               = NULL;
    PSID_AND_ATTRIBUTES          pLocalRestrictedSids     = NULL;
    PLUID_AND_ATTRIBUTES         pLocalPrivileges         = NULL;
    DWORD                        RMSidCount               = 0;
    DWORD                        RMRestrictedSidCount     = 0;
    DWORD                        LocalSidLength           = 0;
    DWORD                        LocalRestrictedSidLength = 0;
    DWORD                        i                        = 0;

    //
    // Compute dynamic groups.
    //

    if (AUTHZ_NON_NULL_PTR(pRM->pfnComputeDynamicGroups))
    {
        b = pRM->pfnComputeDynamicGroups(
                     (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                     DynamicGroupArgs,
                     &pRMSids,
                     &RMSidCount,
                     &pRMRestrictedSids,
                     &RMRestrictedSidCount
                     );

        if (!b) goto Cleanup;
    }

    //
    // Copy the existing sids as well as the dynamic ones into a new buffer if
    // needed.
    //

    if ((0 != RMSidCount) || !bAllocated)
    {
        LocalSidLength = SidLength + RMSidCount * sizeof(SID_AND_ATTRIBUTES);

        for (i = 0; i < RMSidCount; i++)
        {
            LocalSidLength += RtlLengthSid(pRMSids[i].Sid);
        }

        pLocalSids = (PSID_AND_ATTRIBUTES) AuthzpAlloc(LocalSidLength);

        if (AUTHZ_ALLOCATION_FAILED(pLocalSids))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        pCC->SidCount = RMSidCount + SidCount;
        pCC->Sids = pLocalSids;

        b = AuthzpCopySidsAndAttributes(
                pLocalSids,
                Sids,
                SidCount,
                pRMSids,
                RMSidCount
                );

        if (!b)
        {
            goto Cleanup;
        }

        if (!FLAG_ON(pCC->Sids[0].Attributes, SE_GROUP_USE_FOR_DENY_ONLY))
        {
            pCC->Sids[0].Attributes |= SE_GROUP_ENABLED;
        }

        pCC->SidLength = LocalSidLength;
    }

    if ((0 != RMRestrictedSidCount) || !bAllocated)
    {
        LocalRestrictedSidLength = RestrictedSidLength + RMRestrictedSidCount * sizeof(SID_AND_ATTRIBUTES);

        for (i = 0; i < RMRestrictedSidCount; i++)
        {
            LocalRestrictedSidLength += RtlLengthSid(pRMRestrictedSids[i].Sid);
        }

        if (LocalRestrictedSidLength > 0)
        {
            pLocalRestrictedSids = (PSID_AND_ATTRIBUTES) AuthzpAlloc(LocalRestrictedSidLength);

            if (AUTHZ_ALLOCATION_FAILED(pLocalRestrictedSids))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                b = FALSE;
                goto Cleanup;
            }
        }

        pCC->RestrictedSidCount = RMRestrictedSidCount + RestrictedSidCount;
        pCC->RestrictedSids = pLocalRestrictedSids;

        b = AuthzpCopySidsAndAttributes(
                pLocalRestrictedSids,
                RestrictedSids,
                RestrictedSidCount,
                pRMRestrictedSids,
                RMRestrictedSidCount
                );

        if (!b) goto Cleanup;

        pCC->RestrictedSidLength = LocalRestrictedSidLength;
    }

    //
    // Privileges need to copied only in the case of initilize from token.
    //

    if (PrivilegeLength > 0)
    {
        pLocalPrivileges = (PLUID_AND_ATTRIBUTES) AuthzpAlloc(PrivilegeLength);

        if (AUTHZ_ALLOCATION_FAILED(pLocalPrivileges))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        pCC->PrivilegeCount = PrivilegeCount;
        pCC->Privileges = pLocalPrivileges;

        AuthzpCopyLuidAndAttributes(
            pCC,
            Privileges,
            PrivilegeCount,
            pLocalPrivileges
            );
    }
    else
    {
        pCC->Privileges = NULL;
    }

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pLocalSids);
        AuthzpFreeNonNull(pLocalRestrictedSids);
        AuthzpFreeNonNull(pLocalPrivileges);
    }

    if (AUTHZ_NON_NULL_PTR(pRMSids))
    {
        pRM->pfnFreeDynamicGroups(pRMSids);
    }

    if (AUTHZ_NON_NULL_PTR(pRMRestrictedSids))
    {
        pRM->pfnFreeDynamicGroups(pRMSids);
    }

    return b;
}



BOOL
AuthzpComputeSkipFlagsForWellKnownSid(
    IN PSID UserSid,
    OUT PDWORD Flags
    )

/*++

Routine description:

    This routine computes skip flags if the User sid is a wellknown sid.

Arguments:

    UserSid - User sid for which SKIP flag will be computed.

    Flags - to return the SKIP flags.

    A value of AUTHZ_SKIP_TOKEN_GROUPS is returned for well-known and builtin
    sid. A value of 0 is returned in failure cases as well as other cases.

Return Value:
   
    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{

    DWORD  dwErr             = ERROR_SUCCESS;
    BOOL   b                 = TRUE;
    LPWSTR Name              = NULL;
    LPWSTR RefDomainName     = NULL;
    DWORD  NameSize          = 0;
    DWORD  RefDomainNameSize = 0;
    SID_NAME_USE SidNameUse  = SidTypeUnknown;

    *Flags = 0;

    //
    // Dummy call to get the size of the buffer.
    //

    b = LookupAccountSidW(
            NULL,
            UserSid,
            NULL,
            &NameSize,
            NULL,
            &RefDomainNameSize,
            &SidNameUse
            );

    if (FALSE == b)
    {
        dwErr = GetLastError();

        //
        // Return if we failed because of any error other than insufficient 
        // buffer.
        //

        if(dwErr != ERROR_INSUFFICIENT_BUFFER)
        {
            return FALSE;
        }

        //
        // LookupAccountSid returns the size in TCHARS.
        //

        NameSize *= sizeof(WCHAR);
        RefDomainNameSize *= sizeof(WCHAR);

        //
        // Allocate memory required to hold the names.
        //

        Name = (LPWSTR) AuthzpAlloc(NameSize);

        if (AUTHZ_ALLOCATION_FAILED(Name))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        RefDomainName = (LPWSTR) AuthzpAlloc(RefDomainNameSize);

        if (AUTHZ_ALLOCATION_FAILED(RefDomainName))
        {
            AuthzpFree(Name);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        //
        // Do the real lookup.
        //

        b = LookupAccountSidW(
                NULL,
                UserSid,
                Name,
                &NameSize,
                RefDomainName,
                &RefDomainNameSize,
                &SidNameUse
                );

        AuthzpFree(Name);
        AuthzpFree(RefDomainName);

        if (FALSE == b)
        {
            return FALSE;
        }

        //
        // Add the SKIP flag for the cases required.
        //

        switch (SidNameUse)
        {
        case SidTypeAlias:
        case SidTypeWellKnownGroup:
        case SidTypeInvalid:
        case SidTypeUnknown:
        case SidTypeGroup:
            *Flags = AUTHZ_SKIP_TOKEN_GROUPS;
            return TRUE;
        case SidTypeComputer:
        case SidTypeDomain:
        case SidTypeDeletedAccount:
        case SidTypeUser:
        default:
            return TRUE;
        }
    }

    //
    // Should not get here.
    //

    ASSERT(FALSE);
    return TRUE;
}

DWORD
AuthzpIsDC(
    OUT PBOOL pbIsDC
    )

/*++

Routine description:

    This routine decides whether a trip to the AD is required to fetch
    TokenGroups attribute. 

Arguments:

    pbIsDC - Returns whether or not this is a DC.

Return Value:

    Returns ERROR_SUCCESS on success, appropriate failure value otherwise.
    
--*/

{
    static BOOL bFirstTime = TRUE;
    static BOOL bIsDC      = FALSE;

    DWORD                             dwErr      = ERROR_SUCCESS;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC BasicInfo  = NULL;

    if (bFirstTime)
    {
        //
        // Get the information about the local machine.
        //

        dwErr = DsRoleGetPrimaryDomainInformation(
                    NULL,
                    DsRolePrimaryDomainInfoBasic,
                    & (PBYTE) BasicInfo
                    );

        if (ERROR_SUCCESS != dwErr)
        {
            return dwErr;
        }

        //
        // If the local machine is a DC then TokenGroups should be computed anyway.
        //

        switch(BasicInfo->MachineRole)
        {
        case DsRole_RolePrimaryDomainController:
        case DsRole_RoleBackupDomainController:

            bIsDC = TRUE;

            break;

        default:
            break;
        }

        DsRoleFreeMemory(BasicInfo);
        bFirstTime = FALSE;
    }

    *pbIsDC = bIsDC;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\authzp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    authzp.c

Abstract:

   This module implements the internal worker routines for access check and
   audit APIs.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/

#include "pch.h"

#pragma hdrstop

#include <authzp.h>
#include <ntrmlsa.h>

DWORD AuthzpPrincipalSelfSidBuffer[] = {0x101, 0x5000000, 0xA};
PSID pAuthzPrincipalSelfSid          = (PSID) AuthzpPrincipalSelfSidBuffer;
USHORT AuthzpPrincipalSelfSidLen     = sizeof(AuthzpPrincipalSelfSidBuffer);

DWORD AuthzpCreatorOwnerSidBuffer[] = {0x101, 0x3000000, 0x0};
PSID pAuthzCreatorOwnerSid          = (PSID) AuthzpCreatorOwnerSidBuffer;

DWORD AuthzpEveryoneSidBuffer[] = {0x101, 0x1000000, 0x0};
PSID pAuthzEveryoneSid          = (PSID) AuthzpEveryoneSidBuffer;
USHORT AuthzpEveryoneSidLen     = sizeof(AuthzpEveryoneSidBuffer);

DWORD AuthzpAnonymousSidBuffer[] = {0x101, 0x5000000, 0x7};
PSID pAuthzAnonymousSid          = (PSID) AuthzpAnonymousSidBuffer;
USHORT AuthzpAnonymousSidLen     = sizeof(AuthzpAnonymousSidBuffer);

//
// This is used to get the index of the first '1' bit in a given byte.
//     a[0] = 9     // This is a dummy.
//     a[1] = 0
//     a[2] = 1
//     a[3] = 0
//     ...
//     a[i] = first '1' bit from LSB
//

UCHAR AuthzpByteToIndexLookupTable[] = {
    9,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
};

#ifndef AUTHZ_DEBUG_MEMLEAK

#define AuthzpAlloc(s) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (s))
#define AuthzpFree(p) LocalFree((p))

#else

//
// This is to be used for debugging memory leaks. Primitive method but works in
// a small project like this.
//


PVOID
AuthzpAlloc(IN DWORD Size)
{

    PVOID l = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Size);

    wprintf(L"Allocated %d at %x\n", Size, l);

    return l;
}


VOID
AuthzpFree(PVOID l)
{
    LocalFree(l);
    wprintf(L"Freeing %x\n", l);
}

#endif


BOOL
AuthzpVerifyAccessCheckArguments(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults OPTIONAL
    )

/*++

Routine description:

    This routine validates inputs for the access check call. It also initializes
    input parameters to default.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - Supplies a pointer to a reply structure used to return the results.

    phAccessCheckResults - Supplies a pointer to return a handle to the cached results
        of access check.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    if (ARGUMENT_PRESENT(phAccessCheckResults))
    {
        *phAccessCheckResults = NULL;
    }

    if (!ARGUMENT_PRESENT(pCC))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
   
    if (!ARGUMENT_PRESENT(pSecurityDescriptor))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

#ifdef DBG
    if (!RtlValidSecurityDescriptor(pSecurityDescriptor))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
#endif

    if (!ARGUMENT_PRESENT(RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((0 != OptionalSecurityDescriptorCount) && (!ARGUMENT_PRESENT(OptionalSecurityDescriptorArray)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // The caller can specify one of the two values for Reply->ResultListLength
    //     a. 1 - representing the whole object.
    //     b. pRequest->ObjectTypeListLength - for every node in the type list.
    //

    if ((1 != pReply->ResultListLength) &&
        (pReply->ResultListLength != pRequest->ObjectTypeListLength))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}


BOOL
AuthzpVerifyOpenObjectArguments(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent
    )

/*++

Routine description:

    This routine validates inputs for AuthzOpenObjectAuditAlarm.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - Supplies a pointer to a reply structure containing the results of 
        an AuthzAccessCheck.

    pAuditEvent - pointer to AUTHZ_AUDIT_EVENT.
    
Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    if (!ARGUMENT_PRESENT(pCC))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(pAuditEvent))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(pSecurityDescriptor))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

#if DBG
    if (!RtlValidSecurityDescriptor(pSecurityDescriptor))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
#endif

    if (!ARGUMENT_PRESENT(RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((0 != OptionalSecurityDescriptorCount) && (!ARGUMENT_PRESENT(OptionalSecurityDescriptorArray)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}


BOOL
AuthzpCaptureObjectTypeList(
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL
    )

/*++

Routine description:

    This routine captures an object type list into internal structres.

Arguments:

    ObjectTypeList - Object type list to capture.

    ObjectTypeListLength - Length of the object type list.

    LocalTypeList - To return the internal representation of the
    input list. Memory is allocated by the caller.

    LocalCachingTypeList - To return internal representation of the
    input list This list will be used to hold static always-granted access bits.
    Memory is allocated by the caller.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD              i                    = 0;
    BOOL               b                    = TRUE;

    DWORD Levels[ACCESS_MAX_LEVEL + 1];

    if ((0 == ObjectTypeListLength) || (!ARGUMENT_PRESENT(ObjectTypeList)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for (i = 0; i < ObjectTypeListLength; i++)
    {
        USHORT CurrentLevel;

        CurrentLevel = ObjectTypeList[i].Level;

        if (CurrentLevel > ACCESS_MAX_LEVEL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }

        //
        // Copy data the caller passed in.
        //

        LocalTypeList[i].Level = CurrentLevel;
        LocalTypeList[i].Flags = 0;
        LocalTypeList[i].ObjectType = *ObjectTypeList[i].ObjectType;
        LocalTypeList[i].Remaining = 0;
        LocalTypeList[i].CurrentGranted = 0;
        LocalTypeList[i].CurrentDenied = 0;

        //
        // Ensure that the level number is consistent with the
        // level number of the previous entry.
        //

        if (0 == i)
        {
            if (0 != CurrentLevel)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                b = FALSE;
                goto Cleanup;
            }
        }
        else
        {
            //
            // The previous entry is either:
            //  my immediate parent,
            //  my sibling, or
            //  the child (or grandchild, etc.) of my sibling.
            //

            if ( CurrentLevel > LocalTypeList[i-1].Level + 1 )
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                b = FALSE;
                goto Cleanup;
            }

            //
            // Don't support two roots.
            //

            if (0 == CurrentLevel)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                b = FALSE;
                goto Cleanup;
            }
        }

        //
        // If the above rules are maintained,
        //  then my parent object is the last object seen that
        //  has a level one less than mine.
        //

        if (0 == CurrentLevel)
        {
            LocalTypeList[i].ParentIndex = -1;
        }
        else
        {
            LocalTypeList[i].ParentIndex = Levels[CurrentLevel-1];
        }

        //
        // Save this obect as the last object seen at this level.
        //

        Levels[CurrentLevel] = i;
    }

    //
    // If the caller has requested caching then create a copy of the object type
    // list that we just captured.
    //

    if (ARGUMENT_PRESENT(LocalCachingTypeList))
    {
        memcpy(
            LocalCachingTypeList,
            LocalTypeList,
            (ObjectTypeListLength * sizeof(IOBJECT_TYPE_LIST))
            );
    }

    return TRUE;

Cleanup:

    return FALSE;
}


VOID
AuthzpFillReplyStructure(
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN DWORD Error,
    IN ACCESS_MASK GrantedAccess
    )

/*++

Routine description:

    This routine fills the reply structure with supplied parameters.

Arguments:

    pReply - The reply structure to fill.

    Error - The same error value is filled in all the elements of the array.

    GrantedAccess - Access granted to the entire object.

Return Value:

    None.

--*/

{
    DWORD i = 0;

    for (i = 0; i < pReply->ResultListLength; i++)
    {
        pReply->GrantedAccessMask[i] = GrantedAccess;
        pReply->Error[i] = Error;
    }
}


BOOL
AuthzpMaximumAllowedAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    OUT PDWORD pCachingFlags
    )

/*++

Routine description:

    This routine does a maximum allowed access check on multiple security
        descriptors. In case of restricted tokens, access granted is a bitwise
        AND of granted access by the normal as well as the restricted parts of
        the client context.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

    pCachingFlags - To return the flags that will be stored in the caching
        handle if the caller requested caching.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL b = TRUE;

    //
    // Do the access check with the non-restricted part of the client context.
    //

    b = AuthzpMaximumAllowedMultipleSDAccessCheck(
            pCC,
            pRequest,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            LocalTypeList,
            LocalCachingTypeList,
            LocalTypeListLength,
            ObjectTypeListPresent,
            FALSE,  // Non-restricted access check
            pCachingFlags
            );

#ifdef AUTHZ_DEBUG
    wprintf(L"AuthzpMaximumAllowedAccessCheck: GrantedAccess = %x\n",
            LocalTypeList->CurrentGranted);
#endif

    if (!b)
    {
        return FALSE;
    }

    //
    // Do the access check with the restricted part of the client context if
    // it exists.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {
        b = AuthzpMaximumAllowedMultipleSDAccessCheck(
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                LocalTypeList,
                LocalCachingTypeList,
                LocalTypeListLength,
                ObjectTypeListPresent,
                TRUE, // Restricted access check
                pCachingFlags
                );

#ifdef AUTHZ_DEBUG
    wprintf(L"AuthzpMaximumAllowedAccessCheck: RestrictedGrantedAccess = %x\n",
            LocalTypeList->CurrentGranted);
#endif

    }

    return b;
}


BOOL
AuthzpMaximumAllowedMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    IN BOOL Restricted,
    OUT PDWORD pCachingFlags
    )

/*++

Routine description:

    This routine performs access check for all security descriptors provided.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

    Restricted - Whether the restricted part of the client context should be
        used for access check.

    pCachingFlags - To return the flags that will be stored in the caching
        handle if the caller requested caching.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                  i               = 0;
    DWORD                  j               = 0;
    DWORD                  SidCount        = 0;
    BOOL                   b               = TRUE;
    PSID_AND_ATTRIBUTES    pSidAttr        = NULL;
    PACL                   pAcl            = NULL;
    PSID                   pOwnerSid       = NULL;
    PAUTHZI_SID_HASH_ENTRY pSidHash        = NULL;

    pOwnerSid = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    if (Restricted)
    {
        //
        // For restricted client context, granted access is a bitwise AND of
        // granted access from both parts of the context.
        //

        if (ARGUMENT_PRESENT(LocalCachingTypeList))
        {
            for (j = 0; j < LocalTypeListLength; j++)
            {
                LocalTypeList[j].Remaining = LocalTypeList[j].CurrentGranted;
                LocalTypeList[j].CurrentGranted = 0;

                LocalCachingTypeList[j].Remaining = LocalCachingTypeList[j].CurrentGranted;
                LocalCachingTypeList[j].CurrentGranted = 0;
            }
        }
        else
        {
            for (j = 0; j < LocalTypeListLength; j++)
            {
                LocalTypeList[j].Remaining = LocalTypeList[j].CurrentGranted;
                LocalTypeList[j].CurrentGranted = 0;
            }
        }

        pSidAttr = pCC->RestrictedSids;
        SidCount = pCC->RestrictedSidCount;
        pSidHash = pCC->RestrictedSidHash;
    }
    else
    {
        pSidAttr = pCC->Sids;
        SidCount = pCC->SidCount;
        pSidHash = pCC->SidHash;
    }

    pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    b = AuthzpMaximumAllowedSingleAclAccessCheck(
            pCC,
            pSidAttr,
            SidCount,
            pSidHash,
            pRequest,
            pAcl,
            pOwnerSid,
            LocalTypeList,
            LocalCachingTypeList,
            LocalTypeListLength,
            ObjectTypeListPresent,
            pCachingFlags
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        if (!AUTHZ_NON_NULL_PTR(pAcl))
        {
            continue;
        }

        b = AuthzpMaximumAllowedSingleAclAccessCheck(
                pCC,
                pSidAttr,
                SidCount,
                pSidHash,
                pRequest,
                pAcl,
                pOwnerSid,
                LocalTypeList,
                LocalCachingTypeList,
                LocalTypeListLength,
                ObjectTypeListPresent,
                pCachingFlags
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}


BOOL
AuthzpIsAccessMaskApplicable(
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength,
    IN DWORD StartIndex,
    IN ACCESS_MASK AceMask
    )

/*++

Routine Description:

    This routine checks if a given access mask might have any effect on the 
    object type list if the ace were applicable.
    
Arguments:

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

    StartIndex - Index to the root element where the ace might be applicable.

    AceMask - Access mask in the ace.

Return Value:

    Boolean: TRUE if the ace will change the Allowed/Denied structure of the
             tree if it were applicable. False otherwise.
    
--*/

{
    DWORD Index = 0;
                                        
    ACCESS_MASK GrantedOrDeniedMask = LocalTypeList[StartIndex].CurrentDenied |
                                      LocalTypeList[StartIndex].CurrentGranted;

    //
    // If the ace mask has bits that have not already been allowed/denied at the
    // root of the tree then return TRUE. This quick check will save us the 
    // tree traversal in most cases.
    //

    if (0 != (AceMask & ~GrantedOrDeniedMask))
    {
        return TRUE;
    }

    //
    // Loop handling all children of the target.
    //

    for (Index = StartIndex + 1; Index < LocalTypeListLength; Index++)
    {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if (LocalTypeList[Index].Level <= LocalTypeList[StartIndex].Level)
        {
            break;
        }

        GrantedOrDeniedMask &= (LocalTypeList[Index].CurrentDenied |
                                LocalTypeList[Index].CurrentGranted);
    }

    //
    // If the ace mask has bits that have not already been allowed/denied at the
    // some node in the subtree stating at the specified index then return TRUE.
    //

    if (0 != (AceMask & ~GrantedOrDeniedMask))
    {
        return TRUE;
    }

    return FALSE;
}


BOOL
AuthzpMaximumAllowedSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    OUT PDWORD pCachingFlags
    )

/*++

Routine description:

    This routine

Arguments:
    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes to be used for matching the one in the aces.

    SidCount - Number of sids in the pSidAttr array

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Discretionary acl against which access check will be performed.
        It is assumed that the acl is non-null.

    pOwnerSid - To support the future DS requirement of not mapping Creator
        Owner at the time of object creation.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

    Restricted - Whether the restricted part of the client context should be
        used for access check.

    pCachingFlags - To return the flags that will be stored in the caching
        handle if the caller requested caching.

Algorithm:

    BEGIN_MAX_ALGO

    for all aces
      skip INHERIT_ONLY aces

      ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

        If (the sid is applicable) AND (Server Sid is also applicable)
          Update the entire tree starting at the root.
          Grant those bits that have not already been denied.

        Note: No one uses these!!

      ACCESS_ALLOWED_ACE_TYPE

        If the sid is applicable
          Update the entire tree starting at the root.
          Grant those bits that have not already been denied.

      ACCESS_ALLOWED_CALLBACK_ACE_TYPE

        If (the sid is applicable) AND (callback call evaluates ace applicable)
          Update the entire tree starting at the root.
          Grant those bits that have not already been denied.

      ACCESS_ALLOWED_OBJECT_ACE_TYPE

        If the sid is applicable
          get the ObjectType guid from the ace

          if the guid is NULL
            Update the entire tree starting at the root.
            Grant those bits that have not already been denied.
          else
            If (object type list exists) AND (contains a matching guid)
              Update the tree starting at the MATCH.
              Grant those bits that have not already been denied.

      ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE

        If (the sid is applicable) AND (callback call evaluates ace applicable)
          get the ObjectType guid from the ace

          if the guid is NULL
            Update the entire tree starting at the root.
            Grant those bits that have not already been denied.
          else
            If (object type list exists) AND (contains a matching guid)
              Update the tree starting at the MATCH.
              Grant those bits that have not already been denied.

      ACCESS_DENIED_ACE_TYPE

        If the sid is applicable
          Update the entire tree starting at the root.
          Deny those bits that have not already been granted.
          Propagate the deny all the way up to the root.

      ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE

        If (the sid is applicable) AND (callback call evaluates ace applicable)
          Update the entire tree starting at the root.
          Deny those bits that have not already been granted.
          Propagate the deny all the way up to the root.

      ACCESS_DENIED_OBJECT_ACE_TYPE

        If the sid is applicable
          get the ObjectType guid from the ace

          if the guid is NULL
            Update the entire tree starting at the root.
            Deny those bits that have not already been granted.
            Propagate the deny all the way up to the root.
          else
            If (object type list exists) AND (contains a matching guid)
              Update the tree starting at the MATCH.
              Deny those bits that have not already been granted.
              Propagate the deny all the way up to the root.

      ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE

        If (the sid is applicable) AND (callback call evaluates ace applicable)
          get the ObjectType guid from the ace

          if the guid is NULL
            Update the entire tree starting at the root.
            Deny those bits that have not already been granted.
            Propagate the deny all the way up to the root.
          else
            If (object type list exists) AND (contains a matching guid)
              Update the tree starting at the MATCH.
              Deny those bits that have not already been granted.
              Propagate the deny all the way up to the root.

Note:

    LocalCachingFlags is used to return whether the ace is contains principal
    self sid.

    We take a pessimistic view for dynamic aces. There are two types of
    dynamic aces:
        1. Call back aces
        2. Normal aces with principal self sid in it.

    For any dynamic ace,
        Grant aces are never applicable to the caching list.
        Deny aces are always applicable to the caching list.


Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD     AceCount          = 0;
    DWORD     i                 = 0;
    DWORD     Index             = 0;
    PVOID     Ace               = NULL;
    GUID    * ObjectTypeInAce   = NULL;
    BOOL      bAceApplicable    = FALSE;
    BOOL      bCallbackMayApply = FALSE;
    DWORD     LocalCachingFlags = 0;
    
    AceCount = pAcl->AceCount;

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {

        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }
        
        LocalCachingFlags = 0;

        switch (((PACE_HEADER) Ace)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //
                                               
            bAceApplicable = AuthzpSidApplicable(
                                 SidCount,
                                 pSidAttr,
                                 pSidHash,
                                 AuthzAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FALSE,
                                 &LocalCachingFlags
                                 );

            //
            // Record the caching flags for this ace into the global flags.
            //

            *pCachingFlags |= LocalCachingFlags;

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);

                //
                // A grant ace is considered static only if PrincipalSelf sid
                // is not found in the ace.
                //

                if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                {
                    LocalCachingTypeList->CurrentGranted |= (((PKNOWN_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentDenied);
                }
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );

                //
                // A grant ace is considered static only if PrincipalSelf sid
                // is not found in the ace.
                //

                if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                {
                    AuthzpAddAccessTypeList(
                        LocalCachingTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 SidCount,
                                 pSidAttr,
                                 pSidHash,
                                 AuthzCallbackAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FALSE,
                                 &LocalCachingFlags
                                 );


            //
            // Record the presence of a dynamic grant ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT);

            if (!bAceApplicable)
            {
                break;
            }

            if (1 == LocalTypeListLength)
            {
                //
                // If the all the bits from this ace have already been granted
                // or denied, then there is no need to evaluate this callback ace.
                //

                if (0 == ((((PKNOWN_ACE) Ace)->Mask) &
                          ~(LocalTypeList->CurrentGranted | LocalTypeList->CurrentDenied)))
                {
                    break;
                }
            }
            else
            {
                //
                // We have an object type list. Compute whether we need to break
                // out early.
                // 

                bCallbackMayApply = AuthzpIsAccessMaskApplicable(
                                        LocalTypeList,
                                        LocalTypeListLength,
                                        0,
                                        ((PKNOWN_ACE) Ace)->Mask
                                        );

                if (!bCallbackMayApply)
                {
                    break;
                }

            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );
            }

            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            if ( ObjectTypeInAce && ( pRequest->ObjectTypeListLength == 0 ))
            {
                break;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 SidCount,
                                 pSidAttr,
                                 pSidHash,
                                 AuthzObjectAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FALSE,
                                 &LocalCachingFlags
                                 );

            //
            // Record the the caching flags for this ace into the global flags.
            //

            *pCachingFlags |= LocalCachingFlags;

            if (!bAceApplicable)
            {
                break;
            }

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (NULL == ObjectTypeInAce)
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);

                    //
                    // A grant ace is considered static only if PrincipalSelf sid
                    // is not found in the ace.
                    //

                    if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                    {
                        LocalCachingTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentDenied);
                    }
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );

                    //
                    // A grant ace is considered static only if PrincipalSelf sid
                    // is not found in the ace.
                    //

                    if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                    {
                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            0,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentGranted
                            );
                    }
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );

                    //
                    // A grant ace is considered static only if PrincipalSelf sid
                    // is not found in the ace.
                    //

                    if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                    {
                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            Index,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentGranted
                            );
                    }
                }
            }

           break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 SidCount,
                                 pSidAttr,
                                 pSidHash,
                                 AuthzCallbackObjectAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FALSE,
                                 &LocalCachingFlags
                                 );

            //
            // Record the presence of a dynamic grant ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT);

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                if (1 == LocalTypeListLength)
                {
                    //
                    // If the all the bits from this ace have already been granted
                    // or denied, then there is no need to evaluate this callback ace.
                    //

                    if (0 == ((((PKNOWN_ACE) Ace)->Mask) &
                              ~(LocalTypeList->CurrentGranted | LocalTypeList->CurrentDenied)))
                    {
                        break;
                    }
                }
                else
                {
                    //
                    // We have an object type list. Compute whether we need to break
                    // out early.
                    // 

                    bCallbackMayApply = AuthzpIsAccessMaskApplicable(
                                            LocalTypeList,
                                            LocalTypeListLength,
                                            0,
                                            ((PKNOWN_ACE) Ace)->Mask
                                            );

                    if (!bCallbackMayApply)
                    {
                        break;
                    }
                }

                bAceApplicable = FALSE;

                //
                // Make a call to the resource manager to get his opinion. His
                // evaluation is returned in bAceApplicalble.
                //
                // Note: The return value of the callback is used to decide whether
                // the API failed/succeeded. On a failure, we exit out of access
                // check. On success, we check the boolean returned by
                // bAceApplicable to decide whether to use the current ace.
                //

                if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                           (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                           Ace,
                           pRequest->OptionalArguments,
                           &bAceApplicable
                           )))
                {
                    return FALSE;
                }

                if (!bAceApplicable)
                {
                    break;
                }

                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // We have an object type list. Compute whether we need to break
                    // out early.
                    // 

                    bCallbackMayApply = AuthzpIsAccessMaskApplicable(
                                            LocalTypeList,
                                            LocalTypeListLength,
                                            Index,
                                            ((PKNOWN_ACE) Ace)->Mask
                                            );

                    if (!bCallbackMayApply)
                    {
                        break;
                    }

                    //
                    // Make a call to the resource manager to get his opinion. His
                    // evaluation is returned in bAceApplicalble.
                    //
                    // Note: The return value of the callback is used to decide whether
                    // the API failed/succeeded. On a failure, we exit out of access
                    // check. On success, we check the boolean returned by
                    // bAceApplicable to decide whether to use the current ace.
                    //

                    if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                               (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                               Ace,
                               pRequest->OptionalArguments,
                               &bAceApplicable
                               )))
                    {
                        return FALSE;
                    }

                    if (!bAceApplicable)
                    {
                        break;
                    }

                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );

                }
            }

           break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (!AUTHZ_NON_NULL_PTR(pCC->Server))
            {
                break;
            }

            LocalCachingFlags = 0;

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 SidCount,
                                 pSidAttr,
                                 pSidHash,
                                 RtlCompoundAceClientSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FALSE,
                                 &LocalCachingFlags
                                 );

            //
            // Record the caching flags for this ace into the global flags.
            //

            *pCachingFlags |= LocalCachingFlags;

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = AuthzpSidApplicable(
                                 pCC->Server->SidCount,
                                 pCC->Server->Sids,
                                 pCC->Server->SidHash,
                                 RtlCompoundAceServerSid(Ace),
                                 NULL,
                                 NULL,
                                 FALSE,
                                 NULL
                                 );

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);

                //
                // A grant ace is considered static only if PrincipalSelf sid
                // is not found in the ace.
                //

                if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                {
                    LocalCachingTypeList->CurrentGranted |= (((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentDenied);
                }
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );

                //
                // A grant ace is considered static only if PrincipalSelf sid
                // is not found in the ace.
                //

                if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                {
                    AuthzpAddAccessTypeList(
                        LocalCachingTypeList,
                        LocalTypeListLength,
                        0,
                        ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            break;

        case ACCESS_DENIED_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 SidCount,
                                 pSidAttr,
                                 pSidHash,
                                 AuthzAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 TRUE,
                                 &LocalCachingFlags
                                 );

            //
            // Record the presence of a Deny ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DENY_ACE_PRESENT);

            //
            // If the ace is applicable or principal self sid is present then
            // deny the access bits to the cached access check results. We
            // take a pessimistic view and assume that the principal self sid
            // will be applicable in the next access check.
            //

            if ((bAceApplicable || (0 != LocalCachingFlags)) &&
                (ARGUMENT_PRESENT(LocalCachingTypeList)))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Deny access bits that have not already been granted.
                    //

                    LocalCachingTypeList->CurrentDenied |= (((PKNOWN_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentGranted);
                }
                else
                {
                    //
                    // Propagate deny bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalCachingTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Deny access bits that have not already been granted.
                //

                LocalTypeList->CurrentDenied |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentGranted);
            }
            else
            {
                //
                // Propagate deny bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentDenied
                    );
            }

            break;

        case ACCESS_DENIED_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 SidCount,
                                 pSidAttr,
                                 pSidHash,
                                 AuthzCallbackAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 TRUE,
                                 &LocalCachingFlags
                                 );

            //
            // Record the presence of a dynamic Deny ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DYNAMIC_DENY_ACE_PRESENT);

            //
            // If the ace is applicable or principal self sid is present then
            // deny the access bits to the cached access check results. We
            // take a pessimistic view and assume that the principal self sid
            // will be applicable in the next access check.
            //

            if ((bAceApplicable || (0 != LocalCachingFlags)) &&
                (ARGUMENT_PRESENT(LocalCachingTypeList)))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Deny access bits that have not already been granted.
                    //

                    LocalCachingTypeList->CurrentDenied |= (((PKNOWN_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentGranted);
                }
                else
                {
                    //
                    // Propagate deny bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalCachingTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            if (!bAceApplicable)
            {
                break;
            }

            if (1 == LocalTypeListLength)
            {
                //
                // If the all the bits from this ace have already been granted
                // or denied, then there is no need to evaluate this callback ace.
                //

                if (0 == ((((PKNOWN_ACE) Ace)->Mask) &
                          ~(LocalTypeList->CurrentGranted | LocalTypeList->CurrentDenied)))
                {
                    break;
                }
            }
            else
            {
                //
                // We have an object type list. Compute whether we need to break
                // out early.
                // 

                bCallbackMayApply = AuthzpIsAccessMaskApplicable(
                                        LocalTypeList,
                                        LocalTypeListLength,
                                        0,
                                        ((PKNOWN_ACE) Ace)->Mask
                                        );

                if (!bCallbackMayApply)
                {
                    break;
                }

            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }


            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Deny access bits that have not already been granted.
                //

                LocalTypeList->CurrentDenied |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentGranted);
            }
            else
            {
                //
                // Propagate deny bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentDenied
                    );
            }

            break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 SidCount,
                                 pSidAttr,
                                 pSidHash,
                                 AuthzObjectAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 TRUE,
                                 &LocalCachingFlags
                                 );

            //
            // Record the presence of a Deny ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DENY_ACE_PRESENT);

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // If the ace is applicable or principal self sid is present then
            // deny the access bits to the cached access check results. We
            // take a pessimistic view and assume that the principal self sid
            // will be applicable in the next access check.
            //

            if ((bAceApplicable || (0 != LocalCachingFlags)) &&
                (ARGUMENT_PRESENT(LocalCachingTypeList)))
            {
                //
                // An object type ace with a NULL Object Type guid is the same
                // as a normal ace.
                //

                if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
                {
                    //
                    // Optimize the common case instead of calling a subroutine.
                    //

                    if (1 == LocalTypeListLength)
                    {
                        //
                        // Deny access bits that have not already been granted.
                        //

                        LocalCachingTypeList->CurrentDenied |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentGranted);
                    }
                    else
                    {
                        //
                        // Propagate deny bits down the tree starting at the root.
                        //

                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            0,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentDenied
                            );
                    }
                }

                //
                // So, it is a true object type ace. Proceed only if we are doing
                // access check on a object type list.
                //

                else if (ObjectTypeListPresent)
                {
                    //
                    // Look for a matching object type guid that matches the one in
                    // the ace.
                    //

                    if (AuthzpObjectInTypeList(
                                 ObjectTypeInAce,
                                 LocalTypeList,
                                 LocalTypeListLength,
                                 &Index
                                 )
                             )
                    {
                        //
                        // Propagate deny bits down the tree starting at the
                        // index at which the guids matched. Deny bits are
                        // propagated to all the ancestors as well.
                        //

                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            Index,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentDenied
                            );
                    }
                }
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Deny access bits that have not already been granted.
                    //

                    LocalTypeList->CurrentDenied |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentGranted);
                }
                else
                {                    
                    //
                    // Propagate deny bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                             ObjectTypeInAce,
                             LocalTypeList,
                             LocalTypeListLength,
                             &Index
                             )
                         )
                {
                    //
                    // Propagate deny bits down the tree starting at the
                    // index at which the guids matched. Deny bits are
                    // propagated to all the ancestors as well.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            break;

        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 SidCount,
                                 pSidAttr,
                                 pSidHash,
                                 AuthzObjectAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 TRUE,
                                 &LocalCachingFlags
                                 );

            //
            // Record the presence of a dynamic Deny ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DYNAMIC_DENY_ACE_PRESENT);

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // If the ace is applicable or principal self sid is present then
            // deny the access bits to the cached access check results. We
            // take a pessimistic view and assume that the principal self sid
            // will be applicable in the next access check.
            //

            if ((bAceApplicable || (0 != LocalCachingFlags)) &&
                (ARGUMENT_PRESENT(LocalCachingTypeList)))
            {
                //
                // An object type ace with a NULL Object Type guid is the same
                // as a normal ace.
                //

                if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
                {
                    //
                    // Optimize the common case instead of calling a subroutine.
                    //

                    if (1 == LocalTypeListLength)
                    {
                        //
                        // Deny access bits that have not already been granted.
                        //

                        LocalCachingTypeList->CurrentDenied |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentGranted);
                    }
                    else
                    {
                        //
                        // Propagate deny bits down the tree starting at the root.
                        //

                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            0,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentDenied
                            );
                    }
                }

                //
                // So, it is a true object type ace. Proceed only if we are doing
                // access check on a object type list.
                //

                else if (ObjectTypeListPresent)
                {
                    //
                    // Look for a matching object type guid that matches the one in
                    // the ace.
                    //

                    if (AuthzpObjectInTypeList(
                                 ObjectTypeInAce,
                                 LocalTypeList,
                                 LocalTypeListLength,
                                 &Index
                                 )
                             )
                    {
                        //
                        // Propagate deny bits down the tree starting at the
                        // index at which the guids matched. Deny bits are
                        // propagated to all the ancestors as well.
                        //

                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            Index,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentDenied
                            );
                    }
                }
            }

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                if (1 == LocalTypeListLength)
                {
                    //
                    // If the all the bits from this ace have already been granted
                    // or denied, then there is no need to evaluate this callback ace.
                    //

                    if (0 == ((((PKNOWN_ACE) Ace)->Mask) &
                              ~(LocalTypeList->CurrentGranted | LocalTypeList->CurrentDenied)))
                    {
                        break;
                    }
                }
                else
                {
                    //
                    // We have an object type list. Compute whether we need to break
                    // out early.
                    // 

                    bCallbackMayApply = AuthzpIsAccessMaskApplicable(
                                            LocalTypeList,
                                            LocalTypeListLength,
                                            0,
                                            ((PKNOWN_ACE) Ace)->Mask
                                            );

                    if (!bCallbackMayApply)
                    {
                        break;
                    }
                }

                //
                // Make a call to the resource manager to get his opinion. His
                // evaluation is returned in bAceApplicalble.
                //
                // Note: The return value of the callback is used to decide whether
                // the API failed/succeeded. On a failure, we exit out of access
                // check. On success, we check the boolean returned by
                // bAceApplicable to decide whether to use the current ace.
                //

                if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                           (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                           Ace,
                           pRequest->OptionalArguments,
                           &bAceApplicable
                           )))
                {
                    return FALSE;
                }

                if (!bAceApplicable)
                {
                    break;
                }

                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Deny access bits that have not already been granted.
                    //

                    LocalTypeList->CurrentDenied |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentGranted);
                }
                else
                {
                    //
                    // Propagate deny bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                             ObjectTypeInAce,
                             LocalTypeList,
                             LocalTypeListLength,
                             &Index
                             )
                         )
                {
                    //
                    // We have an object type list. Compute whether we need to break
                    // out early.
                    // 

                    bCallbackMayApply = AuthzpIsAccessMaskApplicable(
                                            LocalTypeList,
                                            LocalTypeListLength,
                                            Index,
                                            ((PKNOWN_ACE) Ace)->Mask
                                            );

                    if (!bCallbackMayApply)
                    {
                        break;
                    }

                    //
                    // Make a call to the resource manager to get his opinion. His
                    // evaluation is returned in bAceApplicalble.
                    //
                    // Note: The return value of the callback is used to decide whether
                    // the API failed/succeeded. On a failure, we exit out of access
                    // check. On success, we check the boolean returned by
                    // bAceApplicable to decide whether to use the current ace.
                    //

                    if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                               (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                               Ace,
                               pRequest->OptionalArguments,
                               &bAceApplicable
                               )))
                    {
                        return FALSE;
                    }

                    if (!bAceApplicable)
                    {
                        break;
                    }

                    //
                    // Propagate deny bits down the tree starting at the
                    // index at which the guids matched. Deny bits are
                    // propagated to all the ancestors as well.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            break;

        default:
            break;
        }
    }

    return TRUE;
}

#if 0

BOOL
AuthzpSidApplicableOrig(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PSID pAceSid,
    IN PSID PrincipalSelfSid,
    IN PSID CreatorOwnerSid,
    IN BOOL DenyAce,
    OUT PDWORD pCachingFlags
    )

/*++

Routine description:

    This routine decides whether the ace is applicable to the client context.

Arguments:

    SidCount - Number of sids in the pSidAttrArray

    pSidAttr - Sid and attributes against which the ace sid should be compared.

    pAceSid - Sid in the ace.

    PrincipalSelfSid - To replace the ace sid if the ace sid is
        Principal Self Sid (S-1-5-A).

    CreatorOwnerSid - To replace the ace sid if the ace sid is Creator Owner
        sid (S-1-3-0). This will not be used in the current implementation but
        will come in effect once we do single instancing.

    DenyAce - Boolean specifying whether the ace is a deny ace.

    pCachingFlags - To return caching information in the form of:
        AUTHZ_PRINCIPAL_SELF_ACE_PRESENT
        AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT
        AUTHZ_DYNAMIC_DENY_ACE_PRESENT

Return Value:

    A value of TRUE is returned if the effective sid is found in the client
    context and (is enabled OR enabled for deny only for deny aces).
    FALSE otherwise.

--*/

{
    DWORD i        = 0;
    PISID MatchSid = NULL;
    PSID  pSid     = pAceSid;
    DWORD SidLen   = RtlLengthSid(pAceSid);

    UNREFERENCED_PARAMETER(CreatorOwnerSid);

    //
    // If the principal ace sid is principal self sid and Principal self sid
    // has been provided then use it.
    //

    if (AUTHZ_EQUAL_SID(pSid, pAuthzPrincipalSelfSid, SidLen))
    {
        //
        // Record the presence of a principal self sid in this ace.
        //

        *pCachingFlags |= AUTHZ_PRINCIPAL_SELF_ACE_PRESENT;

        if (ARGUMENT_PRESENT(PrincipalSelfSid))
        {
            pSid = PrincipalSelfSid;
            SidLen = RtlLengthSid(pSid);
        }
        else
        {
            return FALSE;
        }
    }

#ifdef AUTHZ_SINGLE_INSTANCE

    //
    // Single instance security descriptor code
    //

    else if (ARGUMENT_PRESENT(CreatorOwnerSid) && AUTHZ_EQUAL_SID(pSid, pAuthzCreatorOwnerSid, SidLen))
    {
        pSid = CreatorOwnerSid;
        SidLen   = RtlLengthSid(pSid);
    }

#endif

    //
    // Loop thru the sids to find a match.
    //

    for (i = 0; i < SidCount; i++, pSidAttr++)
    {
        MatchSid = (PISID) pSidAttr->Sid;

        if (AUTHZ_EQUAL_SID(pSid, MatchSid, SidLen))
        {
            //
            // Return TRUE if
            //    a. the sid is enabled OR
            //    b the sid is enabled for deny only and the ace is a Deny ace.
            // Else
            //    return FALSE.
            //

            if (FLAG_ON(pSidAttr->Attributes, SE_GROUP_ENABLED) ||
                (DenyAce && FLAG_ON(pSidAttr->Attributes, SE_GROUP_USE_FOR_DENY_ONLY))
                )
            {

#ifdef AUTHZ_DEBUG
                wprintf(L"Applicable sid = %x, %x, %x, %x, %x, %x, %x\n",
                        ((DWORD *) MatchSid)[0], ((DWORD *) MatchSid)[1],
                        ((DWORD *) MatchSid)[2], ((DWORD *) MatchSid)[3],
                        ((DWORD *) MatchSid)[4], ((DWORD *) MatchSid)[5],
                        ((DWORD *) MatchSid)[1]);
#endif
                return TRUE;
            }

            return FALSE;
        }
    }

    return FALSE;
}
#endif

#define AUTHZ_SID_HASH_BYTE(s) ((UCHAR)(((PISID)s)->SubAuthority[((PISID)s)->SubAuthorityCount - 1]))


VOID
AuthzpInitSidHash(
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN ULONG SidCount,
    OUT PAUTHZI_SID_HASH_ENTRY pHash
    )

/*++

Routine Description

    Initializes the SID hash table.
 
Arguments

    pSidAttr - array of sids to store in hash.
    
    SidCount - number of sids in array.
    
    pHash - pointer to the sid hash table.  
    
Return Value

    None.

--*/

{
    ULONG i           = 0;
    ULONG PositionBit = 0;
    BYTE  HashByte    = 0;

    //
    // Zero the table.
    //

    RtlZeroMemory(
        pHash,
        sizeof(AUTHZI_SID_HASH_ENTRY) * AUTHZI_SID_HASH_SIZE
        );

    if (pSidAttr == NULL)
    {
        return;
    }

    //
    // Can only hash the number of sids that each table entry can hold
    //

    if (SidCount > AUTHZI_SID_HASH_ENTRY_NUM_BITS)
    {
        SidCount = AUTHZI_SID_HASH_ENTRY_NUM_BITS;
    }

    for (i = 0; i < SidCount; i++)
    {
        //
        // HashByte is last byte in SID.
        //

        HashByte = AUTHZ_SID_HASH_BYTE(pSidAttr[i].Sid);
        
        //
        // Position indicates the location of this SID in pSidAttr.
        //

        PositionBit = 1 << i;
        
        //
        // Store the position bit in the low hash indexed by the low order bits of the HashByte
        //

        pHash[(HashByte & AUTHZ_SID_HASH_LOW_MASK)] |= PositionBit;
        
        //
        // Store the position bit in the high hash indexed by the high order bits of the HashByte
        //

        pHash[AUTHZ_SID_HASH_HIGH + ((HashByte & AUTHZ_SID_HASH_HIGH_MASK) >> 4)] |= PositionBit;
    }
}


BOOL
AuthzpSidApplicable(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PAUTHZI_SID_HASH_ENTRY pHash,
    IN PSID pAceSid,
    IN PSID PrincipalSelfSid,
    IN PSID CreatorOwnerSid,
    IN BOOL DenyAce,
    OUT PDWORD pCachingFlags
)

/*++

Routine description:

    This routine decides whether the ace is applicable to the client context.

Arguments:

    SidCount - Number of sids in the pSidAttrArray

    pSidAttr - Sid and attributes against which the ace sid should be compared.

    pHash - Hash table of the pSidAttr array.
                                                                                 
    pAceSid - Sid in the ace.

    PrincipalSelfSid - To replace the ace sid if the ace sid is
        Principal Self Sid (S-1-5-A).

    CreatorOwnerSid - To replace the ace sid if the ace sid is Creator Owner
        sid (S-1-3-0). This will not be used in the current implementation but
        will come in effect once we do single instancing.

    DenyAce - Boolean specifying whether the ace is a deny ace.

    pCachingFlags - To return caching information in the form of:
        AUTHZ_PRINCIPAL_SELF_ACE_PRESENT
        AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT
        AUTHZ_DYNAMIC_DENY_ACE_PRESENT

Return Value:

    A value of TRUE is returned if the effective sid is found in the client
    context and (is enabled OR enabled for deny only for deny aces).
    FALSE otherwise.

--*/

{
    DWORD                 SidLen;
    DWORD                 BitIndex;
    UCHAR                 HashByte;
    DWORD                 i;
    UCHAR                 ByteToExamine;
    UCHAR                 ByteOffset;
    AUTHZI_SID_HASH_ENTRY SidPositionBitMap;
    PSID_AND_ATTRIBUTES   pSA;

    UNREFERENCED_PARAMETER(CreatorOwnerSid);

    //
    // If the principal ace sid is principal self sid and Principal self sid
    // has been provided then use it.
    //

    if (ARGUMENT_PRESENT(PrincipalSelfSid))
    {
        SidLen = RtlLengthSid(pAceSid);

        if ((SidLen == AuthzpPrincipalSelfSidLen) &&
            (AUTHZ_EQUAL_SID(pAceSid, pAuthzPrincipalSelfSid, SidLen)))
        {
            //
            // Record the presence of a principal self sid in this ace.
            //

            *pCachingFlags |= AUTHZ_PRINCIPAL_SELF_ACE_PRESENT;

            pAceSid = PrincipalSelfSid;
            SidLen = RtlLengthSid(pAceSid);
        }
    }

    //
    // Index into pHash by the last byte of the SID.  The resulting value (SidPositionBitMap) 
    // indicates the locations of SIDs in a corresponding SID_AND_ATTRIBUTES array that match 
    // that last byte.
    //

    HashByte          = AUTHZ_SID_HASH_BYTE(pAceSid);
    SidPositionBitMap = AUTHZ_SID_HASH_LOOKUP(pHash, HashByte);
    SidLen            = RtlLengthSid(pAceSid);
    ByteOffset        = 0;

    while (0 != SidPositionBitMap)
    {
        ByteToExamine = (UCHAR)SidPositionBitMap;

        while (ByteToExamine)
        {
            //
            // Get the first nonzero bit in ByteToExamine
            //

            BitIndex = AuthzpByteToIndexLookupTable[ByteToExamine];
            
            //
            // Find the PSID_AND_ATTRIBUTES to which the bit refers.
            //

            pSA = &pSidAttr[ByteOffset + BitIndex];

            if (AUTHZ_EQUAL_SID(pAceSid, pSA->Sid, SidLen))
            {
                if ((FLAG_ON(pSA->Attributes, SE_GROUP_ENABLED)) ||
                    (DenyAce && FLAG_ON(pSA->Attributes, SE_GROUP_USE_FOR_DENY_ONLY)))
                {
                    return TRUE;
                }

                return FALSE;
            }

            // 
            // Turn the current bit off and try the next SID.
            //

            ByteToExamine ^= (1 << BitIndex);
        }

        ByteOffset        = ByteOffset + sizeof(UCHAR);
        SidPositionBitMap = SidPositionBitMap >> sizeof(UCHAR);
    }
    
    //
    // If a matching sid was not found in the pHash and there are SIDS in pSidAttr which did not 
    // get placed in pHash, then search those SIDS for a match.
    //
    
    for (i = AUTHZI_SID_HASH_ENTRY_NUM_BITS; i < SidCount; i++)
    {
        pSA = &pSidAttr[i];

        if (AUTHZ_EQUAL_SID(pAceSid, pSA->Sid, SidLen))
        {
            if ((FLAG_ON(pSA->Attributes, SE_GROUP_ENABLED)) ||
                (DenyAce && FLAG_ON(pSA->Attributes, SE_GROUP_USE_FOR_DENY_ONLY)))
            {
                return TRUE;
            }

            return FALSE;
        }
    }

    return FALSE;
}


BOOL
AuthzpAccessCheckWithCaching(
    IN DWORD Flags,
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults OPTIONAL,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine does a MaximumAllowed access check. It is called if any of the
    following is TRUE
        1. RM has requested for caching
        2. DesiredAccessMask has MAXIMUM_ALLOWED turned on.
        3. ObjectTypeList is present and pReply->ResultList has a length > 1

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - To return the results of access check call.

    phAccessCheckResults - To return a handle to cached results of the access check
        call.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    ACCESS_MASK PreviouslyGrantedAccess = 0;
    DWORD       CachingFlags            = 0;
    DWORD       i                       = 0;
    BOOL        b                       = TRUE;
    PACL        pAcl                    = NULL;

    //
    // Owner is always granted READ_CONTROL and WRITE_DAC.
    //

    if (AuthzpOwnerSidInClientContext(pCC, pSecurityDescriptor))
    {
        PreviouslyGrantedAccess |= (WRITE_DAC | READ_CONTROL);
    }

    //
    // Take ownership privilege grants WRITE_OWNER.
    //

    if (AUTHZ_PRIVILEGE_CHECK(pCC, AUTHZ_TAKE_OWNERSHIP_PRIVILEGE_ENABLED))
    {
        PreviouslyGrantedAccess |= WRITE_OWNER;
    }

    //
    // SecurityPrivilege grants ACCESS_SYSTEM_SECURITY.
    //

    if (AUTHZ_PRIVILEGE_CHECK(pCC, AUTHZ_SECURITY_PRIVILEGE_ENABLED))
    {
        PreviouslyGrantedAccess |= ACCESS_SYSTEM_SECURITY;
    }
    else if (FLAG_ON(pRequest->DesiredAccess, ACCESS_SYSTEM_SECURITY))
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_PRIVILEGE_NOT_HELD,
            0
            );

        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }

    pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    //
    // NULL Dacl is synonymous with Full Control.
    //

    if (!AUTHZ_NON_NULL_PTR(pAcl))
    {
        PreviouslyGrantedAccess |= (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL);

        for (i = 0; i < LocalTypeListLength; i++)
        {
             LocalTypeList[i].CurrentGranted |= PreviouslyGrantedAccess;

             if (ARGUMENT_PRESENT(LocalCachingTypeList))
             {
                 LocalCachingTypeList[i].CurrentGranted |= PreviouslyGrantedAccess;
             }
        }
    }
    else
    {
        for (i = 0; i < LocalTypeListLength; i++)
        {
             LocalTypeList[i].CurrentGranted |= PreviouslyGrantedAccess;

             if (ARGUMENT_PRESENT(LocalCachingTypeList))
             {
                 LocalCachingTypeList[i].CurrentGranted |= PreviouslyGrantedAccess;
             }
        }

        b = AuthzpMaximumAllowedAccessCheck(
                    pCC,
                    pRequest,
                    pSecurityDescriptor,
                    OptionalSecurityDescriptorArray,
                    OptionalSecurityDescriptorCount,
                    LocalTypeList,
                    LocalCachingTypeList,
                    LocalTypeListLength,
                    0 != pRequest->ObjectTypeListLength,
                    &CachingFlags
                    );

        if (!b) 
        {
            goto Cleanup;
        }
    }

    //
    // If the caller asked for caching then allocate a handle, store the results
    // of the static access check in it and insert it into the list of handles.
    //

    if (ARGUMENT_PRESENT(phAccessCheckResults))
    {
        b = AuthzpCacheResults(
                Flags,
                pCC,
                LocalCachingTypeList,
                LocalTypeListLength,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                CachingFlags,
                phAccessCheckResults
                );

        if (!b) goto Cleanup;
    }

    AuthzpFillReplyFromParameters(
        pRequest,
        pReply,
        LocalTypeList
        );

Cleanup:

    return b;
}


VOID
AuthzpFillReplyFromParameters(
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN PIOBJECT_TYPE_LIST LocalTypeList
    )

/*++

Routine description:

    This routine fills in the reply structure wih the results of access check
    supplied by LocalTypeList.

Arguments:

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pReply - The reply structure to fill.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results. This is used to fill the reply structure.

Return Value:

    None.

--*/

{
    ACCESS_MASK DesiredAccess   = 0;
    ACCESS_MASK RelevantAccess  = 0;
    DWORD       i               = 0;

    if (FLAG_ON(pRequest->DesiredAccess, ACCESS_SYSTEM_SECURITY))
    {
        RelevantAccess = STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY;
    }
    else
    {
        RelevantAccess = STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL;
    }

    if (FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED))
    {
        DesiredAccess = pRequest->DesiredAccess & ~(MAXIMUM_ALLOWED);
   
        for (i = 0; i < pReply->ResultListLength; i++)
        {
            if (FLAG_ON(DesiredAccess, ~(LocalTypeList[i].CurrentGranted)) ||
                (0 == LocalTypeList[i].CurrentGranted))
            {
                pReply->GrantedAccessMask[i] = 0;
                pReply->Error[i] = ERROR_ACCESS_DENIED;
            }
            else
            {
                pReply->GrantedAccessMask[i] = LocalTypeList[i].CurrentGranted & RelevantAccess;
                pReply->Error[i] = ERROR_SUCCESS;
            }
        }
    }
    else
    {
        for (i = 0; i < pReply->ResultListLength; i++)
        {
            if (FLAG_ON(pRequest->DesiredAccess, ~(LocalTypeList[i].CurrentGranted)))
            {
                pReply->GrantedAccessMask[i] = 0;
                pReply->Error[i] = ERROR_ACCESS_DENIED;
            }
            else
            {
                pReply->GrantedAccessMask[i] = pRequest->DesiredAccess & RelevantAccess;
                pReply->Error[i] = ERROR_SUCCESS;
            }
        }
    }

}


BOOL
AuthzpNormalAccessCheckWithoutCaching(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine does a normal access check. If desired access is denied at any
    point then it stops acl evaluation.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - The reply structure to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    ACCESS_MASK Remaining = pRequest->DesiredAccess;
    PACL        pAcl      = NULL;
    BOOL        b         = TRUE;

    //
    // Check for SeSecurityPrivilege.
    //

    if (FLAG_ON(Remaining, ACCESS_SYSTEM_SECURITY))
    {
        if (AUTHZ_PRIVILEGE_CHECK(pCC, AUTHZ_SECURITY_PRIVILEGE_ENABLED))
        {
            Remaining &= ~(ACCESS_SYSTEM_SECURITY);
        }
        else
        {
            AuthzpFillReplyStructure(
                pReply,
                ERROR_PRIVILEGE_NOT_HELD,
                0
                );

            SetLastError(ERROR_SUCCESS);
            return TRUE;
        }
    }

    //
    // Ownership of the object grants READ_CONTROL and WRITE_DAC.
    //

    if (FLAG_ON(Remaining, (READ_CONTROL | WRITE_DAC)) &&
        AuthzpOwnerSidInClientContext(pCC, pSecurityDescriptor))
    {
        Remaining &= ~(WRITE_DAC | READ_CONTROL);
    }

    //
    // SeTakeOwnership privilege grants WRITE_OWNER.
    //

    if (FLAG_ON(Remaining, WRITE_OWNER) &&
        AUTHZ_PRIVILEGE_CHECK(pCC, AUTHZ_TAKE_OWNERSHIP_PRIVILEGE_ENABLED))
    {
        Remaining &= ~(WRITE_OWNER);
    }

    pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    //
    // Null acl represents FULL CONTROL.
    //

    if (!AUTHZ_NON_NULL_PTR(pAcl))
    {
        Remaining = 0;
    }

    //
    // If we have been granted access at this point then acl evaluation is not
    // needed.
    //

    if (0 == Remaining)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_SUCCESS,
            pRequest->DesiredAccess
            );

        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }

    //
    // Do the access check with the non-restricted part of the client context.
    //

    b = AuthzpNormalMultipleSDAccessCheck(
            pCC,
            pCC->Sids,
            pCC->SidCount,
            pCC->SidHash,
            Remaining,
            pRequest,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            LocalTypeList,
            LocalTypeListLength
            );

    if (!b)
    {
        return FALSE;
    }

#ifdef AUTHZ_DEBUG
    wprintf(L"Remaining = %x, LocalTypeList = %x\n", Remaining, LocalTypeList->Remaining);
#endif

    if (0 != LocalTypeList->Remaining)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_ACCESS_DENIED,
            0
            );

        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }

    //
    // If the client context is resticted then even the resticted part has to
    // grant all the access bits that were asked.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {
        b = AuthzpNormalMultipleSDAccessCheck(
                pCC,
                pCC->RestrictedSids,
                pCC->RestrictedSidCount,
                pCC->RestrictedSidHash,
                Remaining,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                LocalTypeList,
                LocalTypeListLength
                );

        if (!b)
        {
            return FALSE;
        }

        if (0 != LocalTypeList->Remaining)
        {
            AuthzpFillReplyStructure(
                pReply,
                ERROR_ACCESS_DENIED,
                0
                );

            SetLastError(ERROR_SUCCESS);
            return TRUE;
        }
    }

    //
    // If we made it till here then all access bits have been granted.
    //

    AuthzpFillReplyStructure(
        pReply,
        ERROR_SUCCESS,
        pRequest->DesiredAccess
        );

    SetLastError(ERROR_SUCCESS);
    return TRUE;
}


BOOL
AuthzpNormalMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList OPTIONAL,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine loops thru all the security descriptors and calls
    AuthzpNormalAccessCheck.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    Remaining - Access bits that are yet to be granted.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PSID  pOwnerSid = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    PACL  pAcl      = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    BOOL  b         = TRUE;
    DWORD i         = 0;

    ASSERT(AUTHZ_NON_NULL_PTR(pAcl));

    b = AuthzpNormalAccessCheck(
            pCC,
            pSidAttr,
            SidCount,
            pSidHash,
            Remaining,
            pRequest,
            pAcl,
            pOwnerSid,
            LocalTypeList,
            LocalTypeListLength
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        if (!AUTHZ_NON_NULL_PTR(pAcl))
        {
            continue;
        }

        b = AuthzpNormalAccessCheck(
                pCC,
                pSidAttr,
                SidCount,
                pSidHash,
                LocalTypeList->Remaining,
                pRequest,
                pAcl,
                pOwnerSid,
                LocalTypeList,
                LocalTypeListLength
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}


BOOL
AuthzpOwnerSidInClientContext(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PISECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine description:

    This routine determines if client context is the owner of the given object.

Arguments:

    pCC - Pointer to the client context.

    pSecurityDescriptor - To supply the owner sid for the object.

Return Value:

    A value of TRUE is returned if the owner sid in the security descriptor is
    present in the normal part (as well as the restricted part, if it exists).

--*/

{
    PSID pOwnerSid = RtlpOwnerAddrSecurityDescriptor(pSecurityDescriptor);
    BOOL b         = TRUE;

    //
    // Check if the sid exists in the normal part of the token.
    //

        b = AuthzpSidApplicable(
                pCC->SidCount,
                pCC->Sids,
                pCC->SidHash,
                pOwnerSid,
                NULL,
                NULL,
                FALSE,
                NULL
                );

    if (!b)
    {
        return FALSE;
    }

    //
    // If the token is restricted then the sid must exist in the restricted part
    // of the token.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {

            b = AuthzpSidApplicable(
                    pCC->RestrictedSidCount,
                    pCC->RestrictedSids,
                    pCC->RestrictedSidHash,
                    pOwnerSid,
                    NULL,
                    NULL,
                    FALSE,
                    NULL
                    );

        return b;
    }

    return TRUE;
}

BOOL
AuthzpNormalAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine loops thru the acl till we are denied some access bit that the
    caller asked for or the acl is exhausted.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    Remaining - Access bits that are yet to be granted.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Dacl against which the access check will be performed.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   i                     = 0;
    DWORD   AceCount              = 0;
    DWORD   Index                 = 0;
    DWORD   Ignore                = 0;
    PVOID   Ace                   = NULL;
    GUID  * ObjectTypeInAce       = NULL;
    BOOL    ObjectTypeListPresent = (0 != pRequest->ObjectTypeListLength);
    BOOL    bAceApplicable        = FALSE;

    for (i = 0; i < LocalTypeListLength; i++)
    {
        LocalTypeList[i].Remaining = Remaining;
    }

    AceCount = pAcl->AceCount;

    for (i = 0, Ace = FirstAce(pAcl); 
         (i < AceCount) && (LocalTypeList[0].Remaining != 0);
         i++, Ace = NextAce(Ace))
    {
        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }

        switch (((PACE_HEADER) Ace)->AceType)
        {

        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

            if (!AuthzpSidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    AuthzAceSid(Ace),
                    pRequest->PrincipalSelfSid,
                    pOwnerSid,
                    FALSE,
                    &Ignore
                    ))
            {
                break;
            }
            

#ifdef AUTHZ_DEBUG
            wprintf(L"Allowed access Mask = %x\n", ((PKNOWN_ACE) Ace)->Mask);
#endif

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                     LocalTypeList,
                     LocalTypeListLength,
                     0,
                     ((PKNOWN_ACE) Ace)->Mask,
                     AuthzUpdateRemaining
                     );
            }

            break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

            if (!AuthzpSidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    AuthzAceSid(Ace),
                    pRequest->PrincipalSelfSid,
                    pOwnerSid,
                    FALSE,
                    &Ignore
                    ))
            {
                break;
            }

            //
            // If the all the bits granted by this ace have already been granted
            // or denied, then there is no need to evaluate this callback ace.
            //

            if (0 == (LocalTypeList->Remaining & ((PKNOWN_ACE) Ace)->Mask))
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                     LocalTypeList,
                     LocalTypeListLength,
                     0,
                     ((PKNOWN_ACE) Ace)->Mask,
                     AuthzUpdateRemaining
                     );
            }

            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (!AUTHZ_NON_NULL_PTR(pCC->Server))
            {
                break;
            }

            if (!AuthzpSidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    RtlCompoundAceClientSid(Ace),
                    pRequest->PrincipalSelfSid,
                    pOwnerSid,
                    FALSE,
                    &Ignore
                    ) ||
                !AuthzpSidApplicable(
                        pCC->Server->SidCount,
                        pCC->Server->Sids,
                        pCC->Server->SidHash,
                        RtlCompoundAceServerSid(Ace),
                        NULL,
                        NULL,
                        FALSE,
                        &Ignore
                        ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                     LocalTypeList,
                     LocalTypeListLength,
                     0,
                     ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                     AuthzUpdateRemaining
                     );
            }

            break;

        case ACCESS_DENIED_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

            if (!AuthzpSidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    AuthzAceSid(Ace),
                    pRequest->PrincipalSelfSid,
                    pOwnerSid,
                    TRUE,
                    &Ignore
                    ))
            {
                break;
            }

#ifdef AUTHZ_DEBUG
            wprintf(L"Allowed access Mask = %x\n", ((PKNOWN_ACE) Ace)->Mask);
#endif

            //
            // If any of the remaining bits are denied by this ace, exit early.
            //

            if (LocalTypeList->Remaining & ((PKNOWN_ACE) Ace)->Mask)
            {
                return TRUE;
            }

            break;

        case ACCESS_DENIED_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //
                
            if (!AuthzpSidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    AuthzCallbackAceSid(Ace),
                    pRequest->PrincipalSelfSid,
                    pOwnerSid,
                    TRUE,
                    &Ignore
                    ))
            {
                break;
            }

            //
            // If none of the bits denied by this ace are desired, then
            // there is no need to evaluate this callback ace.
            //

            if (0 == (LocalTypeList->Remaining & ((PKNOWN_ACE) Ace)->Mask))
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Exit early.
            //

            return TRUE;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            
            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            if ((ObjectTypeInAce) && (0 == pRequest->ObjectTypeListLength))
            {
                break;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

            if (!AuthzpSidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    RtlObjectAceSid(Ace),
                    pRequest->PrincipalSelfSid,
                    pOwnerSid,
                    FALSE,
                    &Ignore
                    ))
            {
                break;
            }
            
            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Clear the granted bits from the remaining.
                    //

                    LocalTypeList->Remaining &= ~((PKNOWN_OBJECT_ACE) Ace)->Mask;
                }
                else
                {
                    //
                    // Clear off the granted bits from the remaining for the entire
                    // tree.
                    //

                    AuthzpAddAccessTypeList(
                         LocalTypeList,
                         LocalTypeListLength,
                         0,
                         ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                         AuthzUpdateRemaining
                         );

                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Clear off the granted bits from the remaining for the
                    // subtree starting at the matched Index.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE)Ace)->Mask,
                        AuthzUpdateRemaining
                        );

                }
            }

           break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

            if (!AuthzpSidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    AuthzObjectAceSid(Ace),
                    pRequest->PrincipalSelfSid,
                    pOwnerSid,
                    FALSE,
                    &Ignore
                    ))
            {
                break;
            }

            bAceApplicable = FALSE;

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // If none of the bits granted by this ace are desired, then
                // there is no need to evaluate this callback ace.
                //

                if (0 == (LocalTypeList->Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask))
                {
                    break;
                }

                //
                // Make a call to the resource manager to get his opinion. His
                // evaluation is returned in bAceApplicalble.
                //
                // Note: The return value of the callback is used to decide whether
                // the API failed/succeeded. On a failure, we exit out of access
                // check. On success, we check the boolean returned by
                // bAceApplicable to decide whether to use the current ace.
                //

                if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                           (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                           Ace,
                           pRequest->OptionalArguments,
                           &bAceApplicable
                           )))
                {
                    return FALSE;
                }

                if (!bAceApplicable)
                {
                    break;
                }

                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Clear the granted bits from the remaining.
                    //

                    LocalTypeList->Remaining &= ~((PKNOWN_OBJECT_ACE) Ace)->Mask;
                }
                else
                {
                    //
                    // Clear off the granted bits from the remaining for the entire
                    // tree.
                    //

                    AuthzpAddAccessTypeList(
                         LocalTypeList,
                         LocalTypeListLength,
                         0,
                         ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                         AuthzUpdateRemaining
                         );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // If none of the bits granted by this ace are desired, then
                    // there is no need to evaluate this callback ace.
                    //

                    if (0 == (LocalTypeList[Index].Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask))
                    {
                        break;
                    }

                    //
                    // Make a call to the resource manager to get his opinion. His
                    // evaluation is returned in bAceApplicalble.
                    //
                    // Note: The return value of the callback is used to decide whether
                    // the API failed/succeeded. On a failure, we exit out of access
                    // check. On success, we check the boolean returned by
                    // bAceApplicable to decide whether to use the current ace.
                    //

                    if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                               (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                               Ace,
                               pRequest->OptionalArguments,
                               &bAceApplicable
                               )))
                    {
                        return FALSE;
                    }

                    if (!bAceApplicable)
                    {
                        break;
                    }

                    //
                    // Clear off the granted bits from the remaining for the
                    // subtree starting at the matched Index.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE)Ace)->Mask,
                        AuthzUpdateRemaining
                        );
                }
            }

           break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

            if (!AuthzpSidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    AuthzObjectAceSid(Ace),
                    pRequest->PrincipalSelfSid,
                    pOwnerSid,
                    TRUE,
                    &Ignore
                    ))
            {
                break;
            }
            
            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // If any of the remaining bits are denied by this ace, exit
                // early.
                //

                if (LocalTypeList->Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask)
                {
                    return TRUE;
                }
            }

            //
            // Look for a matching object type guid that matches the one in
            // the ace.
            //

            if (AuthzpObjectInTypeList(
                    ObjectTypeInAce,
                    LocalTypeList,
                    LocalTypeListLength,
                    &Index
                    ))
            {
                //
                // If any of the remaining bits are denied by this ace, exit
                // early.
                //

                if (LocalTypeList[Index].Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask)
                {
                    return TRUE;
                }
            }

            break;

        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //
                
            if (!AuthzpSidApplicable(
                        SidCount,
                        pSidAttr,
                        pSidHash,
                        AuthzObjectAceSid(Ace),
                        pRequest->PrincipalSelfSid,
                        pOwnerSid,
                        TRUE,
                        &Ignore
                        ))
                {
                    break;
                }
            
            bAceApplicable = FALSE;

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // If none of the bits denied by this ace are desired, then
                // there is no need to evaluate this callback ace.
                //

                if (0 == (LocalTypeList->Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask))
                {
                    break;
                }

                //
                // Make a call to the resource manager to get his opinion. His
                // evaluation is returned in bAceApplicalble.
                //
                // Note: The return value of the callback is used to decide whether
                // the API failed/succeeded. On a failure, we exit out of access
                // check. On success, we check the boolean returned by
                // bAceApplicable to decide whether to use the current ace.
                //

                if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                           (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                           Ace,
                           pRequest->OptionalArguments,
                           &bAceApplicable
                           )))
                {
                    return FALSE;
                }

                if (!bAceApplicable)
                {
                    break;
                }

                //
                // Exit early.
                //

                return TRUE;
            }

            //
            // Look for a matching object type guid that matches the one in
            // the ace.
            //

            if (AuthzpObjectInTypeList(
                    ObjectTypeInAce,
                    LocalTypeList,
                    LocalTypeListLength,
                    &Index
                    ))
            {
                //
                // If none of the bits granted by this ace are desired, then
                // there is no need to evaluate this callback ace.
                //

                if (0 == (LocalTypeList[Index].Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask))
                {
                    break;
                }

                //
                // Make a call to the resource manager to get his opinion. His
                // evaluation is returned in bAceApplicalble.
                //
                // Note: The return value of the callback is used to decide whether
                // the API failed/succeeded. On a failure, we exit out of access
                // check. On success, we check the boolean returned by
                // bAceApplicable to decide whether to use the current ace.
                //

                if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                           (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                           Ace,
                           pRequest->OptionalArguments,
                           &bAceApplicable
                           )))
                {
                    return FALSE;
                }

                if (!bAceApplicable)
                {
                    break;
                }

                //
                // Exit early.
                //

                return TRUE;

            }

            break;

        default:
            break;
        }
    }

    return TRUE;
}


BOOL
AuthzpQuickNormalAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine calls AuthzpQuickNormalAccessCheck on regular part as well as
    restricted part (if it exists).

    Access granted = AccessGranted(Sids) [&& AccessGranted(RestrictedSids)
                                            for restricted tokens]

Arguments:

    pCC - Pointer to the client context.

    pAH - Pointer to the authz handle structure.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).
    pReply - The reply structure to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL        b         = TRUE;
    ACCESS_MASK Remaining = pRequest->DesiredAccess & ~pAH->GrantedAccessMask[0];

    //
    // Do the access check with the non-restricted part of the client context.
    //

    b = AuthzpAllowOnlyNormalMultipleSDAccessCheck(
            pCC,
            pCC->Sids,
            pCC->SidCount,
            pCC->SidHash,
            Remaining,
            pRequest,
            pAH->pSecurityDescriptor,
            pAH->OptionalSecurityDescriptorArray,
            pAH->OptionalSecurityDescriptorCount,
            LocalTypeList,
            LocalTypeListLength
            );

    if (!b)
    {
        return FALSE;
    }

    //
    // If some access bits were not granted then no access bits will be granted.
    //

    if (0 != LocalTypeList->Remaining)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_ACCESS_DENIED,
            0
            );

        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }

    //
    // Do the access check with the restricted part of the client context if
    // it exists.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {
        b = AuthzpAllowOnlyNormalMultipleSDAccessCheck(
                pCC,
                pCC->RestrictedSids,
                pCC->RestrictedSidCount,
                pCC->RestrictedSidHash,
                Remaining,
                pRequest,
                pAH->pSecurityDescriptor,
                pAH->OptionalSecurityDescriptorArray,
                pAH->OptionalSecurityDescriptorCount,
                LocalTypeList,
                LocalTypeListLength
                );

        if (!b)
        {
            return FALSE;
        }

        //
        // Make sure that all the bits are granted by the restricted part too.
        //

        if (0 != LocalTypeList->Remaining)
        {
            AuthzpFillReplyStructure(
                pReply,
                ERROR_ACCESS_DENIED,
                0
                );

            SetLastError(ERROR_SUCCESS);
            return TRUE;
        }
    }

    AuthzpFillReplyStructure(
        pReply,
        ERROR_SUCCESS,
        pRequest->DesiredAccess
        );

    return TRUE;
}


BOOL
AuthzpAllowOnlyNormalMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine loops thru all the security descriptors and calls
    AuthzpAllowOnlyNormalSingleAclAccessCheck.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    Remaining - Access bits that are yet to be granted.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PACL  pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    BOOL  b    = TRUE;
    DWORD i    = 0;

    ASSERT(AUTHZ_NON_NULL_PTR(pAcl));

    b = AuthzpAllowOnlyNormalSingleAclAccessCheck(
            pCC,
            pSidAttr,
            SidCount,
            pSidHash,
            Remaining,
            pRequest,
            pAcl,
            LocalTypeList,
            LocalTypeListLength
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        if (!AUTHZ_NON_NULL_PTR(pAcl))
        {
            return TRUE;
        }

        b = AuthzpAllowOnlyNormalSingleAclAccessCheck(
                pCC,
                pSidAttr,
                SidCount,
                pSidHash,
                LocalTypeList->Remaining,
                pRequest,
                pAcl,
                LocalTypeList,
                LocalTypeListLength
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}


BOOL
AuthzpAllowOnlyNormalSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine evaluates only those Grant aces that have principal self sid or
    are callback aces. Deny aces can not exist in the acl unless the resource
    manager messed up with the assumption and changed the security descriptors.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    Remaining - Access bits that are yet to be granted.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Dacl against which the accesscheck will be preformed.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL    ObjectTypeListPresent = (0 != pRequest->ObjectTypeListLength);
    DWORD   i                     = 0;
    DWORD   Index                 = 0;
    DWORD   AceCount              = 0;
    GUID  * ObjectTypeInAce       = NULL;
    PVOID   Ace                   = NULL;
    PSID    pSid                  = NULL;
    BOOL    bAceApplicable        = FALSE;

    for (i = 0; i < LocalTypeListLength; i++)
    {
        LocalTypeList[i].Remaining = Remaining;
    }

    AceCount = pAcl->AceCount;

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {
        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }

        switch (((PACE_HEADER) Ace)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(&((PKNOWN_ACE) Ace)->SidStart))
            {
                break;
            }

            //
            // Check if the caller supplied Principal self sid is present in the
            // client context and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateRemaining
                    );
            }

            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (!AUTHZ_NON_NULL_PTR(pCC->Server))
            {
                break;
            }

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlCompoundAceClientSid(Ace)))
            {
                break;
            }

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ) ||
                !AuthzpAllowOnlySidApplicable(
                        pCC->Server->SidCount,
                        pCC->Server->Sids,
                        pCC->Server->SidHash,
                        RtlCompoundAceServerSid(Ace)
                        ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                    AuthzUpdateRemaining
                    );
            }

            break;


        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlObjectAceSid(Ace)))
            {
                break;
            }

            //
            // Check if the caller supplied Principal self sid is present in the
            // client context and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ))
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Clear the granted bits from the remaining.
                    //

                    LocalTypeList->Remaining &= ~((PKNOWN_OBJECT_ACE) Ace)->Mask;
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateRemaining
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Clear off the granted bits from the remaining for the
                    // subtree starting at the matched Index.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateRemaining
                        );

                }
            }

           break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            //
            // If the ace sid is Principal Self, replace it with the caller
            // supplied Principal sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(&(((PKNOWN_ACE) Ace)->SidStart)))
            {
                pSid = (PSID) &(((PKNOWN_ACE) Ace)->SidStart);
            }
            else
            {
                pSid = pRequest->PrincipalSelfSid;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pSid
                    ))
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // If the all the bits granted by this ace have already been granted
            // or denied, then there is no need to evaluate this callback ace.
            //

            if (0 == (LocalTypeList->Remaining & ((PKNOWN_ACE) Ace)->Mask))
            {
                break;
            }

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateRemaining
                    );
            }

            break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // If the ace sid is Principal Self, replace it with the caller
            // supplied Principal sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlObjectAceSid(Ace)))
            {
                pSid = RtlObjectAceSid(Ace);
            }
            else
            {
                pSid = pRequest->PrincipalSelfSid;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pSid
                    ))
            {
                break;
            }

            bAceApplicable = FALSE;

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // If the all the bits granted by this ace have already been granted
                // or denied, then there is no need to evaluate this callback ace.
                //

                if (0 == (LocalTypeList->Remaining & ((PKNOWN_ACE) Ace)->Mask))
                {
                    break;
                }

                //
                // Make a call to the resource manager to get his opinion. His
                // evaluation is returned in bAceApplicalble.
                //
                // Note: The return value of the callback is used to decide whether
                // the API failed/succeeded. On a failure, we exit out of access
                // check. On success, we check the boolean returned by
                // bAceApplicable to decide whether to use the current ace.
                //

                if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                           (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                           Ace,
                           pRequest->OptionalArguments,
                           &bAceApplicable
                           )))
                {
                    return FALSE;
                }

                if (!bAceApplicable)
                {
                    break;
                }

                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Clear the granted bits from the remaining.
                    //

                    LocalTypeList->Remaining &= ~((PKNOWN_OBJECT_ACE) Ace)->Mask;
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateRemaining
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // If the all the bits granted by this ace are not desired, then
                    // there is no need to evaluate this callback ace.
                    //

                    if (0 == (LocalTypeList[Index].Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask))
                    {
                        break;
                    }

                    //
                    // Make a call to the resource manager to get his opinion. His
                    // evaluation is returned in bAceApplicalble.
                    //
                    // Note: The return value of the callback is used to decide whether
                    // the API failed/succeeded. On a failure, we exit out of access
                    // check. On success, we check the boolean returned by
                    // bAceApplicable to decide whether to use the current ace.
                    //

                    if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                               (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                               Ace,
                               pRequest->OptionalArguments,
                               &bAceApplicable
                               )))
                    {
                        return FALSE;
                    }

                    if (!bAceApplicable)
                    {
                        break;
                    }

                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateRemaining
                        );
                }
            }

           break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case ACCESS_DENIED_CALLBACK_ACE_TYPE:
        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:
            ASSERT(FALSE);
            break;
        default:
            break;
        }
    }

    return TRUE;
}


BOOL
AuthzpAllowOnlySidApplicable(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PSID pSid
    )

/*++

Routine description:

    This routine determine whether the given ace sid is present in the client
    context and is enabled.

Arguments:

    SidCount - Number of sids in the pSidAttrArray

    pSidAttr - Sid and attributes against which the ace sid should be compared.

    pAceSid - Sid in the ace.

Return Value:

    A value of TRUE is returned if the effective sid is found in the client
    context and is enabled.
    FALSE otherwise.

--*/

{
    DWORD i        = 0;
    DWORD SidLen   = 0;
    PISID MatchSid = NULL;

    UNREFERENCED_PARAMETER(pSidHash);

    if (!ARGUMENT_PRESENT(pSid))
    {
        return FALSE;
    }

    SidLen = RtlLengthSid(pSid);

    //
    // Loop thru the sids and return TRUE is a match is found and the sid
    // is enabled.
    //

    for (i = 0; i < SidCount; i++, pSidAttr++)
    {
        MatchSid = (PISID) pSidAttr->Sid;

        if (AUTHZ_EQUAL_SID(pSid, MatchSid, SidLen))
        {
            if (FLAG_ON(pSidAttr->Attributes, SE_GROUP_ENABLED))
            {
                return TRUE;
            }

            return FALSE;
        }
    }

    return FALSE;
}



BOOL
AuthzpQuickMaximumAllowedAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine calls AuthzpQuickMaximumAllowedAccessCheck on normal part (as
    well as restricted part if it exists).

Arguments:

    pCC - Pointer to the client context.

    pAH - Pointer to the authz handle structure.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pReply - The reply structure to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL b                     = FALSE;
    BOOL ObjectTypeListPresent = (0 != pRequest->ObjectTypeListLength);

    UNREFERENCED_PARAMETER(pReply);

    //
    // Do the access check with the non-restricted part of the client context.
    //

    b = AuthzpAllowOnlyMaximumAllowedMultipleSDAccessCheck(
            pCC,
            pRequest,
            pAH->pSecurityDescriptor,
            pAH->OptionalSecurityDescriptorArray,
            pAH->OptionalSecurityDescriptorCount,
            LocalTypeList,
            LocalTypeListLength,
            ObjectTypeListPresent,
            FALSE
            );

    if (!b)
    {
        return FALSE;
    }

    //
    // Do the access check with the restricted part of the client context if
    // it exists.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {
        b = AuthzpAllowOnlyMaximumAllowedMultipleSDAccessCheck(
                pCC,
                pRequest,
                pAH->pSecurityDescriptor,
                pAH->OptionalSecurityDescriptorArray,
                pAH->OptionalSecurityDescriptorCount,
                LocalTypeList,
                LocalTypeListLength,
                ObjectTypeListPresent,
                TRUE
                );
    }

    return b;
}


BOOL
AuthzpAllowOnlyMaximumAllowedMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount OPTIONAL,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    IN BOOL Restricted
    )

/*++

Routine description:

    This routine call AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck for all
    given security descriptors.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

    Restricted - Whether this is an access check on the restricted part of the
        client context.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                  i               = 0;
    DWORD                  j               = 0;
    DWORD                  SidCount        = 0;
    BOOL                   b               = TRUE;
    PSID_AND_ATTRIBUTES    pSidAttr        = NULL;
    PACL                   pAcl            = NULL;
    PSID                   pOwnerSid       = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    PAUTHZI_SID_HASH_ENTRY pSidHash        = NULL;

    if (Restricted)
    {
        //
        // Access granted is a bitwise AND of both (normal & restricted) part
        // of the client context.
        //

        for (j = 0; j < LocalTypeListLength; j++)
        {
            LocalTypeList[j].Remaining = LocalTypeList[j].CurrentGranted;
            LocalTypeList[j].CurrentGranted = 0;
        }

        pSidAttr = pCC->RestrictedSids;
        SidCount = pCC->RestrictedSidCount;
        pSidHash = pCC->RestrictedSidHash;
    }
    else
    {
        pSidAttr = pCC->Sids;
        SidCount = pCC->SidCount;
        pSidHash = pCC->SidHash;
    }

    pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    b = AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck(
            pCC,
            pSidAttr,
            SidCount,
            pSidHash,
            pRequest,
            pAcl,
            pOwnerSid,
            LocalTypeList,
            LocalTypeListLength,
            ObjectTypeListPresent
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        if (!AUTHZ_NON_NULL_PTR(pAcl))
        {
            continue;
        }

        b = AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck(
                pCC,
                pSidAttr,
                SidCount,
                pSidHash,
                pRequest,
                pAcl,
                pOwnerSid,
                LocalTypeList,
                LocalTypeListLength,
                ObjectTypeListPresent
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}



BOOL
AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent
    )

/*++

Routine description:

    This routine loops thru the entire acl and evaluates only those Grant aces
    that have principal self sid in them or are callback aces.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Sacl to be used to make the decision about audit generation.

    pOwnerSid - The owner sid in the primary security descriptor. This will be
        needed after we implement single instancing.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   AceCount        = 0;
    DWORD   i               = 0;
    DWORD   Index           = 0;
    PVOID   Ace             = NULL;
    GUID  * ObjectTypeInAce = NULL;
    BOOL    bAceApplicable  = FALSE;
    BOOL    bCallbackMayApply = FALSE;
    PSID    pSid            = NULL;

    UNREFERENCED_PARAMETER(pOwnerSid);

    AceCount = pAcl->AceCount;

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {
        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }

        switch (((PACE_HEADER) Ace)->AceType)
        {

        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(&((PKNOWN_ACE) Ace)->SidStart))
            {
                break;
            }

            //
            // Check if the caller supplied Principal self sid is present in the
            // client context and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );
            }

            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (!AUTHZ_NON_NULL_PTR(pCC->Server))
            {
                break;
            }

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlCompoundAceClientSid(Ace)))
            {
                break;
            }

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ) ||
                !AuthzpAllowOnlySidApplicable(
                        pCC->Server->SidCount,
                        pCC->Server->Sids,
                        pCC->Server->SidHash,
                        RtlCompoundAceServerSid(Ace)
                        ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );
            }

            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlObjectAceSid(Ace)))
            {
                break;
            }

            //
            // Check if the caller supplied Principal self sid is present in the
            // client context and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ))
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

           break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            //
            // If the ace sid is Principal Self, replace it with the caller
            // supplied Principal sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(&((PKNOWN_ACE) Ace)->SidStart))
            {
                pSid = (PSID) &(((PKNOWN_ACE) Ace)->SidStart);
            }
            else
            {
                pSid = pRequest->PrincipalSelfSid;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pSid
                    ))
            {
                break;
            }

            if (1 == LocalTypeListLength)
            {
                //
                // If the all the bits granted by this ace have already been granted
                // or denied, then there is no need to evaluate this callback ace.
                //

                if (0 == ((((PKNOWN_ACE) Ace)->Mask) &
                          ~(LocalTypeList->CurrentGranted | LocalTypeList->CurrentDenied)))
                {
                    break;
                }
            }
            else
            {
                //
                // We have an object type list. Compute whether we need to break
                // out early.
                // 

                bCallbackMayApply = AuthzpIsAccessMaskApplicable(
                                        LocalTypeList,
                                        LocalTypeListLength,
                                        0,
                                        ((PKNOWN_ACE) Ace)->Mask
                                        );

                if (!bCallbackMayApply)
                {
                    break;
                }

            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->CurrentGranted |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );
            }

            break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // If the ace sid is Principal Self, replace it with the caller
            // supplied Principal sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlObjectAceSid(Ace)))
            {
                pSid = RtlObjectAceSid(Ace);
            }
            else
            {
                pSid = pRequest->PrincipalSelfSid;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pSid
                    ))
            {
                break;
            }

            bAceApplicable = FALSE;

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                if (1 == LocalTypeListLength)
                {
                    //
                    // If the all the bits granted by this ace have already been
                    // granted, then there is no need to evaluate this callback 
                    // ace.
                    //

                    if (0 == ((~LocalTypeList->CurrentGranted) & (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied)))
                    {
                        break;
                    }

                }
                else
                {
                    //
                    // We have an object type list. Compute whether we need to break
                    // out early.
                    // 

                    bCallbackMayApply = AuthzpIsAccessMaskApplicable(
                                            LocalTypeList,
                                            LocalTypeListLength,
                                            0,
                                            ((PKNOWN_ACE) Ace)->Mask
                                            );

                    if (!bCallbackMayApply)
                    {
                        break;
                    }
                }

                //
                // Make a call to the resource manager to get his opinion. His
                // evaluation is returned in bAceApplicalble.
                //
                // Note: The return value of the callback is used to decide whether
                // the API failed/succeeded. On a failure, we exit out of access
                // check. On success, we check the boolean returned by
                // bAceApplicable to decide whether to use the current ace.
                //

                if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                           (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                           Ace,
                           pRequest->OptionalArguments,
                           &bAceApplicable
                           )))
                {
                    return FALSE;
                }

                if (!bAceApplicable)
                {
                    break;
                }

                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // We have an object type list. Compute whether we need to break
                    // out early.
                    // 

                    bCallbackMayApply = AuthzpIsAccessMaskApplicable(
                                            LocalTypeList,
                                            LocalTypeListLength,
                                            Index,
                                            ((PKNOWN_ACE) Ace)->Mask
                                            );

                    if (!bCallbackMayApply)
                    {
                        break;
                    }

                    //
                    // Make a call to the resource manager to get his opinion. His
                    // evaluation is returned in bAceApplicalble.
                    //
                    // Note: The return value of the callback is used to decide whether
                    // the API failed/succeeded. On a failure, we exit out of access
                    // check. On success, we check the boolean returned by
                    // bAceApplicable to decide whether to use the current ace.
                    //

                    if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                               (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                               Ace,
                               pRequest->OptionalArguments,
                               &bAceApplicable
                               )))
                    {
                        return FALSE;
                    }

                    if (!bAceApplicable)
                    {
                        break;
                    }

                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

           break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case ACCESS_DENIED_CALLBACK_ACE_TYPE:
        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:
            ASSERT(FALSE);
            break;

        default:
            break;
        }
    }

    return TRUE;
}


BOOL
AuthzpObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    OUT PDWORD ReturnedIndex
    )

/*++

Routine description:

    This routine searches an ObjectTypeList to determine if the specified object
    type is in the list. It returns the index of the node if a match is found.

Arguments:

    ObjectType - Object Type guid to search for.

    ObjectTypeList - The object type list to search in.

    ObjectTypeListLength - Number of elements in ObjectTypeList.

    ReturnedIndex - Index to the element ObjectType was found in.


Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   Index           = 0;
    GUID  * LocalObjectType = NULL;

    for (Index = 0; Index < ObjectTypeListLength; Index++)
    {
        LocalObjectType = &ObjectTypeList[Index].ObjectType;

        if (RtlpIsEqualGuid(ObjectType, LocalObjectType))
        {
            *ReturnedIndex = Index;
            return TRUE;
        }
    }

    return FALSE;
}


VOID
AuthzpUpdateParentTypeList(
    IN OUT PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex
    )

/*++

    This routine updates the Access fields of the parent object of the specified
    object.

        The "remaining" field of a parent object is the logical OR of
        the remaining field of all of its children.

        The CurrentGranted field of the parent is the collection of bits
        granted to every one of its children..

        The CurrentDenied fields of the parent is the logical OR of
        the bits denied to any of its children.

    This routine takes an index to one of the children and updates the
    remaining field of the parent (and grandparents recursively).

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the "child" element whose parents are to be updated.

Return Value:

    None.

--*/

{
    DWORD       Index             = 0;
    DWORD       ParentIndex       = 0;
    DWORD       Level             = 0;
    ACCESS_MASK NewRemaining      = 0;
    ACCESS_MASK NewCurrentDenied  = 0;
    ACCESS_MASK NewCurrentGranted = 0xFFFFFFFF;

    //
    // If the target node is at the root,
    //  we're all done.
    //

    if (-1 == ObjectTypeList[StartIndex].ParentIndex)
    {
        return;
    }

    //
    // Get the index to the parent that needs updating and the level of
    // the siblings.
    //

    ParentIndex = ObjectTypeList[StartIndex].ParentIndex;
    Level = ObjectTypeList[StartIndex].Level;

    //
    // Loop through all the children.
    //

    for (Index = ParentIndex + 1; Index < ObjectTypeListLength; Index++)
    {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if (ObjectTypeList[Index].Level <= ObjectTypeList[ParentIndex].Level)
        {
            break;
        }

        //
        // Only handle direct children of the parent.
        //

        if (ObjectTypeList[Index].Level != Level)
        {
            continue;
        }

        //
        // Compute the new bits for the parent.
        //

        NewRemaining |= ObjectTypeList[Index].Remaining;
        NewCurrentGranted &= ObjectTypeList[Index].CurrentGranted;
        NewCurrentDenied |= ObjectTypeList[Index].CurrentDenied;

    }

    //
    // If we've not changed the access to the parent,
    //  we're done.
    //

    if ((NewRemaining == ObjectTypeList[ParentIndex].Remaining) &&
        (NewCurrentGranted == ObjectTypeList[ParentIndex].CurrentGranted) &&
        (NewCurrentDenied == ObjectTypeList[ParentIndex].CurrentDenied))
    {
        return;
    }


    //
    // Change the parent.
    //

    ObjectTypeList[ParentIndex].Remaining = NewRemaining;
    ObjectTypeList[ParentIndex].CurrentGranted = NewCurrentGranted;
    ObjectTypeList[ParentIndex].CurrentDenied = NewCurrentDenied;

    //
    // Go update the grand parents.
    //

    AuthzpUpdateParentTypeList(
        ObjectTypeList,
        ObjectTypeListLength,
        ParentIndex
        );
}


VOID
AuthzpAddAccessTypeList (
    IN OUT PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
    )

/*++

Routine Description:

    This routine grants the specified AccessMask to all of the objects that
    are descendents of the object specified by StartIndex.

    The Access fields of the parent objects are also recomputed as needed.

    For example, if an ACE granting access to a Property Set is found,
        that access is granted to all the Properties in the Property Set.

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the target element to update.

    AccessMask - Mask of access to grant to the target element and
        all of its decendents

    FieldToUpdate - Indicate which fields to update in object type list

Updation cases:

                             A
                            / \
                           /   \
                          B     E
                         / \   / \
                        C   D F   G

    Consider an object type list of length 7, with two property sets, each with
    two properties. In array form this is represented as
    {(A, 0), (B, 1), (C, 2), (D, 2), (E, 1), (F, 2), (G, 2)}

    The following diagrams explain access granted/denied at each node.

    Access may be granted because of one (or more) of the following reasons:
        a  = Access granted by an ace on the node
        ca = Access granted by ORing of the children
        pa = Access granted by an ancestor

    Access may be denied because of one (or more) of the following reasons.

        d  = Access explicitly denied by an ace on the node
        cd = Access explicitly denied by child, grandchild, etc
        pd = Access explicitly denied by an ancestor
        id = Access implicitly denied because no ace was applicable

       case 1:                case 2:                case 3:
           Deny D                 Deny B                 Grant B
           Grant A                Grant E                Grant F
                                  Grant D                Grant G

            cd                      cd                     ca
            / \                    / \                   / \
           /   \                  /   \                 /   \
         cd    pa                d     a               a     ca
         / \   / \             / \   / \             / \   / \
       pa   d pa  pa         pd  pd pa  pa         pa  pa a   a


       case 4:                case 5:                case 6:
           Grant A                Grant C                Grant B
           Deny  B                Grant D                Grant F
           Deny  F                Grant F
                                  Grant G
                                  Deny  A

             a                      ca                    id
            / \                    / \                   / \
           /   \                  /   \                 /   \
         pa    pa               ca    ca               a     id
         / \   / \             / \   / \             / \   / \
       pa  pa pa  pa          a   a a   a          pa  pa a   id

Return Value:

    None.

--*/

{
    DWORD Index;
    ACCESS_MASK OldRemaining;
    ACCESS_MASK OldCurrentGranted;
    ACCESS_MASK OldCurrentDenied;
    BOOL AvoidParent = FALSE;

    //
    // Update the requested field.
    //
    // Always handle the target entry.
    //
    // If we've not actually changed the bits, early out.
    //

    switch (FieldToUpdate)
    {
    case AuthzUpdateRemaining:

        OldRemaining = ObjectTypeList[StartIndex].Remaining;
        ObjectTypeList[StartIndex].Remaining = OldRemaining & ~AccessMask;

        if (OldRemaining == ObjectTypeList[StartIndex].Remaining)
        {
            return;
        }

        break;

    case AuthzUpdateCurrentGranted:

        OldCurrentGranted = ObjectTypeList[StartIndex].CurrentGranted;
        ObjectTypeList[StartIndex].CurrentGranted |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentDenied;

        if (OldCurrentGranted == ObjectTypeList[StartIndex].CurrentGranted)
        {

            //
            // We can't simply return here.
            // We have to visit our children.  Consider the case where there
            // was a previous deny ACE on a child.  That deny would have
            // propagated up the tree to this entry.  However, this allow ACE
            // needs to be added all of the children that haven't been
            // explictly denied.
            //

            AvoidParent = TRUE;
        }

        break;

    case AuthzUpdateCurrentDenied:

        OldCurrentDenied = ObjectTypeList[StartIndex].CurrentDenied;
        ObjectTypeList[StartIndex].CurrentDenied |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentGranted;

        if (OldCurrentDenied == ObjectTypeList[StartIndex].CurrentDenied)
        {
            return;
        }

        break;

    default:
        return;
    }


    //
    // Go update parent of the target.
    //

    if (!AvoidParent)
    {
        AuthzpUpdateParentTypeList(
            ObjectTypeList,
            ObjectTypeListLength,
            StartIndex
            );
    }

    //
    // Loop handling all children of the target.
    //

    for (Index = StartIndex + 1; Index < ObjectTypeListLength; Index++)
    {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if (ObjectTypeList[Index].Level <= ObjectTypeList[StartIndex].Level)
        {
            break;
        }

        //
        // Grant access to the children
        //

        switch (FieldToUpdate)
        {
        case AuthzUpdateRemaining:

            ObjectTypeList[Index].Remaining &= ~AccessMask;

            break;

        case AuthzUpdateCurrentGranted:

            ObjectTypeList[Index].CurrentGranted |=
                AccessMask & ~ObjectTypeList[Index].CurrentDenied;

            break;

        case AuthzUpdateCurrentDenied:

            ObjectTypeList[Index].CurrentDenied |=
                AccessMask & ~ObjectTypeList[Index].CurrentGranted;

            break;

        default:
            return;
        }
    }
}


BOOL
AuthzpCacheResults(
    IN DWORD Flags,
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PIOBJECT_TYPE_LIST LocalCachingTypeList,
    IN DWORD LocalTypeListLength,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN DWORD CachingFlags,
    OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults
    )

/*++

Routine description:

    This routine allocates a handle node, stores the results of static access
    check in it and inserts it into the list of handles.

Arguments:

    pCC - Pointer to the client context.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    CachingFlags - Flags that will be stored in the caching handle.

    phAccessCheckResults - To return the newly allocated handle.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD          i            = 0;
    DWORD          Size         = 0;
    DWORD          SDSize       = 0;
    DWORD          SDArraySize  = 0;
    ULONG          LengthNeeded = 0;
    PAUTHZI_HANDLE pHandle      = NULL;
    NTSTATUS       Status       = STATUS_SUCCESS;
    PUCHAR         pWrite       = NULL;
    BOOL           b            = TRUE;

    Size = PtrAlignSize((LocalTypeListLength - 1) * sizeof(ACCESS_MASK) + sizeof(AUTHZI_HANDLE));

    //
    // If we are going to copy the SDs we will need some space for the pointers.
    //

    if (!FLAG_ON(Flags, AUTHZ_ACCESS_CHECK_NO_DEEP_COPY_SD))
    {
        SDSize      = PtrAlignSize(RtlLengthSecurityDescriptor(pSecurityDescriptor));
        SDArraySize = PtrAlignSize(sizeof(ULONG_PTR) * OptionalSecurityDescriptorCount);
        
        for (i = 0; i < OptionalSecurityDescriptorCount; i++)
        {
            SDArraySize += PtrAlignSize(RtlLengthSecurityDescriptor(OptionalSecurityDescriptorArray[i]));
        }
    }

    pHandle = (PAUTHZI_HANDLE) AuthzpAlloc(Size + SDSize + SDArraySize);

    if (AUTHZ_ALLOCATION_FAILED(pHandle))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (FLAG_ON(Flags, AUTHZ_ACCESS_CHECK_NO_DEEP_COPY_SD))
    {
        pHandle->pSecurityDescriptor             = pSecurityDescriptor;
        pHandle->OptionalSecurityDescriptorArray = OptionalSecurityDescriptorArray;
    }
    else
    {
        //
        // Put the primary SD immediately after the pHandle
        //

        pWrite                       = ((PUCHAR)pHandle + Size);
        pHandle->pSecurityDescriptor = (PSECURITY_DESCRIPTOR) pWrite;
        
        LengthNeeded = SDSize;

        Status = RtlMakeSelfRelativeSD(
                     pSecurityDescriptor,
                     pHandle->pSecurityDescriptor,
                     &LengthNeeded
                     );

        ASSERT(NT_SUCCESS(Status));

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            goto Cleanup;
        }

        pWrite += PtrAlignSize(LengthNeeded);

        //
        // After the primary SD we put the Optional SD array
        //

        if (OptionalSecurityDescriptorCount == 0)
        {
            pHandle->OptionalSecurityDescriptorArray = NULL;
        }
        else 
        {
            pHandle->OptionalSecurityDescriptorArray = (PSECURITY_DESCRIPTOR *) pWrite;
            pWrite += (sizeof(ULONG_PTR) * OptionalSecurityDescriptorCount);

            for (i = 0; i < OptionalSecurityDescriptorCount; i++)
            {
                //
                // After the array put in each optional SD, and point an array element at the SD
                //

                pHandle->OptionalSecurityDescriptorArray[i] = pWrite;

                LengthNeeded = PtrAlignSize(RtlLengthSecurityDescriptor(OptionalSecurityDescriptorArray[i]));

                Status = RtlMakeSelfRelativeSD(
                             OptionalSecurityDescriptorArray[i],
                             pHandle->OptionalSecurityDescriptorArray[i],
                             &LengthNeeded
                             );

                ASSERT(NT_SUCCESS(Status));

                if (!NT_SUCCESS(Status))
                {
                    b = FALSE;
                    goto Cleanup;
                }
                
                pWrite += PtrAlignSize(LengthNeeded);
            }
        }
    }

    ASSERT(((PUCHAR)pHandle + Size + SDSize + SDArraySize) == pWrite);

    pHandle->Flags                           = CachingFlags;
    pHandle->pAuthzClientContext             = pCC;
    pHandle->ResultListLength                = LocalTypeListLength;
    pHandle->OptionalSecurityDescriptorCount = OptionalSecurityDescriptorCount;

    //
    // Store the static access check results in the handle.
    //

    for (i = 0; i < LocalTypeListLength; i++)
    {
        pHandle->GrantedAccessMask[i] = LocalCachingTypeList[i].CurrentGranted;
    }

    AuthzpAcquireClientCacheWriteLock(pCC);

    pHandle->next = pCC->AuthzHandleHead;
    pCC->AuthzHandleHead = pHandle;

    AuthzpReleaseClientCacheLock(pCC);

    *phAccessCheckResults = (AUTHZ_ACCESS_CHECK_RESULTS_HANDLE) pHandle;

Cleanup:
    
    if (!b)
    {
        AuthzpFreeNonNull(pHandle);
        SetLastError(RtlNtStatusToDosError(Status));
    }
    return b;
}


BOOL
AuthzpDefaultAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    )

/*++

Routine description:

    This routine is the default function to be used for callback aces if none
    has been specified by the resource manager.

    Returns AceApplicable = TRUE for DENY aces.
                            FALSE for Grant and audit aces.

Arguments:
    Ignores all arguments other than pAce->AceType.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{

    UNREFERENCED_PARAMETER(pArgs);
    UNREFERENCED_PARAMETER(pAuthzClientContext);

    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:
    case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:
    case SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE:

        *pbAceApplicable = FALSE;

        break;

    case ACCESS_DENIED_CALLBACK_ACE_TYPE:
    case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:

        *pbAceApplicable = TRUE;

        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}


BOOL
AuthzpGenerateAudit(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList
    )

/*++

Routine description:

    This routine decides whether an audit needs to be generated. It is called
    at the end of the access check.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAuditEvent - Audit info to be in case we decide to generate an audit.

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - The reply structure holding the results of the access check.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL b                     = FALSE;
    BOOL bGenerateAudit        = FALSE;
    BOOL bGenerateSuccessAudit = FALSE;
    BOOL bGenerateFailureAudit = FALSE;

    //
    // if the caller is interested in the whole object
    //     generate a normal audit
    // else
    //     generate an audit for the entire tree - DS style
    //

    if ((1 == pReply->ResultListLength) && (NULL == pRequest->ObjectTypeList))
    {
        b = AuthzpExamineSacl(
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                &bGenerateAudit
                );

        if (!b)
        {
            return FALSE;
        }

        if (bGenerateAudit)
        {
            if (ERROR_SUCCESS == pReply->Error[0])
            {
                LocalTypeList->Flags |= AUTHZ_OBJECT_SUCCESS_AUDIT;
                
                b = AuthzpCreateAndLogAudit(
                        AUTHZ_OBJECT_SUCCESS_AUDIT,
                        pCC,
                        pAuditEvent,
                        (PAUTHZI_RESOURCE_MANAGER)pCC->pResourceManager,
                        LocalTypeList,
                        pRequest,
                        pReply
                        );
            }
            else
            {
                LocalTypeList->Flags |= AUTHZ_OBJECT_FAILURE_AUDIT;
                
                b = AuthzpCreateAndLogAudit(
                        AUTHZ_OBJECT_FAILURE_AUDIT,
                        pCC,
                        pAuditEvent,
                        (PAUTHZI_RESOURCE_MANAGER)pCC->pResourceManager,
                        LocalTypeList,
                        pRequest,
                        pReply
                        );
            }
        }
    }
    else
    {
        b = AuthzpExamineSaclForObjectTypeList(
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                LocalTypeList,
                &bGenerateSuccessAudit,
                &bGenerateFailureAudit
                );

        if (!b)
        {
            return FALSE;
        }

        if (bGenerateSuccessAudit)
        {
            b = AuthzpCreateAndLogAudit(
                    AUTHZ_OBJECT_SUCCESS_AUDIT,
                    pCC,
                    pAuditEvent,
                    (PAUTHZI_RESOURCE_MANAGER)pCC->pResourceManager,
                    LocalTypeList,
                    pRequest,
                    pReply
                    );
        }
        if (bGenerateFailureAudit)
        {
            b = AuthzpCreateAndLogAudit(
                    AUTHZ_OBJECT_FAILURE_AUDIT,
                    pCC,
                    pAuditEvent,
                    (PAUTHZI_RESOURCE_MANAGER)pCC->pResourceManager,
                    LocalTypeList,
                    pRequest,
                    pReply
                    );
        }
    }

    return b;
}



BOOL
AuthzpExamineSacl(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN PAUTHZ_ACCESS_REPLY pReply,
    OUT PBOOL pbGenerateAudit
    )

/*++

Routine description:

    This routine loops thru the entire list of security descriptors and call
    AuthzpExamineSingleSacl for each security descriptor.

    Called in one of the following cases:
        - the caller has not passed in an object type list
        - the caller has passed in an object type list and asked for access at
          the root of the tree instead of the whole tree.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - The reply structure holding the results of the access check.

    pbGenerateAudit - To return whether an audit needs to be generated.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PACL        pAcl              = NULL;
    PSID        pOwnerSid         = NULL;
    BOOL        b                 = FALSE;
    BOOL        bMaximumFailed    = FALSE;
    UCHAR       AuditMaskType     = SUCCESSFUL_ACCESS_ACE_FLAG;
    ACCESS_MASK AccessMask        = 0;
    DWORD       i                 = 0;

    if (0 == pReply->GrantedAccessMask[0])
    {
        AuditMaskType = FAILED_ACCESS_ACE_FLAG;

        if (FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED))
        {
            bMaximumFailed = TRUE;
        }

        AccessMask = pRequest->DesiredAccess;
    }
    else
    {
        AccessMask = pReply->GrantedAccessMask[0];
    }

    pAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    pOwnerSid = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    b = AuthzpExamineSingleSacl(
            pCC,
            pRequest,
            AccessMask,
            pAcl,
            pOwnerSid,
            AuditMaskType,
            bMaximumFailed,
            pReply,
            pbGenerateAudit
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; (i < OptionalSecurityDescriptorCount) && (!*pbGenerateAudit); i++)
    {
        pAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        b = AuthzpExamineSingleSacl(
                pCC,
                pRequest,
                AccessMask,
                pAcl,
                pOwnerSid,
                AuditMaskType,
                bMaximumFailed,
                pReply,
                pbGenerateAudit
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}


BOOL
AuthzpExamineSingleSacl(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN ACCESS_MASK AccessMask,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN UCHAR AuditMaskType,
    IN BOOL bMaximumFailed,
    OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PBOOL pbGenerateAudit
    )

/*++

Routine description:

    This routine walk the sacl till we hit an ace that is applicable for the
    access check result.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list structure (if any).

    AccessMask - Desired access mask in case of failure,
                 Granted access mask in case of success

    pAcl - The sacl against which granted/desired access bits will be matched

    pOwnerSid - Need for single instance work later on

    pReply - Results of the access check.

    AuditMaskType - SUCCESSFUL_ACCESS_ACE_FLAG if access check succeeded
                    FAILED_ACCESS_ACE_FLAG otherwise

    bMaximumFailed - Whether the caller asked for MaximumAllowed and access
        check failed

    pbGenerateAudit - To return whether an audit should be generated

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   AceCount          = 0;
    DWORD   i                 = 0;
    PVOID   Ace               = NULL;
    BOOL    bAceApplicable    = FALSE;
    DWORD   Ignore            = 0;
    BOOL    bIsAnonymous      = FALSE;

    //
    // Ignore NULL as well as Empty sacls.
    //

    if ((!ARGUMENT_PRESENT(pAcl)) || (0 == (AceCount = pAcl->AceCount)))
    {
        return TRUE;
    }

    //
    // Check if this is Anonymous. We audit Anonymous when we see an ACE for 
    // Anonymous as well as Everyone.
    //

    if (AUTHZ_EQUAL_SID(pCC->Sids[0].Sid, pAuthzAnonymousSid, AuthzpAnonymousSidLen))
    {
        bIsAnonymous = TRUE;
    }

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {
        //
        // We are not interested in the ace if one of the following is true
        //     - inherit only ace
        //     - AuditMaskType does not match
        //     - AccessMask has no matching bits with the Mask in the acl and
        //       we are not looking for a MaximumAllowed failure audit
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE) ||
            !FLAG_ON(((PACE_HEADER) Ace)->AceFlags, AuditMaskType) ||
            (!FLAG_ON(((PKNOWN_ACE) Ace)->Mask, AccessMask) && !bMaximumFailed))
        {
            continue;
        }

        switch(((PACE_HEADER) Ace)->AceType)
        {
        case SYSTEM_AUDIT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 pCC->SidCount,
                                 pCC->Sids,
                                 pCC->SidHash,
                                 AuthzAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                 &Ignore
                                 );

            //
            // The AceSid may not be directly applicable. However, if the user
            // is Anonymous, and the ACE is applicable to Everyone, we use this
            // ACE is SACL evaluation.
            // 
            //

            if (!bAceApplicable)
            {
                if (bIsAnonymous) 
                {
                    if (!AUTHZ_EQUAL_SID(AuthzAceSid(Ace), pAuthzEveryoneSid, AuthzpEveryoneSidLen))
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }

            }

            *pbGenerateAudit = TRUE;
            if (NULL != pReply->SaclEvaluationResults)
            {
                pReply->SaclEvaluationResults[0] |= 
                    (pReply->Error[0] == ERROR_SUCCESS ? AUTHZ_GENERATE_SUCCESS_AUDIT : AUTHZ_GENERATE_FAILURE_AUDIT);
            }

            return TRUE;

        case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 pCC->SidCount,
                                 pCC->Sids,
                                 pCC->SidHash,
                                 AuthzCallbackAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                 &Ignore
                                 );

            //
            // The AceSid may not be directly applicable. However, if the user
            // is Anonymous, and the ACE is applicable to Everyone, we use this
            // ACE is SACL evaluation.
            // 
            //

            if (!bAceApplicable)
            {
                if (bIsAnonymous) 
                {
                    if (!AUTHZ_EQUAL_SID(AuthzCallbackAceSid(Ace), pAuthzEveryoneSid, AuthzpEveryoneSidLen))
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }

            }

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            *pbGenerateAudit = TRUE;
            if (NULL != pReply->SaclEvaluationResults)
            {
                pReply->SaclEvaluationResults[0] |= 
                    (pReply->Error[0] == ERROR_SUCCESS ? AUTHZ_GENERATE_SUCCESS_AUDIT : AUTHZ_GENERATE_FAILURE_AUDIT);
            }

            return TRUE;

        default:
            break;
        }
    }

    return TRUE;
}


BOOL
AuthzpExamineSaclForObjectTypeList(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    )

/*++

Routine description:

    This routine walks thru the entire list of security descriptors and calls
    AuthzpExamineSingleSaclForObjectTypeList for each security descriptor.
    Called when an object type list is passed and the caller has asked for
    the results at each node.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - The reply structure to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

    pbGenerateSuccessAudit - Returns whether a success audit should be
        generated.

    pbGenerateFailureAudit - Returns whether a failure audit should be
        generated.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PACL  pAcl      = NULL;
    PSID  pOwnerSid = NULL;
    BOOL  b         = FALSE;
    DWORD i         = 0;

    pAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    pOwnerSid = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    b = AuthzpExamineSingleSaclForObjectTypeList(
            pCC,
            pRequest,
            pAcl,
            pOwnerSid,
            pReply,
            LocalTypeList,
            pbGenerateSuccessAudit,
            pbGenerateFailureAudit
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        b = AuthzpExamineSingleSaclForObjectTypeList(
                pCC,
                pRequest,
                pAcl,
                pOwnerSid,
                pReply,
                LocalTypeList,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}



BOOL
AuthzpExamineSingleSaclForObjectTypeList(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    )

/*++

Routine description:

    This routine walk thru the entire sacl and mark those nodes in the tree that
    need be dumped to the audit log. It colors the whole subtree including the
    node at which the ace is applicable. A normal ace is applicable at the root
    of the tree.

Arguments:
    pCC - Pointer to the client context to be audited.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Sacl to be used to make the decision about audit generation.

    pOwnerSid - The owner sid in the primary security descriptor. This will be
        needed after we implement single instancing.

    pReply - Supplies a pointer to a reply structure used to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    pbGenerateSuccessAudit - Returns whether a success audit should be
        generated.

    pbGenerateFailureAudit - Returns whether a failure audit should be
        generated.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   AceCount        = 0;
    DWORD   i               = 0;
    DWORD   Ignore          = 0;
    DWORD   Index           = 0;
    PVOID   Ace             = NULL;
    GUID  * ObjectTypeInAce = NULL;
    BOOL    bAceApplicable  = FALSE;
    BOOL    bIsAnonymous    = FALSE;

    //
    // Ignore NULL as well as Empty sacls.
    //

    if ((!ARGUMENT_PRESENT(pAcl)) || (0 == (AceCount = pAcl->AceCount)))
    {
        return TRUE;
    }

    //
    // Check if this is Anonymous. We audit Anonymous when we see an ACE for 
    // Anonymous as well as Everyone.
    //

    if (AUTHZ_EQUAL_SID(pCC->Sids[0].Sid, pAuthzAnonymousSid, AuthzpAnonymousSidLen))
    {
        bIsAnonymous = TRUE;
    }

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {
        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }

        switch(((PACE_HEADER) Ace)->AceType)
        {
        case SYSTEM_AUDIT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 pCC->SidCount,
                                 pCC->Sids,
                                 pCC->SidHash,
                                 AuthzAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                 &Ignore
                                 );

            //
            // The AceSid may not be directly applicable. However, if the user
            // is Anonymous, and the ACE is applicable to Everyone, we use this
            // ACE is SACL evaluation.
            // 
            //

            if (!bAceApplicable)
            {
                if (bIsAnonymous) 
                {
                    if (!AUTHZ_EQUAL_SID(AuthzAceSid(Ace), pAuthzEveryoneSid, AuthzpEveryoneSidLen))
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }

            }

            //
            // We have found an ace that is applicable. Walk the tree to decide
            // if an audit should be generated. Also, mark the nodes that need
            // be dumped to the audit log.
            //

            AuthzpSetAuditInfoForObjectType(
                pReply,
                LocalTypeList,
                0,
                ((PKNOWN_ACE) Ace)->Mask,
                pRequest->DesiredAccess,
                ((PACE_HEADER) Ace)->AceFlags,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

            break;

        case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 pCC->SidCount,
                                 pCC->Sids,
                                 pCC->SidHash,
                                 AuthzAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                 &Ignore
                                 );

            //
            // The AceSid may not be directly applicable. However, if the user
            // is Anonymous, and the ACE is applicable to Everyone, we use this
            // ACE is SACL evaluation.
            // 
            //

            if (!bAceApplicable)
            {
                if (bIsAnonymous) 
                {
                    if (!AUTHZ_EQUAL_SID(AuthzAceSid(Ace), pAuthzEveryoneSid, AuthzpEveryoneSidLen))
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }

            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // We have found an ace that is applicable. Walk the tree to decide
            // if an audit should be generated. Also, mark the nodes that need
            // be dumped to the audit log.
            //

            AuthzpSetAuditInfoForObjectType(
                pReply,
                LocalTypeList,
                0,
                ((PKNOWN_ACE) Ace)->Mask,
                pRequest->DesiredAccess,
                ((PACE_HEADER) Ace)->AceFlags,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

            break;

        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 pCC->SidCount,
                                 pCC->Sids,
                                 pCC->SidHash,
                                 RtlObjectAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                 &Ignore
                                 );

            //
            // The AceSid may not be directly applicable. However, if the user
            // is Anonymous, and the ACE is applicable to Everyone, we use this
            // ACE is SACL evaluation.
            // 
            //

            if (!bAceApplicable)
            {
                if (bIsAnonymous) 
                {
                    if (!AUTHZ_EQUAL_SID(RtlObjectAceSid(Ace), pAuthzEveryoneSid, AuthzpEveryoneSidLen))
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }

            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            Index = 0;

            if (AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (!AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        pReply->ResultListLength,
                        &Index
                        ))
                {
                    break;
                }
            }

            //
            // We have found an ace that is applicable. Walk the tree to decide
            // if an audit should be generated. Also, mark the nodes that need
            // be dumped to the audit log.
            //

            AuthzpSetAuditInfoForObjectType(
                pReply,
                LocalTypeList,
                Index,
                ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                pRequest->DesiredAccess,
                ((PACE_HEADER) Ace)->AceFlags,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

            break;

        case SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

            bAceApplicable = AuthzpSidApplicable(
                                 pCC->SidCount,
                                 pCC->Sids,
                                 pCC->SidHash,
                                 AuthzObjectAceSid(Ace),
                                 pRequest->PrincipalSelfSid,
                                 pOwnerSid,
                                 FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                 &Ignore
                                 );

            //
            // The AceSid may not be directly applicable. However, if the user
            // is Anonymous, and the ACE is applicable to Everyone, we use this
            // ACE is SACL evaluation.
            // 
            //

            if (!bAceApplicable)
            {
                if (bIsAnonymous) 
                {
                    if (!AUTHZ_EQUAL_SID(AuthzObjectAceSid(Ace), pAuthzEveryoneSid, AuthzpEveryoneSidLen))
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }

            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            Index = 0;

            if (AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (!AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        pReply->ResultListLength,
                        &Index
                        ))
                {
                    break;
                }
            }

            //
            // We have found an ace that is applicable. Walk the tree to decide
            // if an audit should be generated. Also, mark the nodes that need
            // be dumped to the audit log.
            //

            AuthzpSetAuditInfoForObjectType(
                pReply,
                LocalTypeList,
                Index,
                ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                pRequest->DesiredAccess,
                ((PACE_HEADER) Ace)->AceFlags,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

            break;

        default:
            break;
        }
    }

    return TRUE;
}


VOID
AuthzpSetAuditInfoForObjectType(
    IN PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD StartIndex,
    IN ACCESS_MASK AceAccessMask,
    IN ACCESS_MASK DesiredAccessMask,
    IN UCHAR AceFlags,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    )

/*++

Routine description:

    This routine propagates the audit decision up and down the subtree starting at
    StartIndex.

Arguments:

    pReply - This has been filled by access check at this point. We just read
        the values to make audit decision.

    LocalTypeList - Decision to audit a node is stored into Flags corresponding
        member of this array.

    StartIndex - The index in the array at which the coloring should start.

    AceAccessMask - Access mask in the audit ace.

    DesiredAccessMask - Desired access mask in the access request.

    AceFlags - AceFlags member of the ace header. We are interested in the
        audit flags.

    pbGenerateSuccessAudit - Returns whether a success audit should be
        generated.

    pbGenerateFailureAudit - Returns whether a failure audit should be
        generated.

Return Value:

    None

--*/

{
    DWORD i = StartIndex;
    LONG ParentIndex;
    LONG ChildIndex;

    do
    {
        //
        // ChildIndex will always be the index of the last object in the list
        // that we examined.
        //

        ChildIndex = i;

        //
        // Store the decision to audit in the local type list if there is a
        // match of access bits.
        //

        if (ERROR_SUCCESS == pReply->Error[i])
        {
            if (FLAG_ON(AceFlags, SUCCESSFUL_ACCESS_ACE_FLAG) &&
                FLAG_ON(pReply->GrantedAccessMask[i], AceAccessMask))
            {
                *pbGenerateSuccessAudit = TRUE;
                LocalTypeList[i].Flags |= AUTHZ_OBJECT_SUCCESS_AUDIT;
                if (NULL != pReply->SaclEvaluationResults)
                {
                    pReply->SaclEvaluationResults[i] |= AUTHZ_GENERATE_SUCCESS_AUDIT;
                }
            }
        }
        else
        {
            //
            // Failure audit is generated even if the bits do not match if the
            // caller asked for MAXIMUM_ALLOWED.
            //

            if (FLAG_ON(AceFlags, FAILED_ACCESS_ACE_FLAG) &&
                FLAG_ON(DesiredAccessMask, (AceAccessMask | MAXIMUM_ALLOWED)))
            {
                *pbGenerateFailureAudit = TRUE;
                LocalTypeList[i].Flags |= AUTHZ_OBJECT_FAILURE_AUDIT;
                if (NULL != pReply->SaclEvaluationResults)
                {
                    pReply->SaclEvaluationResults[i] |= AUTHZ_GENERATE_FAILURE_AUDIT;
                }
            }

        }

        i++;

        //
        // Stop the traversal when the list is exhausted or when we have hit a
        // sibling of the starting node.
        //

    } while ((i < pReply->ResultListLength) &&
             (LocalTypeList[i].Level > LocalTypeList[StartIndex].Level));

    //
    // Now propagate the audit bits up through to the parents.
    //
    
    for (ChildIndex; ChildIndex > 0; ChildIndex--)
    {
        ParentIndex = LocalTypeList[ChildIndex].ParentIndex;
        LocalTypeList[ParentIndex].Flags |= LocalTypeList[ChildIndex].Flags;
        if (pReply->SaclEvaluationResults)
        {
            pReply->SaclEvaluationResults[ParentIndex] |= pReply->SaclEvaluationResults[ChildIndex];
        }
    }
}



BOOL
AuthzpVerifyCachedAccessCheckArguments(
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply
    )

/*++

Routine description:

    This routine verifies arguments for the cached access check call.

Arguments:

    pAH - Pointer to the authz handle structure.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pReply - Supplies a pointer to a reply structure used to return the results

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    if (!ARGUMENT_PRESENT(pAH))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(pRequest))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(pReply))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // The caller can specify one of the two values for Reply->ResultListLength
    //     a. 1 - representing the whole object.
    //     b. pRequest->ObjectTypeListLength - for every node in the type list.
    //

    if ((1 != pReply->ResultListLength) &&
        (pReply->ResultListLength != pRequest->ObjectTypeListLength))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}

VOID
AuthzpFillReplyStructureFromCachedGrantedAccessMask(
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_MASK GrantedAccessMask
    )

/*++

Routine description:

    This routine fills the reply structure from the granted access mask array
    in the cache.

Arguments:

    pReply - The reply structure to fill.

    DesiredAccess - Access mask desired.

    GrantedAccessMask - Array of granted masks from the cache.

Return Value:

    None.

--*/

{
    DWORD i = 0;

    for (i = 0; i < pReply->ResultListLength; i++)
    {
        if (FLAG_ON(DesiredAccess, ~(GrantedAccessMask[i])))
        {
            pReply->GrantedAccessMask[i] = 0;
            pReply->Error[i] = ERROR_ACCESS_DENIED;
        }
        else
        {
            pReply->GrantedAccessMask[i] = DesiredAccess;
            pReply->Error[i] = ERROR_SUCCESS;
        }
    }
}


VOID
AuthzpReferenceAuditEventType(
    IN AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET
    )

/*++

Routine Description

    This references an AUTHZ_AUDIT_EVENT_TYPE_HANDLE.  The handle is referenced whenever
    it is used in a situation where it will be 'unused.'  For instance, when an audit is placed
    on the audit queue, we reference hAET.  When we take that audit off of the queue, we deref
    hAET.  This allows the user to not have to concern himself with sync issues revolving around
    the implementation of the hAET.  
    
Arguments

    hAET - the AUTHZ_AUDIT_EVENT_TYPE_HANDLE to reference.
    
Return Value

    Boolean: TRUE on success, FALSE on fail.  Extended information is available with GetLastError().
                                               
--*/

{
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAAETO = (PAUTHZ_AUDIT_EVENT_TYPE_OLD)hAET;
    InterlockedIncrement(&pAAETO->RefCount);
}


BOOL
AuthzpDereferenceAuditEventType(
    IN OUT AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET
    )

/*++

Routine Description

    Dereferences and AUTHZ_AUDIT_EVENT_TYPE_HANDLE.
    
Arguments

    hAET - handle to dereference.

Return Value

    Boolean: TRUE on success, FALSE on fail.  Extended information is available with GetLastError().
    
--*/

{
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAAETO = (PAUTHZ_AUDIT_EVENT_TYPE_OLD)hAET;
    LONG                        Refs   = 0;
    BOOL                        b      = TRUE;

    Refs = InterlockedDecrement(&pAAETO->RefCount);
    
    ASSERT(Refs >= 0);

    if (Refs == 0)
    {
        b = AuthzpUnregisterAuditEvent((PAUDIT_HANDLE)&(pAAETO->hAudit));

        //
        // If we fail because the server is busy, then try once more. 
        // We don't want to sit here forever, however.
        //

        if (!b && (RPC_S_SERVER_TOO_BUSY == GetLastError()))
        {
            Sleep(10000);
            b = AuthzpUnregisterAuditEvent((PAUDIT_HANDLE)&(pAAETO->hAudit));
        }

        //
        // Don't assert if the server was simply too busy (which usually
        // indicates that we are shutting down).
        //

        if (!b && (RPC_S_SERVER_TOO_BUSY != GetLastError()))
        {
            ASSERT(L"AuthzpUnregisterAuditEvent failed for reason != server busy" && FALSE);
        }
        AuthzpFree(hAET);
    }

    return b;
}


BOOL
AuthzpEveryoneIncludesAnonymous(
    OUT PBOOL pbInclude
    )

/*++

Routine Description:

    This routine checks to see if we should include Everyone Sid in Anonymous 
    contexts.  
    
    The reg key under system\currentcontrolset\Control\Lsa\
    AnonymousIncludesEveryone indicates whether or not to include the group.
    If the value is zero (or doesn't exist), we restrict Anonymous context by
    not giving it the Everyone Sid.

Arguments:

    bInclude - TRUE if Everyone Sid should be in the context, false otherwise.

Return Value:

    Boolean: TRUE on success, FALSE on fail.  Extended information is available with GetLastError().
    
--*/
{
    NTSTATUS                       NtStatus            = STATUS_SUCCESS;
    UNICODE_STRING                 KeyName             = {0};     
    OBJECT_ATTRIBUTES              ObjectAttributes    = {0};
    HANDLE                         KeyHandle           = NULL;
    UCHAR                          Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG                          KeyValueLength      = 100;
    ULONG                          ResultLength        = 0;
    PULONG                         Flag                = NULL;
    BOOL                           b                   = TRUE;

    *pbInclude = FALSE;

    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        b = FALSE;
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &KeyName,
        L"EveryoneIncludesAnonymous"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            Flag = (PULONG) KeyValueInformation->Data;

            if (*Flag != 0 ) {
               *pbInclude = TRUE;
            }
        }

    }
    NtClose(KeyHandle);

Cleanup:

    return b;
}


BOOL
AuthzpConstructRegistryPolicyPerUserAuditing(
    IN PTOKEN_AUDIT_POLICY pPolicy,
    OUT PULONGLONG pRegPolicy
    )

/**

Routine Description:

    This constructs a per user policy suitable for setting in the registry key.
    
Arguments:

    pPolicy - the policy to convert into the registry setting.
    
    pRegPolicy - the registry format of the policy.
    
Return Value:

    Boolean: TRUE on success, FALSE on fail.  Extended information is available with GetLastError().
    
**/

{
    ULONG i;
    ULONGLONG RegPolicy = 0;
    DWORD PolicyBits;
    DWORD Category;

    *pRegPolicy = 0;

    //
    // For each policy entry in the array, extract the 4 legal policy bits
    // and place them in the proper nibble in the 64bit registry policy.
    //

    ASSERT(pPolicy->PolicyCount <= POLICY_AUDIT_EVENT_TYPE_COUNT);

    for (i = 0; i < pPolicy->PolicyCount; i++)
    {
        PolicyBits = pPolicy->Policy[i].PolicyMask;
        Category   = pPolicy->Policy[i].Category;
        ASSERT(Category <= POLICY_AUDIT_EVENT_TYPE_COUNT);

        if (Category > POLICY_AUDIT_EVENT_TYPE_COUNT)
        {
            return FALSE;
        }
        
        //
        // 4 bits per category.
        //

        RegPolicy |= ((ULONGLONG)PolicyBits << (4 * Category));
    }

    *pRegPolicy = RegPolicy;

    return TRUE;
}


BOOL
AuthzpConstructPolicyPerUserAuditing(
    IN     ULONGLONG           RawPolicy,
    OUT    PTOKEN_AUDIT_POLICY pTokenPolicy,
    IN OUT PULONG              TokenPolicyLength
    )

/*++

Routine Description

    This constructs a human parsable audit policy (policy appropriate for passing 
    to NtSetTokenInformation).  It converts the raw registry policy into a TOKEN_AUDIT_POLICY.
    
Arguments

    RawPolicy - a 64 bit quantity describing a user's audit policy settings.
    
    pTokenPolicy - points to memory that receives a more presentable form of the RawPolicy.
    
    TokenPolicyLength - The length of the pTokenPolicy buffer.  Receives the necessary length
                        in the case that the buffer is insufficient.

Return Value

    Appropriate NTSTATUS value.

--*/

{
    ULONG i;
    ULONG j;
    ULONG PolicyBits;
    ULONG CategoryCount;
    ULONG LengthNeeded;
    
    //
    // First calculate the number of category settings in the RawPolicy
    // This will reveal if we have enough space to construct the pTokenPolicy.
    //

    for (CategoryCount = 0, i = 0; i < POLICY_AUDIT_EVENT_TYPE_COUNT; i++) 
    {
        if ((RawPolicy >> (4 * i)) & VALID_AUDIT_POLICY_BITS) 
        {
            CategoryCount++;
        }
    }

    LengthNeeded = PER_USER_AUDITING_POLICY_SIZE_BY_COUNT(CategoryCount);

    //
    // Check if the passed buffer is large enough.
    //

    if (*TokenPolicyLength < LengthNeeded)
    {
        *TokenPolicyLength = LengthNeeded;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    *TokenPolicyLength = LengthNeeded;

    //
    // Build the policy.
    //

    pTokenPolicy->PolicyCount = CategoryCount;

    for (j = 0, i = 0; i < POLICY_AUDIT_EVENT_TYPE_COUNT; i++) 
    {
        PolicyBits = (ULONG)((RawPolicy >> (4 * i)) & VALID_AUDIT_POLICY_BITS);
        
        if (PolicyBits) 
        {
            pTokenPolicy->Policy[j].Category   = i;
            pTokenPolicy->Policy[j].PolicyMask = PolicyBits;
            j++;
        }
    }

    return TRUE;
}


BOOL
AuthzpInitializeAuditParamsV(
    IN     DWORD         dwFlags,
    OUT    PAUDIT_PARAMS pParams,
    IN OUT PSID*         ppUserSid,
    IN     PCWSTR        SubsystemName,
    IN     USHORT        AuditId,
    IN     USHORT        NumParams,
    IN     va_list       arglist
    )
/*++

Routine Description:

    Initialize the AUDIT_PARAMS structure based on the passed
    data.

Arguments:

    dwFlags       - control flags. one or more of the following:
                    APF_AuditSuccess
                    AUTHZP_INIT_PARAMS_SKIP_HEADER
                    AUTHZP_INIT_PARAMS_SOURCE_INFO
                    
    pParams       - pointer to AUDIT_PARAMS structure to be initialized
                    the size of pParams->Parameters member must be big enough
                    to hold NumParams elements. The caller must allocate
                    memory for this structure and its members.

    ppUserSid     - pointer to user sid. This sid is referenced
                    by the first parameter (index 0) in AUDIT_PARAMS
                    structure.
                    If dwFlags contains the AUTHZP_INIT_PARAMS_SKIP_HEADER
                    flag, this parameter is completely ignored. 
                    If a NULL sid is passed in, the function will allocate
                    the sid. The caller should free this by calling LocalFree
                    *after* freeing the AUDIT_PARAMS structure.
                    If a non-NULL sid is passed in the function will just
                    use the passed-in value and not allocate anything..

    SubsystemName - name of Subsystem that is generating audit


    ap           - The format of the variable arg portion is as follows:
                    
                    <one of APT_ * flags> <zero or more values>

                    APT_String  <pointer to null terminated string>

                                Flags:
                                AP_Filespec  : treats the string as a filename
                    
                    APT_Ulong   <ulong value> [<object-type-index>]
                    
                                Flags:
                                AP_FormatHex : number appears in hex
                                               in eventlog
                                AP_AccessMask: number is treated as
                                               an access-mask
                                               Index to object type must follow

                    APT_Pointer <pointer/handle>
                                32 bit on 32 bit systems and
                                64 bit on 64 bit systems

                    APT_Sid     <pointer to sid>

                    APT_Luid    <Luid>
                    
                    APT_Guid    <pointer to guid>
                    
                    APT_LogonId [<logon-id>]
                    
                                Flags:
                                AP_PrimaryLogonId : logon-id is captured
                                                    from the process token.
                                                    No need to specify one.

                                AP_ClientLogonId  : logon-id is captured
                                                    from the thread token.
                                                    No need to specify one.
                                                    
                                no flags          : need to supply a logon-id

                    APT_ObjectTypeList <ptr to obj type list> <obj-type-index>
                                Index to object type must be specified

                    APT_Time    <filetime>

Return Value:
    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,
    which will be one of the following:

    ERROR_INVALID_PARAMETER if one of the params is incorrect
    

Notes:

--*/

{
    DWORD dwError = NO_ERROR;
    BOOL fResult = TRUE;
    USHORT i;
    AUDIT_PARAM_TYPE ParamType;
    AUDIT_PARAM* pParam;
    LUID Luid;
    LUID AuthIdThread = {0};
    LUID AuthIdProcess = {0};
    BOOL bGotTokenInfo = FALSE;
    BOOL bGotThreadTokenInfo = FALSE;
    BOOL fImpersonating=TRUE;
    FILETIME FileTime;
    ULONG TypeFlags;
    ULONG ParamFlags;
    ULONG ObjectTypeIndex;
    ULONG ObjectTypeIndexAdjustment = 0;
    PSID pUserSid = NULL;
    
    if (!FLAG_ON(dwFlags, AUTHZP_INIT_PARAMS_SKIP_HEADER))
    {
        //
        // the first two params are always fixed. thus the total number
        // is 2 + the passed number.
        //

        if (( (NumParams+AUTHZP_NUM_FIXED_HEADER_PARAMS) > SE_MAX_AUDIT_PARAMETERS ) ||
            ( pParams == NULL )                         ||
            ( ppUserSid == NULL )                       ||
            ( dwFlags & ~(APF_ValidFlags | AUTHZP_INIT_PARAMS_SOURCE_INFO | AUTHZP_INIT_PARAMS_SKIP_HEADER | AUTHZP_INIT_PARAMS_SOURCE_DS) )
            )
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (*ppUserSid == NULL)
        {
            if (!AuthzpGetThreadTokenInfo( &pUserSid, &AuthIdThread ))
            {
                dwError = GetLastError();

                if (dwError == ERROR_NO_TOKEN)
                {
                    fImpersonating = FALSE;
                    dwError = NO_ERROR;
                }
                else
                {
                    goto Cleanup;
                }
            }

            bGotThreadTokenInfo = TRUE;

            if (!fImpersonating)
            {
                if (!AuthzpGetProcessTokenInfo( &pUserSid, &AuthIdProcess ))
                {
                    dwError = GetLastError();
                    goto Cleanup;
                }

                bGotTokenInfo = TRUE;
            }
        }

        pParams->Length = 0;
        pParams->Count  = NumParams+AUTHZP_NUM_FIXED_HEADER_PARAMS;
        pParam = pParams->Parameters;
        pParams->Flags  = dwFlags & APF_ValidFlags; // strip out any flags that were intended for this API's
                                                    // consumption (AUTHZP_INIT_PARAMS_*)

        //
        // the first param is always the sid of the user in thread token
        // if thread is not impersonating, sid in the primary token is used.
        //

        pParam->Type    = APT_Sid;
        pParam->Data0   = (ULONG_PTR) (pUserSid ? pUserSid : *ppUserSid);

        pParam++;

        //
        // the second param is always the sub-system name "Security"
        //

        pParam->Type    = APT_String;
        if (FLAG_ON(dwFlags, AUTHZP_INIT_PARAMS_SOURCE_DS))
        {
            pParam->Data0   = (ULONG_PTR) L"DS";
        }
        else
        {
            pParam->Data0   = (ULONG_PTR) L"Security";
        }

        pParam++;

        //
        // Since we have prepended 2 parameters, any ObjectTypeIndex calculation
        // must reflect this offset.
        //

        ObjectTypeIndexAdjustment += 2;
    }
    else
    {
        //
        // We are not initializing the params with the first 2 params
        // as the SID and the Security string.
        //

        if (((NumParams+AUTHZP_NUM_FIXED_HEADER_PARAMS) > SE_MAX_AUDIT_PARAMETERS) ||
            (pParams == NULL)                         
            )
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        pParams->Length = 0;
        pParams->Count  = NumParams;
        pParam = pParams->Parameters;
        pParams->Flags  = dwFlags & APF_ValidFlags; // strip out any flags that were intended for this API's
                                                    // consumption (AUTHZP_INIT_PARAMS_*)
    }

    if (FLAG_ON(AUTHZP_INIT_PARAMS_SOURCE_INFO, dwFlags))
    {
        //                                             
        // Create information for eventlog to parse this event properly.
        // We prepend 4 parameters to the final AUDIT_PARAMS structure.
        //

        pParam->Type  = APT_String;
        pParam->Data0 = (ULONG_PTR) SubsystemName;
        pParams->Count++;
        pParam++;

        pParam->Type  = APT_Ulong;
        pParam->Data0 = (ULONG_PTR) AuditId;
        pParams->Count++;
        pParam++;

        //
        // Since we have prepended 2 parameters, any ObjectTypeIndex calculation
        // must reflect this offset.
        //

        ObjectTypeIndexAdjustment += 2;
    }

    //
    // now initialize the rest using the var-arg portion
    //

    for (i = 0; i < NumParams; i++, pParam++)
    {
        TypeFlags = va_arg(arglist, ULONG);

        ParamType  = ApExtractType(TypeFlags);
        ParamFlags = ApExtractFlags(TypeFlags);
        
        pParam->Type = ParamType;

        switch( ParamType )
        {
            default:
                dwError = ERROR_INVALID_PARAMETER;
                break;
                
            case APT_Pointer:
            case APT_String:
            case APT_Sid:
            case APT_Guid:
                pParam->Data0 = (ULONG_PTR) va_arg(arglist, PVOID);
                break;
                
            case APT_Ulong:
                pParam->Data0 = va_arg(arglist, ULONG);

                //
                // in case of an access-mask, store the object-type index
                // This is because, the meaning of the access-mask bits
                // cannot be determined without knowing the object type.
                //

                if (ParamFlags & AP_AccessMask)
                {
                    ObjectTypeIndex = va_arg(arglist, ULONG);
                    //
                    // The object-type-index:
                    // - must have been specified earlier
                    // - must be specified as a string.
                    //

                    if ( ( ObjectTypeIndex >= i ) ||
                         ( pParams->Parameters[ObjectTypeIndex].Type !=
                           APT_String ) )
                    {
                        dwError = ERROR_INVALID_PARAMETER;
                    }
                    else
                    {
                        pParam->Data1 = ObjectTypeIndex + ObjectTypeIndexAdjustment;
                    }
                }
                pParam->Flags   = ParamFlags;
                break;
            
            case APT_Luid:
                Luid = va_arg(arglist, LUID);
                pParam->Data0 = Luid.LowPart;
                pParam->Data1 = Luid.HighPart;
                break;
            
            case APT_LogonId:
                if (ParamFlags & AP_PrimaryLogonId)
                {
                    //
                    // use the captured process token info
                    //

                    if (!bGotTokenInfo)
                    {
                        if (!AuthzpGetProcessTokenInfo( 
                                 NULL, 
                                 &AuthIdProcess 
                                 ))
                        {
                            dwError = GetLastError();
                            goto Cleanup;
                        }
                        bGotTokenInfo = TRUE;
                    }
                    pParam->Data0 = AuthIdProcess.LowPart;
                    pParam->Data1 = AuthIdProcess.HighPart;
                }
                else if (ParamFlags & AP_ClientLogonId)
                {
                    //
                    // use the captured thread token info
                    //

                    if (!bGotThreadTokenInfo)
                    {
                        if (!AuthzpGetThreadTokenInfo(
                                NULL, 
                                &AuthIdThread
                                ))
                        {
                            dwError = GetLastError();

                            if (dwError == ERROR_NO_TOKEN)
                            {
                                fImpersonating = FALSE;
                                dwError = NO_ERROR;
                            }
                            else
                            {
                                goto Cleanup;
                            }
                        }

                        bGotThreadTokenInfo = TRUE;
                    }
                    pParam->Data0 = AuthIdThread.LowPart;
                    pParam->Data1 = AuthIdThread.HighPart;
                }
                else
                {
                    //
                    // no flag is specified, use the supplied logon-id
                    //

                    Luid = va_arg(arglist, LUID);
                    pParam->Data0 = Luid.LowPart;
                    pParam->Data1 = Luid.HighPart;
                }
                break;

            case APT_ObjectTypeList:
                pParam->Data0 = (ULONG_PTR) va_arg(arglist,
                                                   AUDIT_OBJECT_TYPES*);
                //
                // index of object type
                //
                pParam->Data1 = va_arg(arglist, ULONG) + ObjectTypeIndexAdjustment;
                break;

            case APT_Time:
                FileTime = va_arg(arglist, FILETIME);
                pParam->Data0 = FileTime.dwLowDateTime;
                pParam->Data1 = FileTime.dwHighDateTime;
                break;
        }

        if (dwError != NO_ERROR)
        {
            break;
        }
    }

Cleanup:

    if ( dwError != NO_ERROR )
    {
        SetLastError( dwError );
        fResult = FALSE;

        if (pUserSid) 
        {
            AuthzpFree(pUserSid);
        }
    }
    else
    {
        if (ppUserSid && *ppUserSid == NULL)
        {
            *ppUserSid = pUserSid;
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\authzp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    authzp.h

Abstract:

    Internal header file for authorization APIs.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/

#ifndef __AUTHZP_H__
#define __AUTHZP_H__

#define _AUTHZ_

#include <authz.h>
#include <authzi.h>

#if 0
#define AUTHZ_DEBUG       
#define AUTHZ_DEBUG_QUEUE 
#define AUTHZ_DEBUG_MEMLEAK
#else
#define AUTHZ_PARAM_CHECK
#define AUTHZ_AUDIT_COUNTER
#endif

#define AuthzpCloseHandleNonNull(h) if (NULL != (h)) { AuthzpCloseHandle((h)); }
#define AuthzpCloseHandle(h) CloseHandle((h))

//
// Size of the local stack buffer used to save a kernel call as well as a memory
// allocation.
//

#define AUTHZ_MAX_STACK_BUFFER_SIZE 1024

#ifndef AUTHZ_DEBUG_MEMLEAK

#define AuthzpAlloc(s) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (s))
#define AuthzpFree(p) LocalFree((p))

#else

//
// This is to be used for debugging memory leaks. Primitive method but works in
// a small project like this.
//

PVOID
AuthzpAlloc(IN DWORD Size);

VOID
AuthzpFree(PVOID l);

#endif

//
// Given two sids and length of the first sid, compare the two sids.
//

#define AUTHZ_EQUAL_SID(s, d, l) ((*((DWORD*) s) == *((DWORD*) d)) && (RtlEqualMemory((s), (d), (l))))

//
// Compares a given sids with a well known constant PrincipalSelfSid.
//

#define AUTHZ_IS_PRINCIPAL_SELF_SID(s) (RtlEqualMemory(pAuthzPrincipalSelfSid, (s), 12))

//
// The client context is restricted if the restricted sid and attribute array is
// present.
//

#define AUTHZ_TOKEN_RESTRICTED(t) (NULL != (t)->RestrictedSids)

//
// Two privileges are inportant for access check:
//     SeSecurityPrivilege
//     SeTakeOwnershipPrivilege
// Both these are detected at the time of client context capture from token
// and stored in the flags.
//

#define AUTHZ_PRIVILEGE_CHECK(t, f) (FLAG_ON((t)->Flags, (f)))

//
// Flags in the cached handle.
//

#define AUTHZ_DENY_ACE_PRESENT            0x00000001
#define AUTHZ_PRINCIPAL_SELF_ACE_PRESENT  0x00000002
#define AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT   0x00000004
#define AUTHZ_DYNAMIC_DENY_ACE_PRESENT    0x00000008
#define AUTHZ_DYNAMIC_EVALUATION_PRESENT  (AUTHZ_PRINCIPAL_SELF_ACE_PRESENT |  \
                                           AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT  |  \
                                           AUTHZ_DYNAMIC_DENY_ACE_PRESENT)

//
// There are only two valid attributes from access check point of view
//     SE_GROUP_ENABLED
//     SE_GROUP_USE_FOR_DENY_ONLY
//

#define AUTHZ_VALID_SID_ATTRIBUTES (SE_GROUP_ENABLED | SE_GROUP_USE_FOR_DENY_ONLY)

#ifdef FLAG_ON
#undef FLAG_ON
#endif

#define FLAG_ON(f, b) (0 != ((f) & (b)))

#ifdef AUTHZ_NON_NULL_PTR
#undef AUTHZ_NON_NULL_PTR
#endif

#define AUTHZ_NON_NULL_PTR(f) (NULL != (f))

//
// If the pointer is not null then free it. This will save us a function call in
// cases when the pointer is null. Note that LocalFree would also take care null
// pointer being freed.
//

#define AuthzpFreeNonNull(p) if (NULL != (p)) { AuthzpFree((p)); }

//
// Check to see if the memory allocation failed.
//

#define AUTHZ_ALLOCATION_FAILED(p) (NULL == (p))

//
// Macros to traverse the acl.
//     The first one gets the first ace in a given acl.
//     The second one gives the next ace given the current one.
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

//
// These do not need to be defined now since the decision was to put the burden
// on the resource managers. There are disadvantages of making it thread safe.
// Our choices are:
//     1. Have exactly one lock in authz.dll and suffer heavy contention.
//     2. Define one lock per client context which might be too expensive in
//        cases where the clients are too many.
//     3. Let the resource manager decide whether they need locking - unlikely
//        that locks are needed since it is wrong design on part of the RM to
//        have one thread that changes the client context while the other one
//        is doing an access check.
//

#define AuthzpAcquireClientContextWriteLock(c)
#define AuthzpAcquireClientContextReadLock(c)
#define AuthzpReleaseClientContextLock(c)

#define AuthzpAcquireClientCacheWriteLock(c)
#define AuthzpReleaseClientCacheLock(c)
#define AuthzpZeroMemory(p, s) RtlZeroMemory((p), (s))

#define AuthzObjectAceSid(Ace) \
    ((PSID)(((PUCHAR)&(((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + \
     (RtlObjectAceObjectTypePresent(Ace) ? sizeof(GUID) : 0 ) + \
     (RtlObjectAceInheritedObjectTypePresent(Ace) ? sizeof(GUID) : 0 )))

#define AuthzAceSid(Ace) ((PSID)&((PKNOWN_ACE)Ace)->SidStart)
    
#define AuthzCallbackAceSid(Ace) AuthzAceSid(Ace)

#define AuthzCallbackObjectAceSid(Ace) AuthzObjectAceSid(Ace)
                      
//
// Internal structure of the object type list.
//
// Level - Level of the element in the tree. The level of the root is 0.
// Flags - To be used for auditing. The valid ones are
//           AUTHZ_OBJECT_SUCCESS_AUDIT
//           AUTHZ_OBJECT_FAILURE_AUDIT
// ObjectType - Pointer to the guid for this element.
// ParentIndex - The index of the parent of this element in the array. The
//     parent index for the root is -1.
// Remaining - Remaining access bits for this element, used during normal access
//     check algorithm.
// CurrentGranted - Granted access bits so far for this element, used during
//     maximum allowed access check.
// CurrentDenied - Explicitly denied access bits for this element, used during
//     maximum allowed access check.
//

typedef struct _IOBJECT_TYPE_LIST {
    USHORT Level;
    USHORT Flags;
#define AUTHZ_OBJECT_SUCCESS_AUDIT 0x1
#define AUTHZ_OBJECT_FAILURE_AUDIT 0x2
    GUID ObjectType;
    LONG ParentIndex;
    ACCESS_MASK Remaining;
    ACCESS_MASK CurrentGranted;
    ACCESS_MASK CurrentDenied;
} IOBJECT_TYPE_LIST, *PIOBJECT_TYPE_LIST;

typedef struct _AUTHZI_AUDIT_QUEUE
{
    
    //
    // Flags defined in authz.h
    //

    DWORD Flags;

    //
    // High and low marks for the auditing queue
    //

    DWORD dwAuditQueueHigh;
    DWORD dwAuditQueueLow;

    //
    // CS for locking the audit queue
    //

    RTL_CRITICAL_SECTION AuthzAuditQueueLock;
    
    //
    // The audit queue and length.
    //

    LIST_ENTRY AuthzAuditQueue;
    ULONG AuthzAuditQueueLength;

    //
    // Handle to the thread that maintains the audit queue.
    //

    HANDLE hAuthzAuditThread;

    //
    // This event signals that an audit was placed on the queue.
    //

    HANDLE hAuthzAuditAddedEvent;

    //
    // This event signals that the queue is empty.  Initially signalled.
    //

    HANDLE hAuthzAuditQueueEmptyEvent;

    //
    // This boolean indicates that the queue size has reached the RM-specified high water mark.
    //

    BOOL bAuthzAuditQueueHighEvent;

    //
    // This event signals that the queue size is at or below the RM-specified low water mark.
    //

    HANDLE hAuthzAuditQueueLowEvent;

    //
    // This boolean is set to TRUE during the life of the resource manager.  When it turns to FALSE, the 
    // dequeue thread knows that it should exit.
    //

    BOOL bWorker;

} AUTHZI_AUDIT_QUEUE, *PAUTHZI_AUDIT_QUEUE;

typedef struct _AUTHZI_RESOURCE_MANAGER
{
    //
    // No valid flags have been defined yet.
    //

    DWORD Flags;

    //
    // Callback function registered by AuthzRegisterRMAccessCheckCallback, to be
    // used to interpret callback aces. If no such function is registered by the
    // RM then the default  behavior is to return TRUE for a deny ACE, FALSE for
    // a grant ACE.
    //

    PFN_AUTHZ_DYNAMIC_ACCESS_CHECK pfnDynamicAccessCheck;

    //
    // Callback function registered by AuthzRegisterDynamicGroupsCallback, to be
    // used to compute groups to be added to the client context. If no such
    // function is registered by the RM then the default behavior is to return
    // no groups.
    //

    PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups;

    //
    // Callback function registered by AuthzRegisterDynamicGroupsCallback, to be
    // used to free memory allocated by ComputeDynamicGroupsFn.
    //

    PFN_AUTHZ_FREE_DYNAMIC_GROUPS pfnFreeDynamicGroups;

    //
    // String name of resource manager.  Appears in audits.
    //

    PWSTR szResourceManagerName;

    //
    // The user SID and Authentication ID of the RM process
    //

    PSID pUserSID;
    LUID AuthID;

    //
    // Default queue and audit events for the RM
    //

#define AUTHZP_DEFAULT_RM_EVENTS        0x2

    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAETDS;

    AUTHZ_AUDIT_QUEUE_HANDLE hAuditQueue;

} AUTHZI_RESOURCE_MANAGER, *PAUTHZI_RESOURCE_MANAGER;


typedef struct _AUTHZI_CLIENT_CONTEXT AUTHZI_CLIENT_CONTEXT, *PAUTHZI_CLIENT_CONTEXT;
typedef struct _AUTHZI_HANDLE AUTHZI_HANDLE, *PAUTHZI_HANDLE;

//
// The authz code inserts two parmeters in the AUDIT_PARAM array
// before the user supplied parameters. The two parameters are:
// -- SID of the client context
// -- sub-system name (this is same as the RM name)
//
// To account for these two parameters, the authz code adds the following
// offset to variables that hold parameter count.
//

#define AUTHZP_NUM_FIXED_HEADER_PARAMS 2

//
// number of parameters in SE_AUDITID_OBJECT_OPERATION
//

#define AUTHZP_NUM_PARAMS_FOR_SE_AUDITID_OBJECT_OPERATION 12

//
// the number of sids that we hash is equal to 
// the number of  bits in AUTHZI_SID_HASH_ENTRY
//

#ifdef _WIN64_
typedef ULONGLONG AUTHZI_SID_HASH_ENTRY, *PAUTHZI_SID_HASH_ENTRY;
#else
typedef DWORD AUTHZI_SID_HASH_ENTRY, *PAUTHZI_SID_HASH_ENTRY;
#endif

#define AUTHZI_SID_HASH_ENTRY_NUM_BITS (8*sizeof(AUTHZI_SID_HASH_ENTRY))

//
// the hash size is not related to the number of bits. it is the size
// required to hold two 16 element arrays
//

#define AUTHZI_SID_HASH_SIZE 32

struct _AUTHZI_CLIENT_CONTEXT
{

    //
    // The client context structure is recursive to support delegated clients.
    // Not in the picture yet though.
    //

    PAUTHZI_CLIENT_CONTEXT Server;

    //
    // Context will always be created with Revision of AUTHZ_CURRENT_CONTEXT_REVISION.
    //

#define AUTHZ_CURRENT_CONTEXT_REVISION 1

    DWORD Revision;

    //
    // Resource manager supplied identifier. We do not ever use this.
    //

    LUID Identifier;

    //
    // AuthenticationId captured from the token of the client. Needed for
    // auditing.
    //

    LUID AuthenticationId;

    //
    // Token expiration time. This one will be checked at the time of access check against
    // the current time.
    //

    LARGE_INTEGER ExpirationTime;

    //
    // Internal flags for the token.
    //

#define AUTHZ_TAKE_OWNERSHIP_PRIVILEGE_ENABLED 0x00000001
#define AUTHZ_SECURITY_PRIVILEGE_ENABLED       0x00000002


    DWORD Flags;

    //
    // Sids used for normal access checks.
    //

    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
             
    AUTHZI_SID_HASH_ENTRY SidHash[AUTHZI_SID_HASH_SIZE];


    //
    // Sids used if the token is resticted. These will usually be 0 and NULL respectively.
    //

    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;

    AUTHZI_SID_HASH_ENTRY RestrictedSidHash[AUTHZI_SID_HASH_SIZE];
    
    //
    // Privileges used in access checks. Relevant ones are:
    //   1. SeSecurityPrivilege
    //   2. SeTakeOwnershipPrivilege
    // If there are no privileges associated with the client context then the PrivilegeCount = 0
    // and Privileges = NULL
    //

    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;

    //
    // Handles open for this client. When the client context is destroyed all the handles are
    // cleaned up.
    //

     PAUTHZI_HANDLE AuthzHandleHead;

    //
    // Pointer to the resource manager, needed to retrieve static auditing information.
    //

    PAUTHZI_RESOURCE_MANAGER pResourceManager;

};

struct _AUTHZI_HANDLE
{
    //
    // Pointers to the next handle maintained by the AuthzClientContext object.
    //

    PAUTHZI_HANDLE next;

    //
    // Pointer to the security descriptors provided by the RM at the time of first access
    // check call. We do not make a copy of the security descriptors. The assumption
    // is that the SDs will be valid at least as long as the the handle is open.
    //

    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray;
    DWORD OptionalSecurityDescriptorCount;

    //
    // Flags for internal usage only.
    //

    DWORD Flags;

    //
    // Back pointer to the client context that created this handle, required if the static
    // access granted is insufficient and access check needs to be performed again.
    //

    PAUTHZI_CLIENT_CONTEXT pAuthzClientContext;

    //
    // Results of the maximum allowed static access.
    //

    DWORD ResultListLength;
    ACCESS_MASK GrantedAccessMask[ANYSIZE_ARRAY];
};


//
// This structure stores per access audit information.  The structure
// is opaque and initialized with AuthzInitAuditInfo
//

typedef struct _AUTHZI_AUDIT_EVENT
{

    //
    // size of allocated blob for this structure
    //

    DWORD dwSize;

    //
    // Flags are specified in authz.h, and this single private flag for DS callers.
    //

    DWORD Flags;

    //
    // AuditParams used for audit if available.  If no AuditParams is available
    // and the audit id is SE_AUDITID_OBJECT_OPERATION then Authz will construct a
    // suitable structure.
    //

    PAUDIT_PARAMS pAuditParams;

    //
    // Structure defining the Audit Event category and id
    //

    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET;
    
    //
    // millisecond timeout value
    //

    DWORD dwTimeOut;

    //
    // RM specified strings describing this event.
    //

    PWSTR szOperationType;
    PWSTR szObjectType;
    PWSTR szObjectName;
    PWSTR szAdditionalInfo;
    PWSTR szAdditionalInfo2;

    AUTHZ_AUDIT_QUEUE_HANDLE hAuditQueue;

} AUTHZI_AUDIT_EVENT, *PAUTHZI_AUDIT_EVENT;

//
// structure to maintain queue of audits to be sent to LSA
//

typedef struct _AUTHZ_AUDIT_QUEUE_ENTRY
{
    LIST_ENTRY list;
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAAETO;
    DWORD Flags;
    AUDIT_PARAMS * pAuditParams;
    PVOID pReserved;
} AUTHZ_AUDIT_QUEUE_ENTRY, *PAUTHZ_AUDIT_QUEUE_ENTRY;

//
// Enumeration type to be used to specify what type of coloring should be
// passed on to the rest of the tree starting at a given node.
//   Deny gets propagted down the entire subtree as well as to all the
//     ancestors (but NOT to siblings and below)
//   Grants get propagated down the subtree. When a grant exists on all the
//     siblings the parent automatically gets it.
//   Remaining is propagated downwards. The remaining on the parent is a
//     logical OR of the remaining bits on all the children.
//

typedef enum {
    AuthzUpdateRemaining = 1,
    AuthzUpdateCurrentGranted,
    AuthzUpdateCurrentDenied
} ACCESS_MASK_FIELD_TO_UPDATE;

//
// Enumeration type to be used to specify the kind of well known sid for context
// changes. We are not going to support these unless we get a requirement.
//

typedef enum _AUTHZ_WELL_KNOWN_SID_TYPE
{
    AuthzWorldSid = 1,
    AuthzUserSid,
    AuthzAdminSid,
    AuthzDomainAdminSid,
    AuthzAuthenticatedUsersSid,
    AuthzSystemSid
} AUTHZ_WELL_KNOWN_SID_TYPE;

BOOL
AuthzpVerifyAccessCheckArguments(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults OPTIONAL
    );

BOOL
AuthzpVerifyOpenObjectArguments(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent
    );

BOOL
AuthzpCaptureObjectTypeList(
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeLocalTypeListLength,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL
    );

VOID
AuthzpFillReplyStructure(
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN DWORD Error,
    IN ACCESS_MASK GrantedAccess
    );

BOOL
AuthzpMaximumAllowedAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    OUT PDWORD pCachingFlags
    );

BOOL
AuthzpMaximumAllowedMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    IN BOOL Restricted,
    OUT PDWORD pCachingFlags
    );

BOOL
AuthzpMaximumAllowedSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pHash,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    OUT PDWORD pCachingFlags
    );


BOOL
AuthzpSidApplicable(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PAUTHZI_SID_HASH_ENTRY pHash,
    IN PSID pSid,
    IN PSID PrincipalSelfSid,
    IN PSID CreatorOwnerSid,
    IN BOOL DenyAce,
    OUT PDWORD pCachingFlags
    );

BOOL
AuthzpAccessCheckWithCaching(
    IN DWORD Flags,
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults OPTIONAL,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpNormalAccessCheckWithoutCaching(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpNormalMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpOwnerSidInClientContext(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PISECURITY_DESCRIPTOR pSecurityDescriptor
    );

BOOL
AuthzpNormalAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpQuickMaximumAllowedAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpQuickNormalAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpAllowOnlyNormalMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpAllowOnlyNormalSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpAllowOnlySidApplicable(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PSID pSid
    );


VOID
AuthzpAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
    );

BOOL
AuthzpObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    OUT PDWORD ReturnedIndex
    );

BOOL
AuthzpCacheResults(
    IN DWORD Flags,
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PIOBJECT_TYPE_LIST LocalCachingTypeList,
    IN DWORD LocalTypeListLength,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN DWORD CachingFlags,
    IN PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults
    );


BOOL
AuthzpVerifyCachedAccessCheckArguments(
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply
    );

BOOL
AuthzpAllowOnlyMaximumAllowedMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    IN BOOL Restricted
    );

BOOL
AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent
    );

VOID
AuthzpAddAccessTypeList (
    IN OUT PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
    );

VOID
AuthzpUpdateParentTypeList(
    IN OUT PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex
    );

BOOL
AuthzpObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    OUT PDWORD ReturnedIndex
    );


BOOL
AuthzpGenerateAudit(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList
    );

BOOL
AuthzpCopySidsAndAttributes(
    IN OUT PSID_AND_ATTRIBUTES DestSidAttr,
    IN PSID_AND_ATTRIBUTES SidAttr1,
    IN DWORD Count1,
    IN PSID_AND_ATTRIBUTES SidAttr2,
    IN DWORD Count2
    );

VOID
AuthzpCopyLuidAndAttributes(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PLUID_AND_ATTRIBUTES Source,
    IN DWORD Count,
    IN OUT PLUID_AND_ATTRIBUTES Destination
    );

BOOL
AuthzpDefaultAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    );

VOID
AuthzPrintContext(
    IN PAUTHZI_CLIENT_CONTEXT pCC
    );

VOID
AuthzpFillReplyFromParameters(
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN PIOBJECT_TYPE_LIST LocalTypeList
    );

BOOL
AuthzpGetAllGroupsBySid(
    IN  PSID pUserSid,
    IN  DWORD Flags,
    OUT PSID_AND_ATTRIBUTES *ppSidAttr,
    OUT PDWORD pSidCount,
    OUT PDWORD pSidLength
    );

BOOL
AuthzpGetAllGroupsByName(
    IN  PUNICODE_STRING pusUserName,
    IN  PUNICODE_STRING pusDomainName,
    IN  DWORD Flags,
    OUT PSID_AND_ATTRIBUTES *ppSidAttr,
    OUT PDWORD pSidCount,
    OUT PDWORD pSidLength
    );

BOOL
AuthzpAllocateAndInitializeClientContext(
    OUT PAUTHZI_CLIENT_CONTEXT *ppCC,
    IN PAUTHZI_CLIENT_CONTEXT Server,
    IN DWORD Revision,
    IN LUID Identifier,
    IN LARGE_INTEGER ExpirationTime,
    IN DWORD Flags,
    IN DWORD SidCount,
    IN DWORD SidLength,
    IN PSID_AND_ATTRIBUTES Sids,
    IN DWORD RestrictedSidCount,
    IN DWORD RestrictedSidLength,
    IN PSID_AND_ATTRIBUTES RestrictedSids,
    IN DWORD PrivilegeCount,
    IN DWORD PrivilegeLength,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN LUID AuthenticationId,
    IN PAUTHZI_HANDLE AuthzHandleHead,
    IN PAUTHZI_RESOURCE_MANAGER pRM
    );

BOOL
AuthzpAddDynamicSidsToToken(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_RESOURCE_MANAGER pRM,
    IN PVOID DynamicGroupsArgs,
    IN PSID_AND_ATTRIBUTES Sids,
    IN DWORD SidLength,
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES RestrictedSids,
    IN DWORD RestrictedSidLength,
    IN DWORD RestrictedSidCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN DWORD PrivilegeLength,
    IN DWORD PrivilegeCount,
    IN BOOL bAllocated
    );

BOOL
AuthzpExamineSingleSacl(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN ACCESS_MASK AccessMask,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN UCHAR AuditMaskType,
    IN BOOL bMaximumFailed,
    OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PBOOL pbGenerateAudit
    );

BOOL
AuthzpExamineSacl(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN PAUTHZ_ACCESS_REPLY pReply,
    OUT PBOOL pbGenerateAudit
    );


BOOL
AuthzpExamineSaclForObjectTypeList(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    );

BOOL
AuthzpExamineSingleSaclForObjectTypeList(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    );

VOID
AuthzpSetAuditInfoForObjectType(
    IN PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD StartIndex,
    IN ACCESS_MASK AceAccessMask,
    IN ACCESS_MASK DesiredAccessMask,
    IN UCHAR AceFlags,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    );

BOOL
AuthzpCreateAndLogAudit(
    IN DWORD AuditTypeFlag,
    IN PAUTHZI_CLIENT_CONTEXT pAuthzClientContext,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent,
    IN PAUTHZI_RESOURCE_MANAGER pRM,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PAUTHZ_ACCESS_REPLY pReply
    );

VOID
AuthzpFillReplyStructureFromCachedGrantedAccessMask(
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_MASK GrantedAccessMask
    );

BOOL
AuthzpSendAuditToLsa(
    IN AUDIT_HANDLE  hAuditContext,
    IN DWORD         Flags,
    IN PAUDIT_PARAMS pAuditParams,
    IN PVOID         Reserved
    );

BOOL
AuthzpEnQueueAuditEvent(
    PAUTHZI_AUDIT_QUEUE pQueue,
    PAUTHZ_AUDIT_QUEUE_ENTRY pAudit
    );

BOOL
AuthzpEnQueueAuditEventMonitor(
    PAUTHZI_AUDIT_QUEUE pQueue,
    PAUTHZ_AUDIT_QUEUE_ENTRY pAudit
    );

BOOL
AuthzpMarshallAuditParams(
    OUT PAUDIT_PARAMS * ppMarshalledAuditParams,
    IN  PAUDIT_PARAMS   pAuditParams
    );

ULONG
AuthzpDeQueueThreadWorker(
    LPVOID lpParameter
    );

#define AUTHZ_SID_HASH_LOW_MASK 0xf
#define AUTHZ_SID_HASH_HIGH_MASK 0xf0
#define AUTHZ_SID_HASH_HIGH 16
#define AUTHZ_SID_HASH_LOOKUP(table, byte) (((table)[(byte) & 0xf]) & ((table)[AUTHZ_SID_HASH_HIGH + (((byte) & 0xf0) >> 4)]))
    
VOID
AuthzpInitSidHash(
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN ULONG SidCount,
    OUT PAUTHZI_SID_HASH_ENTRY pHash
    );

BOOL
AuthzpGetThreadTokenInfo(
    OUT PSID* pUserSid,
    OUT PLUID pAuthenticationId
    );

BOOL
AuthzpGetProcessTokenInfo(
    OUT PSID* ppUserSid,
    OUT PLUID pAuthenticationId
    );

VOID
AuthzpReferenceAuditEventType(
    IN AUTHZ_AUDIT_EVENT_TYPE_HANDLE
    );
BOOL
AuthzpDereferenceAuditEventType(
    IN OUT AUTHZ_AUDIT_EVENT_TYPE_HANDLE
    );

BOOL
AuthzpEveryoneIncludesAnonymous(
    );

BOOL
AuthzpComputeSkipFlagsForWellKnownSid(
    IN PSID UserSid,
    OUT PDWORD Flags
    );

BOOL
AuthzpConstructPolicyPerUserAuditing(
    IN     ULONGLONG           RawPolicy,
    OUT    PTOKEN_AUDIT_POLICY pTokenPolicy,
    IN OUT PULONG              TokenPolicyLength
    );

BOOL
AuthzpConstructRegistryPolicyPerUserAuditing(
    IN PTOKEN_AUDIT_POLICY pPolicy,
    OUT PULONGLONG pRegPolicy
    );


#define AUTHZP_INIT_PARAMS_SKIP_HEADER 0x2
#define AUTHZP_INIT_PARAMS_SOURCE_INFO 0x4
#define AUTHZP_INIT_PARAMS_SOURCE_DS   0x8

#define AUTHZP_PARAM_FREE_SID          0x80000000

AUTHZAPI    
BOOL
WINAPI
AuthzpInitializeAuditParamsV(
    IN     DWORD         dwFlags,
    OUT    PAUDIT_PARAMS pParams,
    IN OUT PSID*         ppUserSid,
    IN     PCWSTR        SubsystemName,
    IN     USHORT        AuditId,
    IN     USHORT        NumParams,
    IN     va_list       arglist
    );

BOOL
AuthzpRegisterAuditEvent(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT PAUDIT_HANDLE     phAuditContext
    );

BOOL
AuthzpUnregisterAuditEvent(
    IN OUT AUDIT_HANDLE* phAuditContext
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\makefile.inc ===
PRIVLIB= $(O)\authzi.lib
$(O)\authz.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\authzi.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\authzi.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\authzi.def: authz.def
    $(C_PREPROCESSOR) $** -DPRIVATE= > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\adlconvert.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adlconvert.cpp

Abstract:

   The routines to convert between AdlStatement, string in the ADL
   language, and a DACL.
   
Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created                 - August 2000
    Semantics finalized     - September 2000

--*/

#include "adl.h"
#include "adlconvert.h"


void AdlStatement::ConvertFromDacl(IN const PACL pDacl)
/*++

Routine Description:

    Traverses the given ACL, and creates an AdlStatement structure
    representative of the DACL.
    
    Algorithm:
    
    First, break up the ACL into 32 stacks, by access mask bits, keeping
    track of the inheritance and SID.
    
    Then use the heuristic algorithm in ConvertStacksToPops to get a 'good'
    (though not necessarily optimal) sequence of stack pops to perform so as
    to produce the optimal set of ADL statements for the DACL.
    
    Finally, perform the sequence of pops and create the ADL statement.
    
    
Arguments:

    pDacl   -       The DACL to convert to an AdlStatement
    
Return Value:

    none
    
--*/
{
    
    DWORD dwIdx;

    DWORD dwIdxElems;
    
    AdlToken *pTok = NULL;
    
    AdlStatement::ADL_ERROR_TYPE adlErr = AdlStatement::ERROR_NO_ERROR;

    //
    // The stack representation of a DACL
    //

    DWORD pdwStackTop[32];
    DWORD pdwStackSize[32];
    PBIT_STACK_ELEM pStacks[32];


    //
    // Mappings from PSID to AdlToken of the name string and from
    // pointer into the user-specified language def to the appropriate
    // permission token. This allows reuse of name and permission tokens
    //
    
    map<const PSID, const AdlToken *> mapSidName;
    map<const WCHAR *, const AdlToken *> mapStringTok;

    //
    // list of pairs <Stack mask, Block Size>, which define the set of pops
    // to perform. This is filled in by the decision algorithm. For every
    // bit set in the stack mask, a block of the given size will be popped
    // into ADL from the stack.
    //

    list<pair<DWORD, DWORD> > listPops;
    list<pair<DWORD, DWORD> >::iterator iterPops;
    list<pair<DWORD, DWORD> >::iterator iterPopsEnd;

    //
    // List of permissions for a given access mask, used as output
    // by the access mask -> set of names lookup
    // 

    list<WCHAR *> lPermissions;
    list<WCHAR *>::iterator iterPerm;
    list<WCHAR *>::iterator iterPermEnd;

    //
    // Initialize the stacks
    //

    for( dwIdx = 0; dwIdx < 32; dwIdx++ )
    {
        pdwStackSize[dwIdx] = 0;
        pdwStackTop[dwIdx] = 0;
        pStacks[dwIdx] = NULL;
    }
    
    //
    // First look up all names. If some names don't exist, save time
    // by not doing the rest of the conversion below
    //

    ConvertSidsToNames(pDacl, &mapSidName);

    //
    // Now convert the ACL to the set of 32 stacks (this needs to be freed
    // later)
    //

    ConvertDaclToStacks(pDacl, _pControl, pdwStackSize, pStacks);

    //
    // A bit of pre-processing: we will need a map from WCHAR * to
    // AdlToken *, so as to reuse AdlTokens for the same permission
    // name. The tokens will be garbage-collected later.
    //

    try
    {
        for( dwIdx = 0; _pControl->pPermissions[dwIdx].str != NULL; dwIdx++ )
        {
            pTok = new AdlToken(_pControl->pPermissions[dwIdx].str, 0, 0);

            try
            {
                AddToken(pTok);
            }
            catch(exception)
            {
                delete pTok;
                throw AdlStatement::ERROR_OUT_OF_MEMORY;
            }

            mapStringTok[_pControl->pPermissions[dwIdx].str] = pTok;
        }

    }
    catch(exception)
    {
        adlErr = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }

    //
    // Now we are ready to actually convert the stacks into an ADL statement
    // First we run the recursive algorithm to determine the sequence of 
    // pop operations on the stacks
    //

    try
    {
        ConvertStacksToPops(_pControl,
                            pStacks,
                            pdwStackSize,
                            pdwStackTop,
                            &listPops);
    }
    catch(exception)
    {
        adlErr = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }
    catch(AdlStatement::ADL_ERROR_TYPE err)
    {
        adlErr = err;
        goto error;
    }

    //
    // Now we perform the calculated pops
    //

    try
    {
        //
        // Go through the pops in order, and perform them
        //

        DWORD dwStacksPopped;
        DWORD dwBlockSize;

        for( iterPops = listPops.begin(), iterPopsEnd = listPops.end();
             iterPops != iterPopsEnd;
             iterPops++ )
        {
            dwStacksPopped = (*iterPops).first;
            dwBlockSize = (*iterPops).second;

            ASSERT( dwStacksPopped > 0 );
            ASSERT( dwBlockSize > 0 );

            // 
            // Create new ADL statement
            //

            Next();

            //
            // Set permissions once, mask is same as stacks popped
            //

            lPermissions.erase(lPermissions.begin(), lPermissions.end());

            MapMaskToStrings(dwStacksPopped, &lPermissions);

            for( iterPerm = lPermissions.begin(),
                    iterPermEnd = lPermissions.end();
                 iterPerm != iterPermEnd;
                 iterPerm++ )
            {
                Cur()->AddPermission(mapStringTok[*iterPerm]);
            }

            //
            // Now find the first stack with the block in question
            // 

            for( dwIdx = 0; dwIdx < 32; dwIdx++ )
            {
                if( dwStacksPopped & ( 0x00000001 << dwIdx ) )
                {
                    break;
                }
            }

            //
            // Add the Principals, ExPrincipals, and inheritance flags
            // to the ADL statement. The blocks should all be the same,
            // so first block is sufficient
            //

            //
            // First the inheritance flags
            //

            Cur()->OverwriteFlags(pStacks[dwIdx][pdwStackTop[dwIdx]].dwFlags);

            //
            // Now the principals and exprincipals
            //

            for( dwIdxElems = 0; dwIdxElems < dwBlockSize; dwIdxElems++ )
            {

                if(     pStacks[dwIdx][pdwStackTop[dwIdx]+dwIdxElems].bAllow
                    ==  FALSE )
                {
                    Cur()->AddExPrincipal(
                        mapSidName[ 
                                  pStacks[dwIdx][pdwStackTop[dwIdx] + dwIdxElems
                                   ].pSid]);
                }
                else
                {
                    Cur()->AddPrincipal(
                        mapSidName[ 
                                  pStacks[dwIdx][pdwStackTop[dwIdx] + dwIdxElems
                                   ].pSid]);
                }
            }

            //
            // Finally, move the tops of the stacks down to get rid of the
            // popped items
            //


            for( dwIdx = 0; dwIdx < 32; dwIdx++ )
            {
                if( dwStacksPopped & ( 0x00000001 << dwIdx ) )
                {
                    pdwStackTop[dwIdx] += dwBlockSize;
                    ASSERT(pdwStackTop[dwIdx] <= pdwStackSize[dwIdx]);
                }
            }
        }
    }
    catch(exception)
    {
        adlErr = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }
    catch(AdlStatement::ADL_ERROR_TYPE err)
    {
        adlErr = err;
        goto error;
    }



    error:;

    if( pStacks[0] != NULL )
    {
        //
        // Free the chunk of memory allocated by the converion
        //

        FreeMemory(pStacks[0]);
    }

    if( adlErr != AdlStatement::ERROR_NO_ERROR )
    {
        throw adlErr;
    }
    
}



////////////////////////////////////////////////////////////////////////////////
/////////////
///////////// DACL -> ADL conversion algorithm
/////////////
////////////////////////////////////////////////////////////////////////////////


void ConvertStacksToPops(
                        IN      const PADL_PARSER_CONTROL pControl,
                        IN      const PBIT_STACK_ELEM pStacks[32],
                        IN      const DWORD pdwStackSize[32],
                        IN      const DWORD pdwStackTop[32],
                        OUT     list< pair<DWORD, DWORD> > * pListPops
                        )
/*++

Routine Description:

    Recursive heuristic to determine the 'good' conversion from ACL to ADL.
    Not necessarily optimal, but computationally feasible. 
    
    This finds a sequence of pops which will empty the 32 per-bit stacks
    while trying to reduce the number of ADL statements output.
    
    Stacks are empty when the stack tops reach the stack ends.
    
    Algorithm:
    
    ---------
    While stacks are not empty:
        FindOptimalPop with given stack ends
        Set temporary stack sizes to the offsets for the optimal pop
        ConvertStacksToPops on the temporary stack ends
        Store the calculated optimal pop in pListPops
        Perform the optimal pops off the stacks
    Endwhile
    ---------
    
    For empty stacks, this just returns.
    
    The output offsets from FindOptimalPop work as temporary stack sizes,
    since everything ebove that must be popped off.
    
    WARNING: This is recursive, and uses 268 bytes of stack for locals. 
    Therefore, a large worst-case ACL will blow the stack (if the recursion
    is near the bottom of the stack at every step). Once ADL goes into OS,
    this recursion can be rewritten as iteration by keeping a stack of the 
    StackTop and StackSize in the heap instead of locals, as a finite-state
    stack machine.
    
Arguments:
    
    pControl        -   The ADL parser spec, used for determining the number
                        of strings it will take to express a permission
    
    pStacks         -   The stack representation of the DACL
    
    pdwStackSize    -   These are offsets to 1 past the last element in the
                        stacks which should be considered
                        
    pdwStackTop     -   These are offsets to the tops of the stacks to be
                        considered
                        
    pListPops       -   The STL list containing the sequence of pop operations
                        to be performed, new pops are appended to this
    
Return Value:

    none
        
--*/

{
    DWORD pdwTmpStackTop[32];

    DWORD pdwTmpStackSize[32];

    DWORD dwIdx;

    DWORD dwStacksPopped;

    DWORD dwBlockSize;

    //
    // Start with top of given stack
    //

    for( dwIdx = 0; dwIdx < 32; dwIdx++ )
    {
        pdwTmpStackTop[dwIdx] = pdwStackTop[dwIdx];
    }

    // 
    // Stacks are empty when the top of each stack points to 1 past the end
    // Therefore, we can just use a memory compare on the tops array and
    // the stack sizes to check. Empty stacks have 0 size and top offset.
    //

    while( memcmp(pdwStackSize, pdwTmpStackTop, sizeof(DWORD) * 32) )
    {
        //
        // The loop should end on empty stacks. Therefore, if this fails, 
        // we have an internal error. Otherwise, we have our optimal pop.
        //

        if( FALSE == FindOptimalPop(
                                pControl,
                                pStacks,
                                pdwStackSize,
                                pdwTmpStackTop,
                                &dwStacksPopped,
                                &dwBlockSize,
                                pdwTmpStackSize
                                ) )
        {
            throw AdlStatement::ERROR_FATAL_ACL_CONVERT_ERROR;
        }

        //
        // Now recurse, and pop off everything ABOVE the optimal pop
        //
        
        ConvertStacksToPops(
                            pControl,
                            pStacks,
                            pdwTmpStackSize,
                            pdwTmpStackTop,
                            pListPops
                            );
        

        

        //
        // Add the optimal pop to the list
        //

        pListPops->push_back(pair<DWORD, DWORD>(dwStacksPopped, dwBlockSize));

        //
        // Now update the tops of the stacks by lowering the tops by
        // the block size
        //
        
        for( dwIdx = 0; dwIdx < 32; dwIdx++ )
        {
            if( (0x00000001 << dwIdx) & dwStacksPopped )
            {
                //
                // By now we have removed everything ebove the optimal pop, and
                // the optimal pop itself. Therefore, go dwBlockSize past the
                // beginning of the optimal pop. Stacks other than those 
                // involved in the optimal pop cannot be effected.
                //

                pdwTmpStackTop[dwIdx] = pdwTmpStackSize[dwIdx] + dwBlockSize;
            }
        }
    }
}



BOOL FindBlockInStack(
                        IN      const PBIT_STACK_ELEM pBlock,
                        IN      const DWORD dwBlockSize,
                        IN      const PBIT_STACK_ELEM pStack,
                        IN      const DWORD dwStackSize,
                        IN      const DWORD dwStackTop,
                        OUT     PDWORD pdwBlockStart
                        )
/*++

Routine Description:

    Attempts to locate the first block of dwBlockSize which matches a block
    of the same size at pBlock in the given stack pStack, between dwStackTop
    and dwStackSize - 1. If successful, start offset of the block is stored in
    pdwBlockStart.
    
Arguments:

    pBlock          -   A single block (see GetBlockSize for definition)
                        for which to look for in pStack
                        
    dwBlockSize     -   The number of elements composing this block
    
    pStack          -   The stack in which to look for pBlock
    
    dwStackSize     -   Offset to 1 past the last element in the stack to
                        consider
                        
    dwStackTop      -   Offset to the effective beginning of the stack
    
    pdwBlockStart   -   If successful, offset to the beginning of the
                        found block is returned in this.                        
    
Return Value:

    TRUE if block found
    FALSE otherwise, in which case *pdwBlockStart is undefined
    
--*/
{
    //
    // States used by this function
    //

#define TMP2_NO_MATCH_STATE 0
#define TMP2_MATCH_STATE 1

    DWORD dwState = TMP2_NO_MATCH_STATE;

    DWORD dwMatchStartIdx;
    DWORD dwIdxStack;
    DWORD dwIdxBlock;

    ASSERT( dwBlockSize > 0 );
    ASSERT( dwStackTop <= dwStackSize );
    
    for( dwIdxStack = dwStackTop, dwIdxBlock = 0;
         dwIdxStack < dwStackSize;
         dwIdxStack++ )
    {
        switch(dwState)
        {
        case TMP2_NO_MATCH_STATE:

            //
            // If the remaining stack is smaller than the block, no need to 
            // check further
            //
        
            if( dwStackSize - dwIdxStack < dwBlockSize )
            {
                return FALSE;
            }
            
            //
            // Check for match start
            //

            if(     pStack[dwIdxStack].bAllow == pBlock[dwIdxBlock].bAllow
                &&  pStack[dwIdxStack].dwFlags == pBlock[dwIdxBlock].dwFlags
                &&  EqualSid(pStack[dwIdxStack].pSid, pBlock[dwIdxBlock].pSid) )
            {
                //
                // Special case: block size 1
                //

                if( dwBlockSize == 1 )
                {
                    *pdwBlockStart = dwIdxStack;
                    return TRUE;
                }
                else
                {
                    dwState = TMP2_MATCH_STATE;
                    dwMatchStartIdx = dwIdxStack;
                    dwIdxBlock++;
                }
            }
            break;
        
        case TMP2_MATCH_STATE:
            
            //
            // If still matched
            //

            if(     pStack[dwIdxStack].bAllow == pBlock[dwIdxBlock].bAllow
                &&  pStack[dwIdxStack].dwFlags == pBlock[dwIdxBlock].dwFlags
                &&  EqualSid(pStack[dwIdxStack].pSid, pBlock[dwIdxBlock].pSid) )
            {
                dwIdxBlock++;

                //
                // Check for complete match
                //

                if( dwIdxBlock == dwBlockSize )
                {
                    *pdwBlockStart = dwMatchStartIdx;
                    return TRUE;
                }

            }
            else
            {
                //
                // Backtrack to the match start
                //

                dwState = TMP2_NO_MATCH_STATE;
                dwIdxBlock = 0;
                dwIdxStack = dwMatchStartIdx;
            }
            break;
            
        default:
            throw AdlStatement::ERROR_FATAL_ACL_CONVERT_ERROR;
            break;
        }
    }

    //
    // If never matched whole block, return FALSE
    //

    return FALSE;

}


BOOL FindOptimalPop(
                        IN      const PADL_PARSER_CONTROL pControl,
                        IN      const PBIT_STACK_ELEM pStacks[32],
                        IN      const DWORD pdwStackSize[32],
                        IN      const DWORD pdwStackTop[32],
                        OUT     PDWORD pdwStacksPopped,
                        OUT     PDWORD pdwBlockSize,
                        OUT     DWORD pdwPopOffsets[32]
                        )
/*++

Routine Description:

    Attempts to locate the greedy-choice optimal set of blocks to pop off.
    Returns the optimal choice in the OUT values on success.
    
    The weight function can be tweaked, and may allow negative values, however
    the value of popping a single stack off the top MUST be positive.
    
    Uses this algorithm:
    -----------
    Start with weight 0
    For every non-empty stack:
        Get top block of stack
        Search all stacks for this block
        Compute the weight of this solution based on block size and # of stacks
        If the weight is greater than the current best weight:
            store the new weight as best weight
            store the new solution as best solution
        Endif
    Endfor
    If weight > 0
        Return the current best solution
    Else
        Report failure
    Endif
    -----------
    
Arguments:

    pControl        -   The ADL parser spec, used for determining the number
                        of strings it will take to express a permission
    
    pStacks         -   The stack representation of the DACL
    
    pdwStackSize    -   These are offsets to 1 past the last element in the
                        stacks which should be considered
                        
    pdwStackTop     -   These are offsets to the tops of the stacks to be
                        considered
                        
    pdwStacksPopped -   Bitmask for which stacks will be popped, stacks which
                        are effected by this pop have the appropriate bit set
    
    pdwBlockSize    -   The size of the block (same for all effected stacks) to
                        be popped is returned through this.
                        
    pdwPopOffsets   -   The start offsets of the blocks to pop are returned here
    
Return Value:

    TRUE on success, if a pop with weight > 0 has been found
    FALSE otherwise, in which case OUT values are undefined
    
--*/
{

    DWORD dwIdxStacks1;
    DWORD dwIdxStacks2;

    //
    // Initial optimal solution
    //

    LONG iCurrentWeight = 0;

    
    
    //
    // Current solution
    //

    LONG iTempWeight;

    DWORD dwTempStacksPopped;
    DWORD dwTempBlockSize;
    DWORD pdwTempPops[32];

    DWORD dwBlockOffset;


    //
    // Try the block at the top of every stack
    //

    for( dwIdxStacks1 = 0; dwIdxStacks1 < 32; dwIdxStacks1++ )
    {
        //
        // Skip empty stacks
        //

        if( pdwStackSize[dwIdxStacks1] == pdwStackTop[dwIdxStacks1] )
        {
            continue;
        }


        dwTempBlockSize = GetStackBlockSize(pStacks[dwIdxStacks1],
                                        pdwStackTop[dwIdxStacks1],
                                        pdwStackSize[dwIdxStacks1]);


        //
        // If a block size of 0 is detected in a non-empty stack, then
        // this is not expressable in ADL, throw the error here
        //

        if( dwTempBlockSize == 0 )
        {
            throw AdlStatement::ERROR_INEXPRESSIBLE_ACL;
        }

        //
        // The initial weight is 0, since loop will account for top loop stack
        // Same with initial stacks popped
        //

        iTempWeight = 0;
        dwTempStacksPopped = 0;

        //
        // Now, try to find this block in all stacks
        //

        for( dwIdxStacks2 = 0; dwIdxStacks2 < 32; dwIdxStacks2++ )
        {

            //
            // Fist assume pop location is at the top (no pop),
            // even for empty stacks
            //

            pdwTempPops[dwIdxStacks2] = pdwStackTop[dwIdxStacks2];

            
            //
            // Skip empty stacks
            //

            if( ! (pdwStackSize[dwIdxStacks2] - pdwStackTop[dwIdxStacks2] > 0) )
            {
                continue;
            }

            if( TRUE == FindBlockInStack(
                            &(pStacks[dwIdxStacks1][pdwStackTop[dwIdxStacks1]]),
                            dwTempBlockSize,
                            pStacks[dwIdxStacks2],
                            pdwStackSize[dwIdxStacks2],
                            pdwStackTop[dwIdxStacks2],
                            &dwBlockOffset) )
            {
                //
                // Block was found in this stack
                //

                pdwTempPops[dwIdxStacks2] = dwBlockOffset;
                dwTempStacksPopped |= ( 0x00000001 << dwIdxStacks2);

            }
        }

        //
        // Calculate the weight of this solution
        //

        //
        // Weight for number of principals expressed
        //

        iTempWeight += (WEIGHT_STACK_HEIGHT) * dwTempBlockSize;

        //
        // Weights for each bit
        // also weights (or penalties) for having to pop things
        // off above the optimal pop
        //

        for( dwIdxStacks2 = 0; dwIdxStacks2 < 32; dwIdxStacks2++ )
        {
            if( dwTempStacksPopped & ( 0x00000001 << dwIdxStacks2 ) )
            {
                iTempWeight += (WEIGHT_PERM_BIT);

                iTempWeight +=   (WEIGHT_ITEM_ABOVE_POP)
                               * (   pdwTempPops[dwIdxStacks2]
                                   - pdwStackTop[dwIdxStacks2] );
                                 
                
            }
        }

        //
        // Finally the weight/penalty for number of permission names
        // needed beyond the 1st one
        //

        iTempWeight +=   (WEIGHT_PERMISSION_NAME) 
                       * (NumStringsForMask(pControl, dwTempStacksPopped) - 1 );
        

        //
        // If this solution is better than the best so far, save it
        //

        if( iTempWeight > iCurrentWeight )
        {
            iCurrentWeight = iTempWeight;

            *pdwStacksPopped = dwTempStacksPopped;

            *pdwBlockSize = dwTempBlockSize;

            for( dwIdxStacks2 = 0; dwIdxStacks2 < 32; dwIdxStacks2++ )
            {
                pdwPopOffsets[dwIdxStacks2] = pdwTempPops[dwIdxStacks2];
            }
        }
    }

    //
    // If we have not found any solution, we were passed an empty set of stacks
    // Otherwise, the optimal solution is already in the OUT values
    //

    if( iCurrentWeight > 0 )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}



void ConvertDaclToStacks(
                        IN      const PACL pDacl,
                        IN      const PADL_PARSER_CONTROL pControl,
                        OUT     DWORD pdwStackSize[32],
                        OUT     PBIT_STACK_ELEM pStacks[32]
                        )
/*++

Routine Description:

    Traverses the given ACL, allocates the 32 per-bit stacks, and fills them
    with the ACL broken up per-bit. The allocated memory can be freed by
    a SINGLE call to AdlStatement::FreeMemory(pStacks[0]), since the block
    allocated is a single block.
    
Arguments:

    pDacl           -       The DACL to convert
    
    pControl        -       The ADL_PARSER_CONTROL, for permission mapping
    
    pdwStackSize    -       The sizes of the stacks are returned here
    
    pStacks         -       The pointers to the per-bit stacks are returned here
                            pStacks[0] should be freed later using
                            AdlStatement::FreeMemory
    
Return Value:

    none
    
--*/
{
    
    DWORD dwIdx;
    DWORD dwIdx2;
    DWORD dwTmp;
    DWORD dwNumBlocksTotal = 0;

    DWORD dwFlags;
    ACCESS_MASK amMask;
    BOOL bAllow;
    
    PVOID pAce;
    PSID pSid;

    DWORD pdwStackCur[32];

    for( dwIdx = 0; dwIdx < 32; dwIdx++ )
    {
        pdwStackSize[dwIdx] = 0;
        pdwStackCur[dwIdx] = 0;
        pStacks[dwIdx] = NULL;
    }

    //
    // Determine amount of stack space needed for each stack
    //
    
    for( dwIdx = 0; dwIdx < pDacl->AceCount; dwIdx++ )
    {
        GetAce(pDacl, dwIdx, &pAce);

        switch(((PACE_HEADER)pAce)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            amMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask
                     & ~(pControl->amNeverSet | pControl->amSetAllow);
            break;

        case ACCESS_DENIED_ACE_TYPE:
            amMask = ((PACCESS_DENIED_ACE)pAce)->Mask
                     & ~(pControl->amNeverSet | pControl->amSetAllow);
            break;
        
        default:
            throw AdlStatement::ERROR_UNKNOWN_ACE_TYPE;
            break;
        }
        
        for( dwIdx2 = 0, dwTmp = 0x00000001;
             dwIdx2 < 32 ; 
             dwTmp <<= 1, dwIdx2++ )
        {
            if( dwTmp & amMask )
            {
                pdwStackSize[dwIdx2]++;
                dwNumBlocksTotal++;
            }
        }
    }


    //
    // Allocate the 32 stacks of pointers as a single memory chunk
    //

    pStacks[0] = (PBIT_STACK_ELEM) 
                            new BYTE[dwNumBlocksTotal * sizeof(BIT_STACK_ELEM)];

    if( pStacks[0] == NULL )
    {
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

    //
    // Set the stack pointers to the proper locations in the single memory chunk
    //

    for( dwIdx = 1, dwTmp = pdwStackSize[0];
         dwIdx < 32;
         dwIdx++ )
    {
        if( pdwStackSize[dwIdx] > 0 )
        {
            pStacks[dwIdx] = &(pStacks[0][dwTmp]);
            
            dwTmp += pdwStackSize[dwIdx];
        }
    }

    ASSERT( dwTmp == dwNumBlocksTotal );

    //
    // Now go through the ACL again and fill in the stacks and advancing
    // the pStacksCur pointers
    // Stack sizes are known, so we treat the start of memory at TOP
    // of stack
	//
	// Make sure to strip out the INHERITED_ACE flag from the ACEs,
	// and handle the special access masks in the parser control
    //

    for( dwIdx = 0; dwIdx < pDacl->AceCount; dwIdx++ )
    {
        GetAce(pDacl, dwIdx, &pAce);

        switch(((PACE_HEADER)pAce)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            dwFlags = ((PACCESS_ALLOWED_ACE)pAce)->Header.AceFlags
				      & ( CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE
						  | NO_PROPAGATE_INHERIT_ACE | OBJECT_INHERIT_ACE );

            amMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask
                     & ~(pControl->amNeverSet | pControl->amSetAllow);

            bAllow = TRUE;

            pSid = &(((PACCESS_ALLOWED_ACE)pAce)->SidStart);

            break;

        case ACCESS_DENIED_ACE_TYPE:
            dwFlags = ((PACCESS_DENIED_ACE)pAce)->Header.AceFlags
				& ( CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE
					| NO_PROPAGATE_INHERIT_ACE | OBJECT_INHERIT_ACE );

            amMask = ((PACCESS_DENIED_ACE)pAce)->Mask
                     & ~(pControl->amNeverSet | pControl->amSetAllow);

            bAllow = FALSE;

            pSid = &(((PACCESS_DENIED_ACE)pAce)->SidStart);

            break;

        default:
            throw AdlStatement::ERROR_UNKNOWN_ACE_TYPE;
            break;
        }
        
        for( dwIdx2 = 0, dwTmp = 0x00000001;
             dwIdx2 < 32; 
             dwIdx2++, dwTmp <<= 1 )
        {
            if( dwTmp & amMask )
            {
                //
                // Index should never reach size (1 past bottom) of the stack
                //

                ASSERT( pdwStackCur[dwIdx2] < pdwStackSize[dwIdx2] );
                
                //
                // Fill in the actual structure
                //

                pStacks[dwIdx2][pdwStackCur[dwIdx2]].bAllow = bAllow;
                pStacks[dwIdx2][pdwStackCur[dwIdx2]].pSid = pSid;
                pStacks[dwIdx2][pdwStackCur[dwIdx2]].dwFlags = dwFlags;

                //
                // Top of the stack is the top, but we fill the stack top-first
                // So advance toward bottom of stack
                //
                
                pdwStackCur[dwIdx2]++;
                


            }
        }
    }

#if DBG
    //
    // Now perform an additional check in debug only that all stacks have
    // been filled as allocated
    //

    for( dwIdx = 0; dwIdx < 32; dwIdx++ )
    {
        ASSERT( pdwStackCur[dwIdx] == pdwStackSize[dwIdx] );
    }

#endif

}




DWORD GetStackBlockSize(
                        IN const PBIT_STACK_ELEM pStack,
                        IN DWORD dwStartOffset,
                        IN DWORD dwStackSize 
                        )
/*++

Routine Description:

    Finds the size of the maximum 'block' in the current per-bit stack, from
    the current position.
    
    A block is defined to be a set of 0 or more consecutive deny per-bit 
    ACE entries immediately followed by 1 or more consecutive allow per-bit
    ACE entries such that the inheritance masks are the same.
    
    Therefore, a DENY without a matching allow is NOT a block. This is detected
    when we are in the TMP_READ_DENY_STATE (indicating we have already read at
    least one deny) and read either a deny or allow with a non-matching mask.
    
    On the other hand, even a single ALLOW is a valid block. Therefore this
    can only fail if dwStartOffset points to a deny. 
    
Arguments:

    pStack          -   The per-bit stack to check
    
    dwStartOffset   -   Position to begin at (using that ace, not the next one)
    
    dwStackSize     -   Maximum offset will be dwStackSize - 1, this should
                        never get called with dwStackSize of 0.
    
Return Value:

    Number of entries in the block if successful
    0 if not successful
    
--*/
{

//
// States used by this function
//

#define TMP_START_STATE 0
#define TMP_READ_DENY_STATE 1
#define TMP_READ_ALLOW_STATE 2
#define TMP_DONE_STATE 3

    DWORD dwCurState = TMP_START_STATE;

    DWORD dwCurOffset = dwStartOffset;

    DWORD dwFlags;

    ASSERT( dwStackSize > 0 );
    ASSERT( dwStartOffset < dwStackSize );

    //
    // Returns are inside the loop, they will terminate it
    //

    while( ( dwCurState != TMP_DONE_STATE ) && ( dwCurOffset < dwStackSize ) )
    {
        switch( dwCurState )
        {
        case TMP_START_STATE:
    
            dwFlags = pStack[dwCurOffset].dwFlags;
            
            if( pStack[dwCurOffset].bAllow == FALSE ) // DENY entry
            {
                dwCurState = TMP_READ_DENY_STATE;
                dwCurOffset++;
            }
            else // Otherwise an ALLOW entry
            {
                dwCurState = TMP_READ_ALLOW_STATE;
                dwCurOffset++;
            }

            break;

        case TMP_READ_DENY_STATE:

            //
            // If we are in this state, and find an entry with non-matching
            // flags, this means no valid block is possible, return 0
            //

            if( pStack[dwCurOffset].dwFlags != dwFlags )
            {
                //
                // Set end offset to indicate 0 block size and finish
                // This indicates there is no valid block
                //

                dwCurState = TMP_DONE_STATE;
                dwCurOffset = dwStartOffset;
            }
            else
            {
                if( pStack[dwCurOffset].bAllow == FALSE )
                {
                    //
                    // Another deny, stay in same state
                    //

                    dwCurOffset++;
                }
                else
                {
                    //
                    // Allow with matching flags, go into allow state
                    //

                    dwCurState = TMP_READ_ALLOW_STATE;
                    dwCurOffset++;
                }
            }

            break;

        case TMP_READ_ALLOW_STATE:

            //
            // If we are in this state, we have read 0 or more denies and
            // at least 1 allow. Therefore, we already have a block, so we 
            // just need to find its end and return. 
            //

            if(    (dwFlags == pStack[dwCurOffset].dwFlags)
                && (pStack[dwCurOffset].bAllow == TRUE) )
            {
                //
                // Another matching allow
                //

                dwCurOffset++;
            }
            else
            {
                //
                // End of block found
                //

                dwCurState = TMP_DONE_STATE;
            }

            break;
        }
    }

    //
    // Two ways to reach this point, hitting the bottom of the stack or
    // finding the end of the block (or lack thereof). In both cases, the
    // size of the block is dwCurOffset - dwStartOffset. In case of no
    // valid block, this will evaluate to 0.
    //

    return dwCurOffset - dwStartOffset;
}


DWORD NumStringsForMask(
                    IN     const PADL_PARSER_CONTROL pControl,
                    IN     ACCESS_MASK amMask
                    ) 
/*++

Routine Description:
    
    Determines the number of permission names which would be required 
    to express the access mask
        
Arguments:

    pControl    -   This contains the mapping between permission names and masks

    amMask      -   The mask to represent
    
Return Value:

    DWORD       -   The number of strings which would be required
    
--*/

{
    ACCESS_MASK amOptional = amMask;

    DWORD dwIdx = 0;

    DWORD dwNumStrings = 0;
    
    while(     amMask != 0 
            && (pControl->pPermissions )[dwIdx].str != NULL )
    {
        //
        // If all the bits representing the string are present in the whole mask
        // and at least some of the bits have not yet been represented
        // by another string, add this string to the list and remove the 
        // bits from amMask (representing the still required bits)
        //
        if( ( (amOptional & (pControl->pPermissions )[dwIdx].mask)
                ==   (pControl->pPermissions )[dwIdx].mask )
            && (amMask & (pControl->pPermissions )[dwIdx].mask))

        {
            amMask &= ~(pControl->pPermissions )[dwIdx].mask;
            dwNumStrings++;
        }
        
        dwIdx++;
    }

    //
    // If any of the rights are not mapped, throw an exception
    //

    if( amMask != 0 )
    {
            throw AdlStatement::ERROR_UNKNOWN_ACCESS_MASK;
    }

    return dwNumStrings;
}




////////////////////////////////////////////////////////////////////////////////
/////////////
///////////// Conversion from ADL to DACL
/////////////
////////////////////////////////////////////////////////////////////////////////


void AdlStatement::WriteToDacl(OUT PACL * ppDacl)

/*++

Routine Description:

    Creates a DACL representative of the AdlStatement structure.
    
    The PACL to the DACL is stored in ppDacl. It should be freed
    with the AdlStatement::FreeMemory() function.
    
    The algorithm is very straightforward, it's just a linear conversion
    from ADL to a DACL, taking each ADL substatement and creating deny ACEs
    for every ExPrincipal and allow ACEs for Principals.
    
Arguments:

    ppDacl  -       A pointer to the allocated DACL is stored in *pDacl
    
Return Value:

    none
    
--*/

{

    //
    // If not initialized, do not output
    //

    if( _bReady == FALSE )
    {
        throw AdlStatement::ERROR_NOT_INITIALIZED;
    }

    //
    // Mapping from token *'s to SIDs
    //

    map<const AdlToken *, PSID> mapTokSid;

    //
    // Mapping from Adl substatements (AdlTree *'s) to their access mask
    // This is before the special treatment masks are applied
    //

    map<const AdlTree *, ACCESS_MASK> mapTreeMask;

    //
    // Iterators which are reused
    //

    list<AdlTree *>::iterator iterTrees;
    list<AdlTree *>::iterator iterTreesEnd;
    list<const AdlToken *>::iterator iterTokens;
    list<const AdlToken *>::iterator iterTokensEnd;

    ACCESS_MASK amMask;

    stack<PBYTE> stackToFree;
    PBYTE pbLastAllocated;

    DWORD dwAclSize = sizeof(ACL);

    PACL pAcl = NULL;

    try {

        //
        // Do a single LSA lookup, convert all at once
        // SIDs will need to be deleted by retrieving them from the map
        //

        ConvertNamesToSids(&mapTokSid);

    
        //
        // Calculate the ACL size
        //

        for(iterTrees = _lTree.begin(), iterTreesEnd = _lTree.end();
            iterTrees != iterTreesEnd;
            iterTrees++)
        {
        
            //
            // Now go through the Principals
            //
        
            for(iterTokens = (*iterTrees)->GetPrincipals()->begin(), 
                    iterTokensEnd = (*iterTrees)->GetPrincipals()->end();
                iterTokens != iterTokensEnd;
                iterTokens ++)
            {
                dwAclSize += ( 
                          sizeof(ACCESS_ALLOWED_ACE)
                        - sizeof(DWORD)
                        + GetLengthSid((*(mapTokSid.find(*iterTokens))).second)
                          );
            }
        
            //
            // And the ExPrincipals
            //
        
            for(iterTokens = (*iterTrees)->GetExPrincipals()->begin(), 
                    iterTokensEnd = (*iterTrees)->GetExPrincipals()->end();
                iterTokens != iterTokensEnd;
                iterTokens ++)
            {
                dwAclSize += ( 
                          sizeof(ACCESS_DENIED_ACE)
                        - sizeof(DWORD)
                        + GetLengthSid((*(mapTokSid.find(*iterTokens))).second)
                          );
            }

            //
            // Calculate the effective permissions ahead of time
            //

            amMask = 0;

            for(iterTokens = (*iterTrees)->GetPermissions()->begin(), 
                    iterTokensEnd = (*iterTrees)->GetPermissions()->end();
                iterTokens != iterTokensEnd;
                iterTokens ++)
            {
                amMask |= MapTokenToMask(*iterTokens);
            }

            //
            // And enter the AdlTree *, Mask pair into the map
            //

            mapTreeMask[*iterTrees] = amMask;

        }

        //
        // Allocate the ACL
        //

        pAcl = (PACL)new BYTE[dwAclSize];

        if( pAcl == NULL )
        {
            throw AdlStatement::ERROR_OUT_OF_MEMORY;
        }
        
        //
        // Initialize the ACL
        //

        if( ! InitializeAcl(pAcl, dwAclSize, ACL_REVISION_DS))
        {
            throw AdlStatement::ERROR_ACL_API_FAILED;
        }

        
        //
        // Now go through the substatements and create the ACEs
        //

        for(iterTrees = _lTree.begin(), iterTreesEnd = _lTree.end();
            iterTrees != iterTreesEnd;
            iterTrees++)
        {

            //
            // First add the denies for this statement
            //
            
            
            for(iterTokens = (*iterTrees)->GetExPrincipals()->begin(),
                    iterTokensEnd = (*iterTrees)->GetExPrincipals()->end();
                iterTokens != iterTokensEnd; 
                iterTokens ++)
            {
                if( ! AddAccessDeniedAceEx(
                            pAcl,
                            ACL_REVISION_DS,
                            (*iterTrees)->GetFlags(),
                            ( mapTreeMask[*iterTrees] 
                                & ~_pControl->amSetAllow)
                                & ~_pControl->amNeverSet,
                            mapTokSid[*iterTokens] ))
                {
                    throw AdlStatement::ERROR_ACL_API_FAILED;
                }
            }

            
            //
            // Now go through the Principals, add allows
            //
            
            for(iterTokens = (*iterTrees)->GetPrincipals()->begin(),
                    iterTokensEnd = (*iterTrees)->GetPrincipals()->end();
                iterTokens != iterTokensEnd;
                iterTokens ++)
            {
                if( ! AddAccessAllowedAceEx(
                            pAcl,
                            ACL_REVISION_DS,
                            (*iterTrees)->GetFlags(),
                            (mapTreeMask[*iterTrees]
                                | _pControl->amSetAllow)
                                & ~_pControl->amNeverSet,

                            mapTokSid[*iterTokens] ))
                {
                    throw AdlStatement::ERROR_ACL_API_FAILED;
                }
                

            }

        }
    }
    catch(...)
    {
        if( pAcl != NULL )
        {
            //
            // Memory allocated for ACL
            //

            delete[] (PBYTE)pAcl;
        }

        //
        // Memory allocated for the SIDs
        //

        while( !mapTokSid.empty() )
        {
            delete[] (PBYTE) (*(mapTokSid.begin())).second;
            mapTokSid.erase(mapTokSid.begin());
        }

        //
        // and pass the exception along
        //

        throw;
    }

    //
    // Free the SIDs if done, since they are copied into the ACL
    //

    while( !mapTokSid.empty() )
    {
        delete[] (PBYTE) (*(mapTokSid.begin())).second;
        mapTokSid.erase(mapTokSid.begin());
    }

    //
    // The DACL is returned, so it should not be deallocated
    //

    *ppDacl = pAcl;

}





////////////////////////////////////////////////////////////////////////////////
/////////////
///////////// Utility functions
/////////////
////////////////////////////////////////////////////////////////////////////////


bool AdlCompareStruct::operator()(IN const PSID pSid1,
                                  IN const PSID pSid2 ) const
/*++

Routine Description:

	This is a less-than function which places a complete ordering on
	a set of PSIDs by value, NULL PSIDs are valid. This is used by the 
	STL map.
	
	Since the number of subauthorities appears before the subauthorities
	themselves, that difference will be noticed for two SIDs of different
	size before the memcmp tries to access the nonexistant subauthority
	in the shorter SID, therefore an access violation will not occur.

Arguments:

    pSid1   -       First PSID
    pSid2   -       Second PSID

Return Value:

    Returns TRUE iff SID1 < SID2
    FALSE otherwise
    
--*/

{
    
	//
    // If both are NULL, false should be returned for complete ordering
    //

    if(pSid2 == NULL)
    {
        return false;
    }

    if(pSid1 == NULL)
    {
        return true;
    }

    if( memcmp(pSid1, pSid2, GetLengthSid(pSid1)) < 0 )
    {
        return true;
    }
    else
    {
        return false;
    }
}



bool AdlCompareStruct::operator()(IN const WCHAR * sz1,
                                  IN const WCHAR * sz2 ) const
/*++

Routine Description:

    operator() compares two null-terminated WCHAR* strings, case-INSENSITIVE. 
    
Arguments:

    sz1     -       First string
    sz2     -       Second string

Return Value:

    Returns TRUE iff sz1 < sz2
    FALSE otherwise
    
--*/
{

    return ( _wcsicmp(sz1, sz2) < 0 );
}




void AdlStatement::MapMaskToStrings(
                                      IN     ACCESS_MASK amMask,
                                      IN OUT list<WCHAR *> *pList ) const
/*++

Routine Description:

    Converts the given access mask into a list of const WCHAR *'s representing
    the possibly overlapping permission strings which, when combined by a 
    bitwise OR, are equal to the access mask given. Throws exception if
    a given access mask cannot be represented by the user-specified permissions.
    
    The WCHAR * pointers are const, and should not be deallocated.
        
Arguments:

    amMask      -   The mask to represent
    
    pList       -   An allocated STL list in which to store the pointers
    
Return Value:

    none
    
--*/

{
    ACCESS_MASK amOptional = amMask;

    DWORD dwIdx = 0;
    
    while(     amMask != 0 
            && (_pControl->pPermissions )[dwIdx].str != NULL )
    {
        //
        // If all the bits representing the string are present in the whole mask
        // and at least some of the bits have not yet been represented
        // by another string, add this string to the list and remove the 
        // bits from amMask (representing the still required bits)
        //
        if( ( (amOptional & (_pControl->pPermissions )[dwIdx].mask)
                ==   (_pControl->pPermissions )[dwIdx].mask )
            && (amMask & (_pControl->pPermissions )[dwIdx].mask))

        {
            amMask &= ~(_pControl->pPermissions )[dwIdx].mask;
            pList->push_back((_pControl->pPermissions )[dwIdx].str);
        }
        
        dwIdx++;
    }

    //
    // If any of the rights are not mapped, throw an exception
    //

    if( amMask != 0 )
    {
            throw AdlStatement::ERROR_UNKNOWN_ACCESS_MASK;
    }
}



void AdlStatement::ConvertSidsToNames(
    IN const PACL pDacl,
    IN OUT map<const PSID, const AdlToken *> * mapSidsNames 
    )
/*++

Routine Description:

    Traverses a DACL, and creates string representations of every SID
    found in the DACL. Returns them in the provided map. The newly allocated
    tokens will get garbage-collected by the AdlStatement later, no need
    to free manually. Since the PSIDs used are the same as in the ACL itself,
    we don't need to map by value, since pointer uniqueness is guaranteed here.
        
Arguments:

    pDacl  -  DACL to traverse
    
    mapSidNames  -  Where to store the resulting mapping
    
Return Value:

    none
    
--*/

{
    
    AdlStatement::ADL_ERROR_TYPE adlError = AdlStatement::ERROR_NO_ERROR;

    DWORD dwIdx = 0;
    LPVOID pAce = NULL;
    AdlToken *pTok = NULL;
    AdlToken *pTokLastAllocated = NULL;

    wstring wsName, wsDomain;

    NTSTATUS ntErr = STATUS_SUCCESS;

    LSA_HANDLE LsaPolicy;
    PLSA_REFERENCED_DOMAIN_LIST RefDomains = NULL;
    PLSA_TRANSLATED_NAME Names = NULL;
    
    
    LSA_OBJECT_ATTRIBUTES LsaObjectAttributes;

    //
    // Traverse the ACL to get the list of SIDs used
    //

    PSID *ppSids = NULL;
     
    ppSids = (PSID *) new BYTE[sizeof(PSID) * pDacl->AceCount];

    if( ppSids == NULL )
    {
        adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }

    for(dwIdx = 0; dwIdx < pDacl->AceCount; dwIdx++)
    {
        GetAce(pDacl, dwIdx, &pAce);

        switch( ((ACE_HEADER *)pAce)->AceType )
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            ppSids[dwIdx] = &( ((ACCESS_ALLOWED_ACE *)pAce)->SidStart);
            break;

        case ACCESS_DENIED_ACE_TYPE:
            ppSids[dwIdx] = &( ((ACCESS_DENIED_ACE *)pAce)->SidStart);
            break;
            
        default:
            adlError = AdlStatement::ERROR_UNKNOWN_ACE_TYPE;
            goto error;
            break;
        }
    }

    //
    // Look up all SIDs, getting user and domain names, single LSA call
    //

    LsaObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    LsaObjectAttributes.RootDirectory = NULL;
    LsaObjectAttributes.ObjectName = NULL;
    LsaObjectAttributes.Attributes = 0;
    LsaObjectAttributes.SecurityDescriptor = NULL;
    LsaObjectAttributes.SecurityQualityOfService = NULL;
    
    ntErr = LsaOpenPolicy(
                        NULL,
                        &LsaObjectAttributes,
                        POLICY_LOOKUP_NAMES,
                        &LsaPolicy);
    
    if( ntErr != STATUS_SUCCESS )
    {
        adlError = AdlStatement::ERROR_LSA_FAILED;
        goto error;
    }
    
    //
    // Garbage collect later
    //

    ntErr = LsaLookupSids(LsaPolicy,
                          pDacl->AceCount,
                          ppSids,
                          &RefDomains,
                          &Names);
    
    LsaClose(LsaPolicy);

    if( ntErr != ERROR_SUCCESS )
    {

        if( (ntErr == STATUS_SOME_NOT_MAPPED) || (ntErr == STATUS_NONE_MAPPED) )
        {
            adlError = AdlStatement::ERROR_UNKNOWN_SID;
        }
        else
        {
            adlError = AdlStatement::ERROR_LSA_FAILED;
        }

        goto error;
    }

    //
    // Now traverse the list ppSids, creating matching tokens for the 
    // SIDs in the ACL.
    //
    
    try
    {
        for(dwIdx = 0; dwIdx < pDacl->AceCount; dwIdx++)
        {
            pTok = NULL;
            
            //
            // LSA Strings not terminated, create terminated version
            // LSA buffer sizes in bytes, not wchars
            //
    
            assert(Names[dwIdx].DomainIndex >= 0);
    
            wsName.assign(Names[dwIdx].Name.Buffer,
                          Names[dwIdx].Name.Length / sizeof(WCHAR));
    
            //
            // If builtin, no need for domain info
            //
                
            if(Names[dwIdx].Use == SidTypeWellKnownGroup)
            {
                pTok = new AdlToken(wsName.c_str(), 0, 0);
            }
            else
            {
                wsDomain.assign(
                    RefDomains->Domains[Names[dwIdx].DomainIndex].Name.Buffer,
                    RefDomains->Domains[Names[dwIdx].DomainIndex].Name.Length 
                        / sizeof(WCHAR));
    
                pTok = new AdlToken(wsName.c_str(), wsDomain.c_str(), 0, 0);
            }

            if( pTok == NULL )
            {
                adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
                goto error;
            }
            else
            {
                //
                // This will be deleted immediately if we cannot save the token
                // for later deallocation
                //

                pTokLastAllocated = pTok;
            }
                
            AddToken(pTok); // For later garbage collection
            
            //
            // No need ot delete immedeately, since no exception thrown
            //

            pTokLastAllocated = NULL;


            (*mapSidsNames)[(ppSids[dwIdx])] = pTok;
        }
    }
    catch(exception)
    {
        adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }

    // 
    // Done with the SIDs and LSA info, deallocate
    //

    error:;

    if( RefDomains != NULL )
    {
        LsaFreeMemory(RefDomains);
    }

    if( Names != NULL )
    {
        LsaFreeMemory(Names);
    }

    if( ppSids != NULL )
    {
        delete[] (PBYTE) ppSids;
    }

    if( adlError != AdlStatement::ERROR_NO_ERROR )
    {
        throw adlError;
    }

}





ACCESS_MASK AdlStatement::MapTokenToMask(
                                IN const AdlToken * tokPermission
                          )  

/*++

Routine Description:

    This routine maps a string represening a right to the matching access bits
    using the user-supplied mapping.
    
    This assumes that there are no pairs with ACCESS_MASK of 0 in the
    user-supplied mapping.
    
Arguments:

    tokPermission   -       The permission token to be looked up
    
Return Value:

    ACCESS_MASK     -       The corresponding access mask
    
--*/

{
    ACCESS_MASK amMask = 0;

    DWORD dwIdx = 0;

    //
    // The token should never have a second value
    //

    if( tokPermission->GetOptValue() != NULL )
    {
        throw AdlStatement::ERROR_FATAL_PARSER_ERROR;
    }

    while(amMask == 0 && (_pControl->pPermissions)[dwIdx].str != NULL)
    {
        if(0 == _wcsicmp(tokPermission->GetValue(),
                         (_pControl->pPermissions)[dwIdx].str ))
        {
            amMask = (_pControl->pPermissions)[dwIdx].mask;
        }

        ++dwIdx;
    }

    //
    // If mask was not matched, throw exception
    //

    if(amMask == 0)
    {
        SetErrorToken(tokPermission);
        throw AdlStatement::ERROR_UNKNOWN_PERMISSION;
    }

    return amMask;
}



void AdlStatement::ConvertNamesToSids(
                        IN OUT map<const AdlToken *, PSID> * mapTokSid
                        )

/*++

Routine Description:
    
    This routine traverses all AdlTree's in the AdlStatement, and creates a list
    of all usernames used. It then makes a single LSA call, and creates a map
    of name AdlToken*'s to PSIDs, for later use by the conversion function.
    
    The newly allocated PSIDs are stored in the map. They should be freed
    using the AdlStatement::FreeMemory() function.
    
    On error, any PSIDs that have been added to the map are deleted.
    
Arguments:

    mapTokSid       -       Allocated map to which the Token,PSID entries should
                                be added. This MUST be empty. Otherwise, on
                                error, externally allocated memory would get
                                freed here.
    
Return Value:

    none
    
--*/

{

    list<AdlTree *>::iterator iterTrees;
    list<AdlTree *>::iterator iterTreesEnd;
    list<const AdlToken *>::iterator iterTokens;
    list<const AdlToken *>::iterator iterTokensEnd;

    //
    // List of all Principal tokens used, allows for a single tree traversal
    //

    list<const AdlToken *> listAllPrincipals;

    //
    // Mapping from PLSA_STRING to AdlToken, for detecting which
    // username is invalid
    //

    map<DWORD, const AdlToken *> mapIdxToken;

    //
    // Delayed garbage collection
    //

    stack<PBYTE> stackToFree;

    void * pLastAllocated = NULL;


    AdlStatement::ADL_ERROR_TYPE adlError = AdlStatement::ERROR_NO_ERROR;

    DWORD dwDomainSidSize;
    DWORD numNames;
    DWORD dwIdx;

    PSID pSidTemp;

    LSA_HANDLE LsaPolicy;

    PLSA_UNICODE_STRING pLsaStrings;

    PLSA_REFERENCED_DOMAIN_LIST RefDomains = NULL;
    PLSA_TRANSLATED_SID TranslatedSids = NULL;

    LSA_OBJECT_ATTRIBUTES LsaObjectAttributes;
    LsaObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    LsaObjectAttributes.RootDirectory = NULL;
    LsaObjectAttributes.ObjectName = NULL;
    LsaObjectAttributes.Attributes = 0;
    LsaObjectAttributes.SecurityDescriptor = NULL;
    LsaObjectAttributes.SecurityQualityOfService = NULL;
    

    //
    // Verify that the input map is empty as required
    //

    if( !(*mapTokSid).empty() )
    {
        throw AdlStatement::ERROR_FATAL_PARSER_ERROR;
    }

    //
    // STL throws exceptions, catch them here
    //
    try
    {
        //
        // Determine total number of names and place them all in the list
        //
    
        for(numNames = 0, iterTrees = _lTree.begin(), iterTreesEnd = _lTree.end();
            iterTrees != iterTreesEnd;
            iterTrees++)
        {
            iterTokensEnd = (*iterTrees)->GetPrincipals()->end();
    
            for(iterTokens = (*iterTrees)->GetPrincipals()->begin(); 
                iterTokens != iterTokensEnd; iterTokens ++)
            {
                numNames++;
                listAllPrincipals.push_back(*iterTokens);
            }
    
            iterTokensEnd = (*iterTrees)->GetExPrincipals()->end();
    
            for(iterTokens = (*iterTrees)->GetExPrincipals()->begin();
                iterTokens != iterTokensEnd; iterTokens ++)
            {
                numNames++;
                listAllPrincipals.push_back(*iterTokens);
            }
        }
    
        //
        // Allocate the needed memory for the LSA name list
        //
    
        pLsaStrings = (PLSA_UNICODE_STRING)
                        new BYTE[numNames * sizeof(LSA_UNICODE_STRING)];
        
        if( pLsaStrings == NULL )
        {
            adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
            goto error;
        }
        else
        {
            pLastAllocated = pLsaStrings;
            stackToFree.push( (PBYTE)pLsaStrings );
            pLastAllocated = NULL;
        }
    
    
        //      
        // Retrieve name strings here in proper format, DOMAIN\USER
        // 
    
        for(iterTokens = listAllPrincipals.begin(),
                dwIdx = 0,
                iterTokensEnd = listAllPrincipals.end();
            iterTokens != iterTokensEnd;
            iterTokens ++, dwIdx++)
        {
            //
            // Name may be with domain, or just username
            //
    
            if( (*iterTokens)->GetOptValue() != NULL )
            {
                //
                // Extra 1 wchar for the '\' character, 2 bytes per wchar
                //
                pLsaStrings[dwIdx].Length = sizeof(WCHAR) * 
                        ( wcslen((*iterTokens)->GetValue()) +
                          wcslen((*iterTokens)->GetOptValue()) + 1);
            }
            else
            {
                pLsaStrings[dwIdx].Length = sizeof(WCHAR) * 
                             (wcslen((*iterTokens)->GetValue()) + 1);
            }
    
            pLsaStrings[dwIdx].MaximumLength = pLsaStrings[dwIdx].Length 
                                             + sizeof(WCHAR);
    
            pLsaStrings[dwIdx].Buffer = 
                          (LPTSTR)new BYTE[pLsaStrings[dwIdx].MaximumLength];
    
            if( pLsaStrings[dwIdx].Buffer == NULL )
            {
                adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
                goto error;
            }
            else
            {
                pLastAllocated = pLsaStrings[dwIdx].Buffer;
                stackToFree.push((PBYTE)(pLsaStrings[dwIdx].Buffer));
                pLastAllocated = NULL;

                mapIdxToken[dwIdx] = *iterTokens;
            }
    
            if( (*iterTokens)->GetOptValue() != NULL )
            {
                wsprintf( (LPTSTR)(pLsaStrings[dwIdx].Buffer), 
                          L"%s%c%s", 
                          (*iterTokens)->GetOptValue(),
                          _pControl->pLang->CH_SLASH,
                          (*iterTokens)->GetValue() );
    
            }
            else
            {
                wsprintf( (LPTSTR)(pLsaStrings[dwIdx].Buffer), 
                          L"%s", 
                          (*iterTokens)->GetValue() );
            }
        }
        
        //
        // Open the LSA policy
        //
    
        NTSTATUS ntErr;
    
        ntErr = LsaOpenPolicy(
                            NULL,
                            &LsaObjectAttributes,
                            POLICY_LOOKUP_NAMES,
                            &LsaPolicy);
    
        if( ntErr != STATUS_SUCCESS )
        {
            adlError = AdlStatement::ERROR_LSA_FAILED;
            goto error;
        }
        
        //
        // Now perform the LsaLookupNames call
        // 
    
        ntErr = LsaLookupNames(
                            LsaPolicy, 
                            numNames,
                            pLsaStrings,
                            &RefDomains,
                            &TranslatedSids);
    
        //
        // Free the LSA handle
        //
    
        LsaClose(LsaPolicy);
    
        //
        // Check for any unknown names
        //
    
        if( ntErr != STATUS_SUCCESS )
        {
            adlError = AdlStatement::ERROR_LSA_FAILED;
            
            if( ntErr == STATUS_SOME_NOT_MAPPED || ntErr == STATUS_NONE_MAPPED )
            {
                
                adlError = AdlStatement::ERROR_UNKNOWN_USER;
    
                //
                // Find first unknown name and return it to user
                //
    
                for( dwIdx = 0; dwIdx < numNames; dwIdx++ )
                {
                    if( TranslatedSids[dwIdx].Use == SidTypeInvalid ||
                        TranslatedSids[dwIdx].Use == SidTypeUnknown )
                    {
                        SetErrorToken(mapIdxToken[dwIdx]);
                        adlError = AdlStatement::ERROR_UNKNOWN_USER;
                    }
                }
            }
    
            goto error;
        }
    
    
        //
        // Assume all names now mapped if this point is reached 
        // Traverse all tokens again, pairing them with SIDs
        //
    
        for(iterTokens = listAllPrincipals.begin(),
                dwIdx = 0,
                iterTokensEnd = listAllPrincipals.end();
            iterTokens != iterTokensEnd;
            iterTokens ++, dwIdx++)
        {
            //
            // Make sure all domains were looked up successfuly
            // Invalid SIDs caught earlier
            //
    
            assert(TranslatedSids[dwIdx].DomainIndex >= 0);
    
            dwDomainSidSize = GetLengthSid(
                RefDomains->Domains[TranslatedSids[dwIdx].DomainIndex].Sid);
            
            //
            // One more RID for the user
            //
    
            pSidTemp = new BYTE[dwDomainSidSize + sizeof(DWORD)];
    
            if( pSidTemp == NULL )
            {
                adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
                goto error;
            }
    
            //
            // Copy the domain SID
            //
    
            CopySid(dwDomainSidSize + sizeof(DWORD), pSidTemp, 
                RefDomains->Domains[TranslatedSids[dwIdx].DomainIndex].Sid);
    
            //
            // If the SID is not a domain SID, and is valid, then we need to add
            // the last RID. If domain SID, then referenced domain is the only
            // SID we need, and we already have copied it
            //
    
            if( TranslatedSids[dwIdx].Use != SidTypeDomain )
            {
                ((SID *)pSidTemp)->SubAuthority[
                                    ((SID *)pSidTemp)->SubAuthorityCount
                                   ] = TranslatedSids[dwIdx].RelativeId;
    
                //
                // Add 1 more subauthority
                //
    
                ((SID *)pSidTemp)->SubAuthorityCount++;
    
            }
            
            //
            // If this fails, need to allocate the single uninserted SID
            // Other SIDs will be deallocated externally
            //

            pLastAllocated = pSidTemp;
            
            (*mapTokSid)[(*iterTokens)] = pSidTemp;
            
            pLastAllocated = NULL;
    

        }
    }

    //
    // Catch STL exceptions here, if exception is thrown, either the above
    // code is wrong, or out of memory. Assume out of memory.
    //

    catch(exception ex)
    {
        adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
    }

error:;
    //
    // Garbage collection
    //

    if( RefDomains != NULL)
    {
        LsaFreeMemory(RefDomains);
    }
    
    if( TranslatedSids != NULL)
    {
        LsaFreeMemory(TranslatedSids);
    }

    //
    // If the grabage stack threw an exception, deallocate last allocated object
    //

    if( pLastAllocated != NULL )
    {
        delete[] (PBYTE)pLastAllocated;
    }

    while( ! stackToFree.empty() )
    {
        //
        // If popping a stack causes an STL exception, we have bigger problems
        // than memory leaks
        //

        delete[] stackToFree.top();
        stackToFree.pop();
    }

    //
    // If any other error code happened earlier, pass it on
    //

    if( adlError != AdlStatement::ERROR_NO_ERROR )
    {
        while( !(*mapTokSid).empty() )
        {
            delete[] (PBYTE) (*((*mapTokSid).begin())).second;
            (*mapTokSid).erase( (*mapTokSid).begin() );
        }
        throw adlError;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\adl.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adl.h

Abstract:

   The header file for the ADL language parser / printer

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "pch.h"
#include "adlinterface.h"

#include <string>
#include <list>
#include <stack>
#include <map>

using namespace std;

//
// Forward declarations
//

class AdlToken;
class AdlLexer;
class AdlTree;
class AdlStatement;


struct AdlCompareStruct
/*++
   
   Struct:             AdlCompareStruct
   
   Description:        
        
        STL requires custom key comparisons for containers to be supplied in
        such a struct.                
                
--*/

{
    bool operator()(IN const PSID pSid1,
                    IN const PSID pSid2) const;

    bool operator()(IN const WCHAR * sz1,
                    IN const WCHAR * sz2) const;
};



class AdlStatement
/*++
   
   Class:              AdlStatement
   
   Description:        
                
    This class contains a description of a DACL on an object, using the ADL
    language. An instance of this class can be constructed from an ACL or
    from a string statement in the ADL language. Once constructed, an ACL
    or a string statement in the ADL language can be output by an instance
    of this class.
 
   Base Classes:       none
 
   Friend Classes:     AdlLexer 
 
--*/
{
    //
    // Friend classes necessary to access the garbage collection functionality,
    // and for parsing ADL
    //
    
    friend class AdlLexer;

public:

    //
    // Initializes the AdlStatement
    //

    AdlStatement(IN const PADL_PARSER_CONTROL pControl)
        { _bReady = FALSE; _tokError = NULL; _pControl = pControl;
          ValidateParserControl(); }

    
    //
    // Destructor, frees tokens created by this and other classes
    //
    
    ~AdlStatement();

    //
    // Reads in the ADL statement in the input string
    //
    
    void ReadFromString(IN const WCHAR *szInput);

    //
    // Creates an ADL statement equivalent to the given DACL
    //
    
    void ReadFromDacl(IN const PACL pDacl);
    

    //
    // Prints the AdlStatement as a statement in the ADL language,
    // appending it to the allocated STL wstring pSz
    //
    
    void WriteToString(OUT wstring *pSz);

    //
    // Writes the ADL statement to a new DACL and returns the pointer to
    // the new DACL in *ppDacl
    //
    
    void WriteToDacl(OUT PACL *ppDacl);

    //
    // Gets the error string token, if any (depends on error code)
    //

    const AdlToken * GetErrorToken()
        { return _tokError; }

    //
    // This should be used to free any memory allocated by this class
    //

    static void FreeMemory(PVOID pMem)
        {  delete[] (PBYTE) pMem; }



public:

    //
    // AdlStatement throws exceptions of this type on any error
    // Some of the errors will make the offending token available
    // through GetErrorToken()
    //
    
    typedef enum 
    {
        ERROR_NO_ERROR = 0,

        //
        // Internal errors which shoul not occur
        //

        ERROR_FATAL_LEXER_ERROR,
        ERROR_FATAL_PARSER_ERROR,
        ERROR_FATAL_ACL_CONVERT_ERROR,


        //
        // Errors due to the system the code is running on
        //

        ERROR_OUT_OF_MEMORY,
        ERROR_ACL_API_FAILED,
        
        //
        // Possible error due to network problems
        //

        ERROR_LSA_FAILED,


        //
        // If the ADL_PARSER_CONTROL is invalid, this is thrown
        //

        ERROR_INVALID_PARSER_CONTROL,

        //
        // Unknown ACE type encountered in DACL, no token supplied
        //

        ERROR_UNKNOWN_ACE_TYPE,
        
        //
        // User tried to specify impersonation as "user1 as user2"
        // Not currently supported
        //

        ERROR_IMPERSONATION_UNSUPPORTED,
        

        //
        // User error, no token supplied, quote with no closing quote
        //

        ERROR_UNTERMINATED_STRING,

        //
        // The user's statement was not in the ADL language (grammar error)
        // For this error, the offending token is supplied, though
        // the mistake may have happened before that token and was
        // accepted by the grammar
        //

        ERROR_NOT_IN_LANGUAGE,
        

        //
        // User input-related errors
        // For these errors, the offending token is supplied
        //

        //
        // User was not found by LSA lookup
        //

        ERROR_UNKNOWN_USER,
        
        //
        // Permission string was not one of those listed in the parser control
        //

        ERROR_UNKNOWN_PERMISSION,

        //
        // Username contained invalid characters
        //

        ERROR_INVALID_USERNAME,

        //
        // Domain name contained invalid characters
        //

        ERROR_INVALID_DOMAIN,

        //
        // Invalid inheritance specified. Not currently used, since 
        // object type errors are caught at the grammar level
        //

        ERROR_INVALID_OBJECT,

        //
        // Other errors with no token supplied
        //
        
        //
        // A SID in an ACE was not found and mapped to a name by the LSA lookup
        //

        ERROR_UNKNOWN_SID,

        //
        // An access mask was encountered in an ACE that could not be 
        // expressed by the user-specified permission mapping
        //

        ERROR_UNKNOWN_ACCESS_MASK,

        //
        // The ACL cannot be expressed in ADL. This means that, for some access
        // mask bit and set of inheritance flags, there exists a DENY ACE in the
        // ACL with the given bit set in its mask and with the given flags such
        // that either there is no ALLOW ACE which also has this bit set and has
        // the same inheritance flags further down in the ACL, or another 
        // ACE with DIFFERENT inheritance flags and the same bit set follows 
        // this DENY ace. For more information, see the ADL conversion
        // algorithm.
        // 
        ERROR_INEXPRESSIBLE_ACL,

        //
        // User attempted an output operation on AdlStatement without
        // first successfully inputting data from either a string or an ACL
        //

        ERROR_NOT_INITIALIZED

    } ADL_ERROR_TYPE;

private:

    //
    // Internal representation of an ADL statement
    //

    list<AdlTree *> _lTree; // A set of parsed ADL statements, as AdlTree's

    list<AdlTree *>::iterator _iter; // Iterator for the above set

    stack<AdlToken *> _AllocatedTokens; // Tokens to be garbage collected

    PADL_PARSER_CONTROL _pControl;

    const AdlToken * _tokError;

    BOOL _bReady;

private:

    //
    // Goes through the list of AdlTrees, collects a list of all usernames
    // used, and makes a single LSA call to look up all SIDs, inserting the
    // PSIDs into the map by the (unique) token pointer.
    //
    
    void ConvertNamesToSids(
                          IN OUT map<const AdlToken *, PSID> * mapTokSid
                          );

    //
    // Goes throw the DACL, collects a lost of all SIDs used, and makes a 
    // single LSA call to look up all names, inserting the looked up
    // names into the provided map as AdlTokens, which are garbage-
    // collected when the AdlStatement is deleted
    //

    void ConvertSidsToNames(
                      IN const PACL pDacl,
                      IN OUT map<const PSID, const AdlToken *> * mapSidsNames 
                      );

    //
    // Reads a DACL, and constructs an ADL statement from it
    //
    
    void ConvertFromDacl(
                          IN const PACL pDacl
                          );

    //
    // Returns the access mask corresponding to the given right name
    //
    
    ACCESS_MASK MapTokenToMask(
                          IN const AdlToken * tokPermission
                          );

    //
    // Fills in a list ofr const WCHAR *'s matching the passed in access
    // mask, using the preference order given in the grammar
    //

    void MapMaskToStrings(IN     ACCESS_MASK amMask,
                          IN OUT list<WCHAR *> *pList 
                          ) const;

    //
    // Cleans up all of the AdlTrees and all tokens
    //

    void Cleanup();

    //
    // Parses a string in the ADL language
    // This function is generated by YACC from the ADL grammar
    //

    int ParseAdl(IN      const WCHAR *szInput);

    //
    // Returns the current AdlTree, this is used by the ADL parser to create
    // an ADL statement, one tree at a time
    //
    
    AdlTree * Cur();

    //
    // Creates a new AdlTree and pushes it onto the top of the list
    // Used by the ADL parser once the end of a single ADL statement is reached
    //
    
    void Next();


    //
    // If the last added AdlTree is empty, remove it
    // Used by the ADL parser, since it adds an AdlTree at the end
    // of a production instead of the beginning (YACC problem)
    //
    
    void PopEmpty();

    //
    // This is used to validate passed in ADL_PARSER_CONTROL structure
    // referenced by this class
    //

    void ValidateParserControl();

protected:

    //
    // Used to set the error-causing string
    //

    void SetErrorToken(const AdlToken *tokError)
        { _tokError = tokError; }
        
    //
    // Adds a token pointer to be deleted when the AdlStatement is deleted
    //
    
    void AddToken(IN AdlToken *tok);
};




class AdlLexer 
/*++
   
   Class:              AdlLexer
   
   Description:        
                
    This class is the lexer for the ADL language. It allows the ADL parser
    to retrieve tokens from an input string, one token at a time.
 
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{

private:

    const WCHAR *_input; // The input string

    DWORD _position; // Current position in the input string

    DWORD _start; // Start of current token in the buffer

    DWORD _tokCount; // Number of tokens so far retrieved

    //
    // Pointer to the AdlStatement instance which created this AdlLexer 
    // instance, for token garbage collection
    //
    
    AdlStatement *_adlStat; 

    //
    // Pointer to the ADL_LANGUAGE_SPEC structure defining the language to 
    // be parsed
    //
    
    PADL_LANGUAGE_SPEC _pLang;

    //
    // Mapping of special characters to character codes
    // Special characters are assigned codes above WCHAR max
    //
    
    map<WCHAR, DWORD> _mapCharCode;

    //
    // Mapping from wstring to identify special tokens
    //

    map<const WCHAR *, DWORD, AdlCompareStruct> _mapStringToken;

    //
    // Iterators used by NextToken, this way they are only allocated once
    //
    
    map<WCHAR, DWORD>::iterator _iterEnd;
    map<WCHAR, DWORD>::iterator _iter;


public:

    //
    // Constructs a lexer for an input string
    // NextToken() can then be called
    //
    
    AdlLexer(IN const WCHAR *input,
             IN OUT AdlStatement *adlStat,
             IN const PADL_LANGUAGE_SPEC pLang);

    //
    // Retrieves the next token from the input string
    // Returns 0 for the token type when the end of the string
    // is reached, as the YACC-generated parser requires.
    // A pointer to a new token instance containing the token
    // string, row, col, etc, is stored in *value
    //
    
    DWORD NextToken(OUT AdlToken **value);
};



class AdlToken 
/*++
   
   Class:              AdlToken
   
   Description:        
                
    This class contains the relevant information for a token. It is used in
    parsing ADL.
 
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{
private:

    DWORD _begin;           // Start position in the buffer

    DWORD _end;             // End position in the buffer

    wstring _value;         // String value of token
    
    //
    // This allows for collapsing multi-part tokens
    // such as user@domain.domain.domain into a single
    // token by the parser after the individual subparts
    // are verified
    //
    
    wstring _optValue;  
    
public:

    //
    // Constructor for a single-part token
    //
    
    AdlToken(IN const WCHAR *value,
             IN DWORD begin,
             IN DWORD end
             )
        { _value.append(value); _begin = begin; _end = end; }
    
    //
    // Constructor for a multi-part token
    //
    
    AdlToken(IN const WCHAR *value,
             IN const WCHAR *optValue,
             IN DWORD begin,
             IN DWORD end
             )
        { _value.append(value); _optValue.append(optValue);
          _begin = begin; _end = end; }


    //
    // Accessors
    //
    
    DWORD GetStart() const
        { return _begin; }
    
    DWORD GetEnd() const
        { return _end; }

    const WCHAR * GetValue() const
        { return _value.c_str(); }

    const WCHAR * GetOptValue() const
        { return (_optValue.empty() ? NULL : _optValue.c_str()); }
};




class AdlTree
/*++
   
   Class:              AdlTree
   
   Description:        
                
        This class contains the parsed information from a single ADL
        substatement, still in string form. The inheritance information
        is converted to a mask. The names contained are not necessarily
        valid however.
                
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{
private:

    list<const AdlToken *> _lpTokPrincipals;
    list<const AdlToken *> _lpTokExPrincipals;
    list<const AdlToken *> _lpTokPermissions;

    DWORD _dwInheritFlags;

public:

    //
    // Default to inherit-only, since "this object" must be specified
    // to clear that bit
    //

    AdlTree()
        { _dwInheritFlags = INHERIT_ONLY_ACE; }
    //
    // This outputs the ADL statement to stdout
    // Later to go to a string
    //
    
    void PrintAdl(wstring *pSz, PADL_PARSER_CONTROL pControl);

    //
    // Accessors/mutators
    // The Add*/Set* mutators are used by the YACC-generated AdlParse() 
    // function to store information as it is parsed, adding the tokens
    // to the correct places in the AdlTree
    //
    
    void AddPrincipal(IN const AdlToken * pTokPrincipal)
        { _lpTokPrincipals.push_back(pTokPrincipal); }

    void AddExPrincipal(IN const AdlToken * pTokPrincipal)
        { _lpTokExPrincipals.push_back(pTokPrincipal); }        

    void AddPermission(IN const AdlToken * pTokPermission)
        { _lpTokPermissions.push_back(pTokPermission); }

    //
    // Accessors used by AdlStat conversion functions
    //

    list<const AdlToken *> * GetPrincipals()  
        { return &_lpTokPrincipals; }

    list<const AdlToken *> * GetExPrincipals()  
        { return &_lpTokExPrincipals; }

    list<const AdlToken *> * GetPermissions() 
        { return &_lpTokPermissions; }

    //
    // Set/unset/get inheritance flags
    //

    void SetFlags(DWORD dwFlags)
        { _dwInheritFlags |= dwFlags; }

    void UnsetFlags(DWORD dwFlags)
        { _dwInheritFlags &= (~dwFlags); }

    void OverwriteFlags(DWORD dwFlags)
        { _dwInheritFlags = dwFlags; }

    DWORD GetFlags()
        { return _dwInheritFlags; }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\pch.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        P C H . H
//
// Contents:    pre-compiled header file
//
//
// History:     
//   31-March-2000  kumarp        created
//
//------------------------------------------------------------------------

#pragma once

#pragma warning(push, 3)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include "windows.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include <seopaque.h>
#include <sertlp.h>

#include <lm.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <rpc.h>
#include <rpcdce.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <lsarpc.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <kerberos.h>
#include <lsaisrv.h>
#include <alloca.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
#pragma warning(pop)

//  
// unreferenced inline removal
//

#pragma warning (disable: 4514)

//
// conditional expression is constant
//

#pragma warning (disable: 4127)

//
// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.
//

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\god.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include "authz.h"


#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

#define MY_MAX 1024

CHAR Buffer[MY_MAX];
CHAR TypeListBuffer[MY_MAX];

GUID Guid0 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x00}};
GUID Guid1 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x01}};
GUID Guid2 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x02}};
GUID Guid3 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x03}};
GUID Guid4 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x04}};
GUID Guid5 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x05}};
GUID Guid6 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x06}};
GUID Guid7 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x07}};
GUID Guid8 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x08}};

ULONG WORLD_SID[] = {0x101, 0x1000000, 0};

// S-1-5-21-397955417-626881126-188441444-2791022
ULONG KEDAR_SID[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x002a966e};

// S-1-5-21-397955417-626881126-188441444-2204519
ULONG RAHUL_SID[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x0021a367};

// S-1-5-21-397955417-626881126-188441444-2101332
ULONG ROBER_SID[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};

ULONG LOCAL_RAJ_SID[] = {0x00000501, 0x05000000, 21, 1085031214, 57989841, 725345543, 1002};
BOOL GlobalTruthValue = FALSE;

BOOL
MyAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    )
{
    *pbAceApplicable = GlobalTruthValue;

    return TRUE;
}

BOOL
MyComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    )
{
    ULONG Length = 0;

    *pSidCount = 2;
    *pRestrictedSidCount = 0;

    *pRestrictedSidAttrArray = 0;

    Length = RtlLengthSid((PSID) KEDAR_SID);
    Length += RtlLengthSid((PSID) RAHUL_SID);

    if (!(*pSidAttrArray = malloc(sizeof(SID_AND_ATTRIBUTES) * 2 + Length)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    (*pSidAttrArray)[0].Attributes = SE_GROUP_ENABLED;
    (*pSidAttrArray)[0].Sid = ((PUCHAR) (*pSidAttrArray)) + 2 * sizeof(SID_AND_ATTRIBUTES);
    RtlCopySid(Length/2, (*pSidAttrArray)[0].Sid, (PSID) KEDAR_SID);

    (*pSidAttrArray)[1].Attributes = SE_GROUP_USE_FOR_DENY_ONLY;
    (*pSidAttrArray)[1].Sid = ((PUCHAR) (*pSidAttrArray)) + 2 * sizeof(SID_AND_ATTRIBUTES) + Length/2;
    RtlCopySid(Length/2, (*pSidAttrArray)[1].Sid, (PSID) RAHUL_SID);

    // wprintf(L"Returning two groups in COMPUTE_DYNAMIC\n");

    return TRUE;
}

VOID
MyFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    )

{
    if (pSidAttrArray) free(pSidAttrArray);
}

ULONG Special[] = {0x101, 0x2000000, 2};

#if 1
void _cdecl wmain( int argc, WCHAR * argv[] )
{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOL b = TRUE;
    AUTHZ_RESOURCE_MANAGER_HANDLE RM = NULL;
    HANDLE hToken = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    AUTHZ_ACCESS_REQUEST Request;
    PAUTHZ_ACCESS_REPLY pReply = (PAUTHZ_ACCESS_REPLY) Buffer;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwErr;
    ULONG i = 0;
    PACE_HEADER Ace = NULL;
    DWORD AceCount = 0;
    LUID MySeLuid = {0, SE_SECURITY_PRIVILEGE};
    LUID MyOwLuid = {0, SE_TAKE_OWNERSHIP_PRIVILEGE};
    DWORD Len = 0;
    SID_AND_ATTRIBUTES SidAttr[10];
    AUTHZ_AUDIT_INFO_HANDLE AuditInfo;
    PAUTHZ_AUDIT_INFO_HANDLE pAuditInfo = NULL;

    CHAR TokenBuff[100];
    PTOKEN_PRIVILEGES TokenPriv = (PTOKEN_PRIVILEGES) TokenBuff;

    AUTHZ_HANDLE AuthHandle = 0;
    AUTHZ_HANDLE AuthHandlePS = 0;
    PACL pAcl = NULL;

    /*
    PWCHAR StringSD = L"O:BAG:DUD:(D;;0xFFFFFF;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-20) (A;;0xFFFFFF;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-21) (D;;0x60000;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201) (OA;;0x1;00000000-0000-0000-00000000;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201) S:(AU;IDSA;SD;;;DU)";

    PWCHAR StringSD = L"O:BAG:DUD:(D;;0xFFFFFF;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-20)
    (A;;0xFFFFFF;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-25)
    (D;;0x60000;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201)
    (A;;0x1;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201)
    (OA;;0x2;00000000-0000-0000-00000001;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201)
    (OD;;0x2;00000000-0000-0000-00000004;;s-0x1-000000000001-0)
    (OA;;0x4;00000000-0000-0000-00000002;;s-0x1-000000000005-20-220)
    (OA;;0x4;00000000-0000-0000-00000006;;s-0x1-000000000005-20-220)
    (OD;;0xC;00000000-0000-0000-00000000;;s-0x1-000000000005-20-221)
    (OA;;0x18;00000000-0000-0000-00000004;;s-0x1-000000000005-5-0-ae35)
    (OA;;0x38;00000000-0000-0000-00000001;;s-0x1-000000000002-0)
    (OA;;0xF90000;00000000-0000-0000-00000000;;s-0x1-000000000005-4)
    (OA;;0x1000000;00000000-0000-0000-00000004;;s-0x1-000000000005-b)
    S:(AU;IDSA;SD;;;DU)";

    */

    PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";
    // PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;SY)(A;;0x1;;;BA)S:(AU;IDSA;SD;;;DU)";
    // PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;SY)(A;;0x1;;;PS)S:(AU;IDSA;SD;;;DU)";

    TokenPriv->PrivilegeCount = 2;
    TokenPriv->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    TokenPriv->Privileges[0].Luid = MySeLuid;

    TokenPriv->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;
    TokenPriv->Privileges[1].Luid = MyOwLuid;

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSD, SDDL_REVISION_1, &pSD, NULL);

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }


    if (argc == 2)
    {
        wprintf(L"\n\n CALLBACK ACES!!!!\n\n");

        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD);

        // pAcl = (PACL) (((SECURITY_DESCRIPTOR_RELATIVE *) pSD)->Dacl + (PUCHAR) pSD);

        AceCount = pAcl->AceCount;
        for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
        {
            switch(Ace->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                Ace->AceType = ACCESS_ALLOWED_CALLBACK_ACE_TYPE;
                break;
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                Ace->AceType = ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE;
                break;
            }
        }
    }

    b = AuthzInitializeResourceManager(
            MyAccessCheck,
            MyComputeDynamicGroups,
            MyFreeDynamicGroups,
            NULL,
            0,                          // Flags
            &RM
            );

    if (!b)
    {
        wprintf(L"AuthzRMInitialize failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"AuthzRMInitialize succeeded\n");
    }

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        wprintf(L"OpenProcessToken failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"OpenProcessToken succeeded\n");
    }

    wprintf(L"Calling initialize token\n");

    b = AdjustTokenPrivileges(
            hToken,
            FALSE,
            TokenPriv,
            100,
            NULL,
            NULL
            );

    if (!b)
    {
        wprintf(L"Can not adjust privilege, %x\n", GetLastError());
        // return;
    }

    if (!wcscmp(argv[2], L"User"))
    {
        b = AuthzInitializeContextFromSid(
                // (PSID) LOCAL_RAJ_SID,
                (PSID) KEDAR_SID,
                NULL,
                RM,
                NULL,
                luid,
                0,
                NULL,
                &CC
                );
    }
    else
    {
        b = AuthzInitializeContextFromToken(
               hToken,
               RM,
               NULL,
               luid,
               0,
               NULL,
               &CC
               );
    }

    if (!wcscmp(argv[3], L"Audit"))
    {
        pAuditInfo = &AuditInfo;
    }

    pAuditInfo = &AuditInfo;

    if (!b)
    {
        wprintf(L"AuthzInitializeContextFromToken failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"AuthzInitializeContextFromToken succeeded\n");
    }


    Request.DesiredAccess = MAXIMUM_ALLOWED;
    Request.DesiredAccess = wcstol(argv[1], NULL, 16);
    wprintf(L"Desired = %x\n", Request.DesiredAccess);

    Request.ObjectTypeList = (POBJECT_TYPE_LIST) TypeListBuffer;

    Request.ObjectTypeList[0].Level = 0;
    Request.ObjectTypeList[0].ObjectType = &Guid0;
    Request.ObjectTypeList[0].Sbz = 0;

    Request.ObjectTypeList[1].Level = 1;
    Request.ObjectTypeList[1].ObjectType = &Guid1;
    Request.ObjectTypeList[1].Sbz = 0;

    Request.ObjectTypeList[2].Level = 2;
    Request.ObjectTypeList[2].ObjectType = &Guid2;
    Request.ObjectTypeList[2].Sbz = 0;

    Request.ObjectTypeList[3].Level = 2;
    Request.ObjectTypeList[3].ObjectType = &Guid3;
    Request.ObjectTypeList[3].Sbz = 0;

    Request.ObjectTypeList[4].Level = 1;
    Request.ObjectTypeList[4].ObjectType = &Guid4;
    Request.ObjectTypeList[4].Sbz = 0;

    Request.ObjectTypeList[5].Level = 2;
    Request.ObjectTypeList[5].ObjectType = &Guid5;
    Request.ObjectTypeList[5].Sbz = 0;

    Request.ObjectTypeList[6].Level = 3;
    Request.ObjectTypeList[6].ObjectType = &Guid6;
    Request.ObjectTypeList[6].Sbz = 0;

    Request.ObjectTypeList[7].Level = 2;
    Request.ObjectTypeList[7].ObjectType = &Guid7;
    Request.ObjectTypeList[7].Sbz = 0;

    Request.ObjectTypeListLength = 8;
    Request.OptionalArguments = NULL;

    Request.PrincipalSelfSid = NULL;

    pReply->ResultListLength = 8;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);

    b = AuthzAccessCheck(
            CC,
            &Request,
            pAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandle
            );

    if (!b)
    {
        wprintf(L"AccessCheck no SELF failed\n");
        return;
    }
    else
    {
        wprintf(L"\nAccessCheck no SELF succeeded\n\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"i = %d, AccessMask = %x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    Request.PrincipalSelfSid = (PSID) RAHUL_SID;

    GlobalTruthValue = TRUE;

    SidAttr[0].Attributes = SE_GROUP_ENABLED;
    SidAttr[0].Sid = (PSID) Special;
//
//     b = AuthzAddSidsToContext(
//             CC,
//             SidAttr,
//             1,
//             NULL,
//             0
//             );
//
//     if (!b)
//     {
//         wprintf(L"AuthzNormalGroups failed with %d\n", GetLastError());
//         return;
//     }
//
    b = AuthzAccessCheck(
            CC,
            &Request,
            pAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandlePS
            );

    if (!b)
    {
        wprintf(L"AccessCheck SELF = ROBER failed\n");
        return;
    }
    else
    {
        wprintf(L"\nAccessCheck SELF + ROBER succeeded\n\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"i = %d, AccessMask = %x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    Request.PrincipalSelfSid = NULL;

    GlobalTruthValue = FALSE;

    if (AuthHandlePS)
    {
        b = AuthzCachedAccessCheck(
                AuthHandlePS,
                &Request,
                pAuditInfo,
                pReply
                );

        if (!b)
        {
            wprintf(L"CachedAccessCheck failed\n");
            return;
        }
        else
        {
            wprintf(L"\nCachedAccessCheck succeeded\n\n");

            for (i = 0; i < pReply->ResultListLength; i++)
            {
                wprintf(L"i = %d, AccessMask = %x, Error = %d\n",
                        i, pReply->GrantedAccessMask[i], pReply->Error[i]);
            }
        }
        AuthzFreeHandle(AuthHandlePS);
    }
    else
    {
        wprintf(L"No CachedAccessCheck done since NULL = AuthHandlePS\n");
    }

    if (AuthHandle)
    {
        Request.PrincipalSelfSid = (PSID) RAHUL_SID;

        GlobalTruthValue = TRUE;
        b = AuthzCachedAccessCheck(
                AuthHandle,
                &Request,
                pAuditInfo,
                pReply
                );

        if (!b)
        {
            wprintf(L"CachedAccessCheck failed\n");
            return;
        }
        else
        {
            wprintf(L"\nCachedAccessCheck succeeded\n\n");

            for (i = 0; i < pReply->ResultListLength; i++)
            {
                wprintf(L"i = %d, AccessMask = %x, Error = %d\n",
                        i, pReply->GrantedAccessMask[i], pReply->Error[i]);
            }
        }

        AuthzFreeHandle(AuthHandle);
    }
    else
    {
        wprintf(L"No CachedAccessCheck done since NULL = AuthHandle\n");
    }

    AuthzFreeContext(CC);

    return;
}

#else

void _cdecl wmain( int argc, WCHAR * argv[] )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i = 0, j = 0;

    BOOL b = TRUE;
    AUTHZ_RESOURCE_MANAGER RM = NULL;
    HANDLE hToken = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    AUTHZ_ACCESS_REQUEST Request;
    PAUTHZ_ACCESS_REPLY pReply = (PAUTHZ_ACCESS_REPLY) Buffer;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwErr;
    PACE_HEADER Ace = NULL;
    DWORD AceCount = 0;
    LUID MySeLuid = {0, SE_SECURITY_PRIVILEGE};
    LUID MyOwLuid = {0, SE_TAKE_OWNERSHIP_PRIVILEGE};
    DWORD Len = 0;
    SID_AND_ATTRIBUTES SidAttr[10];
    AUTHZ_AUDIT_INFO AuditInfo;
    PAUTHZ_AUDIT_INFO pAuditInfo = NULL;

    CHAR TokenBuff[100];
    PTOKEN_PRIVILEGES TokenPriv = (PTOKEN_PRIVILEGES) TokenBuff;

    AUTHZ_HANDLE AuthHandle = 0;
    AUTHZ_HANDLE AuthHandlePS = 0;
    PACL pAcl = NULL;


    PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSD, SDDL_REVISION_1, &pSD, NULL);

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }

    b = AuthzRMInitialize(
            MyAccessCheck,
            MyComputeDynamicGroups,
            MyFreeDynamicGroups,
            NULL,
            0,
            &RM
            );

    if (!b)
    {
        wprintf(L"AuthzRMInitialize failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"AuthzRMInitialize succeeded\n");
    }

    Request.DesiredAccess = 0x101;
    wprintf(L"Desired = %x\n", Request.DesiredAccess);

    Request.ObjectTypeList = (POBJECT_TYPE_LIST) TypeListBuffer;

    Request.ObjectTypeList[0].Level = 0;
    Request.ObjectTypeList[0].ObjectType = &Guid0;
    Request.ObjectTypeList[0].Sbz = 0;

    Request.ObjectTypeList[1].Level = 1;
    Request.ObjectTypeList[1].ObjectType = &Guid1;
    Request.ObjectTypeList[1].Sbz = 0;

    Request.ObjectTypeList[2].Level = 2;
    Request.ObjectTypeList[2].ObjectType = &Guid2;
    Request.ObjectTypeList[2].Sbz = 0;

    Request.ObjectTypeList[3].Level = 2;
    Request.ObjectTypeList[3].ObjectType = &Guid3;
    Request.ObjectTypeList[3].Sbz = 0;

    Request.ObjectTypeList[4].Level = 1;
    Request.ObjectTypeList[4].ObjectType = &Guid4;
    Request.ObjectTypeList[4].Sbz = 0;

    Request.ObjectTypeList[5].Level = 2;
    Request.ObjectTypeList[5].ObjectType = &Guid5;
    Request.ObjectTypeList[5].Sbz = 0;

    Request.ObjectTypeList[6].Level = 2;
    Request.ObjectTypeList[6].ObjectType = &Guid6;
    Request.ObjectTypeList[6].Sbz = 0;

    Request.ObjectTypeListLength = 7;
    Request.OptionalArguments = NULL;

    Request.PrincipalSelfSid = NULL;

    pReply->ResultListLength = 7;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        // wprintf(L"OpenProcessToken failed with %d\n", GetLastError());
        return;
    }
    else
    {
        // wprintf(L"OpenProcessToken succeeded\n");
    }

    // wprintf(L"Calling initialize token\n");

    b = AuthzInitializeContextFromToken(
               hToken,
               RM,
               NULL,
               luid,
               0,
               NULL,
               &CC
               );

    if (!b)
    {
        // wprintf(L"AuthzInitializeContextFromToken failed\n");
        return;
    }

    for (i = 0; i < 100000; i++)
    {
        DWORD StartTime, EndTime;

        StartTime = GetCurrentTime();

        for (j = 0; j < 50000; j++)
        {
            b = AuthzAccessCheck(
                    CC,
                    &Request,
                    pAuditInfo,
                    pSD,
                    NULL,
                    0,
                    pReply,
                    0
                    );

            if (!b)
            {
                // wprintf(L"AccessCheck no SELF failed\n");
                return;
            }


        }

        EndTime = GetCurrentTime();
        wprintf(L"Time taken %d\n", EndTime - StartTime);
    }

    AuthzFreeContext(CC);
    CloseHandle(hToken);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\adlinterface.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adlinterface.h

Abstract:

    The interface used to specify a language definition to the ADL parser

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#pragma once

//
// YACC-generated tokens
// Language type tokens are in this file
//

#include "tokens.h"

//
// Languages currently supported by the parser
// The ADL_LANGUAGE_* parameter should be used in the ADL_LANGUAGE_SPEC
// structure
//

#define ADL_LANGUAGE_ENGLISH TK_LANG_ENGLISH
#define ADL_LANGUAGE_REVERSE TK_LANG_REVERSE


typedef struct 
/*++
   
   Struct:              ADL_MASK_STRING
   
   Description:        
                
        This is used to specify a mapping between permission strings
        and access masks in the ADL_PARSER_CONTROL structure.
        
        A list of these is traversed in order to map an access mask
        to a set of strings, or a set of strings to an access mask
 
--*/
{
    ACCESS_MASK mask;
    WCHAR *str;
} ADL_MASK_STRING, *PADL_MASK_STRING;


//
// ADL Language Definition, includes grammar type, characters,
// and special token strings
//

typedef struct
/*++
   
   Struct:              ADL_LANGUAGE_SPEC
   
   Description:        
        
        This is used to define the locale-specific detail about the language
        to be used by the ADL parser, such as all specific characters and
        string tokens.
        
        Requirement: All CH_* characters must be distinct. If two of the
                     characters were identical, the lexer behavior would be
                     undefined.
     
        Requirement: All SZ_ strings must be non-null, NULL terminated,
                     and distinct. Distinctness is not verified, and is 
                     left to the user.
                     
        Requirement: dwLanguageType must be one of the language types supported
                     by the given version of the parser. Valid languages are
                     defined above.
 
--*/
{
    //
    // Grammar type (see adl.y for supported grammar types)
    //
    
    DWORD dwLanguageType;

    //
    // Whitespace
    //
    
    WCHAR CH_NULL;
    WCHAR CH_SPACE;
    WCHAR CH_TAB;
    WCHAR CH_NEWLINE;
    WCHAR CH_RETURN;

    //
    // Separators
    //
    
    WCHAR CH_QUOTE;
    WCHAR CH_COMMA;
    WCHAR CH_SEMICOLON;
    WCHAR CH_OPENPAREN;
    WCHAR CH_CLOSEPAREN;

    //
    // Domain / username specifiers
    //
    
    WCHAR CH_AT;
    WCHAR CH_SLASH;
    WCHAR CH_PERIOD;

    //
    // padding
    //
    
    WORD sbz0;

    //
    // ADL-specific tokens
    //
    
    WCHAR * SZ_TK_AND;
    WCHAR * SZ_TK_EXCEPT;
    WCHAR * SZ_TK_ON;
    WCHAR * SZ_TK_ALLOWED;
    WCHAR * SZ_TK_AS;

    //
    // Inheritance specifier tokens
    // 
    
    WCHAR * SZ_TK_THIS_OBJECT;
    WCHAR * SZ_TK_CONTAINERS;
    WCHAR * SZ_TK_OBJECTS;
    WCHAR * SZ_TK_CONTAINERS_OBJECTS;
    WCHAR * SZ_TK_NO_PROPAGATE;

    
} ADL_LANGUAGE_SPEC, *PADL_LANGUAGE_SPEC;


typedef struct
/*++
   
   Struct:              ADL_PARSER_CONTROL
   
   Description:        
        
        This is used to define the behavior of the ADL parser / printer.
        
        Requirement: pLand be non-NULL and valid (see 
                     comments in ADL_LANGUAGE_SPEC definition).
     
        Requirement: pPermissions must be non-null and must be an array of 1
                     or more ADL_MASK_STRING structs with non-NULL strings
                     and non-zero masks. This must be terminated by an entry
                     with a NULL string and a 0 mask.
                     
        Requirement: pPermissions may NOT contain any access masks such that
                     the bitwise AND of that mask and either amNeverSet or
                     amSetAllow is non-zero.
        
        Requirement: For any access mask or subset of one that could be 
                     encountered in the given use of ADL, there must exist a set
                     of pPermissions entries such that the logical OR of that 
                     set (ANDed with the negation of amNeverSet and amSetAllow) 
                     is equal to the access mask encountered. This means that
                     any bit used should have a name associated with it, though
                     masks with multiple bits may be specified.
                     
        Requirement: If mask B is a subset of mask A, then the entry for mask
                     A MUST appear before the entry for mask B, otherwise there
                     will be redundant permission names in the produced ADL
                     statements.
                      
--*/
{
    //
    // Language specification
    //

    PADL_LANGUAGE_SPEC pLang;

    //
    // Permission mapping
    //

    PADL_MASK_STRING pPermissions;

    //
    // Special cases for permission bits never to be set in an ACE
    // such as MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY
    //

    ACCESS_MASK amNeverSet;

    //
    // Special cases for bits which are to be set in all allows
    // and never set in denies. 
    //
    // With files, for example, this is the SYNCHRONIZE bit
    //

    ACCESS_MASK amSetAllow;


} ADL_PARSER_CONTROL, *PADL_PARSER_CONTROL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\adllexer.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   adllexer.cpp

Abstract:

   Implementation of the lexer for the ADL language

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "adl.h"

//
// Constant values outside WCHAR range, for special characters
//

#define CHAR_COMMA      65538
#define CHAR_QUOTE      65539
#define CHAR_SEMICOLON  65540
#define CHAR_OPENPAREN  65541
#define CHAR_CLOSEPAREN 65542
#define CHAR_NULL       65543
#define CHAR_NEWLINE    65544
#define CHAR_RETURN     65545
#define CHAR_TAB        65546
#define CHAR_SPACE      65547
#define CHAR_AT         65548
#define CHAR_SLASH      65549
#define CHAR_PERIOD     65550

//
// States of the lexer DFA
//

#define STATE_WHITESPACE    0
#define STATE_BEGIN         1
#define STATE_IDENT         2
#define STATE_QUOTE         3
#define STATE_DONE          4


//
// If the character is found in the special character map, use the special
// symbol (>65535), otherwise use the regular character value
//

#define RESOLVE_CHAR(CHAR, MAP, ITER, ITEREND) \
   ((((ITER) = (MAP).find((CHAR)) ) == (ITEREND) ) ? (CHAR) : (*(ITER)).second)
        


AdlLexer::AdlLexer(IN       const WCHAR *input,
                   IN OUT   AdlStatement *adlStat,
                   IN       const PADL_LANGUAGE_SPEC pLang) 
/*++

Routine Description:

    Constructor for the AdlLexer. Initializes the mapping for finding special 
    characters, and other initial state information   

Arguments:

    input   -   The input string
    
    adlStat -   The AdlStatement instance, for token garbage collection
    
    pLang   -   The ADL language description

Return Value:
    
    none    
    
--*/

{

    _input = input;
    _pLang = pLang;
    _adlStat = adlStat;

    _position = 0;
    _tokCount = 0;


    //
    // Special character mapping
    //

    _mapCharCode[_pLang->CH_NULL] = CHAR_NULL;
    _mapCharCode[_pLang->CH_SPACE] = CHAR_SPACE;
    _mapCharCode[_pLang->CH_TAB] = CHAR_TAB;
    _mapCharCode[_pLang->CH_NEWLINE] = CHAR_NEWLINE;
    _mapCharCode[_pLang->CH_RETURN] = CHAR_RETURN;
    _mapCharCode[_pLang->CH_QUOTE] = CHAR_QUOTE;
    _mapCharCode[_pLang->CH_COMMA] = CHAR_COMMA;
    _mapCharCode[_pLang->CH_SEMICOLON] = CHAR_SEMICOLON;
    _mapCharCode[_pLang->CH_OPENPAREN] = CHAR_OPENPAREN;
    _mapCharCode[_pLang->CH_CLOSEPAREN] = CHAR_CLOSEPAREN;
    _mapCharCode[_pLang->CH_AT] = CHAR_AT;
    _mapCharCode[_pLang->CH_SLASH] = CHAR_SLASH;
    _mapCharCode[_pLang->CH_PERIOD] = CHAR_PERIOD;

    //
    // Only find end of map once
    //

    _iterEnd = _mapCharCode.end();


    //
    // Place all special tokens into a map, for O(log n) string searches
    //

    _mapStringToken[_pLang->SZ_TK_AND] = TK_AND;
    _mapStringToken[_pLang->SZ_TK_EXCEPT] = TK_EXCEPT;
    _mapStringToken[_pLang->SZ_TK_ON] = TK_ON;
    _mapStringToken[_pLang->SZ_TK_ALLOWED] = TK_ALLOWED;
    _mapStringToken[_pLang->SZ_TK_AS] = TK_AS;
    _mapStringToken[_pLang->SZ_TK_THIS_OBJECT] = TK_THIS_OBJECT;
    _mapStringToken[_pLang->SZ_TK_CONTAINERS] = TK_CONTAINERS;
    _mapStringToken[_pLang->SZ_TK_OBJECTS] = TK_OBJECTS;
    _mapStringToken[_pLang->SZ_TK_CONTAINERS_OBJECTS] = TK_CONTAINERS_OBJECTS;
    _mapStringToken[_pLang->SZ_TK_NO_PROPAGATE] = TK_NO_PROPAGATE;

}


DWORD AdlLexer::NextToken(OUT AdlToken **value) 
/*++

Routine Description:

    This retrieves the next token from the input string. This is basically a
    DFA which begins in the WHITESPACE state, and runs until it reaches
    the DONE state, at which point it returns a token. 
    
Arguments:

    value   -   Pointer to a new token containing the string value
                is stored in *value
                
Return Value:
    
    DWORD   -   The token type, as #define'd by YACC in tokens.h
    
--*/
{

    //
    // Initial DFA state
    //

    DWORD state = STATE_WHITESPACE;
    
    DWORD tokType = TK_ERROR;
    
    wstring curToken;
    
    DWORD dwInput;

    DWORD dwTokStart = 0;

    // 
    // First token should be the grammar type
    //

    if( _tokCount == 0 ) 
    {
        _tokCount++;
        return _pLang->dwLanguageType;
        
    }


    dwInput = RESOLVE_CHAR(_input[_position], _mapCharCode, _iter, _iterEnd);

    while( state != STATE_DONE ) 
    {
        switch( state ) 
        {

        case STATE_WHITESPACE:

            switch( dwInput ) 
            {
            
            case CHAR_NULL:
                tokType = 0;
                state = STATE_DONE;
                break;

            case CHAR_NEWLINE:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);

                break;

            case CHAR_RETURN:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                
                break;

            case CHAR_SPACE:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                break;

            case CHAR_TAB:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                break;

            default:
                state = STATE_BEGIN;
                break;
            }
            
            break;
            
        case STATE_BEGIN:

            dwTokStart = _position;

            tokType = TK_ERROR;

            switch( dwInput ) 
            {
            case CHAR_NULL:
                state = STATE_DONE;
                break;

            case CHAR_COMMA:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_COMMA;
                }

            case CHAR_OPENPAREN:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_OPENPAREN;
                }

            case CHAR_CLOSEPAREN:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_CLOSEPAREN;
                }

            case CHAR_SEMICOLON:
                if( tokType == TK_ERROR )
                { 
                    tokType = TK_SEMICOLON;
                }

            case CHAR_AT:
                if( tokType == TK_ERROR )
                { 
                    tokType = TK_AT;
                }

            case CHAR_SLASH:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_SLASH;
                }

            case CHAR_PERIOD:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_PERIOD;
                }

                //
                // Same action for all special single-char tokens
                //
                curToken.append( &(_input[_position]), 1 );
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);

                state = STATE_DONE;
                break;
            
            case CHAR_QUOTE:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);

                state = STATE_QUOTE;
                tokType = TK_IDENT;
                break;

            default:
                state = STATE_IDENT;
                tokType = TK_IDENT;
                break;
            }

            break;

        case STATE_IDENT:

            switch( dwInput ) 
            {
            case CHAR_NULL:
            case CHAR_COMMA:
            case CHAR_OPENPAREN:
            case CHAR_CLOSEPAREN:
            case CHAR_SEMICOLON:
            case CHAR_NEWLINE:
            case CHAR_RETURN:
            case CHAR_TAB:
            case CHAR_SPACE:
            case CHAR_AT:
            case CHAR_SLASH:
            case CHAR_PERIOD:
            case CHAR_QUOTE:

                state = STATE_DONE;
                break;

            default:
                curToken.append( &(_input[_position]), 1 );
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);

                break;
            }

            break;

        case STATE_QUOTE:

            switch( dwInput ) 
            {
            case CHAR_NULL:
            case CHAR_TAB:
            case CHAR_NEWLINE:
            case CHAR_RETURN:
                throw AdlStatement::ERROR_UNTERMINATED_STRING;
                break;
            

            case CHAR_QUOTE:

                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                state = STATE_DONE;
                break;

            default:
                curToken.append( &(_input[_position]), 1 );
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                break;
            }

            break;

        default:

            //
            // Should never get here, well-defined states
            //

            assert(FALSE);
            break;
        }
    }
    
    //
    // Done state was reached
    // Export the string and column/row info in YACC-form here
    //
    
    AdlToken *outVal;
    
    outVal = new AdlToken(curToken.c_str(), dwTokStart, _position - 1);
    
    _adlStat->AddToken(outVal);

    //
    // Check if the string is a special token, case-insensitive
    //

    if( _mapStringToken.find(outVal->GetValue()) != _mapStringToken.end() )
    {
        tokType = _mapStringToken[outVal->GetValue()];
    }


    *value = outVal;

	// 
	// Set this token to be the error token. This way, if the string is
	// not accepted by the parser, we know at which token the parser failed
	// If another error occurs later, this value will be overwritten
	//

	_adlStat->SetErrorToken(outVal);

    _tokCount++;

    return tokType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\adlconvert.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adlconvert.h

Abstract:

   The private header file for the ADL conversion routines

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#pragma once


//
// Weights for the weight function to determine the optimal pops
// These weights can be modified to change the behavior of the conversion.
// The algorithm selects an action by trying to maximize the weight of the 
// action. For more flexibility (such as squaring some quentities, etc),
// the algorithm itself should be changed in FindOptimalPop()
//
// RESTRICTION: The weight of popping a block of any height off a single stack 
// 				MUST be positive
//

//
// This quantity is added to the weight of the action for every additional
// permission bit expressed by the ADL statement created by this action.
//

#define WEIGHT_PERM_BIT (4)

//
// This quantity is added to the weight of the action for every additional
// Principal expressed by the ADL statement created by this action.
//

#define WEIGHT_STACK_HEIGHT (7)

//
// This quantity is added to the weight of the action for every item which
// will have to be popped off in order to take this action. See the algorithm
// description in adlconvert.cpp for more details. 
//

#define WEIGHT_ITEM_ABOVE_POP (-5)


//
// This quantity is added for every permission name beyond the first needed
// to express a given access mask. This should be a penalty, however for
// better results this should NOT negate the bonus from WEIGHT_PERM_BIT.
// Therefore, if this is negative, it should be greater than (- WEIGHT_PERM_BIT)
//

#define WEIGHT_PERMISSION_NAME (-1)

//
// The stacks in the DACL->ADL conversion consist of these elements
//

typedef struct
{
    PSID pSid;
    DWORD dwFlags;
    BOOL bAllow;
} BIT_STACK_ELEM, *PBIT_STACK_ELEM;


//
// Forward declarations for DACL->ADL conversion
//

DWORD GetStackBlockSize(
                        IN const PBIT_STACK_ELEM pStack,
                        IN DWORD dwStartOffset,
                        IN DWORD dwStackSize 
                        );



void ConvertDaclToStacks(
                        IN      const PACL pDacl,
                        IN      const PADL_PARSER_CONTROL pControl,
                        OUT     DWORD pdwStackSize[32],
                        OUT     PBIT_STACK_ELEM pStacks[32]
                        );

BOOL FindBlockInStack(
                        IN      const PBIT_STACK_ELEM pBlock,
                        IN      const DWORD dwBlockSize,
                        IN      const PBIT_STACK_ELEM pStack,
                        IN      const DWORD dwStackSize,
                        IN      const DWORD dwStackTop,
                        OUT     PDWORD pdwBlockStart
                        );

BOOL FindOptimalPop(
                        IN      const PADL_PARSER_CONTROL pControl,
                        IN      const PBIT_STACK_ELEM pStacks[32],
                        IN      const DWORD pdwStackSize[32],
                        IN      const DWORD pdwStackTop[32],
                        OUT     PDWORD pdwStacksPopped,
                        OUT     PDWORD pdwBlockSize,
                        OUT     DWORD pdwPopOffsets[32]
                        );

void ConvertStacksToPops(
                        IN      const PADL_PARSER_CONTROL pControl,
                        IN      const PBIT_STACK_ELEM pStacks[32],
                        IN      const DWORD pdwStackSize[32],
                        IN      const DWORD pdwStackTop[32],
                        OUT     list< pair<DWORD, DWORD> > * pListPops
                        );

DWORD NumStringsForMask(
						IN     const PADL_PARSER_CONTROL pControl,
						IN     ACCESS_MASK amMask
						);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\adlparser.cpp ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   adl.y/adlparser.cpp

Abstract:

   YACC parser definition for the ADL language
   AdlParser::ParseAdl() function

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/

#include "pch.h"
#include "adl.h"

/**/
/* YACC generates some long->short automatic conversion, disable the warning*/
/**/
#pragma warning(disable : 4242)

/**/
/* ISSUE-2000/08/28-t-eugenz*/
/* This is a private netlib function. */
/**/
    
extern "C" NET_API_STATUS
NetpwNameValidate(
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

/**/
/* Name types for I_NetName* and I_NetListCanonicalize*/
/**/

#define NAMETYPE_USER           1
#define NAMETYPE_PASSWORD       2
#define NAMETYPE_GROUP          3
#define NAMETYPE_COMPUTER       4
#define NAMETYPE_EVENT          5
#define NAMETYPE_DOMAIN         6
#define NAMETYPE_SERVICE        7
#define NAMETYPE_NET            8
#define NAMETYPE_SHARE          9
#define NAMETYPE_MESSAGE        10
#define NAMETYPE_MESSAGEDEST    11
#define NAMETYPE_SHAREPASSWORD  12
#define NAMETYPE_WORKGROUP      13



/**/
/* Validate various tokens, with error handling*/
/* have to cast away const, since NetpNameValidate takes a non-const for some*/
/* reason*/
/**/

#define VALIDATE_USERNAME(TOK) \
    if( NetpwNameValidate( \
                          (WCHAR *)(TOK)->GetValue(), \
                          NAMETYPE_USER, \
                          0) != ERROR_SUCCESS) \
    { \
        this->SetErrorToken( TOK ); \
        throw AdlStatement::ERROR_INVALID_USERNAME; \
    }

#define VALIDATE_DOMAIN(TOK) \
    if( NetpwNameValidate( \
                          (WCHAR *)(TOK)->GetValue(), \
                          NAMETYPE_DOMAIN, \
                          0) != ERROR_SUCCESS) \
    { \
        this->SetErrorToken( TOK ); \
        throw AdlStatement::ERROR_INVALID_DOMAIN; \
    }
    
#define VALIDATE_PERMISSION(TOK) \
    { \
        for(DWORD i = 0;; i++) \
        { \
            if( (_pControl->pPermissions)[i].str == NULL ) \
            { \
                this->SetErrorToken( TOK ); \
                throw AdlStatement::ERROR_UNKNOWN_PERMISSION; \
            } \
            if(!_wcsicmp(TOK->GetValue(), \
                         (_pControl->pPermissions)[i].str)) \
            { \
                break; \
            } \
        } \
    }


/**/
/* YACC value type*/
/**/

#define YYSTYPE AdlToken *

/**/
/* YACC error handler: raise an exception*/
/**/

void yyerror(char *szErr)
{
    throw AdlStatement::ERROR_NOT_IN_LANGUAGE;
}



#define TK_ERROR 257
#define TK_IDENT 258
#define TK_AT 259
#define TK_SLASH 260
#define TK_PERIOD 261
#define TK_COMMA 262
#define TK_OPENPAREN 263
#define TK_CLOSEPAREN 264
#define TK_SEMICOLON 265
#define TK_EXCEPT 266
#define TK_ON 267
#define TK_ALLOWED 268
#define TK_AND 269
#define TK_AS 270
#define TK_THIS_OBJECT 271
#define TK_CONTAINERS 272
#define TK_OBJECTS 273
#define TK_CONTAINERS_OBJECTS 274
#define TK_NO_PROPAGATE 275
#define TK_LANG_ENGLISH 276
#define TK_LANG_REVERSE 277
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,    1,    1,    3,    3,    2,    2,    8,    8,
    4,    4,    4,    5,    5,    5,    6,    6,    6,   10,
    7,    7,    7,    9,    9,   13,   13,   13,   14,   14,
   12,   12,   12,   12,   12,   11,   11,   11,   11,   11,
   11,   11,
};
short yylen[] = {                                         2,
    2,    2,    1,    2,   10,    6,    1,    2,   10,    6,
    1,    3,    3,    1,    3,    3,    1,    3,    3,    1,
    1,    3,    3,    1,    3,    3,    3,    1,    1,    3,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,
};
short yydefred[] = {                                      0,
    0,    0,    0,   42,   36,   40,   41,   37,   38,   39,
    0,    3,    0,   11,    0,    0,    0,    0,    0,    0,
    7,    4,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    8,    0,   12,    0,    0,   17,   20,   13,   29,
    0,   25,   27,   30,    0,   14,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   19,   31,   32,   33,
   34,   35,    0,   21,   18,   15,    0,   16,    0,    0,
    0,    6,    0,    0,   10,    0,   23,   22,    0,    0,
    0,    0,    0,    5,    9,
};
short yydgoto[] = {                                       3,
   11,   19,   12,   13,   45,   36,   63,   21,   14,   37,
   15,   64,   16,   17,
};
short yysindex[] = {                                   -222,
 -238, -210,    0,    0,    0,    0,    0,    0,    0,    0,
 -238,    0, -184,    0, -249, -257, -136, -248, -210, -254,
    0,    0, -238, -240, -238, -238, -238, -238, -238, -238,
 -238,    0, -238,    0, -238, -179,    0,    0,    0,    0,
 -227,    0,    0,    0, -224,    0, -176, -220, -238, -152,
 -238, -238, -238, -238, -152, -216,    0,    0,    0,    0,
    0,    0, -173,    0,    0,    0, -168,    0, -167, -238,
 -152,    0, -152, -238,    0, -163,    0,    0, -159, -152,
 -152, -153, -151,    0,    0,
};
short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   41,    0,    0,    0, -199, -187,    0,    0,   80,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -196,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,
};
short yygindex[] = {                                      0,
    0,    0,   76,   -2,   62,  -31,  -44,   86,  -19,  -28,
  -24,  -49,   79,   88,
};
#define YYTABLESIZE 125
short yytable[] = {                                      20,
   38,   47,   40,   34,   43,   44,   39,   23,   38,   27,
   69,   46,   28,   33,   26,   46,   20,   31,    4,    5,
   57,   77,   65,   78,   38,   35,   38,    6,    7,    8,
    9,   10,   66,   30,   68,   82,   83,   52,   76,   53,
    1,   52,   79,   56,   54,   38,    4,    5,   54,   38,
   67,   70,   18,    1,    2,    6,    7,    8,    9,   10,
   29,   29,   28,   28,   28,   26,   26,   26,   28,   28,
   28,   26,   26,   26,   24,   24,   24,   23,   24,    2,
   24,   24,   49,   25,   26,   49,   22,   50,   71,   51,
   55,   72,   51,   23,   71,   73,   48,   75,   49,   74,
   26,   73,   49,   80,   32,   51,   42,   81,   71,   51,
   71,   84,    0,   85,   41,   73,    0,   73,   58,   59,
   60,   61,   62,   29,   30,
};
short yycheck[] = {                                       2,
   25,   33,   27,   23,   29,   30,   26,  262,   33,  259,
   55,   31,  270,  268,  269,   35,   19,  266,  257,  258,
   49,   71,   51,   73,   49,  266,   51,  266,  267,  268,
  269,  270,   52,  261,   54,   80,   81,  262,   70,  264,
    0,  262,   74,  264,  269,   70,  257,  258,  269,   74,
   53,  268,  263,  276,  277,  266,  267,  268,  269,  270,
  260,  261,  262,  263,  264,  262,  263,  264,  268,  269,
  270,  268,  269,  270,  262,  263,  264,  262,  263,    0,
  268,  269,  262,  268,  269,  262,   11,  267,  262,  269,
  267,  265,  269,  262,  262,  269,   35,  265,  262,  268,
  269,  269,  262,  267,   19,  269,   28,  267,  262,  269,
  262,  265,   -1,  265,   27,  269,   -1,  269,  271,  272,
  273,  274,  275,  260,  261,
};
#define YYFINAL 3
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 277
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
#define yystacksize YYSTACKSIZE
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
AdlStatement::ParseAdl(const WCHAR *szInput)
{
    register int yym, yyn, yystate;

	int yydebug = 0;
	int yynerrs;
	int yyerrflag;
	int yychar;
	short *yyssp;
	YYSTYPE *yyvsp;
	YYSTYPE yyval;
	YYSTYPE yylval;
	short yyss[YYSTACKSIZE];
	YYSTYPE yyvs[YYSTACKSIZE];
	AdlLexer Lexer(szInput, this, _pControl->pLang);


    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = Lexer.NextToken(&yylval)) < 0) yychar = 0;
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{
            /**/
            /* At the end of all ADL_STATEMENT's*/
            /* pop the extra AdlTree that was pushed*/
            /* on when the last ADL_STATEMENT*/
            /* was completed*/
            /**/
            
            this->PopEmpty();
        }
break;
case 2:
{
            /**/
            /* At the end of all ADL_STATEMENT's*/
            /* pop the extra AdlTree that was pushed*/
            /* on when the last ADL_STATEMENT*/
            /* was completed*/
            /**/
            
            this->PopEmpty();
        }
break;
case 5:
{
            this->Next();
        }
break;
case 6:
{
            this->Next();
        }
break;
case 9:
{
            this->Next();
        }
break;
case 10:
{
            this->Next();
        }
break;
case 11:
{
            this->Cur()->AddPrincipal( yyvsp[0] ); 
        }
break;
case 12:
{       
            this->Cur()->AddPrincipal( yyvsp[0] ); 
        }
break;
case 13:
{       
            this->Cur()->AddPrincipal( yyvsp[0] ); 
        }
break;
case 14:
{
            this->Cur()->AddExPrincipal( yyvsp[0] ); 
        }
break;
case 15:
{
            this->Cur()->AddExPrincipal( yyvsp[0] ); 
        }
break;
case 16:
{
            this->Cur()->AddExPrincipal( yyvsp[0] ); 
        }
break;
case 17:
{       
            this->Cur()->AddPermission( yyvsp[0] ); 
        }
break;
case 18:
{       
            this->Cur()->AddPermission( yyvsp[0] );
        }
break;
case 19:
{       
            this->Cur()->AddPermission( yyvsp[0] );
        }
break;
case 20:
{
            VALIDATE_PERMISSION(yyvsp[0]);
        }
break;
case 25:
{       
            /**/
            /* For now, impersonation is not supported*/
            /**/
            
            throw AdlStatement::ERROR_IMPERSONATION_UNSUPPORTED;
        }
break;
case 26:
{       
            VALIDATE_USERNAME(yyvsp[-2]);
            VALIDATE_DOMAIN(yyvsp[0]);
            AdlToken *newTok = new AdlToken(yyvsp[-2]->GetValue(),
                                            yyvsp[0]->GetValue(),
                                            yyvsp[-2]->GetStart(),
                                            yyvsp[0]->GetEnd());
            this->AddToken(newTok);
            yyval = newTok;
        }
break;
case 27:
{       

            VALIDATE_USERNAME(yyvsp[0]);
            VALIDATE_DOMAIN(yyvsp[-2]);
            AdlToken *newTok = new AdlToken(yyvsp[0]->GetValue(),
                                            yyvsp[-2]->GetValue(),
                                            yyvsp[-2]->GetStart(), 
                                            yyvsp[0]->GetEnd());
            this->AddToken(newTok);
            yyval = newTok;
        }
break;
case 28:
{
            VALIDATE_USERNAME(yyvsp[0]);
            yyval = yyvsp[0];
        }
break;
case 30:
{
            /**/
            /* Concatenate into single domain string*/
            /**/
            
            wstring newStr;
            newStr.append(yyvsp[-2]->GetValue());
            newStr.append(yyvsp[-1]->GetValue());
            newStr.append(yyvsp[0]->GetValue());
            AdlToken *newTok = new AdlToken(newStr.c_str(),
                                            yyvsp[-2]->GetStart(),
                                            yyvsp[-2]->GetEnd());
            this->AddToken(newTok);
            yyval = newTok;
        }
break;
case 31:
{
            this->Cur()->UnsetFlags(INHERIT_ONLY_ACE);
        }
break;
case 32:
{
            this->Cur()->SetFlags(CONTAINER_INHERIT_ACE);
        }
break;
case 33:
{
            this->Cur()->SetFlags(OBJECT_INHERIT_ACE);
        }
break;
case 34:
{
            this->Cur()->SetFlags(CONTAINER_INHERIT_ACE);
            this->Cur()->SetFlags(OBJECT_INHERIT_ACE);
        }
break;
case 35:
{
            this->Cur()->SetFlags(NO_PROPAGATE_INHERIT_ACE);
        }
break;
case 42:
{
            /**/
            /* This should never happen*/
            /**/

            throw AdlStatement::ERROR_FATAL_LEXER_ERROR;
        }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = Lexer.NextToken(&yylval)) < 0) yychar = 0;
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\makefile.inc ===
YACC=byacc
GRAMMAR=adl.y
YACCPARAMS=-d -l
SED=sed
SEDCMD=adlyacc.sed
OUTPUTC=adlparser.cpp
OUTPUTH=tokens.h
CC=cl
LINK=link
INCLUDE=d:\nt\public\sdk\inc
CCOPTS=-I$(INCLUDE)

parseronly: parser

test:       parser lexer test testlexer.o
            $(LINK) testlexer.o adllexer.o /link

parser:     adl.y adlyacc.sed
            $(YACC) $(YACCPARAMS) $(GRAMMAR)
            $(SED) -f $(SEDCMD) y_tab.c > $(OUTPUTC)
            rm -f y_tab.c $(OUTPUTH)
            ren y_tab.h $(OUTPUTH)


lexer:      parser adllexer.o 

adllexer.o: adllexer.cpp adllexer.h
            $(CC) adllexer.cpp $(CCOPTS)

testlexer.o: testlexer.cpp
            $(CC) testlexer.cpp $(CCOPTS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\tokens.h ===
#define TK_ERROR 257
#define TK_IDENT 258
#define TK_AT 259
#define TK_SLASH 260
#define TK_PERIOD 261
#define TK_COMMA 262
#define TK_OPENPAREN 263
#define TK_CLOSEPAREN 264
#define TK_SEMICOLON 265
#define TK_EXCEPT 266
#define TK_ON 267
#define TK_ALLOWED 268
#define TK_AND 269
#define TK_AS 270
#define TK_THIS_OBJECT 271
#define TK_CONTAINERS 272
#define TK_OBJECTS 273
#define TK_CONTAINERS_OBJECTS 274
#define TK_NO_PROPAGATE 275
#define TK_LANG_ENGLISH 276
#define TK_LANG_REVERSE 277
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\audit\adtgenp.c ===
/*

*/

#include "pch.h"
#pragma hdrstop

#include "lsaptmp.h"
// #include "adtgen.h"
// #include "adtgenp.h"

#define SE_ADT_NO_AUDIT_PRIVILEGE_CHECK

#include "\nt\ds\security\base\lsa\server\cfiles\adtgenp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\adlstat.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   adlstat.cpp

Abstract:

   Implementation of AdlStatement and AdlTree class methods

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "adl.h"
#include <set>

void AdlStatement::ReadFromDacl(IN const PACL pDacl)
/*++

Routine Description:

    Empties anything in the current ADL statement, and attempts to fill it with
    the ADL representation of the given DACL.
        
Arguments:

    pDacl        -      The DACL from which to construct the statement

Return Value:
    
    none    
    
--*/
{
    //
    // Start with cleanup
    //

    Cleanup();

    try
    {
        ConvertFromDacl(pDacl);
    }
    catch(exception)
    {
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

    _bReady = TRUE;
}


void AdlStatement::ReadFromString(IN const WCHAR *szInput)
/*++

Routine Description:

    Empties anything in the current ADL statement, and attempts to fill it with
    the parsed version of the ADL statement szInput.
    
Arguments:

    szInput      -      Input string in the ADL language describing the 
                        permissions

Return Value:
    
    none    
    
--*/
{
    //
    // Start with cleanup
    //

    Cleanup();

    //
    // Manually create first AdlTree, since the parser only creates
    // new trees AFTER completing an ADL_STATEMENT. At the end, the
    // ParseAdl function itself removes the extra empty tree
    // pushed on
    //

    this->Next();

    try
    {
        ParseAdl(szInput);
    }
    catch(exception)
    {
        Cleanup();
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

    //
    // If no exceptions thrown, the instance is ready for output
    //

    _bReady = TRUE;

}




AdlStatement::~AdlStatement()
/*++

Routine Description:

    Destructor for the AdlStatement
    
    Uses the private Cleanup() function to deallocate
    
Arguments:

    none

Return Value:
    
    none    
    
--*/

{
    this->Cleanup();
}
        


void AdlStatement::Cleanup()
/*++

Routine Description:

    Cleans up any memory used by the parse tree and any allocated tokens
        
Arguments:

    none

Return Value:
    
    none    
    
--*/

{
    _bReady = FALSE;

    this->_tokError = NULL;

    while( !_lTree.empty() )
    {
        delete _lTree.front();
        _lTree.pop_front();
    }

    while( !_AllocatedTokens.empty() )
    {
        delete _AllocatedTokens.top();
        _AllocatedTokens.pop();
    }
}


AdlTree * AdlStatement::Cur()
/*++

Routine Description:

    This protected method returns the current AdlTree being filled in by the
    parser. It is only used by the ParseAdl function when it fills in the
    AdlTree structures
        
Arguments:

    none
    
Return Value:
    
    AdlTree *   -   non-const pointer to the AdlTree    
    
--*/
{
    return *_iter;
}


void AdlStatement::Next()
/*++

Routine Description:

    This protected method constructs a new AdlTree and pushes it on top of the
    list (to make it accessable by this->Cur())
    It is only used by the ParseAdl function after completing an ADL_STATEMENT
    production, and by the AdlStatement constructor (once).
            
Arguments:

    none
    
Return Value:
    
    none
    
--*/
{
    
    AdlTree *pAdlTree = new AdlTree();
    if( pAdlTree == NULL )
    {
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

    try
    {
        _lTree.push_back(pAdlTree);
        _iter = --_lTree.end();
    }
    catch(...)
    {
        delete pAdlTree;
        throw;
    }

}


void AdlStatement::PopEmpty()
/*++

Routine Description:

    This protected method pops the extra empty AdlTree added by the ParseAdl
    function after completing the last ADL_STATEMENT.
            
Arguments:

    none
    
Return Value:
    
    none
    
--*/
{
    delete _lTree.back();
    _lTree.pop_back();
    _iter = -- _lTree.end();
}


void AdlStatement::AddToken(AdlToken *tok)
/*++

Routine Description:

    This protected method is used by AdlStatement and friend classes to keep
    track of tokens which need to be garbage collected later. Tokens need
    to be kept around because they are used in the AdlTrees, and in error
    handling.
            
Arguments:

    tok     -   Pointer to the token to be deleted when ~this is called
    
Return Value:
    
    none
    
--*/
{
    _AllocatedTokens.push(tok);
}


void AdlStatement::WriteToString(OUT wstring *pSz)
/*++

Routine Description:

    This routine prints the AdlStatement structure as a statement in the ADL
    language to stdout. This will be replaced when the ADL semantics are
    finalized.
                
Arguments:

    none
    
Return Value:
    
    none
    
--*/
{

    if( _bReady == FALSE )
    {
        throw AdlStatement::ERROR_NOT_INITIALIZED;
    }

    list<AdlTree *>::iterator iter, iterEnd;
    
    for(iter = _lTree.begin(), iterEnd = _lTree.end();
        iter != iterEnd;
        iter++)
    {
        (*iter)->PrintAdl(pSz, _pControl);
        pSz->append(&(_pControl->pLang->CH_NEWLINE), 1);
    }
}


void AdlStatement::ValidateParserControl()
/*++

Routine Description:

        This validates the ADL_PARSER_CONTROL structure referenced by this
        AdlStatement instance
                                        
Arguments:

    none
    
Return Value:
    
    none
    
--*/
{

    try
    {
        //
        // Test to verify that all characters are unique
        // set.insert returns a pair, with 2nd element being a bool, which
        // is true iff an insertion occured. Set cannot have duplicates.
        //

        set<WCHAR> sChars;
        
        if(
            !sChars.insert(_pControl->pLang->CH_NULL).second ||
            !sChars.insert(_pControl->pLang->CH_SPACE).second ||
            !sChars.insert(_pControl->pLang->CH_TAB).second ||
            !sChars.insert(_pControl->pLang->CH_NEWLINE).second ||
            !sChars.insert(_pControl->pLang->CH_RETURN).second ||
            !sChars.insert(_pControl->pLang->CH_QUOTE).second ||
            !sChars.insert(_pControl->pLang->CH_COMMA).second ||
            !sChars.insert(_pControl->pLang->CH_SEMICOLON).second ||
            !sChars.insert(_pControl->pLang->CH_OPENPAREN).second ||
            !sChars.insert(_pControl->pLang->CH_CLOSEPAREN).second ||
            !sChars.insert(_pControl->pLang->CH_AT).second ||
            !sChars.insert(_pControl->pLang->CH_SLASH).second ||
            !sChars.insert(_pControl->pLang->CH_PERIOD).second 
           )
        {
            throw AdlStatement::ERROR_INVALID_PARSER_CONTROL;
        }


        //
        // Check all strings for null pointers
        //

        if( 
             _pControl->pLang->SZ_TK_AND == NULL ||
             _pControl->pLang->SZ_TK_EXCEPT == NULL ||
             _pControl->pLang->SZ_TK_ON == NULL ||
             _pControl->pLang->SZ_TK_ALLOWED == NULL ||
             _pControl->pLang->SZ_TK_AS == NULL ||
             _pControl->pLang->SZ_TK_THIS_OBJECT == NULL ||
             _pControl->pLang->SZ_TK_CONTAINERS == NULL ||
             _pControl->pLang->SZ_TK_OBJECTS == NULL ||
             _pControl->pLang->SZ_TK_CONTAINERS_OBJECTS == NULL ||
             _pControl->pLang->SZ_TK_NO_PROPAGATE == NULL 
           )
        {
            throw AdlStatement::ERROR_INVALID_PARSER_CONTROL;
        }

    }
    catch(exception)
    {
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

}




/******************************************************************************

        AdlTree Methods

 *****************************************************************************/


//
// An array of these is used to determine the order in which to print
//

#define PRINT_PRINCIPALS 0
#define PRINT_EXPRINCIPALS 1
#define PRINT_ALLOWED 2
#define PRINT_ACCESS 3
#define PRINT_ON 4
#define PRINT_OBJECTS 5

#define PRINT_DEF_SIZE 6

DWORD pdwLangEnglish[6] = 
{
    PRINT_PRINCIPALS,
    PRINT_EXPRINCIPALS,
    PRINT_ALLOWED,
    PRINT_ACCESS,
    PRINT_ON,
    PRINT_OBJECTS
};

DWORD pdwLangReverse[6] = 
{
    PRINT_EXPRINCIPALS,
    PRINT_PRINCIPALS,
    PRINT_ALLOWED,
    PRINT_ACCESS,
    PRINT_ON,
    PRINT_OBJECTS
};

//
// Append a wchar array to the STL string POUTSTLSTRING, add quotes
// if the input string contains any characters in the wchar
// array SPECIALCHARS 
//
#define APPEND_QUOTED_STRING(POUTSTLSTRING, INSTRING, SPECIALCHARS, QUOTECHAR) \
  if( wcspbrk( (INSTRING), (SPECIALCHARS) ) ) { \
      (POUTSTLSTRING)->append(&(QUOTECHAR), 1); \
      (POUTSTLSTRING)->append(INSTRING); \
      (POUTSTLSTRING)->append(&(QUOTECHAR), 1); \
  } else { \
      (POUTSTLSTRING)->append(INSTRING); \
  }
  

void AdlTree::PrintAdl(wstring *pSz, PADL_PARSER_CONTROL pControl)
/*++

Routine Description:

    This routine prints the AdlTree structure using one of the pre-defined
    language specifications, selected by checking the ADL_PARSER_CONTROL 
    structure. To add new languages, simply add a new 6 int array as above,
    and add it into the switch statement below so it will be recognized.
    
Arguments:

    pSz      -   An existing wstring to which the ADL statement output will
                 be appended
    pControl -   Pointer to the ADL_PARSER_CONTROL structure to define the
                 printing
    
Return Value:
    
    none
    
--*/

{


    //
    // Iterators for token lists in the AdlTree
    //

    list<const AdlToken *>::iterator iter;
    list<const AdlToken *>::iterator iter_end;
    list<const AdlToken *>::iterator iter_tmp;

    // 
    // If a string contains these characters, use quotes
    //

    WCHAR szSpecialChars[] = 
    { 
        pControl->pLang->CH_SPACE,
        pControl->pLang->CH_NEWLINE,
        pControl->pLang->CH_TAB,
        pControl->pLang->CH_RETURN,
        pControl->pLang->CH_COMMA,
        pControl->pLang->CH_OPENPAREN,
        pControl->pLang->CH_CLOSEPAREN,
        pControl->pLang->CH_SEMICOLON,
        pControl->pLang->CH_AT,
        pControl->pLang->CH_SLASH,
        pControl->pLang->CH_PERIOD,
        pControl->pLang->CH_QUOTE,
        0
    };

    DWORD dwIdx;
    DWORD dwTmp;

    PDWORD pdwPrintSpec;

    //
    // Determine which type of grammar to use.
    //

    switch( pControl->pLang->dwLanguageType )
    {
    case TK_LANG_ENGLISH:
        pdwPrintSpec = pdwLangEnglish;
        break;
        
    case TK_LANG_REVERSE:
        pdwPrintSpec = pdwLangReverse;
        break;

    default:
        throw AdlStatement::ERROR_INVALID_PARSER_CONTROL;
        break;
    }

    //
    // Using that grammar, print the appropriate parts of each
    // ADL_STATEMENT production
    //
    
    for( dwIdx = 0; dwIdx < PRINT_DEF_SIZE; dwIdx++ )
    {

        switch(pdwPrintSpec[dwIdx])
        {
        
        case PRINT_PRINCIPALS:
            for( iter = _lpTokPrincipals.begin(),
                 iter_end = _lpTokPrincipals.end();
                 iter != iter_end;
                 iter++)
            {
                APPEND_QUOTED_STRING(pSz, 
                                     (*iter)->GetValue(), 
                                     szSpecialChars, 
                                     pControl->pLang->CH_QUOTE);

                //
                // ISSUE-2000/8/31
                // Need to find a way to determine this instead of string comp
                //
                
                if( (*iter)->GetOptValue() != NULL &&
                    _wcsicmp(L"BUILTIN", (*iter)->GetOptValue()))
                {
                    pSz->append(&(pControl->pLang->CH_AT), 1);
                    
                    APPEND_QUOTED_STRING(pSz, 
                                         (*iter)->GetOptValue(), 
                                         szSpecialChars, 
                                         pControl->pLang->CH_QUOTE);
                }

                //
                // Separate with commas except the last one, there use "and"
                //
        
                iter_tmp = iter;
                if( ++iter_tmp == iter_end )
                {
                    //
                    // Do nothing for the last principal
                    //
                }
                else if( ++iter_tmp == iter_end )
                {
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    pSz->append(pControl->pLang->SZ_TK_AND);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
                else
                {
                    pSz->append(&(pControl->pLang->CH_COMMA), 1);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }


            }

            //
            // And a trailing space
            //

            pSz->append(&(pControl->pLang->CH_SPACE), 1);
            
            break;
        
        case PRINT_EXPRINCIPALS:
            
            if( ! _lpTokExPrincipals.empty())
            {
                pSz->append(&(pControl->pLang->CH_OPENPAREN), 1);
                pSz->append(pControl->pLang->SZ_TK_EXCEPT);
                pSz->append(&(pControl->pLang->CH_SPACE), 1);
                
                for( iter = _lpTokExPrincipals.begin(),
                     iter_end = _lpTokExPrincipals.end();
                     iter != iter_end;
                     iter++)
                {
                    APPEND_QUOTED_STRING(pSz, 
                                         (*iter)->GetValue(), 
                                         szSpecialChars, 
                                         pControl->pLang->CH_QUOTE);
    
                    //
                    // ISSUE-2000/8/31
                    // Need to find a way to determine this instead of string comp
                    //
                    
                    if( (*iter)->GetOptValue() != NULL &&
                        _wcsicmp(L"BUILTIN", (*iter)->GetOptValue()))
                    {
                        pSz->append(&(pControl->pLang->CH_AT), 1);
                        
                        APPEND_QUOTED_STRING(pSz, 
                                             (*iter)->GetOptValue(), 
                                             szSpecialChars, 
                                             pControl->pLang->CH_QUOTE);
                    }
    
                    //
                    // Separate with commas except the last one, there use "and"
                    //
            
                    iter_tmp = iter;
                    if( ++iter_tmp == iter_end )
                    {
                        //
                        // Do nothing for the last principal
                        //
                    }
                    else if( ++iter_tmp == iter_end )
                    {
                        pSz->append(&(pControl->pLang->CH_SPACE), 1);
                        pSz->append(pControl->pLang->SZ_TK_AND);
                        pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    }
                    else
                    {
                        pSz->append(&(pControl->pLang->CH_COMMA), 1);
                        pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    }
    
    
                }
    
                
                pSz->append(&(pControl->pLang->CH_CLOSEPAREN), 1);
                pSz->append(&(pControl->pLang->CH_SPACE), 1);
            }

            break;
        
        case PRINT_ALLOWED:
            pSz->append(pControl->pLang->SZ_TK_ALLOWED);
            pSz->append(&(pControl->pLang->CH_SPACE), 1);

            break;
        
        case PRINT_ACCESS:

            for( iter = _lpTokPermissions.begin(),
                 iter_end = _lpTokPermissions.end();
                 iter != iter_end;
                 iter++)
            {
                APPEND_QUOTED_STRING(pSz, 
                                     (*iter)->GetValue(), 
                                     szSpecialChars, 
                                     pControl->pLang->CH_QUOTE);


                //
                // Separate with commas except the last one, there use "and"
                //
        
                iter_tmp = iter;
                if( ++iter_tmp == iter_end )
                {
                    //
                    // Do nothing for the last permission
                    //
                }
                else if( ++iter_tmp == iter_end )
                {
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    pSz->append(pControl->pLang->SZ_TK_AND);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
                else
                {
                    pSz->append(&(pControl->pLang->CH_COMMA), 1);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }


            }

            //
            // And a trailing space
            //
            pSz->append(&(pControl->pLang->CH_SPACE), 1);
            
            break;
        
        case PRINT_ON:

            pSz->append(pControl->pLang->SZ_TK_ON);
            pSz->append(&(pControl->pLang->CH_SPACE), 1);
            
            break;
        
        case PRINT_OBJECTS:
            
            //
            // Make sure all bits are defined
            //

            if( _dwInheritFlags & ~(CONTAINER_INHERIT_ACE |
                                    INHERIT_ONLY_ACE |
                                    NO_PROPAGATE_INHERIT_ACE |
                                    OBJECT_INHERIT_ACE) )
            {
                throw AdlStatement::ERROR_INVALID_OBJECT;
            }

            //
            // Count the number of object statements, for proper punctuation
            //

            dwTmp = 0;
            
            if( ! ( _dwInheritFlags & INHERIT_ONLY_ACE) )
            {
                dwTmp++;
            }

            if(_dwInheritFlags & ( CONTAINER_INHERIT_ACE || OBJECT_INHERIT_ACE))
            {
                dwTmp++;
            }

            if(_dwInheritFlags & NO_PROPAGATE_INHERIT_ACE)
            {
                dwTmp++;
            }


            //
            // First "this object"
            //

            if( ! ( _dwInheritFlags & INHERIT_ONLY_ACE) )
            {
                APPEND_QUOTED_STRING(pSz, 
                                     pControl->pLang->SZ_TK_THIS_OBJECT,
                                     szSpecialChars, 
                                     pControl->pLang->CH_QUOTE);

                //
                // Print "and" if 1 more left, "," if two
                //
                
                dwTmp--;

                if( dwTmp == 2 )
                {
                    pSz->append(&(pControl->pLang->CH_COMMA), 1);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
                else if( dwTmp == 1)
                {
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    pSz->append(pControl->pLang->SZ_TK_AND);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
            }



            //
            // Then container/object inheritance
            //

            if( _dwInheritFlags & ( CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE))
            {
                if(    (_dwInheritFlags & OBJECT_INHERIT_ACE) 
                    && (_dwInheritFlags & CONTAINER_INHERIT_ACE) )
                {
                    APPEND_QUOTED_STRING(pSz, 
                                      pControl->pLang->SZ_TK_CONTAINERS_OBJECTS,
                                      szSpecialChars, 
                                      pControl->pLang->CH_QUOTE);
                }
                else if( _dwInheritFlags & CONTAINER_INHERIT_ACE )
                {
                    APPEND_QUOTED_STRING(pSz, 
                                      pControl->pLang->SZ_TK_CONTAINERS,
                                      szSpecialChars, 
                                      pControl->pLang->CH_QUOTE);
                }
                else
                {
                    APPEND_QUOTED_STRING(pSz, 
                                      pControl->pLang->SZ_TK_OBJECTS,
                                      szSpecialChars, 
                                      pControl->pLang->CH_QUOTE);
                }
                
                dwTmp--;

                //
                // Print "and" if 1 more left
                // nothing if 0
                //

                if( dwTmp == 1)
                {
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    pSz->append(pControl->pLang->SZ_TK_AND);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
            }


            //
            // Now no-propagate
            //

            if(_dwInheritFlags & NO_PROPAGATE_INHERIT_ACE)
            {
                APPEND_QUOTED_STRING(pSz, 
                                  pControl->pLang->SZ_TK_NO_PROPAGATE,
                                  szSpecialChars, 
                                  pControl->pLang->CH_QUOTE);
            }
            

            break;

        default:

            //
            // Should not get here unless language defs are wrong
            //

            throw AdlStatement::ERROR_FATAL_PARSER_ERROR;
            break;
        }

    }


    //
    // And terminate the statement with a semicolon, invariable per grammar
    //

    pSz->append(&(pControl->pLang->CH_SEMICOLON), 1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <authz.h>
#include <sddl.h>
#include <assert.h>
#include <winnls.h>

#define SECURITY_WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\adl\test.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   test.cpp

Abstract:

   Utility which allows to dump a file DACL in ADL or set a file DACL from ADL

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "adl.h"


//
// Various file rights
// More general rights have priority
//

ADL_MASK_STRING MaskStringMap[] = 
{
    { (FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE | WRITE_DAC
      | WRITE_OWNER | READ_CONTROL | DELETE)  & ~SYNCHRONIZE , L"full control" },
    { FILE_GENERIC_READ & ~SYNCHRONIZE, L"read" },
    { FILE_GENERIC_WRITE & ~SYNCHRONIZE, L"write" },
    { FILE_GENERIC_EXECUTE & ~SYNCHRONIZE, L"execute" },
    { DELETE & ~SYNCHRONIZE, L"delete" },
    { READ_CONTROL, L"read control"},
    { WRITE_DAC, L"write dac"},
    { WRITE_OWNER, L"write owner" },
    { SYNCHRONIZE, L"synchronize" },
    { FILE_READ_DATA, L"read data" },
    { FILE_WRITE_DATA, L"write data" },
    { FILE_APPEND_DATA, L"append data" },
    { FILE_READ_EA, L"read extended attributes" },
    { FILE_WRITE_EA, L"write extended attributes" },
    { FILE_EXECUTE, L"file execute" },
    { FILE_READ_ATTRIBUTES, L"read attributes" },
    { FILE_WRITE_ATTRIBUTES, L"write attributes" },
    { 0, NULL }
};


//
// Representation of the English version of ADL
//

ADL_LANGUAGE_SPEC lEnglish = 
{
    TK_LANG_ENGLISH,
    0,
    L' ',
    L'\t',
    L'\n',
    L'\r',
    L'"',
    L',',
    L';',
    L'(',
    L')',
    L'@',
    L'\\',
    L'.',
    0,
    L"and",
    L"except",
    L"on",
    L"allowed",
    L"as",
    L"this file",
    L"subfolders",
    L"files",
    L"subfolders and files",
    L"noprop"
};

ADL_PARSER_CONTROL EnglishFileParser = 
{
    &lEnglish,
    MaskStringMap,
    ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED,
    SYNCHRONIZE   
};



//
// Error handler
//

void HandleError(AdlStatement::ADL_ERROR_TYPE adlErr, const AdlToken *pTok)
{
    switch(adlErr)
    {
    
    //
    // Errors that should not happen unless there is a problem with the 
    // system or the user makes a mistake
    //

    case AdlStatement::ERROR_FATAL_LEXER_ERROR:
    case AdlStatement::ERROR_FATAL_PARSER_ERROR:
    case AdlStatement::ERROR_FATAL_ACL_CONVERT_ERROR:
    case AdlStatement::ERROR_OUT_OF_MEMORY:
    case AdlStatement::ERROR_ACL_API_FAILED:
    case AdlStatement::ERROR_NOT_INITIALIZED:
        wprintf(L"\n\nFatal internal error, Errorcode %u, THIS IS BAD\n\n", adlErr);
        break;

    case AdlStatement::ERROR_LSA_FAILED:
        wprintf(L"\n\nError: LSA failed. Unable to resolve user information\n\n");
        break;


    //
    // Input-related grammar errors: no token supplied
    //

    case AdlStatement::ERROR_UNTERMINATED_STRING:
        wprintf(L"\n\nError: unmatched quote in the input\n\n");
        break;

    case AdlStatement::ERROR_UNKNOWN_ACE_TYPE:
        wprintf(L"\n\nError: Unknown ACE type encountered\n\n");
        break;

    case AdlStatement::ERROR_IMPERSONATION_UNSUPPORTED:
        wprintf(L"\n\nError: Impersonation is currently not supported in ADL\n\n");
        break;

    case AdlStatement::ERROR_INVALID_PARSER_CONTROL:
        wprintf(L"\n\nError: The specified laanguage type is not supported\n\n");
        break;

    //
    // For this error, the last read token is supplied
    //
        
    case AdlStatement::ERROR_NOT_IN_LANGUAGE:
        wprintf(L"\n\nError, invalid ADL statement, did not expect '%s',\n\
                which was found between characters %u and %u\n\n", pTok->GetValue(),
                pTok->GetStart(), pTok->GetEnd());
        break;
        

    //
    // Input-related semantic errors
    //

    //
    // For these errors, the offending token is supplied
    //

    case AdlStatement::ERROR_UNKNOWN_USER:
        
        wprintf(L"\n\nError, unknown user: ");
        if( pTok->GetOptValue() != NULL )
        {
            wprintf(L"'%s%c%s' ", pTok->GetValue(), lEnglish.CH_AT, pTok->GetOptValue());
        }
        else
        {
            wprintf(L"'%s' ", pTok->GetValue());
        }
        wprintf(L"found between characters %u and %u\n\n", pTok->GetStart(), pTok->GetEnd());
        break;


    case AdlStatement::ERROR_UNKNOWN_PERMISSION:
        wprintf(L"\n\nError, unknown permission: '%s' \
                found between characters %u and %u\n\n", 
                pTok->GetValue(), pTok->GetStart(), pTok->GetEnd());
        break;

    case AdlStatement::ERROR_INVALID_USERNAME:
        wprintf(L"\n\nError, invalid username string: '%s' \
                found between characters %u and %u\n\n", 
                pTok->GetValue(), pTok->GetStart(), pTok->GetEnd());
        break;

    case AdlStatement::ERROR_INVALID_DOMAIN:
        wprintf(L"\n\nError, invalid domain name string: '%s' \
                found between characters %u and %u\n\n", 
                pTok->GetValue(), pTok->GetStart(), pTok->GetEnd());
        break;

    case AdlStatement::ERROR_INVALID_OBJECT:
        wprintf(L"\n\nError, invalid object specifier: '%s' \
                found between characters %u and %u\n\n", 
                pTok->GetValue(), pTok->GetStart(), pTok->GetEnd());
        break;

    //
    // Other errors with no token supplied
    //
        
    case AdlStatement::ERROR_UNKNOWN_SID:
        wprintf(L"\n\nError: SID encountered which could not be resolved to a name\n\n");
        break;

    case AdlStatement::ERROR_UNKNOWN_ACCESS_MASK:
        wprintf(L"\n\nError: Access mask contains unknown bit\n\n");
        break;

    case AdlStatement::ERROR_INEXPRESSIBLE_ACL:
        wprintf(L"\n\nError: This DACL cannot be expressed in ADL\n\n");
        break;

    default:
        wprintf(L"\n\nUNKNOWN Error code: %u, THIS IS VERY BAD\n\n", adlErr);
        break;
    }

}

//
// -dump Filename
//

void DumpDaclToAdl(int argc, WCHAR *argv[]) {

    DWORD dwErr;

    if(argc != 3) 
    {
        wprintf(L"\nUsage:\n\n%s -dump <target>\n\n", argv[0]);
        exit(1);
    }

    PSECURITY_DESCRIPTOR pSD;
    SECURITY_INFORMATION SecInfo = DACL_SECURITY_INFORMATION;

    DWORD dwLengthNeeded;
    GetFileSecurity(
        argv[2],
        SecInfo,
        NULL,
        0,
        &dwLengthNeeded);

    pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwLengthNeeded];

    dwErr = GetFileSecurity(
        argv[2],
        SecInfo,
        pSD,
        dwLengthNeeded,
        &dwLengthNeeded);

    if( dwErr == 0)
    {
        dwErr = GetLastError();
        wprintf(L"GetFileSecurity failed on file '%s' with error %u, 0x%x\n",
                argv[2], dwErr, dwErr);
        exit(5);
    }

    PACL pDacl;

    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pDacl, &fDaclDefaulted);

    if( !fDaclPresent || pDacl == NULL )
    {
        wprintf(L"Security descriptor of '%s' does not contain a DACL",argv[2]);
        exit(6);
    }

    AdlStatement *stat;

    try
    {
        stat = new AdlStatement(&EnglishFileParser);
        wstring ws;
        stat->ReadFromDacl(pDacl);
        stat->WriteToString(&ws);
        wprintf(L"%s", ws.c_str());
    }
    catch(AdlStatement::ADL_ERROR_TYPE adlErr)
    {
        HandleError(adlErr, stat->GetErrorToken());
    }

    if( stat != NULL )
    {
        delete stat;
    }

    delete[] (PBYTE)pSD;
}


//
// -set adlfile target
//

void WriteDaclFromAdl(int argc, WCHAR *argv[]) {

    WCHAR buf[16384];
    char buf3[16384];
    DWORD i;
    DWORD dwErr;

    if(argc != 4) 
    {
        wprintf(L"\nUsage:\n\n%s -set <adl rules file> <target>\n\n", argv[0]);
        exit(1);
    }

    FILE *in = _wfopen(argv[2], L"rb");
    if(in == NULL) 
    {
        wprintf(L"Error: cannot open input ADL file '%s', exiting\n", argv[2]);
        exit(2);
    }

    // skip top byte
    if( fgetwc(in) != 0xFEFF)
    {
        fseek(in, 0, SEEK_SET);
        for(i = 0; (buf3[i] = (char)fgetc(in)) != EOF && i < 16384; i++);
        buf3[i] = 0;
        MultiByteToWideChar(CP_ACP, 0, buf3, i+1, buf, 16384);
    }
    else
    {
        for(i = 0; (buf[i] = fgetwc(in)) != WEOF && i < 16384; i++);
        buf[i] = 0;
    }

    AdlStatement * stat;

    try 
    {
        stat = new AdlStatement( &EnglishFileParser);
        wstring ws;
        stat->ReadFromString(buf);
        stat->WriteToString(&ws);
        wprintf(L"Setting permissions to:\n-------------\n%s\n-------------\n",
                ws.c_str());

    }
    catch(AdlStatement::ADL_ERROR_TYPE adlErr)
    {
        HandleError(adlErr, stat->GetErrorToken());
        if( stat != NULL )
        {
            delete stat;
        }
        exit(6);
    }
    
    //
    // Initialize the security descriptor
    //
    
    SECURITY_DESCRIPTOR SD;
    
    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorGroup(&SD, NULL, FALSE);
    SetSecurityDescriptorOwner(&SD, NULL, FALSE);
    SetSecurityDescriptorSacl(&SD, FALSE, NULL, FALSE);

    PACL pDacl = NULL;
    
    try 
    {
        stat->WriteToDacl(&pDacl);
    }
    catch(AdlStatement::ADL_ERROR_TYPE adlErr)
    {
        HandleError(adlErr, stat->GetErrorToken());
        delete stat;
        exit(7);
    }

    SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE);
    
    //
    // Set the file security
    //
        
    SECURITY_INFORMATION SecInfo = DACL_SECURITY_INFORMATION;
    dwErr = SetFileSecurity(argv[3], SecInfo, &SD);
    if(dwErr == 0)
    {
        dwErr = GetLastError();
        wprintf(L"SetFileSecurity on %s failed with %d, 0x%x\n",
                argv[3],
                dwErr,
                dwErr);
    }
    else
    {
        wprintf(L"Success, permissions set.\n");
    }

    AdlStatement::FreeMemory(pDacl);

    delete stat;
}


void __cdecl wmain(int argc, WCHAR *argv[])
{

    if(argc < 2)
    {
        wprintf(L"\nUsage:\n\n%s -set <adl rules file> <target>\n"
               L"%s -dump <target>\n\n", argv[0], argv[0]);
    }
    else
    {
        if(!_wcsicmp(argv[1], L"-dump"))
        {
            DumpDaclToAdl(argc, argv);
        } 
        else if(!_wcsicmp(argv[1], L"-set"))
        {
            WriteDaclFromAdl(argc, argv);
        } 
        else
        {
            wprintf(L"\nUsage:\n\n%s -set <adl rules file> <target>\n"
                L"%s -dump <target>\n\n", argv[0], argv[0]);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\audit\adttest.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T U T I L . C
//
// Contents:    Functions to test generic audit support in LSA
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "authz.h"
#include "authzi.h"
#include "adtgen.h"

//
// defining USE_LOCAL_AUDIT causes audits to be processed in proc
// instead of being sent to lsa. This allows much faster debug
// cycle since LSA is not involved. The audit marshal/process code
// is taken directly from LSA. Thus the same code path is exercised
// as that when this is not defined.
//

//#define USE_LOCAL_AUDIT


#ifdef USE_LOCAL_AUDIT

#include "\nt\ds\security\base\lsa\server\cfiles\adtgenp.h"

#endif 


// ----------------------------------------------------------------------
//
// forward declarations
//
DWORD 
EnableSinglePrivilege(
    IN PWCHAR szPrivName
    );

// ----------------------------------------------------------------------

EXTERN_C
DWORD
TestEventGen( ULONG NumIter )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwError=NO_ERROR;
    HANDLE hAudit = NULL;
    AUDIT_PARAMS AuditParams;
    AUDIT_PARAM ParamArray[SE_MAX_AUDIT_PARAMETERS];
    PSID pUserSid = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_LEGACY AuditEventInfoLegacy = { 0 };
    //AUDIT_EVENT_INFO AuditEventInfo = { 0 };
    AUTHZ_AUDIT_EVENT_TYPE_OLD AuditEventType;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hEventType = NULL;
    BOOL fDone=FALSE;
    PWSTR szMsg = NULL;
    BOOL fResult;

    AUDIT_OBJECT_TYPE Objects[3] =
    {
        {
            { /* f3548725-0458-11d4-bd96-006008269001 */
                0xf3548725,
                0x0458,
                0x11d4,
                {0xbd, 0x96, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01}
            },
            0, 0, STANDARD_RIGHTS_ALL
        },
        {
            { /* f3548726-0458-11d4-bd96-006008269001 */
                0xf3548726,
                0x0458,
                0x11d4,
                {0xbd, 0x96, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01}
            },
            0, 1, STANDARD_RIGHTS_ALL
        },
        {
            { /* f3548727-0458-11d4-bd96-006008269001 */
                0xf3548727,
                0x0458,
                0x11d4,
                {0xbd, 0x96, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01}
            },
            0, 2, STANDARD_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY
        },
    };

    AUDIT_OBJECT_TYPES ObjectTypes =
    {
        3, 0, Objects
    };
    
    AuditParams.Parameters = ParamArray;

    wprintf(L"[%03d] begin...\n", GetCurrentThreadId());

//      AuditEventInfo.Version                  = AUDIT_TYPE_LEGACY;
//      //AuditEventInfo.u.Legacy                 = &AuditEventInfoLegacy;
//      AuditEventInfo.u.Legacy.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
//      AuditEventInfo.u.Legacy.AuditId        = SE_AUDITID_OBJECT_OPERATION;
//      AuditEventInfo.u.Legacy.ParameterCount = 11;

    fResult = AuthziInitializeAuditEventType(
                  0,
                  SE_CATEGID_OBJECT_ACCESS,
                  SE_AUDITID_OBJECT_OPERATION,
                  11,
                  &hEventType
                  );
    if ( !fResult )
    {
        szMsg = L"AuthziInitializeAuditEventType";
        goto Cleanup;
    }
    
#ifdef USE_LOCAL_AUDIT
    Status = LsapRegisterAuditEvent( &AuditEventInfo, &hAudit );

    if (!NT_SUCCESS(Status))
    {
        szMsg = L"LsapRegisterAuditEvent";
        goto Cleanup;
    }
#else    
//      fResult = AuthzpRegisterAuditEvent( &AuditEventInfo, &hAudit );

//      if (!fResult)
//      {
//          szMsg = L"AuthzRegisterAuditEvent";
//          goto Cleanup;
//      }
#endif

    //
    // initialize the AuditParams structure
    //

//      fResult = AuthziInitializeAuditParams(
//                    //
//                    // flags
//                    //

//                    0,
                  
//                    &AuditParams,

//                    //
//                    // sid of the user generating this audit
//                    //

//                    &pUserSid,

//                    //
//                    // resource manager name
//                    //

//                    L"mysubsystem",

//                    //
//                    // generate a success audit
//                    //

//                    APF_AuditSuccess,

//                    //
//                    // there are 9 params to follow
//                    //
//                    9,

//                    //
//                    // operation type
//                    //

//                    APT_String,     L"test",

//                    //
//                    // object type
//                    //

//                    APT_String,     L"File",

//                    //
//                    // object name
//                    //

//                    APT_String,     L"foo-obj",

//                    //
//                    // handle id
//                    //

//                    APT_Pointer,    0x123,

//                    //
//                    // primary user info
//                    //

//                    APT_LogonId | AP_PrimaryLogonId,

//                    //
//                    // client user info
//                    //

//                    APT_LogonId | AP_ClientLogonId,

//                    //
//                    // requested accesses
//                    // 1 refers to 0 based index of the
//                    // parameter (object-type) that is
//                    // passed to this function.
//                    //

//                    APT_Ulong   | AP_AccessMask,
//                    STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL, 1,

//                    //
//                    // object properties
//                    // 1 refers to 0 based index of the
//                    // parameter (object-type) that is
//                    // passed to this function.
//                    //

//                    APT_ObjectTypeList, &ObjectTypes, 1,

//                    //
//                    // additional info
//                    //

//                    APT_String, L"this is not a real obj-opn"
//                    );
//      if (!fResult)
//      {
//  #ifdef USE_LOCAL_AUDIT
//          Status = STATUS_UNSUCCESSFUL;
//          wprintf(L"[%03d] AuthzInitAuditParams: %x\n",
//                  GetCurrentThreadId(), GetLastError());
//  #endif        
//          szMsg = L"AuthzInitAuditParams";
//          goto Cleanup;
//      }

    for (ULONG i=0; i<NumIter; i++)
    {
        Sleep( 10 );

#ifdef USE_LOCAL_AUDIT
        Status = LsapGenAuditEvent( hAudit, 0, &AuditParams, 0 );

        if (!NT_SUCCESS(Status))
        {
            szMsg = L"LsapGenAuditEvent";
            goto Cleanup;
        }
#else        
//          fResult = AuthzGenAuditEvent( hAudit, 0, &AuditParams, 0 );

//          if (!fResult)
//          {
//              szMsg = L"AuthzGenAuditEvent";
//              goto Cleanup;
//          }
#endif
    }
    

Cleanup:
#ifdef USE_LOCAL_AUDIT
    if (!NT_SUCCESS(Status))
    {
        dwError = Status;
    }
#else    
    if (!fResult)
    {
        dwError = GetLastError();
    }
#endif

    wprintf(L"[%03d] end: %s %x\n",
            GetCurrentThreadId(), szMsg ? szMsg : L"", dwError);
    LocalFree( pUserSid );

    if ( hAudit )
    {
#ifdef USE_LOCAL_AUDIT
        Status = LsapUnregisterAuditEvent( &hAudit );

        if (!NT_SUCCESS(Status))
        {
            wprintf (L"LsapUnregisterAuditEvent: %x\n", Status);
        }
#else
        fResult = AuthziFreeAuditEventType( hEventType );

        if (!fResult)
        {
            dwError = GetLastError();

            wprintf (L"AuthziFreeAuditEventType: %x\n", dwError);
        }
#endif
    }

    return dwError;
}

DWORD WINAPI TestEventGenThreadProc( PVOID p )
{
    TestEventGen( (ULONG) (ULONG_PTR) p );

    return 0;
}


DWORD WaitForTonsOfObjects(
    IN  DWORD   dwNumThreads,
    IN  HANDLE* phThreads,
    IN  BOOL    fWaitAll,
    IN  DWORD   dwMilliseconds
    )
{
    LONG dwNumBundles=dwNumThreads / MAXIMUM_WAIT_OBJECTS;
    DWORD dwRem = dwNumThreads % MAXIMUM_WAIT_OBJECTS;
    DWORD dwError = NO_ERROR;
    
    for (LONG i=0; i<dwNumBundles-1; i++)
    {
        dwError = WaitForMultipleObjects( MAXIMUM_WAIT_OBJECTS,
                                          &phThreads[i*MAXIMUM_WAIT_OBJECTS],
                                          fWaitAll,
                                          dwMilliseconds );
        if ( dwError == WAIT_FAILED )
        {
            goto Cleanup;
        }
    }

    dwError = WaitForMultipleObjects( dwRem,
                                      &phThreads[i*MAXIMUM_WAIT_OBJECTS],
                                      fWaitAll,
                                      dwMilliseconds );
    
Cleanup:
    return dwError;
}

EXTERN_C
NTSTATUS
TestEventGenMulti(
    IN  USHORT NumThreads,
    IN  ULONG  NumIter
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE* phThreads = NULL;
    DWORD* pdwThreadIds = NULL;
    PWSTR szMsg = NULL;
    DWORD dwError;

#ifdef USE_LOCAL_AUDIT
    Status = LsapAdtInitGenericAudits();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
#endif
    
    dwError = EnableSinglePrivilege( SE_AUDIT_NAME );

    if ( dwError != NO_ERROR )
    {
        szMsg = L"EnableSinglePrivilege: SeAuditPrivilege";
        Status = dwError;
        goto Cleanup;
    }
    
    phThreads = (HANDLE*) LocalAlloc( LMEM_ZEROINIT,
                                      sizeof(HANDLE) * NumThreads );
    if ( !phThreads )
    {
        Status = STATUS_NO_MEMORY;
        szMsg = L"LsapAllocateLsaHeap";
        goto Cleanup;
    }

    wprintf(L"Creating %d threads...\n", NumThreads);
    
    for (int i=0; i<NumThreads; i++)
    {
        phThreads[i] = CreateThread( NULL, 0,
                                     TestEventGenThreadProc, (PVOID) NumIter,
                                     CREATE_SUSPENDED, NULL );
        if (!phThreads[i])
        {
            szMsg = L"CreateThread";
            goto Cleanup;
        }
    }
    wprintf(L"...done\n");

    wprintf(L"Waiting for the threads to finish work...\n");

    for (int i=0; i<NumThreads; i++)
    {
        ResumeThread( phThreads[i] );
    }

    dwError = WaitForTonsOfObjects( NumThreads, phThreads, TRUE, INFINITE );
    if ( dwError == WAIT_FAILED )
    {
        szMsg = L"WaitForMultipleObjects";
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    
    for (int i=0; i<NumThreads; i++)
    {
        CloseHandle( phThreads[i] );
    }
    RtlZeroMemory( phThreads, sizeof(HANDLE) * NumThreads );
    
Cleanup:
    if ( szMsg )
    {
        wprintf (L"%s: %x\n", szMsg, Status);
    }

    for (i=0; i<NumThreads; i++)
    {
        if (phThreads[i])
        {
            TerminateThread( phThreads[i], 0 );
        }
    }

    LocalFree( phThreads );
    //LocalFree( pdwThreadIds );

    return Status;
}

EXTERN_C
NTSTATUS
GetSidName(
    IN  PSID   pSid,
    OUT PWSTR szName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_OBJECT_ATTRIBUTES ObjectAttrs = { 0 };
    PLSA_REFERENCED_DOMAIN_LIST pDomains;
    PLSA_TRANSLATED_NAME pNames;
    LSA_HANDLE hLsa;

    *szName = UNICODE_NULL;
    
    Status = LsaOpenPolicy( NULL, &ObjectAttrs, POLICY_LOOKUP_NAMES, &hLsa );
    if (NT_SUCCESS(Status))
    {
        Status = LsaLookupSids( hLsa, 1, &pSid, &pDomains, &pNames );
        if (NT_SUCCESS(Status))
        {
            if (pDomains->Entries > 0)
            {
                lstrcpyn( szName, pDomains->Domains[0].Name.Buffer,
                          pDomains->Domains[0].Name.Length / sizeof(WCHAR) + 1);
                lstrcat( szName, L"\\" );
                if ( pNames[0].Use == SidTypeUser )
                {
                    lstrcat( szName, pNames[0].Name.Buffer );
                }
                else
                {
                    lstrcat( szName, L"unknown" );
                }
            }
        }
    }
    
    return Status;
}

DWORD 
EnableSinglePrivilege(
    IN PWCHAR szPrivName
    )
{
    DWORD dwError=NO_ERROR;
    HANDLE hToken;
    LUID   luidPriv;
    TOKEN_PRIVILEGES Privileges;
    //LUID_AND_ATTRIBUTES lna[1];

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES,
                          &hToken))
    {
        goto GetError;
    }

    
    if (!LookupPrivilegeValue(NULL, szPrivName, &Privileges.Privileges[0].Luid))
    {
        goto GetError;
    }

    Privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    Privileges.PrivilegeCount = 1;


    if (!AdjustTokenPrivileges(hToken, FALSE, &Privileges, 0, NULL, 0 ))
    {
        goto GetError;
    }

    CloseHandle(hToken);
    

Cleanup:

    return dwError;
    
GetError:
    dwError = GetLastError();
    goto Cleanup;
}


EXTERN_C
NTSTATUS
kElfReportEventW (
    IN      HANDLE          LogHandle,
    IN      USHORT          EventType,
    IN      USHORT          EventCategory OPTIONAL,
    IN      ULONG           EventID,
    IN      PSID            UserSid,
    IN      USHORT          NumStrings,
    IN      ULONG           DataSize,
    IN      PUNICODE_STRING *Strings,
    IN      PVOID           Data,
    IN      USHORT          Flags,
    IN OUT  PULONG          RecordNumber OPTIONAL,
    IN OUT  PULONG          TimeWritten  OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCWSTR szT;
    WCHAR szUserName[256];
    
    ASSERT((EventType == EVENTLOG_AUDIT_SUCCESS) ||
           (EventType == EVENTLOG_AUDIT_FAILURE));
    
    return Status;
    
    wprintf(L"-----------------------------------------------------------------\n");
    
    if (EventType == EVENTLOG_AUDIT_SUCCESS)
    {
        szT = L"AUDIT_SUCCESS";
    }
    else
    {
        szT = L"AUDIT_FAILURE";
    }

    wprintf(L"Type\t: %s\n", szT);

    wprintf(L"Category: %d\n", EventCategory);
    wprintf(L"AuditId\t: %d\n", EventID);

    if (STATUS_SUCCESS == GetSidName( UserSid, szUserName ))
    {
        wprintf(L"UserSid\t: %s\n\n", szUserName);
    }
    else
    {
        wprintf(L"UserSid\t: <NA>\n\n");
    }

    wprintf(L"#strings: %d\n", NumStrings);

    for (int i=0; i<NumStrings; i++)
    {
        wprintf(L"[%02d]\t: %wZ\n", i, Strings[i]);
    }

    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\audit\lsapch2.h ===
// empty file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\audit\main.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        M A I N . C P P
//
// Contents:    The main fn
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "adttest.h"

extern "C" int __cdecl wmain(int argc, PWSTR argv[])
{
    ULONG NumThreads = 1;
    ULONG  NumIter = 10;
    
    if ( argc == 2 )
    {
        swscanf(argv[1], L"%d", &NumThreads);
    }

    if ( argc == 3 )
    {
        swscanf(argv[1], L"%d", &NumThreads);
        swscanf(argv[2], L"%d", &NumIter);
    }

    printf("TestEventGenMulti: #threads: %d\t#iterations: %d...\n",
           NumThreads, NumIter);
    //getchar();
    
    TestEventGenMulti( (USHORT) NumThreads, NumIter );
    printf("TestEventGenMulti: done\n");
    
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\audit\adtp.h ===
// empty file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\audit\adttest.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T U T I L . C
//
// Contents:    Functions to test generic audit support in LSA
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#pragma once

EXTERN_C
NTSTATUS
TestEventGenMulti(
    IN  USHORT NumThreads,
    IN  ULONG  NumIter
    );

EXTERN_C
NTSTATUS
kElfReportEventW (
    IN      HANDLE          LogHandle,
    IN      USHORT          EventType,
    IN      USHORT          EventCategory OPTIONAL,
    IN      ULONG           EventID,
    IN      PSID            UserSid,
    IN      USHORT          NumStrings,
    IN      ULONG           DataSize,
    IN      PUNICODE_STRING *Strings,
    IN      PVOID           Data,
    IN      USHORT          Flags,
    IN OUT  PULONG          RecordNumber OPTIONAL,
    IN OUT  PULONG          TimeWritten  OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\audit\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include "windows.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\audit\lsaptmp.h ===
#pragma once

#define FLAG_ON(flags,bit)        ((flags) & (bit))

#define SE_MAX_AUDIT_PARAM_STRINGS 32

extern LUID AuditPrivilege;

NTSTATUS
LsapRtlConvertSidToString(
    IN     PSID   Sid,
    OUT    PWSTR  szString,
    IN OUT DWORD *pdwRequiredSize
    );

PVOID NTAPI
LsapAllocateLsaHeap(
    IN ULONG cbMemory
    );

void NTAPI
LsapFreeLsaHeap(
    IN PVOID pvMemory
    );


NTSTATUS
LsapAdtDemarshallAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    );

NTSTATUS
LsapAdtBuildDashString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildHexUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildPtrString(
    IN  PVOID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );


NTSTATUS
LsapAdtBuildSidString(
    IN PSID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildObjectTypeStrings(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN PSE_ADT_OBJECT_TYPE ObjectTypeList,
    IN ULONG ObjectTypeCount,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    OUT PUNICODE_STRING NewObjectTypeName
    );

NTSTATUS
LsapAdtBuildAccessesString(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK Accesses,
    IN BOOLEAN Indent,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildFilePathString(
    IN PUNICODE_STRING Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildLogonIdStrings(
    IN PLUID LogonId,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    );

NTSTATUS
LsapBuildPrivilegeAuditString(
    IN PPRIVILEGE_SET PrivilegeSet,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

VOID
LsapAdtSubstituteDriveLetter(
    IN PUNICODE_STRING FileName
    );

#define DsysAssertMsg(exp, msg) ASSERT(exp)

EXTERN_C
NTSTATUS
LsapApiReturnResult(
    ULONG ExceptionCode
    );

NTSTATUS
LsapAdtWriteLog(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters OPTIONAL,
    IN ULONG Options
    );

BOOLEAN
LsapAdtIsAuditingEnabledForCategory(
    IN POLICY_AUDIT_EVENT_TYPE AuditCategory,
    IN UINT AuditEventType
    );

VOID
LsapAuditFailed(
    IN NTSTATUS AuditStatus
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\audit\lsaptmp.c ===
#include "pch.h"
#pragma hdrstop


#if !defined(lint)

#include "lsaptmp.h"
#include "adttest.h"

LUID AuditPrivilege = { SE_AUDIT_PRIVILEGE, 0 };

NTSTATUS
LsapGetLogonSessionAccountInfo(
    IN PLUID Value,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    );


NTSTATUS
LsapRtlConvertSidToString(
    IN     PSID   Sid,
    OUT    PWSTR  szString,
    IN OUT DWORD *pdwRequiredSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PWSTR   szBufPtr = szString;
    ULONG   ulNumChars;
    UCHAR   i;
    ULONG   Tmp;
    PISID   iSid = (PISID)Sid;

    if ( *pdwRequiredSize < 256 )
    {
        Status = STATUS_BUFFER_OVERFLOW;
        *pdwRequiredSize = 256;
        goto Cleanup;
    }

    ulNumChars = wsprintf(szBufPtr, L"S-%u-", (USHORT)iSid->Revision );
    szBufPtr += ulNumChars;
    
    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     )
    {
        ulNumChars = wsprintf(szBufPtr, L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                              (USHORT)iSid->IdentifierAuthority.Value[0],
                              (USHORT)iSid->IdentifierAuthority.Value[1],
                              (USHORT)iSid->IdentifierAuthority.Value[2],
                              (USHORT)iSid->IdentifierAuthority.Value[3],
                              (USHORT)iSid->IdentifierAuthority.Value[4],
                              (USHORT)iSid->IdentifierAuthority.Value[5] );
    }
    else
    {
        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        ulNumChars = wsprintf(szBufPtr, L"%lu", Tmp);
    }
    szBufPtr += ulNumChars;

    for (i=0;i<iSid->SubAuthorityCount ;i++ )
    {
        ulNumChars = wsprintf(szBufPtr, L"-%lu", iSid->SubAuthority[i]);
        szBufPtr += ulNumChars;
    }

Cleanup:

    return(Status);
}

PVOID NTAPI
LsapAllocateLsaHeap(
    IN ULONG cbMemory
    )
{
    return(RtlAllocateHeap(
                RtlProcessHeap(),
                HEAP_ZERO_MEMORY,
                cbMemory
                ));
}

void NTAPI
LsapFreeLsaHeap(
    IN PVOID pvMemory
    )
{

    RtlFreeHeap(RtlProcessHeap(), 0, pvMemory);

}


NTSTATUS
LsapAdtDemarshallAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    )

/*++

Routine Description:

    This routine will walk down a marshalled audit parameter
    array and unpack it so that its information may be passed
    into the event logging service.

    Three parallel data structures are maintained:

    StringArray - Array of Unicode string structures.  This array
    is used primarily as temporary storage for returned string
    structures.

    StringPointerArray - Array of pointers to Unicode string structures.

    FreeWhenDone - Array of booleans describing how to dispose of each
    of the strings pointed to by the StringPointerArray.


    Note that entries in the StringPointerArray are contiguous, but that
    there may be gaps in the StringArray structure.  For each entry in the
    StringPointerArray there will be a corresponding entry in the FreeWhenDone
    array.  If the entry for a particular string is TRUE, the storage for
    the string buffer will be released to the process heap.



      StringArray
                                       Other strings
    +----------------+
    |                |<-----------+  +----------------+
    |                |            |  |                |<-------------------+
    +----------------+            |  |                |                    |
    |    UNUSED      |            |  +----------------+                    |
    |                |            |                                        |
    +----------------+            |                                        |
    |                |<------+    |  +----------------+                    |
    |                |       |    |  |                |<-----------+       |
    +----------------+       |    |  |                |            |       |
    |    UNUSED      |       |    |  +----------------+            |       |
    |                |       |    |                                |       |
    +----------------+       |    |                                |       |
    |                |<--+   |    |                                |       |
    |                |   |   |    |                                |       |
    +----------------+   |   |    |                                |       |
    |                |   |   |    |                                |       |
    |                |   |   |    |     StringPointerArray         |       |
          ....           |   |    |                                |       |
                         |   |    |     +----------------+         |       |
                         |   |    +-----|                |         |       |
                         |   |          +----------------+         |       |
                         |   |          |                |---------+       |
                         |   |          +----------------+                 |
                         |   +----------|                |                 |
                         |              +----------------+                 |
                         |              |                |-----------------+
                         |              +----------------+
                         +--------------|                |
                                        +----------------+
                                        |                |
                                        +----------------+
                                        |                |
                                        +----------------+
                                        |                |
                                              ....


Arguments:

    AuditParameters - Receives a pointer to an audit
        parameters array in self-relative form.

Return Value:


--*/

{

    ULONG ParameterCount;
    USHORT i;
    PUNICODE_STRING StringPointerArray[SE_MAX_AUDIT_PARAM_STRINGS];
    UNICODE_STRING NewObjectTypeName;
    ULONG NewObjectTypeStringIndex = 0;
    BOOLEAN FreeWhenDone[SE_MAX_AUDIT_PARAM_STRINGS];
    UNICODE_STRING StringArray[SE_MAX_AUDIT_PARAM_STRINGS];
    USHORT StringIndexArray[SE_MAX_AUDIT_PARAM_STRINGS];
    USHORT StringIndex = 0;
    UNICODE_STRING DashString;
    BOOLEAN FreeDash;
    NTSTATUS Status;
    PUNICODE_STRING SourceModule;
    PSID UserSid;


    //
    // Initialization.
    //

    RtlInitUnicodeString( &NewObjectTypeName, NULL );

    Status= LsapAdtBuildDashString(
                &DashString,
                &FreeDash
                );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    ParameterCount = AuditParameters->ParameterCount;

    //
    // Parameter 0 will always be the user SID.  Convert the
    // offset to the SID into a pointer.
    //

    ASSERT( AuditParameters->Parameters[0].Type == SeAdtParmTypeSid );



    UserSid =      (PSID)AuditParameters->Parameters[0].Address;



    //
    // Parameter 1 will always be the Source Module (or Subsystem Name).
    // Unpack this now.
    //

    ASSERT( AuditParameters->Parameters[1].Type == SeAdtParmTypeString );



    SourceModule = (PUNICODE_STRING)AuditParameters->Parameters[1].Address;


    for (i=2; i<ParameterCount; i++) {
        StringIndexArray[i] = StringIndex;

        switch ( AuditParameters->Parameters[i].Type ) {
            case SeAdtParmTypeNone:
                {
                    StringPointerArray[StringIndex] = &DashString;

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeString:
                {
                    StringPointerArray[StringIndex] =
                        (PUNICODE_STRING)AuditParameters->Parameters[i].Address;

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeFileSpec:
                {
                    //
                    // Same as a string, except we must attempt to replace
                    // device information with a drive letter.
                    //

                    StringPointerArray[StringIndex] =
                        (PUNICODE_STRING)AuditParameters->Parameters[i].Address;


                    //
                    // This may not do anything, in which case just audit what
                    // we have.
                    //

                    //LsapAdtSubstituteDriveLetter( StringPointerArray[StringIndex] );

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeUlong:
                {
                    ULONG Data;

                    Data = (ULONG) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildUlongString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        //
                        // Couldn't allocate memory for that string,
                        // use the Dash string that we've already created.
                        //

                        StringPointerArray[StringIndex] = &DashString;
                        FreeWhenDone[StringIndex] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeHexUlong:
                {
                    ULONG Data;

                    Data = (ULONG) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildHexUlongString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        //
                        // Couldn't allocate memory for that string,
                        // use the Dash string that we've already created.
                        //

                        StringPointerArray[StringIndex] = &DashString;
                        FreeWhenDone[StringIndex] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeSid:
                {
                    PSID Sid;

                    Sid = (PSID)AuditParameters->Parameters[i].Address;

                    Status = LsapAdtBuildSidString(
                                 Sid,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];

                    } else {

                        //
                        // Couldn't allocate memory for that string,
                        // use the Dash string that we've already created.
                        //

                        StringPointerArray[StringIndex] = &DashString;
                        FreeWhenDone[StringIndex] = FALSE;
                    }

                    StringIndex++;


                    break;
                }
            case SeAdtParmTypeLogonId:
                {
                    PLUID LogonId;
                    ULONG j;

                    LogonId = (PLUID)(&AuditParameters->Parameters[i].Data[0]);

                    Status = LsapAdtBuildLogonIdStrings(
                                 LogonId,
                                 &StringArray [ StringIndex     ],
                                 &FreeWhenDone[ StringIndex     ],
                                 &StringArray [ StringIndex + 1 ],
                                 &FreeWhenDone[ StringIndex + 1 ],
                                 &StringArray [ StringIndex + 2 ],
                                 &FreeWhenDone[ StringIndex + 2 ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        for (j=0; j<3; j++) {

                            StringPointerArray[StringIndex] = &StringArray[StringIndex];
                            StringIndex++;
                        }

                        //
                        // Finished, break out to surrounding loop.
                        //

                        break;

                    } else {

                        //
                        // Do nothing, fall through to the NoLogonId case
                        //

                    }
                }
            case SeAdtParmTypeNoLogonId:
                {
                    ULONG j;
                    //
                    // Create three "-" strings.
                    //

                    for (j=0; j<3; j++) {

                        StringPointerArray[ StringIndex ] = &DashString;
                        FreeWhenDone[ StringIndex ] = FALSE;
                        StringIndex++;
                    }

                    break;
                }
            case SeAdtParmTypeAccessMask:
                {
                    PUNICODE_STRING ObjectTypeName;
                    ULONG ObjectTypeNameIndex;
                    ACCESS_MASK Accesses;

                    ObjectTypeNameIndex = (ULONG) AuditParameters->Parameters[i].Data[1];
                    ObjectTypeName = AuditParameters->Parameters[ObjectTypeNameIndex].Address;
                    Accesses= (ACCESS_MASK) AuditParameters->Parameters[i].Data[0];

                    //
                    // We can determine the index to the ObjectTypeName
                    // parameter since it was stored away in the Data[1]
                    // field of this parameter.
                    //

                    Status = LsapAdtBuildAccessesString(
                                 SourceModule,
                                 ObjectTypeName,
                                 Accesses,
                                 TRUE,
                                 &StringArray [ StringIndex ],
                                 &FreeWhenDone[ StringIndex ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[ StringIndex ] = &StringArray[ StringIndex ];

                    } else {

                        //
                        // That didn't work, use the Dash string instead.
                        //

                        StringPointerArray[ StringIndex ] = &DashString;
                        FreeWhenDone      [ StringIndex ] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypePrivs:
                {

                    PPRIVILEGE_SET Privileges = (PPRIVILEGE_SET)AuditParameters->Parameters[i].Address;

                    Status = LsapBuildPrivilegeAuditString(
                                 Privileges,
                                 &StringArray [ StringIndex ],
                                 &FreeWhenDone[ StringIndex ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[ StringIndex ] = &StringArray[ StringIndex ];

                    } else {

                        //
                        // That didn't work, use the Dash string instead.
                        //

                        StringPointerArray[ StringIndex ] = &DashString;
                        FreeWhenDone      [ StringIndex ] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeObjectTypes:
                {
                    PUNICODE_STRING ObjectTypeName;
                    ULONG ObjectTypeNameIndex;
                    PSE_ADT_OBJECT_TYPE ObjectTypeList;
                    ULONG ObjectTypeCount;
                    ULONG j;

                    ObjectTypeNameIndex = (ULONG) AuditParameters->Parameters[i].Data[1];
                    NewObjectTypeStringIndex = StringIndexArray[ObjectTypeNameIndex];
                    ObjectTypeName = AuditParameters->Parameters[ObjectTypeNameIndex].Address;
                    ObjectTypeList = AuditParameters->Parameters[i].Address;
                    ObjectTypeCount = AuditParameters->Parameters[i].Length / sizeof(SE_ADT_OBJECT_TYPE);

                    //
                    // Will Fill in 10 entries.
                    Status = LsapAdtBuildObjectTypeStrings(
                                 SourceModule,
                                 ObjectTypeName,
                                 ObjectTypeList,
                                 ObjectTypeCount,
                                 &StringArray [ StringIndex ],
                                 &FreeWhenDone[ StringIndex ],
                                 &NewObjectTypeName
                                 );

                    for (j=0; j<10; j++) {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                        StringIndex++;
                    }


                    //
                    //
                    // &StringArray [ StringIndexArray[ObjectTypeNameIndex]],
                    // &FreeWhenDone[ StringIndexArray[ObjectTypeNameIndex]],

                    //
                    // Finished, break out to surrounding loop.
                    //

                    break;
                }
            case SeAdtParmTypePtr:
                {
                    PVOID Data;

                    Data = (PVOID) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildPtrString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        //
                        // Couldn't allocate memory for that string,
                        // use the Dash string that we've already created.
                        //

                        StringPointerArray[StringIndex] = &DashString;
                        FreeWhenDone[StringIndex] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
        }
    }

    //
    // If the generic object type name has been converted to something
    //  specific to this audit,
    //  substitute it now.
    //

    if ( NewObjectTypeName.Length != 0 ) {

        //
        // Free the previous object type name.
        //
        if ( FreeWhenDone[NewObjectTypeStringIndex] ) {
            LsapFreeLsaHeap( StringPointerArray[NewObjectTypeStringIndex]->Buffer );
        }

        //
        // Save the new object type name.
        //

        FreeWhenDone[NewObjectTypeStringIndex] = TRUE;
        StringPointerArray[NewObjectTypeStringIndex] = &NewObjectTypeName;

    }

    //
    // Probably have to do this from somewhere else eventually, but for now
    // do it from here.
    //

    Status = kElfReportEventW (
                 NULL, //LsapAdtLogHandle,
                 AuditParameters->Type,
                 (USHORT)AuditParameters->CategoryId,
                 AuditParameters->AuditId,
                 UserSid,
                 StringIndex,
                 0,
                 StringPointerArray,
                 NULL,
                 0,
                 NULL,
                 NULL
                 );

    //
    // cleanup
    //

    for (i=0; i<StringIndex; i++) {

        if (FreeWhenDone[i]) {
            LsapFreeLsaHeap( StringPointerArray[i]->Buffer );
        }
    }

    //
    // If we are shutting down and we got an expected error back from the
    // eventlog, don't worry about it. This prevents bugchecking from an
    // audit failure while shutting down.
    //

    if ( ( (Status == RPC_NT_UNKNOWN_IF) || (Status == STATUS_UNSUCCESSFUL)) &&
         TRUE /*LsapState.SystemShutdownPending*/ ) {
        Status = STATUS_SUCCESS;
    }
    return( Status );
}

// ======================================================================
// adtbuild.c
// ======================================================================



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Local Macro definitions and local function prototypes             //
//                                                                    //
////////////////////////////////////////////////////////////////////////



#ifdef LSAP_ADT_UMTEST

//
// Define all external routines that we won't pick up in a user mode test
//

// NTSTATUS
// LsapGetLogonSessionAccountInfo(
//     IN PLUID Value,
//     OUT PUNICODE_STRING AccountName,
//     OUT PUNICODE_STRING AuthorityName
//     );



#endif



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Data types used within this module                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Variables global within this module                               //
//                                                                    //
////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services exported by this module.                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapAdtBuildUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed value.

    The resultant string will be formatted as a decimal value with not
    more than 10 digits.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;



    //
    // Maximum length is 10 wchar characters plus a null termination character.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 11 * sizeof(WCHAR); // 10 digits & null termination

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }




    Status = RtlIntegerToUnicodeString( Value, 10, ResultantString );
    ASSERT(NT_SUCCESS(Status));


    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildHexUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed value.

    The resultant string will be formatted as a hexidecimal value with not
    more than 10 digits.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;



    //
    // Maximum length is 10 wchar characters plus a null termination character.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 11 * sizeof(WCHAR); // 8 digits, a 0x, & null termination

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }


    ResultantString->Buffer[0] = L'0';
    ResultantString->Buffer[1] = L'x';
    ResultantString->Buffer += 2;


    Status = RtlIntegerToUnicodeString( Value, 16, ResultantString );
    ASSERT(NT_SUCCESS(Status));

    //
    // Subtract off the two
    //

    ResultantString->Buffer -= 2;
    ResultantString->Length += 2 * sizeof(WCHAR);

    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildPtrString(
    IN  PVOID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed pointer.

    The resultant string will be formatted as a hexidecimal value.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT NumChars;
    
    ResultantString->Length        = 0;
    //
    // Maximum length: 0x + 16 digit hex + null + 1 bonus == 20 chars
    //
    ResultantString->MaximumLength = 20 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
    
        Status = STATUS_NO_MEMORY;

    } else {
    
        NumChars = (USHORT) wsprintf( ResultantString->Buffer, L"0x%p", Value );

        ResultantString->Length = NumChars * sizeof(WCHAR);

        (*FreeWhenDone) = TRUE;
    }
    
    return Status;
}


NTSTATUS
LsapAdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        (0x00005678,0x12340000)

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;

    UNICODE_STRING          IntegerString;


    ULONG                   Buffer[(16*sizeof(WCHAR))/sizeof(ULONG)];


    IntegerString.Buffer = (PWCHAR)&Buffer[0];
    IntegerString.MaximumLength = 16*sizeof(WCHAR);


    //
    // Length (in WCHARS) is  3 for   (0x
    //                       10 for   1st hex number
    //                        3 for   ,0x
    //                       10 for   2nd hex number
    //                        1 for   )
    //                        1 for   null termination
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 28 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }



    Status = RtlAppendUnicodeToString( ResultantString, L"(0x" );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlIntegerToUnicodeString( Value->HighPart, 16, &IntegerString );
    ASSERT(NT_SUCCESS(Status));
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlAppendUnicodeToString( ResultantString, L",0x" );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlIntegerToUnicodeString( Value->LowPart, 16, &IntegerString );
    ASSERT(NT_SUCCESS(Status));
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAppendUnicodeToString( ResultantString, L")" );
    ASSERT(NT_SUCCESS(Status));


    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildSidString(
    IN PSID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status=STATUS_NO_MEMORY;
    LPWSTR   UniBuffer=NULL;
    USHORT   Len;
    USHORT   MaxLen;
    
    *FreeWhenDone = FALSE;
    //
    // Note: RtlConvertSidToUnicodeString also uses a hard-coded const 256
    //       to generate the string SID.
    //
    MaxLen    = (256+3) * sizeof(WCHAR);
    UniBuffer = LsapAllocateLsaHeap(MaxLen);

    if (UniBuffer)
    {
        ResultantString->Buffer        = UniBuffer+2;
        ResultantString->MaximumLength = MaxLen;
        Status = RtlConvertSidToUnicodeString( ResultantString, Value, FALSE );

        if (Status == STATUS_SUCCESS)
        {
            *FreeWhenDone = TRUE;
            UniBuffer[0] = L'%';
            UniBuffer[1] = L'{';
            Len = ResultantString->Length / sizeof(WCHAR);
            UniBuffer[Len+2] = L'}';
            UniBuffer[Len+3] = UNICODE_NULL;
            ResultantString->Buffer = UniBuffer;
            ResultantString->Length = (Len+3)*sizeof(WCHAR);
        }
        else
        {
            LsapFreeLsaHeap(UniBuffer);
        }
    }

    return(Status);
}



NTSTATUS
LsapAdtBuildDashString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function returns a string containing a dash ("-").
    This is commonly used to represent "No value" in audit records.


Arguments:


    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_SUCCESS only.

--*/

{
    RtlInitUnicodeString(ResultantString, L"-");

    (*FreeWhenDone) = FALSE;

    return STATUS_SUCCESS;
}




NTSTATUS
LsapAdtBuildFilePathString(
    IN PUNICODE_STRING Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed file
    path name.  If possible, the string will be generated using drive
    letters instead of object architecture namespace.


Arguments:

    Value - The original file path name.  This is expected (but does not
        have to be) a standard NT object architecture name-space pathname.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;



    //
    // For now, don't do the conversion.
    // Do this if we have time before we ship.
    //

    ResultantString->Length        = Value->Length;
    ResultantString->Buffer        = Value->Buffer;
    ResultantString->MaximumLength = Value->MaximumLength;


    (*FreeWhenDone) = FALSE;
    return(Status);
}




NTSTATUS
LsapAdtBuildLogonIdStrings(
    IN PLUID LogonId,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    )

/*++

Routine Description:

    This function builds a 3 unicode strings representing the specified
    logon ID.  These strings will contain the username, domain, and
    LUID string of the specified logon session (respectively).


Arguments:

    Value - The logon ID.

    ResultantString1 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone1 - If TRUE, indicates that the body of ResultantString1
        must be freed to process heap when no longer needed.

    ResultantString2 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone2 - If TRUE, indicates that the body of ResultantString2
        must be freed to process heap when no longer needed.

    ResultantString3 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone3 - If TRUE, indicates that the body of ResultantString3
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING DashString;
    BOOLEAN FreeDash;
    
    //
    // Try to convert the LUID first.
    //

    Status= LsapAdtBuildDashString(
                &DashString,
                &FreeDash
                );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = LsapAdtBuildLuidString( LogonId, ResultantString3, FreeWhenDone3 );

    if (NT_SUCCESS(Status)) {

//         *ResultantString1 = DashString;
//         *ResultantString2 = DashString;
        *FreeWhenDone1 = FALSE;
        *FreeWhenDone2 = FALSE;
        
        //
        // Now get the username and domain names
        //

        Status = LsapGetLogonSessionAccountInfo( LogonId,
                                                 ResultantString1,
                                                 ResultantString2
                                                 );

        if (NT_SUCCESS(Status)) {

//             (*FreeWhenDone1) = TRUE;
//             (*FreeWhenDone2) = TRUE;

        } else {

            //
            // The LUID may be the system LUID
            //

            LUID SystemLuid = SYSTEM_LUID;

            if ( RtlEqualLuid( LogonId, &SystemLuid )) {

                RtlInitUnicodeString(ResultantString1, L"SYSTEM");
                RtlInitUnicodeString(ResultantString2, L"SYSTEM");

                (*FreeWhenDone1) = FALSE;
                (*FreeWhenDone2) = FALSE;

                Status = STATUS_SUCCESS;

            } else {

                //
                // We have no clue what this is, just free what we've
                // allocated.
                //

                if ((FreeWhenDone3)) {
                    LsapFreeLsaHeap( ResultantString3->Buffer );
                }
            }
        }
    }

    return(Status);

}






////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services private to this module.                                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////





//
// Define this routine only for user mode test
//

NTSTATUS
LsapGetLogonSessionAccountInfo(
    IN PLUID Value,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    )

{
    NTSTATUS        Status = STATUS_UNSUCCESSFUL;
    HRESULT hr;
    SECURITY_USER_DATA* pUserData;
    
    hr = GetSecurityUserInfo( Value, 0, &pUserData  );
    if (SUCCEEDED(hr))
    {
        Status = STATUS_SUCCESS;
        *AccountName   = pUserData->UserName;
        *AuthorityName = pUserData->LogonDomainName;
    }

    
    return(Status);
}


// ======================================================================
// from adtobjs.c
// ======================================================================

#define LSAP_ADT_OBJECT_TYPE_STRINGS 10
#define LSAP_ADT_ACCESS_NAME_FORMATTING L"\r\n\t\t\t"
#define LSAP_ADT_ACCESS_NAME_FORMATTING_TAB L"\t"
#define LSAP_ADT_ACCESS_NAME_FORMATTING_NL L"\r\n"


UNICODE_STRING          LsapAdtEventIdStringDelete,
                        LsapAdtEventIdStringReadControl,
                        LsapAdtEventIdStringWriteDac,
                        LsapAdtEventIdStringWriteOwner,
                        LsapAdtEventIdStringSynchronize,
                        LsapAdtEventIdStringAccessSysSec,
                        LsapAdtEventIdStringMaxAllowed,
                        LsapAdtEventIdStringSpecific[16];


#define LsapAdtSourceModuleLock()    0
#define LsapAdtSourceModuleUnlock()  0




//
// Each event source is represented by a source module descriptor.
// These are kept on a linked list (LsapAdtSourceModules).
//

typedef struct _LSAP_ADT_OBJECT {

    //
    // Pointer to next source module descriptor
    // This is assumed to be the first field in the structure.
    //

    struct _LSAP_ADT_OBJECT *Next;

    //
    // Name of object
    //

    UNICODE_STRING Name;

    //
    // Base offset of specific access types
    //

    ULONG BaseOffset;

} LSAP_ADT_OBJECT, *PLSAP_ADT_OBJECT;




//
// Each event source is represented by a source module descriptor.
// These are kept on a linked list (LsapAdtSourceModules).
//

typedef struct _LSAP_ADT_SOURCE {

    //
    // Pointer to next source module descriptor
    // This is assumed to be the first field in the structure.
    //

    struct _LSAP_ADT_SOURCE *Next;

    //
    // Name of source module
    //

    UNICODE_STRING Name;

    //
    // list of objects
    //

    PLSAP_ADT_OBJECT Objects;

} LSAP_ADT_SOURCE, *PLSAP_ADT_SOURCE;


PLSAP_ADT_SOURCE LsapAdtSourceModules;



NTSTATUS
LsapDsGuidToString(
    IN GUID *ObjectType,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine converts a GUID to a string.  The GUID is one of the following:

        Class Guid indicating the class of an object.
        Property Set Guid identifying a property set.
        Property Guid identifying a property.

    In each case, the routine returns a text string naming the object/property
    set or property.

    If the passed in GUID is cannot be found in the schema,
    the GUID will simply be converted to a text string.


Arguments:

    ObjectType - Specifies the GUID to translate.

    UnicodeString - Returns the text string.

Return Values:

    STATUS_NO_MEMORY - Not enough memory to allocate string.


--*/

{
    NTSTATUS Status;
    RPC_STATUS RpcStatus;
    LPWSTR GuidString = NULL;
    ULONG GuidStringSize;
    ULONG GuidStringLen;
    LPWSTR LocalGuidString;

    //
    // Convert the GUID to text
    //

    RpcStatus = UuidToStringW( ObjectType,
                               &GuidString );

    if ( RpcStatus != RPC_S_OK ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    GuidStringLen = wcslen( GuidString );
    GuidStringSize = (GuidStringLen + 4) * sizeof(WCHAR);

    LocalGuidString = LsapAllocateLsaHeap( GuidStringSize );

    if ( LocalGuidString == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    LocalGuidString[0] = L'%';
    LocalGuidString[1] = L'{';
    RtlCopyMemory( &LocalGuidString[2], GuidString, GuidStringLen*sizeof(WCHAR) );
    LocalGuidString[GuidStringLen+2] = L'}';
    LocalGuidString[GuidStringLen+3] = L'\0';
    RtlInitUnicodeString( UnicodeString, LocalGuidString );

    Status = STATUS_SUCCESS;

Cleanup:
    if ( GuidString != NULL ) {
        RpcStringFreeW( &GuidString );
    }
    return Status;
}


NTSTATUS
LsapAdtAppendString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    IN PUNICODE_STRING StringToAppend,
    IN PULONG StringIndex
    )

/*++

Routine Description:

    This function appends a string to the next available of the LSAP_ADT_OBJECT_TYPE_STRINGS unicode
    output strings.


Arguments:

    ResultantString - Points to an array of LSAP_ADT_OBJECT_TYPE_STRINGS unicode string headers.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

    StringToAppend - String to be appended to ResultantString.

    StringIndex - Index to the current ResultantString to be used.
        Passes in an index to the resultant string to use.
        Passes out the index to the resultant string being used.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING SourceString;
    ULONG Index;
// Must be multiple of sizeof(WCHAR)
#define ADT_MAX_STRING 0xFFFE

    //
    // Initialization.
    //

    SourceString = *StringToAppend;
    Index = *StringIndex;

    //
    // If all of the strings are already full,
    //  early out.
    //

    if ( Index >= LSAP_ADT_OBJECT_TYPE_STRINGS ) {
        return STATUS_SUCCESS;
    }

    //
    // Loop until the source string is completely appended.
    //

    while ( SourceString.Length ) {

        //
        // If the destination string has room,
        //  append to it.
        //

        if ( FreeWhenDone[Index] && ResultantString[Index].Length != ADT_MAX_STRING ){
            UNICODE_STRING SubString;
            USHORT RoomLeft;

            //
            // If the Source String is a replacement string,
            //  make sure we don't split it across a ResultantString boundary
            //

            RoomLeft = ResultantString[Index].MaximumLength -
                       ResultantString[Index].Length;

            if ( SourceString.Buffer[0] != L'%' ||
                 RoomLeft >= SourceString.Length ) {

                //
                // Compute the substring that fits.
                //

                SubString.Length = min( RoomLeft, SourceString.Length );
                SubString.Buffer = SourceString.Buffer;

                SourceString.Length -= SubString.Length;
                SourceString.Buffer = (LPWSTR)(((LPBYTE)SourceString.Buffer) + SubString.Length);


                //
                // Append the substring onto the destination.
                //

                Status = RtlAppendUnicodeStringToString(
                                    &ResultantString[Index],
                                    &SubString );

                ASSERT(NT_SUCCESS(Status));

            }



        }

        //
        // If there's more to copy,
        //  grow the buffer.
        //

        if ( SourceString.Length ) {
            ULONG NewSize;
            LPWSTR NewBuffer;

            //
            // If the current buffer is full,
            //  move to the next buffer.
            //

            if ( ResultantString[Index].Length == ADT_MAX_STRING ) {

                //
                // If ALL of the buffers are full,
                //  silently return to the caller.
                //
                Index ++;

                if ( Index >= LSAP_ADT_OBJECT_TYPE_STRINGS ) {
                    *StringIndex = Index;
                    return STATUS_SUCCESS;
                }
            }

            //
            // Allocate a buffer suitable for both the old string and the new one.
            //
            // Allocate the buffer at least large enough for the new string.
            // Always grow the buffer in 1Kb chunks.
            // Don't allocate larger than the maximum allowed size.
            //

            NewSize = max( ResultantString[Index].MaximumLength + 1024,
                           SourceString.Length );
            NewSize = min( NewSize, ADT_MAX_STRING );

            NewBuffer = LsapAllocateLsaHeap( NewSize );

            if ( NewBuffer == NULL ) {
                *StringIndex = Index;
                return STATUS_NO_MEMORY;
            }

            //
            // Copy the old buffer into the new buffer.
            //

            if ( ResultantString[Index].Buffer != NULL ) {
                RtlCopyMemory( NewBuffer,
                               ResultantString[Index].Buffer,
                               ResultantString[Index].Length );

                if ( FreeWhenDone[Index] ) {
                    LsapFreeLsaHeap( ResultantString[Index].Buffer );
                }
            }

            ResultantString[Index].Buffer = NewBuffer;
            ResultantString[Index].MaximumLength = (USHORT) NewSize;
            FreeWhenDone[Index] = TRUE;

        }
    }

    *StringIndex = Index;
    return STATUS_SUCCESS;

}


NTSTATUS
LsapAdtAppendZString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    IN LPWSTR StringToAppend,
    IN PULONG StringIndex
    )

/*++

Routine Description:

    Same as LsapAdpAppendString but takes a zero terminated string.

Arguments:

    Same as LsapAdpAppendString but takes a zero terminated string.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, StringToAppend );

    return LsapAdtAppendString( ResultantString,
                                FreeWhenDone,
                                &UnicodeString,
                                StringIndex );
}

ULONG
__cdecl
CompareObjectTypes(
    const void * Param1,
    const void * Param2
    )

/*++

Routine Description:

    Qsort comparison routine for sorting an object type array by access mask.

--*/
{
    const SE_ADT_OBJECT_TYPE *ObjectType1 = Param1;
    const SE_ADT_OBJECT_TYPE *ObjectType2 = Param2;

    return ObjectType1->AccessMask - ObjectType2->AccessMask;
}



NTSTATUS
LsapAdtBuildObjectTypeStrings(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN PSE_ADT_OBJECT_TYPE ObjectTypeList,
    IN ULONG ObjectTypeCount,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    OUT PUNICODE_STRING NewObjectTypeName
    )

/*++

Routine Description:

    This function builds a LSAP_ADT_OBJECT_TYPE_STRINGS unicode strings containing parameter
    file replacement parameters (e.g. %%1043) and Object GUIDs separated by carriage
    return and tab characters suitable for display via the event viewer.


    The buffers returned by this routine must be deallocated when no
    longer needed if FreeWhenDone is true.


Arguments:

    SourceModule - The module (ala event viewer modules) defining the
        object type.

    ObjectTypeName - The type of object to which the access mask applies.

    ObjectTypeList - List of objects being granted access.

    ObjectTypeCount - Number of objects in ObjectTypeList.

    ResultantString - Points to an array of LSAP_ADT_OBJECT_TYPE_STRINGS unicode string headers.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.


    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

    NewObjectTypeName - Returns a new name for the object type if one is
        available.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING LocalString;
    LPWSTR GuidString;
    UNICODE_STRING DsSourceName;
    UNICODE_STRING DsObjectTypeName;
    BOOLEAN LocalFreeWhenDone;
    ULONG ResultantStringIndex = 0;
    ULONG i;
    ACCESS_MASK PreviousAccessMask;
    ULONG Index;
    BOOLEAN IsDs;
    USHORT IndentLevel;

    static LPWSTR Tabs[] =
    {
        L"\t",
        L"\t\t",
        L"\t\t\t",
        L"\t\t\t\t"
    };
    USHORT cTabs = sizeof(Tabs) / sizeof(LPWSTR);

    //
    // Initialize all LSAP_ADT_OBJECT_TYPE_STRINGS buffers to empty strings
    //

    for ( i=0; i<LSAP_ADT_OBJECT_TYPE_STRINGS; i++ ) {
        RtlInitUnicodeString( &ResultantString[i], L"" );
        FreeWhenDone[i] = FALSE;
    }

    //
    // If there are no objects,
    //  we're done.
    //

    if ( ObjectTypeCount == 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // Determine if this entry is for the DS.
    //

    RtlInitUnicodeString( &DsSourceName, ACCESS_DS_SOURCE_W );
    RtlInitUnicodeString( &DsObjectTypeName, ACCESS_DS_OBJECT_TYPE_NAME_W );

    IsDs = RtlEqualUnicodeString( SourceModule, &DsSourceName, TRUE) &&
           RtlEqualUnicodeString( ObjectTypeName, &DsObjectTypeName, TRUE);


    //
    // Group the objects with like access masks together.
    //  (Simply sort them).
    //

    qsort( ObjectTypeList,
           ObjectTypeCount,
           sizeof(SE_ADT_OBJECT_TYPE),
           CompareObjectTypes );

    //
    // Loop through the objects outputting a line for each one.
    //

    PreviousAccessMask = ObjectTypeList[0].AccessMask -1;
    for ( Index=0; Index<ObjectTypeCount;